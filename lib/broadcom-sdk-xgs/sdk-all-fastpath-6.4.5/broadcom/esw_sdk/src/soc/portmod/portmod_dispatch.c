/*
 *         
 * $Id:$
 * 
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *         
 *     
 * DO NOT EDIT THIS FILE!
 *
 */

#include <soc/types.h>
#include <soc/error.h>
#include <soc/portmod/portmod_internal.h>
#include <soc/portmod/portmod.h>
#include <soc/portmod/portmod_dispatch.h>


        
#ifdef _ERR_MSG_MODULE_NAME 
#error "_ERR_MSG_MODULE_NAME redefined" 
#endif
#define _ERR_MSG_MODULE_NAME BSL_LS_SOC_PORT

#ifdef PORTMOD_PM4X25_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x25_driver;
#endif
#ifdef PORTMOD_PM4X10_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x10_driver;
#endif
#ifdef PORTMOD_PM12X10_SUPPORT
extern __portmod__dispatch__t__ portmod_pm12x10_driver;
#endif
#ifdef PORTMOD_PM4x10Q_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x10Q_driver;
#endif
#ifdef PORTMOD_PM_OS_ILKN_SUPPORT
extern __portmod__dispatch__t__ portmod_pmOsILKN_driver;
#endif
#ifdef PORTMOD_DNX_FABRIC_SUPPORT
extern __portmod__dispatch__t__ portmod_dnx_fabric_driver;
#endif
#ifdef PORTMOD_PM4X25TD_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x25td_driver;
#endif

__portmod__dispatch__t__* __portmod__dispatch__[portmodDispatchTypeCount] = {
#ifdef PORTMOD_PM4X25_SUPPORT
    &portmod_pm4x25_driver,
#endif
#ifdef PORTMOD_PM4X10_SUPPORT
    &portmod_pm4x10_driver,
#endif
#ifdef PORTMOD_PM12X10_SUPPORT
    &portmod_pm12x10_driver,
#endif
#ifdef PORTMOD_PM4x10Q_SUPPORT
    &portmod_pm4x10Q_driver,
#endif
#ifdef PORTMOD_PM_OS_ILKN_SUPPORT
    &portmod_pmOsILKN_driver,
#endif
#ifdef PORTMOD_DNX_FABRIC_SUPPORT
    &portmod_dnx_fabric_driver,
#endif
#ifdef PORTMOD_PM4X25TD_SUPPORT
    &portmod_pm4x25td_driver,
#endif

};

int portmod_dispatch_type_t_validate(int unit, portmod_dispatch_type_t portmod_dispatch_type)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_dispatch_type >= portmodDispatchTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_default_user_access_t_validate(int unit, const portmod_default_user_access_t* portmod_default_user_access)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_default_user_access == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_default_user_access_t_init(int unit, portmod_default_user_access_t* portmod_default_user_access)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_default_user_access == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_default_user_access NULL parameter"));
    }
    sal_memset(portmod_default_user_access, 0, sizeof(portmod_default_user_access_t));
    portmod_default_user_access->unit = -1;
    portmod_default_user_access->port = -1;
    portmod_default_user_access->is_legacy_phy_present = 0;
    portmod_default_user_access->cmd_for_phy = 0;
    portmod_default_user_access->blk_id = -1;
    portmod_default_user_access->mutex = NULL;
    portmod_default_user_access->flags = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_fifo_status_t_validate(int unit, const portmod_fifo_status_t* portmod_fifo_status)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_fifo_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_fifo_status_t_init(int unit, portmod_fifo_status_t* portmod_fifo_status)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_fifo_status == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_fifo_status NULL parameter"));
    }
    sal_memset(portmod_fifo_status, 0, sizeof(portmod_fifo_status_t));
    portmod_fifo_status->timestamps_in_fifo = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_config_t_validate(int unit, const portmod_pfc_config_t* portmod_pfc_config)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pfc_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_config_t_init(int unit, portmod_pfc_config_t* portmod_pfc_config)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pfc_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pfc_config NULL parameter"));
    }
    sal_memset(portmod_pfc_config, 0, sizeof(portmod_pfc_config_t));
    portmod_pfc_config->type = 0;
    portmod_pfc_config->opcode = 0;
    portmod_pfc_config->classes = 0;
    portmod_pfc_config->da_oui = 0;
    portmod_pfc_config->da_nonoui = 0;
    portmod_pfc_config->rxpass = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_eee_t_validate(int unit, const portmod_eee_t* portmod_eee)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_eee == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_eee_t_init(int unit, portmod_eee_t* portmod_eee)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_eee == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_eee NULL parameter"));
    }
    sal_memset(portmod_eee, 0, sizeof(portmod_eee_t));
    portmod_eee->enable = 0;
    portmod_eee->tx_idle_time = 0;
    portmod_eee->tx_wake_time = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_vlan_tag_t_validate(int unit, const portmod_vlan_tag_t* portmod_vlan_tag)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_vlan_tag == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_vlan_tag_t_init(int unit, portmod_vlan_tag_t* portmod_vlan_tag)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_vlan_tag == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_vlan_tag NULL parameter"));
    }
    sal_memset(portmod_vlan_tag, 0, sizeof(portmod_vlan_tag_t));
    portmod_vlan_tag->inner_vlan_tag = 0;
    portmod_vlan_tag->outer_vlan_tag = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_rx_control_t_validate(int unit, const portmod_rx_control_t* portmod_rx_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_rx_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_rx_control_t_init(int unit, portmod_rx_control_t* portmod_rx_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_rx_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_rx_control NULL parameter"));
    }
    sal_memset(portmod_rx_control, 0, sizeof(portmod_rx_control_t));
    portmod_rx_control->pass_control_frames = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_multi_get_t_validate(int unit, const portmod_multi_get_t* portmod_multi_get)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_multi_get == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_multi_get_t_init(int unit, portmod_multi_get_t* portmod_multi_get)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_multi_get == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_multi_get NULL parameter"));
    }
    sal_memset(portmod_multi_get, 0, sizeof(portmod_multi_get_t));
    portmod_multi_get->flags = 0;
    portmod_multi_get->dev_addr = 0;
    portmod_multi_get->offset = 0;
    portmod_multi_get->max_size = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_loopback_mode_t_validate(int unit, portmod_loopback_mode_t portmod_loopback_mode)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_loopback_mode >= portmodLoopbackCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_core_port_mode_t_validate(int unit, portmod_core_port_mode_t portmod_core_port_mode)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_core_port_mode >= portmodPortModeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_prbs_mode_t_validate(int unit, portmod_prbs_mode_t portmod_prbs_mode)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_prbs_mode >= portmodPrbsModeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ext_to_int_phy_ctrlcode_t_validate(int unit, portmod_ext_to_int_phy_ctrlcode_t portmod_ext_to_int_phy_ctrlcode)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_ext_to_int_phy_ctrlcode >= portmodExtToInt_CtrlCode_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_portphy_ability_t_validate(int unit, const portmod_portphy_ability_t* portmod_portphy_ability)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_portphy_ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_portphy_ability_t_init(int unit, portmod_portphy_ability_t* portmod_portphy_ability)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_portphy_ability == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_portphy_ability NULL parameter"));
    }
    sal_memset(portmod_portphy_ability, 0, sizeof(portmod_portphy_ability_t));
    portmod_portphy_ability->cur_mode = 0;
    portmod_portphy_ability->speed_half_duplex = 0;
    portmod_portphy_ability->speed_full_duplex = 0;
    portmod_portphy_ability->pause = 0;
    portmod_portphy_ability->interface = 0;
    portmod_portphy_ability->medium = 0;
    portmod_portphy_ability->loopback = 0;
    portmod_portphy_ability->flags = 0;
    portmod_portphy_ability->eee = 0;
    portmod_portphy_ability->fcmap = 0;
    portmod_portphy_ability->encap = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pdata_t_validate(int unit, const portmod_pdata_t* portmod_pdata)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pdata == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pdata_t_init(int unit, portmod_pdata_t* portmod_pdata)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pdata == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pdata NULL parameter"));
    }
    sal_memset(portmod_pdata, 0, sizeof(portmod_pdata_t));
    portmod_pdata->data = 0;
    portmod_pdata->enable = 0;
    portmod_pdata->pif = 0;
    portmod_pdata->ability = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_mode_info_t_validate(int unit, const portmod_port_mode_info_t* portmod_port_mode_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_mode_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_core_port_mode_t_validate(unit, portmod_port_mode_info->cur_mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cur_mode validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_mode_info_t_init(int unit, portmod_port_mode_info_t* portmod_port_mode_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_mode_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_mode_info NULL parameter"));
    }
    sal_memset(portmod_port_mode_info, 0, sizeof(portmod_port_mode_info_t));
    portmod_port_mode_info->cur_mode = 0;
    portmod_port_mode_info->lanes = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_diag_info_t_validate(int unit, const portmod_port_diag_info_t* portmod_port_diag_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_diag_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_port_mode_info_t_validate(unit, &portmod_port_diag_info->core_mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_mode validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_diag_info_t_init(int unit, portmod_port_diag_info_t* portmod_port_diag_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_diag_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_diag_info NULL parameter"));
    }
    sal_memset(portmod_port_diag_info, 0, sizeof(portmod_port_diag_info_t));
    portmod_port_diag_info->interface = phymodInterfaceCount;
    SOC_PBMP_CLEAR(portmod_port_diag_info->phys);
    portmod_port_diag_info->sub_phy = 0;
    portmod_port_diag_info->medium = 0;
    sal_memset(&(portmod_port_diag_info->core_mode), 0, sizeof(portmod_port_mode_info_t));
    sal_memset(&(portmod_port_diag_info->polarity), 0, sizeof(phymod_polarity_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_core_info_t_validate(int unit, const portmod_pm_core_info_t* portmod_pm_core_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_core_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_core_info_t_init(int unit, portmod_pm_core_info_t* portmod_pm_core_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_core_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_core_info NULL parameter"));
    }
    sal_memset(portmod_pm_core_info, 0, sizeof(portmod_pm_core_info_t));
    portmod_pm_core_info->ref_clk = -1;
    sal_memset(&(portmod_pm_core_info->lane_map), 0, sizeof(phymod_lane_map_t));
    portmod_pm_core_info->nof_phys = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_diag_info_t_validate(int unit, const portmod_pm_diag_info_t* portmod_pm_diag_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_diag_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_diag_info->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }

    if(SOC_E_NONE != portmod_pm_core_info_t_validate(unit, &portmod_pm_diag_info->core_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_diag_info_t_init(int unit, portmod_pm_diag_info_t* portmod_pm_diag_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_diag_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_diag_info NULL parameter"));
    }
    sal_memset(portmod_pm_diag_info, 0, sizeof(portmod_pm_diag_info_t));
    portmod_pm_diag_info->type = portmodDispatchTypeCount;
    sal_memset(&(portmod_pm_diag_info->core_info), 0, sizeof(portmod_pm_core_info_t));
    SOC_PBMP_CLEAR(portmod_pm_diag_info->phys);
    SOC_PBMP_CLEAR(portmod_pm_diag_info->ports);
    portmod_pm_diag_info->serdes_id0 = -1;
    portmod_pm_diag_info->phy_id0 = -1;
    portmod_pm_diag_info->phy_id1 = -1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_init_config_t_validate(int unit, const portmod_port_init_config_t* portmod_port_init_config)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_init_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_init_config_t_init(int unit, portmod_port_init_config_t* portmod_port_init_config)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_init_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_init_config NULL parameter"));
    }
    sal_memset(portmod_port_init_config, 0, sizeof(portmod_port_init_config_t));
    portmod_port_init_config->cx4_10g = 0;
    portmod_port_init_config->pdetect1000x = 0;
    portmod_port_init_config->an_mode = phymod_AN_MODE_NONE;
    portmod_port_init_config->an_cl72 = 0;
    portmod_port_init_config->fs_cl72 = 0;
    portmod_port_init_config->an_fec = 0;
    portmod_port_init_config->sgmii_mstr = 0;
    portmod_port_init_config->serdes_driver_current = 0;
    portmod_port_init_config->serdes_1000x_at_6250_vco = 0;
    portmod_port_init_config->pll_divider_req = 0;
    portmod_port_init_config->rxaui_mode = 0;
    portmod_port_init_config->port_fallback_lane = 0;
    portmod_port_init_config->tx_params_user_flag = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_interface_config_t_validate(int unit, const portmod_port_interface_config_t* portmod_port_interface_config)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_interface_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_interface_config_t_init(int unit, portmod_port_interface_config_t* portmod_port_interface_config)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_interface_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_interface_config NULL parameter"));
    }
    sal_memset(portmod_port_interface_config, 0, sizeof(portmod_port_interface_config_t));
    portmod_port_interface_config->interface = SOC_PORT_IF_NULL;
    portmod_port_interface_config->interface_modes = 0;
    portmod_port_interface_config->flags = 0;
    portmod_port_interface_config->port_refclk_int = -1;
    portmod_port_interface_config->port_num_lanes = 0;
    portmod_port_interface_config->speed = 0;
    portmod_port_interface_config->max_speed = 0;
    portmod_port_interface_config->encap_mode = 0;
    portmod_port_interface_config->pll_divider_req = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_add_info_t_validate(int unit, const portmod_port_add_info_t* portmod_port_add_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_add_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, &portmod_port_add_info->interface_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface_config validation failed"));
    }

    if(SOC_E_NONE != portmod_port_init_config_t_validate(unit, &portmod_port_add_info->init_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("init_config validation failed"));
    }

    switch(portmod_port_add_info->sub_phy) {
        case 0:
        case 1:
        case 2:
        case 3:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("sub_phy not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_add_info_t_init(int unit, portmod_port_add_info_t* portmod_port_add_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_add_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_add_info NULL parameter"));
    }
    sal_memset(portmod_port_add_info, 0, sizeof(portmod_port_add_info_t));
    if(SOC_E_NONE != portmod_port_interface_config_t_init(unit, &portmod_port_add_info->interface_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface_config initialization failed"));
    }

    if(SOC_E_NONE != portmod_port_init_config_t_init(unit, &portmod_port_add_info->init_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("init_config initialization failed"));
    }

    SOC_PBMP_CLEAR(portmod_port_add_info->phys);
    portmod_port_add_info->sub_phy = 0;
    portmod_port_add_info->autoneg_en = 0;
    portmod_port_add_info->link_training_en = 0;
    portmod_port_add_info->flags = PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY;
    portmod_port_add_info->ilkn_core_id = 0;
    portmod_port_add_info->rx_retransmit = 0;
    portmod_port_add_info->tx_retransmit = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_dnx_fabric_create_info_t_validate(int unit, const portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_dnx_fabric_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_dnx_fabric_create_info_t_init(int unit, portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_dnx_fabric_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_dnx_fabric_create_info NULL parameter"));
    }
    sal_memset(portmod_dnx_fabric_create_info, 0, sizeof(portmod_dnx_fabric_create_info_t));
    portmod_dnx_fabric_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_dnx_fabric_create_info->access);
    phymod_lane_map_t_init(&portmod_dnx_fabric_create_info->lane_map);
    portmod_dnx_fabric_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_dnx_fabric_create_info->external_fw_loader = NULL;
    portmod_dnx_fabric_create_info->fmac_schan_id = -1;
    portmod_dnx_fabric_create_info->fsrd_schan_id = -1;
    portmod_dnx_fabric_create_info->fsrd_internal_quad = -1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_call_back_action_type_t_validate(int unit, portmod_call_back_action_type_t portmod_call_back_action_type)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_call_back_action_type >= portmodCallBackActionTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x25_create_info_t_validate(int unit, const portmod_pm4x25_create_info_t* portmod_pm4x25_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x25_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_pm4x25_create_info->in_pm_12x10) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("in_pm_12x10 not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x25_create_info_t_init(int unit, portmod_pm4x25_create_info_t* portmod_pm4x25_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x25_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x25_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x25_create_info, 0, sizeof(portmod_pm4x25_create_info_t));
    portmod_pm4x25_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm4x25_create_info->access);
    phymod_lane_map_t_init(&portmod_pm4x25_create_info->lane_map);
    portmod_pm4x25_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm4x25_create_info->external_fw_loader = NULL;
    portmod_pm4x25_create_info->in_pm_12x10 = 0;
    portmod_pm4x25_create_info->core_num = 0;
    portmod_pm4x25_create_info->core_num_int = 0;
    portmod_pm4x25_create_info->portmod_mac_soft_reset = NULL;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10_create_info_t_validate(int unit, const portmod_pm4x10_create_info_t* portmod_pm4x10_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x10_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_pm4x10_create_info->in_pm_12x10) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("in_pm_12x10 not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10_create_info_t_init(int unit, portmod_pm4x10_create_info_t* portmod_pm4x10_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x10_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x10_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x10_create_info, 0, sizeof(portmod_pm4x10_create_info_t));
    portmod_pm4x10_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm4x10_create_info->access);
    phymod_lane_map_t_init(&portmod_pm4x10_create_info->lane_map);
    portmod_pm4x10_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm4x10_create_info->external_fw_loader = NULL;
    portmod_pm4x10_create_info->in_pm_12x10 = 0;
    portmod_pm4x10_create_info->portmod_phy_external_reset = NULL;
    portmod_pm4x10_create_info->portmod_mac_soft_reset = NULL;
    portmod_pm4x10_create_info->core_num = 0;
    portmod_pm4x10_create_info->core_num_int = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm12x10_create_info_t_validate(int unit, const portmod_pm12x10_create_info_t* portmod_pm12x10_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm12x10_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm4x25_create_info_t_validate(unit, &portmod_pm12x10_create_info->pm4x25_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x25_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm12x10_create_info_t_init(int unit, portmod_pm12x10_create_info_t* portmod_pm12x10_create_info)
{
    int _array_iter;

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm12x10_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm12x10_create_info NULL parameter"));
    }
    sal_memset(portmod_pm12x10_create_info, 0, sizeof(portmod_pm12x10_create_info_t));
    for(_array_iter = 0 ; _array_iter < 3 ; _array_iter++){
        if(SOC_E_NONE != portmod_pm4x10_create_info_t_init(unit, &portmod_pm12x10_create_info->pm4x10_infos[_array_iter])) {
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_infos initialization failed"));
        }
    }

    if(SOC_E_NONE != portmod_pm4x25_create_info_t_init(unit, &portmod_pm12x10_create_info->pm4x25_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x25_info initialization failed"));
    }

    portmod_pm12x10_create_info->blk_id = -1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_create_info_t_validate(int unit, const portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x10q_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm4x10_create_info_t_validate(unit, &portmod_pm4x10q_create_info->pm4x10_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_create_info_t_init(int unit, portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x10q_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x10q_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x10q_create_info, 0, sizeof(portmod_pm4x10q_create_info_t));
    if(SOC_E_NONE != portmod_pm4x10_create_info_t_init(unit, &portmod_pm4x10q_create_info->pm4x10_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_info initialization failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_identifier_t_validate(int unit, const portmod_pm_identifier_t* portmod_pm_identifier)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_identifier == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_identifier->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_identifier_t_init(int unit, portmod_pm_identifier_t* portmod_pm_identifier)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_identifier == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_identifier NULL parameter"));
    }
    sal_memset(portmod_pm_identifier, 0, sizeof(portmod_pm_identifier_t));
    portmod_pm_identifier->type = portmodDispatchTypeCount;
    portmod_pm_identifier->phy = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ilkn_os_create_info_t_validate(int unit, const portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_ilkn_os_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm_identifier_t_validate(unit, portmod_ilkn_os_create_info->controlled_pms)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("controlled_pms validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ilkn_os_create_info_t_init(int unit, portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_ilkn_os_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_ilkn_os_create_info NULL parameter"));
    }
    sal_memset(portmod_ilkn_os_create_info, 0, sizeof(portmod_ilkn_os_create_info_t));
    portmod_ilkn_os_create_info->nof_aggregated_pms = phymodRefClkCount;
    portmod_ilkn_os_create_info->controlled_pms = NULL;
    portmod_ilkn_os_create_info->wm_high = 0;
    portmod_ilkn_os_create_info->wm_low = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_remote_fault_control_t_validate(int unit, const portmod_remote_fault_control_t* portmod_remote_fault_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_remote_fault_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_remote_fault_control_t_init(int unit, portmod_remote_fault_control_t* portmod_remote_fault_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_remote_fault_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_remote_fault_control NULL parameter"));
    }
    sal_memset(portmod_remote_fault_control, 0, sizeof(portmod_remote_fault_control_t));
    portmod_remote_fault_control->enable = 0;
    portmod_remote_fault_control->drop_tx_on_fault = 1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_local_fault_control_t_validate(int unit, const portmod_local_fault_control_t* portmod_local_fault_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_local_fault_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_local_fault_control_t_init(int unit, portmod_local_fault_control_t* portmod_local_fault_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_local_fault_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_local_fault_control NULL parameter"));
    }
    sal_memset(portmod_local_fault_control, 0, sizeof(portmod_local_fault_control_t));
    portmod_local_fault_control->enable = 0;
    portmod_local_fault_control->drop_tx_on_fault = 1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_llfc_control_t_validate(int unit, const portmod_llfc_control_t* portmod_llfc_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_llfc_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_llfc_control_t_init(int unit, portmod_llfc_control_t* portmod_llfc_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_llfc_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_llfc_control NULL parameter"));
    }
    sal_memset(portmod_llfc_control, 0, sizeof(portmod_llfc_control_t));
    portmod_llfc_control->rx_enable = 1;
    portmod_llfc_control->tx_enable = 1;
    portmod_llfc_control->crc_ignore = 0;
    portmod_llfc_control->in_ipg_only = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_control_t_validate(int unit, const portmod_pfc_control_t* portmod_pfc_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pfc_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_control_t_init(int unit, portmod_pfc_control_t* portmod_pfc_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pfc_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pfc_control NULL parameter"));
    }
    sal_memset(portmod_pfc_control, 0, sizeof(portmod_pfc_control_t));
    portmod_pfc_control->rx_enable = 0;
    portmod_pfc_control->tx_enable = 0;
    portmod_pfc_control->stats_en = 1;
    portmod_pfc_control->force_xon = 0;
    portmod_pfc_control->refresh_timer = -1;
    portmod_pfc_control->xoff_timer = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pause_control_t_validate(int unit, const portmod_pause_control_t* portmod_pause_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pause_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pause_control_t_init(int unit, portmod_pause_control_t* portmod_pause_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pause_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pause_control NULL parameter"));
    }
    sal_memset(portmod_pause_control, 0, sizeof(portmod_pause_control_t));
    portmod_pause_control->rx_enable = 0;
    portmod_pause_control->tx_enable = 0;
    portmod_pause_control->refresh_timer = 0xc000;
    portmod_pause_control->xoff_timer = 0xFFFF;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_drain_cells_t_validate(int unit, const portmod_drain_cells_t* portmod_drain_cells)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_drain_cells == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_drain_cells_t_init(int unit, portmod_drain_cells_t* portmod_drain_cells)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_drain_cells == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_drain_cells NULL parameter"));
    }
    sal_memset(portmod_drain_cells, 0, sizeof(portmod_drain_cells_t));
    portmod_drain_cells->rx_pfc_en = 0;
    portmod_drain_cells->llfc_en = 0;
    portmod_drain_cells->rx_pause = 0;
    portmod_drain_cells->tx_pause = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_create_info_t_validate(int unit, const portmod_pm_create_info_t* portmod_pm_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_create_info->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_create_info_t_init(int unit, portmod_pm_create_info_t* portmod_pm_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_create_info NULL parameter"));
    }
    sal_memset(portmod_pm_create_info, 0, sizeof(portmod_pm_create_info_t));
    portmod_pm_create_info->type = portmodDispatchTypeCount;
    SOC_PBMP_CLEAR(portmod_pm_create_info->phys);
    sal_memset(&(portmod_pm_create_info->pm_specific_info), 0, sizeof(portmod_pm_specific_create_info_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_access_get_params_t_validate(int unit, const portmod_access_get_params_t* portmod_access_get_params)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_access_get_params == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_access_get_params->sys_side) {
        case PORTMOD_SIDE_LINE:
        case  PORTMOD_SIDE_SYSTEM:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("sys_side not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_access_get_params_t_init(int unit, portmod_access_get_params_t* portmod_access_get_params)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_access_get_params == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_access_get_params NULL parameter"));
    }
    sal_memset(portmod_access_get_params, 0, sizeof(portmod_access_get_params_t));
    portmod_access_get_params->phyn = -1;
    portmod_access_get_params->sys_side = PORTMOD_SIDE_LINE;
    portmod_access_get_params->lane = -1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_instances_t_validate(int unit, const portmod_pm_instances_t* portmod_pm_instances)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_instances == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_instances->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_instances_t_init(int unit, portmod_pm_instances_t* portmod_pm_instances)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_instances == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_instances NULL parameter"));
    }
    sal_memset(portmod_pm_instances, 0, sizeof(portmod_pm_instances_t));
    portmod_pm_instances->type = portmodDispatchTypeCount;
    portmod_pm_instances->instances = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_interface_type_is_supported(int unit, pm_info_t pm_info, soc_port_if_t interface, int* is_supported)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(is_supported == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("is_supported NULL parameter"));
    }
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_interface_type_is_supported) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_interface_type_is_supported(unit, interface, is_supported);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_interface_type_is_supported isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_init(int unit, const portmod_pm_create_info_internal_t* pm_add_info, int wb_buffer_index, pm_info_t pm_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_add_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_init) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_init(unit, pm_add_info, wb_buffer_index, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_init isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_destroy(int unit, pm_info_t pm_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_destroy) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_destroy(unit, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_destroy isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_attach(int unit, int port, const portmod_port_add_info_t* add_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_add_info_t_validate(unit, add_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("add_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_attach) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_attach(unit, port, pm_info, add_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_attach isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_default_bus_update(int unit, pm_info_t pm_info, const portmod_bus_update_t* update)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_default_bus_update) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_default_bus_update(unit, pm_info, update);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_default_bus_update isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_bypass_set(int unit, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, enable, &enable, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_bypass_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, enable, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_bypass_set(unit, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_bypass_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_core_info_get(int unit, pm_info_t pm_info, int phyn, portmod_pm_core_info_t* core_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(core_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pm_core_info_t_init(unit, core_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_info initialization failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_core_info_get) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_core_info_get(unit, pm_info, phyn, core_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_core_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_detach(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_detach) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_detach(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_detach isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_enable_set(int unit, int port, int flags, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    switch(enable) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_enable_set(unit, port, pm_info, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_enable_get(int unit, int port, int flags, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_enable_get(unit, port, pm_info, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interface_config_set(int unit, int port, const portmod_port_interface_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interface_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interface_config_set(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interface_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interface_config_get(int unit, int port, portmod_port_interface_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_interface_config_t_init(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interface_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interface_config_get(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interface_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encoding_set(int unit, int port, uint32 properties, portmod_port_pcs_t encoding)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encoding_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encoding_set(unit, port, pm_info, properties, encoding);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encoding_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encoding_get(int unit, int port, uint32* properties, portmod_port_pcs_t* encoding)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(properties == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("properties NULL parameter"));
    }
    if(encoding == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("encoding NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encoding_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encoding_get(unit, port, pm_info, properties, encoding);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encoding_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cl72_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cl72_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cl72_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cl72_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cl72_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cl72_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cl72_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cl72_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_loopback_set(int unit, int port, portmod_loopback_mode_t loopback_type, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_loopback_mode_t_validate(unit, loopback_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback_type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_loopback_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_loopback_set(unit, port, pm_info, loopback_type, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_loopback_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_loopback_get(int unit, int port, portmod_loopback_mode_t loopback_type, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_loopback_mode_t_validate(unit, loopback_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback_type validation failed"));
    }

    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_loopback_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_loopback_get(unit, port, pm_info, loopback_type, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_loopback_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_enable_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_local_get(int unit, int port, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_local_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_local_get(unit, port, pm_info, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_local_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_set(int unit, int port, const phymod_autoneg_control_t* an)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_set(unit, port, pm_info, an);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_get(int unit, int port, phymod_autoneg_control_t* an)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(an == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("an NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_get(unit, port, pm_info, an);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_status_get(int unit, int port, phymod_autoneg_status_t* an_status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(an_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("an_status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_status_get(unit, port, pm_info, an_status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_link_get(int unit, int port, int* link)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(link == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("link NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_link_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_link_get(unit, port, pm_info, link);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_link_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_config_set(int unit, int port, portmod_prbs_mode_t mode, int flags, const phymod_prbs_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_set(unit, port, pm_info, mode, flags, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_config_get(int unit, int port, portmod_prbs_mode_t mode, int flags, phymod_prbs_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_get(unit, port, pm_info, mode, flags, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_enable_set(int unit, int port, portmod_prbs_mode_t mode, int flags, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    switch(enable) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_set(unit, port, pm_info, mode, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_enable_get(int unit, int port, portmod_prbs_mode_t mode, int flags, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_get(unit, port, pm_info, mode, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_status_get(int unit, int port, portmod_prbs_mode_t mode, int flags, phymod_prbs_status_t* status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    if(status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_status_get(unit, port, pm_info, mode, flags, status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_nof_lanes_set(int unit, int port, int nof_lanes)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_set(unit, port, pm_info, nof_lanes);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_nof_lanes_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_nof_lanes_get(int unit, int port, int* nof_lanes)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(nof_lanes == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_lanes NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_get(unit, port, pm_info, nof_lanes);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_nof_lanes_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ilkn_retranstmit_config_set(int unit, int port, const ilkn_retransmit_config_t* retransmit_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_set(unit, port, pm_info, retransmit_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ilkn_retranstmit_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ilkn_retranstmit_config_get(int unit, int port, ilkn_retransmit_config_t* retransmit_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(retransmit_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("retransmit_config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_get(unit, port, pm_info, retransmit_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ilkn_retranstmit_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lanes_assign(int unit, int port, const portmod_lanes_assign_info_t* assign_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lanes_assign) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lanes_assign(unit, port, pm_info, assign_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lanes_assign isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lanes_retrieve(int unit, int port, portmod_lanes_assign_info_t* assign_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(assign_map == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("assign_map NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lanes_retrieve) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lanes_retrieve(unit, port, pm_info, assign_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lanes_retrieve isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_firmware_mode_set(int unit, int port, phymod_firmware_mode_t fw_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_set(unit, port, pm_info, fw_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_firmware_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_firmware_mode_get(int unit, int port, phymod_firmware_mode_t* fw_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(fw_mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fw_mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_get(unit, port, pm_info, fw_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_firmware_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_runt_threshold_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_runt_threshold_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_runt_threshold_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_runt_threshold_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_max_packet_size_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_max_packet_size_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_max_packet_size_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_max_packet_size_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pad_size_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pad_size_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pad_size_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pad_size_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pad_size_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pad_size_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pad_size_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pad_size_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_set(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_sa_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_get(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_sa_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_set(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_sa_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_get(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_sa_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_average_ipg_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_average_ipg_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_average_ipg_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_average_ipg_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_preamble_length_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_preamble_length_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_preamble_length_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_preamble_length_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_control_set(int unit, int port, const portmod_local_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_local_fault_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_control_get(int unit, int port, portmod_local_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_local_fault_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_control_set(int unit, int port, const portmod_remote_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_remote_fault_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_control_get(int unit, int port, portmod_remote_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_remote_fault_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_status_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_status_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_status_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_status_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_status_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_status_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pause_control_set(int unit, int port, const portmod_pause_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pause_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pause_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pause_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pause_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pause_control_get(int unit, int port, portmod_pause_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pause_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pause_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pause_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pause_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_control_set(int unit, int port, const portmod_pfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pfc_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_control_get(int unit, int port, portmod_pfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pfc_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_llfc_control_set(int unit, int port, const portmod_llfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_llfc_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_llfc_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_llfc_control_get(int unit, int port, portmod_llfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_llfc_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_llfc_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_update_control_t_validate(int unit, const portmod_port_update_control_t* portmod_port_update_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_update_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_update_control_t_init(int unit, portmod_port_update_control_t* portmod_port_update_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_update_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_update_control NULL parameter"));
    }
    sal_memset(portmod_port_update_control, 0, sizeof(portmod_port_update_control_t));
    portmod_port_update_control->link_status = -1;
    portmod_port_update_control->flags = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_update(int unit, int port, const portmod_port_update_control_t* update_control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_update_control_t_validate(unit, update_control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("update_control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_update) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_update(unit, port, pm_info, update_control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_update isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_core_access_get(int unit, int port, int phyn, int max_cores, phymod_core_access_t* core_access_arr, int* nof_cores, int* is_most_ext)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(core_access_arr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_access_arr NULL parameter"));
    }
    if(nof_cores == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_cores NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_core_access_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_core_access_get(unit, port, pm_info, phyn, max_cores, core_access_arr, nof_cores, is_most_ext);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_core_access_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_lane_access_get(int unit, int port, const portmod_access_get_params_t* params, int max_phys, phymod_phy_access_t* access, int* nof_phys, int* is_most_ext)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_access_get_params_t_validate(unit, params)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("params validation failed"));
    }

    if(access == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("access NULL parameter"));
    }
    if(nof_phys == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_phys NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_lane_access_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_lane_access_get(unit, port, pm_info, params, max_phys, access, nof_phys, is_most_ext);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_lane_access_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_duplex_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_duplex_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_duplex_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_duplex_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_duplex_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_duplex_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_duplex_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_duplex_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_reg_read(int unit, int port, int flags, int reg_addr, uint32* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_read) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_read(unit, port, pm_info, flags, reg_addr, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_reg_read isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_reg_write(int unit, int port, int flags, int reg_addr, uint32 value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_write) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_write(unit, port, pm_info, flags, reg_addr, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_reg_write isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_reset_set(int unit, int port, int mode, int opcode, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_reset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_reset_set(unit, port, pm_info, mode, opcode, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_reset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_reset_get(int unit, int port, int mode, int opcode, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_reset_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_reset_get(unit, port, pm_info, mode, opcode, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_reset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_adv_remote_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_adv_remote_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_adv_remote_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_adv_remote_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drv_name(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drv_name) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drv_name(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drv_name isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drv_name_get(int unit, int port, char* name, int len)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(name == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("name NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drv_name_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drv_name_get(unit, port, pm_info, name, len);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drv_name_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_advert_set(int unit, int port, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_set(unit, port, pm_info, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_advert_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_advert_get(int unit, int port, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_get(unit, port, pm_info, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_advert_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_remote_get(int unit, int port, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_remote_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_remote_get(unit, port, pm_info, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_remote_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_frame_spacing_stretch_set(int unit, int port, int spacing)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_set(unit, port, pm_info, spacing);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_frame_spacing_stretch_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_frame_spacing_stretch_get(int unit, int port, const int* spacing)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_get(unit, port, pm_info, spacing);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_frame_spacing_stretch_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_diag_fifo_status_get(int unit, int port, const portmod_fifo_status_t* diag_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_fifo_status_t_validate(unit, diag_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("diag_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_diag_fifo_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_diag_fifo_status_get(unit, port, pm_info, diag_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_diag_fifo_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_control_set(int unit, int port, const portmod_rx_control_t* rx_ctrl)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_rx_control_t_validate(unit, rx_ctrl)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rx_ctrl validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_control_set(unit, port, pm_info, rx_ctrl);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_config_set(int unit, int port, const portmod_pfc_config_t* pfc_cfg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pfc_config_t_validate(unit, pfc_cfg)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pfc_cfg validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_set(unit, port, pm_info, pfc_cfg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_config_get(int unit, int port, const portmod_pfc_config_t* pfc_cfg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pfc_config_t_validate(unit, pfc_cfg)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pfc_cfg validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_get(unit, port, pm_info, pfc_cfg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_eee_set(int unit, int port, const portmod_eee_t* eee)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_eee_t_validate(unit, eee)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_eee_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_eee_set(unit, port, pm_info, eee);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_eee_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_eee_get(int unit, int port, portmod_eee_t* eee)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(eee == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee NULL parameter"));
    }
    if(SOC_E_NONE != portmod_eee_t_init(unit, eee)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_eee_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_eee_get(unit, port, pm_info, eee);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_eee_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_vlan_tag_set(int unit, int port, const portmod_vlan_tag_t* vlan_tag)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_vlan_tag_t_validate(unit, vlan_tag)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_tag validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_set(unit, port, pm_info, vlan_tag);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_vlan_tag_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_vlan_tag_get(int unit, int port, portmod_vlan_tag_t* vlan_tag)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(vlan_tag == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_tag NULL parameter"));
    }
    if(SOC_E_NONE != portmod_vlan_tag_t_init(unit, vlan_tag)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_tag initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_get(unit, port, pm_info, vlan_tag);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_vlan_tag_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_modid_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_modid_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_modid_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_modid_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_led_chain_config(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_led_chain_config) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_led_chain_config(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_led_chain_config isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_clear_rx_lss_status_set(int unit, int port, int lcl_fault, int rmt_fault)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_set(unit, port, pm_info, lcl_fault, rmt_fault);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_clear_rx_lss_status_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_clear_rx_lss_status_get(int unit, int port, int* lcl_fault, int* rmt_fault)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(lcl_fault == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lcl_fault NULL parameter"));
    }
    if(rmt_fault == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rmt_fault NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_get(unit, port, pm_info, lcl_fault, rmt_fault);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_clear_rx_lss_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ext_phy_attach_to_pm(int unit, pm_info_t pm_info, const phymod_core_access_t* ext_phy_access, uint32 first_phy_lane)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ext_phy_attach_to_pm) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ext_phy_attach_to_pm(unit, pm_info, ext_phy_access, first_phy_lane);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ext_phy_attach_to_pm isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ext_phy_detach_from_pm(int unit, pm_info_t pm_info, phymod_core_access_t* ext_phy_access)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ext_phy_detach_from_pm) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ext_phy_detach_from_pm(unit, pm_info, ext_phy_access);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ext_phy_detach_from_pm isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_status_toggle(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_status_toggle) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_status_toggle(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_status_toggle isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_loopback_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_loopback_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_loopback_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_loopback_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mode_set(int unit, int port, portmod_port_mode_info_t* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_mode_info_t_init(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mode_set(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mode_get(int unit, int port, portmod_port_mode_info_t* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_mode_info_t_init(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mode_get(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encap_set(int unit, int port, int flags, portmod_encap_t encap)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encap_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encap_set(unit, port, pm_info, flags, encap);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encap_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encap_get(int unit, int port, int* flags, portmod_encap_t* encap)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(flags == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flags NULL parameter"));
    }
    if(encap == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("encap NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encap_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encap_get(unit, port, pm_info, flags, encap);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encap_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig_mode_set(int unit, int port, int mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_set(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig_mode_get(int unit, int port, int* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_get(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig2_mode_set(int unit, int port, int mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_set(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig2_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig2_mode_get(int unit, int port, int* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_get(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig2_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_config_port_type_set(int unit, int port, int type)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_set(unit, port, pm_info, type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_config_port_type_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_config_port_type_get(int unit, int port, int* type)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(type == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_get(unit, port, pm_info, type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_config_port_type_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_trunk_hwfailover_config_set(int unit, int port, int hw_count)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_set(unit, port, pm_info, hw_count);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_trunk_hwfailover_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_trunk_hwfailover_config_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_trunk_hwfailover_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_trunk_hwfailover_status_get(int unit, int port, int* loopback)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(loopback == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_status_get(unit, port, pm_info, loopback);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_trunk_hwfailover_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_diag_ctrl(int unit, int port, uint32 inst, int op_type, int op_cmd, const void* arg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_diag_ctrl) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_diag_ctrl(unit, port, pm_info, inst, op_type, op_cmd, arg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_diag_ctrl isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ifg_set(int unit, int port, int speed, soc_port_duplex_t duplex, int ifg, int* real_ifg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(real_ifg == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("real_ifg NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ifg_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ifg_set(unit, port, pm_info, speed, duplex, ifg, real_ifg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ifg_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ifg_get(int unit, int port, int speed, soc_port_duplex_t duplex, int* ifg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(ifg == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ifg NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ifg_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ifg_get(unit, port, pm_info, speed, duplex, ifg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ifg_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ref_clk_get(int unit, int port, int* ref_clk)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(ref_clk == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ref_clk NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ref_clk_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ref_clk_get(unit, port, pm_info, ref_clk);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ref_clk_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_disable(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_disable) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_disable(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_disable isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_remove_failover_lpbk_set(int unit, int port, int val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_set(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_remove_failover_lpbk_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_remove_failover_lpbk_get(int unit, int port, int* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_get(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_remove_failover_lpbk_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cntmaxsize_set(int unit, int port, int val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_set(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cntmaxsize_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cntmaxsize_get(int unit, int port, int* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_get(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cntmaxsize_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_multi_get(int unit, int port, portmod_multi_get_t* multi_get)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(multi_get == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("multi_get NULL parameter"));
    }
    if(SOC_E_NONE != portmod_multi_get_t_init(unit, multi_get)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("multi_get initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_multi_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_multi_get(unit, port, pm_info, multi_get);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_multi_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cell_get(int unit, int port, portmod_drain_cells_t* drain_cells)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(drain_cells == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("drain_cells NULL parameter"));
    }
    if(SOC_E_NONE != portmod_drain_cells_t_init(unit, drain_cells)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("drain_cells initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_get(unit, port, pm_info, drain_cells);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cell_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cell_stop(int unit, int port, const portmod_drain_cells_t* drain_cells)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_drain_cells_t_validate(unit, drain_cells)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("drain_cells validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_stop) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_stop(unit, port, pm_info, drain_cells);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cell_stop isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cell_start(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_start) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_start(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cell_start isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cells_rx_enable(int unit, int port, int rx_en)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cells_rx_enable) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cells_rx_enable(unit, port, pm_info, rx_en);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cells_rx_enable isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_egress_queue_drain_rx_en(int unit, int port, int rx_en)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_rx_en) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_rx_en(unit, port, pm_info, rx_en);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_egress_queue_drain_rx_en isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_ctrl_set(int unit, int port, uint64 ctrl)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_ctrl_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_ctrl_set(unit, port, pm_info, ctrl);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_ctrl_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_txfifo_cell_cnt_get(int unit, int port, uint32* cnt)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(cnt == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cnt NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_txfifo_cell_cnt_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_txfifo_cell_cnt_get(unit, port, pm_info, cnt);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_txfifo_cell_cnt_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_egress_queue_drain_get(int unit, int port, uint64* ctrl, int* rxen)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(ctrl == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ctrl NULL parameter"));
    }
    if(rxen == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rxen NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_get(unit, port, pm_info, ctrl, rxen);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_egress_queue_drain_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_reset_set(int unit, int port, int val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_set(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_reset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_soft_reset_toggle(int unit, int port, int idx)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_soft_reset_toggle) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_soft_reset_toggle(unit, port, pm_info, idx);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_soft_reset_toggle isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_reset_check(int unit, int port, int enable, int* reset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(reset == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("reset NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_check) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_check(unit, port, pm_info, enable, reset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_reset_check isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_core_num_get(int unit, int port, int* core_num)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(core_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_num NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_core_num_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_core_num_get(unit, port, pm_info, core_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_core_num_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig_e2ecc_hdr_t_validate(int unit, const portmod_port_higig_e2ecc_hdr_t* portmod_port_higig_e2ecc_hdr)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_higig_e2ecc_hdr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_higig_e2ecc_hdr_t_init(int unit, portmod_port_higig_e2ecc_hdr_t* portmod_port_higig_e2ecc_hdr)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_higig_e2ecc_hdr == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_higig_e2ecc_hdr NULL parameter"));
    }
    sal_memset(portmod_port_higig_e2ecc_hdr, 0, sizeof(portmod_port_higig_e2ecc_hdr_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_e2ecc_hdr_set(int unit, int port, portmod_port_higig_e2ecc_hdr_t* e2ecc_hdr)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(e2ecc_hdr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("e2ecc_hdr NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_higig_e2ecc_hdr_t_init(unit, e2ecc_hdr)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("e2ecc_hdr initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_set(unit, port, pm_info, e2ecc_hdr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2ecc_hdr_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_e2ecc_hdr_get(int unit, int port, portmod_port_higig_e2ecc_hdr_t* e2ecc_hdr)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(e2ecc_hdr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("e2ecc_hdr NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_higig_e2ecc_hdr_t_init(unit, e2ecc_hdr)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("e2ecc_hdr initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_get(unit, port, pm_info, e2ecc_hdr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2ecc_hdr_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_e2e_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2e_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_e2e_enable_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2e_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_fallback_lane_get(int unit, int port, int* fallback_lane)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(fallback_lane == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fallback_lane NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_fallback_lane_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_fallback_lane_get(unit, port, pm_info, fallback_lane);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_fallback_lane_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}



#undef _ERR_MSG_MODULE_NAME
