/* \file ctest_dnx_apt.h
 *
 * Contains all of the API performance test functions declarations.
 */
/*
 * $Copyright: (c) 2020 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef CTEST_DNX_APT_H_INCLUDED
#define CTEST_DNX_APT_H_INCLUDED

/*
* Include files.
* {
*/

#include <shared/shrextend/shrextend_debug.h>
#include <sal/appl/sal.h>
#include <bcm/types.h>
#include <appl/diag/sand/diag_sand_framework.h>
#include "ctest_dnx_apt_object_def.h"

/*
 * }
 */
/*
 * Generic API performance test (APT) framework
 * ============================================
 * *Measures the execution time of a single API.
 * *The measurement is performed in the form of a CTEST.
 * *Each test is created by defining new test object of type dnx_apt_object_def_t and adding it to a global test list.
 * *The test executes X number of identical runs.
 * *Each run executes Y number of API calls with different input data provided by the user.
 * *The framework is responsible for the execution of the test from the test object and measuring the execution time.
 * *The framework provides random number generation functions to the user.
 *
 * Main goal
 * =========
 * *The measured execution time will be stored in regresison database during regression runs in order to track the
 * *performance of the API.
 * *All measured execution times will be exctracted from the regression database and will be used to create a
 * *visual graph that can be presented to customers.
 * *The graph will show the performance of the API for a given period of time.
 *
 * Test execution flow
 * ===================
 * 1) Test support validation.
 *    Whether a test is supported or not is decided by the support_flags and the custom_support_check function defined
 *    in the test object.
 * 2) Engine initialization.
 *    Disables threads and error recovery. Allocates necessary variables.
 * 3) Test initialization.
 *    Executed once at the beginning of the test. Skipped if test_object->init is NULL.
 *    Example usage: Allocating <number_of_calls> route entries to the provided custom_data pointer and setting their
 *                   keys and payloads with random values.
 * 4) Test run initialization (pre_execute).
 *    Executed once at the beginning of each run. Skipped if test_object->pre_exec is NULL.
 *    Example usage: Add <number_of_calls> route entries from the custom_data.
 * 5) Test execution.
 *    Calls the tested API <number_of_calls> times with call iterator as input parameter.
 *    Time measurements are performed from the beginning to the end of this step.
 *    Example usage: Update the <number_of_calls> route entries that were added in the previous step.
 * 6) Test run deinitialization (post_execute).
 *    Executed once at the end of each run. Skipped if test_object->post_execute is NULL.
 *    Example usage: Delete all route entries that were added and updated in the previous steps in order to allow the
 *                   next run to start clean.
 * 7) Test measurements validation.
 *    The execution time is measured per run and converted to average API execution time per run. These converted
 *    measurenets are validated based on the test_object->time_validation_method and compared against the
 *    test_object->time_threshold. The test fails if the measured time is longer than the time threshold.
 * 8) Test deinitialization.
 *    Executed once at the end of the test. Skipped if test_object->deinit is NULL.
 * 9) Engine deinitialization.
 *    Enables threads and error recovery. Frees previous allocations. Frees custom_data if allocated by the user and
 *    unique random numbers if generated by the user.
 *
 * Adding new tests
 * ================
 * 1) Create a new file - dnx_apt_object_xxx_def.c (where xxx stands for the module name).
 *    Use existing dnx_apt_object_xxx_def.c file when appropriate.
 *    *) Include this file in the new file.
 * 2) Implement the necessary test functions.
 *    The function prototypes need to comply with the prototypes of the respective test object function pointer.
 *    The functions can be common for all tests in the file.
 * 3) Create new test object.
 *    a) Define the new test object as a structure of type dnx_apt_object_def_t.
 *    b) Set all test object fields.
 *       Information for each field can be found in the definition of the structure (in dnx_apt_object_def.h)
 *    c) Test time threshold is provided as a function in order to provide flexibility for specifying different
 *       thresholds depending on device, revision and configuration.
 *       In order to set the correct threshold, execute the test once it's implemented. The test can be un with option
 *       'debug' to print the execution time for all runs. Set the test time threshold to a high enough value to pass
 *       the test. Execution time higher that the set threshold will cause the test to fail. It is user to track changes
 *       in the API performance.
 * 3) Add the new test to dnx_apt_object_def.c.
 *    a) Declare the new test object as external.
 *    b) Add a pointer to the test object as a next element in the test objects array (*dnx_apt_objects[]).
 * 4) Compile.
 * 5) Run "ctest apt validate".
 * 6) Run the test to make sure it's behaving as expected - "ctest apt test name=<test_name>".
 * 7) Make sure to add the owner of the new test to the test owners list.
 *    The test name format is - AT_Dnx_CTest_APT_TeST_<test name from object>
 *
 * Display Results
 * ===============
 * BCM.0> ctest apt test name=L3_Route_IPv4_Update
 *
 * Test "L3_Route_IPv4_Update" Start. 10 runs 10000 calls.
 * ..........
 * Test "L3_Route_IPv4_Update" results:
 *         Validating: Stable average
 *         Execution time 8.776us <= 9.709us time threshold.
 *         Execution rate 113950 >= 103000 calls per second
 *         Passing runs 10/10
 *         Result: (PASS).
 * Test "L3_Route_IPv4_Update" Finished. (PASS)
 * BCM.0>
 */

/*
 * DEFINEs
 * {
 */

/*
 * }
 */

/*
 * MACROs
 * {
 */

/*
 * }
 */

/*
 * TYPEDEFs
 * {
 */

/*
 * }
 */

/*
 * GLOBALSs
 * {
 */

/*
 * }
 */

/*
 * FUNCTIONs
 * {
 */

int dnx_apt_number_of_objects(
    void);

shr_error_e dnx_apt_engine_test_run(
    int unit,
    const dnx_apt_object_def_t * test_object);

uint8 dnx_apt_is_compilation_supported(
    void);

shr_error_e dnx_apt_test_support_check(
    int unit,
    const dnx_apt_object_def_t * test_object);

const char *dnx_apt_validation_method_string(
    dnx_apt_validation_method_e validation_method);

/***********************************************************************************************************************
 * Random number utility APIs
 **********************************************************************************************************************/

/** API for seeding the state of the pseudo-random number generator */
void dnx_apt_random_seed(
    uint64 seed);

/** APIs for fast generating of 64b pseudo-random numbers (splitmix64) */
uint64 dnx_apt_random_get_64(
    void);

/** API for truncating the 64b pseudo-random number to 32b */
uint32 dnx_apt_random_get(
    void);

/*
 * API for generating an array of unique random numbers.
 * The array will contain randomly shuffled numbers in the range from 0 to <numbers - 1>.
 */
shr_error_e dnx_apt_unique_random_generate(
    int unit,
    uint32 numbers);

/*
 * API for retrieving unique random number from the pre-generated array.
 * Should be preceeded by dnx_apt_unique_random_generate().
 */
uint32 dnx_apt_unique_random_get(
    int number_index);

/*
 * API for freeing the array of unique random numbers.
 * Automatically called by the API performance test engine.
 */
void dnx_apt_unique_random_free(
    void);

/*
 * }
 */

#endif /* CTEST_DNX_APT_H_INCLUDED */
