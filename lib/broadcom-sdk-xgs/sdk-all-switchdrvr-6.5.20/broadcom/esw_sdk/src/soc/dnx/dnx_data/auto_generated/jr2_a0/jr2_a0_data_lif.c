/** \file jr2_a0_data_lif.c
 * 
 * DEVICE DATA - LIF
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2020 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_LIF
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_lif.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_property.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_device.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_mdb.h>
/*
 * }
 */

/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: global_lif
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_global_lif_prevent_tunnel_update_rif_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int feature_index = dnx_data_lif_global_lif_prevent_tunnel_update_rif;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define use_mdb_size
 * define info:
 * Some lif sizes are not taken from dnx data, but from the mdb. Use this flag to indicate if it should be used, or just use default minimal value.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_global_lif_use_mdb_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_use_mdb_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define glem_rif_optimization_enabled
 * define info:
 * Amount of out RIFs one GLEM entry can hold for optimized GLEM usage is 4.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_global_lif_glem_rif_optimization_enabled_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_glem_rif_optimization_enabled;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define null_lif
 * define info:
 * ERPP GLEM trap requires NULL LIF to be added to GLEM by default.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_global_lif_null_lif_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_null_lif;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_global_in_lifs
 * numeric info:
 * Number of in global lifs in the device.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_global_lif_nof_global_in_lifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_nof_global_in_lifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x300000;

    /* Set value */
    define->data = 0x300000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_SYSTEM_HEADERS_MODE;
    define->property.doc = NULL;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0x40000;
    define->property.mapping[1].name = "1";
    define->property.mapping[1].val = 0x300000;
    define->property.mapping[1].is_default = 1 ;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_global_out_lifs
 * numeric info:
 * Number of out global lifs in the device.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_global_lif_nof_global_out_lifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_nof_global_out_lifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.global_lif.nof_global_in_lifs_get(unit);

    /* Set value */
    define->data = dnx_data_lif.global_lif.nof_global_in_lifs_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric egress_in_lif_null_value
 * numeric info:
 * IN_LIF null value in egress stage.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_global_lif_egress_in_lif_null_value_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_egress_in_lif_null_value;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x0;

    /* Set value */
    define->data = 0x0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_SYSTEM_HEADERS_MODE;
    define->property.doc = 
        "IN_LIF null value in egress stage\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0x0;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "1";
    define->property.mapping[1].val = 0x0;
    define->property.mapping[1].is_default = 1 ;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric egress_out_lif_null_value
 * numeric info:
 * OUT_LIF null value in egress stage.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_global_lif_egress_out_lif_null_value_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_egress_out_lif_null_value;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x0;

    /* Set value */
    define->data = 0x0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_SYSTEM_HEADERS_MODE;
    define->property.doc = 
        "IN_LIF null value in egress stage\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0x3FFFF;
    define->property.mapping[1].name = "1";
    define->property.mapping[1].val = 0x0;
    define->property.mapping[1].is_default = 1 ;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_global_l2_gport_lifs
 * numeric info:
 * The mpls and vlan ports don't have enough bits to support the full global lif address. Their number is limited by this value.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_global_lif_nof_global_l2_gport_lifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_nof_global_l2_gport_lifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x100000;

    /* Set value */
    define->data = 0x100000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_SYSTEM_HEADERS_MODE;
    define->property.doc = NULL;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0x40000;
    define->property.mapping[1].name = "1";
    define->property.mapping[1].val = 0x100000;
    define->property.mapping[1].is_default = 1 ;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: in_lif
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_mapped_in_lif_profile_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int feature_index = dnx_data_lif_in_lif_mapped_in_lif_profile;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_in_lif_profile_iop_mode_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int feature_index = dnx_data_lif_in_lif_in_lif_profile_iop_mode;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define inlif_index_bit_size
 * define info:
 * This is the size of a single index in the inlif table. Divide the entry bit size by this to get its size in indexes.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_inlif_index_bit_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_inlif_index_bit_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 60;

    /* Set value */
    define->data = 60;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define inlif_minimum_index_size
 * define info:
 * The minimum size in indexes of an inlif entry
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_inlif_minimum_index_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_inlif_minimum_index_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define inlif_resource_tag_size
 * define info:
 * The size of the inlif resource's n-packs. The packs are used to prevent fragmentation by assigning each pack a fixed entry size. The pack should be the least common denominator of every possible entry side. See the SDD for full description.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_inlif_resource_tag_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_inlif_resource_tag_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_in_lif_profiles
 * define info:
 * Number of possible in_lif profiles.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_nof_in_lif_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_in_lif_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_used_in_lif_profile_bits
 * define info:
 * Number of used in_lif_profile bits out of 8.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_nof_used_in_lif_profile_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_used_in_lif_profile_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 7;

    /* Set value */
    define->data = 7;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_used_eth_rif_profile_bits
 * define info:
 * Number of used eth_rif_profile bits.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_nof_used_eth_rif_profile_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_used_eth_rif_profile_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 7;

    /* Set value */
    define->data = 7;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_in_lif_incoming_orientation
 * define info:
 * Number of possible in_lif profile incoming orientation groups.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_nof_in_lif_incoming_orientation_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_in_lif_incoming_orientation;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_eth_rif_profiles
 * define info:
 * Number of possible eth_rif profiles.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_nof_eth_rif_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_eth_rif_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_da_not_found_destination_profiles
 * define info:
 * Number of da_not_found_destination profiles.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_nof_da_not_found_destination_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_da_not_found_destination_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_da_not_found_destination_profile
 * define info:
 * Default da_not_found_destination profile.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_default_da_not_found_destination_profile_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_default_da_not_found_destination_profile;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define drop_in_lif
 * define info:
 * local in_lif id performing trap with drop action.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_drop_in_lif_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_drop_in_lif;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define mc_bridge_fallback_per_lif_profile
 * define info:
 * Enable/Disable the MC bridge fallback functionality based on LIF profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_mc_bridge_fallback_per_lif_profile_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_mc_bridge_fallback_per_lif_profile;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric in_lif_profile_allocate_indexed_mode
 * numeric info:
 * number of values needed for property indexed_mode in in_lif_profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_indexed_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_indexed_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "in_lif_profile_allocate";
    define->property.doc = 
        "number of values needed for property indexed_mode in in_lif_profile\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_range;
    define->property.method_str = "suffix_range";
    define->property.suffix = "indexed_mode";
    define->property.range_min = 0;
    define->property.range_max = 2;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric in_lif_profile_allocate_orientation
 * numeric info:
 * number of values needed for egress property in_lif_orientation in in_lif_profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_orientation_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_orientation;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "in_lif_profile_egress_allocate";
    define->property.doc = 
        "number of values needed for egress property in_lif_orientation in in_lif_profile\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_range;
    define->property.method_str = "suffix_range";
    define->property.suffix = "orientation";
    define->property.range_min = 0;
    define->property.range_max = 8;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric in_lif_profile_allocate_policer_inner_dp
 * numeric info:
 * number of values needed for egress property ive_inner_qos_dp_profile in in_lif_profile.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_policer_inner_dp_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_inner_dp;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "in_lif_profile_egress_allocate";
    define->property.doc = 
        "number of values needed for egress property ive_inner_qos_dp_profile in in_lif_profile\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_range;
    define->property.method_str = "suffix_range";
    define->property.suffix = "policer_inner_dp";
    define->property.range_min = 0;
    define->property.range_max = 4;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric in_lif_profile_allocate_policer_outer_dp
 * numeric info:
 * number of values needed for egress property ive_outer_qos_dp_profile in in_lif_profile.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_policer_outer_dp_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_outer_dp;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "in_lif_profile_egress_allocate";
    define->property.doc = 
        "number of values needed for egress property ive_outer_qos_dp_profile in in_lif_profile\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_range;
    define->property.method_str = "suffix_range";
    define->property.suffix = "policer_outer_dp";
    define->property.range_min = 0;
    define->property.range_max = 4;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric in_lif_profile_allocate_same_interface_mode
 * numeric info:
 * number of values needed for egress property in_lif_profile_allocate_same_interface_mode in in_lif_profile.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_same_interface_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_same_interface_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "in_lif_profile_egress_allocate";
    define->property.doc = 
        "number of values needed for egress property same_interface_mode in in_lif_profile\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_range;
    define->property.method_str = "suffix_range";
    define->property.suffix = "same_interface_mode";
    define->property.range_min = 0;
    define->property.range_max = 3;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: out_lif
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_out_lif_profiles
 * define info:
 * Number of possible out_lif profiles.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_nof_out_lif_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_nof_out_lif_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_erpp_out_lif_profiles
 * define info:
 * Number of possible erpp_out_lif profiles.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_nof_erpp_out_lif_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_nof_erpp_out_lif_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_out_lif_outgoing_orientation
 * define info:
 * Number of possible out_lif profile outgoing orientation groups.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_nof_out_lif_outgoing_orientation_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_nof_out_lif_outgoing_orientation;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define outrif_profile_width
 * define info:
 * The number of bits in the outrif profile from GLEM.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_outrif_profile_width_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_outrif_profile_width;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define glem_result
 * define info:
 * The number of bits in GLEM result.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_glem_result_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_glem_result;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 20;

    /* Set value */
    define->data = 20;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define physical_bank_pointer_size
 * define info:
 * How many bits from the outlif pointer are used to indicate the physical bank.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_physical_bank_pointer_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_physical_bank_pointer_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 7;

    /* Set value */
    define->data = 7;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define outlif_eedb_banks_pointer_size
 * define info:
 * pointer size used to access eedb banks.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_outlif_eedb_banks_pointer_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_outlif_eedb_banks_pointer_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 19;

    /* Set value */
    define->data = 19;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric outlif_pointer_size
 * numeric info:
 * The number of bits in the outlif profile from GLEM.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_outlif_pointer_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_outlif_pointer_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 19;

    /* Set value */
    define->data = 19;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_OUTLIF_NOF_BITS;
    define->property.doc = NULL;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "19";
    define->property.mapping[0].val = 19;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "20";
    define->property.mapping[1].val = 20;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric allocation_bank_size
 * numeric info:
 * Size of the outlif bank used by the outlif allocation algorithm.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_allocation_bank_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_allocation_bank_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8192;

    /* Set value */
    define->data = 8192;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_OUTLIF_NOF_BITS;
    define->property.doc = 
        "8192 + (DATA(lif,out_lif,outlif_pointer_size)-19)*8192\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "19";
    define->property.mapping[0].val = 8192;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "20";
    define->property.mapping[1].val = 16384;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric local_outlif_width
 * numeric info:
 * Size of the outlif bank used by the outlif allocation algorithm.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_local_outlif_width_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_local_outlif_width;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 19;

    /* Set value */
    define->data = 19;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_OUTLIF_NOF_BITS;
    define->property.doc = 
        "DATA(lif,out_lif,outlif_pointer_size)\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "19";
    define->property.mapping[0].val = 19;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "20";
    define->property.mapping[1].val = 20;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric outlif_profile_width
 * numeric info:
 * The number of bits in the outlif profile from GLEM.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_outlif_profile_width_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_outlif_profile_width;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_OUTLIF_NOF_BITS;
    define->property.doc = 
        "DATA(lif,out_lif,glem_result)-DATA(lif,out_lif,local_outlif_width)\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "19";
    define->property.mapping[0].val = 1;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "20";
    define->property.mapping[1].val = 0;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_local_out_lifs
 * numeric info:
 * Number of potential local outlifs in the device. Derived from the pointer size.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_nof_local_out_lifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_nof_local_out_lifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x80000;

    /* Set value */
    define->data = 0x80000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_OUTLIF_NOF_BITS;
    define->property.doc = 
        "1 << DATA(lif,out_lif,outlif_pointer_size)\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "19";
    define->property.mapping[0].val = 0x80000;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "20";
    define->property.mapping[1].val = 0x100000;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric physical_bank_size
 * numeric info:
 * Size of the outlif bank used by the phase map and mags. Derived from the outlif pointer size and the physical bank pointer size.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_physical_bank_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_physical_bank_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x1000;

    /* Set value */
    define->data = 0x1000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_OUTLIF_NOF_BITS;
    define->property.doc = 
        "1 << (DATA(lif,out_lif,outlif_pointer_size) - DATA(lif,out_lif,physical_bank_pointer_size))\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "19";
    define->property.mapping[0].val = 0x1000;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "20";
    define->property.mapping[1].val = 0x2000;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table logical_to_physical_phase_map
 * Module - 'lif', Submodule - 'out_lif', table - 'logical_to_physical_phase_map'
 * Map outlif logical phase to physical phase. The reverse mapping is implied from this.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_out_lif_logical_to_physical_phase_map_set(
    int unit)
{
    int logical_phase_index;
    dnx_data_lif_out_lif_logical_to_physical_phase_map_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int table_index = dnx_data_lif_out_lif_table_logical_to_physical_phase_map;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 9;
    table->info_get.key_size[0] = 9;

    /* Info - default values */
    table->values[0].default_val = "-1";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_lif_out_lif_logical_to_physical_phase_map_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_lif_out_lif_table_logical_to_physical_phase_map");

    /* Store Default Values */
    default_data = (dnx_data_lif_out_lif_logical_to_physical_phase_map_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->physical_phase = -1;
    /* Set Default Values */
    for (logical_phase_index = 0; logical_phase_index < table->keys[0].size; logical_phase_index++)
    {
        data = (dnx_data_lif_out_lif_logical_to_physical_phase_map_t *) dnxc_data_mgmt_table_data_get(unit, table, logical_phase_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - physical_phase
     */
    table->values[0].property.name = spn_OUTLIF_LOGICAL_TO_PHYSICAL_PHASE_MAP;
    table->values[0].property.doc =
        "\n"
        "Map outlif logical phase to physical phase.\n"
        "The suffix for this property is the logical phase, and the value is the physical phase.\n"
        "Every logical phase and every physical phase must be configured.\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_suffix_direct_map;
    table->values[0].property.method_str = "suffix_direct_map";
    table->values[0].property.suffix = "";
    table->values[0].property.nof_mapping = 8;
    DNXC_DATA_ALLOC(table->values[0].property.mapping, dnxc_data_property_map_t, table->values[0].property.nof_mapping, "dnx_data_lif_out_lif_logical_to_physical_phase_map_t property mapping");

    table->values[0].property.mapping[0].name = "XL";
    table->values[0].property.mapping[0].val = 0;
    table->values[0].property.mapping[1].name = "L1";
    table->values[0].property.mapping[1].val = 2;
    table->values[0].property.mapping[2].name = "L2";
    table->values[0].property.mapping[2].val = 4;
    table->values[0].property.mapping[3].name = "M1";
    table->values[0].property.mapping[3].val = 6;
    table->values[0].property.mapping[4].name = "M2";
    table->values[0].property.mapping[4].val = 7;
    table->values[0].property.mapping[5].name = "M3";
    table->values[0].property.mapping[5].val = 5;
    table->values[0].property.mapping[6].name = "S1";
    table->values[0].property.mapping[6].val = 3;
    table->values[0].property.mapping[7].name = "S2";
    table->values[0].property.mapping[7].val = 1;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));

    for (logical_phase_index = 0; logical_phase_index < table->keys[0].size; logical_phase_index++)
    {
        data = (dnx_data_lif_out_lif_logical_to_physical_phase_map_t *) dnxc_data_mgmt_table_data_get(unit, table, logical_phase_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, logical_phase_index, &data->physical_phase));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: lif_table_manager
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define max_nof_lif_tables
 * define info:
 * Maximal number of logical lif tables (inlif + outlif)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_lif_table_manager_max_nof_lif_tables_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_lif_table_manager;
    int define_index = dnx_data_lif_lif_table_manager_define_max_nof_lif_tables;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 100;

    /* Set value */
    define->data = 100;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_nof_result_types
 * define info:
 * Maximal number of result types in lif table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_lif_table_manager_max_nof_result_types_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_lif_table_manager;
    int define_index = dnx_data_lif_lif_table_manager_define_max_nof_result_types;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 30;

    /* Set value */
    define->data = 30;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_fields_per_result_type
 * define info:
 * Maximal number of fields for one result types in lif table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_lif_table_manager_max_fields_per_result_type_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_lif_table_manager;
    int define_index = dnx_data_lif_lif_table_manager_define_max_fields_per_result_type;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_fields_per_table
 * define info:
 * Maximal number of fields in a lif table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_lif_table_manager_max_fields_per_table_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_lif_table_manager;
    int define_index = dnx_data_lif_lif_table_manager_define_max_fields_per_table;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: feature
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_feature_iop_mode_outlif_selection_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_feature;
    int feature_index = dnx_data_lif_feature_iop_mode_outlif_selection;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_feature_iop_mode_orientation_selection_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_feature;
    int feature_index = dnx_data_lif_feature_iop_mode_orientation_selection;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_lif_feature_in_lif_tunnel_wide_data_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_feature;
    int feature_index = dnx_data_lif_feature_in_lif_tunnel_wide_data;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/*
 * Tables
 */
/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - 
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e
jr2_a0_data_lif_attach(
    int unit)
{
    dnxc_data_module_t *module = NULL;
    dnxc_data_submodule_t *submodule = NULL;
    dnxc_data_define_t *define = NULL;
    dnxc_data_feature_t *feature = NULL;
    dnxc_data_table_t *table = NULL;
    int module_index = dnx_data_module_lif;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnxc_data[unit].modules[module_index];
    /*
     * Attach submodule: global_lif
     */
    submodule_index = dnx_data_lif_submodule_global_lif;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_lif_global_lif_define_use_mdb_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_global_lif_use_mdb_size_set;
    data_index = dnx_data_lif_global_lif_define_glem_rif_optimization_enabled;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_global_lif_glem_rif_optimization_enabled_set;
    data_index = dnx_data_lif_global_lif_define_null_lif;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_global_lif_null_lif_set;
    data_index = dnx_data_lif_global_lif_define_nof_global_in_lifs;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_global_lif_nof_global_in_lifs_set;
    data_index = dnx_data_lif_global_lif_define_nof_global_out_lifs;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_global_lif_nof_global_out_lifs_set;
    data_index = dnx_data_lif_global_lif_define_egress_in_lif_null_value;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_global_lif_egress_in_lif_null_value_set;
    data_index = dnx_data_lif_global_lif_define_egress_out_lif_null_value;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_global_lif_egress_out_lif_null_value_set;
    data_index = dnx_data_lif_global_lif_define_nof_global_l2_gport_lifs;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_global_lif_nof_global_l2_gport_lifs_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_lif_global_lif_prevent_tunnel_update_rif;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_lif_global_lif_prevent_tunnel_update_rif_set;

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: in_lif
     */
    submodule_index = dnx_data_lif_submodule_in_lif;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_lif_in_lif_define_inlif_index_bit_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_inlif_index_bit_size_set;
    data_index = dnx_data_lif_in_lif_define_inlif_minimum_index_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_inlif_minimum_index_size_set;
    data_index = dnx_data_lif_in_lif_define_inlif_resource_tag_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_inlif_resource_tag_size_set;
    data_index = dnx_data_lif_in_lif_define_nof_in_lif_profiles;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_nof_in_lif_profiles_set;
    data_index = dnx_data_lif_in_lif_define_nof_used_in_lif_profile_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_nof_used_in_lif_profile_bits_set;
    data_index = dnx_data_lif_in_lif_define_nof_used_eth_rif_profile_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_nof_used_eth_rif_profile_bits_set;
    data_index = dnx_data_lif_in_lif_define_nof_in_lif_incoming_orientation;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_nof_in_lif_incoming_orientation_set;
    data_index = dnx_data_lif_in_lif_define_nof_eth_rif_profiles;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_nof_eth_rif_profiles_set;
    data_index = dnx_data_lif_in_lif_define_nof_da_not_found_destination_profiles;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_nof_da_not_found_destination_profiles_set;
    data_index = dnx_data_lif_in_lif_define_default_da_not_found_destination_profile;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_default_da_not_found_destination_profile_set;
    data_index = dnx_data_lif_in_lif_define_drop_in_lif;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_drop_in_lif_set;
    data_index = dnx_data_lif_in_lif_define_mc_bridge_fallback_per_lif_profile;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_mc_bridge_fallback_per_lif_profile_set;
    data_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_indexed_mode;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_indexed_mode_set;
    data_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_orientation;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_orientation_set;
    data_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_inner_dp;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_policer_inner_dp_set;
    data_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_outer_dp;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_policer_outer_dp_set;
    data_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_same_interface_mode;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_same_interface_mode_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_lif_in_lif_mapped_in_lif_profile;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_lif_in_lif_mapped_in_lif_profile_set;
    data_index = dnx_data_lif_in_lif_in_lif_profile_iop_mode;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_lif_in_lif_in_lif_profile_iop_mode_set;

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: out_lif
     */
    submodule_index = dnx_data_lif_submodule_out_lif;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_lif_out_lif_define_nof_out_lif_profiles;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_nof_out_lif_profiles_set;
    data_index = dnx_data_lif_out_lif_define_nof_erpp_out_lif_profiles;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_nof_erpp_out_lif_profiles_set;
    data_index = dnx_data_lif_out_lif_define_nof_out_lif_outgoing_orientation;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_nof_out_lif_outgoing_orientation_set;
    data_index = dnx_data_lif_out_lif_define_outrif_profile_width;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_outrif_profile_width_set;
    data_index = dnx_data_lif_out_lif_define_glem_result;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_glem_result_set;
    data_index = dnx_data_lif_out_lif_define_physical_bank_pointer_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_physical_bank_pointer_size_set;
    data_index = dnx_data_lif_out_lif_define_outlif_eedb_banks_pointer_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_outlif_eedb_banks_pointer_size_set;
    data_index = dnx_data_lif_out_lif_define_outlif_pointer_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_outlif_pointer_size_set;
    data_index = dnx_data_lif_out_lif_define_allocation_bank_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_allocation_bank_size_set;
    data_index = dnx_data_lif_out_lif_define_local_outlif_width;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_local_outlif_width_set;
    data_index = dnx_data_lif_out_lif_define_outlif_profile_width;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_outlif_profile_width_set;
    data_index = dnx_data_lif_out_lif_define_nof_local_out_lifs;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_nof_local_out_lifs_set;
    data_index = dnx_data_lif_out_lif_define_physical_bank_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_out_lif_physical_bank_size_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_lif_out_lif_table_logical_to_physical_phase_map;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_lif_out_lif_logical_to_physical_phase_map_set;
    /*
     * Attach submodule: lif_table_manager
     */
    submodule_index = dnx_data_lif_submodule_lif_table_manager;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_lif_lif_table_manager_define_max_nof_lif_tables;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_lif_table_manager_max_nof_lif_tables_set;
    data_index = dnx_data_lif_lif_table_manager_define_max_nof_result_types;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_lif_table_manager_max_nof_result_types_set;
    data_index = dnx_data_lif_lif_table_manager_define_max_fields_per_result_type;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_lif_table_manager_max_fields_per_result_type_set;
    data_index = dnx_data_lif_lif_table_manager_define_max_fields_per_table;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_lif_lif_table_manager_max_fields_per_table_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: feature
     */
    submodule_index = dnx_data_lif_submodule_feature;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */

    /*
     * Attach features: 
     */
    data_index = dnx_data_lif_feature_iop_mode_outlif_selection;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_lif_feature_iop_mode_outlif_selection_set;
    data_index = dnx_data_lif_feature_iop_mode_orientation_selection;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_lif_feature_iop_mode_orientation_selection_set;
    data_index = dnx_data_lif_feature_in_lif_tunnel_wide_data;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_lif_feature_in_lif_tunnel_wide_data_set;

    /*
     * Attach tables: 
     */

    SHR_FUNC_EXIT;
}
#undef BSL_LOG_MODULE
/* *INDENT-ON* */
