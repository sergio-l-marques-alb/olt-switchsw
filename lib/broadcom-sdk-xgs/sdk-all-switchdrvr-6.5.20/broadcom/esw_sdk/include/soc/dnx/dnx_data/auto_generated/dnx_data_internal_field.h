/** \file dnx_data_internal_field.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2020 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_FIELD_H_
/*{*/
#define _DNX_DATA_INTERNAL_FIELD_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_field.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_field_submodule_base_ipmf1,
    dnx_data_field_submodule_base_ipmf2,
    dnx_data_field_submodule_base_ipmf3,
    dnx_data_field_submodule_base_epmf,
    dnx_data_field_submodule_base_ifwd2,
    dnx_data_field_submodule_stage,
    dnx_data_field_submodule_kbp,
    dnx_data_field_submodule_tcam,
    dnx_data_field_submodule_group,
    dnx_data_field_submodule_efes,
    dnx_data_field_submodule_fem,
    dnx_data_field_submodule_context,
    dnx_data_field_submodule_preselector,
    dnx_data_field_submodule_qual,
    dnx_data_field_submodule_action,
    dnx_data_field_submodule_virtual_wire,
    dnx_data_field_submodule_profile_bits,
    dnx_data_field_submodule_dir_ext,
    dnx_data_field_submodule_state_table,
    dnx_data_field_submodule_map,
    dnx_data_field_submodule_hash,
    dnx_data_field_submodule_udh,
    dnx_data_field_submodule_system_headers,
    dnx_data_field_submodule_exem,
    dnx_data_field_submodule_exem_learn_flush_machine,
    dnx_data_field_submodule_ace,
    dnx_data_field_submodule_entry,
    dnx_data_field_submodule_L4_Ops,
    dnx_data_field_submodule_encoded_qual_actions_offset,
    dnx_data_field_submodule_Compare_operand,
    dnx_data_field_submodule_diag,
    dnx_data_field_submodule_common_max_val,
    dnx_data_field_submodule_init,
    dnx_data_field_submodule_features,
    dnx_data_field_submodule_signal_sizes,
    dnx_data_field_submodule_dnx_data_internal,
    dnx_data_field_submodule_tests,

    /**
     * Must be last one!
     */
    _dnx_data_field_submodule_nof
} dnx_data_field_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE BASE_IPMF1:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_base_ipmf1_feature_get(
    int unit,
    dnx_data_field_base_ipmf1_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_base_ipmf1_define_nof_ffc,
    dnx_data_field_base_ipmf1_define_nof_ffc_groups,
    dnx_data_field_base_ipmf1_define_ffc_group_one_lower,
    dnx_data_field_base_ipmf1_define_ffc_group_one_upper,
    dnx_data_field_base_ipmf1_define_ffc_group_two_lower,
    dnx_data_field_base_ipmf1_define_ffc_group_two_upper,
    dnx_data_field_base_ipmf1_define_ffc_group_three_lower,
    dnx_data_field_base_ipmf1_define_ffc_group_three_upper,
    dnx_data_field_base_ipmf1_define_ffc_group_four_lower,
    dnx_data_field_base_ipmf1_define_ffc_group_four_upper,
    dnx_data_field_base_ipmf1_define_nof_keys,
    dnx_data_field_base_ipmf1_define_nof_keys_alloc,
    dnx_data_field_base_ipmf1_define_nof_keys_alloc_for_tcam,
    dnx_data_field_base_ipmf1_define_nof_keys_alloc_for_exem,
    dnx_data_field_base_ipmf1_define_nof_keys_alloc_for_mdb_dt,
    dnx_data_field_base_ipmf1_define_nof_masks_per_fes,
    dnx_data_field_base_ipmf1_define_nof_fes_id_per_array,
    dnx_data_field_base_ipmf1_define_nof_fes_array,
    dnx_data_field_base_ipmf1_define_nof_fes_instruction_per_context,
    dnx_data_field_base_ipmf1_define_nof_fes_programs,
    dnx_data_field_base_ipmf1_define_nof_prog_per_fes,
    dnx_data_field_base_ipmf1_define_program_selection_cam_mask_nof_bits,
    dnx_data_field_base_ipmf1_define_cs_container_5_selected_bits_size,
    dnx_data_field_base_ipmf1_define_nof_contexts,
    dnx_data_field_base_ipmf1_define_nof_link_profiles,
    dnx_data_field_base_ipmf1_define_nof_cs_lines,
    dnx_data_field_base_ipmf1_define_nof_actions,
    dnx_data_field_base_ipmf1_define_nof_qualifiers,
    dnx_data_field_base_ipmf1_define_nof_80B_zones,
    dnx_data_field_base_ipmf1_define_nof_key_zones,
    dnx_data_field_base_ipmf1_define_nof_key_zone_bits,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fes_action,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fes_key_select,
    dnx_data_field_base_ipmf1_define_nof_fes_key_selects_on_one_actions_line,
    dnx_data_field_base_ipmf1_define_fem_condition_ms_bit_min_value,
    dnx_data_field_base_ipmf1_define_fem_condition_ms_bit_max_value,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_programs,
    dnx_data_field_base_ipmf1_define_nof_fem_programs,
    dnx_data_field_base_ipmf1_define_log_nof_bits_in_fem_key_select,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_key_select,
    dnx_data_field_base_ipmf1_define_fem_key_select_resolution_in_bits,
    dnx_data_field_base_ipmf1_define_log_nof_bits_in_fem_map_data_field,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_map_data_field,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action_fems_2_15,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action_fems_0_1,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_condition,
    dnx_data_field_base_ipmf1_define_nof_fem_condition,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_map_index,
    dnx_data_field_base_ipmf1_define_nof_fem_map_index,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_id,
    dnx_data_field_base_ipmf1_define_nof_fem_id,
    dnx_data_field_base_ipmf1_define_num_fems_with_short_action,
    dnx_data_field_base_ipmf1_define_num_bits_in_fem_field_select,
    dnx_data_field_base_ipmf1_define_nof_fem_id_per_array,
    dnx_data_field_base_ipmf1_define_nof_fem_array,
    dnx_data_field_base_ipmf1_define_nof_fems_per_context,
    dnx_data_field_base_ipmf1_define_nof_fem_action_overriding_bits,
    dnx_data_field_base_ipmf1_define_default_strength,
    dnx_data_field_base_ipmf1_define_nof_compare_pairs_in_compare_mode,
    dnx_data_field_base_ipmf1_define_nof_compare_keys_in_compare_mode,
    dnx_data_field_base_ipmf1_define_compare_key_size,
    dnx_data_field_base_ipmf1_define_nof_l4_ops_ranges_legacy,
    dnx_data_field_base_ipmf1_define_nof_ext_l4_ops_ranges,
    dnx_data_field_base_ipmf1_define_nof_pkt_hdr_ranges,
    dnx_data_field_base_ipmf1_define_nof_out_lif_ranges,
    dnx_data_field_base_ipmf1_define_fes_key_select_for_zero_bit,
    dnx_data_field_base_ipmf1_define_fes_shift_for_zero_bit,
    dnx_data_field_base_ipmf1_define_uses_small_exem,
    dnx_data_field_base_ipmf1_define_uses_large_exem,
    dnx_data_field_base_ipmf1_define_cmp_selection,
    dnx_data_field_base_ipmf1_define_fes_instruction_size,
    dnx_data_field_base_ipmf1_define_fes_pgm_id_offset,
    dnx_data_field_base_ipmf1_define_dir_ext_single_key_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf1_define_nof
} dnx_data_field_base_ipmf1_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_ffc'
 * Number of FFC's per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_ffc_groups_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_one_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_one_upper_get(
    int unit);

/**
 * \brief returns define data of ffc_group_two_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_two_lower'
 * Min FFC Index for Second FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_two_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_two_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_two_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_two_upper'
 * Max FFC Index for Second FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_two_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_two_upper_get(
    int unit);

/**
 * \brief returns define data of ffc_group_three_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_three_lower'
 * Min FFC Index for Thirth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_three_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_three_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_three_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_three_upper'
 * Max FFC Index for Thirth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_three_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_three_upper_get(
    int unit);

/**
 * \brief returns define data of ffc_group_four_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_four_lower'
 * Min FFC Index for Fourth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_four_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_four_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_four_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_four_upper'
 * Max FFC Index for Fourth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_four_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_four_upper_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_keys_alloc_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_keys_alloc_for_tcam_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_keys_alloc_for_exem_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_mdb_dt
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc_for_mdb_dt'
 * Number of keys available for allocation for use by this specific PMF stage for MDB_DT access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_mdb_dt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_keys_alloc_for_mdb_dt_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fes_programs_get(
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_prog_per_fes_get(
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_program_selection_cam_mask_nof_bits_get(
    int unit);

/**
 * \brief returns define data of cs_container_5_selected_bits_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'cs_container_5_selected_bits_size'
 * Number of bits taken from general data for context selection.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cs_container_5_selected_bits_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_cs_container_5_selected_bits_size_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_contexts'
 * Number of Ingress PMF_A programs (contexts). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_link_profiles
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_link_profiles'
 * Number of profiles assigned to iPMF1 contexts in order to create links between iPMF1 and iPMF2 contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_link_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_link_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_cs_lines_get(
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_actions_get(
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_qualifiers_get(
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groupsv
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_80B_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_key_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_key_zone_bits_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fes_action_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fes_key_select_get(
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can go into one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fes_key_selects_on_one_actions_line_get(
    int unit);

/**
 * \brief returns define data of fem_condition_ms_bit_min_value
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fem_condition_ms_bit_min_value'
 * The minumum legal value to be set in bit select for a FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_condition_ms_bit_min_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fem_condition_ms_bit_min_value_get(
    int unit);

/**
 * \brief returns define data of fem_condition_ms_bit_max_value
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fem_condition_ms_bit_max_value'
 * The maximum legal value to be set in bit select for a FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_condition_ms_bit_max_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fem_condition_ms_bit_max_value_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_programs
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_programs'
 * Number of bit in FEM program representation. This is log2 of the number of fem programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_programs_get(
    int unit);

/**
 * \brief returns define data of nof_fem_programs
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_programs'
 * Total number FEM programs available. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_programs_get(
    int unit);

/**
 * \brief returns define data of log_nof_bits_in_fem_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'log_nof_bits_in_fem_key_select'
 * Log2 of number of bits on one 'chunk' of input to FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     log_nof_bits_in_fem_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_log_nof_bits_in_fem_key_select_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_key_select'
 * Number of bits on one 'chunk' of input to FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_key_select_get(
    int unit);

/**
 * \brief returns define data of fem_key_select_resolution_in_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fem_key_select_resolution_in_bits'
 * Number of bits in the 'step' from one 'key select' to the following. See dbal_enum_value_field_field_pmf_a_fem_key_select_e. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_key_select_resolution_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fem_key_select_resolution_in_bits_get(
    int unit);

/**
 * \brief returns define data of log_nof_bits_in_fem_map_data_field
 * Module - 'field', Submodule - 'base_ipmf1', data - 'log_nof_bits_in_fem_map_data_field'
 * Log2 of number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     log_nof_bits_in_fem_map_data_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_log_nof_bits_in_fem_map_data_field_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_map_data_field
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_map_data_field'
 * Number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_map_data_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_map_data_field_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action_fems_2_15
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action_fems_2_15'
 * Number of bits on action value in IPPC_FEM_*_24B_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action_fems_2_15 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_2_15_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action_fems_0_1
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action_fems_0_1'
 * Number of bits on action value in IPPC_FEM_*_4B_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action_fems_0_1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_0_1_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action'
 * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_action_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_condition
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_condition'
 * Number of bits on fem condition. This is log2 of the number of conditions that may be assigned to each (fem_id,fem_program) combination. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_condition - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_condition_get(
    int unit);

/**
 * \brief returns define data of nof_fem_condition
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_condition'
 * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_condition - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_condition_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_map_index
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_map_index'
 * Number of bits on fem map index. This represents log2 of the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_map_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_map_index_get(
    int unit);

/**
 * \brief returns define data of nof_fem_map_index
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_map_index'
 * Total number fem map indices. This represents the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_map_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_map_index_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_id
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_id'
 * Number of bits on fem identifier. This represents the number of FEMs in the system: No. of FEMs is 2^nof_bits_in_fem_id. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_id_get(
    int unit);

/**
 * \brief returns define data of nof_fem_id
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_id'
 * Total number 'FEM id's available. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_id_get(
    int unit);

/**
 * \brief returns define data of num_fems_with_short_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'num_fems_with_short_action'
 * Number of FEMs, starting from 'fem_id=0', which have only 4 bits on action value. The rest have 24 bits on action value. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_fems_with_short_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_num_fems_with_short_action_get(
    int unit);

/**
 * \brief returns define data of num_bits_in_fem_field_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'num_bits_in_fem_field_select'
 * Number of bits on each of the HW field marked FIELD_SELECT_MAP_*. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_bits_in_fem_field_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_num_bits_in_fem_field_select_get(
    int unit);

/**
 * \brief returns define data of nof_fem_id_per_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_id_per_array'
 * Number FEMes in each FEM array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fem_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_array'
 * Number FEM arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_array_get(
    int unit);

/**
 * \brief returns define data of nof_fems_per_context
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fems_per_context'
 * Number of FEMs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fems_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fems_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_fem_action_overriding_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_action_overriding_bits'
 * Number of FEM action bits to be overridden.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_action_overriding_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_action_overriding_bits_get(
    int unit);

/**
 * \brief returns define data of default_strength
 * Module - 'field', Submodule - 'base_ipmf1', data - 'default_strength'
 * Default value for PMF strength. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_default_strength_get(
    int unit);

/**
 * \brief returns define data of nof_compare_pairs_in_compare_mode
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_compare_pairs_in_compare_mode'
 * Number compare pairs in compare mode. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_compare_pairs_in_compare_mode_get(
    int unit);

/**
 * \brief returns define data of nof_compare_keys_in_compare_mode
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_compare_keys_in_compare_mode'
 * Number compare keys in compare mode. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_keys_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_compare_keys_in_compare_mode_get(
    int unit);

/**
 * \brief returns define data of compare_key_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'compare_key_size'
 * Size of the compare key in the system. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     compare_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_compare_key_size_get(
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges_legacy
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_l4_ops_ranges_legacy'
 * Number of ranges for L4 Ops legacy. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges_legacy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_l4_ops_ranges_legacy_get(
    int unit);

/**
 * \brief returns define data of nof_ext_l4_ops_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_ext_l4_ops_ranges'
 * Number of ranges for External L4 Ops. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ext_l4_ops_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_ext_l4_ops_ranges_get(
    int unit);

/**
 * \brief returns define data of nof_pkt_hdr_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_pkt_hdr_ranges'
 * Number of ranges for PKT HDR. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pkt_hdr_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_pkt_hdr_ranges_get(
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_out_lif_ranges'
 * Number of ranges for Out Lif. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_out_lif_ranges_get(
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fes_key_select_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fes_shift_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_uses_small_exem_get(
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_uses_large_exem_get(
    int unit);

/**
 * \brief returns define data of cmp_selection
 * Module - 'field', Submodule - 'base_ipmf1', data - 'cmp_selection'
 * Compare selection for both keys of 2nd compare, See the CMP_SELECTION field in IPPC_PMF_GENERAL register for additional information. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cmp_selection - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_cmp_selection_get(
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fes_instruction_size_get(
    int unit);

/**
 * \brief returns define data of fes_pgm_id_offset
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_pgm_id_offset'
 * FES Program ID offset pointing to IPPC_PMF_FES_PROGRAMm->FES_2ND_INSTRUCTION_LSB_ADDRESSf.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_pgm_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fes_pgm_id_offset_get(
    int unit);

/**
 * \brief returns define data of dir_ext_single_key_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'dir_ext_single_key_size'
 * Single key size used for Direct Extraction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_dir_ext_single_key_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf1_table_nof
} dnx_data_field_base_ipmf1_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE BASE_IPMF2:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_base_ipmf2_feature_get(
    int unit,
    dnx_data_field_base_ipmf2_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_base_ipmf2_define_nof_ffc,
    dnx_data_field_base_ipmf2_define_nof_ffc_groups,
    dnx_data_field_base_ipmf2_define_ffc_group_one_lower,
    dnx_data_field_base_ipmf2_define_ffc_group_one_upper,
    dnx_data_field_base_ipmf2_define_nof_keys,
    dnx_data_field_base_ipmf2_define_nof_keys_alloc,
    dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_tcam,
    dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_exem,
    dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_dir_ext,
    dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_mdb_dt,
    dnx_data_field_base_ipmf2_define_nof_masks_per_fes,
    dnx_data_field_base_ipmf2_define_nof_fes_id_per_array,
    dnx_data_field_base_ipmf2_define_nof_fes_array,
    dnx_data_field_base_ipmf2_define_nof_fes_instruction_per_context,
    dnx_data_field_base_ipmf2_define_nof_cs_lines,
    dnx_data_field_base_ipmf2_define_nof_contexts,
    dnx_data_field_base_ipmf2_define_program_selection_cam_mask_nof_bits,
    dnx_data_field_base_ipmf2_define_nof_qualifiers,
    dnx_data_field_base_ipmf2_define_nof_80B_zones,
    dnx_data_field_base_ipmf2_define_nof_key_zones,
    dnx_data_field_base_ipmf2_define_nof_key_zone_bits,
    dnx_data_field_base_ipmf2_define_fes_key_select_for_zero_bit,
    dnx_data_field_base_ipmf2_define_fes_shift_for_zero_bit,
    dnx_data_field_base_ipmf2_define_uses_small_exem,
    dnx_data_field_base_ipmf2_define_uses_large_exem,
    dnx_data_field_base_ipmf2_define_dir_ext_single_key_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf2_define_nof
} dnx_data_field_base_ipmf2_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_ffc'
 * Number of FFC's per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_ffc_groups_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ipmf2', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_ffc_group_one_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ipmf2', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_ffc_group_one_upper_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_keys_alloc_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_keys_alloc_for_tcam_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_keys_alloc_for_exem_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_dir_ext
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_dir_ext'
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_dir_ext - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_keys_alloc_for_dir_ext_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_mdb_dt
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_mdb_dt'
 * Number of keys available for allocation for use by this specific PMF stage for MDB_DT access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_mdb_dt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_keys_alloc_for_mdb_dt_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_cs_lines_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_contexts'
 * Number of contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_ipmf2', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_program_selection_cam_mask_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_qualifiers_get(
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_80B_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_key_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_key_zone_bits_get(
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf2', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_fes_key_select_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf2', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_fes_shift_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_uses_small_exem_get(
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_uses_large_exem_get(
    int unit);

/**
 * \brief returns define data of dir_ext_single_key_size
 * Module - 'field', Submodule - 'base_ipmf2', data - 'dir_ext_single_key_size'
 * Single key size used for Direct Extraction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_dir_ext_single_key_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf2_table_nof
} dnx_data_field_base_ipmf2_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE BASE_IPMF3:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_base_ipmf3_feature_get(
    int unit,
    dnx_data_field_base_ipmf3_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_base_ipmf3_define_nof_ffc,
    dnx_data_field_base_ipmf3_define_nof_ffc_groups,
    dnx_data_field_base_ipmf3_define_ffc_group_one_lower,
    dnx_data_field_base_ipmf3_define_ffc_group_one_upper,
    dnx_data_field_base_ipmf3_define_nof_keys,
    dnx_data_field_base_ipmf3_define_nof_keys_alloc,
    dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_tcam,
    dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_exem,
    dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_dir_ext,
    dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_mdb_dt,
    dnx_data_field_base_ipmf3_define_nof_masks_per_fes,
    dnx_data_field_base_ipmf3_define_nof_fes_id_per_array,
    dnx_data_field_base_ipmf3_define_nof_fes_array,
    dnx_data_field_base_ipmf3_define_nof_fes_instruction_per_context,
    dnx_data_field_base_ipmf3_define_nof_fes_programs,
    dnx_data_field_base_ipmf3_define_nof_prog_per_fes,
    dnx_data_field_base_ipmf3_define_program_selection_cam_mask_nof_bits,
    dnx_data_field_base_ipmf3_define_cs_scratch_pad_size,
    dnx_data_field_base_ipmf3_define_nof_contexts,
    dnx_data_field_base_ipmf3_define_nof_cs_lines,
    dnx_data_field_base_ipmf3_define_nof_actions,
    dnx_data_field_base_ipmf3_define_nof_qualifiers,
    dnx_data_field_base_ipmf3_define_nof_80B_zones,
    dnx_data_field_base_ipmf3_define_nof_key_zones,
    dnx_data_field_base_ipmf3_define_nof_key_zone_bits,
    dnx_data_field_base_ipmf3_define_nof_bits_in_fes_action,
    dnx_data_field_base_ipmf3_define_nof_bits_in_fes_key_select,
    dnx_data_field_base_ipmf3_define_nof_fes_key_selects_on_one_actions_line,
    dnx_data_field_base_ipmf3_define_default_strength,
    dnx_data_field_base_ipmf3_define_nof_out_lif_ranges,
    dnx_data_field_base_ipmf3_define_fes_key_select_for_zero_bit,
    dnx_data_field_base_ipmf3_define_fes_shift_for_zero_bit,
    dnx_data_field_base_ipmf3_define_uses_small_exem,
    dnx_data_field_base_ipmf3_define_uses_large_exem,
    dnx_data_field_base_ipmf3_define_fes_instruction_size,
    dnx_data_field_base_ipmf3_define_fes_pgm_id_offset,
    dnx_data_field_base_ipmf3_define_dir_ext_single_key_size,
    dnx_data_field_base_ipmf3_define_nof_fes_used_by_sdk,

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf3_define_nof
} dnx_data_field_base_ipmf3_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_ffc'
 * Number of FFC's. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_ffc_groups_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ipmf3', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_ffc_group_one_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ipmf3', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_ffc_group_one_upper_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_keys_alloc_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_keys_alloc_for_tcam_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_keys_alloc_for_exem_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_dir_ext
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_dir_ext'
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_dir_ext - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_keys_alloc_for_dir_ext_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_mdb_dt
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_mdb_dt'
 * Number of keys available for allocation for use by this specific PMF stage for MDB_DT access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_mdb_dt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_keys_alloc_for_mdb_dt_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_fes_programs_get(
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_prog_per_fes_get(
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_ipmf3', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_program_selection_cam_mask_nof_bits_get(
    int unit);

/**
 * \brief returns define data of cs_scratch_pad_size
 * Module - 'field', Submodule - 'base_ipmf3', data - 'cs_scratch_pad_size'
 * Number of bits taken from general data for context selection.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cs_scratch_pad_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_cs_scratch_pad_size_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_contexts'
 * Number of Ingress PMF_B programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_cs_lines_get(
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_actions_get(
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_qualifiers_get(
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_80B_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_key_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_key_zone_bits_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_bits_in_fes_action_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_bits_in_fes_key_select_get(
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can go into one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_fes_key_selects_on_one_actions_line_get(
    int unit);

/**
 * \brief returns define data of default_strength
 * Module - 'field', Submodule - 'base_ipmf3', data - 'default_strength'
 * Default value for PMF strength. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_default_strength_get(
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_out_lif_ranges'
 * Number of ranges for Out Lif. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_out_lif_ranges_get(
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_fes_key_select_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_fes_shift_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_uses_small_exem_get(
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_uses_large_exem_get(
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_fes_instruction_size_get(
    int unit);

/**
 * \brief returns define data of fes_pgm_id_offset
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_pgm_id_offset'
 * FES Program ID offset pointing to IPPD_PMF_FES_PROGRAMm->FES_2ND_INSTRUCTION_LSB_ADDRESSf.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_pgm_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_fes_pgm_id_offset_get(
    int unit);

/**
 * \brief returns define data of dir_ext_single_key_size
 * Module - 'field', Submodule - 'base_ipmf3', data - 'dir_ext_single_key_size'
 * Single key size used for Direct Extraction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_dir_ext_single_key_size_get(
    int unit);

/**
 * \brief returns numeric data of nof_fes_used_by_sdk
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_used_by_sdk'
 * nof fe used by sdk in ipmf3 can be changed per system header soc property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_used_by_sdk - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_fes_used_by_sdk_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf3_table_nof
} dnx_data_field_base_ipmf3_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE BASE_EPMF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_base_epmf_feature_get(
    int unit,
    dnx_data_field_base_epmf_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_base_epmf_define_nof_ffc,
    dnx_data_field_base_epmf_define_nof_ffc_groups,
    dnx_data_field_base_epmf_define_ffc_group_one_lower,
    dnx_data_field_base_epmf_define_ffc_group_one_upper,
    dnx_data_field_base_epmf_define_nof_keys,
    dnx_data_field_base_epmf_define_nof_keys_alloc,
    dnx_data_field_base_epmf_define_nof_keys_alloc_for_tcam,
    dnx_data_field_base_epmf_define_nof_keys_alloc_for_exem,
    dnx_data_field_base_epmf_define_nof_keys_alloc_for_dir_ext,
    dnx_data_field_base_epmf_define_nof_masks_per_fes,
    dnx_data_field_base_epmf_define_nof_fes_id_per_array,
    dnx_data_field_base_epmf_define_nof_fes_array,
    dnx_data_field_base_epmf_define_nof_fes_instruction_per_context,
    dnx_data_field_base_epmf_define_nof_fes_programs,
    dnx_data_field_base_epmf_define_nof_prog_per_fes,
    dnx_data_field_base_epmf_define_program_selection_cam_mask_nof_bits,
    dnx_data_field_base_epmf_define_nof_cs_lines,
    dnx_data_field_base_epmf_define_nof_contexts,
    dnx_data_field_base_epmf_define_nof_actions,
    dnx_data_field_base_epmf_define_nof_qualifiers,
    dnx_data_field_base_epmf_define_nof_80B_zones,
    dnx_data_field_base_epmf_define_nof_key_zones,
    dnx_data_field_base_epmf_define_nof_key_zone_bits,
    dnx_data_field_base_epmf_define_nof_bits_in_fes_action,
    dnx_data_field_base_epmf_define_nof_bits_in_fes_key_select,
    dnx_data_field_base_epmf_define_nof_fes_key_selects_on_one_actions_line,
    dnx_data_field_base_epmf_define_nof_l4_ops_ranges_legacy,
    dnx_data_field_base_epmf_define_fes_key_select_for_zero_bit,
    dnx_data_field_base_epmf_define_fes_shift_for_zero_bit,
    dnx_data_field_base_epmf_define_uses_small_exem,
    dnx_data_field_base_epmf_define_uses_large_exem,
    dnx_data_field_base_epmf_define_fes_instruction_size,
    dnx_data_field_base_epmf_define_fes_pgm_id_offset,
    dnx_data_field_base_epmf_define_dir_ext_single_key_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_base_epmf_define_nof
} dnx_data_field_base_epmf_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_ffc'
 * Number of FFC's. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_ffc_groups_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_epmf', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_ffc_group_one_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_epmf', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_ffc_group_one_upper_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_keys_alloc_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_keys_alloc_for_tcam_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_keys_alloc_for_exem_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_dir_ext
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc_for_dir_ext'
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_dir_ext - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_keys_alloc_for_dir_ext_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_fes_programs_get(
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_prog_per_fes_get(
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_epmf', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory EGQ_PMF_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_program_selection_cam_mask_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_cs_lines_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_contexts'
 * Number of Egress contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_actions_get(
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_qualifiers_get(
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_80B_zones'
 * Number of Egress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_80B_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_key_zones'
 * Number of Egress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_key_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_key_zone_bits'
 * Number of Egress PMF key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_key_zone_bits_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_bits_in_fes_action_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_bits_in_fes_key_select_get(
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can applied on one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_fes_key_selects_on_one_actions_line_get(
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges_legacy
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_l4_ops_ranges_legacy'
 * Number of ranges for L4 Ops legacy. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges_legacy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_l4_ops_ranges_legacy_get(
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_fes_key_select_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_fes_shift_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_uses_small_exem_get(
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_uses_large_exem_get(
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_fes_instruction_size_get(
    int unit);

/**
 * \brief returns define data of fes_pgm_id_offset
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_pgm_id_offset'
 * FES Program ID offset pointing to ERPP_PMF_FES_PROGRAMmm->FES_2ND_INSTRUCTION_LSB_ADDRESSf.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_pgm_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_fes_pgm_id_offset_get(
    int unit);

/**
 * \brief returns define data of dir_ext_single_key_size
 * Module - 'field', Submodule - 'base_epmf', data - 'dir_ext_single_key_size'
 * Single key size used for Direct Extraction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_dir_ext_single_key_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_epmf_table_nof
} dnx_data_field_base_epmf_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE BASE_IFWD2:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_base_ifwd2_feature_get(
    int unit,
    dnx_data_field_base_ifwd2_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_base_ifwd2_define_nof_ffc,
    dnx_data_field_base_ifwd2_define_nof_ffc_groups,
    dnx_data_field_base_ifwd2_define_ffc_group_one_lower,
    dnx_data_field_base_ifwd2_define_ffc_group_one_upper,
    dnx_data_field_base_ifwd2_define_nof_keys,
    dnx_data_field_base_ifwd2_define_nof_contexts,
    dnx_data_field_base_ifwd2_define_nof_cs_lines,

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ifwd2_define_nof
} dnx_data_field_base_ifwd2_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_ffc'
 * Number of FFC's in this specific IFWD2 stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_nof_ffc_groups_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ifwd2', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_ffc_group_one_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ifwd2', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_ffc_group_one_upper_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_keys'
 * Number of keys available for allocation for use by this specific IFWD2 stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_contexts'
 * Number of KBP ACL contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_nof_cs_lines_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ifwd2_table_nof
} dnx_data_field_base_ifwd2_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE STAGE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_stage_feature_get(
    int unit,
    dnx_data_field_stage_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_stage_define_nof
} dnx_data_field_stage_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_stage_table_stage_info,

    /**
     * Must be last one!
     */
    _dnx_data_field_stage_table_nof
} dnx_data_field_stage_table_e;

/* Get Data */
/**
 * \brief get table stage_info entry 
 * Per stage information
 * 
 * \param [in] unit - unit #
 * \param [in] stage - Field stage enum
 * 
 * \return
 *     stage_info - returns the relevant entry values grouped in struct - see dnx_data_field_stage_stage_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_stage_stage_info_t * dnx_data_field_stage_stage_info_get(
    int unit,
    int stage);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'stage', table - 'stage_info'
 * Per stage information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_stage_stage_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)stage_info info
 * Per stage information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stage_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_stage_stage_info_info_get(
    int unit);

/*
 * SUBMODULE KBP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_kbp_feature_get(
    int unit,
    dnx_data_field_kbp_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_kbp_define_nof_fgs,
    dnx_data_field_kbp_define_max_single_key_size,
    dnx_data_field_kbp_define_nof_acl_keys_master_max,
    dnx_data_field_kbp_define_nof_acl_keys_fg_max,
    dnx_data_field_kbp_define_min_acl_nof_ffc,
    dnx_data_field_kbp_define_max_fwd_context_num_for_one_apptype,
    dnx_data_field_kbp_define_max_acl_context_num,
    dnx_data_field_kbp_define_size_apptype_profile_id,
    dnx_data_field_kbp_define_key_bmp,
    dnx_data_field_kbp_define_apptype_user_1st,
    dnx_data_field_kbp_define_apptype_user_nof,
    dnx_data_field_kbp_define_max_payload_size_per_opcode,

    /**
     * Must be last one!
     */
    _dnx_data_field_kbp_define_nof
} dnx_data_field_kbp_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_fgs
 * Module - 'field', Submodule - 'kbp', data - 'nof_fgs'
 * Number of External TCAM Field Groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fgs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_nof_fgs_get(
    int unit);

/**
 * \brief returns define data of max_single_key_size
 * Module - 'field', Submodule - 'kbp', data - 'max_single_key_size'
 * Maximum single key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_max_single_key_size_get(
    int unit);

/**
 * \brief returns define data of nof_acl_keys_master_max
 * Module - 'field', Submodule - 'kbp', data - 'nof_acl_keys_master_max'
 * The maximum number of keys that can be used by ACL (not FWD) in KBP for a single context
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_acl_keys_master_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_nof_acl_keys_master_max_get(
    int unit);

/**
 * \brief returns define data of nof_acl_keys_fg_max
 * Module - 'field', Submodule - 'kbp', data - 'nof_acl_keys_fg_max'
 * The maximum number of keys that can be used by ACL (not FWD) in KBP for a single field group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_acl_keys_fg_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_nof_acl_keys_fg_max_get(
    int unit);

/**
 * \brief returns define data of min_acl_nof_ffc
 * Module - 'field', Submodule - 'kbp', data - 'min_acl_nof_ffc'
 * Minimum number of FFC's that should be allocated for each context for ACL purposes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_acl_nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_min_acl_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of max_fwd_context_num_for_one_apptype
 * Module - 'field', Submodule - 'kbp', data - 'max_fwd_context_num_for_one_apptype'
 * Maximum number of fwd contexts that could be mapped to an apptype 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fwd_context_num_for_one_apptype - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_max_fwd_context_num_for_one_apptype_get(
    int unit);

/**
 * \brief returns define data of max_acl_context_num
 * Module - 'field', Submodule - 'kbp', data - 'max_acl_context_num'
 * Maximum number of ACL contexts in the KBP 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_acl_context_num - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_max_acl_context_num_get(
    int unit);

/**
 * \brief returns define data of size_apptype_profile_id
 * Module - 'field', Submodule - 'kbp', data - 'size_apptype_profile_id'
 * Size in bits of the apptype profile ID (based on iFED2 ACL context)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     size_apptype_profile_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_size_apptype_profile_id_get(
    int unit);

/**
 * \brief returns define data of key_bmp
 * Module - 'field', Submodule - 'kbp', data - 'key_bmp'
 * bitmap of the key IDs used by the KBP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_bmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_key_bmp_get(
    int unit);

/**
 * \brief returns define data of apptype_user_1st
 * Module - 'field', Submodule - 'kbp', data - 'apptype_user_1st'
 * First User defined Apptype id to avoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     apptype_user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_apptype_user_1st_get(
    int unit);

/**
 * \brief returns define data of apptype_user_nof
 * Module - 'field', Submodule - 'kbp', data - 'apptype_user_nof'
 * Number of user Defined apptypes that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     apptype_user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_apptype_user_nof_get(
    int unit);

/**
 * \brief returns define data of max_payload_size_per_opcode
 * Module - 'field', Submodule - 'kbp', data - 'max_payload_size_per_opcode'
 * The total payload size of the KBP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_payload_size_per_opcode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_max_payload_size_per_opcode_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_kbp_table_ffc_to_quad_and_group_map,

    /**
     * Must be last one!
     */
    _dnx_data_field_kbp_table_nof
} dnx_data_field_kbp_table_e;

/* Get Data */
/**
 * \brief get table ffc_to_quad_and_group_map entry 
 * Mapping of the ffc id to its quad anad group
 * 
 * \param [in] unit - unit #
 * \param [in] ffc_id - Id of the required ffc
 * 
 * \return
 *     ffc_to_quad_and_group_map - returns the relevant entry values grouped in struct - see dnx_data_field_kbp_ffc_to_quad_and_group_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_kbp_ffc_to_quad_and_group_map_t * dnx_data_field_kbp_ffc_to_quad_and_group_map_get(
    int unit,
    int ffc_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'kbp', table - 'ffc_to_quad_and_group_map'
 * Mapping of the ffc id to its quad anad group
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_kbp_ffc_to_quad_and_group_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)ffc_to_quad_and_group_map info
 * Mapping of the ffc id to its quad anad group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_to_quad_and_group_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_kbp_ffc_to_quad_and_group_map_info_get(
    int unit);

/*
 * SUBMODULE TCAM:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_tcam_feature_get(
    int unit,
    dnx_data_field_tcam_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_tcam_define_key_size_half,
    dnx_data_field_tcam_define_key_size_single,
    dnx_data_field_tcam_define_key_size_double,
    dnx_data_field_tcam_define_dt_max_key_size,
    dnx_data_field_tcam_define_action_size_half,
    dnx_data_field_tcam_define_action_size_single,
    dnx_data_field_tcam_define_action_size_double,
    dnx_data_field_tcam_define_key_mode_size,
    dnx_data_field_tcam_define_entry_size_single_key_hw,
    dnx_data_field_tcam_define_entry_size_single_valid_bits_hw,
    dnx_data_field_tcam_define_entry_size_half_payload_hw,
    dnx_data_field_tcam_define_hw_bank_size,
    dnx_data_field_tcam_define_small_bank_size,
    dnx_data_field_tcam_define_nof_big_bank_lines,
    dnx_data_field_tcam_define_nof_small_bank_lines,
    dnx_data_field_tcam_define_nof_big_banks,
    dnx_data_field_tcam_define_nof_small_banks,
    dnx_data_field_tcam_define_nof_banks,
    dnx_data_field_tcam_define_nof_payload_tables,
    dnx_data_field_tcam_define_nof_access_profiles,
    dnx_data_field_tcam_define_action_width_selector_size,
    dnx_data_field_tcam_define_cascaded_data_nof_bits,
    dnx_data_field_tcam_define_big_bank_key_nof_bits,
    dnx_data_field_tcam_define_nof_entries_160_bits,
    dnx_data_field_tcam_define_nof_entries_80_bits,
    dnx_data_field_tcam_define_tcam_banks_size,
    dnx_data_field_tcam_define_tcam_banks_last_index,
    dnx_data_field_tcam_define_nof_tcam_handlers,
    dnx_data_field_tcam_define_max_prefix_size,
    dnx_data_field_tcam_define_max_prefix_value,
    dnx_data_field_tcam_define_nof_keys_in_double_key,
    dnx_data_field_tcam_define_nof_keys_max,
    dnx_data_field_tcam_define_access_profile_half_key_mode,
    dnx_data_field_tcam_define_access_profile_single_key_mode,
    dnx_data_field_tcam_define_access_profile_double_key_mode,
    dnx_data_field_tcam_define_tcam_entries_per_hit_indication_entry,
    dnx_data_field_tcam_define_max_tcam_priority,
    dnx_data_field_tcam_define_nof_big_banks_srams,
    dnx_data_field_tcam_define_nof_small_banks_srams,
    dnx_data_field_tcam_define_nof_big_bank_lines_per_sram,
    dnx_data_field_tcam_define_nof_small_bank_lines_per_sram,
    dnx_data_field_tcam_define_app_db_id_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_tcam_define_nof
} dnx_data_field_tcam_define_e;

/* Get Data */
/**
 * \brief returns define data of key_size_half
 * Module - 'field', Submodule - 'tcam', data - 'key_size_half'
 * Half TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_half - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_key_size_half_get(
    int unit);

/**
 * \brief returns define data of key_size_single
 * Module - 'field', Submodule - 'tcam', data - 'key_size_single'
 * Single TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_single - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_key_size_single_get(
    int unit);

/**
 * \brief returns define data of key_size_double
 * Module - 'field', Submodule - 'tcam', data - 'key_size_double'
 * Double TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_double - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_key_size_double_get(
    int unit);

/**
 * \brief returns define data of dt_max_key_size
 * Module - 'field', Submodule - 'tcam', data - 'dt_max_key_size'
 * Maximum key size for TCAM DT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dt_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_dt_max_key_size_get(
    int unit);

/**
 * \brief returns define data of action_size_half
 * Module - 'field', Submodule - 'tcam', data - 'action_size_half'
 * When the key size is half key (80b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_half - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_action_size_half_get(
    int unit);

/**
 * \brief returns define data of action_size_single
 * Module - 'field', Submodule - 'tcam', data - 'action_size_single'
 * When the key size is single key (160b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_single - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_action_size_single_get(
    int unit);

/**
 * \brief returns define data of action_size_double
 * Module - 'field', Submodule - 'tcam', data - 'action_size_double'
 * When the key size is double key (320b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_double - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_action_size_double_get(
    int unit);

/**
 * \brief returns define data of key_mode_size
 * Module - 'field', Submodule - 'tcam', data - 'key_mode_size'
 * Number of bits representing the entry size for each half entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_mode_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_key_mode_size_get(
    int unit);

/**
 * \brief returns define data of entry_size_single_key_hw
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_single_key_hw'
 * The full key size in HW, includingd entry size field, not including payload and valid bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_single_key_hw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_entry_size_single_key_hw_get(
    int unit);

/**
 * \brief returns define data of entry_size_single_valid_bits_hw
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_single_valid_bits_hw'
 * The size of the valid bits in HW.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_single_valid_bits_hw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_entry_size_single_valid_bits_hw_get(
    int unit);

/**
 * \brief returns define data of entry_size_half_payload_hw
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_half_payload_hw'
 * The full payload size in HW for half an entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_half_payload_hw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_entry_size_half_payload_hw_get(
    int unit);

/**
 * \brief returns define data of hw_bank_size
 * Module - 'field', Submodule - 'tcam', data - 'hw_bank_size'
 * Size of a TCAM bank in HW
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hw_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_hw_bank_size_get(
    int unit);

/**
 * \brief returns define data of small_bank_size
 * Module - 'field', Submodule - 'tcam', data - 'small_bank_size'
 * Number of entries per small TCAM bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_small_bank_size_get(
    int unit);

/**
 * \brief returns define data of nof_big_bank_lines
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_bank_lines'
 * Number of TCAM big bank lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_bank_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_big_bank_lines_get(
    int unit);

/**
 * \brief returns define data of nof_small_bank_lines
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_bank_lines'
 * Number of TCAM small bank lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_bank_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_small_bank_lines_get(
    int unit);

/**
 * \brief returns define data of nof_big_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_banks'
 * Number of TCAM big banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_big_banks_get(
    int unit);

/**
 * \brief returns define data of nof_small_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_banks'
 * Number of TCAM small banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_small_banks_get(
    int unit);

/**
 * \brief returns define data of nof_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_banks'
 * Number of TCAM banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_banks_get(
    int unit);

/**
 * \brief returns define data of nof_payload_tables
 * Module - 'field', Submodule - 'tcam', data - 'nof_payload_tables'
 * Number of action tables
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_payload_tables - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_payload_tables_get(
    int unit);

/**
 * \brief returns define data of nof_access_profiles
 * Module - 'field', Submodule - 'tcam', data - 'nof_access_profiles'
 * Number of TCAM access profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_access_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_access_profiles_get(
    int unit);

/**
 * \brief returns define data of action_width_selector_size
 * Module - 'field', Submodule - 'tcam', data - 'action_width_selector_size'
 * The action width selector size for each bank in each access profile, each bit represents the corresponding 32 bit in the action table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_width_selector_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_action_width_selector_size_get(
    int unit);

/**
 * \brief returns define data of cascaded_data_nof_bits
 * Module - 'field', Submodule - 'tcam', data - 'cascaded_data_nof_bits'
 * Number of TCAM cascaded data bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cascaded_data_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_cascaded_data_nof_bits_get(
    int unit);

/**
 * \brief returns define data of big_bank_key_nof_bits
 * Module - 'field', Submodule - 'tcam', data - 'big_bank_key_nof_bits'
 * Number of TCAM big bank key bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     big_bank_key_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_big_bank_key_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_entries_160_bits
 * Module - 'field', Submodule - 'tcam', data - 'nof_entries_160_bits'
 * Number of 160 bits TCAM entries; Value: (nof_big_banks*nof_big_bank_lines)+(nof_small_banks*nof_small_bank_lines)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_entries_160_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_entries_160_bits_get(
    int unit);

/**
 * \brief returns define data of nof_entries_80_bits
 * Module - 'field', Submodule - 'tcam', data - 'nof_entries_80_bits'
 * Number of 80 bits TCAM entries; Value: (2*nof_big_banks*nof_big_bank_lines)+(2*nof_small_banks*nof_small_bank_lines)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_entries_80_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_entries_80_bits_get(
    int unit);

/**
 * \brief returns define data of tcam_banks_size
 * Module - 'field', Submodule - 'tcam', data - 'tcam_banks_size'
 * The size of TCAM_TCAM_BANK which is equal to (nof_big_banks + nof_small_banks) * nof_big_bank_lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_banks_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_tcam_banks_size_get(
    int unit);

/**
 * \brief returns define data of tcam_banks_last_index
 * Module - 'field', Submodule - 'tcam', data - 'tcam_banks_last_index'
 * Last index available in TCAM banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_banks_last_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_tcam_banks_last_index_get(
    int unit);

/**
 * \brief returns define data of nof_tcam_handlers
 * Module - 'field', Submodule - 'tcam', data - 'nof_tcam_handlers'
 * Number of TCAM handlers in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_handlers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_tcam_handlers_get(
    int unit);

/**
 * \brief returns define data of max_prefix_size
 * Module - 'field', Submodule - 'tcam', data - 'max_prefix_size'
 * Maximum prefix size in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_max_prefix_size_get(
    int unit);

/**
 * \brief returns define data of max_prefix_value
 * Module - 'field', Submodule - 'tcam', data - 'max_prefix_value'
 * Maximum prefix value in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_max_prefix_value_get(
    int unit);

/**
 * \brief returns define data of nof_keys_in_double_key
 * Module - 'field', Submodule - 'tcam', data - 'nof_keys_in_double_key'
 * Number of 160'b key's in double key
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_in_double_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_keys_in_double_key_get(
    int unit);

/**
 * \brief returns define data of nof_keys_max
 * Module - 'field', Submodule - 'tcam', data - 'nof_keys_max'
 * Number of 160'b key's in one search lookup
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_keys_max_get(
    int unit);

/**
 * \brief returns define data of access_profile_half_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_half_key_mode'
 * Half key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_half_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_access_profile_half_key_mode_get(
    int unit);

/**
 * \brief returns define data of access_profile_single_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_single_key_mode'
 * Single key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_single_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_access_profile_single_key_mode_get(
    int unit);

/**
 * \brief returns define data of access_profile_double_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_double_key_mode'
 * Double key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_double_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_access_profile_double_key_mode_get(
    int unit);

/**
 * \brief returns define data of tcam_entries_per_hit_indication_entry
 * Module - 'field', Submodule - 'tcam', data - 'tcam_entries_per_hit_indication_entry'
 * Number of entries in TCAM and CS TCAM HIT indication memories line (8b bmp).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_entries_per_hit_indication_entry - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_tcam_entries_per_hit_indication_entry_get(
    int unit);

/**
 * \brief returns define data of max_tcam_priority
 * Module - 'field', Submodule - 'tcam', data - 'max_tcam_priority'
 * The biggest valid value for the priority of a TCAM entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tcam_priority - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_max_tcam_priority_get(
    int unit);

/**
 * \brief returns define data of nof_big_banks_srams
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_banks_srams'
 * Number of SRAMs for big banks.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_banks_srams - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_big_banks_srams_get(
    int unit);

/**
 * \brief returns define data of nof_small_banks_srams
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_banks_srams'
 * Number of SRAMs for small banks.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_banks_srams - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_small_banks_srams_get(
    int unit);

/**
 * \brief returns define data of nof_big_bank_lines_per_sram
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_bank_lines_per_sram'
 * Number of big bank lines per SRAM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_bank_lines_per_sram - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_big_bank_lines_per_sram_get(
    int unit);

/**
 * \brief returns define data of nof_small_bank_lines_per_sram
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_bank_lines_per_sram'
 * Number of small bank lines per SRAM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_bank_lines_per_sram - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_small_bank_lines_per_sram_get(
    int unit);

/**
 * \brief returns define data of app_db_id_size
 * Module - 'field', Submodule - 'tcam', data - 'app_db_id_size'
 * Size in bits of the app_db_id.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_app_db_id_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_tcam_table_nof
} dnx_data_field_tcam_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE GROUP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_group_feature_get(
    int unit,
    dnx_data_field_group_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_group_define_nof_fgs,
    dnx_data_field_group_define_nof_action_per_fg,
    dnx_data_field_group_define_nof_quals_per_fg,
    dnx_data_field_group_define_nof_keys_per_fg_max,
    dnx_data_field_group_define_id_fec,
    dnx_data_field_group_define_payload_max_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_group_define_nof
} dnx_data_field_group_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_fgs
 * Module - 'field', Submodule - 'group', data - 'nof_fgs'
 * Number of Field Groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fgs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_group_nof_fgs_get(
    int unit);

/**
 * \brief returns define data of nof_action_per_fg
 * Module - 'field', Submodule - 'group', data - 'nof_action_per_fg'
 * Number of action per Field Group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_fg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_group_nof_action_per_fg_get(
    int unit);

/**
 * \brief returns define data of nof_quals_per_fg
 * Module - 'field', Submodule - 'group', data - 'nof_quals_per_fg'
 * Number of qualifiers per Field Group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_quals_per_fg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_group_nof_quals_per_fg_get(
    int unit);

/**
 * \brief returns define data of nof_keys_per_fg_max
 * Module - 'field', Submodule - 'group', data - 'nof_keys_per_fg_max'
 * Maximum number of keys (KBRs) a field group can have.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_per_fg_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_group_nof_keys_per_fg_max_get(
    int unit);

/**
 * \brief returns define data of id_fec
 * Module - 'field', Submodule - 'group', data - 'id_fec'
 * FEC is being used in more then one context, hence must be created with_id so that other applications can re-use the FG
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     id_fec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_group_id_fec_get(
    int unit);

/**
 * \brief returns define data of payload_max_size
 * Module - 'field', Submodule - 'group', data - 'payload_max_size'
 * Maximum Payload size a field group can have.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     payload_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_group_payload_max_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_group_table_nof
} dnx_data_field_group_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE EFES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_efes_feature_get(
    int unit,
    dnx_data_field_efes_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_efes_define_max_nof_key_selects_per_field_io,

    /**
     * Must be last one!
     */
    _dnx_data_field_efes_define_nof
} dnx_data_field_efes_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_key_selects_per_field_io
 * Module - 'field', Submodule - 'efes', data - 'max_nof_key_selects_per_field_io'
 * Number of key selects in table for each field IO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_key_selects_per_field_io - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_efes_max_nof_key_selects_per_field_io_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_efes_table_key_select_properties,

    /**
     * Must be last one!
     */
    _dnx_data_field_efes_table_nof
} dnx_data_field_efes_table_e;

/* Get Data */
/**
 * \brief get table key_select_properties entry 
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * \param [in] stage - Field stage enum
 * \param [in] field_io - Identifies the source of the information
 * 
 * \return
 *     key_select_properties - returns the relevant entry values grouped in struct - see dnx_data_field_efes_key_select_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_efes_key_select_properties_t * dnx_data_field_efes_key_select_properties_get(
    int unit,
    int stage,
    int field_io);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'efes', table - 'key_select_properties'
 * The properties of the different key select options
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_efes_key_select_properties_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)key_select_properties info
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_select_properties - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_efes_key_select_properties_info_get(
    int unit);

/*
 * SUBMODULE FEM:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_fem_feature_get(
    int unit,
    dnx_data_field_fem_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_fem_define_max_nof_key_selects_per_field_io,

    /**
     * Must be last one!
     */
    _dnx_data_field_fem_define_nof
} dnx_data_field_fem_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_key_selects_per_field_io
 * Module - 'field', Submodule - 'fem', data - 'max_nof_key_selects_per_field_io'
 * Number of key selects in table for each field IO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_key_selects_per_field_io - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_fem_max_nof_key_selects_per_field_io_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_fem_table_key_select_properties,

    /**
     * Must be last one!
     */
    _dnx_data_field_fem_table_nof
} dnx_data_field_fem_table_e;

/* Get Data */
/**
 * \brief get table key_select_properties entry 
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * \param [in] field_io - Identifies the source of the information
 * 
 * \return
 *     key_select_properties - returns the relevant entry values grouped in struct - see dnx_data_field_fem_key_select_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_fem_key_select_properties_t * dnx_data_field_fem_key_select_properties_get(
    int unit,
    int field_io);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'fem', table - 'key_select_properties'
 * The properties of the different key select options
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_fem_key_select_properties_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)key_select_properties info
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_select_properties - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_fem_key_select_properties_info_get(
    int unit);

/*
 * SUBMODULE CONTEXT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_context_feature_get(
    int unit,
    dnx_data_field_context_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_context_define_default_context,
    dnx_data_field_context_define_default_itmh_context,
    dnx_data_field_context_define_default_itmh_pph_context,
    dnx_data_field_context_define_default_j1_itmh_context,
    dnx_data_field_context_define_default_j1_itmh_pph_context,
    dnx_data_field_context_define_default_stacking_context,
    dnx_data_field_context_define_default_oam_context,
    dnx_data_field_context_define_default_oam_reflector_context,
    dnx_data_field_context_define_default_oam_upmep_context,
    dnx_data_field_context_define_default_j1_learning_2ndpass_context,
    dnx_data_field_context_define_default_rch_remove_context,
    dnx_data_field_context_define_default_nat_context,
    dnx_data_field_context_define_nof_hash_keys,

    /**
     * Must be last one!
     */
    _dnx_data_field_context_define_nof
} dnx_data_field_context_define_e;

/* Get Data */
/**
 * \brief returns define data of default_context
 * Module - 'field', Submodule - 'context', data - 'default_context'
 * Default Context Id (used for Ethernet Packets)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_context_get(
    int unit);

/**
 * \brief returns define data of default_itmh_context
 * Module - 'field', Submodule - 'context', data - 'default_itmh_context'
 * Default Context Id for ITMH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_itmh_context_get(
    int unit);

/**
 * \brief returns define data of default_itmh_pph_context
 * Module - 'field', Submodule - 'context', data - 'default_itmh_pph_context'
 * Default Context Id for ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_itmh_pph_context_get(
    int unit);

/**
 * \brief returns define data of default_j1_itmh_context
 * Module - 'field', Submodule - 'context', data - 'default_j1_itmh_context'
 * Default Context Id for J1 ITMH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_j1_itmh_context_get(
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_context
 * Module - 'field', Submodule - 'context', data - 'default_j1_itmh_pph_context'
 * Default Context Id for J1 ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_j1_itmh_pph_context_get(
    int unit);

/**
 * \brief returns define data of default_stacking_context
 * Module - 'field', Submodule - 'context', data - 'default_stacking_context'
 * Default Context Id for Stacking Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_stacking_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_stacking_context_get(
    int unit);

/**
 * \brief returns define data of default_oam_context
 * Module - 'field', Submodule - 'context', data - 'default_oam_context'
 * Default Context Id for OAM Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_oam_context_get(
    int unit);

/**
 * \brief returns define data of default_oam_reflector_context
 * Module - 'field', Submodule - 'context', data - 'default_oam_reflector_context'
 * Default Context Id for OAM downmep reflector Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_reflector_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_oam_reflector_context_get(
    int unit);

/**
 * \brief returns define data of default_oam_upmep_context
 * Module - 'field', Submodule - 'context', data - 'default_oam_upmep_context'
 * Default Context Id for OAM upmep Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_upmep_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_oam_upmep_context_get(
    int unit);

/**
 * \brief returns define data of default_j1_learning_2ndpass_context
 * Module - 'field', Submodule - 'context', data - 'default_j1_learning_2ndpass_context'
 * Default Context Id for 2nd pass of J1 Learning flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_learning_2ndpass_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_j1_learning_2ndpass_context_get(
    int unit);

/**
 * \brief returns define data of default_rch_remove_context
 * Module - 'field', Submodule - 'context', data - 'default_rch_remove_context'
 * Default Context Id for packets with RCH header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_rch_remove_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_rch_remove_context_get(
    int unit);

/**
 * \brief returns define data of default_nat_context
 * Module - 'field', Submodule - 'context', data - 'default_nat_context'
 * Default Context Id for NAT packets.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_nat_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_nat_context_get(
    int unit);

/**
 * \brief returns define data of nof_hash_keys
 * Module - 'field', Submodule - 'context', data - 'nof_hash_keys'
 * Number of action keys per Hash Context.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_hash_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_nof_hash_keys_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_context_table_nof
} dnx_data_field_context_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE PRESELECTOR:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_preselector_feature_get(
    int unit,
    dnx_data_field_preselector_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_preselector_define_default_oam_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_itmh_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_itmh_pph_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_itmh_pph_oamp_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_j1_itmh_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_j1_itmh_pph_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_j1_itmh_pph_oamp_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_stacking_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_j1_learn_presel_id_1st_pass_ipmf1,
    dnx_data_field_preselector_define_default_j1_learn_presel_id_2nd_pass_ipmf1,
    dnx_data_field_preselector_define_default_nat_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_itmh_pph_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_j1_itmh_pph_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_oam_roo_ipv4_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_oam_roo_ipv6_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_j1_ipv4_mc_in_lif_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_j1_ipv6_mc_in_lif_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_rch_remove_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_j1_php_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_j1_swap_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_j1_same_port_presel_id_epmf,
    dnx_data_field_preselector_define_default_learn_limit_presel_id_epmf,
    dnx_data_field_preselector_define_num_cs_inlif_profile_entries,

    /**
     * Must be last one!
     */
    _dnx_data_field_preselector_define_nof
} dnx_data_field_preselector_define_e;

/* Get Data */
/**
 * \brief returns define data of default_oam_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for OAM Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_oam_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_itmh_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_itmh_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_itmh_pph_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMHoPPH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_itmh_pph_oamp_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_oamp_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH_J2oPPH_J2 injected Packets from OAMP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_oamp_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_itmh_pph_oamp_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_j1_itmh_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH_J1 injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_itmh_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_pph_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH_J1oPPH_J1 injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_oamp_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_pph_oamp_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH_J1oPPH_J1 injected Packets from OAMP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_oamp_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_itmh_pph_oamp_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_stacking_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_stacking_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for Stacking Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_stacking_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_stacking_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_j1_learn_presel_id_1st_pass_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_learn_presel_id_1st_pass_ipmf1'
 * Default Presel in iPMF1 Learn 1st Pass
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_learn_presel_id_1st_pass_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_learn_presel_id_1st_pass_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_j1_learn_presel_id_2nd_pass_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_learn_presel_id_2nd_pass_ipmf1'
 * Default Presel in iPMF1 Learn 2nd Pass
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_learn_presel_id_2nd_pass_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_learn_presel_id_2nd_pass_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_nat_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_nat_presel_id_ipmf1'
 * Default Presel in iPMF1 NAT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_nat_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_nat_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_itmh_pph_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_presel_id_ipmf3'
 * Default Presel Id in iPMF1 for ITMHoPPH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_pph_presel_id_ipmf3'
 * Default Presel Id in iPMF1 for ITMH_J1oPPH_J1 injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_oam_roo_ipv4_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_roo_ipv4_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 with ROO Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_roo_ipv4_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_oam_roo_ipv4_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_oam_roo_ipv6_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_roo_ipv6_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 with ROO Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_roo_ipv6_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_oam_roo_ipv6_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 without ROO Packets no RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 without ROO Packets no RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 without ROO Packets with RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 without ROO Packets with RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_j1_ipv4_mc_in_lif_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_ipv4_mc_in_lif_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 MC Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_ipv4_mc_in_lif_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_ipv4_mc_in_lif_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_j1_ipv6_mc_in_lif_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_ipv6_mc_in_lif_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 MC Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_ipv6_mc_in_lif_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_ipv6_mc_in_lif_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_rch_remove_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_rch_remove_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for packets with TCH header
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_rch_remove_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_rch_remove_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_j1_php_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_php_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for MPLS PHP Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_php_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_php_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_j1_swap_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_swap_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for MPLS SWAP Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_swap_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_swap_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_j1_same_port_presel_id_epmf
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_same_port_presel_id_epmf'
 * Default Presel in ePMF Same port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_same_port_presel_id_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_same_port_presel_id_epmf_get(
    int unit);

/**
 * \brief returns define data of default_learn_limit_presel_id_epmf
 * Module - 'field', Submodule - 'preselector', data - 'default_learn_limit_presel_id_epmf'
 * Default Presel in ePMF Learn
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_learn_limit_presel_id_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_learn_limit_presel_id_epmf_get(
    int unit);

/**
 * \brief returns define data of num_cs_inlif_profile_entries
 * Module - 'field', Submodule - 'preselector', data - 'num_cs_inlif_profile_entries'
 * The number of CS entries which are used for inlif profile mapping
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_cs_inlif_profile_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_num_cs_inlif_profile_entries_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_preselector_table_nof
} dnx_data_field_preselector_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE QUAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_qual_feature_get(
    int unit,
    dnx_data_field_qual_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_qual_define_user_1st,
    dnx_data_field_qual_define_user_nof,
    dnx_data_field_qual_define_vw_1st,
    dnx_data_field_qual_define_vw_nof,
    dnx_data_field_qual_define_max_bits_in_qual,
    dnx_data_field_qual_define_ingress_pbus_header_length,
    dnx_data_field_qual_define_egress_pbus_header_length,
    dnx_data_field_qual_define_ifwd2_pbus_size,
    dnx_data_field_qual_define_ipmf1_pbus_size,
    dnx_data_field_qual_define_ipmf2_pbus_size,
    dnx_data_field_qual_define_ipmf3_pbus_size,
    dnx_data_field_qual_define_epmf_pbus_size,
    dnx_data_field_qual_define_ingress_nof_layer_records,
    dnx_data_field_qual_define_ingress_layer_record_size,
    dnx_data_field_qual_define_egress_nof_layer_records,
    dnx_data_field_qual_define_egress_layer_record_size,
    dnx_data_field_qual_define_ac_lif_wide_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_qual_define_nof
} dnx_data_field_qual_define_e;

/* Get Data */
/**
 * \brief returns define data of user_1st
 * Module - 'field', Submodule - 'qual', data - 'user_1st'
 * First User qualifier id to avoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_user_1st_get(
    int unit);

/**
 * \brief returns define data of user_nof
 * Module - 'field', Submodule - 'qual', data - 'user_nof'
 * Number of User Define Data qualifiers that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_user_nof_get(
    int unit);

/**
 * \brief returns define data of vw_1st
 * Module - 'field', Submodule - 'qual', data - 'vw_1st'
 * First VW qualifier id to avoid overlapping with static or user defined qualifiers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_vw_1st_get(
    int unit);

/**
 * \brief returns define data of vw_nof
 * Module - 'field', Submodule - 'qual', data - 'vw_nof'
 * Number of VW qualifiers that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_vw_nof_get(
    int unit);

/**
 * \brief returns define data of max_bits_in_qual
 * Module - 'field', Submodule - 'qual', data - 'max_bits_in_qual'
 * Maximum number of bits that any qualifier can have
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_bits_in_qual - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_max_bits_in_qual_get(
    int unit);

/**
 * \brief returns define data of ingress_pbus_header_length
 * Module - 'field', Submodule - 'qual', data - 'ingress_pbus_header_length'
 * Number of bits reserved in ingress PBUS for header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_pbus_header_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ingress_pbus_header_length_get(
    int unit);

/**
 * \brief returns define data of egress_pbus_header_length
 * Module - 'field', Submodule - 'qual', data - 'egress_pbus_header_length'
 * Number of bits reserved in egress PBUS for header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_pbus_header_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_egress_pbus_header_length_get(
    int unit);

/**
 * \brief returns define data of ifwd2_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ifwd2_pbus_size'
 * Number of bits in the PBUS of iFWD2
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ifwd2_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ifwd2_pbus_size_get(
    int unit);

/**
 * \brief returns define data of ipmf1_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf1_pbus_size'
 * Number of bits in the PBUS of iPMF1
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf1_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ipmf1_pbus_size_get(
    int unit);

/**
 * \brief returns define data of ipmf2_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf2_pbus_size'
 * Number of bits in the PBUS of iPMF3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf2_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ipmf2_pbus_size_get(
    int unit);

/**
 * \brief returns define data of ipmf3_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf3_pbus_size'
 * Number of bits in the PBUS of iPMF3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf3_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ipmf3_pbus_size_get(
    int unit);

/**
 * \brief returns define data of epmf_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'epmf_pbus_size'
 * Number of bits in the PBUS of ePMF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     epmf_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_epmf_pbus_size_get(
    int unit);

/**
 * \brief returns define data of ingress_nof_layer_records
 * Module - 'field', Submodule - 'qual', data - 'ingress_nof_layer_records'
 * Number of layer records taken from the parser in ingress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ingress_nof_layer_records_get(
    int unit);

/**
 * \brief returns define data of ingress_layer_record_size
 * Module - 'field', Submodule - 'qual', data - 'ingress_layer_record_size'
 * Number of bits in each layer record in ingress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_layer_record_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ingress_layer_record_size_get(
    int unit);

/**
 * \brief returns define data of egress_nof_layer_records
 * Module - 'field', Submodule - 'qual', data - 'egress_nof_layer_records'
 * Number of layer records taken from the parser in egress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_egress_nof_layer_records_get(
    int unit);

/**
 * \brief returns define data of egress_layer_record_size
 * Module - 'field', Submodule - 'qual', data - 'egress_layer_record_size'
 * Number of bits in each layer record in egress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_layer_record_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_egress_layer_record_size_get(
    int unit);

/**
 * \brief returns define data of ac_lif_wide_size
 * Module - 'field', Submodule - 'qual', data - 'ac_lif_wide_size'
 * Size of AC_LIF_WIDE data size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ac_lif_wide_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ac_lif_wide_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_qual_table_params,
    dnx_data_field_qual_table_layer_record_info_ingress,
    dnx_data_field_qual_table_layer_record_info_egress,

    /**
     * Must be last one!
     */
    _dnx_data_field_qual_table_nof
} dnx_data_field_qual_table_e;

/* Get Data */
/**
 * \brief get table params entry 
 * Per stage Per qualifier properties
 * 
 * \param [in] unit - unit #
 * \param [in] stage - stage enum
 * \param [in] qual - dnx qualifier
 * 
 * \return
 *     params - returns the relevant entry values grouped in struct - see dnx_data_field_qual_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_qual_params_t * dnx_data_field_qual_params_get(
    int unit,
    int stage,
    int qual);

/**
 * \brief get table layer_record_info_ingress entry 
 * Information about layer record qualifiers in the ingress
 * 
 * \param [in] unit - unit #
 * \param [in] layer_record - layer record enum
 * 
 * \return
 *     layer_record_info_ingress - returns the relevant entry values grouped in struct - see dnx_data_field_qual_layer_record_info_ingress_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_qual_layer_record_info_ingress_t * dnx_data_field_qual_layer_record_info_ingress_get(
    int unit,
    int layer_record);

/**
 * \brief get table layer_record_info_egress entry 
 * Information about layer record qualifiers in the egress
 * 
 * \param [in] unit - unit #
 * \param [in] layer_record - layer record enum
 * 
 * \return
 *     layer_record_info_egress - returns the relevant entry values grouped in struct - see dnx_data_field_qual_layer_record_info_egress_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_qual_layer_record_info_egress_t * dnx_data_field_qual_layer_record_info_egress_get(
    int unit,
    int layer_record);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'qual', table - 'params'
 * Per stage Per qualifier properties
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_qual_params_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'qual', table - 'layer_record_info_ingress'
 * Information about layer record qualifiers in the ingress
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_qual_layer_record_info_ingress_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'qual', table - 'layer_record_info_egress'
 * Information about layer record qualifiers in the egress
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_qual_layer_record_info_egress_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)params info
 * Per stage Per qualifier properties
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     params - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_qual_params_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)layer_record_info_ingress info
 * Information about layer record qualifiers in the ingress
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layer_record_info_ingress - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_qual_layer_record_info_ingress_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)layer_record_info_egress info
 * Information about layer record qualifiers in the egress
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layer_record_info_egress - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_qual_layer_record_info_egress_info_get(
    int unit);

/*
 * SUBMODULE ACTION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_action_feature_get(
    int unit,
    dnx_data_field_action_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_action_define_user_1st,
    dnx_data_field_action_define_user_nof,
    dnx_data_field_action_define_vw_1st,
    dnx_data_field_action_define_vw_nof,

    /**
     * Must be last one!
     */
    _dnx_data_field_action_define_nof
} dnx_data_field_action_define_e;

/* Get Data */
/**
 * \brief returns define data of user_1st
 * Module - 'field', Submodule - 'action', data - 'user_1st'
 * First user action id to avaoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_action_user_1st_get(
    int unit);

/**
 * \brief returns define data of user_nof
 * Module - 'field', Submodule - 'action', data - 'user_nof'
 * Number of User Define Data actions that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_action_user_nof_get(
    int unit);

/**
 * \brief returns define data of vw_1st
 * Module - 'field', Submodule - 'action', data - 'vw_1st'
 * First VW action id to avoid overlapping with static or user defined qualifiers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_action_vw_1st_get(
    int unit);

/**
 * \brief returns define data of vw_nof
 * Module - 'field', Submodule - 'action', data - 'vw_nof'
 * Number of VW action that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_action_vw_nof_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_action_table_nof
} dnx_data_field_action_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE VIRTUAL_WIRE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_virtual_wire_feature_get(
    int unit,
    dnx_data_field_virtual_wire_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_virtual_wire_define_signals_nof,
    dnx_data_field_virtual_wire_define_actions_per_signal_nof,
    dnx_data_field_virtual_wire_define_general_data_user_general_containers_size,
    dnx_data_field_virtual_wire_define_ipmf1_general_data_index,

    /**
     * Must be last one!
     */
    _dnx_data_field_virtual_wire_define_nof
} dnx_data_field_virtual_wire_define_e;

/* Get Data */
/**
 * \brief returns define data of signals_nof
 * Module - 'field', Submodule - 'virtual_wire', data - 'signals_nof'
 * Number of elements in the table vw_quals.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     signals_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_virtual_wire_signals_nof_get(
    int unit);

/**
 * \brief returns define data of actions_per_signal_nof
 * Module - 'field', Submodule - 'virtual_wire', data - 'actions_per_signal_nof'
 * Maximum number of actions that write to a signal.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     actions_per_signal_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_virtual_wire_actions_per_signal_nof_get(
    int unit);

/**
 * \brief returns define data of general_data_user_general_containers_size
 * Module - 'field', Submodule - 'virtual_wire', data - 'general_data_user_general_containers_size'
 * The size in bits of the user_general part of the general_data (before the comp_general_data part).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     general_data_user_general_containers_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_virtual_wire_general_data_user_general_containers_size_get(
    int unit);

/**
 * \brief returns define data of ipmf1_general_data_index
 * Module - 'field', Submodule - 'virtual_wire', data - 'ipmf1_general_data_index'
 * The index in signal_qual_mapping table of the general data signal for iPMF1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf1_general_data_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_virtual_wire_ipmf1_general_data_index_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_virtual_wire_table_signal_mapping,

    /**
     * Must be last one!
     */
    _dnx_data_field_virtual_wire_table_nof
} dnx_data_field_virtual_wire_table_e;

/* Get Data */
/**
 * \brief get table signal_mapping entry 
 * Per stage per signal, how it maps to standard 1 qualifiers and actions
 * 
 * \param [in] unit - unit #
 * \param [in] stage - stage enum
 * \param [in] signal_id - A local index for the entry
 * 
 * \return
 *     signal_mapping - returns the relevant entry values grouped in struct - see dnx_data_field_virtual_wire_signal_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_virtual_wire_signal_mapping_t * dnx_data_field_virtual_wire_signal_mapping_get(
    int unit,
    int stage,
    int signal_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'virtual_wire', table - 'signal_mapping'
 * Per stage per signal, how it maps to standard 1 qualifiers and actions
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_virtual_wire_signal_mapping_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)signal_mapping info
 * Per stage per signal, how it maps to standard 1 qualifiers and actions
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     signal_mapping - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_virtual_wire_signal_mapping_info_get(
    int unit);

/*
 * SUBMODULE PROFILE_BITS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_profile_bits_feature_get(
    int unit,
    dnx_data_field_profile_bits_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_profile_bits_define_nof_ing_in_lif,
    dnx_data_field_profile_bits_define_nof_eg_in_lif,
    dnx_data_field_profile_bits_define_nof_ing_eth_rif,
    dnx_data_field_profile_bits_define_nof_eg_eth_rif,
    dnx_data_field_profile_bits_define_ingress_pp_port_key_gen_var_size,
    dnx_data_field_profile_bits_define_max_port_profile_size,
    dnx_data_field_profile_bits_define_nof_bits_in_port_profile,
    dnx_data_field_profile_bits_define_nof_bits_in_ingress_pp_port_general_data,
    dnx_data_field_profile_bits_define_pmf_sexem3_stage,
    dnx_data_field_profile_bits_define_pmf_map_stage,

    /**
     * Must be last one!
     */
    _dnx_data_field_profile_bits_define_nof
} dnx_data_field_profile_bits_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ing_in_lif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_ing_in_lif'
 * Number of reserved bits for Ingress FP in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ing_in_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_ing_in_lif_get(
    int unit);

/**
 * \brief returns define data of nof_eg_in_lif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_eg_in_lif'
 * Number of reserved bits for Egress FP in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eg_in_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_eg_in_lif_get(
    int unit);

/**
 * \brief returns define data of nof_ing_eth_rif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_ing_eth_rif'
 * Number of reserved bits for Ingress FP in in_rif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ing_eth_rif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_ing_eth_rif_get(
    int unit);

/**
 * \brief returns define data of nof_eg_eth_rif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_eg_eth_rif'
 * Number of reserved bits for Egress FP in in_rif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eg_eth_rif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_eg_eth_rif_get(
    int unit);

/**
 * \brief returns define data of ingress_pp_port_key_gen_var_size
 * Module - 'field', Submodule - 'profile_bits', data - 'ingress_pp_port_key_gen_var_size'
 * Number of bits available on the key_ken_per per PP port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_pp_port_key_gen_var_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_ingress_pp_port_key_gen_var_size_get(
    int unit);

/**
 * \brief returns define data of max_port_profile_size
 * Module - 'field', Submodule - 'profile_bits', data - 'max_port_profile_size'
 * The maximum number in bits of all port profiles hw memories possible
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_port_profile_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_max_port_profile_size_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_port_profile
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_bits_in_port_profile'
 * The number of bits used by the PMF for port profiles. Note that the actual number may be lower in some stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_port_profile - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_bits_in_port_profile_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_ingress_pp_port_general_data
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_bits_in_ingress_pp_port_general_data'
 * The number of bits used by the PMF for per PP port general data.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_ingress_pp_port_general_data - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_bits_in_ingress_pp_port_general_data_get(
    int unit);

/**
 * \brief returns numeric data of pmf_sexem3_stage
 * Module - 'field', Submodule - 'profile_bits', data - 'pmf_sexem3_stage'
 * Determines using SOC property if we use SEXEM3 in iPMF2 or iPMF3.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pmf_sexem3_stage - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_pmf_sexem3_stage_get(
    int unit);

/**
 * \brief returns numeric data of pmf_map_stage
 * Module - 'field', Submodule - 'profile_bits', data - 'pmf_map_stage'
 * Determines using SOC property if we use MAP in iPMF1/iPMF2 or iPMF3.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pmf_map_stage - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_pmf_map_stage_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_profile_bits_table_nof
} dnx_data_field_profile_bits_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE DIR_EXT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_dir_ext_feature_get(
    int unit,
    dnx_data_field_dir_ext_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_dir_ext_define_half_key_size,
    dnx_data_field_dir_ext_define_single_key_size,
    dnx_data_field_dir_ext_define_double_key_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_dir_ext_define_nof
} dnx_data_field_dir_ext_define_e;

/* Get Data */
/**
 * \brief returns define data of half_key_size
 * Module - 'field', Submodule - 'dir_ext', data - 'half_key_size'
 * Half key size of direct extraction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     half_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_dir_ext_half_key_size_get(
    int unit);

/**
 * \brief returns define data of single_key_size
 * Module - 'field', Submodule - 'dir_ext', data - 'single_key_size'
 * Single key size of direct extraction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_dir_ext_single_key_size_get(
    int unit);

/**
 * \brief returns define data of double_key_size
 * Module - 'field', Submodule - 'dir_ext', data - 'double_key_size'
 * Double key size of direct extraction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     double_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_dir_ext_double_key_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_dir_ext_table_nof
} dnx_data_field_dir_ext_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE STATE_TABLE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_state_table_feature_get(
    int unit,
    dnx_data_field_state_table_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_state_table_define_address_size_entry_max,
    dnx_data_field_state_table_define_data_size_entry_max,
    dnx_data_field_state_table_define_address_max_entry_max,
    dnx_data_field_state_table_define_wr_bit_size_rw,
    dnx_data_field_state_table_define_opcode_size_rmw,
    dnx_data_field_state_table_define_data_size,
    dnx_data_field_state_table_define_state_table_stage_key,
    dnx_data_field_state_table_define_address_size,
    dnx_data_field_state_table_define_address_max,
    dnx_data_field_state_table_define_wr_bit_size,
    dnx_data_field_state_table_define_key_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_state_table_define_nof
} dnx_data_field_state_table_define_e;

/* Get Data */
/**
 * \brief returns define data of address_size_entry_max
 * Module - 'field', Submodule - 'state_table', data - 'address_size_entry_max'
 * Size of the address field in State Table in bits, for the case where the maximum size entry was chosen. Number of entries in HW.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_size_entry_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_address_size_entry_max_get(
    int unit);

/**
 * \brief returns define data of data_size_entry_max
 * Module - 'field', Submodule - 'state_table', data - 'data_size_entry_max'
 * Size of the DATA/ARGUMENT field in State Table in bits, for the case where the maximum size entry was chosen. Number of bits on the paylaod of the entry in HW.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_size_entry_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_data_size_entry_max_get(
    int unit);

/**
 * \brief returns define data of address_max_entry_max
 * Module - 'field', Submodule - 'state_table', data - 'address_max_entry_max'
 * Max address for the state table, for the case where the maximum size entry was chosen. Number of entries in HW.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_max_entry_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_address_max_entry_max_get(
    int unit);

/**
 * \brief returns define data of wr_bit_size_rw
 * Module - 'field', Submodule - 'state_table', data - 'wr_bit_size_rw'
 * Size of wr bit field in state table interface in bits. Relevant for separate read write operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wr_bit_size_rw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_wr_bit_size_rw_get(
    int unit);

/**
 * \brief returns define data of opcode_size_rmw
 * Module - 'field', Submodule - 'state_table', data - 'opcode_size_rmw'
 * Size of opcode field in state table interface in bits. Relevant for atomic read modify write operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     opcode_size_rmw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_opcode_size_rmw_get(
    int unit);

/**
 * \brief returns numeric data of data_size
 * Module - 'field', Submodule - 'state_table', data - 'data_size'
 * Size of the data field in State Table in bits. Determined by SOC property.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_data_size_get(
    int unit);

/**
 * \brief returns numeric data of state_table_stage_key
 * Module - 'field', Submodule - 'state_table', data - 'state_table_stage_key'
 * Indication of the source of the key for the state table lookup. Determined by SOC property.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     state_table_stage_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_state_table_stage_key_get(
    int unit);

/**
 * \brief returns numeric data of address_size
 * Module - 'field', Submodule - 'state_table', data - 'address_size'
 * Size of the address field in State Table in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_address_size_get(
    int unit);

/**
 * \brief returns numeric data of address_max
 * Module - 'field', Submodule - 'state_table', data - 'address_max'
 * Max address for the state table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_address_max_get(
    int unit);

/**
 * \brief returns numeric data of wr_bit_size
 * Module - 'field', Submodule - 'state_table', data - 'wr_bit_size'
 * Size of wr bit field in state table interface in bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wr_bit_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_wr_bit_size_get(
    int unit);

/**
 * \brief returns numeric data of key_size
 * Module - 'field', Submodule - 'state_table', data - 'key_size'
 * Size of the state table key in the system. Changes between RW or RMW according to device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_key_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_state_table_table_nof
} dnx_data_field_state_table_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE MAP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_map_feature_get(
    int unit,
    dnx_data_field_map_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_map_define_key_size,
    dnx_data_field_map_define_action_size_small,
    dnx_data_field_map_define_action_size_mid,
    dnx_data_field_map_define_action_size_large,
    dnx_data_field_map_define_ipmf1_key_select,
    dnx_data_field_map_define_ipmf2_key_select,
    dnx_data_field_map_define_ipmf3_key_select,

    /**
     * Must be last one!
     */
    _dnx_data_field_map_define_nof
} dnx_data_field_map_define_e;

/* Get Data */
/**
 * \brief returns define data of key_size
 * Module - 'field', Submodule - 'map', data - 'key_size'
 * Size of the MAP key in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_map_key_size_get(
    int unit);

/**
 * \brief returns define data of action_size_small
 * Module - 'field', Submodule - 'map', data - 'action_size_small'
 * Size of the small MAP action in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_small - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_map_action_size_small_get(
    int unit);

/**
 * \brief returns define data of action_size_mid
 * Module - 'field', Submodule - 'map', data - 'action_size_mid'
 * Size of the mid MAP action in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_mid - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_map_action_size_mid_get(
    int unit);

/**
 * \brief returns define data of action_size_large
 * Module - 'field', Submodule - 'map', data - 'action_size_large'
 * Size of the large MAP action in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_large - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_map_action_size_large_get(
    int unit);

/**
 * \brief returns define data of ipmf1_key_select
 * Module - 'field', Submodule - 'map', data - 'ipmf1_key_select'
 * The PMF key used for MAP lookup by iPMF1. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf1_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_map_ipmf1_key_select_get(
    int unit);

/**
 * \brief returns define data of ipmf2_key_select
 * Module - 'field', Submodule - 'map', data - 'ipmf2_key_select'
 * The PMF key used for MAP lookup by iPMF2. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf2_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_map_ipmf2_key_select_get(
    int unit);

/**
 * \brief returns define data of ipmf3_key_select
 * Module - 'field', Submodule - 'map', data - 'ipmf3_key_select'
 * The PMF key used for MAP lookup by iPMF3. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf3_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_map_ipmf3_key_select_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_map_table_nof
} dnx_data_field_map_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE HASH:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_hash_feature_get(
    int unit,
    dnx_data_field_hash_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_hash_define_max_key_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_hash_define_nof
} dnx_data_field_hash_define_e;

/* Get Data */
/**
 * \brief returns define data of max_key_size
 * Module - 'field', Submodule - 'hash', data - 'max_key_size'
 * maximal key size Field Group type 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_hash_max_key_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_hash_table_nof
} dnx_data_field_hash_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE UDH:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_udh_feature_get(
    int unit,
    dnx_data_field_udh_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_udh_define_type_count,
    dnx_data_field_udh_define_type_0_length,
    dnx_data_field_udh_define_type_1_length,
    dnx_data_field_udh_define_type_2_length,
    dnx_data_field_udh_define_type_3_length,
    dnx_data_field_udh_define_field_class_id_size_0,
    dnx_data_field_udh_define_field_class_id_size_1,
    dnx_data_field_udh_define_field_class_id_size_2,
    dnx_data_field_udh_define_field_class_id_size_3,
    dnx_data_field_udh_define_field_class_id_total_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_udh_define_nof
} dnx_data_field_udh_define_e;

/* Get Data */
/**
 * \brief returns define data of type_count
 * Module - 'field', Submodule - 'udh', data - 'type_count'
 * UDH Type count
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_count - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_type_count_get(
    int unit);

/**
 * \brief returns define data of type_0_length
 * Module - 'field', Submodule - 'udh', data - 'type_0_length'
 * UDH Type 0 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_0_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_type_0_length_get(
    int unit);

/**
 * \brief returns define data of type_1_length
 * Module - 'field', Submodule - 'udh', data - 'type_1_length'
 * UDH Type 1 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_1_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_type_1_length_get(
    int unit);

/**
 * \brief returns define data of type_2_length
 * Module - 'field', Submodule - 'udh', data - 'type_2_length'
 * UDH Type 2 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_2_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_type_2_length_get(
    int unit);

/**
 * \brief returns define data of type_3_length
 * Module - 'field', Submodule - 'udh', data - 'type_3_length'
 * UDH Type 3 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_3_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_type_3_length_get(
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_0
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_0'
 * J1 Mode UDH related size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_0 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_field_class_id_size_0_get(
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_1
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_1'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_field_class_id_size_1_get(
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_2
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_2'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_field_class_id_size_2_get(
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_3
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_3'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_field_class_id_size_3_get(
    int unit);

/**
 * \brief returns numeric data of field_class_id_total_size
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_total_size'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_total_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_field_class_id_total_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_udh_table_nof
} dnx_data_field_udh_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE SYSTEM_HEADERS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_system_headers_feature_get(
    int unit,
    dnx_data_field_system_headers_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_system_headers_define_nof_profiles,
    dnx_data_field_system_headers_define_pph_learn_ext_disable,

    /**
     * Must be last one!
     */
    _dnx_data_field_system_headers_define_nof
} dnx_data_field_system_headers_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_profiles
 * Module - 'field', Submodule - 'system_headers', data - 'nof_profiles'
 * Number of system headers in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_system_headers_nof_profiles_get(
    int unit);

/**
 * \brief returns numeric data of pph_learn_ext_disable
 * Module - 'field', Submodule - 'system_headers', data - 'pph_learn_ext_disable'
 * Never add learn_ext in system headers unlesee FP required. Used by default header_profile only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pph_learn_ext_disable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_system_headers_pph_learn_ext_disable_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_system_headers_table_system_header_profiles,

    /**
     * Must be last one!
     */
    _dnx_data_field_system_headers_table_nof
} dnx_data_field_system_headers_table_e;

/* Get Data */
/**
 * \brief get table system_header_profiles entry 
 * Contains all system headers profiles defined in this device
 * 
 * \param [in] unit - unit #
 * \param [in] system_header_profile - System header profile number
 * 
 * \return
 *     system_header_profiles - returns the relevant entry values grouped in struct - see dnx_data_field_system_headers_system_header_profiles_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_system_headers_system_header_profiles_t * dnx_data_field_system_headers_system_header_profiles_get(
    int unit,
    int system_header_profile);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'system_headers', table - 'system_header_profiles'
 * Contains all system headers profiles defined in this device
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_system_headers_system_header_profiles_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)system_header_profiles info
 * Contains all system headers profiles defined in this device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     system_header_profiles - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_system_headers_system_header_profiles_info_get(
    int unit);

/*
 * SUBMODULE EXEM:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_exem_feature_get(
    int unit,
    dnx_data_field_exem_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_exem_define_small_app_db_id_size,
    dnx_data_field_exem_define_large_app_db_id_size,
    dnx_data_field_exem_define_small_max_key_size,
    dnx_data_field_exem_define_large_max_key_size,
    dnx_data_field_exem_define_small_max_result_size,
    dnx_data_field_exem_define_large_max_result_size,
    dnx_data_field_exem_define_small_max_container_size,
    dnx_data_field_exem_define_large_max_container_size,
    dnx_data_field_exem_define_small_key_hash_size,
    dnx_data_field_exem_define_large_key_hash_size,
    dnx_data_field_exem_define_small_min_app_db_id_range,
    dnx_data_field_exem_define_large_min_app_db_id_range,
    dnx_data_field_exem_define_small_max_app_db_id_range,
    dnx_data_field_exem_define_large_max_app_db_id_range,
    dnx_data_field_exem_define_small_ipmf2_key,
    dnx_data_field_exem_define_small_ipmf2_key_part,
    dnx_data_field_exem_define_small_ipmf2_key_hw_value,
    dnx_data_field_exem_define_small_ipmf2_key_hw_bits,
    dnx_data_field_exem_define_large_ipmf1_key_configurable,
    dnx_data_field_exem_define_large_ipmf1_key,
    dnx_data_field_exem_define_small_nof_flush_profiles,

    /**
     * Must be last one!
     */
    _dnx_data_field_exem_define_nof
} dnx_data_field_exem_define_e;

/* Get Data */
/**
 * \brief returns define data of small_app_db_id_size
 * Module - 'field', Submodule - 'exem', data - 'small_app_db_id_size'
 * Number of bits used application db
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_app_db_id_size_get(
    int unit);

/**
 * \brief returns define data of large_app_db_id_size
 * Module - 'field', Submodule - 'exem', data - 'large_app_db_id_size'
 * Number of bits used application db
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_app_db_id_size_get(
    int unit);

/**
 * \brief returns define data of small_max_key_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_key_size'
 * Small EXEM key size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_max_key_size_get(
    int unit);

/**
 * \brief returns define data of large_max_key_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_key_size'
 * Large EXEM key size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_max_key_size_get(
    int unit);

/**
 * \brief returns define data of small_max_result_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_result_size'
 * Small EXEM result (payload) size in bits, including VMV
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_result_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_max_result_size_get(
    int unit);

/**
 * \brief returns define data of large_max_result_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_result_size'
 * Large EXEM result (payload) size in bits, including VMV
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_result_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_max_result_size_get(
    int unit);

/**
 * \brief returns define data of small_max_container_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_container_size'
 * Large EXEM maximal container size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_container_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_max_container_size_get(
    int unit);

/**
 * \brief returns define data of large_max_container_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_container_size'
 * Large EXEM result (payload) size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_container_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_max_container_size_get(
    int unit);

/**
 * \brief returns define data of small_key_hash_size
 * Module - 'field', Submodule - 'exem', data - 'small_key_hash_size'
 * number of bits out of key used for hashing (these bits are spared from saving in container)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_key_hash_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_key_hash_size_get(
    int unit);

/**
 * \brief returns define data of large_key_hash_size
 * Module - 'field', Submodule - 'exem', data - 'large_key_hash_size'
 * number of bits out of key used for hashing (these bits are spared from saving in container)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_key_hash_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_key_hash_size_get(
    int unit);

/**
 * \brief returns define data of small_min_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'small_min_app_db_id_range'
 * Small EXEM first APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_min_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_min_app_db_id_range_get(
    int unit);

/**
 * \brief returns define data of large_min_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'large_min_app_db_id_range'
 * Large EXEM first APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_min_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_min_app_db_id_range_get(
    int unit);

/**
 * \brief returns define data of small_max_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'small_max_app_db_id_range'
 * Small EXEM last APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_max_app_db_id_range_get(
    int unit);

/**
 * \brief returns define data of large_max_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'large_max_app_db_id_range'
 * Large EXEM last APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_max_app_db_id_range_get(
    int unit);

/**
 * \brief returns define data of small_ipmf2_key
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key'
 * The PMF key used for EXEM lookup by iPMF2. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_ipmf2_key_get(
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_part
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_part'
 * The PMF key part used for EXEM lookup by iPMF2. 0 means the LSB half, 1 the MSB half.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_part - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_ipmf2_key_part_get(
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_hw_value
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_hw_value'
 * The HW value to provide for selecting small_ipmf2_key and small_ipmf2_key_part.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_hw_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_ipmf2_key_hw_value_get(
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_hw_bits
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_hw_bits'
 * The number of bits used by the HW for selecting small_ipmf2_key and small_ipmf2_key_part.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_hw_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_ipmf2_key_hw_bits_get(
    int unit);

/**
 * \brief returns define data of large_ipmf1_key_configurable
 * Module - 'field', Submodule - 'exem', data - 'large_ipmf1_key_configurable'
 * Whether or not the EXEM key for iPMF1 can be configured on a chip wide basis.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_ipmf1_key_configurable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_ipmf1_key_configurable_get(
    int unit);

/**
 * \brief returns define data of large_ipmf1_key
 * Module - 'field', Submodule - 'exem', data - 'large_ipmf1_key'
 * The PMF key used for EXEM lookup by iPMF1. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_ipmf1_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_ipmf1_key_get(
    int unit);

/**
 * \brief returns define data of small_nof_flush_profiles
 * Module - 'field', Submodule - 'exem', data - 'small_nof_flush_profiles'
 * Small EXEM - number of flush profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_nof_flush_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_nof_flush_profiles_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_exem_table_nof
} dnx_data_field_exem_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE EXEM_LEARN_FLUSH_MACHINE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_exem_learn_flush_machine_feature_get(
    int unit,
    dnx_data_field_exem_learn_flush_machine_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_exem_learn_flush_machine_define_flush_machine_nof_entries,
    dnx_data_field_exem_learn_flush_machine_define_entry_extra_bits_for_hash,
    dnx_data_field_exem_learn_flush_machine_define_sexem_entry_max_size,
    dnx_data_field_exem_learn_flush_machine_define_lexem_entry_max_size,
    dnx_data_field_exem_learn_flush_machine_define_command_bit_transplant,
    dnx_data_field_exem_learn_flush_machine_define_command_bit_delete,
    dnx_data_field_exem_learn_flush_machine_define_command_bit_clear_hit_bit,
    dnx_data_field_exem_learn_flush_machine_define_nof_bits_source,
    dnx_data_field_exem_learn_flush_machine_define_source_bit_for_scan,
    dnx_data_field_exem_learn_flush_machine_define_source_bit_for_pipe,
    dnx_data_field_exem_learn_flush_machine_define_source_bit_for_mrq,
    dnx_data_field_exem_learn_flush_machine_define_nof_bits_accessed,

    /**
     * Must be last one!
     */
    _dnx_data_field_exem_learn_flush_machine_define_nof
} dnx_data_field_exem_learn_flush_machine_define_e;

/* Get Data */
/**
 * \brief returns define data of flush_machine_nof_entries
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'flush_machine_nof_entries'
 * Number of entries in the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_machine_nof_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_flush_machine_nof_entries_get(
    int unit);

/**
 * \brief returns define data of entry_extra_bits_for_hash
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'entry_extra_bits_for_hash'
 * Number of bits added to the exem entry size to account for the hash bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_extra_bits_for_hash - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_entry_extra_bits_for_hash_get(
    int unit);

/**
 * \brief returns define data of sexem_entry_max_size
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'sexem_entry_max_size'
 * Number of bits in HW that represent the SEXEM entry in the TCAM of the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sexem_entry_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_sexem_entry_max_size_get(
    int unit);

/**
 * \brief returns define data of lexem_entry_max_size
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'lexem_entry_max_size'
 * Number of bits in HW that represent the LEXEM entry in the TCAM of the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lexem_entry_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_lexem_entry_max_size_get(
    int unit);

/**
 * \brief returns define data of command_bit_transplant
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'command_bit_transplant'
 * The bit on the command field of the flush entry paylaod to set to change the payload of the EXEM entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_bit_transplant - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_command_bit_transplant_get(
    int unit);

/**
 * \brief returns define data of command_bit_delete
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'command_bit_delete'
 * The bit on the command field of the flush entry paylaod to set to delete the EXEM entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_bit_delete - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_command_bit_delete_get(
    int unit);

/**
 * \brief returns define data of command_bit_clear_hit_bit
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'command_bit_clear_hit_bit'
 * The bit on the command field of the flush entry paylaod to set to clear the hit bit of the EXEM entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_bit_clear_hit_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_command_bit_clear_hit_bit_get(
    int unit);

/**
 * \brief returns define data of nof_bits_source
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'nof_bits_source'
 * Number of bits in HW that represent the source field in the flush machine key.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_source - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_nof_bits_source_get(
    int unit);

/**
 * \brief returns define data of source_bit_for_scan
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'source_bit_for_scan'
 * The bit on source field to indicate that the flush was activated by scan.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_bit_for_scan - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_source_bit_for_scan_get(
    int unit);

/**
 * \brief returns define data of source_bit_for_pipe
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'source_bit_for_pipe'
 * The bit on source field to indicate that the flush was activated by pipe.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_bit_for_pipe - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_source_bit_for_pipe_get(
    int unit);

/**
 * \brief returns define data of source_bit_for_mrq
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'source_bit_for_mrq'
 * The bit on source field to indicate that the flush was activated by MRQ.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_bit_for_mrq - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_source_bit_for_mrq_get(
    int unit);

/**
 * \brief returns define data of nof_bits_accessed
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'nof_bits_accessed'
 * Number of bits in HW that represent the accessed field in the flush machine key (hit bit).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_accessed - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_learn_flush_machine_nof_bits_accessed_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_exem_learn_flush_machine_table_sexem_flush_tcam_tcam_memories,
    dnx_data_field_exem_learn_flush_machine_table_lexem_flush_tcam_tcam_memories,
    dnx_data_field_exem_learn_flush_machine_table_sexem_flush_tcam_data_rules,
    dnx_data_field_exem_learn_flush_machine_table_lexem_flush_tcam_data_rules,

    /**
     * Must be last one!
     */
    _dnx_data_field_exem_learn_flush_machine_table_nof
} dnx_data_field_exem_learn_flush_machine_table_e;

/* Get Data */
/**
 * \brief get table sexem_flush_tcam_tcam_memories entry 
 * Holds the memories of the flush TCAM for SEXEM3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sexem_flush_tcam_tcam_memories - returns the relevant entry values grouped in struct - see dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_tcam_memories_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_tcam_memories_t * dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_tcam_memories_get(
    int unit);

/**
 * \brief get table lexem_flush_tcam_tcam_memories entry 
 * Holds the memories of the flush TCAM for LEXEM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lexem_flush_tcam_tcam_memories - returns the relevant entry values grouped in struct - see dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_tcam_memories_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_tcam_memories_t * dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_tcam_memories_get(
    int unit);

/**
 * \brief get table sexem_flush_tcam_data_rules entry 
 * Holds the memories of the flush DATA for SEXEM3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sexem_flush_tcam_data_rules - returns the relevant entry values grouped in struct - see dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_data_rules_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_data_rules_t * dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_data_rules_get(
    int unit);

/**
 * \brief get table lexem_flush_tcam_data_rules entry 
 * Holds the memories of the flush DATA for LEXEM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lexem_flush_tcam_data_rules - returns the relevant entry values grouped in struct - see dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_data_rules_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_data_rules_t * dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_data_rules_get(
    int unit);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'exem_learn_flush_machine', table - 'sexem_flush_tcam_tcam_memories'
 * Holds the memories of the flush TCAM for SEXEM3
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_tcam_memories_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'exem_learn_flush_machine', table - 'lexem_flush_tcam_tcam_memories'
 * Holds the memories of the flush TCAM for LEXEM
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_tcam_memories_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'exem_learn_flush_machine', table - 'sexem_flush_tcam_data_rules'
 * Holds the memories of the flush DATA for SEXEM3
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_data_rules_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'exem_learn_flush_machine', table - 'lexem_flush_tcam_data_rules'
 * Holds the memories of the flush DATA for LEXEM
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_data_rules_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)sexem_flush_tcam_tcam_memories info
 * Holds the memories of the flush TCAM for SEXEM3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sexem_flush_tcam_tcam_memories - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_tcam_memories_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)lexem_flush_tcam_tcam_memories info
 * Holds the memories of the flush TCAM for LEXEM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lexem_flush_tcam_tcam_memories - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_tcam_memories_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)sexem_flush_tcam_data_rules info
 * Holds the memories of the flush DATA for SEXEM3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sexem_flush_tcam_data_rules - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_data_rules_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)lexem_flush_tcam_data_rules info
 * Holds the memories of the flush DATA for LEXEM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lexem_flush_tcam_data_rules - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_data_rules_info_get(
    int unit);

/*
 * SUBMODULE ACE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_ace_feature_get(
    int unit,
    dnx_data_field_ace_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_ace_define_ace_id_size,
    dnx_data_field_ace_define_key_size,
    dnx_data_field_ace_define_key_hash_size,
    dnx_data_field_ace_define_app_db_id_size,
    dnx_data_field_ace_define_payload_size,
    dnx_data_field_ace_define_min_key_range_pmf,
    dnx_data_field_ace_define_max_key_range_pmf,
    dnx_data_field_ace_define_min_ace_id_dynamic_range,
    dnx_data_field_ace_define_nof_ace_id,
    dnx_data_field_ace_define_nof_action_per_ace_format,
    dnx_data_field_ace_define_row_size,
    dnx_data_field_ace_define_min_entry_size,
    dnx_data_field_ace_define_ace_id_pmf_alloc_first,
    dnx_data_field_ace_define_ace_id_pmf_alloc_last,
    dnx_data_field_ace_define_nof_masks_per_fes,
    dnx_data_field_ace_define_nof_fes_id_per_array,
    dnx_data_field_ace_define_nof_fes_array,
    dnx_data_field_ace_define_nof_fes_instruction_per_context,
    dnx_data_field_ace_define_nof_fes_programs,
    dnx_data_field_ace_define_nof_prog_per_fes,
    dnx_data_field_ace_define_nof_bits_in_fes_action,
    dnx_data_field_ace_define_fes_shift_for_zero_bit,
    dnx_data_field_ace_define_fes_instruction_size,
    dnx_data_field_ace_define_fes_shift_offset,
    dnx_data_field_ace_define_fes_invalid_bits_offset,
    dnx_data_field_ace_define_fes_type_offset,
    dnx_data_field_ace_define_fes_ace_action_offset,
    dnx_data_field_ace_define_fes_chosen_mask_offset,

    /**
     * Must be last one!
     */
    _dnx_data_field_ace_define_nof
} dnx_data_field_ace_define_e;

/* Get Data */
/**
 * \brief returns define data of ace_id_size
 * Module - 'field', Submodule - 'ace', data - 'ace_id_size'
 * Number of bits used for the ACE ID (result type), which serves as an ID for the ACE format and context ID for the ACE EFES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_ace_id_size_get(
    int unit);

/**
 * \brief returns define data of key_size
 * Module - 'field', Submodule - 'ace', data - 'key_size'
 * Number of bits in the key of the PPMC table, including the prefix that indicates the type to the entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_key_size_get(
    int unit);

/**
 * \brief returns define data of key_hash_size
 * Module - 'field', Submodule - 'ace', data - 'key_hash_size'
 * Number of bits in the key that are only used in the hash and aren't placed in the entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_hash_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_key_hash_size_get(
    int unit);

/**
 * \brief returns define data of app_db_id_size
 * Module - 'field', Submodule - 'ace', data - 'app_db_id_size'
 * Number of bits Used for the APP DB ID.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_app_db_id_size_get(
    int unit);

/**
 * \brief returns define data of payload_size
 * Module - 'field', Submodule - 'ace', data - 'payload_size'
 * Number of bits used to encode the container size, including the result type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_payload_size_get(
    int unit);

/**
 * \brief returns define data of min_key_range_pmf
 * Module - 'field', Submodule - 'ace', data - 'min_key_range_pmf'
 * The first entry in the range of ACE keys allocated to ACE pointers (but not to MC replication ID).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_key_range_pmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_min_key_range_pmf_get(
    int unit);

/**
 * \brief returns define data of max_key_range_pmf
 * Module - 'field', Submodule - 'ace', data - 'max_key_range_pmf'
 * The last entry in the range of ACE keys allocated to ACE pointers (but not to MC replication ID).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_range_pmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_max_key_range_pmf_get(
    int unit);

/**
 * \brief returns define data of min_ace_id_dynamic_range
 * Module - 'field', Submodule - 'ace', data - 'min_ace_id_dynamic_range'
 * Minimal number of ACE ID that can be allocated dynamically.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_ace_id_dynamic_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_min_ace_id_dynamic_range_get(
    int unit);

/**
 * \brief returns define data of nof_ace_id
 * Module - 'field', Submodule - 'ace', data - 'nof_ace_id'
 * Number of ACE IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ace_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_ace_id_get(
    int unit);

/**
 * \brief returns define data of nof_action_per_ace_format
 * Module - 'field', Submodule - 'ace', data - 'nof_action_per_ace_format'
 * Number of action per ACE Format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_ace_format - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_action_per_ace_format_get(
    int unit);

/**
 * \brief returns define data of row_size
 * Module - 'field', Submodule - 'ace', data - 'row_size'
 * Number of bits per raw, entry size is number row size times VMV encoding meaning, e.g. half row encoding VMV would mean 60 bits entry size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     row_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_row_size_get(
    int unit);

/**
 * \brief returns define data of min_entry_size
 * Module - 'field', Submodule - 'ace', data - 'min_entry_size'
 * Minimum number of bits in entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_min_entry_size_get(
    int unit);

/**
 * \brief returns define data of ace_id_pmf_alloc_first
 * Module - 'field', Submodule - 'ace', data - 'ace_id_pmf_alloc_first'
 * The first ACE ID allocated to ACE, that is to ePMF extension.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_pmf_alloc_first - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_ace_id_pmf_alloc_first_get(
    int unit);

/**
 * \brief returns define data of ace_id_pmf_alloc_last
 * Module - 'field', Submodule - 'ace', data - 'ace_id_pmf_alloc_last'
 * The last ACE ID allocated to ACE, that is to ePMF extension.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_pmf_alloc_last - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_ace_id_pmf_alloc_last_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'ace', data - 'nof_masks_per_fes'
 * Number of masks per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_array'
 * Number FES arrays
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per ACE ID, also the number of FESes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_programs'
 * Number of FES programs. For ACE the FES program is the same as ACE ID. Used here for compatibility with PMF FESes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_fes_programs_get(
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'ace', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_prog_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'ace', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_bits_in_fes_action_get(
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'ace', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES. Uses the zero padding at the end of the payload, expected to work only if EFES field type=1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_fes_shift_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'ace', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_fes_instruction_size_get(
    int unit);

/**
 * \brief returns define data of fes_shift_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_shift_offset'
 * FES shift offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_fes_shift_offset_get(
    int unit);

/**
 * \brief returns define data of fes_invalid_bits_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_invalid_bits_offset'
 * FES invalid bits offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_invalid_bits_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_fes_invalid_bits_offset_get(
    int unit);

/**
 * \brief returns define data of fes_type_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_type_offset'
 * FES type offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_type_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_fes_type_offset_get(
    int unit);

/**
 * \brief returns define data of fes_ace_action_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_ace_action_offset'
 * FES ace action offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_ace_action_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_fes_ace_action_offset_get(
    int unit);

/**
 * \brief returns define data of fes_chosen_mask_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_chosen_mask_offset'
 * FES chosen mask offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_chosen_mask_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_fes_chosen_mask_offset_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_ace_table_nof
} dnx_data_field_ace_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE ENTRY:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_entry_feature_get(
    int unit,
    dnx_data_field_entry_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_entry_define_dir_ext_nof_fields,
    dnx_data_field_entry_define_nof_action_params_per_entry,
    dnx_data_field_entry_define_nof_qual_params_per_entry,

    /**
     * Must be last one!
     */
    _dnx_data_field_entry_define_nof
} dnx_data_field_entry_define_e;

/* Get Data */
/**
 * \brief returns define data of dir_ext_nof_fields
 * Module - 'field', Submodule - 'entry', data - 'dir_ext_nof_fields'
 * The maximum number of fields in a direct extraction request. \n                                                   (e.g. if we want the action to be composed of 3 bits of constant value, 5 bits from the key, \n                                                   5 bits of constant value and then 4 bits from the key we need at least 4 fields.)\n                                                   Used by dnx_field_dir_ext_action_t for the array size of the fields. \n                                                   Arbitrary value, can be increased.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_nof_fields - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_entry_dir_ext_nof_fields_get(
    int unit);

/**
 * \brief returns define data of nof_action_params_per_entry
 * Module - 'field', Submodule - 'entry', data - 'nof_action_params_per_entry'
 * Number of action parameters can be given for each action \n                                                             e.g. action values that are filled for TCAM action result
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_params_per_entry - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_entry_nof_action_params_per_entry_get(
    int unit);

/**
 * \brief returns define data of nof_qual_params_per_entry
 * Module - 'field', Submodule - 'entry', data - 'nof_qual_params_per_entry'
 * Number of qualifiers parameters can be given for each qualifier type \n                                                             e.g. qualifier/key values that are filled for TCAM key
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qual_params_per_entry - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_entry_nof_qual_params_per_entry_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_entry_table_nof
} dnx_data_field_entry_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE L4_OPS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_L4_Ops_feature_get(
    int unit,
    dnx_data_field_L4_Ops_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_L4_Ops_define_udp_position,
    dnx_data_field_L4_Ops_define_tcp_position,
    dnx_data_field_L4_Ops_define_nof_range_entries,
    dnx_data_field_L4_Ops_define_nof_ext_encoders,
    dnx_data_field_L4_Ops_define_nof_ext_types,
    dnx_data_field_L4_Ops_define_nof_configurable_ranges,

    /**
     * Must be last one!
     */
    _dnx_data_field_L4_Ops_define_nof
} dnx_data_field_L4_Ops_define_e;

/* Get Data */
/**
 * \brief returns define data of udp_position
 * Module - 'field', Submodule - 'L4_Ops', data - 'udp_position'
 * The position of the UDP protocol in the register
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     udp_position - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_L4_Ops_udp_position_get(
    int unit);

/**
 * \brief returns define data of tcp_position
 * Module - 'field', Submodule - 'L4_Ops', data - 'tcp_position'
 * The position of the UDP protocol in the register
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcp_position - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_L4_Ops_tcp_position_get(
    int unit);

/**
 * \brief returns define data of nof_range_entries
 * Module - 'field', Submodule - 'L4_Ops', data - 'nof_range_entries'
 * number of range entries in L4 Ops
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_range_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_L4_Ops_nof_range_entries_get(
    int unit);

/**
 * \brief returns define data of nof_ext_encoders
 * Module - 'field', Submodule - 'L4_Ops', data - 'nof_ext_encoders'
 * Number of range result encoders in extended L4 OPs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ext_encoders - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_L4_Ops_nof_ext_encoders_get(
    int unit);

/**
 * \brief returns define data of nof_ext_types
 * Module - 'field', Submodule - 'L4_Ops', data - 'nof_ext_types'
 * Number of range types in extended L4 OPs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ext_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_L4_Ops_nof_ext_types_get(
    int unit);

/**
 * \brief returns define data of nof_configurable_ranges
 * Module - 'field', Submodule - 'L4_Ops', data - 'nof_configurable_ranges'
 * Number of configurable ranges
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_configurable_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_L4_Ops_nof_configurable_ranges_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_L4_Ops_table_nof
} dnx_data_field_L4_Ops_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE ENCODED_QUAL_ACTIONS_OFFSET:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_encoded_qual_actions_offset_feature_get(
    int unit,
    dnx_data_field_encoded_qual_actions_offset_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_encoded_qual_actions_offset_define_trap_strength_offset,
    dnx_data_field_encoded_qual_actions_offset_define_trap_qualifier_offset,
    dnx_data_field_encoded_qual_actions_offset_define_sniff_qualifier_offset,
    dnx_data_field_encoded_qual_actions_offset_define_mirror_qualifier_offset,

    /**
     * Must be last one!
     */
    _dnx_data_field_encoded_qual_actions_offset_define_nof
} dnx_data_field_encoded_qual_actions_offset_define_e;

/* Get Data */
/**
 * \brief returns define data of trap_strength_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'trap_strength_offset'
 * The offset of the Trap Strength in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     trap_strength_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_encoded_qual_actions_offset_trap_strength_offset_get(
    int unit);

/**
 * \brief returns define data of trap_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'trap_qualifier_offset'
 * The offset of the Trap Qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     trap_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_encoded_qual_actions_offset_trap_qualifier_offset_get(
    int unit);

/**
 * \brief returns define data of sniff_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'sniff_qualifier_offset'
 * The offset of the Snoop qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sniff_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_encoded_qual_actions_offset_sniff_qualifier_offset_get(
    int unit);

/**
 * \brief returns define data of mirror_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'mirror_qualifier_offset'
 * The offset of the Mirror Qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mirror_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_encoded_qual_actions_offset_mirror_qualifier_offset_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_encoded_qual_actions_offset_table_nof
} dnx_data_field_encoded_qual_actions_offset_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE COMPARE_OPERAND:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_Compare_operand_feature_get(
    int unit,
    dnx_data_field_Compare_operand_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_Compare_operand_define_equal,
    dnx_data_field_Compare_operand_define_not_equal,
    dnx_data_field_Compare_operand_define_smaller,
    dnx_data_field_Compare_operand_define_not_smaller,
    dnx_data_field_Compare_operand_define_bigger,
    dnx_data_field_Compare_operand_define_not_bigger,
    dnx_data_field_Compare_operand_define_nof_operands,

    /**
     * Must be last one!
     */
    _dnx_data_field_Compare_operand_define_nof
} dnx_data_field_Compare_operand_define_e;

/* Get Data */
/**
 * \brief returns define data of equal
 * Module - 'field', Submodule - 'Compare_operand', data - 'equal'
 * The position in the qual showing that the result of compare is equal
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     equal - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_equal_get(
    int unit);

/**
 * \brief returns define data of not_equal
 * Module - 'field', Submodule - 'Compare_operand', data - 'not_equal'
 * The position in the qual showing that the result of compare is not equal
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_equal - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_not_equal_get(
    int unit);

/**
 * \brief returns define data of smaller
 * Module - 'field', Submodule - 'Compare_operand', data - 'smaller'
 * The position in the qual showing that the first compare value is smaller then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     smaller - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_smaller_get(
    int unit);

/**
 * \brief returns define data of not_smaller
 * Module - 'field', Submodule - 'Compare_operand', data - 'not_smaller'
 * The position in the qual showing that the first compare value is not smaller then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_smaller - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_not_smaller_get(
    int unit);

/**
 * \brief returns define data of bigger
 * Module - 'field', Submodule - 'Compare_operand', data - 'bigger'
 * The position in the qual showing that the first compare value is bigger then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bigger - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_bigger_get(
    int unit);

/**
 * \brief returns define data of not_bigger
 * Module - 'field', Submodule - 'Compare_operand', data - 'not_bigger'
 * The position in the qual showing that the first compare value is not bigger then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_bigger - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_not_bigger_get(
    int unit);

/**
 * \brief returns define data of nof_operands
 * Module - 'field', Submodule - 'Compare_operand', data - 'nof_operands'
 * The number of all operands
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_operands - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_nof_operands_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_Compare_operand_table_nof
} dnx_data_field_Compare_operand_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE DIAG:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_diag_feature_get(
    int unit,
    dnx_data_field_diag_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_diag_define_bytes_to_remove_mask,
    dnx_data_field_diag_define_layers_to_remove_size_in_bit,
    dnx_data_field_diag_define_layers_to_remove_mask,
    dnx_data_field_diag_define_nof_signals_per_action,
    dnx_data_field_diag_define_nof_signals_per_qualifier,
    dnx_data_field_diag_define_key_signal_size_in_words,
    dnx_data_field_diag_define_result_signal_size_in_words,
    dnx_data_field_diag_define_dt_result_signal_size_in_words,
    dnx_data_field_diag_define_hit_signal_size_in_words,

    /**
     * Must be last one!
     */
    _dnx_data_field_diag_define_nof
} dnx_data_field_diag_define_e;

/* Get Data */
/**
 * \brief returns define data of bytes_to_remove_mask
 * Module - 'field', Submodule - 'diag', data - 'bytes_to_remove_mask'
 * Mask of bits, which are related to the value of bytes to remove, from the signal.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bytes_to_remove_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_bytes_to_remove_mask_get(
    int unit);

/**
 * \brief returns define data of layers_to_remove_size_in_bit
 * Module - 'field', Submodule - 'diag', data - 'layers_to_remove_size_in_bit'
 * Size of the layers to remove value in bits, to be used for shifting the signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layers_to_remove_size_in_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_layers_to_remove_size_in_bit_get(
    int unit);

/**
 * \brief returns define data of layers_to_remove_mask
 * Module - 'field', Submodule - 'diag', data - 'layers_to_remove_mask'
 * Mask of bits, which are related to the value of layers to remove, from the signal.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layers_to_remove_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_layers_to_remove_mask_get(
    int unit);

/**
 * \brief returns define data of nof_signals_per_action
 * Module - 'field', Submodule - 'diag', data - 'nof_signals_per_action'
 * Maximum number of signals per action.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_signals_per_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_nof_signals_per_action_get(
    int unit);

/**
 * \brief returns define data of nof_signals_per_qualifier
 * Module - 'field', Submodule - 'diag', data - 'nof_signals_per_qualifier'
 * Maximum number of signals per qualifier.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_signals_per_qualifier - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_nof_signals_per_qualifier_get(
    int unit);

/**
 * \brief returns define data of key_signal_size_in_words
 * Module - 'field', Submodule - 'diag', data - 'key_signal_size_in_words'
 * Maximum number of words to store KEY signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_signal_size_in_words - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_key_signal_size_in_words_get(
    int unit);

/**
 * \brief returns define data of result_signal_size_in_words
 * Module - 'field', Submodule - 'diag', data - 'result_signal_size_in_words'
 * Maximum number of words to store RESULT signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     result_signal_size_in_words - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_result_signal_size_in_words_get(
    int unit);

/**
 * \brief returns define data of dt_result_signal_size_in_words
 * Module - 'field', Submodule - 'diag', data - 'dt_result_signal_size_in_words'
 * Maximum number of words to store DT RESULT signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dt_result_signal_size_in_words - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_dt_result_signal_size_in_words_get(
    int unit);

/**
 * \brief returns define data of hit_signal_size_in_words
 * Module - 'field', Submodule - 'diag', data - 'hit_signal_size_in_words'
 * Maximum number of words to store HIT signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hit_signal_size_in_words - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_hit_signal_size_in_words_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_diag_table_nof
} dnx_data_field_diag_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE COMMON_MAX_VAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_common_max_val_feature_get(
    int unit,
    dnx_data_field_common_max_val_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_common_max_val_define_nof_ffc,
    dnx_data_field_common_max_val_define_nof_keys,
    dnx_data_field_common_max_val_define_nof_masks_per_fes,
    dnx_data_field_common_max_val_define_nof_fes_id_per_array,
    dnx_data_field_common_max_val_define_nof_fes_array,
    dnx_data_field_common_max_val_define_nof_fes_instruction_per_context,
    dnx_data_field_common_max_val_define_nof_fes_programs,
    dnx_data_field_common_max_val_define_nof_prog_per_fes,
    dnx_data_field_common_max_val_define_nof_program_selection_lines,
    dnx_data_field_common_max_val_define_program_selection_cam_mask_nof_bits,
    dnx_data_field_common_max_val_define_nof_cs_lines,
    dnx_data_field_common_max_val_define_nof_contexts,
    dnx_data_field_common_max_val_define_nof_actions,
    dnx_data_field_common_max_val_define_nof_qualifiers,
    dnx_data_field_common_max_val_define_nof_80B_zones,
    dnx_data_field_common_max_val_define_nof_key_zones,
    dnx_data_field_common_max_val_define_nof_key_zone_bits,
    dnx_data_field_common_max_val_define_nof_bits_in_fes_action,
    dnx_data_field_common_max_val_define_nof_bits_in_fes_key_select,
    dnx_data_field_common_max_val_define_nof_fes_key_selects_on_one_actions_line,
    dnx_data_field_common_max_val_define_nof_ffc_in_qual,
    dnx_data_field_common_max_val_define_nof_bits_in_ffc,
    dnx_data_field_common_max_val_define_nof_ffc_in_uint32,
    dnx_data_field_common_max_val_define_nof_action_per_group,
    dnx_data_field_common_max_val_define_nof_layer_records,
    dnx_data_field_common_max_val_define_layer_record_size,
    dnx_data_field_common_max_val_define_nof_l4_ops_ranges_legacy,
    dnx_data_field_common_max_val_define_nof_pkt_hdr_ranges,
    dnx_data_field_common_max_val_define_nof_out_lif_ranges,
    dnx_data_field_common_max_val_define_kbr_size,
    dnx_data_field_common_max_val_define_nof_compare_pairs,
    dnx_data_field_common_max_val_define_nof_compare_pairs_in_compare_mode,
    dnx_data_field_common_max_val_define_nof_compare_keys_in_compare_mode,
    dnx_data_field_common_max_val_define_nof_bits_in_fem_action,
    dnx_data_field_common_max_val_define_nof_fem_condition,
    dnx_data_field_common_max_val_define_nof_fem_map_index,
    dnx_data_field_common_max_val_define_nof_fem_id,
    dnx_data_field_common_max_val_define_nof_array_ids,
    dnx_data_field_common_max_val_define_dbal_pairs,

    /**
     * Must be last one!
     */
    _dnx_data_field_common_max_val_define_nof
} dnx_data_field_common_max_val_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_ffc'
 * Maximal number of FFC's in all stages
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_keys'
 * Number of keys for the entire PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_masks_per_fes'
 * Number of masks per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_array'
 * Number FES arrays
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_programs'
 * Number of FES programs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fes_programs_get(
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_prog_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_program_selection_lines
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_program_selection_lines'
 * Number of Ingress context selection lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_program_selection_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_program_selection_lines_get(
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'common_max_val', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_program_selection_cam_mask_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_cs_lines'
 * Number of program selection lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_cs_lines_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_contexts'
 * Number of contexts per PMF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_actions'
 * Number of actions
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_actions_get(
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_qualifiers'
 * Number of qualifiers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_qualifiers_get(
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_80B_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_key_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_key_zone_bits_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fes_action'
 * Number of bits on the outpus of a FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_bits_in_fes_action_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_bits_in_fes_key_select_get(
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can be applied on one line on actions table. ('double key' actions are considered one line)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fes_key_selects_on_one_actions_line_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_in_qual
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_ffc_in_qual'
 * Maximal number of ffc for one qualifier.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_in_qual - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_ffc_in_qual_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_ffc
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_ffc'
 * Number of bits in ffc.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_bits_in_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_in_uint32
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_ffc_in_uint32'
 * Number of uint32 needed to hold bitmap for maximum number of FFC's.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_in_uint32 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_ffc_in_uint32_get(
    int unit);

/**
 * \brief returns define data of nof_action_per_group
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_action_per_group'
 * Maxmimal number of actions between both Field Group and ACE format. Used for arrays in functions that serve both.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_action_per_group_get(
    int unit);

/**
 * \brief returns define data of nof_layer_records
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_layer_records'
 * Maximal number of layer records.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_layer_records_get(
    int unit);

/**
 * \brief returns define data of layer_record_size
 * Module - 'field', Submodule - 'common_max_val', data - 'layer_record_size'
 * Maximal size of layer records.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layer_record_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_layer_record_size_get(
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges_legacy
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_l4_ops_ranges_legacy'
 * Maximal number of ranges for L4 Ops legacy.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges_legacy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_l4_ops_ranges_legacy_get(
    int unit);

/**
 * \brief returns define data of nof_pkt_hdr_ranges
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_pkt_hdr_ranges'
 * Maximal number of ranges for packet header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pkt_hdr_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_pkt_hdr_ranges_get(
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_out_lif_ranges'
 * Maximal number of ranges for Out Lif.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_out_lif_ranges_get(
    int unit);

/**
 * \brief returns define data of kbr_size
 * Module - 'field', Submodule - 'common_max_val', data - 'kbr_size'
 * Maximal KBR size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kbr_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_kbr_size_get(
    int unit);

/**
 * \brief returns define data of nof_compare_pairs
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_compare_pairs'
 * Maximal number of pairs used for compare.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_compare_pairs_get(
    int unit);

/**
 * \brief returns define data of nof_compare_pairs_in_compare_mode
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_compare_pairs_in_compare_mode'
 * Number compare pairs in compare mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_compare_pairs_in_compare_mode_get(
    int unit);

/**
 * \brief returns define data of nof_compare_keys_in_compare_mode
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_compare_keys_in_compare_mode'
 * Number compare keys in compare mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_keys_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_compare_keys_in_compare_mode_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fem_action'
 * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_bits_in_fem_action_get(
    int unit);

/**
 * \brief returns define data of nof_fem_condition
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fem_condition'
 * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_condition - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fem_condition_get(
    int unit);

/**
 * \brief returns define data of nof_fem_map_index
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fem_map_index'
 * Total number fem map indices. This represents the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_map_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fem_map_index_get(
    int unit);

/**
 * \brief returns define data of nof_fem_id
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fem_id'
 * Total number 'FEM id's available.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fem_id_get(
    int unit);

/**
 * \brief returns define data of nof_array_ids
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_array_ids'
 * Total number of 'array_is's which are used to identify a range of FESes or FEMs. See BCM_FIELD_ACTION_POSITION.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_array_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_array_ids_get(
    int unit);

/**
 * \brief returns define data of dbal_pairs
 * Module - 'field', Submodule - 'common_max_val', data - 'dbal_pairs'
 * Maximum number of pairs which are used to identify the DBAL key/result field in dnx_field_dbal_entry_set function. 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbal_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_dbal_pairs_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_common_max_val_table_array_id_type,

    /**
     * Must be last one!
     */
    _dnx_data_field_common_max_val_table_nof
} dnx_data_field_common_max_val_table_e;

/* Get Data */
/**
 * \brief get table array_id_type entry 
 * Contains indications on whether a specific 'array_id' is for FESes or for FEMs
 * 
 * \param [in] unit - unit #
 * \param [in] array_id - Index identifier of 'array_id'
 * 
 * \return
 *     array_id_type - returns the relevant entry values grouped in struct - see dnx_data_field_common_max_val_array_id_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_common_max_val_array_id_type_t * dnx_data_field_common_max_val_array_id_type_get(
    int unit,
    int array_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'common_max_val', table - 'array_id_type'
 * Contains indications on whether a specific 'array_id' is for FESes or for FEMs
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_common_max_val_array_id_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)array_id_type info
 * Contains indications on whether a specific 'array_id' is for FESes or for FEMs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     array_id_type - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_common_max_val_array_id_type_info_get(
    int unit);

/*
 * SUBMODULE INIT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_init_feature_get(
    int unit,
    dnx_data_field_init_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_init_define_fec_dest,
    dnx_data_field_init_define_l4_trap,
    dnx_data_field_init_define_oam_layer_index,
    dnx_data_field_init_define_oam_stat,
    dnx_data_field_init_define_flow_id,
    dnx_data_field_init_define_roo,
    dnx_data_field_init_define_jr1_ipmc_inlif,
    dnx_data_field_init_define_j1_same_port,
    dnx_data_field_init_define_j1_learning,
    dnx_data_field_init_define_learn_limit,
    dnx_data_field_init_define_j1_php,

    /**
     * Must be last one!
     */
    _dnx_data_field_init_define_nof
} dnx_data_field_init_define_e;

/* Get Data */
/**
 * \brief returns define data of fec_dest
 * Module - 'field', Submodule - 'init', data - 'fec_dest'
 * APP for fec destination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_dest - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_fec_dest_get(
    int unit);

/**
 * \brief returns define data of l4_trap
 * Module - 'field', Submodule - 'init', data - 'l4_trap'
 * APP for L4 Trap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l4_trap - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_l4_trap_get(
    int unit);

/**
 * \brief returns define data of oam_layer_index
 * Module - 'field', Submodule - 'init', data - 'oam_layer_index'
 * APP for OAM Layer Index
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     oam_layer_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_oam_layer_index_get(
    int unit);

/**
 * \brief returns define data of oam_stat
 * Module - 'field', Submodule - 'init', data - 'oam_stat'
 * APP for OAM Statistics
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     oam_stat - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_oam_stat_get(
    int unit);

/**
 * \brief returns define data of flow_id
 * Module - 'field', Submodule - 'init', data - 'flow_id'
 * APP for Flow ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_flow_id_get(
    int unit);

/**
 * \brief returns define data of roo
 * Module - 'field', Submodule - 'init', data - 'roo'
 * APP for Roo
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     roo - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_roo_get(
    int unit);

/**
 * \brief returns define data of jr1_ipmc_inlif
 * Module - 'field', Submodule - 'init', data - 'jr1_ipmc_inlif'
 * APP for IPMC In LIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     jr1_ipmc_inlif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_jr1_ipmc_inlif_get(
    int unit);

/**
 * \brief returns define data of j1_same_port
 * Module - 'field', Submodule - 'init', data - 'j1_same_port'
 * APP for J1 Same port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     j1_same_port - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_j1_same_port_get(
    int unit);

/**
 * \brief returns define data of j1_learning
 * Module - 'field', Submodule - 'init', data - 'j1_learning'
 * APP for J1 Learning
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     j1_learning - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_j1_learning_get(
    int unit);

/**
 * \brief returns define data of learn_limit
 * Module - 'field', Submodule - 'init', data - 'learn_limit'
 * APP for Learn Limit
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     learn_limit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_learn_limit_get(
    int unit);

/**
 * \brief returns define data of j1_php
 * Module - 'field', Submodule - 'init', data - 'j1_php'
 * APP for J1 MPLS PHP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     j1_php - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_j1_php_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_init_table_nof
} dnx_data_field_init_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FEATURES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_features_feature_get(
    int unit,
    dnx_data_field_features_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_features_define_ecc_enable,
    dnx_data_field_features_define_switch_to_acl_context,
    dnx_data_field_features_define_per_pp_port_pmf_profile_cs_offset,
    dnx_data_field_features_define_tcam_result_flip_eco,
    dnx_data_field_features_define_tcam_result_half_payload_on_msb,
    dnx_data_field_features_define_parsing_start_offset_msb_meaningless,
    dnx_data_field_features_define_kbp_opcode_in_ipmf1_cs,
    dnx_data_field_features_define_kbp_hitbits_correct_in_ipmf1_cs,
    dnx_data_field_features_define_exem_vmv_removable_from_payload,
    dnx_data_field_features_define_multiple_dynamic_mem_enablers,
    dnx_data_field_features_define_aacl_super_group_handler_enable,
    dnx_data_field_features_define_aacl_tcam_swap_enable,
    dnx_data_field_features_define_extended_l4_ops,
    dnx_data_field_features_define_state_table_ipmf1_key_select,
    dnx_data_field_features_define_state_table_acr_bus,
    dnx_data_field_features_define_state_table_atomic_rmw,
    dnx_data_field_features_define_hitbit_volatile,
    dnx_data_field_features_define_fem_replace_msb_instead_lsb,
    dnx_data_field_features_define_no_parser_resources,
    dnx_data_field_features_define_dir_ext_epmf,
    dnx_data_field_features_define_hashing_process_lsb_to_msb,
    dnx_data_field_features_define_exem_age_flush_scan,

    /**
     * Must be last one!
     */
    _dnx_data_field_features_define_nof
} dnx_data_field_features_define_e;

/* Get Data */
/**
 * \brief returns define data of ecc_enable
 * Module - 'field', Submodule - 'features', data - 'ecc_enable'
 * ECC is calculated per whole entry on each entry write, therefore, when writing half-entries\n                      need to get whole entry from the SW and update relevant half entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecc_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_ecc_enable_get(
    int unit);

/**
 * \brief returns define data of switch_to_acl_context
 * Module - 'field', Submodule - 'features', data - 'switch_to_acl_context'
 * Allows to swap the acl_context and fwd_context signals after iPMF1/2 using IPPC_PMF_GENERAL.SWITCH_TO_ACL_CONTEXT.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     switch_to_acl_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_switch_to_acl_context_get(
    int unit);

/**
 * \brief returns define data of per_pp_port_pmf_profile_cs_offset
 * Module - 'field', Submodule - 'features', data - 'per_pp_port_pmf_profile_cs_offset'
 * The placement of PMF_PROFILE field within ERPP_PER_PORT_TABLE. Used because DBAL mapping by device didn't work.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     per_pp_port_pmf_profile_cs_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_per_pp_port_pmf_profile_cs_offset_get(
    int unit);

/**
 * \brief returns define data of tcam_result_flip_eco
 * Module - 'field', Submodule - 'features', data - 'tcam_result_flip_eco'
 * The TCAM result flip ECO is about flippiing lsb and msb parts of the TCAM-result in order to support 80b result being parsed by ARR
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_result_flip_eco - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_tcam_result_flip_eco_get(
    int unit);

/**
 * \brief returns define data of tcam_result_half_payload_on_msb
 * Module - 'field', Submodule - 'features', data - 'tcam_result_half_payload_on_msb'
 * Indicates that for half payload lookup the result is on the MSB half, but not using the tcam_result_flip_eco.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_result_half_payload_on_msb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_tcam_result_half_payload_on_msb_get(
    int unit);

/**
 * \brief returns define data of parsing_start_offset_msb_meaningless
 * Module - 'field', Submodule - 'features', data - 'parsing_start_offset_msb_meaningless'
 * In JR2, the parsing_start_offset signal is 8 bit in ingress but only 7 in egress, so we make the action smaller so as not to have a meaningles MSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     parsing_start_offset_msb_meaningless - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_parsing_start_offset_msb_meaningless_get(
    int unit);

/**
 * \brief returns define data of kbp_opcode_in_ipmf1_cs
 * Module - 'field', Submodule - 'features', data - 'kbp_opcode_in_ipmf1_cs'
 * Indicates whether the context selection of iPMF1 takes the KBP opcode into account.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kbp_opcode_in_ipmf1_cs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_kbp_opcode_in_ipmf1_cs_get(
    int unit);

/**
 * \brief returns define data of kbp_hitbits_correct_in_ipmf1_cs
 * Module - 'field', Submodule - 'features', data - 'kbp_hitbits_correct_in_ipmf1_cs'
 * Indicates whether the context selection of iPMF1 takes the KBP hitbits from the correct place of the elk payload. Assumed to be either 0 or 1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kbp_hitbits_correct_in_ipmf1_cs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_kbp_hitbits_correct_in_ipmf1_cs_get(
    int unit);

/**
 * \brief returns define data of exem_vmv_removable_from_payload
 * Module - 'field', Submodule - 'features', data - 'exem_vmv_removable_from_payload'
 * Indicates whether it is possible to configure a shift to remove the from the EXEM payload.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_vmv_removable_from_payload - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_exem_vmv_removable_from_payload_get(
    int unit);

/**
 * \brief returns define data of multiple_dynamic_mem_enablers
 * Module - 'field', Submodule - 'features', data - 'multiple_dynamic_mem_enablers'
 * Indicates whether it is possible to configure dynamic memory enablers for ST, CS hit, TCAM entry protection etc.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     multiple_dynamic_mem_enablers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_multiple_dynamic_mem_enablers_get(
    int unit);

/**
 * \brief returns define data of aacl_super_group_handler_enable
 * Module - 'field', Submodule - 'features', data - 'aacl_super_group_handler_enable'
 * Indicates whether it is possible to configure Super Group Handler for AACL
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aacl_super_group_handler_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_aacl_super_group_handler_enable_get(
    int unit);

/**
 * \brief returns define data of aacl_tcam_swap_enable
 * Module - 'field', Submodule - 'features', data - 'aacl_tcam_swap_enable'
 * Indicates whether it is possible to configure TCAM swap for AACL
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aacl_tcam_swap_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_aacl_tcam_swap_enable_get(
    int unit);

/**
 * \brief returns define data of extended_l4_ops
 * Module - 'field', Submodule - 'features', data - 'extended_l4_ops'
 * Whether extended L4 Ops is supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     extended_l4_ops - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_extended_l4_ops_get(
    int unit);

/**
 * \brief returns define data of state_table_ipmf1_key_select
 * Module - 'field', Submodule - 'features', data - 'state_table_ipmf1_key_select'
 * Whether we can choose the key for state table in iPMF1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     state_table_ipmf1_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_state_table_ipmf1_key_select_get(
    int unit);

/**
 * \brief returns define data of state_table_acr_bus
 * Module - 'field', Submodule - 'features', data - 'state_table_acr_bus'
 * Whether the EFES/FEM can access the state table result.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     state_table_acr_bus - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_state_table_acr_bus_get(
    int unit);

/**
 * \brief returns define data of state_table_atomic_rmw
 * Module - 'field', Submodule - 'features', data - 'state_table_atomic_rmw'
 * Whether state table uses atomic read modify write (rmw) instead of separate read and write (rw).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     state_table_atomic_rmw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_state_table_atomic_rmw_get(
    int unit);

/**
 * \brief returns define data of hitbit_volatile
 * Module - 'field', Submodule - 'features', data - 'hitbit_volatile'
 * Indicates on, which devices the HIT_INCDICATION memories have volatile values and therefore we add SW state to save them.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hitbit_volatile - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_hitbit_volatile_get(
    int unit);

/**
 * \brief returns define data of fem_replace_msb_instead_lsb
 * Module - 'field', Submodule - 'features', data - 'fem_replace_msb_instead_lsb'
 * Starting from Q2A, the 16 MSB of the overriding TCAM are taken, instead of the 16 LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_replace_msb_instead_lsb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_fem_replace_msb_instead_lsb_get(
    int unit);

/**
 * \brief returns define data of no_parser_resources
 * Module - 'field', Submodule - 'features', data - 'no_parser_resources'
 * Not enough parser resources in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     no_parser_resources - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_no_parser_resources_get(
    int unit);

/**
 * \brief returns define data of dir_ext_epmf
 * Module - 'field', Submodule - 'features', data - 'dir_ext_epmf'
 * Indicates whether Direct Extract is supported for EPMF stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_dir_ext_epmf_get(
    int unit);

/**
 * \brief returns define data of hashing_process_lsb_to_msb
 * Module - 'field', Submodule - 'features', data - 'hashing_process_lsb_to_msb'
 * Indicates whether the Hashing processes the bits from LSB to MSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hashing_process_lsb_to_msb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_hashing_process_lsb_to_msb_get(
    int unit);

/**
 * \brief returns define data of exem_age_flush_scan
 * Module - 'field', Submodule - 'features', data - 'exem_age_flush_scan'
 * Indicates whether EXEM age scan period or flush scan period works.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_age_flush_scan - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_features_exem_age_flush_scan_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_features_table_nof
} dnx_data_field_features_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE SIGNAL_SIZES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_signal_sizes_feature_get(
    int unit,
    dnx_data_field_signal_sizes_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_signal_sizes_define_dual_queue_size,
    dnx_data_field_signal_sizes_define_packet_header_size,
    dnx_data_field_signal_sizes_define_ecn,
    dnx_data_field_signal_sizes_define_congestion_info,
    dnx_data_field_signal_sizes_define_parsing_start_offset_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_signal_sizes_define_nof
} dnx_data_field_signal_sizes_define_e;

/* Get Data */
/**
 * \brief returns define data of dual_queue_size
 * Module - 'field', Submodule - 'signal_sizes', data - 'dual_queue_size'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dual_queue_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_signal_sizes_dual_queue_size_get(
    int unit);

/**
 * \brief returns define data of packet_header_size
 * Module - 'field', Submodule - 'signal_sizes', data - 'packet_header_size'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     packet_header_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_signal_sizes_packet_header_size_get(
    int unit);

/**
 * \brief returns define data of ecn
 * Module - 'field', Submodule - 'signal_sizes', data - 'ecn'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecn - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_signal_sizes_ecn_get(
    int unit);

/**
 * \brief returns define data of congestion_info
 * Module - 'field', Submodule - 'signal_sizes', data - 'congestion_info'
 * CONGESTION_INFO signal. Takes ECN by default, and changed with it.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     congestion_info - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_signal_sizes_congestion_info_get(
    int unit);

/**
 * \brief returns define data of parsing_start_offset_size
 * Module - 'field', Submodule - 'signal_sizes', data - 'parsing_start_offset_size'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     parsing_start_offset_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_signal_sizes_parsing_start_offset_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_signal_sizes_table_nof
} dnx_data_field_signal_sizes_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE DNX_DATA_INTERNAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_dnx_data_internal_feature_get(
    int unit,
    dnx_data_field_dnx_data_internal_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_dnx_data_internal_define_lr_eth_is_da_mac_valid,

    /**
     * Must be last one!
     */
    _dnx_data_field_dnx_data_internal_define_nof
} dnx_data_field_dnx_data_internal_define_e;

/* Get Data */
/**
 * \brief returns define data of lr_eth_is_da_mac_valid
 * Module - 'field', Submodule - 'dnx_data_internal', data - 'lr_eth_is_da_mac_valid'
 * Whether layer record ETH_IS_DA_MAC works on device (works on JR2_B0 but not on JR2_A0).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lr_eth_is_da_mac_valid - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_dnx_data_internal_lr_eth_is_da_mac_valid_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_dnx_data_internal_table_nof
} dnx_data_field_dnx_data_internal_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE TESTS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_tests_feature_get(
    int unit,
    dnx_data_field_tests_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_tests_define_learn_info_actions_structure_change,
    dnx_data_field_tests_define_ingress_time_stamp_increased,
    dnx_data_field_tests_define_ace_debug_signals_exist,

    /**
     * Must be last one!
     */
    _dnx_data_field_tests_define_nof
} dnx_data_field_tests_define_e;

/* Get Data */
/**
 * \brief returns define data of learn_info_actions_structure_change
 * Module - 'field', Submodule - 'tests', data - 'learn_info_actions_structure_change'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     learn_info_actions_structure_change - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tests_learn_info_actions_structure_change_get(
    int unit);

/**
 * \brief returns define data of ingress_time_stamp_increased
 * Module - 'field', Submodule - 'tests', data - 'ingress_time_stamp_increased'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_time_stamp_increased - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tests_ingress_time_stamp_increased_get(
    int unit);

/**
 * \brief returns define data of ace_debug_signals_exist
 * Module - 'field', Submodule - 'tests', data - 'ace_debug_signals_exist'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_debug_signals_exist - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tests_ace_debug_signals_exist_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_tests_table_nof
} dnx_data_field_tests_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_FIELD_H_*/
/* *INDENT-ON* */
