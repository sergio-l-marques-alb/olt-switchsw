/** \file dnx_data_internal_port.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2020 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_PORT_H_
/*{*/
#define _DNX_DATA_INTERNAL_PORT_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_port.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_port_submodule_static_add,
    dnx_data_port_submodule_general,
    dnx_data_port_submodule_egress,
    dnx_data_port_submodule_imb,

    /**
     * Must be last one!
     */
    _dnx_data_port_submodule_nof
} dnx_data_port_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE STATIC_ADD:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_port_static_add_feature_get(
    int unit,
    dnx_data_port_static_add_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_port_static_add_define_default_speed_for_special_if,
    dnx_data_port_static_add_define_fabric_fw_load_method,
    dnx_data_port_static_add_define_fabric_fw_crc_check,
    dnx_data_port_static_add_define_fabric_fw_load_verify,
    dnx_data_port_static_add_define_nif_fw_load_method,
    dnx_data_port_static_add_define_nif_fw_crc_check,
    dnx_data_port_static_add_define_nif_fw_load_verify,

    /**
     * Must be last one!
     */
    _dnx_data_port_static_add_define_nof
} dnx_data_port_static_add_define_e;

/* Get Data */
/**
 * \brief returns define data of default_speed_for_special_if
 * Module - 'port', Submodule - 'static_add', data - 'default_speed_for_special_if'
 * default speed in kbps for special interfaces (tm ports excluding NIF)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_speed_for_special_if - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_static_add_default_speed_for_special_if_get(
    int unit);

/**
 * \brief returns numeric data of fabric_fw_load_method
 * Module - 'port', Submodule - 'static_add', data - 'fabric_fw_load_method'
 * Method of the Fabric firmware load
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_fw_load_method - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_static_add_fabric_fw_load_method_get(
    int unit);

/**
 * \brief returns numeric data of fabric_fw_crc_check
 * Module - 'port', Submodule - 'static_add', data - 'fabric_fw_crc_check'
 * Enable fabric firmware CRC check.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_fw_crc_check - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_static_add_fabric_fw_crc_check_get(
    int unit);

/**
 * \brief returns numeric data of fabric_fw_load_verify
 * Module - 'port', Submodule - 'static_add', data - 'fabric_fw_load_verify'
 * Enable fabric firmware load verification.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_fw_load_verify - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_static_add_fabric_fw_load_verify_get(
    int unit);

/**
 * \brief returns numeric data of nif_fw_load_method
 * Module - 'port', Submodule - 'static_add', data - 'nif_fw_load_method'
 * Method of the Nif firmware load
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_fw_load_method - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_static_add_nif_fw_load_method_get(
    int unit);

/**
 * \brief returns numeric data of nif_fw_crc_check
 * Module - 'port', Submodule - 'static_add', data - 'nif_fw_crc_check'
 * Enable NIF firmware CRC check.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_fw_crc_check - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_static_add_nif_fw_crc_check_get(
    int unit);

/**
 * \brief returns numeric data of nif_fw_load_verify
 * Module - 'port', Submodule - 'static_add', data - 'nif_fw_load_verify'
 * Enable NIF firmware load verification.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_fw_load_verify - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_static_add_nif_fw_load_verify_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_port_static_add_table_ucode_port,
    dnx_data_port_static_add_table_speed,
    dnx_data_port_static_add_table_ext_stat_speed,
    dnx_data_port_static_add_table_eth_padding,
    dnx_data_port_static_add_table_link_training,
    dnx_data_port_static_add_table_ext_stat_link_training,
    dnx_data_port_static_add_table_fec_type,
    dnx_data_port_static_add_table_serdes_lane_config,
    dnx_data_port_static_add_table_serdes_tx_taps,
    dnx_data_port_static_add_table_ext_stat_global_serdes_tx_taps,
    dnx_data_port_static_add_table_ext_stat_lane_serdes_tx_taps,
    dnx_data_port_static_add_table_tx_pam4_precoder,
    dnx_data_port_static_add_table_lp_tx_precoder,
    dnx_data_port_static_add_table_fabric_quad_info,
    dnx_data_port_static_add_table_header_type,
    dnx_data_port_static_add_table_erp_exist,
    dnx_data_port_static_add_table_base_flexe_instance,

    /**
     * Must be last one!
     */
    _dnx_data_port_static_add_table_nof
} dnx_data_port_static_add_table_e;

/* Get Data */
/**
 * \brief get table ucode_port entry 
 * static port configuration
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port
 * 
 * \return
 *     ucode_port - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_ucode_port_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_ucode_port_t * dnx_data_port_static_add_ucode_port_get(
    int unit,
    int port);

/**
 * \brief get table speed entry 
 * per port speed
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     speed - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_speed_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_speed_t * dnx_data_port_static_add_speed_get(
    int unit,
    int port);

/**
 * \brief get table ext_stat_speed entry 
 * per external kbp stat port speed
 * 
 * \param [in] unit - unit #
 * \param [in] ext_stat_port - external device (kbp) statistics port number
 * 
 * \return
 *     ext_stat_speed - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_ext_stat_speed_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_ext_stat_speed_t * dnx_data_port_static_add_ext_stat_speed_get(
    int unit,
    int ext_stat_port);

/**
 * \brief get table eth_padding entry 
 * eth ports padding
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     eth_padding - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_eth_padding_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_eth_padding_t * dnx_data_port_static_add_eth_padding_get(
    int unit,
    int port);

/**
 * \brief get table link_training entry 
 * per port link training (CL72)
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     link_training - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_link_training_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_link_training_t * dnx_data_port_static_add_link_training_get(
    int unit,
    int port);

/**
 * \brief get table ext_stat_link_training entry 
 * per external kbp stat port link training (CL72)
 * 
 * \param [in] unit - unit #
 * \param [in] ext_stat_port - external device (kbp) statistics port number
 * 
 * \return
 *     ext_stat_link_training - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_ext_stat_link_training_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_ext_stat_link_training_t * dnx_data_port_static_add_ext_stat_link_training_get(
    int unit,
    int ext_stat_port);

/**
 * \brief get table fec_type entry 
 * per port FEC type
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     fec_type - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_fec_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_fec_type_t * dnx_data_port_static_add_fec_type_get(
    int unit,
    int port);

/**
 * \brief get table serdes_lane_config entry 
 * serdes lane configurations, related to firmware
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     serdes_lane_config - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_serdes_lane_config_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_serdes_lane_config_t * dnx_data_port_static_add_serdes_lane_config_get(
    int unit,
    int port);

/**
 * \brief get table serdes_tx_taps entry 
 * PHY TX tap configuration
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     serdes_tx_taps - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_serdes_tx_taps_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_serdes_tx_taps_t * dnx_data_port_static_add_serdes_tx_taps_get(
    int unit,
    int port);

/**
 * \brief get table ext_stat_global_serdes_tx_taps entry 
 * PHY TX tap configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ext_stat_global_serdes_tx_taps - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_ext_stat_global_serdes_tx_taps_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_ext_stat_global_serdes_tx_taps_t * dnx_data_port_static_add_ext_stat_global_serdes_tx_taps_get(
    int unit);

/**
 * \brief get table ext_stat_lane_serdes_tx_taps entry 
 * PHY TX tap configuration
 * 
 * \param [in] unit - unit #
 * \param [in] lane - physical lane id
 * 
 * \return
 *     ext_stat_lane_serdes_tx_taps - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_ext_stat_lane_serdes_tx_taps_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_ext_stat_lane_serdes_tx_taps_t * dnx_data_port_static_add_ext_stat_lane_serdes_tx_taps_get(
    int unit,
    int lane);

/**
 * \brief get table tx_pam4_precoder entry 
 * is the precoding enabled on TX side
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     tx_pam4_precoder - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_tx_pam4_precoder_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_tx_pam4_precoder_t * dnx_data_port_static_add_tx_pam4_precoder_get(
    int unit,
    int port);

/**
 * \brief get table lp_tx_precoder entry 
 * has the link partner enabled pre-coding on its TX side. In other words - enable the decoding on my RX side.
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     lp_tx_precoder - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_lp_tx_precoder_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_lp_tx_precoder_t * dnx_data_port_static_add_lp_tx_precoder_get(
    int unit,
    int port);

/**
 * \brief get table fabric_quad_info entry 
 * General fabric quad info
 * 
 * \param [in] unit - unit #
 * \param [in] quad - Quad ID
 * 
 * \return
 *     fabric_quad_info - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_fabric_quad_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_fabric_quad_info_t * dnx_data_port_static_add_fabric_quad_info_get(
    int unit,
    int quad);

/**
 * \brief get table header_type entry 
 * header type information
 * 
 * \param [in] unit - unit #
 * \param [in] port - port
 * 
 * \return
 *     header_type - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_header_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_header_type_t * dnx_data_port_static_add_header_type_get(
    int unit,
    int port);

/**
 * \brief get table erp_exist entry 
 * Is ERP port defined in config file for the core
 * 
 * \param [in] unit - unit #
 * \param [in] core - core
 * 
 * \return
 *     erp_exist - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_erp_exist_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_erp_exist_t * dnx_data_port_static_add_erp_exist_get(
    int unit,
    int core);

/**
 * \brief get table base_flexe_instance entry 
 * base flexe instance
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     base_flexe_instance - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_base_flexe_instance_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_static_add_base_flexe_instance_t * dnx_data_port_static_add_base_flexe_instance_get(
    int unit,
    int port);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'ucode_port'
 * static port configuration
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_ucode_port_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'speed'
 * per port speed
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_speed_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'ext_stat_speed'
 * per external kbp stat port speed
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_ext_stat_speed_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'eth_padding'
 * eth ports padding
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_eth_padding_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'link_training'
 * per port link training (CL72)
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_link_training_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'ext_stat_link_training'
 * per external kbp stat port link training (CL72)
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_ext_stat_link_training_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'fec_type'
 * per port FEC type
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_fec_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'serdes_lane_config'
 * serdes lane configurations, related to firmware
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_serdes_lane_config_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'serdes_tx_taps'
 * PHY TX tap configuration
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_serdes_tx_taps_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'ext_stat_global_serdes_tx_taps'
 * PHY TX tap configuration
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_ext_stat_global_serdes_tx_taps_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'ext_stat_lane_serdes_tx_taps'
 * PHY TX tap configuration
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_ext_stat_lane_serdes_tx_taps_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'tx_pam4_precoder'
 * is the precoding enabled on TX side
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_tx_pam4_precoder_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'lp_tx_precoder'
 * has the link partner enabled pre-coding on its TX side. In other words - enable the decoding on my RX side.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_lp_tx_precoder_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'fabric_quad_info'
 * General fabric quad info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_fabric_quad_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'header_type'
 * header type information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_header_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'erp_exist'
 * Is ERP port defined in config file for the core
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_erp_exist_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'base_flexe_instance'
 * base flexe instance
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_static_add_base_flexe_instance_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)ucode_port info
 * static port configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ucode_port - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_ucode_port_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)speed info
 * per port speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     speed - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_speed_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ext_stat_speed info
 * per external kbp stat port speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ext_stat_speed - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_ext_stat_speed_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)eth_padding info
 * eth ports padding
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     eth_padding - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_eth_padding_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)link_training info
 * per port link training (CL72)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     link_training - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_link_training_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ext_stat_link_training info
 * per external kbp stat port link training (CL72)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ext_stat_link_training - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_ext_stat_link_training_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fec_type info
 * per port FEC type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_type - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_fec_type_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)serdes_lane_config info
 * serdes lane configurations, related to firmware
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     serdes_lane_config - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_serdes_lane_config_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)serdes_tx_taps info
 * PHY TX tap configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     serdes_tx_taps - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_serdes_tx_taps_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ext_stat_global_serdes_tx_taps info
 * PHY TX tap configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ext_stat_global_serdes_tx_taps - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_ext_stat_global_serdes_tx_taps_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ext_stat_lane_serdes_tx_taps info
 * PHY TX tap configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ext_stat_lane_serdes_tx_taps - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_ext_stat_lane_serdes_tx_taps_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)tx_pam4_precoder info
 * is the precoding enabled on TX side
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tx_pam4_precoder - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_tx_pam4_precoder_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)lp_tx_precoder info
 * has the link partner enabled pre-coding on its TX side. In other words - enable the decoding on my RX side.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lp_tx_precoder - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_lp_tx_precoder_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fabric_quad_info info
 * General fabric quad info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_quad_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_fabric_quad_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)header_type info
 * header type information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     header_type - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_header_type_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)erp_exist info
 * Is ERP port defined in config file for the core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     erp_exist - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_erp_exist_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)base_flexe_instance info
 * base flexe instance
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     base_flexe_instance - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_static_add_base_flexe_instance_info_get(
    int unit);

/*
 * SUBMODULE GENERAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_port_general_feature_get(
    int unit,
    dnx_data_port_general_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_port_general_define_erp_tm_port,
    dnx_data_port_general_define_max_nof_channels,
    dnx_data_port_general_define_fabric_phys_offset,
    dnx_data_port_general_define_pp_dsp_size,
    dnx_data_port_general_define_ingress_vlan_domain_size,
    dnx_data_port_general_define_vlan_domain_size,
    dnx_data_port_general_define_ffc_instruction_size,
    dnx_data_port_general_define_max_first_header_size_to_skip,
    dnx_data_port_general_define_prt_ffc_width_start_offset,
    dnx_data_port_general_define_prt_ffc_start_input_offset,
    dnx_data_port_general_define_nof_tm_ports,
    dnx_data_port_general_define_nof_tm_ports_per_fap_id,
    dnx_data_port_general_define_nof_pp_ports,
    dnx_data_port_general_define_reserved_tm_port,
    dnx_data_port_general_define_nof_vlan_membership_if,
    dnx_data_port_general_define_max_vlan_membership_if,
    dnx_data_port_general_define_fabric_port_base,
    dnx_data_port_general_define_pp_port_bits_size,
    dnx_data_port_general_define_nof_port_bits_in_pp_bus,
    dnx_data_port_general_define_prt_configuration_ptch2_default_index,
    dnx_data_port_general_define_prt_configuration_ptch1_default_index,
    dnx_data_port_general_define_prt_configuration_eth_default_index,

    /**
     * Must be last one!
     */
    _dnx_data_port_general_define_nof
} dnx_data_port_general_define_e;

/* Get Data */
/**
 * \brief returns define data of erp_tm_port
 * Module - 'port', Submodule - 'general', data - 'erp_tm_port'
 * tm port reserved for ERP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     erp_tm_port - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_erp_tm_port_get(
    int unit);

/**
 * \brief returns define data of max_nof_channels
 * Module - 'port', Submodule - 'general', data - 'max_nof_channels'
 * max nof channel in an interface
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_channels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_max_nof_channels_get(
    int unit);

/**
 * \brief returns define data of fabric_phys_offset
 * Module - 'port', Submodule - 'general', data - 'fabric_phys_offset'
 * Offset for physical fabric ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_phys_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_fabric_phys_offset_get(
    int unit);

/**
 * \brief returns define data of pp_dsp_size
 * Module - 'port', Submodule - 'general', data - 'pp_dsp_size'
 * define the size of the pp dsp (in bits)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pp_dsp_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_pp_dsp_size_get(
    int unit);

/**
 * \brief returns define data of ingress_vlan_domain_size
 * Module - 'port', Submodule - 'general', data - 'ingress_vlan_domain_size'
 * define the size of the ingress vlan domain (in bits)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_vlan_domain_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_ingress_vlan_domain_size_get(
    int unit);

/**
 * \brief returns define data of vlan_domain_size
 * Module - 'port', Submodule - 'general', data - 'vlan_domain_size'
 * define the max size of vlan domain (in bits)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vlan_domain_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_vlan_domain_size_get(
    int unit);

/**
 * \brief returns define data of ffc_instruction_size
 * Module - 'port', Submodule - 'general', data - 'ffc_instruction_size'
 * define the size of the ffc instruction (in bits)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_ffc_instruction_size_get(
    int unit);

/**
 * \brief returns define data of max_first_header_size_to_skip
 * Module - 'port', Submodule - 'general', data - 'max_first_header_size_to_skip'
 * max number of bytes that can be skipped
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_first_header_size_to_skip - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_max_first_header_size_to_skip_get(
    int unit);

/**
 * \brief returns define data of prt_ffc_width_start_offset
 * Module - 'port', Submodule - 'general', data - 'prt_ffc_width_start_offset'
 * The offset of ffc width in the PRT FFC builder
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     prt_ffc_width_start_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_prt_ffc_width_start_offset_get(
    int unit);

/**
 * \brief returns define data of prt_ffc_start_input_offset
 * Module - 'port', Submodule - 'general', data - 'prt_ffc_start_input_offset'
 * The offset of ffc input offset in the PRT FFC builder
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     prt_ffc_start_input_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_prt_ffc_start_input_offset_get(
    int unit);

/**
 * \brief returns numeric data of nof_tm_ports
 * Module - 'port', Submodule - 'general', data - 'nof_tm_ports'
 * nof tm ports per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tm_ports - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_nof_tm_ports_get(
    int unit);

/**
 * \brief returns numeric data of nof_tm_ports_per_fap_id
 * Module - 'port', Submodule - 'general', data - 'nof_tm_ports_per_fap_id'
 * nof tm ports per fap id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tm_ports_per_fap_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_nof_tm_ports_per_fap_id_get(
    int unit);

/**
 * \brief returns numeric data of nof_pp_ports
 * Module - 'port', Submodule - 'general', data - 'nof_pp_ports'
 * nof pp ports per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pp_ports - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_nof_pp_ports_get(
    int unit);

/**
 * \brief returns numeric data of reserved_tm_port
 * Module - 'port', Submodule - 'general', data - 'reserved_tm_port'
 * tm port reserved for redirection of returned credits in LAG SCH
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     reserved_tm_port - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_reserved_tm_port_get(
    int unit);

/**
 * \brief returns numeric data of nof_vlan_membership_if
 * Module - 'port', Submodule - 'general', data - 'nof_vlan_membership_if'
 * number of vlan_membership_if
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vlan_membership_if - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_nof_vlan_membership_if_get(
    int unit);

/**
 * \brief returns numeric data of max_vlan_membership_if
 * Module - 'port', Submodule - 'general', data - 'max_vlan_membership_if'
 * max value of vlan_membership_if
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_vlan_membership_if - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_max_vlan_membership_if_get(
    int unit);

/**
 * \brief returns numeric data of fabric_port_base
 * Module - 'port', Submodule - 'general', data - 'fabric_port_base'
 * first fabric logical port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_port_base - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_fabric_port_base_get(
    int unit);

/**
 * \brief returns numeric data of pp_port_bits_size
 * Module - 'port', Submodule - 'general', data - 'pp_port_bits_size'
 * pp port size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pp_port_bits_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_pp_port_bits_size_get(
    int unit);

/**
 * \brief returns numeric data of nof_port_bits_in_pp_bus
 * Module - 'port', Submodule - 'general', data - 'nof_port_bits_in_pp_bus'
 * nof port bits in PP bus
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_port_bits_in_pp_bus - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_nof_port_bits_in_pp_bus_get(
    int unit);

/**
 * \brief returns numeric data of prt_configuration_ptch2_default_index
 * Module - 'port', Submodule - 'general', data - 'prt_configuration_ptch2_default_index'
 * index of ptch2 default configuration in prt_configuration table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     prt_configuration_ptch2_default_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_prt_configuration_ptch2_default_index_get(
    int unit);

/**
 * \brief returns numeric data of prt_configuration_ptch1_default_index
 * Module - 'port', Submodule - 'general', data - 'prt_configuration_ptch1_default_index'
 * index of ptch1 default configuration in prt_configuration table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     prt_configuration_ptch1_default_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_prt_configuration_ptch1_default_index_get(
    int unit);

/**
 * \brief returns numeric data of prt_configuration_eth_default_index
 * Module - 'port', Submodule - 'general', data - 'prt_configuration_eth_default_index'
 * index of eth default configuration in prt_configuration table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     prt_configuration_eth_default_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_general_prt_configuration_eth_default_index_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_port_general_table_prt_configuration,
    dnx_data_port_general_table_first_header_size,

    /**
     * Must be last one!
     */
    _dnx_data_port_general_table_nof
} dnx_data_port_general_table_e;

/* Get Data */
/**
 * \brief get table prt_configuration entry 
 * prt configuration information
 * 
 * \param [in] unit - unit #
 * \param [in] index - arbitrary index
 * 
 * \return
 *     prt_configuration - returns the relevant entry values grouped in struct - see dnx_data_port_general_prt_configuration_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_general_prt_configuration_t * dnx_data_port_general_prt_configuration_get(
    int unit,
    int index);

/**
 * \brief get table first_header_size entry 
 * size of the first header that should be skipped
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port
 * 
 * \return
 *     first_header_size - returns the relevant entry values grouped in struct - see dnx_data_port_general_first_header_size_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_general_first_header_size_t * dnx_data_port_general_first_header_size_get(
    int unit,
    int port);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'general', table - 'prt_configuration'
 * prt configuration information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_general_prt_configuration_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'general', table - 'first_header_size'
 * size of the first header that should be skipped
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_general_first_header_size_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)prt_configuration info
 * prt configuration information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     prt_configuration - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_general_prt_configuration_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)first_header_size info
 * size of the first header that should be skipped
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_header_size - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_general_first_header_size_info_get(
    int unit);

/*
 * SUBMODULE EGRESS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_port_egress_feature_get(
    int unit,
    dnx_data_port_egress_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_port_egress_define_nof_ifs,

    /**
     * Must be last one!
     */
    _dnx_data_port_egress_define_nof
} dnx_data_port_egress_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ifs
 * Module - 'port', Submodule - 'egress', data - 'nof_ifs'
 * nof egress intrfaces per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_port_egress_nof_ifs_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_port_egress_table_nof
} dnx_data_port_egress_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE IMB:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_port_imb_feature_get(
    int unit,
    dnx_data_port_imb_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_port_imb_define_nof
} dnx_data_port_imb_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_port_imb_table_imb_type_info,

    /**
     * Must be last one!
     */
    _dnx_data_port_imb_table_nof
} dnx_data_port_imb_table_e;

/* Get Data */
/**
 * \brief get table imb_type_info entry 
 * Information per IMB type
 * 
 * \param [in] unit - unit #
 * \param [in] type - IMB type
 * 
 * \return
 *     imb_type_info - returns the relevant entry values grouped in struct - see dnx_data_port_imb_imb_type_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_port_imb_imb_type_info_t * dnx_data_port_imb_imb_type_info_get(
    int unit,
    int type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'imb', table - 'imb_type_info'
 * Information per IMB type
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_imb_imb_type_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)imb_type_info info
 * Information per IMB type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     imb_type_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_port_imb_imb_type_info_info_get(
    int unit);

/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_port_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_PORT_H_*/
/* *INDENT-ON* */
