/** \file dnx_data_lif.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2020 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_LIF_H_
/*{*/
#define _DNX_DATA_LIF_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_lif.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_lif
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_lif_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - GLOBAL_LIF:
 * Global lif attributes
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * if sys_inlif is null, then tunnel lif does not update inlif array
     */
    dnx_data_lif_global_lif_prevent_tunnel_update_rif,

    /**
     * Must be last one!
     */
    _dnx_data_lif_global_lif_feature_nof
} dnx_data_lif_global_lif_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_lif_global_lif_feature_get_f) (
    int unit,
    dnx_data_lif_global_lif_feature_e feature);

/**
 * \brief returns define data of use_mdb_size
 * Module - 'lif', Submodule - 'global_lif', data - 'use_mdb_size'
 * Some lif sizes are not taken from dnx data, but from the mdb. Use this flag to indicate if it should be used, or just use default minimal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     use_mdb_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_global_lif_use_mdb_size_get_f) (
    int unit);

/**
 * \brief returns define data of glem_rif_optimization_enabled
 * Module - 'lif', Submodule - 'global_lif', data - 'glem_rif_optimization_enabled'
 * Amount of out RIFs one GLEM entry can hold for optimized GLEM usage is 4.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     glem_rif_optimization_enabled - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_global_lif_glem_rif_optimization_enabled_get_f) (
    int unit);

/**
 * \brief returns define data of null_lif
 * Module - 'lif', Submodule - 'global_lif', data - 'null_lif'
 * ERPP GLEM trap requires NULL LIF to be added to GLEM by default.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     null_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_global_lif_null_lif_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_global_in_lifs
 * Module - 'lif', Submodule - 'global_lif', data - 'nof_global_in_lifs'
 * Number of in global lifs in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_global_in_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_global_lif_nof_global_in_lifs_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_global_out_lifs
 * Module - 'lif', Submodule - 'global_lif', data - 'nof_global_out_lifs'
 * Number of out global lifs in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_global_out_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_global_lif_nof_global_out_lifs_get_f) (
    int unit);

/**
 * \brief returns numeric data of egress_in_lif_null_value
 * Module - 'lif', Submodule - 'global_lif', data - 'egress_in_lif_null_value'
 * IN_LIF null value in egress stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_in_lif_null_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_global_lif_egress_in_lif_null_value_get_f) (
    int unit);

/**
 * \brief returns numeric data of egress_out_lif_null_value
 * Module - 'lif', Submodule - 'global_lif', data - 'egress_out_lif_null_value'
 * OUT_LIF null value in egress stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_out_lif_null_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_global_lif_egress_out_lif_null_value_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_global_l2_gport_lifs
 * Module - 'lif', Submodule - 'global_lif', data - 'nof_global_l2_gport_lifs'
 * The mpls and vlan ports don't have enough bits to support the full global lif address. Their number is limited by this value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_global_l2_gport_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_global_lif_nof_global_l2_gport_lifs_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_LIF - GLOBAL_LIF:
 * {
 */
/**
 * \brief Interface for lif global_lif data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_lif_global_lif_feature_get_f feature_get;
    /**
     * returns define data of use_mdb_size
     */
    dnx_data_lif_global_lif_use_mdb_size_get_f use_mdb_size_get;
    /**
     * returns define data of glem_rif_optimization_enabled
     */
    dnx_data_lif_global_lif_glem_rif_optimization_enabled_get_f glem_rif_optimization_enabled_get;
    /**
     * returns define data of null_lif
     */
    dnx_data_lif_global_lif_null_lif_get_f null_lif_get;
    /**
     * returns numeric data of nof_global_in_lifs
     */
    dnx_data_lif_global_lif_nof_global_in_lifs_get_f nof_global_in_lifs_get;
    /**
     * returns numeric data of nof_global_out_lifs
     */
    dnx_data_lif_global_lif_nof_global_out_lifs_get_f nof_global_out_lifs_get;
    /**
     * returns numeric data of egress_in_lif_null_value
     */
    dnx_data_lif_global_lif_egress_in_lif_null_value_get_f egress_in_lif_null_value_get;
    /**
     * returns numeric data of egress_out_lif_null_value
     */
    dnx_data_lif_global_lif_egress_out_lif_null_value_get_f egress_out_lif_null_value_get;
    /**
     * returns numeric data of nof_global_l2_gport_lifs
     */
    dnx_data_lif_global_lif_nof_global_l2_gport_lifs_get_f nof_global_l2_gport_lifs_get;
} dnx_data_if_lif_global_lif_t;

/*
 * }
 */

/*
 * SUBMODULE  - IN_LIF:
 * In lif attributes
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * defines the existence of mapped inlif profile
     */
    dnx_data_lif_in_lif_mapped_in_lif_profile,
    /**
     * defines the existence of inlif profile in iop mode
     */
    dnx_data_lif_in_lif_in_lif_profile_iop_mode,

    /**
     * Must be last one!
     */
    _dnx_data_lif_in_lif_feature_nof
} dnx_data_lif_in_lif_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_lif_in_lif_feature_get_f) (
    int unit,
    dnx_data_lif_in_lif_feature_e feature);

/**
 * \brief returns define data of inlif_index_bit_size
 * Module - 'lif', Submodule - 'in_lif', data - 'inlif_index_bit_size'
 * This is the size of a single index in the inlif table. Divide the entry bit size by this to get its size in indexes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     inlif_index_bit_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_inlif_index_bit_size_get_f) (
    int unit);

/**
 * \brief returns define data of inlif_minimum_index_size
 * Module - 'lif', Submodule - 'in_lif', data - 'inlif_minimum_index_size'
 * The minimum size in indexes of an inlif entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     inlif_minimum_index_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_inlif_minimum_index_size_get_f) (
    int unit);

/**
 * \brief returns define data of inlif_resource_tag_size
 * Module - 'lif', Submodule - 'in_lif', data - 'inlif_resource_tag_size'
 * The size of the inlif resource's n-packs. The packs are used to prevent fragmentation by assigning each pack a fixed entry size. The pack should be the least common denominator of every possible entry side. See the SDD for full description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     inlif_resource_tag_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_inlif_resource_tag_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_in_lif_profiles
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_in_lif_profiles'
 * Number of possible in_lif profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_in_lif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_nof_in_lif_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_used_in_lif_profile_bits
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_used_in_lif_profile_bits'
 * Number of used in_lif_profile bits out of 8.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_used_in_lif_profile_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_nof_used_in_lif_profile_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_used_eth_rif_profile_bits
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_used_eth_rif_profile_bits'
 * Number of used eth_rif_profile bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_used_eth_rif_profile_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_nof_used_eth_rif_profile_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_in_lif_incoming_orientation
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_in_lif_incoming_orientation'
 * Number of possible in_lif profile incoming orientation groups.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_in_lif_incoming_orientation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_nof_in_lif_incoming_orientation_get_f) (
    int unit);

/**
 * \brief returns define data of nof_eth_rif_profiles
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_eth_rif_profiles'
 * Number of possible eth_rif profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eth_rif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_nof_eth_rif_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_da_not_found_destination_profiles
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_da_not_found_destination_profiles'
 * Number of da_not_found_destination profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_da_not_found_destination_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_nof_da_not_found_destination_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of default_da_not_found_destination_profile
 * Module - 'lif', Submodule - 'in_lif', data - 'default_da_not_found_destination_profile'
 * Default da_not_found_destination profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_da_not_found_destination_profile - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_default_da_not_found_destination_profile_get_f) (
    int unit);

/**
 * \brief returns define data of drop_in_lif
 * Module - 'lif', Submodule - 'in_lif', data - 'drop_in_lif'
 * local in_lif id performing trap with drop action.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     drop_in_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_drop_in_lif_get_f) (
    int unit);

/**
 * \brief returns define data of mc_bridge_fallback_per_lif_profile
 * Module - 'lif', Submodule - 'in_lif', data - 'mc_bridge_fallback_per_lif_profile'
 * Enable/Disable the MC bridge fallback functionality based on LIF profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mc_bridge_fallback_per_lif_profile - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_mc_bridge_fallback_per_lif_profile_get_f) (
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_indexed_mode
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_indexed_mode'
 * number of values needed for property indexed_mode in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_indexed_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_in_lif_profile_allocate_indexed_mode_get_f) (
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_orientation
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_orientation'
 * number of values needed for egress property in_lif_orientation in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_orientation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_in_lif_profile_allocate_orientation_get_f) (
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_policer_inner_dp
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_policer_inner_dp'
 * number of values needed for egress property ive_inner_qos_dp_profile in in_lif_profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_policer_inner_dp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_in_lif_profile_allocate_policer_inner_dp_get_f) (
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_policer_outer_dp
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_policer_outer_dp'
 * number of values needed for egress property ive_outer_qos_dp_profile in in_lif_profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_policer_outer_dp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_in_lif_profile_allocate_policer_outer_dp_get_f) (
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_same_interface_mode
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_same_interface_mode'
 * number of values needed for egress property in_lif_profile_allocate_same_interface_mode in in_lif_profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_same_interface_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_in_lif_in_lif_profile_allocate_same_interface_mode_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_LIF - IN_LIF:
 * {
 */
/**
 * \brief Interface for lif in_lif data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_lif_in_lif_feature_get_f feature_get;
    /**
     * returns define data of inlif_index_bit_size
     */
    dnx_data_lif_in_lif_inlif_index_bit_size_get_f inlif_index_bit_size_get;
    /**
     * returns define data of inlif_minimum_index_size
     */
    dnx_data_lif_in_lif_inlif_minimum_index_size_get_f inlif_minimum_index_size_get;
    /**
     * returns define data of inlif_resource_tag_size
     */
    dnx_data_lif_in_lif_inlif_resource_tag_size_get_f inlif_resource_tag_size_get;
    /**
     * returns define data of nof_in_lif_profiles
     */
    dnx_data_lif_in_lif_nof_in_lif_profiles_get_f nof_in_lif_profiles_get;
    /**
     * returns define data of nof_used_in_lif_profile_bits
     */
    dnx_data_lif_in_lif_nof_used_in_lif_profile_bits_get_f nof_used_in_lif_profile_bits_get;
    /**
     * returns define data of nof_used_eth_rif_profile_bits
     */
    dnx_data_lif_in_lif_nof_used_eth_rif_profile_bits_get_f nof_used_eth_rif_profile_bits_get;
    /**
     * returns define data of nof_in_lif_incoming_orientation
     */
    dnx_data_lif_in_lif_nof_in_lif_incoming_orientation_get_f nof_in_lif_incoming_orientation_get;
    /**
     * returns define data of nof_eth_rif_profiles
     */
    dnx_data_lif_in_lif_nof_eth_rif_profiles_get_f nof_eth_rif_profiles_get;
    /**
     * returns define data of nof_da_not_found_destination_profiles
     */
    dnx_data_lif_in_lif_nof_da_not_found_destination_profiles_get_f nof_da_not_found_destination_profiles_get;
    /**
     * returns define data of default_da_not_found_destination_profile
     */
    dnx_data_lif_in_lif_default_da_not_found_destination_profile_get_f default_da_not_found_destination_profile_get;
    /**
     * returns define data of drop_in_lif
     */
    dnx_data_lif_in_lif_drop_in_lif_get_f drop_in_lif_get;
    /**
     * returns define data of mc_bridge_fallback_per_lif_profile
     */
    dnx_data_lif_in_lif_mc_bridge_fallback_per_lif_profile_get_f mc_bridge_fallback_per_lif_profile_get;
    /**
     * returns numeric data of in_lif_profile_allocate_indexed_mode
     */
    dnx_data_lif_in_lif_in_lif_profile_allocate_indexed_mode_get_f in_lif_profile_allocate_indexed_mode_get;
    /**
     * returns numeric data of in_lif_profile_allocate_orientation
     */
    dnx_data_lif_in_lif_in_lif_profile_allocate_orientation_get_f in_lif_profile_allocate_orientation_get;
    /**
     * returns numeric data of in_lif_profile_allocate_policer_inner_dp
     */
    dnx_data_lif_in_lif_in_lif_profile_allocate_policer_inner_dp_get_f in_lif_profile_allocate_policer_inner_dp_get;
    /**
     * returns numeric data of in_lif_profile_allocate_policer_outer_dp
     */
    dnx_data_lif_in_lif_in_lif_profile_allocate_policer_outer_dp_get_f in_lif_profile_allocate_policer_outer_dp_get;
    /**
     * returns numeric data of in_lif_profile_allocate_same_interface_mode
     */
    dnx_data_lif_in_lif_in_lif_profile_allocate_same_interface_mode_get_f in_lif_profile_allocate_same_interface_mode_get;
} dnx_data_if_lif_in_lif_t;

/*
 * }
 */

/*
 * SUBMODULE  - OUT_LIF:
 * Out lif attributes
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule out_lif table logical_to_physical_phase_map
 * Table info:
 * Map outlif logical phase to physical phase. The reverse mapping is implied from this.
 */
typedef struct
{
    /**
     * Mapped physical phase.
     */
    int physical_phase;
} dnx_data_lif_out_lif_logical_to_physical_phase_map_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_lif_out_lif_feature_nof
} dnx_data_lif_out_lif_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_lif_out_lif_feature_get_f) (
    int unit,
    dnx_data_lif_out_lif_feature_e feature);

/**
 * \brief returns define data of nof_out_lif_profiles
 * Module - 'lif', Submodule - 'out_lif', data - 'nof_out_lif_profiles'
 * Number of possible out_lif profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_nof_out_lif_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_erpp_out_lif_profiles
 * Module - 'lif', Submodule - 'out_lif', data - 'nof_erpp_out_lif_profiles'
 * Number of possible erpp_out_lif profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_erpp_out_lif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_nof_erpp_out_lif_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_out_lif_outgoing_orientation
 * Module - 'lif', Submodule - 'out_lif', data - 'nof_out_lif_outgoing_orientation'
 * Number of possible out_lif profile outgoing orientation groups.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_outgoing_orientation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_nof_out_lif_outgoing_orientation_get_f) (
    int unit);

/**
 * \brief returns define data of outrif_profile_width
 * Module - 'lif', Submodule - 'out_lif', data - 'outrif_profile_width'
 * The number of bits in the outrif profile from GLEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outrif_profile_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_outrif_profile_width_get_f) (
    int unit);

/**
 * \brief returns define data of glem_result
 * Module - 'lif', Submodule - 'out_lif', data - 'glem_result'
 * The number of bits in GLEM result.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     glem_result - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_glem_result_get_f) (
    int unit);

/**
 * \brief returns define data of physical_bank_pointer_size
 * Module - 'lif', Submodule - 'out_lif', data - 'physical_bank_pointer_size'
 * How many bits from the outlif pointer are used to indicate the physical bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_bank_pointer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_physical_bank_pointer_size_get_f) (
    int unit);

/**
 * \brief returns define data of outlif_eedb_banks_pointer_size
 * Module - 'lif', Submodule - 'out_lif', data - 'outlif_eedb_banks_pointer_size'
 * pointer size used to access eedb banks.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_eedb_banks_pointer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_outlif_eedb_banks_pointer_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of outlif_pointer_size
 * Module - 'lif', Submodule - 'out_lif', data - 'outlif_pointer_size'
 * The number of bits in the outlif profile from GLEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_pointer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_outlif_pointer_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of allocation_bank_size
 * Module - 'lif', Submodule - 'out_lif', data - 'allocation_bank_size'
 * Size of the outlif bank used by the outlif allocation algorithm.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     allocation_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_allocation_bank_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of local_outlif_width
 * Module - 'lif', Submodule - 'out_lif', data - 'local_outlif_width'
 * Size of the outlif bank used by the outlif allocation algorithm.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     local_outlif_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_local_outlif_width_get_f) (
    int unit);

/**
 * \brief returns numeric data of outlif_profile_width
 * Module - 'lif', Submodule - 'out_lif', data - 'outlif_profile_width'
 * The number of bits in the outlif profile from GLEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_profile_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_outlif_profile_width_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_local_out_lifs
 * Module - 'lif', Submodule - 'out_lif', data - 'nof_local_out_lifs'
 * Number of potential local outlifs in the device. Derived from the pointer size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_local_out_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_nof_local_out_lifs_get_f) (
    int unit);

/**
 * \brief returns numeric data of physical_bank_size
 * Module - 'lif', Submodule - 'out_lif', data - 'physical_bank_size'
 * Size of the outlif bank used by the phase map and mags. Derived from the outlif pointer size and the physical bank pointer size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_out_lif_physical_bank_size_get_f) (
    int unit);

/**
 * \brief get table logical_to_physical_phase_map entry 
 * Map outlif logical phase to physical phase. The reverse mapping is implied from this.
 * 
 * \param [in] unit - unit #
 * \param [in] logical_phase - Logical phase to map.
 * 
 * \return
 *     logical_to_physical_phase_map - returns the relevant entry values grouped in struct - see dnx_data_lif_out_lif_logical_to_physical_phase_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_lif_out_lif_logical_to_physical_phase_map_t *(
    *dnx_data_lif_out_lif_logical_to_physical_phase_map_get_f) (
    int unit,
    int logical_phase);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_LIF - OUT_LIF:
 * {
 */
/**
 * \brief Interface for lif out_lif data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_lif_out_lif_feature_get_f feature_get;
    /**
     * returns define data of nof_out_lif_profiles
     */
    dnx_data_lif_out_lif_nof_out_lif_profiles_get_f nof_out_lif_profiles_get;
    /**
     * returns define data of nof_erpp_out_lif_profiles
     */
    dnx_data_lif_out_lif_nof_erpp_out_lif_profiles_get_f nof_erpp_out_lif_profiles_get;
    /**
     * returns define data of nof_out_lif_outgoing_orientation
     */
    dnx_data_lif_out_lif_nof_out_lif_outgoing_orientation_get_f nof_out_lif_outgoing_orientation_get;
    /**
     * returns define data of outrif_profile_width
     */
    dnx_data_lif_out_lif_outrif_profile_width_get_f outrif_profile_width_get;
    /**
     * returns define data of glem_result
     */
    dnx_data_lif_out_lif_glem_result_get_f glem_result_get;
    /**
     * returns define data of physical_bank_pointer_size
     */
    dnx_data_lif_out_lif_physical_bank_pointer_size_get_f physical_bank_pointer_size_get;
    /**
     * returns define data of outlif_eedb_banks_pointer_size
     */
    dnx_data_lif_out_lif_outlif_eedb_banks_pointer_size_get_f outlif_eedb_banks_pointer_size_get;
    /**
     * returns numeric data of outlif_pointer_size
     */
    dnx_data_lif_out_lif_outlif_pointer_size_get_f outlif_pointer_size_get;
    /**
     * returns numeric data of allocation_bank_size
     */
    dnx_data_lif_out_lif_allocation_bank_size_get_f allocation_bank_size_get;
    /**
     * returns numeric data of local_outlif_width
     */
    dnx_data_lif_out_lif_local_outlif_width_get_f local_outlif_width_get;
    /**
     * returns numeric data of outlif_profile_width
     */
    dnx_data_lif_out_lif_outlif_profile_width_get_f outlif_profile_width_get;
    /**
     * returns numeric data of nof_local_out_lifs
     */
    dnx_data_lif_out_lif_nof_local_out_lifs_get_f nof_local_out_lifs_get;
    /**
     * returns numeric data of physical_bank_size
     */
    dnx_data_lif_out_lif_physical_bank_size_get_f physical_bank_size_get;
    /**
     * get table logical_to_physical_phase_map entry 
     */
    dnx_data_lif_out_lif_logical_to_physical_phase_map_get_f logical_to_physical_phase_map_get;
    /**
     * get general info table about table (for example key size)logical_to_physical_phase_map info
     */
    dnxc_data_table_info_get_f logical_to_physical_phase_map_info_get;
} dnx_data_if_lif_out_lif_t;

/*
 * }
 */

/*
 * SUBMODULE  - LIF_TABLE_MANAGER:
 * module for local lif allocation
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_lif_lif_table_manager_feature_nof
} dnx_data_lif_lif_table_manager_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_lif_lif_table_manager_feature_get_f) (
    int unit,
    dnx_data_lif_lif_table_manager_feature_e feature);

/**
 * \brief returns define data of max_nof_lif_tables
 * Module - 'lif', Submodule - 'lif_table_manager', data - 'max_nof_lif_tables'
 * Maximal number of logical lif tables (inlif + outlif)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_lif_tables - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_lif_table_manager_max_nof_lif_tables_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_result_types
 * Module - 'lif', Submodule - 'lif_table_manager', data - 'max_nof_result_types'
 * Maximal number of result types in lif table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_result_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_lif_table_manager_max_nof_result_types_get_f) (
    int unit);

/**
 * \brief returns define data of max_fields_per_result_type
 * Module - 'lif', Submodule - 'lif_table_manager', data - 'max_fields_per_result_type'
 * Maximal number of fields for one result types in lif table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fields_per_result_type - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_lif_table_manager_max_fields_per_result_type_get_f) (
    int unit);

/**
 * \brief returns define data of max_fields_per_table
 * Module - 'lif', Submodule - 'lif_table_manager', data - 'max_fields_per_table'
 * Maximal number of fields in a lif table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fields_per_table - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_lif_lif_table_manager_max_fields_per_table_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_LIF - LIF_TABLE_MANAGER:
 * {
 */
/**
 * \brief Interface for lif lif_table_manager data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_lif_lif_table_manager_feature_get_f feature_get;
    /**
     * returns define data of max_nof_lif_tables
     */
    dnx_data_lif_lif_table_manager_max_nof_lif_tables_get_f max_nof_lif_tables_get;
    /**
     * returns define data of max_nof_result_types
     */
    dnx_data_lif_lif_table_manager_max_nof_result_types_get_f max_nof_result_types_get;
    /**
     * returns define data of max_fields_per_result_type
     */
    dnx_data_lif_lif_table_manager_max_fields_per_result_type_get_f max_fields_per_result_type_get;
    /**
     * returns define data of max_fields_per_table
     */
    dnx_data_lif_lif_table_manager_max_fields_per_table_get_f max_fields_per_table_get;
} dnx_data_if_lif_lif_table_manager_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEATURE:
 * 
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * IOP mode incorrect outlif selection
     */
    dnx_data_lif_feature_iop_mode_outlif_selection,
    /**
     * IOP mode incorrect lif profile key selection for orientation
     */
    dnx_data_lif_feature_iop_mode_orientation_selection,
    /**
     * In lif tunnel wide data is supported
     */
    dnx_data_lif_feature_in_lif_tunnel_wide_data,

    /**
     * Must be last one!
     */
    _dnx_data_lif_feature_feature_nof
} dnx_data_lif_feature_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_lif_feature_feature_get_f) (
    int unit,
    dnx_data_lif_feature_feature_e feature);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_LIF - FEATURE:
 * {
 */
/**
 * \brief Interface for lif feature data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_lif_feature_feature_get_f feature_get;
} dnx_data_if_lif_feature_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_LIF:
 * {
 */
/**
 * \brief Interface for lif data
 */
typedef struct
{
    /**
     * Interface for lif global_lif data
     */
    dnx_data_if_lif_global_lif_t global_lif;
    /**
     * Interface for lif in_lif data
     */
    dnx_data_if_lif_in_lif_t in_lif;
    /**
     * Interface for lif out_lif data
     */
    dnx_data_if_lif_out_lif_t out_lif;
    /**
     * Interface for lif lif_table_manager data
     */
    dnx_data_if_lif_lif_table_manager_t lif_table_manager;
    /**
     * Interface for lif feature data
     */
    dnx_data_if_lif_feature_t feature;
} dnx_data_if_lif_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_lif_t dnx_data_lif;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_LIF_H_*/
/* *INDENT-ON* */
