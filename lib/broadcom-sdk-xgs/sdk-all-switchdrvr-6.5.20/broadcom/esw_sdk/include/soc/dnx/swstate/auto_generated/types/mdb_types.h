/** \file dnx/swstate/auto_generated/types/mdb_types.h
 *
 * sw state types (structs/enums/typedefs)
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 */
/*
 * $Copyright: (c) 2020 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */

#ifndef __MDB_TYPES_H__
#define __MDB_TYPES_H__

#include <soc/dnxc/swstate/dnxc_sw_state_h_includes.h>
#include <include/soc/dnx/dnx_data/auto_generated/dnx_data_l3.h>
#include <soc/dnx/dbal/auto_generated/dbal_defines_fields.h>
#include <soc/dnx/dbal/auto_generated/dbal_defines_tables.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_device.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_mdb.h>
#include <soc/dnx/mdb_global.h>
/*
 * MACROs
 */

/**
 * Indicate that an encoding value isn't available.
 */
#define MDB_INVALID_EM_FORMAT_VALUE 0xFF

/**
 * The EM logical key has a size of 8 bits and the TID 6, this is the max value of both which is 256 + 64 = 320.
 */
#define MDB_EM_MAX_KEYS_PLUS_TID_VALS_SIZE 320

/*
 * STRUCTs
 */

typedef struct {
    /**
     * The macro type of this cluster, in case of LL phydb it must be MDB_EEDB_BANK.
     */
    mdb_macro_types_e macro_type;
    /**
     * the index of the macro 0-nof indexes of the macro types -1
     */
    uint8 macro_index;
    /**
     * 0- NOF clusters in case of a MACRO A/B or bank number in case of EEDB bank.
     */
    uint8 cluster_index;
    /**
     * This is the serial number of the cluster in the entry which is a part of.e.g. if the entry is 480bits width and start on cluster 4, then cluster 4 will get position 0, cluster 5 position 1, 6->2 and 7->3.
     */
    uint8 cluster_position_in_entry;
    /**
     * The physical start address of entries in this cluster (inclusive)
     */
    int start_address;
    /**
     * The physical end address is calculated using the start_address + MDB_NOF_ROWS_IN_MACRO_A/B_CLUSTER / MDB_NOF_ROWS_IN_EEDB_BANK (exclusive).
     */
    int end_address;
} mdb_cluster_info_t;

/**
 * Info for the FEC resource allocation
 */
typedef struct {
    /**
     * Information for the hierarchy value for each bank of FEC IDs
     */
    uint32* fec_hierarchy_map;
    /**
     * The first FEC ID available for an  hierarchy.
     */
    uint32* fec_id_range_start;
    /**
     * The size of the FEC ID range of an hierarchy.
     */
    uint32* fec_id_range_size;
} l3_fec_hierarchy_info_t;

typedef struct {
    /**
     * The total number of clusters that were allocated for this table at init.
     */
    int number_of_alloc_clusters;
    /**
     * The total number of clusters associated with this table.
     */
    int number_of_clusters;
    /**
     * The number of clusters that each entry holds.
     */
    int nof_cluster_per_entry;
    /**
     * The cluster information.
     */
    mdb_cluster_info_t* clusters_info;
} mdb_db_info_t;

/**
 * This structure holds information to update the EM bank size and the EM formats which depends on the bank sizes.
 */
typedef struct {
    /**
     * Does this bank use flex.
     */
    uint8 is_flex;
    /**
     * Accumulates the macro_b entries equivalent bank size that were used (relevant for EM only).Basically an allocation in DHA will result in +2 and in DHB in +1.Note that the row size doesn't affect the calculation  (240 doesn't counted twice)
     */
    uint32 bank_size_used_macro_b;
    /**
     * The macro index that the bank sizes were collected to.
     */
    uint8 macro_index;
    /**
     * The macro type that the bank sizes were collected to.
     */
    mdb_macro_types_e macro_type;
    /**
     * The clusters that are used in this macro for the given PDB.
     */
    uint32 cluster_mapping;
} dh_em_bank_info;

/**
 * This structure holds a single EM table key-format information.which is the format allocation to each key type.
 */
typedef struct {
    /**
     * Holds for each table and app_id its defined key size. This key size is after round up to nearest available SPN.
     */
    uint8 key_size[DNX_DATA_MAX_MDB_EM_MAX_NOF_TIDS];
    /**
     * Maps between a key (key size + TID size) value to its allocated format.
     */
    uint8 format_count;
    /**
     * Maps between a key (key size + TID size) value to its allocated format.
     */
    uint32 key_to_format_map[MDB_EM_MAX_KEYS_PLUS_TID_VALS_SIZE];
    /**
     * This structure holds the information of each EM PDB interface that is used for updating the relevant clusters EM format.
     */
    dh_em_bank_info em_bank_info[DNX_DATA_MAX_MDB_PDBS_MAX_NOF_INTERFACE_DHS];
    /**
     * Number of bits taken from the entry key lsbits after hashing to be used as the address, these bits are not part of the entry stored in the cluster.
     */
    uint32 nof_address_bits;
} em_key_format_info;

/**
 * The MDB table association of a MACRO clusters.
 */
typedef struct {
    /**
     * The MDB PDB that is associated with the MACRO cluster
     */
    dbal_enum_value_field_mdb_physical_table_e pdb;
    /**
     * Holds additional information regarding the cluster using the MDB_INIT_CLUSTER_FLAG_XXX flags
     */
    uint8 flags;
} cluster_assoc_info;

/**
 * The data contained within a single cluster
 */
typedef struct {
    /**
     * The SW shadow of of a single cluster, only allocated for Direct/EEDB.
     */
    uint32 (*data)[DNX_DATA_MAX_MDB_DH_CLUSTER_ROW_WIDTH_UINT32];
} cluster_data;

/**
 * An array that holds for each cluster its MDB table association and SW shadow in case of Direct/EEDB clusters.
 */
typedef struct {
    /**
     * Enable MDB cache.
     */
    uint8 cache_enabled;
    /**
     * The MDB table association of a MACRO clusters.
     */
    cluster_assoc_info* macro_cluster_assoc[MDB_NOF_MACRO_TYPES];
    /**
     * The SW shadow of MACRO clusters/banks, only allocated for Direct/EEDB.
     */
    cluster_data* macro_cluster_cache[MDB_NOF_MACRO_TYPES];
    /**
     * Cache for eedb hitbit banks. Since they're always read and clear, we must cache them after every call or they'll be overridden.
     */
    uint32* eedb_banks_hitbit[DNX_DATA_MAX_MDB_EEDB_NOF_EEDB_BANKS];
    /**
     * Cache for small KAPS BB hitbit banks. Since they're always read and clear, we must cache them after every call or they'll be overridden.
     */
    uint32** small_kaps_bb_hitbit;
    /**
     * Cache for small KAPS RPB hitbit banks. Since they're always read and clear, we must cache them after every call or they'll be overridden.
     */
    uint32** small_kaps_rpb_hitbit;
    /**
     * Holds a mapping from physical address to physical direct table (including EEDB and ADS stored in MDB clusters) and cluster number for faster entry lookup.
     */
    uint32* direct_address_mapping[DBAL_NOF_ENUM_MDB_PHYSICAL_TABLE_VALUES];
    /**
     * Holds a mapping from logical address to physical EEDB table (including EEDB stored in MDB clusters) and cluster number (LL + data) for faster entry lookup.
     */
    uint32* eedb_address_mapping;
} mdb_cluster_info;

/**
 * Information required for the eedb bank traffic lock feature.
 */
typedef struct {
    /**
     * Holds the local lif which is required when accessing the eedb lock feature. First index is instance, second is phase.
     */
    int* local_lifs[2];
    /**
     * Use these global lifs as global lif destination when the eedb access feature is used
     */
    int global_lif_destination[2];
} eedb_bank_traffic_lock_t;

/**
 * An array that holds for each physical table the addresses of its physical resources.
 */
typedef struct {
    /**
     * Holds all the EM key and format information for both the DHs init and the MDB tables init.
     */
    em_key_format_info em_key_format[DBAL_NOF_PHYSICAL_TABLES];
    /**
     * clusters information of the MDB tables.
     */
    mdb_db_info_t db[DBAL_NOF_ENUM_MDB_PHYSICAL_TABLE_VALUES];
    /**
     * Each entry in this array holds the capacity of an MDB table. This is the absolute maximum capacity, effectively unreachable for EM/LPM.
     */
    int capacity[DBAL_NOF_PHYSICAL_TABLES];
    /**
     * EM entry count per table and encoding.
     */
    int em_entry_count[DBAL_NOF_PHYSICAL_TABLES][DNX_DATA_MAX_MDB_EM_NOF_ENCODING_TYPES];
    /**
     * Pessimistic EM entry capacity estimate based on table and encoding.
     */
    int em_entry_capacity_estimate[DBAL_NOF_PHYSICAL_TABLES][DNX_DATA_MAX_MDB_EM_NOF_ENCODING_TYPES];
    /**
     * Average EM entry capacity estimate based on table and encoding.
     */
    int em_entry_capacity_estimate_average[DBAL_NOF_PHYSICAL_TABLES][DNX_DATA_MAX_MDB_EM_NOF_ENCODING_TYPES];
    /**
     * the EEDB payload type.
     */
    uint32 eedb_payload_type[DBAL_NOF_ENUM_MDB_EEDB_PHASE_VALUES];
    /**
     * The MDB cluster association and SW shadow.
     */
    mdb_cluster_info mdb_cluster_infos;
    /**
     * the maximal  FEC ID value supported.
     */
    uint32 max_fec_id_value;
    eedb_bank_traffic_lock_t eedb_bank_traffic_lock;
    /**
     * FEC hierarchy mapping information
     */
    l3_fec_hierarchy_info_t fec_hierarchy_info;
    /**
     * The MDB profile
     */
    uint8 mdb_profile;
    /**
     * MDB EM init done indication
     */
    uint8 mdb_em_init_done;
    /**
     * The KAPS RPB TCAM scan active configuration
     */
    uint32 kaps_scan_cfg_on[2];
    /**
     * The KAPS RPB TCAM scan paused configuration
     */
    uint32 kaps_scan_cfg_paused[2];
} mdb_tables_info;


#endif /* __MDB_TYPES_H__ */
