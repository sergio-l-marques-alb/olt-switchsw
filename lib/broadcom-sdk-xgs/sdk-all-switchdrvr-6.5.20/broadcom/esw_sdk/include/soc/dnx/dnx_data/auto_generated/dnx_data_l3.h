/** \file dnx_data_l3.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2020 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_L3_H_
/*{*/
#define _DNX_DATA_L3_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_l3.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_l3
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_l3_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - EGR_POINTED:
 * Virtual egress objects which do not access GLEM
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_egr_pointed_feature_nof
} dnx_data_l3_egr_pointed_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_egr_pointed_feature_get_f) (
    int unit,
    dnx_data_l3_egr_pointed_feature_e feature);

/**
 * \brief returns define data of first_egr_pointed_id
 * Module - 'l3', Submodule - 'egr_pointed', data - 'first_egr_pointed_id'
 * Identifier of very first virtual egress pointed object.                            Range is from 'first_egr_pointed_id' to 'nof_egr_pointed_ids - 1'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_egr_pointed_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_egr_pointed_first_egr_pointed_id_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_egr_pointed_ids
 * Module - 'l3', Submodule - 'egr_pointed', data - 'nof_egr_pointed_ids'
 * Number of virtual egress pointed object ids
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_pointed_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_egr_pointed_nof_egr_pointed_ids_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_bits_in_egr_pointed_id
 * Module - 'l3', Submodule - 'egr_pointed', data - 'nof_bits_in_egr_pointed_id'
 * Number of bits representing one virtual egress pointed object id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_egr_pointed_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_egr_pointed_nof_bits_in_egr_pointed_id_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - EGR_POINTED:
 * {
 */
/**
 * \brief Interface for l3 egr_pointed data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_egr_pointed_feature_get_f feature_get;
    /**
     * returns define data of first_egr_pointed_id
     */
    dnx_data_l3_egr_pointed_first_egr_pointed_id_get_f first_egr_pointed_id_get;
    /**
     * returns numeric data of nof_egr_pointed_ids
     */
    dnx_data_l3_egr_pointed_nof_egr_pointed_ids_get_f nof_egr_pointed_ids_get;
    /**
     * returns numeric data of nof_bits_in_egr_pointed_id
     */
    dnx_data_l3_egr_pointed_nof_bits_in_egr_pointed_id_get_f nof_bits_in_egr_pointed_id_get;
} dnx_data_if_l3_egr_pointed_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEC:
 * FEC data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_fec_feature_nof
} dnx_data_l3_fec_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_fec_feature_get_f) (
    int unit,
    dnx_data_l3_fec_feature_e feature);

/**
 * \brief returns define data of nof_fecs
 * Module - 'l3', Submodule - 'fec', data - 'nof_fecs'
 * The maximal number of FECs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fecs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_nof_fecs_get_f) (
    int unit);

/**
 * \brief returns define data of first_valid_fec_ecmp_id
 * Module - 'l3', Submodule - 'fec', data - 'first_valid_fec_ecmp_id'
 * The ID of the first valid FEC/ECMP group which can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_valid_fec_ecmp_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_first_valid_fec_ecmp_id_get_f) (
    int unit);

/**
 * \brief returns define data of max_fec_id_for_single_dhb_cluster_pair_granularity
 * Module - 'l3', Submodule - 'fec', data - 'max_fec_id_for_single_dhb_cluster_pair_granularity'
 * The maximal FEC ID that support a single DHB cluasters pair.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fec_id_for_single_dhb_cluster_pair_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_fec_id_for_single_dhb_cluster_pair_granularity_get_f) (
    int unit);

/**
 * \brief returns define data of max_fec_id_for_double_dhb_cluster_pair_granularity
 * Module - 'l3', Submodule - 'fec', data - 'max_fec_id_for_double_dhb_cluster_pair_granularity'
 * The maximal FEC ID that requiere an even number of DHB clusters pairs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fec_id_for_double_dhb_cluster_pair_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_fec_id_for_double_dhb_cluster_pair_granularity_get_f) (
    int unit);

/**
 * \brief returns define data of max_default_fec
 * Module - 'l3', Submodule - 'fec', data - 'max_default_fec'
 * The maximal FEC id that can be used for default route.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_default_fec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_default_fec_get_f) (
    int unit);

/**
 * \brief returns define data of bank_size
 * Module - 'l3', Submodule - 'fec', data - 'bank_size'
 * The smallest number of FECs which belong to the same hierarchy
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_bank_size_get_f) (
    int unit);

/**
 * \brief returns define data of bank_size_round_up
 * Module - 'l3', Submodule - 'fec', data - 'bank_size_round_up'
 * In some cases FEC bank size contains extra FECs due to round up which results from physical to logical translation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_size_round_up - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_bank_size_round_up_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_super_fecs_per_bank
 * Module - 'l3', Submodule - 'fec', data - 'max_nof_super_fecs_per_bank'
 * The max NOF SUPER FEC IDs per resource manager bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_super_fecs_per_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_nof_super_fecs_per_bank_get_f) (
    int unit);

/**
 * \brief returns define data of nof_physical_fecs_per_bank
 * Module - 'l3', Submodule - 'fec', data - 'nof_physical_fecs_per_bank'
 * The number of physical FEC IDs per bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_physical_fecs_per_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_nof_physical_fecs_per_bank_get_f) (
    int unit);

/**
 * \brief returns define data of super_fec_size
 * Module - 'l3', Submodule - 'fec', data - 'super_fec_size'
 * The number of bits of a single super FEC in the MDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     super_fec_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_super_fec_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_banks
 * Module - 'l3', Submodule - 'fec', data - 'max_nof_banks'
 * The maximal NOF possible banks in the device (not MDB profile dependent).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_nof_banks_get_f) (
    int unit);

/**
 * \brief returns define data of first_bank_without_id_alloc
 * Module - 'l3', Submodule - 'fec', data - 'first_bank_without_id_alloc'
 * the first fec allocation bank that can be used for allocating FECs without an ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_bank_without_id_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_first_bank_without_id_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of max_super_fec_id
 * Module - 'l3', Submodule - 'fec', data - 'max_super_fec_id'
 * The max ID of the super FEC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_super_fec_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_super_fec_id_get_f) (
    int unit);

/**
 * \brief returns define data of fer_mdb_granularity_ratio
 * Module - 'l3', Submodule - 'fec', data - 'fer_mdb_granularity_ratio'
 * This value indicate the ratio between the FER FEC granularity relative to the MDB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fer_mdb_granularity_ratio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_fer_mdb_granularity_ratio_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - FEC:
 * {
 */
/**
 * \brief Interface for l3 fec data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_fec_feature_get_f feature_get;
    /**
     * returns define data of nof_fecs
     */
    dnx_data_l3_fec_nof_fecs_get_f nof_fecs_get;
    /**
     * returns define data of first_valid_fec_ecmp_id
     */
    dnx_data_l3_fec_first_valid_fec_ecmp_id_get_f first_valid_fec_ecmp_id_get;
    /**
     * returns define data of max_fec_id_for_single_dhb_cluster_pair_granularity
     */
    dnx_data_l3_fec_max_fec_id_for_single_dhb_cluster_pair_granularity_get_f max_fec_id_for_single_dhb_cluster_pair_granularity_get;
    /**
     * returns define data of max_fec_id_for_double_dhb_cluster_pair_granularity
     */
    dnx_data_l3_fec_max_fec_id_for_double_dhb_cluster_pair_granularity_get_f max_fec_id_for_double_dhb_cluster_pair_granularity_get;
    /**
     * returns define data of max_default_fec
     */
    dnx_data_l3_fec_max_default_fec_get_f max_default_fec_get;
    /**
     * returns define data of bank_size
     */
    dnx_data_l3_fec_bank_size_get_f bank_size_get;
    /**
     * returns define data of bank_size_round_up
     */
    dnx_data_l3_fec_bank_size_round_up_get_f bank_size_round_up_get;
    /**
     * returns define data of max_nof_super_fecs_per_bank
     */
    dnx_data_l3_fec_max_nof_super_fecs_per_bank_get_f max_nof_super_fecs_per_bank_get;
    /**
     * returns define data of nof_physical_fecs_per_bank
     */
    dnx_data_l3_fec_nof_physical_fecs_per_bank_get_f nof_physical_fecs_per_bank_get;
    /**
     * returns define data of super_fec_size
     */
    dnx_data_l3_fec_super_fec_size_get_f super_fec_size_get;
    /**
     * returns define data of max_nof_banks
     */
    dnx_data_l3_fec_max_nof_banks_get_f max_nof_banks_get;
    /**
     * returns define data of first_bank_without_id_alloc
     */
    dnx_data_l3_fec_first_bank_without_id_alloc_get_f first_bank_without_id_alloc_get;
    /**
     * returns define data of max_super_fec_id
     */
    dnx_data_l3_fec_max_super_fec_id_get_f max_super_fec_id_get;
    /**
     * returns define data of fer_mdb_granularity_ratio
     */
    dnx_data_l3_fec_fer_mdb_granularity_ratio_get_f fer_mdb_granularity_ratio_get;
} dnx_data_if_l3_fec_t;

/*
 * }
 */

/*
 * SUBMODULE  - SOURCE_ADDRESS:
 * Source address data.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_feature_nof
} dnx_data_l3_source_address_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_source_address_feature_get_f) (
    int unit,
    dnx_data_l3_source_address_feature_e feature);

/**
 * \brief returns define data of source_address_table_size
 * Module - 'l3', Submodule - 'source_address', data - 'source_address_table_size'
 * The number of entries in the source address table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_address_table_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_source_address_source_address_table_size_get_f) (
    int unit);

/**
 * \brief returns define data of custom_sa_use_dual_homing
 * Module - 'l3', Submodule - 'source_address', data - 'custom_sa_use_dual_homing'
 * Indication whether ARP custom sa feature is using EEDB dual homing field or full mac address from source address table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     custom_sa_use_dual_homing - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_source_address_custom_sa_use_dual_homing_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - SOURCE_ADDRESS:
 * {
 */
/**
 * \brief Interface for l3 source_address data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_source_address_feature_get_f feature_get;
    /**
     * returns define data of source_address_table_size
     */
    dnx_data_l3_source_address_source_address_table_size_get_f source_address_table_size_get;
    /**
     * returns define data of custom_sa_use_dual_homing
     */
    dnx_data_l3_source_address_custom_sa_use_dual_homing_get_f custom_sa_use_dual_homing_get;
} dnx_data_if_l3_source_address_t;

/*
 * }
 */

/*
 * SUBMODULE  - VRF:
 * vrf data.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrf_feature_nof
} dnx_data_l3_vrf_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_vrf_feature_get_f) (
    int unit,
    dnx_data_l3_vrf_feature_e feature);

/**
 * \brief returns define data of nof_vrf
 * Module - 'l3', Submodule - 'vrf', data - 'nof_vrf'
 * The maximal number of VRFs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vrf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrf_nof_vrf_get_f) (
    int unit);

/**
 * \brief returns define data of nof_vrf_ipv6
 * Module - 'l3', Submodule - 'vrf', data - 'nof_vrf_ipv6'
 * The maximal number of VRFs supported by the device for an IPv6 MC table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vrf_ipv6 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrf_nof_vrf_ipv6_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - VRF:
 * {
 */
/**
 * \brief Interface for l3 vrf data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_vrf_feature_get_f feature_get;
    /**
     * returns define data of nof_vrf
     */
    dnx_data_l3_vrf_nof_vrf_get_f nof_vrf_get;
    /**
     * returns define data of nof_vrf_ipv6
     */
    dnx_data_l3_vrf_nof_vrf_ipv6_get_f nof_vrf_ipv6_get;
} dnx_data_if_l3_vrf_t;

/*
 * }
 */

/*
 * SUBMODULE  - ROUTING_ENABLERS:
 * routing enablers data.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_routing_enablers_feature_nof
} dnx_data_l3_routing_enablers_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_routing_enablers_feature_get_f) (
    int unit,
    dnx_data_l3_routing_enablers_feature_e feature);

/**
 * \brief returns define data of nof_routing_enablers_profiles
 * Module - 'l3', Submodule - 'routing_enablers', data - 'nof_routing_enablers_profiles'
 * The maximal number of references for a routing enablers vector.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_routing_enablers_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_routing_enablers_nof_routing_enablers_profiles_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - ROUTING_ENABLERS:
 * {
 */
/**
 * \brief Interface for l3 routing_enablers data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_routing_enablers_feature_get_f feature_get;
    /**
     * returns define data of nof_routing_enablers_profiles
     */
    dnx_data_l3_routing_enablers_nof_routing_enablers_profiles_get_f nof_routing_enablers_profiles_get;
} dnx_data_if_l3_routing_enablers_t;

/*
 * }
 */

/*
 * SUBMODULE  - RIF:
 * Routing interface
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_rif_feature_nof
} dnx_data_l3_rif_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_rif_feature_get_f) (
    int unit,
    dnx_data_l3_rif_feature_e feature);

/**
 * \brief returns define data of max_nof_rifs
 * Module - 'l3', Submodule - 'rif', data - 'max_nof_rifs'
 * Maximum number of rifs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_rifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_rif_max_nof_rifs_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_rifs
 * Module - 'l3', Submodule - 'rif', data - 'nof_rifs'
 * Number of rifs available in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_rif_nof_rifs_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - RIF:
 * {
 */
/**
 * \brief Interface for l3 rif data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_rif_feature_get_f feature_get;
    /**
     * returns define data of max_nof_rifs
     */
    dnx_data_l3_rif_max_nof_rifs_get_f max_nof_rifs_get;
    /**
     * returns numeric data of nof_rifs
     */
    dnx_data_l3_rif_nof_rifs_get_f nof_rifs_get;
} dnx_data_if_l3_rif_t;

/*
 * }
 */

/*
 * SUBMODULE  - FWD:
 * Forwarding data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule fwd table lpm_profile_to_entry_strength
 * Table info:
 * LPM profile to entry strength mapping
 */
typedef struct
{
    /**
     * Prefix length ranges for non-default entries.The value in each array cell is the highest value of the range.
     */
    uint32 prefix_len_non_def[8];
    /**
     * Prefix length ranges for non-default entries.The value in each array cell is the highest value of the range.
     */
    uint32 prefix_len_def[8];
    /**
     * Entry strength.
     */
    uint32 entry_strength_non_def[8];
    /**
     * Default entry strength.
     */
    uint32 entry_strength_def[8];
} dnx_data_l3_fwd_lpm_profile_to_entry_strength_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_fwd_feature_nof
} dnx_data_l3_fwd_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_fwd_feature_get_f) (
    int unit,
    dnx_data_l3_fwd_feature_e feature);

/**
 * \brief returns define data of flp_fragment_support
 * Module - 'l3', Submodule - 'fwd', data - 'flp_fragment_support'
 * Indicate whether the LB fragmentation is handled by the FLP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flp_fragment_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_flp_fragment_support_get_f) (
    int unit);

/**
 * \brief returns define data of max_mc_group_lpm
 * Module - 'l3', Submodule - 'fwd', data - 'max_mc_group_lpm'
 * The maximum number of MC group ID for IPMC route entries.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_mc_group_lpm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_max_mc_group_lpm_get_f) (
    int unit);

/**
 * \brief returns define data of max_mc_group_em
 * Module - 'l3', Submodule - 'fwd', data - 'max_mc_group_em'
 * The maximum number of MC group ID for IPMC host entries.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_mc_group_em - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_max_mc_group_em_get_f) (
    int unit);

/**
 * \brief returns define data of nof_my_mac_prefixes
 * Module - 'l3', Submodule - 'fwd', data - 'nof_my_mac_prefixes'
 * The number of my MACs prefixes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_my_mac_prefixes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_nof_my_mac_prefixes_get_f) (
    int unit);

/**
 * \brief returns define data of compressed_sip_svl_size
 * Module - 'l3', Submodule - 'fwd', data - 'compressed_sip_svl_size'
 * The size in bits of the IPMC IP6 compressed SIP for SVL table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     compressed_sip_svl_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_compressed_sip_svl_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compressed_svl_sip
 * Module - 'l3', Submodule - 'fwd', data - 'nof_compressed_svl_sip'
 * Number of supported IPMC compressed SIPs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compressed_svl_sip - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_nof_compressed_svl_sip_get_f) (
    int unit);

/**
 * \brief returns define data of lpm_strength_profile_support
 * Module - 'l3', Submodule - 'fwd', data - 'lpm_strength_profile_support'
 * Indicates whether the KAPS strength mapping is different per LPM profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpm_strength_profile_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_lpm_strength_profile_support_get_f) (
    int unit);

/**
 * \brief returns define data of nof_lpm_profiles
 * Module - 'l3', Submodule - 'fwd', data - 'nof_lpm_profiles'
 * The number of LPM profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lpm_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_nof_lpm_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_prefix_ranges
 * Module - 'l3', Submodule - 'fwd', data - 'nof_prefix_ranges'
 * The number of KAPS prefix ranges.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prefix_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_nof_prefix_ranges_get_f) (
    int unit);

/**
 * \brief get table lpm_profile_to_entry_strength entry 
 * LPM profile to entry strength mapping
 * 
 * \param [in] unit - unit #
 * \param [in] lpm_profile - LPM profile.
 * \param [in] kaps_intf - KAPS interface.
 * 
 * \return
 *     lpm_profile_to_entry_strength - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_lpm_profile_to_entry_strength_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fwd_lpm_profile_to_entry_strength_t *(
    *dnx_data_l3_fwd_lpm_profile_to_entry_strength_get_f) (
    int unit,
    int lpm_profile,
    int kaps_intf);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - FWD:
 * {
 */
/**
 * \brief Interface for l3 fwd data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_fwd_feature_get_f feature_get;
    /**
     * returns define data of flp_fragment_support
     */
    dnx_data_l3_fwd_flp_fragment_support_get_f flp_fragment_support_get;
    /**
     * returns define data of max_mc_group_lpm
     */
    dnx_data_l3_fwd_max_mc_group_lpm_get_f max_mc_group_lpm_get;
    /**
     * returns define data of max_mc_group_em
     */
    dnx_data_l3_fwd_max_mc_group_em_get_f max_mc_group_em_get;
    /**
     * returns define data of nof_my_mac_prefixes
     */
    dnx_data_l3_fwd_nof_my_mac_prefixes_get_f nof_my_mac_prefixes_get;
    /**
     * returns define data of compressed_sip_svl_size
     */
    dnx_data_l3_fwd_compressed_sip_svl_size_get_f compressed_sip_svl_size_get;
    /**
     * returns define data of nof_compressed_svl_sip
     */
    dnx_data_l3_fwd_nof_compressed_svl_sip_get_f nof_compressed_svl_sip_get;
    /**
     * returns define data of lpm_strength_profile_support
     */
    dnx_data_l3_fwd_lpm_strength_profile_support_get_f lpm_strength_profile_support_get;
    /**
     * returns define data of nof_lpm_profiles
     */
    dnx_data_l3_fwd_nof_lpm_profiles_get_f nof_lpm_profiles_get;
    /**
     * returns define data of nof_prefix_ranges
     */
    dnx_data_l3_fwd_nof_prefix_ranges_get_f nof_prefix_ranges_get;
    /**
     * get table lpm_profile_to_entry_strength entry 
     */
    dnx_data_l3_fwd_lpm_profile_to_entry_strength_get_f lpm_profile_to_entry_strength_get;
    /**
     * get general info table about table (for example key size)lpm_profile_to_entry_strength info
     */
    dnxc_data_table_info_get_f lpm_profile_to_entry_strength_info_get;
} dnx_data_if_l3_fwd_t;

/*
 * }
 */

/*
 * SUBMODULE  - ECMP:
 * ECMP data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule ecmp table consistent_tables_info
 * Table info:
 * information on the different consistent tables sizes
 */
typedef struct
{
    /**
     * The NOF entries this tables holds
     */
    uint32 nof_entries;
    /**
     * A single table entry size in bits.
     */
    uint32 entry_size_in_bits;
    /**
     * The max NOF unique members that this table can hold.
     */
    uint32 max_nof_unique_members;
} dnx_data_l3_ecmp_consistent_tables_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Allows extended number of ECMPs.
     */
    dnx_data_l3_ecmp_ecmp_extended,

    /**
     * Must be last one!
     */
    _dnx_data_l3_ecmp_feature_nof
} dnx_data_l3_ecmp_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_ecmp_feature_get_f) (
    int unit,
    dnx_data_l3_ecmp_feature_e feature);

/**
 * \brief returns define data of group_size_multiply_and_divide_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_multiply_and_divide_nof_bits'
 * The NOF bit of the multiply and division group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_multiply_and_divide_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_group_size_multiply_and_divide_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of group_size_consistent_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_consistent_nof_bits'
 * The NOF bit of the consistent group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_consistent_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_group_size_consistent_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of group_size_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_nof_bits'
 * The max NOF bit of the ECMP group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_group_size_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of max_group_size
 * Module - 'l3', Submodule - 'ecmp', data - 'max_group_size'
 * The maximal size of an ECMP group.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_group_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_max_group_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ecmp_per_bank_of_low_ecmps
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_per_bank_of_low_ecmps'
 * The low 32k ECMP are placed in a memory of 16 banks, each bank holds 2k ECMPS.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_per_bank_of_low_ecmps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_ecmp_per_bank_of_low_ecmps_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ecmp_basic_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_basic_mode'
 * Number of ECMP groups that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_basic_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_ecmp_basic_mode_get_f) (
    int unit);

/**
 * \brief returns define data of total_nof_ecmp
 * Module - 'l3', Submodule - 'ecmp', data - 'total_nof_ecmp'
 * The total number of IDs that are considered to be in the ECMP range.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_total_nof_ecmp_get_f) (
    int unit);

/**
 * \brief returns define data of max_ecmp_basic_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'max_ecmp_basic_mode'
 * Maximum ECMP group ID that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_ecmp_basic_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_max_ecmp_basic_mode_get_f) (
    int unit);

/**
 * \brief returns define data of max_ecmp_extended_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'max_ecmp_extended_mode'
 * Maximum ECMP group ID that can be created in extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_ecmp_extended_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_max_ecmp_extended_mode_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ecmp_per_bank_of_extended_ecmps
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_per_bank_of_extended_ecmps'
 * The upper 8k ECMP (from 32k to 40k) are placed in a memory of 16 banks, each bank holds 512 ECMPS.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_per_bank_of_extended_ecmps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_ecmp_per_bank_of_extended_ecmps_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fec_banks_per_extended_ecmp_bank
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_fec_banks_per_extended_ecmp_bank'
 * nof fec protection banks to be used for 1 ecmp extended bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_banks_per_extended_ecmp_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_fec_banks_per_extended_ecmp_bank_get_f) (
    int unit);

/**
 * \brief returns define data of nof_group_profiles_per_hierarchy
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_group_profiles_per_hierarchy'
 * Number of profiles that are available for each ECMP hierarchy.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_group_profiles_per_hierarchy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_group_profiles_per_hierarchy_get_f) (
    int unit);

/**
 * \brief returns define data of member_table_nof_rows_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'member_table_nof_rows_size_in_bits'
 * The NOF bits required to represent the NOF rows in the consistent members memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_table_nof_rows_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_member_table_nof_rows_size_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of member_table_address_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'member_table_address_size_in_bits'
 * The member table address size in bits when it used by the ECMP profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_table_address_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_member_table_address_size_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of ecmp_stage_map_size
 * Module - 'l3', Submodule - 'ecmp', data - 'ecmp_stage_map_size'
 * The smallest number of consecutive ECMP groups which belong to the same hierarchy
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecmp_stage_map_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_ecmp_stage_map_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ecmp_banks_basic
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_banks_basic'
 * The number of ECMP banks in the basic range of IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_banks_basic - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_ecmp_banks_basic_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ecmp_banks_extended
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_banks_extended'
 * The number of ECMP banks in the extended range of IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_banks_extended - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_ecmp_banks_extended_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ecmp
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp'
 * Number of ECMPs in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_ecmp_get_f) (
    int unit);

/**
 * \brief returns define data of profile_id_size
 * Module - 'l3', Submodule - 'ecmp', data - 'profile_id_size'
 * The size of the profile ID field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     profile_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_profile_id_size_get_f) (
    int unit);

/**
 * \brief returns define data of profile_id_offset
 * Module - 'l3', Submodule - 'ecmp', data - 'profile_id_offset'
 * The offset of the profile ID field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     profile_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_profile_id_offset_get_f) (
    int unit);

/**
 * \brief returns define data of member_table_row_width
 * Module - 'l3', Submodule - 'ecmp', data - 'member_table_row_width'
 * The width in bits of a row in the ECMP member table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_table_row_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_member_table_row_width_get_f) (
    int unit);

/**
 * \brief returns define data of tunnel_priority_support
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_support'
 * Device has tunnel priority support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_tunnel_priority_support_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tunnel_priority_map_profiles
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_tunnel_priority_map_profiles'
 * The NOF tunnle priority map profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tunnel_priority_map_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_tunnel_priority_map_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of tunnel_priority_field_width
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_field_width'
 * The width in bits of the tunnel priority field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_field_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_tunnel_priority_field_width_get_f) (
    int unit);

/**
 * \brief returns define data of tunnel_priority_index_field_width
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_index_field_width'
 * The size of the possible TP indexes field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_index_field_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_tunnel_priority_index_field_width_get_f) (
    int unit);

/**
 * \brief returns define data of consistent_mem_row_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'consistent_mem_row_size_in_bits'
 * The size in bits of a row in the consistent members memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     consistent_mem_row_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_consistent_mem_row_size_in_bits_get_f) (
    int unit);

/**
 * \brief get table consistent_tables_info entry 
 * information on the different consistent tables sizes
 * 
 * \param [in] unit - unit #
 * \param [in] table_type - The table type.
 * 
 * \return
 *     consistent_tables_info - returns the relevant entry values grouped in struct - see dnx_data_l3_ecmp_consistent_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_ecmp_consistent_tables_info_t *(
    *dnx_data_l3_ecmp_consistent_tables_info_get_f) (
    int unit,
    int table_type);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - ECMP:
 * {
 */
/**
 * \brief Interface for l3 ecmp data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_ecmp_feature_get_f feature_get;
    /**
     * returns define data of group_size_multiply_and_divide_nof_bits
     */
    dnx_data_l3_ecmp_group_size_multiply_and_divide_nof_bits_get_f group_size_multiply_and_divide_nof_bits_get;
    /**
     * returns define data of group_size_consistent_nof_bits
     */
    dnx_data_l3_ecmp_group_size_consistent_nof_bits_get_f group_size_consistent_nof_bits_get;
    /**
     * returns define data of group_size_nof_bits
     */
    dnx_data_l3_ecmp_group_size_nof_bits_get_f group_size_nof_bits_get;
    /**
     * returns define data of max_group_size
     */
    dnx_data_l3_ecmp_max_group_size_get_f max_group_size_get;
    /**
     * returns define data of nof_ecmp_per_bank_of_low_ecmps
     */
    dnx_data_l3_ecmp_nof_ecmp_per_bank_of_low_ecmps_get_f nof_ecmp_per_bank_of_low_ecmps_get;
    /**
     * returns define data of nof_ecmp_basic_mode
     */
    dnx_data_l3_ecmp_nof_ecmp_basic_mode_get_f nof_ecmp_basic_mode_get;
    /**
     * returns define data of total_nof_ecmp
     */
    dnx_data_l3_ecmp_total_nof_ecmp_get_f total_nof_ecmp_get;
    /**
     * returns define data of max_ecmp_basic_mode
     */
    dnx_data_l3_ecmp_max_ecmp_basic_mode_get_f max_ecmp_basic_mode_get;
    /**
     * returns define data of max_ecmp_extended_mode
     */
    dnx_data_l3_ecmp_max_ecmp_extended_mode_get_f max_ecmp_extended_mode_get;
    /**
     * returns define data of nof_ecmp_per_bank_of_extended_ecmps
     */
    dnx_data_l3_ecmp_nof_ecmp_per_bank_of_extended_ecmps_get_f nof_ecmp_per_bank_of_extended_ecmps_get;
    /**
     * returns define data of nof_fec_banks_per_extended_ecmp_bank
     */
    dnx_data_l3_ecmp_nof_fec_banks_per_extended_ecmp_bank_get_f nof_fec_banks_per_extended_ecmp_bank_get;
    /**
     * returns define data of nof_group_profiles_per_hierarchy
     */
    dnx_data_l3_ecmp_nof_group_profiles_per_hierarchy_get_f nof_group_profiles_per_hierarchy_get;
    /**
     * returns define data of member_table_nof_rows_size_in_bits
     */
    dnx_data_l3_ecmp_member_table_nof_rows_size_in_bits_get_f member_table_nof_rows_size_in_bits_get;
    /**
     * returns define data of member_table_address_size_in_bits
     */
    dnx_data_l3_ecmp_member_table_address_size_in_bits_get_f member_table_address_size_in_bits_get;
    /**
     * returns define data of ecmp_stage_map_size
     */
    dnx_data_l3_ecmp_ecmp_stage_map_size_get_f ecmp_stage_map_size_get;
    /**
     * returns define data of nof_ecmp_banks_basic
     */
    dnx_data_l3_ecmp_nof_ecmp_banks_basic_get_f nof_ecmp_banks_basic_get;
    /**
     * returns define data of nof_ecmp_banks_extended
     */
    dnx_data_l3_ecmp_nof_ecmp_banks_extended_get_f nof_ecmp_banks_extended_get;
    /**
     * returns define data of nof_ecmp
     */
    dnx_data_l3_ecmp_nof_ecmp_get_f nof_ecmp_get;
    /**
     * returns define data of profile_id_size
     */
    dnx_data_l3_ecmp_profile_id_size_get_f profile_id_size_get;
    /**
     * returns define data of profile_id_offset
     */
    dnx_data_l3_ecmp_profile_id_offset_get_f profile_id_offset_get;
    /**
     * returns define data of member_table_row_width
     */
    dnx_data_l3_ecmp_member_table_row_width_get_f member_table_row_width_get;
    /**
     * returns define data of tunnel_priority_support
     */
    dnx_data_l3_ecmp_tunnel_priority_support_get_f tunnel_priority_support_get;
    /**
     * returns define data of nof_tunnel_priority_map_profiles
     */
    dnx_data_l3_ecmp_nof_tunnel_priority_map_profiles_get_f nof_tunnel_priority_map_profiles_get;
    /**
     * returns define data of tunnel_priority_field_width
     */
    dnx_data_l3_ecmp_tunnel_priority_field_width_get_f tunnel_priority_field_width_get;
    /**
     * returns define data of tunnel_priority_index_field_width
     */
    dnx_data_l3_ecmp_tunnel_priority_index_field_width_get_f tunnel_priority_index_field_width_get;
    /**
     * returns define data of consistent_mem_row_size_in_bits
     */
    dnx_data_l3_ecmp_consistent_mem_row_size_in_bits_get_f consistent_mem_row_size_in_bits_get;
    /**
     * get table consistent_tables_info entry 
     */
    dnx_data_l3_ecmp_consistent_tables_info_get_f consistent_tables_info_get;
    /**
     * get general info table about table (for example key size)consistent_tables_info info
     */
    dnxc_data_table_info_get_f consistent_tables_info_info_get;
} dnx_data_if_l3_ecmp_t;

/*
 * }
 */

/*
 * SUBMODULE  - VIP_ECMP:
 * VIRTUAL IP ECMP group data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_vip_ecmp_feature_nof
} dnx_data_l3_vip_ecmp_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_vip_ecmp_feature_get_f) (
    int unit,
    dnx_data_l3_vip_ecmp_feature_e feature);

/**
 * \brief returns define data of nof_vip_ecmp
 * Module - 'l3', Submodule - 'vip_ecmp', data - 'nof_vip_ecmp'
 * Number of VIP ECMP groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vip_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vip_ecmp_nof_vip_ecmp_get_f) (
    int unit);

/**
 * \brief returns define data of max_vip_ecmp_table_size
 * Module - 'l3', Submodule - 'vip_ecmp', data - 'max_vip_ecmp_table_size'
 * Maximum number entries per VIP ECMP group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_vip_ecmp_table_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vip_ecmp_max_vip_ecmp_table_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - VIP_ECMP:
 * {
 */
/**
 * \brief Interface for l3 vip_ecmp data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_vip_ecmp_feature_get_f feature_get;
    /**
     * returns define data of nof_vip_ecmp
     */
    dnx_data_l3_vip_ecmp_nof_vip_ecmp_get_f nof_vip_ecmp_get;
    /**
     * returns define data of max_vip_ecmp_table_size
     */
    dnx_data_l3_vip_ecmp_max_vip_ecmp_table_size_get_f max_vip_ecmp_table_size_get;
} dnx_data_if_l3_vip_ecmp_t;

/*
 * }
 */

/*
 * SUBMODULE  - SOURCE_ADDRESS_ETHERNET:
 * SOURCE_ADDRESS_ETHERNET data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_ethernet_feature_nof
} dnx_data_l3_source_address_ethernet_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_source_address_ethernet_feature_get_f) (
    int unit,
    dnx_data_l3_source_address_ethernet_feature_e feature);

/**
 * \brief returns define data of nof_mymac_prefixes
 * Module - 'l3', Submodule - 'source_address_ethernet', data - 'nof_mymac_prefixes'
 * Number of mymac prefixes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mymac_prefixes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_source_address_ethernet_nof_mymac_prefixes_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - SOURCE_ADDRESS_ETHERNET:
 * {
 */
/**
 * \brief Interface for l3 source_address_ethernet data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_source_address_ethernet_feature_get_f feature_get;
    /**
     * returns define data of nof_mymac_prefixes
     */
    dnx_data_l3_source_address_ethernet_nof_mymac_prefixes_get_f nof_mymac_prefixes_get;
} dnx_data_if_l3_source_address_ethernet_t;

/*
 * }
 */

/*
 * SUBMODULE  - VRRP:
 * VRRP (multiple my mac) data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrrp_feature_nof
} dnx_data_l3_vrrp_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_vrrp_feature_get_f) (
    int unit,
    dnx_data_l3_vrrp_feature_e feature);

/**
 * \brief returns define data of nof_protocol_groups
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_protocol_groups'
 * Number of L3 protocol groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_protocol_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_nof_protocol_groups_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tcam_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_tcam_entries'
 * Size of VRRP TCAM table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_nof_tcam_entries_get_f) (
    int unit);

/**
 * \brief returns define data of nof_vsi_tcam_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_vsi_tcam_entries'
 * Number of enries in VRRP TCAM table that can be used by VSI table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vsi_tcam_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_nof_vsi_tcam_entries_get_f) (
    int unit);

/**
 * \brief returns define data of exem_vrid_ipv4_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_vrid_ipv4_tcam_index'
 * TCAM index for EXEM VRRP VRID IPv4 protocol
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_vrid_ipv4_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_exem_vrid_ipv4_tcam_index_get_f) (
    int unit);

/**
 * \brief returns define data of exem_vrid_ipv6_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_vrid_ipv6_tcam_index'
 * TCAM index for EXEM VRRP VRID IPv6 protocol
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_vrid_ipv6_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_exem_vrid_ipv6_tcam_index_get_f) (
    int unit);

/**
 * \brief returns define data of exem_default_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_default_tcam_index'
 * TCAM index for EXEM VSI LSB or SOURCE-PORT multiple my mac
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_default_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_exem_default_tcam_index_get_f) (
    int unit);

/**
 * \brief returns define data of exem_default_tcam_index_msb
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_default_tcam_index_msb'
 * TCAM index for EXEM VSI MSB multiple my mac
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_default_tcam_index_msb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_exem_default_tcam_index_msb_get_f) (
    int unit);

/**
 * \brief returns define data of vrrp_default_num_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'vrrp_default_num_entries'
 * Number of default VRRP entries in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vrrp_default_num_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_vrrp_default_num_entries_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - VRRP:
 * {
 */
/**
 * \brief Interface for l3 vrrp data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_vrrp_feature_get_f feature_get;
    /**
     * returns define data of nof_protocol_groups
     */
    dnx_data_l3_vrrp_nof_protocol_groups_get_f nof_protocol_groups_get;
    /**
     * returns define data of nof_tcam_entries
     */
    dnx_data_l3_vrrp_nof_tcam_entries_get_f nof_tcam_entries_get;
    /**
     * returns define data of nof_vsi_tcam_entries
     */
    dnx_data_l3_vrrp_nof_vsi_tcam_entries_get_f nof_vsi_tcam_entries_get;
    /**
     * returns define data of exem_vrid_ipv4_tcam_index
     */
    dnx_data_l3_vrrp_exem_vrid_ipv4_tcam_index_get_f exem_vrid_ipv4_tcam_index_get;
    /**
     * returns define data of exem_vrid_ipv6_tcam_index
     */
    dnx_data_l3_vrrp_exem_vrid_ipv6_tcam_index_get_f exem_vrid_ipv6_tcam_index_get;
    /**
     * returns define data of exem_default_tcam_index
     */
    dnx_data_l3_vrrp_exem_default_tcam_index_get_f exem_default_tcam_index_get;
    /**
     * returns define data of exem_default_tcam_index_msb
     */
    dnx_data_l3_vrrp_exem_default_tcam_index_msb_get_f exem_default_tcam_index_msb_get;
    /**
     * returns define data of vrrp_default_num_entries
     */
    dnx_data_l3_vrrp_vrrp_default_num_entries_get_f vrrp_default_num_entries_get;
} dnx_data_if_l3_vrrp_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEATURE:
 * 
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * IPv6 compatible MC destination MAC is considered UC
     */
    dnx_data_l3_feature_ipv6_mc_compatible_dmac,
    /**
     * Hit bit retrieval for FEC is not supported.
     */
    dnx_data_l3_feature_fec_hit_bit,
    /**
     * The FER granularity is double the size of the MDB granularity.
     */
    dnx_data_l3_feature_fer_fec_granularity_double_size,
    /**
     * Multicast bridge fallback is not supported.
     */
    dnx_data_l3_feature_mc_bridge_fallback,
    /**
     * NAT on a stick feature
     */
    dnx_data_l3_feature_nat_on_a_stick,

    /**
     * Must be last one!
     */
    _dnx_data_l3_feature_feature_nof
} dnx_data_l3_feature_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_feature_feature_get_f) (
    int unit,
    dnx_data_l3_feature_feature_e feature);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - FEATURE:
 * {
 */
/**
 * \brief Interface for l3 feature data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_feature_feature_get_f feature_get;
} dnx_data_if_l3_feature_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_L3:
 * {
 */
/**
 * \brief Interface for l3 data
 */
typedef struct
{
    /**
     * Interface for l3 egr_pointed data
     */
    dnx_data_if_l3_egr_pointed_t egr_pointed;
    /**
     * Interface for l3 fec data
     */
    dnx_data_if_l3_fec_t fec;
    /**
     * Interface for l3 source_address data
     */
    dnx_data_if_l3_source_address_t source_address;
    /**
     * Interface for l3 vrf data
     */
    dnx_data_if_l3_vrf_t vrf;
    /**
     * Interface for l3 routing_enablers data
     */
    dnx_data_if_l3_routing_enablers_t routing_enablers;
    /**
     * Interface for l3 rif data
     */
    dnx_data_if_l3_rif_t rif;
    /**
     * Interface for l3 fwd data
     */
    dnx_data_if_l3_fwd_t fwd;
    /**
     * Interface for l3 ecmp data
     */
    dnx_data_if_l3_ecmp_t ecmp;
    /**
     * Interface for l3 vip_ecmp data
     */
    dnx_data_if_l3_vip_ecmp_t vip_ecmp;
    /**
     * Interface for l3 source_address_ethernet data
     */
    dnx_data_if_l3_source_address_ethernet_t source_address_ethernet;
    /**
     * Interface for l3 vrrp data
     */
    dnx_data_if_l3_vrrp_t vrrp;
    /**
     * Interface for l3 feature data
     */
    dnx_data_if_l3_feature_t feature;
} dnx_data_if_l3_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_l3_t dnx_data_l3;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_L3_H_*/
/* *INDENT-ON* */
