<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDK API Guide: UDF Resources Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_brcm.css" rel="stylesheet" type="text/css"/>
<link href="tabs_brcm.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SDK API Guide
   &#160;<span id="projectnumber">Version 6.5.20</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">UDF Resources Management </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The BCM UDF APIs allow application developers to manage the UDF resources in StrataXGS devices.</p>
<h1><a class="anchor" id="udf_overview"></a>
UDF Resources</h1>
<p>Historically, in StrataXGS devices the UDF resources were exclusively used by the Field Processor for flexible classification of user defined patterns in the incoming packets. The APIs for managing these resources were hence defined within FIELD module. See fp_apis_data</p>
<p>The UDF selection logic is now being used by many other applications apart from the ContentAware Engine. For example, BCM56850 uses the UDF selected chunks for flexible hashing using layer 4 payload data.</p>
<p>For the purpose of centralized management of these shared resources, these new set of APIs are defined. These APIs will supersede the existing field data qualifier management APIs. These APIs will control the management of the UDF resources and the applications (like field, hashing etc..) will have APIs that use these objects for programming the switch for the desired functionality.</p>
<p>API bcm_udf_create takes "layer" (base offset), "start" (relative offset) and "width" (window of udf) inputs through bcm_udf_t input and allocates an opaque bcm_udf_id_t handle to the UDF object thus created. This API can optionally take "hints" from the user through bcm_udf_alloc_hints_t to reserve the hardware offset chunks in a manner that is best suitable for other applications in the pipeline - Vlan Stage Field Processor, Ingress Stage Field Processor, Flexible hashing entries etc...</p>
<p>A udf object will only be functional when it is associated with a packet format entry. A single udf object can be associated with multiple packet format entries and similarly a sinlge packet format entry can be associated with multiple udf objects. And when the udf is dissociated from all the packet format entries, the entry will be removed from hardware but the object would be removed from software only when it is destroyed using bcm_udf_destroy API.</p>
<p>API bcm_udf_pkt_format_create creates a packet format matching entry to qualify the packets for UDF selection logic. This API returns a bcm_udf_pkt_format_entry_t handle to refer to the packet format entry thus created.</p>
<p>In case of ambiguous packet format matching entries, the entry with the higher priority will take precedence and the udf selection will happen according to the associated udf objects.</p>
<p>Since the number of udf objects are limited by the hardware, users can create shared objects that would use the same hardware offsets as the other udf but they need to be associated with different packet format entries.</p>
<p>These APIs supercede the bcm_field_data_qualifier_* APIs defined here: fp_apis_data The intermixed usage is not supported.</p>
<h1><a class="anchor" id="udf_data_structures"></a>
UDF Data Structures</h1>
<ul>
<li>The UDF. <a class="anchor" id="bcm_udf_t"></a><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__udf__s.html">bcm_udf_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__udf__s.html#a81a27ce50e78368b0d0de1e8767fd32d">flags</a>;           <span class="comment">/* See BCM_UDF_F_XXX */</span></div><div class="line">    <a class="code" href="group__udf.html#gaf06cf0e5937106d00fcb40187f6a977e">bcm_udf_layer_t</a> <a class="code" href="structbcm__udf__s.html#a8743fd7f1434398670b872204c9aa303">layer</a>;  <span class="comment">/* UDF base offset. bcmUdfLayerXxx */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__udf__s.html#a37722a150250e2a5a98e5e0d11e53449">start</a>;              <span class="comment">/* Relative offset in bits (from the &#39;layer&#39;) in the</span></div><div class="line"><span class="comment">                               packet */</span></div><div class="line">    <a class="code" href="group__types.html#ga6e9f69e8948f73d9da295756c2ce581d">bcm_pbmp_t</a> <a class="code" href="structbcm__udf__s.html#a92fd9cf429d4027bbaa6ae6e0908fb7d">ports</a>;       <span class="comment">/* port bitmap used in OperModePipeLocal.</span></div><div class="line"><span class="comment">                               ports must be in same ingress pipe */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__udf__s.html#a9ddae86018522bf2d708066884d89b3c">width</a>;           <span class="comment">/* width of data in bits to extract */</span></div><div class="line">} <a class="code" href="group__udf.html#gae0c8afe87b676e67aba78d19c2dd840b">bcm_udf_t</a>;</div></div><!-- fragment --></li>
<li>UDF allocation hints. <a class="anchor" id="bcm_udf_alloc_hints_t"></a><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__udf__alloc__hints__s.html">bcm_udf_alloc_hints_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__udf__alloc__hints__s.html#a81a27ce50e78368b0d0de1e8767fd32d">flags</a>;               <span class="comment">/* See BCM_UDF_CREATE_O_xxx */</span></div><div class="line">    <a class="code" href="group__types.html#gab368d00814d904eb59d12ec92f279cd2">bcm_udf_id_t</a> <a class="code" href="structbcm__udf__alloc__hints__s.html#a2bd221724b739f7a219b75124e0141ed">shared_udf</a>;    <span class="comment">/* Used when BCM_UDF_CREATE_O_SHARED_HWID is set */</span></div><div class="line">    <a class="code" href="structbcm__field__qset__s.html">bcm_field_qset_t</a> <a class="code" href="structbcm__udf__alloc__hints__s.html#a347e8e01948b5b53239776246d31c211">qset</a>;      <span class="comment">/* Field group qset for optimal H/W resource</span></div><div class="line"><span class="comment">                                   allocation */</span></div><div class="line">} <a class="code" href="group__udf.html#gaff216c732b39b6eb20c41ada53b3282c">bcm_udf_alloc_hints_t</a>;</div></div><!-- fragment --></li>
<li>Packet format based UDF specification structure. <a class="anchor" id="bcm_udf_pkt_format_info_t"></a><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__udf__pkt__format__info__s.html">bcm_udf_pkt_format_info_s</a> {</div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a6f8e491cf1d80eb127fe0c10ebbfc659">prio</a>;                       <span class="comment">/* Priority of the UDF */</span></div><div class="line">    <a class="code" href="group__types.html#ga450a4500056fa57db6d051dcb4709501">bcm_ethertype_t</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#acbec95f89c0d1dfef2d74656cd88b7c6">ethertype</a>;      <span class="comment">/* EtherType in the packet */</span></div><div class="line">    <a class="code" href="group__types.html#ga450a4500056fa57db6d051dcb4709501">bcm_ethertype_t</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a597a0865d1520a8fdd1e17bf57a239d0">ethertype_mask</a>; <span class="comment">/* EtherType Mask */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#abc516bfaffd1558a4ee27a4023e0d160">ip_protocol</a>;              <span class="comment">/* IP protocol field in the packet */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#aa2b38b237b7566ff1a0c57833ff08d81">ip_protocol_mask</a>;         <span class="comment">/* IP protocol Mask */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a8ca5a3d381bc18f627d4b16a5b367cd7">l2</a>;                      <span class="comment">/* L2 packet format. (BCM_PKT_FORMAT_L2_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#ad30652e3c13231a9c7a6f04673edaa6c">vlan_tag</a>;                <span class="comment">/* Vlan tag format.</span></div><div class="line"><span class="comment">                                       (BCM_PKT_FORMAT_VLAN_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a00c6d3e44d7555f7647133393f68278b">outer_ip</a>;                <span class="comment">/* Outer IP header type.</span></div><div class="line"><span class="comment">                                       (BCM_PKT_FORMAT_IP_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a43e8285ea08d6cd8c5d8fb05af8414e2">inner_ip</a>;                <span class="comment">/* Inner IP header type.</span></div><div class="line"><span class="comment">                                       (BCM_PKT_FORMAT_IP_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a725dbc4ccaaf56e9f3c70cf4f668d74d">tunnel</a>;                  <span class="comment">/* Tunnel type. (BCM_PKT_FORMAT_TUNNEL_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a0e6673ee54f2cc69c2fde66b40eacff8">mpls</a>;                    <span class="comment">/* Mpls labels. (BCM_PKT_FORMAT_MPLS_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a443950517a8f1552fc0bda44646d6924">fibre_chan_outer</a>;        <span class="comment">/* Fibre Channel outer header type.</span></div><div class="line"><span class="comment">                                       (BCM_PKT_FORMAT_FIBRE_CHAN_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a6640599ed946a3ed1770c5ab794a7075">fibre_chan_inner</a>;        <span class="comment">/* Fibre Channel inner header</span></div><div class="line"><span class="comment">                                       type.(BCM_PKT_FORMAT_FIBRE_CHAN_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a44611ce5568f2ebde9ff2275674f2c5b">higig</a>;                   <span class="comment">/* HIGIG packet</span></div><div class="line"><span class="comment">                                       format.(BCM_PKT_FORMAT_HIGIG_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a22bb5be1832a9d038671d69f35be4b43">vntag</a>;                   <span class="comment">/* NIV packet</span></div><div class="line"><span class="comment">                                       format.(BCM_PKT_FORMAT_VNTAG_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#afd3123c46bd7e3fd612ae266c0b74701">etag</a>;                    <span class="comment">/* Extender tag packet</span></div><div class="line"><span class="comment">                                       format.(BCM_PKT_FORMAT_ETAG_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a795d2132d1f9790e50510059d90b67ef">cntag</a>;                   <span class="comment">/* CNTAG packet</span></div><div class="line"><span class="comment">                                       format.(BCM_PKT_FORMAT_CNTAG_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a967024fa52048541e4dac58be8acde05">icnm</a>;                    <span class="comment">/* ICNM packet</span></div><div class="line"><span class="comment">                                       format.(BCM_PKT_FORMAT_ICNM_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a5506b262b282148688f9c75b9b84559f">subport_tag</a>;             <span class="comment">/* SUBPORT_TAG packet format.</span></div><div class="line"><span class="comment">                                       (BCM_PKT_FORMAT_SUBPORT_TAG_XXX) */</span></div><div class="line">    <span class="keywordtype">int</span>    <a class="code" href="structbcm__udf__pkt__format__info__s.html#af41be8c18bfbbb35ccd740b87d3813ea">class_id</a>;                <span class="comment">/* id used by the IFP Key Selection Mechanism.</span></div><div class="line"><span class="comment">                                        range 0~255 */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#ad6e3da567865ce5ce1b41639cc75e923">inner_protocol</a>;          <span class="comment">/* Inner protocol field in the packet. Inner_ip should be set to BCM_PKT_FORMAT_IP_NONE to make this take effect. IP-IN-IP type GRE should take original API sequence. */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#adf1630948e5cfea4f3558bf0aa8b872d">inner_protocol_mask</a>;     <span class="comment">/* Inner protocol mask */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#ad73ef5ad59a6035539fd9e4ef7289d68">l4_dst_port</a>;             <span class="comment">/* TCP or UDP Destination Port number. */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a2bfdd00e9d01c1483447868feedf1444">l4_dst_port_mask</a>;        <span class="comment">/* TCP or UDP Destination Port number mask. */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#ac9e8b5044b2832c3987ea86588675a22">opaque_tag_type</a>;          <span class="comment">/* Tag type field in the opaque tag. */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a2ad204b3d2f66be7713295bda9ff8053">opaque_tag_type_mask</a>;     <span class="comment">/* Mask for tag type field in the opaque</span></div><div class="line"><span class="comment">                                       tag. */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a578c0652d109ed9b13e87081c797cade">int_pkt</a>;                  <span class="comment">/* Inband Telemetry packet indicator.</span></div><div class="line"><span class="comment">                                       (BCM_PKT_FORMAT_INT_PKT_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a2301858aa2ac44e846aa28901fa29309">src_port</a>;                 <span class="comment">/* Logical Source Port number. */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a52b994fd5fce741a24659e4f25a86a91">src_port_mask</a>;            <span class="comment">/* Logical Source Port number mask. */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#afabbc38ca75e5f60fdfed4c06337a66e">lb_pkt_type</a>;              <span class="comment">/* Loopback Packet Type.</span></div><div class="line"><span class="comment">                                       (BCM_PKT_FORMAT_LB_TYPE_XXX) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#ac809a2e7f98147fe73b8207b7ee4cefb">first_2bytes_after_mpls_bos</a>; <span class="comment">/* First 2 bytes after BOS in an mpls</span></div><div class="line"><span class="comment">                                           packet. */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__udf__pkt__format__info__s.html#a3d12cd5ed0e866f405629dbfd2ff9037">first_2bytes_after_mpls_bos_mask</a>; <span class="comment">/* Mask for first 2 bytes after BOS in</span></div><div class="line"><span class="comment">                                           an mpls packet. */</span></div><div class="line">} <a class="code" href="group__udf.html#ga7b8a7fac1ca2ab11613b8c01e7bba92a">bcm_udf_pkt_format_info_t</a>;</div></div><!-- fragment --></li>
<li>UDF hashing specification structure. <a class="anchor" id="bcm_udf_hash_config_t"></a><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__udf__hash__config__s.html">bcm_udf_hash_config_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__udf__hash__config__s.html#a81a27ce50e78368b0d0de1e8767fd32d">flags</a>;                             <span class="comment">/* Reserved for future usage. Must be</span></div><div class="line"><span class="comment">                                                 zero today. */</span></div><div class="line">    <a class="code" href="group__types.html#gab368d00814d904eb59d12ec92f279cd2">bcm_udf_id_t</a> <a class="code" href="structbcm__udf__hash__config__s.html#ae8be65136e6a043c3d3c68da049bdf80">udf_id</a>;                      <span class="comment">/* UDF object id */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__udf__hash__config__s.html#abd28482a43cd697ffe8b029ca2e25672">mask_length</a>;                          <span class="comment">/* Length of mask bytes. Must equal to</span></div><div class="line"><span class="comment">                                                 the width of the UDF object. */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__udf__hash__config__s.html#afbf4cc90c5d491af190db3368d2f3c5c">hash_mask</a>[BCM_UDF_HASH_MAX_LENGTH]; <span class="comment">/* Array of mask fields. Index 0 is MSB</span></div><div class="line"><span class="comment">                                                 of mask. */</span></div><div class="line">} <a class="code" href="group__udf.html#ga0e1080c3df9ee173b3daf0be56b17ac3">bcm_udf_hash_config_t</a>;</div></div><!-- fragment --></li>
<li>UDF Operation mode selection enum. <a class="anchor" id="bcm_udf_oper_mode_t"></a><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="group__udf.html#ga8b933c6777c1fc4458395027532339fb">bcm_udf_oper_mode_e</a> {</div><div class="line">   <a class="code" href="group__udf.html#gga8b933c6777c1fc4458395027532339fba07c153de85ab81d37a46eb7b87a69d99">bcmUdfOperModeGlobal</a> = 0, <span class="comment">/* Group Operational Global Mode Value. */</span></div><div class="line">   <a class="code" href="group__udf.html#gga8b933c6777c1fc4458395027532339fba6439f1830d579fcd154e9d82e3a04f9b">bcmUdfOperModePipeLocal</a> = 1, <span class="comment">/* Group Operational Pipe Local Mode Value. */</span></div><div class="line">   <a class="code" href="group__udf.html#gga8b933c6777c1fc4458395027532339fba066f0c5550d3bbeca6fb5c5bc3145a0e">bcmUdfOperModeCount</a> = 2 <span class="comment">/* Always last. Not a usable value. */</span></div><div class="line">} <a class="code" href="group__udf.html#gad5a386d905e19759dd0b16a1e8ce1e1d">bcm_udf_oper_mode_t</a>;</div></div><!-- fragment --></li>
<li>UDF Chunk Information Structure. <a class="anchor" id="bcm_udf_chunk_info_t"></a><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__udf__chunk__info__s.html">bcm_udf_chunk_info_s</a> {</div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__udf__chunk__info__s.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;                                        <span class="comment">/* Relative offset in bits (Starts from</span></div><div class="line"><span class="comment">                                                          base offset of given abstract packet</span></div><div class="line"><span class="comment">                                                          format) in the packet */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__udf__chunk__info__s.html#a9ddae86018522bf2d708066884d89b3c">width</a>;                                      <span class="comment">/* width of data in bits to extract.</span></div><div class="line"><span class="comment">                                                          It should be chunk aligned (multiples of chunk size). */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__udf__chunk__info__s.html#a1a0699f442a1b2a3028eeb544a46f3f6">chunk_bmap</a>;                                 <span class="comment">/* Chunk bitmap (Each bit in the bitmap</span></div><div class="line"><span class="comment">                                                          represents 1 chunk (2 bytes) */</span></div><div class="line">    <a class="code" href="group__udf.html#gaf0624b76a4d8b58b1bc67b35b4d6dd41">bcm_udf_abstract_pkt_format_t</a> <a class="code" href="structbcm__udf__chunk__info__s.html#a89201906570347d260520696debdeadc">abstract_pkt_format</a>; <span class="comment">/* Abstract Packet Format (one of the format from</span></div><div class="line"><span class="comment">                                                          &#39;bcm_udf_abstract_pkt_format_t&#39;) */</span></div><div class="line">} <a class="code" href="group__udf.html#gab0aec480de05443fb3e48094ef316dcd">bcm_udf_chunk_info_t</a>;</div></div><!-- fragment --></li>
<li>UDF Abstract Packet Format Information Structure. <a class="anchor" id="bcm_udf_abstract_pkt_format_info_t"></a><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__udf__abstract__pkt__format__info__s.html">bcm_udf_abstract_pkt_format_info_s</a> {</div><div class="line">    <a class="code" href="group__udf.html#ga6896664fec02015b7e710be13606c6ba">bcm_udf_pkt_base_offset_t</a> <a class="code" href="structbcm__udf__abstract__pkt__format__info__s.html#a7d3c27177c82d7cf25a3af9ea8101e6c">base_offset</a>; <span class="comment">/* Relative offset of</span></div><div class="line"><span class="comment">                                              &#39;bcmUdfPktBaseOffsetXxx&#39; type (from</span></div><div class="line"><span class="comment">                                              &#39;bcm_udf_pkt_base_offset_t&#39;) */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__udf__abstract__pkt__format__info__s.html#a8691ef1595256a4157fe3b4086ea7718">num_chunks_max</a>;                 <span class="comment">/* Maximum number of chunks supported by</span></div><div class="line"><span class="comment">                                              the abstract packet format */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__udf__abstract__pkt__format__info__s.html#a2d780bacb4b0036fbde60adcd061e154">chunk_bmap_used</a>;                <span class="comment">/* Bitmap of Chunks already used by the</span></div><div class="line"><span class="comment">                                              abstract packet format */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__udf__abstract__pkt__format__info__s.html#a0fabdf761908628942f6913fe41f609e">unavail_chunk_bmap</a>;             <span class="comment">/* Bitmap of Chunks unavailable/reserved */</span></div><div class="line">} <a class="code" href="group__udf.html#ga428b74abe6cb43c0414e1f27c2adc4b8">bcm_udf_abstract_pkt_format_info_t</a>;</div></div><!-- fragment --></li>
</ul>
<p><a class="anchor" id="udf_offset_flags"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Flags to control UDF extraction</caption>
<tr>
<th>flags </th><th>Description  </th></tr>
<tr>
<td>BCM_UDF_F_ADJUST_IP4_OPTIONS </td><td>Adjust the UDF selection to ignore IPv4 options.  </td></tr>
<tr>
<td>BCM_UDF_F_ADJUST_IP6_OPTIONS </td><td>Adjust the UDF selection to ignore IPv6 options.  </td></tr>
</table>
<p><a class="anchor" id="udf_create_options"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Options to bcm_udf_create</caption>
<tr>
<th>flags </th><th>Description  </th></tr>
<tr>
<td>BCM_UDF_CREATE_O_NONE </td><td>Default.  </td></tr>
<tr>
<td>BCM_UDF_CREATE_O_WITHID </td><td>UDF Id from user will be used.  </td></tr>
<tr>
<td>BCM_UDF_CREATE_O_REPLACE </td><td>Replace UDF.  </td></tr>
<tr>
<td>BCM_UDF_CREATE_O_FLEXHASH </td><td>Hint to the API so the udf allocation is adjusted to be used by the flexible hashing entries.  </td></tr>
<tr>
<td>BCM_UDF_CREATE_O_FIELD_INGRESS </td><td>Hint to the API so the udf allocation is adjusted to be used by Ingress Stage FP groups.  </td></tr>
<tr>
<td>BCM_UDF_CREATE_O_FIELD_LOOKUP </td><td>Hint to the API so the udf allocation is adjusted to be used by Lookup Stage FP groups.  </td></tr>
<tr>
<td>BCM_UDF_CREATE_O_SHARED_HWID </td><td>Use same hardware chunk position as the "shared_udf". Use of this flag will clone an udf id with same hardware chunks as that of "shared_udf" of same width but can be with a different start/offset byte position. Mainly used to add multiple packet formats with the same hardware chunks. For eg: Consider an example to extract 4 bytes after L2 header. Expected packet types are single tagged and no tagged. To achieve this, both BCM_PKT_FORMAT_VLAN_TAG_NONE and BCM_PKT_FORMAT_VLAN_TAG_SINGLE packet formats can use with same hardware chunks with different start/offset. For BCM_PKT_FORMAT_VLAN_TAG_NONE, UDF id created with start as 14 * 8 bits will be attached. For BCM_PKT_FORMAT_VLAN_TAG_SINGLE same hardware chunk can be re-used but with start as 18 * 8 bit. This is achieved by creating a new UDF id with BCM_UDF_CREATE_O_SHARED_HWID flag and "shared_id" used for BCM_PKT_FORMAT_VLAN_TAG_NONE.   </td></tr>
<tr>
<td>BCM_UDF_CREATE_O_POLICER_GROUP </td><td>UDF allocation will be adjusted for use by global (service) meter.  </td></tr>
<tr>
<td>BCM_UDF_CREATE_O_UDFHASH </td><td>Hint to the API so the udf allocation is adjusted to be used by the UDF hashing entries.  </td></tr>
<tr>
<td>BCM_UDF_CREATE_O_RANGE_CHECK </td><td>Hint to the API so the udf allocation is adjusted to be used by Range Checker.  </td></tr>
<tr>
<td>BCM_UDF_CREATE_O_FLEX_COUNTER </td><td>Hint to the API so the udf allocation is adjusted to be used by Flexible Counter.  </td></tr>
</table>
<p><a class="anchor" id="udf_pkt_format_options"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Options to bcm_udf_pkt_format_create</caption>
<tr>
<th>flags </th><th>Description  </th></tr>
<tr>
<td>BCM_UDF_PKT_FORMAT_CREATE_O_NONE </td><td>Default.  </td></tr>
<tr>
<td>BCM_UDF_PKT_FORMAT_CREATE_O_WITHID </td><td>Packet format Id from the user will be used.  </td></tr>
<tr>
<td>BCM_UDF_PKT_FORMAT_CREATE_O_REPLACE </td><td>Replace packet format entry.  </td></tr>
</table>
<p><a class="anchor" id="bcmUdfLayerXxx"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>UDF Base Offset.</caption>
<tr>
<th>bcmUdfLayerXxx </th><th>Description  </th></tr>
<tr>
<td>bcmUdfLayerL2Header </td><td>Start of L2 header in the Packet  </td></tr>
<tr>
<td>bcmUdfLayerL3OuterHeader </td><td>Start of outer L3 header in the packet  </td></tr>
<tr>
<td>bcmUdfLayerL3InnerHeader </td><td>Start of inner L3 header in the packet  </td></tr>
<tr>
<td>bcmUdfLayerL4OuterHeader </td><td>Start of outer L4 header in the packet  </td></tr>
<tr>
<td>bcmUdfLayerL4InnerHeader </td><td>Start of outer L4 header in the packet  </td></tr>
<tr>
<td>bcmUdfLayerHigigHeader </td><td>Start of HiGig header in the packet  </td></tr>
<tr>
<td>bcmUdfLayerHigig2Header </td><td>Start of HiGig2 header in the packet  </td></tr>
<tr>
<td>bcmUdfLayerTunnelHeader </td><td>Start of outermost tunnel header in the Packet   </td></tr>
<tr>
<td>bcmUdfLayerTunnelPayload </td><td>Start of outermost tunnel payload in the Packet   </td></tr>
<tr>
<td>bcmUdfLayerUserPayload </td><td>Start of application payload in the Packet  </td></tr>
</table>
<p><a class="anchor" id="BCM_PKT_FORMAT_TUNNEL_XXX"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Options to tunnels of packet format</caption>
<tr>
<th>BCM_PKT_FORMAT_TUNNEL_XXX </th><th>Description  </th></tr>
<tr>
<td>BCM_PKT_FORMAT_TUNNEL_ANY </td><td>Any packet.  </td></tr>
<tr>
<td>BCM_PKT_FORMAT_TUNNEL_NONE </td><td>Non tunneled packet.  </td></tr>
<tr>
<td>BCM_PKT_FORMAT_TUNNEL_IP_IN_IP </td><td>IP in IP tunneled packet.  </td></tr>
<tr>
<td>BCM_PKT_FORMAT_TUNNEL_GRE </td><td>GRE tunneled packet.  </td></tr>
<tr>
<td>BCM_PKT_FORMAT_TUNNEL_MPLS </td><td>MPLS tunneled packet.  </td></tr>
<tr>
<td>BCM_PKT_FORMAT_TUNNEL_FCOE </td><td>FCOE tunneled packet.  </td></tr>
<tr>
<td>BCM_PKT_FORMAT_TUNNEL_FCOE_INIT </td><td>FCOE initialization proptocol (FIP) packet.  </td></tr>
</table>
<p><a class="anchor" id="BCM_UDF_HASH_ADD_O_XXX"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Options to control UDF hashing adding</caption>
<tr>
<th>BCM_UDF_HASH_ADD_O_XXX </th><th>Description  </th></tr>
<tr>
<td>BCM_UDF_HASH_ADD_O_NONE </td><td>Add a new entry to list.  </td></tr>
<tr>
<td>BCM_UDF_HASH_ADD_O_REPLACE </td><td>Modify an entry which is already in list.  </td></tr>
</table>
<p><a class="anchor" id="BCM_UDF_HASH_CONFIG_XXX"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Flags to control UDF hashing configuration</caption>
<tr>
<th>BCM_UDF_HASH_CONFIG_XXX </th><th>Description  </th></tr>
<tr>
<td>BCM_UDF_HASH_CONFIG_ENGINE_0 </td><td>UDF is used by hash engine 0.  </td></tr>
<tr>
<td>BCM_UDF_HASH_CONFIG_ENGINE_1 </td><td>UDF is used by hash engine 1.  </td></tr>
</table>
<p><a class="anchor" id="bcm_udf_abstract_pkt_format_t"></a><a class="anchor" id="bcmUdfAbstractPktFormatXxx"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>UDF Abstract Packet Format Types enumeration for 'bcm_udf_abstract_pkt_format_t'.</caption>
<tr>
<th>bcmUdfAbstractPktFormatXxx </th><th>Description  </th></tr>
<tr>
<td>bcmUdfAbstractPktFormatLlc </td><td>Start of first byte of LLC Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerLlc </td><td>Start of Inner payload's first byte of LLC Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUnknownL3 </td><td>Start of first byte after unknown EtherType.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerUnknownL3 </td><td>Start of inner payload's first byte after unknown EtherType.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownNonIp </td><td>Start of first byte after Known non-ip EtherType (other than Known IPv4/6 and FCoE/Mim/MPLS tunnels).  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerKnownNonIp </td><td>Start of Inner payload's first byte after Known non-ip EtherType (other than Known IPv4/6 and FCoE/Mim/MPLS tunnels).  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownL3Mim </td><td>Start of MiM Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownL3FcoeStdEncap </td><td>Start of FCoE with Standard or Encapsulation Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownL3FcoeVftIfr </td><td>Start of FCoE with Virtual Fabric Tag (VFT) or Inter Fabric Routing (IFR) Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownL3MplsOneLabel </td><td>Start of MPLS Header with one label.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownL3MplsTwoLabel </td><td>Start of MPLS Header with two labels.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownL3MplsThreeLabel </td><td>Start of MPLS Header with three labels.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownL3MplsFourLabel </td><td>Start of MPLS Header with four labels.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownL3MplsMoreThanFourLabel </td><td>Start of MPLS Header with more than four labels.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUnknownL4 </td><td>Start of first byte of unknown L4 Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerUnknownL4 </td><td>Start of Inner payload's first byte of unknown L4 Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUdpUnknownL5 </td><td>To extract Unknown L5 payload fields, the base start offset should be the first byte of UDP Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerUdpUnknownL5 </td><td>To extract Unknown L5 payload fields, the base start offset should be the first byte of inner UDP Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUdpGpeGeneve </td><td>Start of first byte of UDP Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUdpBfd </td><td>Start of first byte of UDP Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerUdpBfd </td><td>Start of inner payload's first byte of UDP Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUdpVxlan </td><td>Start of first byte of UDP Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUdp1588 </td><td>Start of first byte of UDP Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatTcpUnknownL5 </td><td>To extract Unknown L5 payload fields, the base start offset should be the first byte of TCP Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerTcpUnknownL5 </td><td>To extract Unknown L5 payload fields, the base start offset should be the first byte of inner TCP Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatSctpUnknownL5 </td><td>Start of first byte of SCTP Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerSctpUnknownL5 </td><td>Start of inner payload's first byte of SCTP Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatGreWithoutKey </td><td>Start of first byte of L4 header for GRE packets without key flag set (K=0).  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatGreWithKey </td><td>Start of first byte of L4 header for GRE packets with key flag set (K=1).  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatGreWithoutChecksumRouting </td><td>Start of first byte of L4 header for GRE packets with flags C=0, R=0.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2GreWithoutChecksumRouting </td><td>Start of first byte of L4 header for L2-GRE packets with flags C=0, R=0.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2GreWithoutRouting </td><td>Start of first byte of L4 header for L2-GRE packets without Routing flag set (R=0).  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownL3FcoeUnknownRctl </td><td>Start of FCoE Header for Unknown R_CTL FCoE flows  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatAchNonIp </td><td>Start of first byte after ACH header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUdpINT </td><td>Start of first byte of L4 UDP header for INT (Inband-Telemetry) packet.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatTcpUnknownL5WithIpExtnHdr </td><td>To extract Unknown L5 payload fields for TCP packet with IP extension header, the base start offset should be the first byte of L5 Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL3GreUnknownPayload </td><td>To extract Unknown L3 GRE payload fields, the base start offset should be the first byte of L3 GRE header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatGreWithKeyRouting </td><td>Abstract from the start of first byte of L4 header for GRE packets (with key and routing flag set K=1, R=1, C=0/1).  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2GreWithKeyRouting </td><td>Abstract from the start of first byte of L4 header for L2-GRE packets (with flags K=1, R=1, C=0/1).  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerUdp1588 </td><td>Abstract from the start of Inner header's first byte of known L5 1588 header after UDP.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUdpINT </td><td>Start of first byte of L4 TCP header for INT (Inband-Telemetry) packet.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownL3FcoeUnknownRctl </td><td>Abstract from the start of FCoE with Unknown R_CTL.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatHiGigPpd0 </td><td>Abstract from the start of HiGig System Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatHiGigPpd0EHType0 </td><td>Abstract from the start of HiGig System Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatHiGigPpd0EHType1 </td><td>Abstract from the start of HiGig System Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatHiGigPpd0EHType2 </td><td>Abstract from the start of HiGig System Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatHiGigPpd2 </td><td>Abstract from the start of HiGig System Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatHiGigPpd2EHType0 </td><td>Abstract from the start of HiGig System Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatHiGigPpd2EHType1 </td><td>Abstract from the start of HiGig System Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatHiGigPpd2EHType2 </td><td>Abstract from the start of HiGig System Header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatGpeIOAM </td><td>Abstract from the start of GPE IOAM.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatKnownMplsMcast </td><td>Abstract from the start of MPLS Multicast header.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatLoopbackHdrType0 </td><td>Abstract from the start of Loopback Type 0 System Header.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatLoopbackHdrType1 </td><td>Abstract from the start of Loopback Type 1 System Header.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL3Ipv4Fragmented </td><td>Abstract from the start of L3 for IPv4 Fragmented packets (that is, non-zero fragmented offset) without IP options.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL3Ipv4FragmentedWithOptions </td><td>Abstract from the start of L3 for IPv4 Fragmented packets with IP options (that is, non-zero fragmented offset).   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL3Ipv4WithoutOptions </td><td>Abstract from the start of L3 for IPv4 packets without IP options.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL3Ipv4WithOptions </td><td>Abstract from the start of L3 for IPv4 packets with IP options.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL3Ipv6 </td><td>Abstract from the start of L3 for IPv6 packet.  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2 </td><td>Abstract from the start of first byte of L2 header.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2Untagged </td><td>Abstract from the start of 14 bytes after L2 header without VLAN tag.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2OuterVlanTag </td><td>Abstract from the start of 14 bytes after L2 header with single outer VLAN tag.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2InnerVlanTag </td><td>Abstract from the start of 14 bytes after L2 header with single inner VLAN tag.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2DoubleVlanTag </td><td>Abstract from the start of 14 bytes after L2 header with double VLAN tag.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2GbpTag </td><td>Abstract from the start of 14 bytes after L2 header with GBP tag (without VLAN tag).   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2OuterVlanWithGbpTag </td><td>Abstract from the start of 14 bytes after L2 header with single outer vlan and GBP tags.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2InnerVlanWithGbpTag </td><td>Abstract from the start of 14 bytes after L2 header with single inner vlan and GBP tags.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2DoubleVlanWithGbpTag </td><td>Abstract from the start of 14 bytes after L2 header with double vlan and GBP tag.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2Vntag </td><td>Abstract from the start of 14 bytes after L2 header with VNTAG (without vlan tag).   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2OuterVlanWithVntag </td><td>Abstract from the start of 14 bytes after L2 header with single outer vlan tag and VNTAG.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2InnerVlanWithVntag </td><td>Abstract from the start of 14 bytes after L2 header with single inner vlan tag and VNTAG.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2DoubleVlanWithVntag </td><td>Abstract from the start of 14 bytes after L2 header with double vlan tag and VNTAG.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2Etag </td><td>Abstract from the start of 14 bytes after L2 header with ETAG (without vlan tag).   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2OuterVlanEtag </td><td>Abstract from the start of 14 bytes after L2 header with single outer vlan tag and ETAG.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2InnerVlanEtag </td><td>Abstract from the start of 14 bytes after L2 header with single inner vlan tag and ETAG.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatL2DoubleVlanEtag </td><td>Abstract from the start of 14 bytes after L2 header with double vlan tag and ETAG.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerL3Ipv4 </td><td>Abstract from the start of Inner header's first byte of L3 IPv4 header.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerL3Ipv4Fragmented </td><td>Abstract from the start of Inner header's first byte of L3 IPv4 header with non-zero fragment offset.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerL3Ipv6 </td><td>Abstract from the start of Inner L3 header's first byte of L3 IPv6 header.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerL2Untagged </td><td>Abstract from the start of 12 bytes after Inner L2 header with no VLAN tag.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerL2OuterVlanTag </td><td>Abstract from the start of 12 bytes after Inner L2 header with no VLAN tag.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerL2InnerVlanTag </td><td>Abstract from the start of 12 bytes after Inner L2 header with single outer VLAN tag.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerL2DoubleVlanTag </td><td>Abstract from the start of 12 bytes after Inner L2 header with single inner VLAN tag.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerL2GbpTag </td><td>Abstract from the start of 12 bytes after Inner L2 header with GBP tag (without VLAN tag).   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerL2OuterVlanWithGbpTag </td><td>Abstract from the start of 12 bytes after Inner L2 header with single outer vlan and GBP tags.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerL2InnerVlanWithGbpTag </td><td>Abstract from the start of 12 bytes after Inner L2 header with single inner vlan and GBP tags.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerL2DoubleVlanWithGbpTag </td><td>Abstract from the start of 12 bytes after Inner L2 header with double vlan and GBP tags.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUnknownL3CustomEtherType1 </td><td>Abstract from the start of first byte of L3 with unknown custom EtherType 1.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUnknownL3CustomEtherType2 </td><td>Abstract from the start of first byte of L3 with unknown custom EtherType 2.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUnknownL3CustomIpProtocol1 </td><td>Abstract from the start of first byte of L4 with unknown custom IP Protocol 1.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUnknownL3CustomIpProtocol2 </td><td>Abstract from the start of first byte of L4 with unknown custom IP Protocol 2.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUnknownL3CustomUdpDstPort1 </td><td>Abstract from the start of first byte of L4 with unknown custom UDP destination port 1.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUnknownL3CustomUdpDstPort2 </td><td>Abstract from the start of first byte of L4 with unknown custom UDP destination port 2.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerUnknownL3CustomEtherType1 </td><td>Abstract from the start of first byte of Inner L3 with unknown custom EtherType 1.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerUnknownL3CustomEtherType2 </td><td>Abstract from the start of first byte of Inner L3 with unknown custom EtherType 2.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerUnknownL3CustomIpProtocol1 </td><td>Abstract from the start of first byte of Inner L4 with unknown custom IP Protocol 1.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerUnknownL3CustomIpProtocol2 </td><td>Abstract from the start of first byte of Inner L4 with unknown custom IP Protocol 2.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerUnknownL3CustomUdpDstPort1 </td><td>Abstract from the start of first byte of Inner L4 with unknown custom UDP destination port 1.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatInnerUnknownL3CustomUdpDstPort2 </td><td>Abstract from the start of first byte of Inner L4 with unknown custom UDP destination port 2.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatUdpProbeBasedINT </td><td>Abstract from the start of first byte of UDP header to match on probe based INT (Inband-Telemetry) header payload.   </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatMacsecDecrypt </td><td>Abstract from the start of the first byte of L2 for the incoming MACSEC decrypted packet.  </td></tr>
<tr>
<td>bcmUdfAbstarctPktFormatGpeIOAMEdgeToEdge </td><td>Abstract from the start of the first byte of GPE header with IOAM type as E2E (Edge to Edge).  </td></tr>
<tr>
<td>bcmUdfAbstractPktFormatCount </td><td>Always Last. Not to be used.  </td></tr>
</table>
<p><a class="anchor" id="bcm_udf_pkt_base_offset_t"></a><a class="anchor" id="bcmUdfPktBaseOffsetXxx"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>UDF Packet Base Offset Types.</caption>
<tr>
<th>bcmUdfPktBaseOffsetXxx </th><th>Description  </th></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfOuterL2 </td><td>Base offset from the start of Outer L2 Header.  </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfOuterLlc </td><td>Base offset from the start of Outer LLC Header.  </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfTunnel </td><td>Base offset from the start of Tunnel Header.  </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfOuterL3 </td><td>Base offset from the start of Outer L3 Header.  </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfOuterL4 </td><td>Base offset from the start of Outer L4 Header.  </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfOuterL5 </td><td>Base offset from the start of Outer L5 Header.  </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfInnerL2 </td><td>Base offset from the start of Inner L2 Header.  </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfInnerLlc </td><td>Base offset from the start of Inner LLC Header.  </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfInnerL3 </td><td>Base offset from the start of Inner L3 Header.  </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfInnerL4 </td><td>Base offset from the start of Inner L4 Header.  </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfInnerL5 </td><td>Base offset from the start of Inner L5 Header.  </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfSystemHeader </td><td>Base offset from the start of system header (HiGig or Loopback).   </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOf14bytesAfterOuterL2 </td><td>Base offset from the start of 14 bytes after Outer L2 Header. (For example: In-case of L2 Single tagged packet, it is start of 802.1p priority field after TPID.)   </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOf12bytesAfterInnerL2 </td><td>Base offset from the start of 12 bytes after Outer L2 Header.   </td></tr>
<tr>
<td>bcmUdfPktBaseOffsetStartOfGpe </td><td>Base offset from the start of Gpe Header.  </td></tr>
</table>
<p><a class="anchor" id="bcm_udf_tunnel_term_flow_type_t"></a><a class="anchor" id="bcmUdfTunnelTermFlowTypeXxx"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>UDF tunnel termination flow types enumeration for 'bcm_udf_tunnel_term_flow_type_t'.</caption>
<tr>
<th>bcmUdfTunnelTermFlowTypeXxx </th><th>Description  </th></tr>
<tr>
<td>bcmUdfTunnelTermFlowTypeMimWithIpPayload </td><td>MiM with IP Payload.  </td></tr>
<tr>
<td>bcmUdfTunnelTermFlowTypeMimWithoutIpPayload </td><td>MiM without IP Payload.  </td></tr>
<tr>
<td>bcmUdfTunnelTermFlowTypeL2MplsWithIpPayload </td><td>L2 MPLS with IP Payload.  </td></tr>
<tr>
<td>bcmUdfTunnelTermFlowTypeL2MplsWithoutIpPayload </td><td>L2 MPLS without IP Payload.  </td></tr>
<tr>
<td>bcmUdfTunnelTermFlowTypeL2GreWithIpPayload </td><td>L2 GRE with IP Payload.  </td></tr>
<tr>
<td>bcmUdfTunnelTermFlowTypeL2GreWithoutIpPayload </td><td>L2 GRE without IP Payload.  </td></tr>
<tr>
<td>bcmUdfTunnelTermFlowTypeVxlanWithIpPayload </td><td>VxLAN with IP Payload.  </td></tr>
<tr>
<td>bcmUdfTunnelTermFlowTypeVxlanWithoutIpPayload </td><td>VxLAN without IP Payload.  </td></tr>
<tr>
<td>bcmUdfTunnelTermFlowTypeL3Mpls </td><td>L3 MPLS.  </td></tr>
<tr>
<td>bcmUdfTunnelTermFlowTypeL3Tunnel </td><td>L3 Tunnel.  </td></tr>
<tr>
<td>bcmUdfTunnelTermFlowTypeL3GpeGeneve </td><td>L3 Gpe Geneve.  </td></tr>
</table>
<h1><a class="anchor" id="udf_apis"></a>
APIs to manage the UDF resources</h1>
<p>During bcm_init, The udf module will be initialized (or reinitialized, if warm-booting) before the field module is initialized. This is required, at least in case of warm reloading because the udf objects which are recovered in UDF module are needed for appropriate object recovery while recovering field groups/entries.</p>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="group__udf.html#gac8355a96df58c76c8845ac39f747f387" title="Initializes the UDF structure.">bcm_udf_t_init(bcm_udf_t* udf_info)</a>  </td><td>Initializes the UDF structure   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#gad0c927914571f44f11fe6e850be37a5a" title="Initializes the UDF alloc hints structure.">bcm_udf_alloc_hints_t_init(bcm_udf_alloc_hints_t* udf_hints)</a>  </td><td>Initializes the UDF alloc hints structure   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga0fa96356e54ad70eb4b5788ca1516275" title="Initialize the UDF packet format structure.">bcm_udf_pkt_format_info_t_init(bcm_udf_pkt_format_info_t* pkt_format)</a>  </td><td>Initialize the UDF packet format structure   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga001d12b5828a6bc060497bf3168a7078" title="Initialize the UDF hashing configuration structure.">bcm_udf_hash_config_t_init(bcm_udf_hash_config_t* info)</a>  </td><td>Initialize the UDF hashing configuration structure   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#gaba6f60be93c6a9e996c374c329616aa6" title="Initialize UDF module.">bcm_udf_init(int unit)</a>  </td><td>Initialize UDF module   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga946bfe37ed0752c6b2ea7146ccdb7aea" title="Detach UDF module.">bcm_udf_detach(int unit)</a>  </td><td>Detach UDF module   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga8b5397e2c6e7f08a0d3c8b388bba69a5" title="Creates a UDF object.">bcm_udf_create(int unit, bcm_udf_alloc_hints_t* hints, bcm_udf_t* udf_info, bcm_udf_id_t* udf_id)</a>  </td><td>Creates a UDF object   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#gaf45232aa16ba08f3b6fcee482860de75" title="Fetches the UDF object created in the system.">bcm_udf_get(int unit, bcm_udf_id_t udf_id, bcm_udf_t* udf_info)</a>  </td><td>Fetches the UDF object created in the system   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga898a182d905a58f81aa36e7b99dc457d" title="Fetches all existing UDF ids.">bcm_udf_get_all(int unit, int max, bcm_udf_id_t* udf_id_list, int* actual)</a>  </td><td>Fetches all existing UDF ids   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#gac9de5f841e5cfedd70a6208cfaed6468" title="Destroys the UDF object.">bcm_udf_destroy(int unit, bcm_udf_id_t udf_id)</a>  </td><td>Destroys the UDF object   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga113c557ca4ccb65918a7adb8dfc26aec" title="Create a packet format entry.">bcm_udf_pkt_format_create(int unit, bcm_udf_pkt_format_options_t options, bcm_udf_pkt_format_info_t* pkt_format, bcm_udf_pkt_format_id_t* pkt_format_id)</a>  </td><td>Create a packet format entry   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga47df03f55c7afaefc32a893e7be71447" title="Retrieve packet format info given the packet format Id.">bcm_udf_pkt_format_info_get(int unit, bcm_udf_pkt_format_id_t pkt_format_id, bcm_udf_pkt_format_info_t* pkt_format)</a>  </td><td>Retrieve packet format info given the packet format Id   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga0e0ab75a44fe67f26340ae7aa5707cb9" title="Destroy existing packet format entry.">bcm_udf_pkt_format_destroy(int unit, bcm_udf_pkt_format_id_t pkt_format_id)</a>  </td><td>Destroy existing packet format entry   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga3966951dc14f8c91690b32f5c06cc3f0" title="Adds packet format entry to UDF object.">bcm_udf_pkt_format_add(int unit, bcm_udf_id_t udf_id, bcm_udf_pkt_format_id_t pkt_format_id)</a>  </td><td>Adds packet format entry to UDF object   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#gaa8aba9010a4698840494aa0e150fbba3" title="Deletes packet format spec associated with the UDF.">bcm_udf_pkt_format_get(int unit, bcm_udf_pkt_format_id_t pkt_format_id, int max, bcm_udf_id_t* udf_id_list, int* actual)</a>  </td><td>Deletes packet format spec associated with the UDF   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga008b45fbfe28ed139cdefaf90bacbb8b" title="Deletes packet format spec associated with the UDF.">bcm_udf_pkt_format_delete(int unit, bcm_udf_id_t udf_id, bcm_udf_pkt_format_id_t pkt_format_id)</a>  </td><td>Deletes packet format spec associated with the UDF   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga581f36a99745df7b373110791dfaa779" title="Retrieves the user defined format specification configuration from UDF.">bcm_udf_pkt_format_get_all(int unit, bcm_udf_id_t udf_id, int max, bcm_udf_pkt_format_id_t* pkt_format_id_list, int* actual)</a>  </td><td>Retrieves the user defined format specification configuration from UDF   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#gad1af2955eaf24fdc6bddba2a64fa0c82" title="Deletes all packet format specs associated with the UDF.">bcm_udf_pkt_format_delete_all(int unit, bcm_udf_id_t udf_id)</a>  </td><td>Deletes all packet format specs associated with the UDF   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga8bed89564c155d028ae33a6d614eb463" title="Add UDF id into UDF hashing list.">bcm_udf_hash_config_add(int unit, uint32 options, bcm_udf_hash_config_t* config)</a>  </td><td>Add UDF id into UDF hashing list   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#gaca7920cf923ba49f1ba63e44f0fe52e4" title="Delete UDF id from UDF hashing list.">bcm_udf_hash_config_delete(int unit, bcm_udf_hash_config_t* config)</a>  </td><td>Delete UDF id from UDF hashing list   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga72b95ca94fbc9854b1feffd3d6e29edf" title="Delete all UDF id from UDF hashing list.">bcm_udf_hash_config_delete_all(int unit)</a>  </td><td>Delete all UDF id from UDF hashing list   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga93cc4512bd2f251918e3265a75be2d1a" title="Get UDF hashing configuration of a certain id.">bcm_udf_hash_config_get(int unit, bcm_udf_hash_config_t* config)</a>  </td><td>Get UDF hashing configuration of a certain id   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga03fc99455f38bb93ed7d05b69c7913ce" title="Get all added UDF ids from list.">bcm_udf_hash_config_get_all(int unit, int max, bcm_udf_hash_config_t* config_list, int* actual)</a>  </td><td>Get all added UDF ids from list   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#gaedd583a054da8066a56675907733ebee" title="Set UDF operation mode.">bcm_udf_oper_mode_set(int unit, bcm_udf_oper_mode_t mode)</a>  </td><td>Set UDF operation mode   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#gaeebe7571935ef09c8a6eae88d8db8d63" title="get UDF operation mode">bcm_udf_oper_mode_get(int unit, bcm_udf_oper_mode_t* mode)</a>  </td><td>get UDF operation mode   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga28aad24e8da46198b563e1c1f68b3be8" title="Create UDF object.">bcm_udf_chunk_create(int unit, bcm_udf_alloc_hints_t* hints, bcm_udf_chunk_info_t* udf_chunk_info, bcm_udf_id_t* udf_id)</a>  </td><td>Create UDF object   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#gada8bda01c8d30ce49187c6615c8f4f1b" title="Get a UDF object information.">bcm_udf_chunk_info_get(int unit, bcm_udf_id_t udf_id, bcm_udf_chunk_info_t* udf_chunk_info)</a>  </td><td>Get a UDF object information.   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#gad54564766a834e64b982ffd1a2eb3bc1" title="API to retrieve the list of UDF Objects associated with a given abstract packet format.">bcm_udf_abstract_pkt_format_object_list_get(int unit, bcm_udf_abstract_pkt_format_t abstract_pkt_format, int max, bcm_udf_id_t* udf_id_list, int* actual)</a>  </td><td>API to retrieve the list of UDF Objects associated with a given abstract packet format   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga9206363afd00977212a933dd20ba4881" title="API to retrieve Abstract packet format information.">bcm_udf_abstract_pkt_format_info_get(int unit, bcm_udf_abstract_pkt_format_t abstract_pkt_format, bcm_udf_abstract_pkt_format_info_t* pkt_format_info)</a>  </td><td>API to retrieve Abstract packet format information.   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga482c063f667869a2a24bbe52edd8d45f" title="API to retrieve the chunk information supported for Range Checker.">bcm_udf_range_checker_chunk_info_get(int unit, uint8* num_chunks, uint32* chunk_bmap)</a>  </td><td>API to retrieve the chunk information supported for Range Checker.   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga77dc86c1b6438459998cbf71156f3740" title="API to assign the chunk bitmaps to the tunnel termination flows. The non-zero bits assigned to the ch...">bcm_udf_flow_based_chunk_arrange_set(int unit, bcm_udf_tunnel_term_flow_type_t flow_type, uint32 chunk_bmap)</a>  </td><td>API to assign the chunk bitmaps to the tunnel termination flows. The non-zero bits assigned to the chunk bitmap are applicable to extract the information from the tunnel header and zero bits are applicable to tunnel payload for a given termination flow.   </td></tr>
<tr>
<td><a class="el" href="group__udf.html#ga6af4f546ab7cb44fc4092c2537a0d865" title="API to retrieve the chunk bitmaps information for a given tunnel termination flow.">bcm_udf_flow_based_chunk_arrange_get(int unit, bcm_udf_tunnel_term_flow_type_t flow_type, uint32* chunk_bmap)</a>  </td><td>API to retrieve the chunk bitmaps information for a given tunnel termination flow.   </td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="footer-brcm-wrapper">
<table class="footer-brcm">
	<tbody><tr>
		<td class="footer-brcm"><img src="BRCM_Red+Black_noTag_RGB.png" align="left"></td>
		<td class="footer-brcm"><small><b>Proprietary and Confidential &copy; 2020 Broadcom</b></small>
			<div class="footer-brcm">Broadcom Incorporated reserves the right to make changes without further notice to any products or data herein to improve reliability, function, or design.
Information furnished by Broadcom Incorporated is believed to be accurate and reliable. However, Broadcom Incorporated does not assume any liability arising
out of the application or use of this information, nor the application or use of any product or circuit described herein, neither does it convey any license
under its patent rights nor the rights of others.
			</div>
		</td>
	</tr>
</tbody></table>
</div>
</body>
</html>
