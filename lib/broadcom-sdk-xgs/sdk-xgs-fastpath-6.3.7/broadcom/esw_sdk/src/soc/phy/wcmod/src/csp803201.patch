--- wcmod_diagnostics.c.orig    2014-07-09 03:19:45.502391000 -0700
+++ wcmod_diagnostics.c 2014-07-09 03:35:06.164716000 -0700
@@ -3570,7 +3570,57 @@

 int wcmod_diag_tx_amps(wcmod_st *ws)
 {
-  uint16 dt, idrv, predrv, p2_cf;
+   uint16 dt, idrv, predrv, p2_cf, tmp_lane;
+
+   if (ws->model_type == WCMOD_QS_A0) {
+     tmp_lane = ws->this_lane;
+     ws->this_lane = (tmp_lane / 4) * 4;
+   } else {
+     tmp_lane = ws->this_lane;
+   }
+
+   if ((ws->model_type != WCMOD_QS_A0) && (tmp_lane >= 4)) {
+     printf ("%s FATAL: Internal. Bad lane:%d\n", FUNCTION_NAME(), tmp_lane);
+     return SOC_E_ERROR;
+   }
+
+
+  if (ws->model_type == WCMOD_QS_A0) {
+     READ_WC40_TX0_TX_DRIVERr(ws->unit, ws, &dt);
+  } else {
+      if (ws->this_lane % 4 == 0)  {
+        READ_WC40_TX0_TX_DRIVERr(ws->unit, ws, &dt);
+      } else if (ws->this_lane % 4 == 1) {
+        READ_WC40_TX1_TX_DRIVERr(ws->unit, ws, &dt);
+      } else if (ws->this_lane % 4 == 2) {
+        READ_WC40_TX2_TX_DRIVERr(ws->unit, ws, &dt);
+      } else {
+        READ_WC40_TX3_TX_DRIVERr(ws->unit, ws, &dt);
+      }
+   }
+
+   idrv  =(dt & TX0_TX_DRIVER_IDRIVER_MASK) >> TX0_TX_DRIVER_IDRIVER_SHIFT;
+   predrv=(dt & TX0_TX_DRIVER_IPREDRIVER_MASK) >> TX0_TX_DRIVER_IPREDRIVER_SHIFT;
+   p2_cf =(dt & TX0_TX_DRIVER_POST2_COEFF_MASK) >> TX0_TX_DRIVER_POST2_COEFF_SHIFT;
+printf ("Tx Amps. Lane %d: IDriver:%d PreDriver:%d P2_Coeff:%d\n",
+                                               tmp_lane,idrv,predrv,p2_cf);
+
+   if ((ws->accData) == 0x1)        {
+     ws->accData = predrv;
+   } else if ((ws->accData) == 0x2) {
+     ws->accData = idrv;
+   } else if ((ws->accData) == 0x3) {
+     ws->accData = p2_cf;
+   }
+   ws->this_lane = tmp_lane;
+   return SOC_E_NONE;
+
+
+
+
+#if 0
+  uint16 dt, idrv, predrv, p2_cf, temp_lane;
+

   if (ws->this_lane == 0) {
     READ_WC40_TX0_TX_DRIVERr(ws->unit, ws, &dt);
@@ -3598,6 +3648,7 @@
     ws->accData = p2_cf;
   }
   return SOC_E_NONE;
+#endif
 }

 int wcmod_diag_prbs(wcmod_st* ws)
@@ -3706,7 +3757,8 @@
 /* WCMOD_DIAG_TX_TAPS */
 int wcmod_diag_tx_taps(wcmod_st *ws)
 {
-  uint16 dt, pre, mn, post;
+#if 0
+uint16 dt, pre, mn, post;
   SOC_IF_ERROR_RETURN
       (READ_WC40_CL72_USERB0_CL72_TX_FIR_TAP_REGISTERr(ws->unit,ws, &dt));

@@ -3721,6 +3773,49 @@

   printf ("Tx_Taps, Lane:%d: Pre:0x%02x Main:0x%02x Post:0x%02x\n",
   ws->this_lane, pre,mn  ,post);
+#endif
+
+
+  uint16 dt, pre, mn, post, tmp_lane;
+
+  if (ws->model_type == WCMOD_QS_A0) {
+    tmp_lane = ws->this_lane;
+    ws->this_lane = (tmp_lane / 4) * 4;
+  } else {
+    tmp_lane = ws->this_lane;
+  }
+
+  if ((ws->model_type != WCMOD_QS_A0) && (tmp_lane >= 4)) {
+    printf ("%s FATAL: Internal. Bad lane:%d\n", FUNCTION_NAME(), tmp_lane);
+    return SOC_E_ERROR;
+  }
+
+  if (ws->model_type == WCMOD_QS_A0) {
+          SOC_IF_ERROR_RETURN
+              (READ_WC40_TX0_ANATXACONTROL2r(ws->unit,ws, &dt));
+          pre = (dt & 0x8000) >> 15;
+          mn =  (dt & 0x7c00) >> 10;
+          SOC_IF_ERROR_RETURN
+              (READ_WC40_TX0_TX_DRIVERr(ws->unit,ws, &dt));
+          post = (dt & 0xf) << 1 | pre;
+          pre = 0;
+          ws->this_lane = tmp_lane;
+  } else {
+      SOC_IF_ERROR_RETURN
+          (READ_WC40_CL72_USERB0_CL72_TX_FIR_TAP_REGISTERr(ws->unit,ws, &dt));
+
+      ws->accData = dt & (~CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_FORCE_MASK);
+      /* using mask of lane 0. only */
+      pre = (dt & CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_PRE_MASK)
+               >> CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_PRE_SHIFT;
+      mn  = (dt & CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_MAIN_MASK)
+               >> CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_MAIN_SHIFT;
+      post= (dt & CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_POST_MASK)
+               >> CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_POST_SHIFT;
+  }
+  printf ("Tx_Taps, Lane:%d: Pre:0x%02x Main:0x%02x Post:0x%02x\n",
+  tmp_lane, pre,mn  ,post);
+
   return SOC_E_NONE;
 }


--- wcmod_cfg_seq.c.orig        2014-07-09 03:13:51.843618000 -0700
+++ wcmod_cfg_seq.c     2014-07-09 03:18:17.921985000 -0700
@@ -5332,7 +5332,7 @@
 {
   int cntl = pc->per_lane_control;
   int val = 0, mask = 0, mask_cntl = 0;
-
+#if 0
  if (cntl & 0x8000000) {
     MODIFY_WC40_CL72_USERB0_CL72_TX_FIR_TAP_REGISTERr(pc->unit, pc,
             0, CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_FORCE_MASK );
@@ -5366,6 +5366,75 @@
     MODIFY_WC40_CL72_USERB0_CL72_TX_FIR_TAP_REGISTERr(pc->unit, pc,
       (val | CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_FORCE_MASK),
       (mask_cntl | CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_FORCE_MASK));
+#endif
+  uint16 tmp_lane, post, main_tap;
+
+  post = 0;
+  main_tap = 0;
+
+  if (pc->model_type == WCMOD_QS_A0) {
+    tmp_lane = pc->this_lane;
+    pc->this_lane = (pc->this_lane / 4) * 4;
+  } else {
+    tmp_lane = pc->this_lane;
+  }
+
+  if ((pc->model_type != WCMOD_QS_A0) && (tmp_lane >= 4)) {
+    printf ("%s FATAL: Internal. Bad lane:%d\n", FUNCTION_NAME(), tmp_lane);
+    return SOC_E_ERROR;
+  }
+
+  if (pc->model_type == WCMOD_QS_A0) {
+      if (cntl & 0x2000000) { /* set main override */
+        mask = CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_MAIN_MASK >>
+               CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_MAIN_SHIFT ;
+        main_tap = (((cntl & 0xff00)>>8) & mask) ;
+      }
+      if (cntl & 0x4000000) { /* set post override */
+        mask = CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_POST_MASK >>
+               CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_POST_SHIFT;
+        post = (((cntl & 0xff0000)>>16) & mask);
+      }
+
+      MODIFY_WC40_TX0_ANATXACONTROL2r(pc->unit, pc,  main_tap << 10, 0x7c00);
+      MODIFY_WC40_TX0_ANATXACONTROL2r(pc->unit, pc, (post & 0x1) << 15, 0x8000);
+      MODIFY_WC40_TX0_TX_DRIVERr(pc->unit, pc, (post & 0x1e) >> 1, 0xf);
+      pc->this_lane = tmp_lane;
+} else {
+      if (cntl & 0x8000000) {
+        MODIFY_WC40_CL72_USERB0_CL72_TX_FIR_TAP_REGISTERr(pc->unit, pc,
+                0, CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_FORCE_MASK );
+        return SOC_E_NONE;
+      }
+      if (cntl & 0x1000000) { /* set pre override */
+        mask_cntl |= CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_PRE_MASK;
+        mask = CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_PRE_MASK >>
+               CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_PRE_SHIFT;
+        val = ((cntl & 0xff)  & mask)
+               << CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_PRE_SHIFT;
+
+      }
+      if (cntl & 0x2000000) { /* set main override */
+       mask_cntl |= CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_MAIN_MASK;
+        mask = CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_MAIN_MASK >>
+               CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_MAIN_SHIFT ;
+        val |= (((cntl & 0xff00)>>8) & mask)
+                << CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_MAIN_SHIFT;
+      }
+
+      if (cntl & 0x4000000) { /* set post override */
+        mask_cntl |= CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_POST_MASK;
+        mask = CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_POST_MASK >>
+               CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_POST_SHIFT;
+        val |= (((cntl & 0xff0000)>>16) & mask)
+                << CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_POST_SHIFT;
+      }
+
+      if (cntl & 0x7000000) {  /* was using || */
+        MODIFY_WC40_CL72_USERB0_CL72_TX_FIR_TAP_REGISTERr(pc->unit, pc,
+          (val | CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_FORCE_MASK),
+          (mask_cntl | CL72_USERB0_CL72_TX_FIR_TAP_REGISTER_TX_FIR_TAP_FORCE_MASK));
+      }
   }
   return SOC_E_NONE;
 }
