/*
 * $Id: $
 * 
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_FLEXCTR_H__
#define __BCM_FLEXCTR_H__

#include <bcm/types.h>
#include <bcm/port.h>

/* 
 * Enumeration of flex counter sources.
 * 
 * Flex counter source indicates the sources to generates a flex counter
 * action.
 */
typedef enum bcm_flexctr_source_e {
    bcmFlexctrSourceIngPort = 0,        /* Ingress system port. */
    bcmFlexctrSourceEgrPort = 1,        /* Egress system port. */
    bcmFlexctrSourceIngVlan = 2,        /* Ingress VLAN. */
    bcmFlexctrSourceEgrVlan = 3,        /* Egress VLAN. */
    bcmFlexctrSourceIngVpn = 4,         /* Ingress VPN. */
    bcmFlexctrSourceEgrVpn = 5,         /* Egress VPN. */
    bcmFlexctrSourceSvp = 6,            /* Source VP. */
    bcmFlexctrSourceDvp = 7,            /* Destination VP. */
    bcmFlexctrSourceIngL3Intf = 8,      /* Ingress L3 interface. */
    bcmFlexctrSourceIngVrf = 9,         /* Ingress VRF. */
    bcmFlexctrSourceIfp = 10,           /* Ingress filter processor. */
    bcmFlexctrSourceVfp = 11,           /* Ingress VLAN filter processor. */
    bcmFlexctrSourceEfp = 12,           /* Egress filter processor. */
    bcmFlexctrSourceL3EgressOverlay = 13, /* Overlay L3 egress. */
    bcmFlexctrSourceL3EgressUnderlay = 14, /* Underlay L3 egress. */
    bcmFlexctrSourceExactMatch = 15,    /* ExactMatch filter processor. */
    bcmFlexctrSourceIpmc = 16,          /* Ipmc. */
    bcmFlexctrSourceFieldDestination = 17, /* Destination field. */
    bcmFlexctrSourceIngSamplePool = 18, /* Packets eligible to be sampled by
                                           ingress sampler. */
    bcmFlexctrSourceIngSampleCount = 19, /* Packets sampled by ingress sampler. */
    bcmFlexctrSourceFlexSamplePool = 20, /* Packets eligible to be sampled by
                                           flex sampler. */
    bcmFlexctrSourceFlexSampleCount = 21, /* Packets sampled by flex sampler. */
    bcmFlexctrSourceCount = 22          /* Always last one. */
} bcm_flexctr_source_t;

#define BCM_FLEXCTR_SOURCE_NAME_INITIALIZER \
{ \
    "bcmFlexctrSourceIngPort", \
    "bcmFlexctrSourceEgrPort", \
    "bcmFlexctrSourceIngVlan", \
    "bcmFlexctrSourceEgrVlan", \
    "bcmFlexctrSourceIngVpn", \
    "bcmFlexctrSourceEgrVpn", \
    "bcmFlexctrSourceSvp", \
    "bcmFlexctrSourceDvp", \
    "bcmFlexctrSourceIngL3Intf", \
    "bcmFlexctrSourceIngVrf", \
    "bcmFlexctrSourceIfp", \
    "bcmFlexctrSourceVfp", \
    "bcmFlexctrSourceEfp", \
    "bcmFlexctrSourceL3EgressOverlay", \
    "bcmFlexctrSourceL3EgressUnderlay", \
    "bcmFlexctrSourceExactMatch", \
    "bcmFlexctrSourceIpmc", \
    "bcmFlexctrSourceFieldDestination", \
    "bcmFlexctrSourceIngSamplePool", \
    "bcmFlexctrSourceIngSampleCount", \
    "bcmFlexctrSourceFlexSamplePool", \
    "bcmFlexctrSourceFlexSampleCount", \
    "bcmFlexctrSourceCount"  \
}

/* 
 * Enumeration of flex counter objects.
 * 
 * Flex counter object could be used to generate counter index and
 * counter value.
 * Some objects could also be used for conditional trigger and
 * quantization.
 */
typedef enum bcm_flexctr_object_e {
    bcmFlexctrObjectConstZero = 0,      /* Const value 0 object. */
    bcmFlexctrObjectConstOne = 1,       /* Const value 1 object. */
    bcmFlexctrObjectTriggerInterval = 2, /* Trigger interval object. */
    bcmFlexctrObjectQuant = 3,          /* Quantization result object. */
    bcmFlexctrObjectIngSystemSource = 1000, /* Ingress system source object. */
    bcmFlexctrObjectIngIngressPpPort = 1001, /* Ingress pp port object. */
    bcmFlexctrObjectIngL2Iif = 1002,    /* Ingress l2 iif object. */
    bcmFlexctrObjectIngL3Iif = 1003,    /* Ingress l3 iif object. */
    bcmFlexctrObjectIngL2SrcLookupHitIndex0 = 1004, /* Ingress l2 src lookup hit index 0
                                           object. */
    bcmFlexctrObjectIngL2SrcLookupHitIndex1 = 1005, /* Ingress l2 src lookup hit index 1
                                           object. */
    bcmFlexctrObjectIngL2DstLookupHitIndex0 = 1006, /* Ingress l2 dst lookup hit index 0
                                           object. */
    bcmFlexctrObjectIngL2DstLookupHitIndex1 = 1007, /* Ingress l2 dst lookup hit index 1
                                           object. */
    bcmFlexctrObjectIngSvp = 1008,      /* Ingress svp object. */
    bcmFlexctrObjectIngVfi = 1009,      /* Ingress vfi object. */
    bcmFlexctrObjectIngDstFpFlexCtrIndex = 1010, /* Ingress dst fp flex ctr index object. */
    bcmFlexctrObjectIngIfpOpaqueObj1 = 1011, /* Ingress ifp opaque obj 1 object. */
    bcmFlexctrObjectIngIfpOpaqueObj0 = 1012, /* Ingress ifp opaque obj 0 object. */
    bcmFlexctrObjectEgrVfi = 1013,      /* Egress vfi object. */
    bcmFlexctrObjectEgrDvp = 1014,      /* Egress dvp object. */
    bcmFlexctrObjectEgrL2Oif = 1015,    /* Egress l2 oif object. */
    bcmFlexctrObjectEgrL3Oif1 = 1016,   /* Egress l3 oif 1 object. */
    bcmFlexctrObjectEgrTxPpPort = 1017, /* Egress tx pp port object. */
    bcmFlexctrObjectEgrL3Oif2 = 1018,   /* Egress l3 oif 2 object. */
    bcmFlexctrObjectEgrL3NextHop2FlexCtrIndex = 1019, /* Egress l3 next hop 2 flex ctr index
                                           object. */
    bcmFlexctrObjectEgrL3NextHop1FlexCtrIndex = 1020, /* Egress l3 next hop 1 flex ctr index
                                           object. */
    bcmFlexctrObjectEgrPipePortQueueNum = 1021, /* Egress pipe port queue num object. */
    bcmFlexctrObjectEgrEfpOpaqueObj2 = 1022, /* Egress efp opaque obj 2 object. */
    bcmFlexctrObjectEgrEfpOpaqueObj1 = 1023, /* Egress efp opaque obj 1 object. */
    bcmFlexctrObjectEgrResidenceTimeShifted0 = 1024, /* Egress residence time shifted 0
                                           object. */
    bcmFlexctrObjectEgrResidenceTimeShifted = 1025, /* Egress residence time shifted object. */
    bcmFlexctrObjectIngVfpOpaqueObj0 = 1026, /* Ingress vfp opaque obj 0 object. */
    bcmFlexctrObjectIngNhop2OrEcmpGroupIndex1 = 1027, /* Ingress nhop 2 or ecmp group index 1
                                           object. */
    bcmFlexctrObjectIngNhopIndex1 = 1028, /* Ingress nhop index 1 object. */
    bcmFlexctrObjectIngEmFtOpaqueObj1 = 1029, /* Ingress em ft opaque obj 1 object. */
    bcmFlexctrObjectIngEmFtOpaqueObj0 = 1030, /* Ingress em ft opaque obj 0 object. */
    bcmFlexctrObjectEgrEcnMapInputVector = 1031, /* Egress ecn map input vector object. */
    bcmFlexctrObjectIngEmFtHitIndex0 = 1032, /* Ingress em ft hit index 0 object. */
    bcmFlexctrObjectIngEmFtHitIndex1 = 1033, /* Ingress em ft hit index 1 object. */
    bcmFlexctrObjectIngL3DstClassId = 1034, /* Ingress l3 dst class id object. */
    bcmFlexctrObjectEgrResidenceTimeShifted1 = 1035, /* Egress residence time shifted 1
                                           object. */
    bcmFlexctrObjectEgrEcnMapInputVector0 = 1036, /* Egress ecn map input vector 0 object. */
    bcmFlexctrObjectIngIntPri = 1037,   /* Ingress int pri object. */
    bcmFlexctrObjectCount = 1038        /* Always last one. */
} bcm_flexctr_object_t;

#define BCM_FLEXCTR_OBJECT_NAME_INITIALIZER \
{ \
    "bcmFlexctrObjectConstZero", \
    "bcmFlexctrObjectConstOne", \
    "bcmFlexctrObjectTriggerInterval", \
    "bcmFlexctrObjectQuant", \
    "bcmFlexctrObjectIngSystemSource", \
    "bcmFlexctrObjectIngIngressPpPort", \
    "bcmFlexctrObjectIngL2Iif", \
    "bcmFlexctrObjectIngL3Iif", \
    "bcmFlexctrObjectIngL2SrcLookupHitIndex0", \
    "bcmFlexctrObjectIngL2SrcLookupHitIndex1", \
    "bcmFlexctrObjectIngL2DstLookupHitIndex0", \
    "bcmFlexctrObjectIngL2DstLookupHitIndex1", \
    "bcmFlexctrObjectIngSvp", \
    "bcmFlexctrObjectIngVfi", \
    "bcmFlexctrObjectIngDstFpFlexCtrIndex", \
    "bcmFlexctrObjectIngIfpOpaqueObj1", \
    "bcmFlexctrObjectIngIfpOpaqueObj0", \
    "bcmFlexctrObjectEgrVfi", \
    "bcmFlexctrObjectEgrDvp", \
    "bcmFlexctrObjectEgrL2Oif", \
    "bcmFlexctrObjectEgrL3Oif1", \
    "bcmFlexctrObjectEgrTxPpPort", \
    "bcmFlexctrObjectEgrL3Oif2", \
    "bcmFlexctrObjectEgrL3NextHop2FlexCtrIndex", \
    "bcmFlexctrObjectEgrL3NextHop1FlexCtrIndex", \
    "bcmFlexctrObjectEgrPipePortQueueNum", \
    "bcmFlexctrObjectEgrEfpOpaqueObj2", \
    "bcmFlexctrObjectEgrEfpOpaqueObj1", \
    "bcmFlexctrObjectEgrResidenceTimeShifted0", \
    "bcmFlexctrObjectEgrResidenceTimeShifted", \
    "bcmFlexctrObjectIngVfpOpaqueObj0", \
    "bcmFlexctrObjectIngNhop2OrEcmpGroupIndex1", \
    "bcmFlexctrObjectIngNhopIndex1", \
    "bcmFlexctrObjectIngEmFtOpaqueObj1", \
    "bcmFlexctrObjectIngEmFtOpaqueObj0", \
    "bcmFlexctrObjectEgrEcnMapInputVector", \
    "bcmFlexctrObjectIngEmFtHitIndex0", \
    "bcmFlexctrObjectIngEmFtHitIndex1", \
    "bcmFlexctrObjectIngL3DstClassId", \
    "bcmFlexctrObjectEgrResidenceTimeShifted1", \
    "bcmFlexctrObjectEgrEcnMapInputVector0", \
    "bcmFlexctrObjectIngIntPri", \
    "bcmFlexctrObjectCount"  \
}

#define BCM_FLEXCTR_COUNTER_VALUE_SIZE  2          /* Counter array size number. */

/* 
 * Flex counter statistic value.
 * 
 * Normal mode:
 * value[0] is the data of counter value A.
 * value[1] is the data of counter value B.
 * Wide mode:
 * value[0] is the upper part data of counter value A.
 * value[1] is the lower part data of counter value A.
 * Slim mode:
 * value[0] is the data of counter value A.
 */
typedef struct bcm_flexctr_counter_value_s {
    uint64 value[BCM_FLEXCTR_COUNTER_VALUE_SIZE]; /* Flex counter statistic value array. */
} bcm_flexctr_counter_value_t;

#define BCM_FLEXCTR_OPERATION_OBJECT_SIZE   2          /* Operation object array
                                                          size number. */

/* 
 * Flex counter index operation structure.
 * 
 * This data structure lists the operation of a flex counter index.
 * Flex counter index would be generated as below:
 *      value0 = (SEL(object0) >> shift0) & ((1 << mask_size0) - 1)).
 *      value1 = (SEL(object1) & ((1 << mask_size1) - 1)) << shift1.
 *      index = (value1 | value0).
 */
typedef struct bcm_flexctr_index_operation_s {
    bcm_flexctr_object_t object[BCM_FLEXCTR_OPERATION_OBJECT_SIZE]; /* Flex counter object array. */
    uint32 quant_id[BCM_FLEXCTR_OPERATION_OBJECT_SIZE]; /* Quantization ID. */
    uint8 mask_size[BCM_FLEXCTR_OPERATION_OBJECT_SIZE]; /* Object mask size array. */
    uint8 shift[BCM_FLEXCTR_OPERATION_OBJECT_SIZE]; /* Object shift array. */
} bcm_flexctr_index_operation_t;

/* Enumeration of flex counter value select. */
typedef enum bcm_flexctr_value_select_e {
    bcmFlexctrValueSelectCounterValue = 0, /* Select counter value generated by
                                           operation to update counter. */
    bcmFlexctrValueSelectPacketLength = 1, /* Select packet length to update
                                           counter. */
    bcmFlexctrValueSelectPairedCounter = 2, /* Select paired counter value to update
                                           counter. */
    bcmFlexctrValueSelectCount = 3      /* Always last one. */
} bcm_flexctr_value_select_t;

/* Enumeration of flex counter value operation types. */
typedef enum bcm_flexctr_value_operation_type_e {
    bcmFlexctrValueOperationTypeNoop = 0, /* COUNTER = OLD_COUNTER. */
    bcmFlexctrValueOperationTypeSet = 1, /* COUNTER = CVALUE. */
    bcmFlexctrValueOperationTypeInc = 2, /* COUNTER = OLD_COUNTER + CVALUE. */
    bcmFlexctrValueOperationTypeDec = 3, /* COUNTER = OLD_COUNTER - CVALUE. */
    bcmFlexctrValueOperationTypeMax = 4, /* COUNTER = MAX(OLD_COUNTER, CVALUE). */
    bcmFlexctrValueOperationTypeMin = 5, /* COUNTER = MIN(OLD_COUNTER, CVALUE). */
    bcmFlexctrValueOperationTypeAverage = 6, /* COUNTER = AVERAGE(OLD_COUNTER,
                                           CVALUE). */
    bcmFlexctrValueOperationTypeSetBit = 7, /* COUNTER = SETBIT(OLD_COUNTER,
                                           CVALUE). */
    bcmFlexctrValueOperationTypeRdec = 8, /* COUNTER = CVALUE - OLD_COUNTER. */
    bcmFlexctrValueOperationTypeXor = 9, /* COUNTER = XOR(OLD_COUNTER, CVALUE). */
    bcmFlexctrValueOperationTypeCount = 10 /* Always last one. */
} bcm_flexctr_value_operation_type_t;

/* 
 * Flex counter value operation structure.
 * 
 * This data structure lists the operation of a flex counter update
 * value.
 * Flex counter update value would be generated as below:
 *      value0 = (SEL(object0) >> shift0) & ((1 << mask_size0) - 1)).
 *      value1 = (SEL(object1) & ((1 << mask_size1) - 1)) << shift1.
 *      value = (value1 | value0).
 *      New_counter = UPDATE_TYPE(old_counter, value).
 */
typedef struct bcm_flexctr_value_operation_s {
    bcm_flexctr_value_select_t select;  /* Select counter value. */
    bcm_flexctr_object_t object[BCM_FLEXCTR_OPERATION_OBJECT_SIZE]; /* Flex counter object array. */
    uint32 quant_id[BCM_FLEXCTR_OPERATION_OBJECT_SIZE]; /* Quantization ID. */
    uint8 mask_size[BCM_FLEXCTR_OPERATION_OBJECT_SIZE]; /* Object mask size array. */
    uint8 shift[BCM_FLEXCTR_OPERATION_OBJECT_SIZE]; /* Object shift array. */
    bcm_flexctr_value_operation_type_t type; /* Counter value operation type. */
} bcm_flexctr_value_operation_t;

#define BCM_FLEXCTR_QUANTIZATION_RANGE_SIZE 8          /* Quantization range
                                                          check array size
                                                          number. */

/* 
 * Flex counter quantization structure.
 * 
 * This data structure lists the properties of a flex counter
 * quantization.
 * Each quantization instance generates a range check result.
 */
typedef struct bcm_flexctr_quantization_s {
    bcm_flexctr_object_t object;        /* Flex counter object. */
    bcm_pbmp_t ports;                   /* Flex counter ports. */
    uint32 range_check_min[BCM_FLEXCTR_QUANTIZATION_RANGE_SIZE]; /* Range check min value array. */
    uint32 range_check_max[BCM_FLEXCTR_QUANTIZATION_RANGE_SIZE]; /* Range check max value array. */
    uint8 range_num;                    /* Total range check number */
} bcm_flexctr_quantization_t;

/* Enumeration of flex counter trigger type. */
typedef enum bcm_flexctr_trigger_type_e {
    bcmFlexctrTriggerTypeTime = 0,      /* Time based trigger type. */
    bcmFlexctrTriggerTypeCondition = 1, /* Condition based trigger type. */
    bcmFlexctrTriggerTypeCount = 2      /* Always last one. */
} bcm_flexctr_trigger_type_t;

/* Enumeration of flex counter trigger interval scale. */
typedef enum bcm_flexctr_trigger_interval_e {
    bcmFlexctrTriggerIntervalUnlimited = 0, /* Unlimited collection. */
    bcmFlexctrTriggerInterval100ns = 1, /* 100 nanosecond interval. */
    bcmFlexctrTriggerInterval500ns = 2, /* 500 nanosecond interval. */
    bcmFlexctrTriggerInterval1us = 3,   /* 1 microsecond interval. */
    bcmFlexctrTriggerInterval10us = 4,  /* 10 microsecond interval. */
    bcmFlexctrTriggerInterval100us = 5, /* 100 microsecond interval. */
    bcmFlexctrTriggerInterval1ms = 6,   /* 1 millisecond interval. */
    bcmFlexctrTriggerInterval10ms = 7,  /* 10 millisecond interval. */
    bcmFlexctrTriggerIntervalCount = 8  /* Always last one. */
} bcm_flexctr_trigger_interval_t;

/* 
 * Flex counter trigger structure.
 * 
 * This data structure lists the properties of the flex counter trigger.
 */
typedef struct bcm_flexctr_trigger_s {
    bcm_flexctr_trigger_type_t trigger_type; /* Trigger type. */
    uint8 period_num;                   /* Time trigger period number. */
    bcm_flexctr_trigger_interval_t interval; /* Time trigger interval scale. */
    bcm_flexctr_object_t object;        /* Flex counter object. */
    uint16 object_value_start;          /* Conditional trigger start value. */
    uint16 object_value_stop;           /* Conditional trigger stop value. */
    uint16 object_value_mask;           /* Conditional trigger mask. */
} bcm_flexctr_trigger_t;

/* Enumeration of flex counter counter modes. */
typedef enum bcm_flexctr_counter_mode_e {
    bcmFlexctrCounterModeNormal = 0,    /* Each counter contains two values A
                                           and B.
                                           The update value of value A and B are
                                           separately controlled by
                                           value_a_operation and
                                           value_b_operation in counter action.
                                           All value operation modes except
                                           SetBit are suitable for values A and
                                           B. */
    bcmFlexctrCounterModeWide = 1,      /* Each counter only contains one value
                                           A.
                                           The update value of value A is
                                           controlled by value_a_operation in
                                           counter action.
                                           Only value operation modes noop, set,
                                           inc and setbit are suitable for value
                                           A. */
    bcmFlexctrCounterModeSlim = 2,      /* Each counter only contains one value
                                           A.
                                           The update value of value A is
                                           controlled by value_a_operation in
                                           counter action.
                                           Only value operation modes noop, set
                                           and inc are suitable for value A.
                                           Using slim mode could contain more
                                           counters within same h/w resources. */
    bcmFlexctrCounterModeCount = 3      /* Always last one. */
} bcm_flexctr_counter_mode_t;

/* Enumeration of flex counter drop count modes. */
typedef enum bcm_flexctr_drop_count_mode_e {
    bcmFlexctrDropCountModeNoDrop = 0,  /* Count only if not being dropped. */
    bcmFlexctrDropCountModeDrop = 1,    /* Count only if being dropped. */
    bcmFlexctrDropCountModeAll = 2,     /* Ignore drop status and always count. */
    bcmFlexctrDropCountModeCount = 3    /* Always last one. */
} bcm_flexctr_drop_count_mode_t;

#define BCM_FLEXCTR_ACTION_FLAGS_TRIGGER    0x1        /* Flex counter trigger
                                                          is attached in the
                                                          action. */

/* 
 * Flex counter action structure.
 * 
 * This data structure lists the properties of a flex counter action.
 */
typedef struct bcm_flexctr_action_s {
    uint32 flags;                       /* Action flags. */
    bcm_flexctr_source_t source;        /* Flex counter source. */
    bcm_pbmp_t ports;                   /* Flex counter ports. */
    int hint;                           /* Flex counter hint. */
    bcm_flexctr_drop_count_mode_t drop_count_mode; /* Counter drop mode for functional
                                           packet drops. */
    int exception_drop_count_enable;    /* Enable to count on hardware exception
                                           drops. */
    int egress_mirror_count_enable;     /* Enable to count egress mirrored
                                           packets also. */
    bcm_flexctr_counter_mode_t mode;    /* Action mode. */
    uint32 index_num;                   /* Total counter index number. */
    bcm_flexctr_index_operation_t index_operation; /* Flex counter index operation
                                           structure. */
    bcm_flexctr_value_operation_t operation_a; /* Flex counter value A operation
                                           structure. */
    bcm_flexctr_value_operation_t operation_b; /* Flex counter value B operation
                                           structure. */
    bcm_flexctr_trigger_t trigger;      /* Flex counter trigger structure. */
} bcm_flexctr_action_t;

#define BCM_FLEXCTR_GROUP_ACTION_SIZE   16         /* Group action array size
                                                      number. */

/* 
 * Flex counter group action structure.
 * 
 * This data structure lists the properties of a flex counter group
 * action.
 */
typedef struct bcm_flexctr_group_action_s {
    bcm_flexctr_source_t source;        /* Flex counter source. */
    bcm_pbmp_t ports;                   /* Flex counter ports. */
    uint32 stat_counter_id[BCM_FLEXCTR_GROUP_ACTION_SIZE]; /* Flex counter group action array. */
    uint8 action_num;                   /* Total group action array number */
} bcm_flexctr_group_action_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Flexctr module initialization function.
 * 
 * This function is used to initialize flexctr module.
 * 
 * [in] unit Unit number.
 * 
 * BCM_E_NONE No errors.
 * BCM_E_XXX API errors.
 */
extern int bcm_flexctr_init(
    int unit);

/* 
 * Flexctr module cleanup function.
 * 
 * This function is used to shut down flexctr module.
 * 
 * [in] unit Unit number.
 * 
 * BCM_E_NONE No errors.
 * BCM_E_XXX API errors.
 */
extern int bcm_flexctr_cleanup(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FLEXCTR_OPTIONS_WITH_ID 0x1        /* Instance id is presented. */
#define BCM_FLEXCTR_OPTIONS_REPLACE 0x2        /* Need to replace an existing
                                                  instance. */

/* Flex counter quantization data structure initialization function. */
extern void bcm_flexctr_quantization_t_init(
    bcm_flexctr_quantization_t *quantization);

#ifndef BCM_HIDE_DISPATCHABLE

/* Flex counter quantization creation function. */
extern int bcm_flexctr_quantization_create(
    int unit, 
    int options, 
    bcm_flexctr_quantization_t *quantization, 
    uint32 *quant_id);

/* Flex counter quantization destroy function. */
extern int bcm_flexctr_quantization_destroy(
    int unit, 
    uint32 quant_id);

/* Flex counter quantization get function. */
extern int bcm_flexctr_quantization_get(
    int unit, 
    uint32 quant_id, 
    bcm_flexctr_quantization_t *quantization);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Flex counter quantization traverse callback. */
typedef int (*bcm_flexctr_quantization_traverse_cb)(
    int unit, 
    uint32 quant_id, 
    bcm_flexctr_quantization_t *quantization, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Flex counter quantization traverse function. */
extern int bcm_flexctr_quantization_traverse(
    int unit, 
    bcm_flexctr_quantization_traverse_cb trav_fn, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Flex counter action data structure initialization function. */
extern void bcm_flexctr_action_t_init(
    bcm_flexctr_action_t *action);

#ifndef BCM_HIDE_DISPATCHABLE

/* Flex counter action creation function. */
extern int bcm_flexctr_action_create(
    int unit, 
    int options, 
    bcm_flexctr_action_t *action, 
    uint32 *stat_counter_id);

/* Flex counter action destroy function. */
extern int bcm_flexctr_action_destroy(
    int unit, 
    uint32 stat_counter_id);

/* Flex counter action get function. */
extern int bcm_flexctr_action_get(
    int unit, 
    uint32 stat_counter_id, 
    bcm_flexctr_action_t *action);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Flex counter action traverse callback. */
typedef int (*bcm_flexctr_action_traverse_cb)(
    int unit, 
    uint32 stat_counter_id, 
    bcm_flexctr_action_t *action, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Flex counter action traverse function. */
extern int bcm_flexctr_action_traverse(
    int unit, 
    bcm_flexctr_action_traverse_cb trav_fn, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Flex counter group action data structure initialization function. */
extern void bcm_flexctr_group_action_t_init(
    bcm_flexctr_group_action_t *group_action);

#ifndef BCM_HIDE_DISPATCHABLE

/* Flex counter group action creation function. */
extern int bcm_flexctr_group_action_create(
    int unit, 
    int options, 
    bcm_flexctr_group_action_t *group_action, 
    uint32 *group_stat_counter_id);

/* Flex counter group action destroy function. */
extern int bcm_flexctr_group_action_destroy(
    int unit, 
    uint32 group_stat_counter_id);

/* Flex counter group action get function. */
extern int bcm_flexctr_group_action_get(
    int unit, 
    uint32 group_stat_counter_id, 
    bcm_flexctr_group_action_t *group_action);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Flex counter group action traverse callback. */
typedef int (*bcm_flexctr_group_action_traverse_cb)(
    int unit, 
    uint32 group_stat_counter_id, 
    bcm_flexctr_group_action_t *group_action, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Flex counter group action traverse function. */
extern int bcm_flexctr_group_action_traverse(
    int unit, 
    bcm_flexctr_group_action_traverse_cb trav_fn, 
    void *user_data);

/* Flex counter trigger enable set function. */
extern int bcm_flexctr_trigger_enable_set(
    int unit, 
    uint32 stat_counter_id, 
    int enable);

/* Flex counter trigger enable get function. */
extern int bcm_flexctr_trigger_enable_get(
    int unit, 
    uint32 stat_counter_id, 
    int *enable);

/* Flex counter statistic get function. */
extern int bcm_flexctr_stat_get(
    int unit, 
    uint32 stat_counter_id, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_flexctr_counter_value_t *counter_values);

/* Flex counter statistic sync get function. */
extern int bcm_flexctr_stat_sync_get(
    int unit, 
    uint32 stat_counter_id, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_flexctr_counter_value_t *counter_values);

/* Flex counter statistic set function. */
extern int bcm_flexctr_stat_set(
    int unit, 
    uint32 stat_counter_id, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_flexctr_counter_value_t *counter_values);

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_FLEXCTR_H__ */
