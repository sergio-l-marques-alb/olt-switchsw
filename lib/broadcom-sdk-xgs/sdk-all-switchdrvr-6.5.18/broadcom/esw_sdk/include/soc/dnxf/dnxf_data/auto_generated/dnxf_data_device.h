/** \file dnxf_data_device.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNXF_DATA_DEVICE_H_
/*{*/
#define _DNXF_DATA_DEVICE_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/property.h>
#include <sal/limits.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnxf/dnxf_data/dnxf_data_verify.h>
#include <soc/chip.h>
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_max_device.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNXF_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnxf_data_if_device
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_if_device_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - GENERAL:
 * General attributes
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_general_feature_nof
} dnxf_data_device_general_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_general_feature_get_f) (
    int unit,
    dnxf_data_device_general_feature_e feature);

/**
 * \brief returns define data of nof_pvt_monitors
 * Module - 'device', Submodule - 'general', data - 'nof_pvt_monitors'
 * Number of device PVT monitors
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pvt_monitors - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_nof_pvt_monitors_get_f) (
    int unit);

/**
 * \brief returns define data of pvt_base
 * Module - 'device', Submodule - 'general', data - 'pvt_base'
 * PVT base. Used for correct calculation of the monitor readings
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pvt_base - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_general_pvt_base_get_f) (
    int unit);

/**
 * \brief returns define data of pvt_factor
 * Module - 'device', Submodule - 'general', data - 'pvt_factor'
 * PVT factor Used for correct calculation of the monitor readings
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pvt_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_general_pvt_factor_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cores
 * Module - 'device', Submodule - 'general', data - 'nof_cores'
 * Number of cores in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cores - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_nof_cores_get_f) (
    int unit);

/**
 * \brief returns numeric data of hard_reset_disable
 * Module - 'device', Submodule - 'general', data - 'hard_reset_disable'
 * Init device without hard reset.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hard_reset_disable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_hard_reset_disable_get_f) (
    int unit);

/**
 * \brief returns numeric data of core_clock_khz
 * Module - 'device', Submodule - 'general', data - 'core_clock_khz'
 * Specifies system core clock speed in kHz.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     core_clock_khz - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_core_clock_khz_get_f) (
    int unit);

/**
 * \brief returns numeric data of system_ref_core_clock_khz
 * Module - 'device', Submodule - 'general', data - 'system_ref_core_clock_khz'
 * Specifies system reference clock speed in kHz.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     system_ref_core_clock_khz - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_system_ref_core_clock_khz_get_f) (
    int unit);

/**
 * \brief returns numeric data of device_id
 * Module - 'device', Submodule - 'general', data - 'device_id'
 * BCM Device ID (8XXX)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     device_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_device_id_get_f) (
    int unit);

/**
 * \brief returns numeric data of emulation_system
 * Module - 'device', Submodule - 'general', data - 'emulation_system'
 * Checking if the device is ran on emulation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     emulation_system - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_emulation_system_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - GENERAL:
 * {
 */
/**
 * \brief Interface for device general data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_general_feature_get_f feature_get;
    /**
     * returns define data of nof_pvt_monitors
     */
    dnxf_data_device_general_nof_pvt_monitors_get_f nof_pvt_monitors_get;
    /**
     * returns define data of pvt_base
     */
    dnxf_data_device_general_pvt_base_get_f pvt_base_get;
    /**
     * returns define data of pvt_factor
     */
    dnxf_data_device_general_pvt_factor_get_f pvt_factor_get;
    /**
     * returns define data of nof_cores
     */
    dnxf_data_device_general_nof_cores_get_f nof_cores_get;
    /**
     * returns numeric data of hard_reset_disable
     */
    dnxf_data_device_general_hard_reset_disable_get_f hard_reset_disable_get;
    /**
     * returns numeric data of core_clock_khz
     */
    dnxf_data_device_general_core_clock_khz_get_f core_clock_khz_get;
    /**
     * returns numeric data of system_ref_core_clock_khz
     */
    dnxf_data_device_general_system_ref_core_clock_khz_get_f system_ref_core_clock_khz_get;
    /**
     * returns numeric data of device_id
     */
    dnxf_data_device_general_device_id_get_f device_id_get;
    /**
     * returns numeric data of emulation_system
     */
    dnxf_data_device_general_emulation_system_get_f emulation_system_get;
} dnxf_data_if_device_general_t;

/*
 * }
 */

/*
 * SUBMODULE  - ACCESS:
 * General access attributes
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_access_feature_nof
} dnxf_data_device_access_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_access_feature_get_f) (
    int unit,
    dnxf_data_device_access_feature_e feature);

/**
 * \brief returns numeric data of table_dma_enable
 * Module - 'device', Submodule - 'access', data - 'table_dma_enable'
 * Enable/disable table DMA operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_dma_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_table_dma_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of tdma_timeout_usec
 * Module - 'device', Submodule - 'access', data - 'tdma_timeout_usec'
 * Table DMA operation timeout.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdma_timeout_usec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_tdma_timeout_usec_get_f) (
    int unit);

/**
 * \brief returns numeric data of tdma_intr_enable
 * Module - 'device', Submodule - 'access', data - 'tdma_intr_enable'
 * Table DMA done is interrupt driven or by polling.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdma_intr_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_tdma_intr_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of tslam_dma_enable
 * Module - 'device', Submodule - 'access', data - 'tslam_dma_enable'
 * Enable/disable tslam DMA operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_dma_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_tslam_dma_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of tslam_timeout_usec
 * Module - 'device', Submodule - 'access', data - 'tslam_timeout_usec'
 * Tslam DMA operation timeout.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_timeout_usec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_tslam_timeout_usec_get_f) (
    int unit);

/**
 * \brief returns numeric data of tslam_int_enable
 * Module - 'device', Submodule - 'access', data - 'tslam_int_enable'
 * Tslam DMA done is interrupt driven or by polling.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_int_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_tslam_int_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of mdio_int_divisor
 * Module - 'device', Submodule - 'access', data - 'mdio_int_divisor'
 * mdio_int_divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_int_divisor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_mdio_int_divisor_get_f) (
    int unit);

/**
 * \brief returns numeric data of mdio_ext_divisor
 * Module - 'device', Submodule - 'access', data - 'mdio_ext_divisor'
 * mdio_ext_divisor.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_ext_divisor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_mdio_ext_divisor_get_f) (
    int unit);

/**
 * \brief returns numeric data of mdio_int_div_out_delay
 * Module - 'device', Submodule - 'access', data - 'mdio_int_div_out_delay'
 * number of clock delay between the rising edge of MDC and the starting data of MDIO for internal divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_int_div_out_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_mdio_int_div_out_delay_get_f) (
    int unit);

/**
 * \brief returns numeric data of mdio_ext_div_out_delay
 * Module - 'device', Submodule - 'access', data - 'mdio_ext_div_out_delay'
 * number of clock delay between the rising edge of MDC and the starting data of MDIO for external divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_ext_div_out_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_mdio_ext_div_out_delay_get_f) (
    int unit);

/**
 * \brief returns numeric data of bist_enable
 * Module - 'device', Submodule - 'access', data - 'bist_enable'
 * Determines if to run Memory Built-In Self-Test (MBIST) of internal memory (tables) during startup.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bist_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_bist_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of sbus_dma_interval
 * Module - 'device', Submodule - 'access', data - 'sbus_dma_interval'
 * sbus DMA operation interval.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbus_dma_interval - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_sbus_dma_interval_get_f) (
    int unit);

/**
 * \brief returns numeric data of sbus_dma_intr_enable
 * Module - 'device', Submodule - 'access', data - 'sbus_dma_intr_enable'
 * sbus DMA interrupt enable.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbus_dma_intr_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_sbus_dma_intr_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of mem_clear_chunk_size
 * Module - 'device', Submodule - 'access', data - 'mem_clear_chunk_size'
 * sbus DMA chunk size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mem_clear_chunk_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_mem_clear_chunk_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - ACCESS:
 * {
 */
/**
 * \brief Interface for device access data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_access_feature_get_f feature_get;
    /**
     * returns numeric data of table_dma_enable
     */
    dnxf_data_device_access_table_dma_enable_get_f table_dma_enable_get;
    /**
     * returns numeric data of tdma_timeout_usec
     */
    dnxf_data_device_access_tdma_timeout_usec_get_f tdma_timeout_usec_get;
    /**
     * returns numeric data of tdma_intr_enable
     */
    dnxf_data_device_access_tdma_intr_enable_get_f tdma_intr_enable_get;
    /**
     * returns numeric data of tslam_dma_enable
     */
    dnxf_data_device_access_tslam_dma_enable_get_f tslam_dma_enable_get;
    /**
     * returns numeric data of tslam_timeout_usec
     */
    dnxf_data_device_access_tslam_timeout_usec_get_f tslam_timeout_usec_get;
    /**
     * returns numeric data of tslam_int_enable
     */
    dnxf_data_device_access_tslam_int_enable_get_f tslam_int_enable_get;
    /**
     * returns numeric data of mdio_int_divisor
     */
    dnxf_data_device_access_mdio_int_divisor_get_f mdio_int_divisor_get;
    /**
     * returns numeric data of mdio_ext_divisor
     */
    dnxf_data_device_access_mdio_ext_divisor_get_f mdio_ext_divisor_get;
    /**
     * returns numeric data of mdio_int_div_out_delay
     */
    dnxf_data_device_access_mdio_int_div_out_delay_get_f mdio_int_div_out_delay_get;
    /**
     * returns numeric data of mdio_ext_div_out_delay
     */
    dnxf_data_device_access_mdio_ext_div_out_delay_get_f mdio_ext_div_out_delay_get;
    /**
     * returns numeric data of bist_enable
     */
    dnxf_data_device_access_bist_enable_get_f bist_enable_get;
    /**
     * returns numeric data of sbus_dma_interval
     */
    dnxf_data_device_access_sbus_dma_interval_get_f sbus_dma_interval_get;
    /**
     * returns numeric data of sbus_dma_intr_enable
     */
    dnxf_data_device_access_sbus_dma_intr_enable_get_f sbus_dma_intr_enable_get;
    /**
     * returns numeric data of mem_clear_chunk_size
     */
    dnxf_data_device_access_mem_clear_chunk_size_get_f mem_clear_chunk_size_get;
} dnxf_data_if_device_access_t;

/*
 * }
 */

/*
 * SUBMODULE  - BLOCKS:
 * General block information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule blocks table override
 * Table info:
 * blocks enable/disable override
 */
typedef struct
{
    /**
     * See soc_block_type_t
     */
    char *block_type;
    /**
     * instance ID within block type
     */
    int block_instance;
    /**
     * The value to override
     */
    int value;
} dnxf_data_device_blocks_override_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_blocks_feature_nof
} dnxf_data_device_blocks_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_blocks_feature_get_f) (
    int unit,
    dnxf_data_device_blocks_feature_e feature);

/**
 * \brief returns define data of nof_all_blocks
 * Module - 'device', Submodule - 'blocks', data - 'nof_all_blocks'
 * Number of block instances in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_all_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_all_blocks_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_fmac
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_fmac'
 * Number of FMAC instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_fmac - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_fmac_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_fmac
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_fmac'
 * Number of links for each FMAC block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_fmac - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_fmac_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_fsrd'
 * Number of FSRD instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_fsrd_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fsrd'
 * Number of BRoaDCast FSRD instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_brdc_fsrd_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_dch
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_dch'
 * Number of DCH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_dch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_dch_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_dch
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dch'
 * Number of links for each DCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_dch_get_f) (
    int unit);

/**
 * \brief returns define data of nof_dch_link_groups
 * Module - 'device', Submodule - 'blocks', data - 'nof_dch_link_groups'
 * Number of link groups for each DCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dch_link_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_dch_link_groups_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_cch
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_cch'
 * Number of CCH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_cch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_cch_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_cch
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_cch'
 * Number of links for each CCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_cch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_cch_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_dcq
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dcq'
 * Number of links for each DCQ block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dcq - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_dcq_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_rtp
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_rtp'
 * Number of RTP instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_rtp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_rtp_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_occg
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_occg'
 * Number of OCCG instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_occg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_occg_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_eci
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_eci'
 * Number of ECI instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_eci - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_eci_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_cmic
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_cmic'
 * Number of CMIC instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_cmic - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_cmic_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_mesh_topology
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_mesh_topology'
 * Number of MESH Topology instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_mesh_topology - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_mesh_topology_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_otpc
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_otpc'
 * Number of OTPC instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_otpc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_otpc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fmach
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fmach'
 * Number of BRoaDCast FMACH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fmach - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_brdc_fmach_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fmacl
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fmacl'
 * Number of BRoaDCast FMACL instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fmacl - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_brdc_fmacl_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fmac_ac
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fmac_ac'
 * Number of BRoaDCast FMAC_AC instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fmac_ac - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_brdc_fmac_ac_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fmac_bd
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fmac_bd'
 * Number of BRoaDCast FMAC_BD instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fmac_bd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_brdc_fmac_bd_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_dch
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_dch'
 * Number of BRoaDCast DCH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_dch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_brdc_dch_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_dcml
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_dcml'
 * Number of BRoaDCast DCML instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_dcml - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_brdc_dcml_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_lcm
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_lcm'
 * Number of LCM instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_lcm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_lcm_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_mct
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_mct'
 * Number of MCT instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_mct - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_mct_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_qrh
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_qrh'
 * Number of QRH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_qrh - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_qrh_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_dcml
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_dcml'
 * Number of DCML instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_dcml - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_dcml_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_dcml
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dcml'
 * Number of links for each DCML block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dcml - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_dcml_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_lcm
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_lcm'
 * Number of links for each LCM block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_lcm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_lcm_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_qrh
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_qrh'
 * Number of links for each QRH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_qrh - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_qrh_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qrh_mclbt_instances
 * Module - 'device', Submodule - 'blocks', data - 'nof_qrh_mclbt_instances'
 * Number of QRH MCLBT instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qrh_mclbt_instances - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_qrh_mclbt_instances_get_f) (
    int unit);

/**
 * \brief returns define data of nof_dtm_fifos
 * Module - 'device', Submodule - 'blocks', data - 'nof_dtm_fifos'
 * Number of FIFOs for each DTM block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dtm_fifos - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_dtm_fifos_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_fsrd'
 * Number of links for each FSRD block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_fsrd_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_phy_core
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_phy_core'
 * Number of links in each PHY core.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_phy_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_phy_core_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fmacs_in_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_fmacs_in_fsrd'
 * Number of FMAC blocks for each FSRD block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fmacs_in_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_fmacs_in_fsrd_get_f) (
    int unit);

/**
 * \brief get table override entry 
 * blocks enable/disable override
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     override - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_override_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_device_blocks_override_t *(
    *dnxf_data_device_blocks_override_get_f) (
    int unit,
    int index);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - BLOCKS:
 * {
 */
/**
 * \brief Interface for device blocks data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_blocks_feature_get_f feature_get;
    /**
     * returns define data of nof_all_blocks
     */
    dnxf_data_device_blocks_nof_all_blocks_get_f nof_all_blocks_get;
    /**
     * returns define data of nof_instances_fmac
     */
    dnxf_data_device_blocks_nof_instances_fmac_get_f nof_instances_fmac_get;
    /**
     * returns define data of nof_links_in_fmac
     */
    dnxf_data_device_blocks_nof_links_in_fmac_get_f nof_links_in_fmac_get;
    /**
     * returns define data of nof_instances_fsrd
     */
    dnxf_data_device_blocks_nof_instances_fsrd_get_f nof_instances_fsrd_get;
    /**
     * returns define data of nof_instances_brdc_fsrd
     */
    dnxf_data_device_blocks_nof_instances_brdc_fsrd_get_f nof_instances_brdc_fsrd_get;
    /**
     * returns define data of nof_instances_dch
     */
    dnxf_data_device_blocks_nof_instances_dch_get_f nof_instances_dch_get;
    /**
     * returns define data of nof_links_in_dch
     */
    dnxf_data_device_blocks_nof_links_in_dch_get_f nof_links_in_dch_get;
    /**
     * returns define data of nof_dch_link_groups
     */
    dnxf_data_device_blocks_nof_dch_link_groups_get_f nof_dch_link_groups_get;
    /**
     * returns define data of nof_instances_cch
     */
    dnxf_data_device_blocks_nof_instances_cch_get_f nof_instances_cch_get;
    /**
     * returns define data of nof_links_in_cch
     */
    dnxf_data_device_blocks_nof_links_in_cch_get_f nof_links_in_cch_get;
    /**
     * returns define data of nof_links_in_dcq
     */
    dnxf_data_device_blocks_nof_links_in_dcq_get_f nof_links_in_dcq_get;
    /**
     * returns define data of nof_instances_rtp
     */
    dnxf_data_device_blocks_nof_instances_rtp_get_f nof_instances_rtp_get;
    /**
     * returns define data of nof_instances_occg
     */
    dnxf_data_device_blocks_nof_instances_occg_get_f nof_instances_occg_get;
    /**
     * returns define data of nof_instances_eci
     */
    dnxf_data_device_blocks_nof_instances_eci_get_f nof_instances_eci_get;
    /**
     * returns define data of nof_instances_cmic
     */
    dnxf_data_device_blocks_nof_instances_cmic_get_f nof_instances_cmic_get;
    /**
     * returns define data of nof_instances_mesh_topology
     */
    dnxf_data_device_blocks_nof_instances_mesh_topology_get_f nof_instances_mesh_topology_get;
    /**
     * returns define data of nof_instances_otpc
     */
    dnxf_data_device_blocks_nof_instances_otpc_get_f nof_instances_otpc_get;
    /**
     * returns define data of nof_instances_brdc_fmach
     */
    dnxf_data_device_blocks_nof_instances_brdc_fmach_get_f nof_instances_brdc_fmach_get;
    /**
     * returns define data of nof_instances_brdc_fmacl
     */
    dnxf_data_device_blocks_nof_instances_brdc_fmacl_get_f nof_instances_brdc_fmacl_get;
    /**
     * returns define data of nof_instances_brdc_fmac_ac
     */
    dnxf_data_device_blocks_nof_instances_brdc_fmac_ac_get_f nof_instances_brdc_fmac_ac_get;
    /**
     * returns define data of nof_instances_brdc_fmac_bd
     */
    dnxf_data_device_blocks_nof_instances_brdc_fmac_bd_get_f nof_instances_brdc_fmac_bd_get;
    /**
     * returns define data of nof_instances_brdc_dch
     */
    dnxf_data_device_blocks_nof_instances_brdc_dch_get_f nof_instances_brdc_dch_get;
    /**
     * returns define data of nof_instances_brdc_dcml
     */
    dnxf_data_device_blocks_nof_instances_brdc_dcml_get_f nof_instances_brdc_dcml_get;
    /**
     * returns define data of nof_instances_lcm
     */
    dnxf_data_device_blocks_nof_instances_lcm_get_f nof_instances_lcm_get;
    /**
     * returns define data of nof_instances_mct
     */
    dnxf_data_device_blocks_nof_instances_mct_get_f nof_instances_mct_get;
    /**
     * returns define data of nof_instances_qrh
     */
    dnxf_data_device_blocks_nof_instances_qrh_get_f nof_instances_qrh_get;
    /**
     * returns define data of nof_instances_dcml
     */
    dnxf_data_device_blocks_nof_instances_dcml_get_f nof_instances_dcml_get;
    /**
     * returns define data of nof_links_in_dcml
     */
    dnxf_data_device_blocks_nof_links_in_dcml_get_f nof_links_in_dcml_get;
    /**
     * returns define data of nof_links_in_lcm
     */
    dnxf_data_device_blocks_nof_links_in_lcm_get_f nof_links_in_lcm_get;
    /**
     * returns define data of nof_links_in_qrh
     */
    dnxf_data_device_blocks_nof_links_in_qrh_get_f nof_links_in_qrh_get;
    /**
     * returns define data of nof_qrh_mclbt_instances
     */
    dnxf_data_device_blocks_nof_qrh_mclbt_instances_get_f nof_qrh_mclbt_instances_get;
    /**
     * returns define data of nof_dtm_fifos
     */
    dnxf_data_device_blocks_nof_dtm_fifos_get_f nof_dtm_fifos_get;
    /**
     * returns define data of nof_links_in_fsrd
     */
    dnxf_data_device_blocks_nof_links_in_fsrd_get_f nof_links_in_fsrd_get;
    /**
     * returns define data of nof_links_in_phy_core
     */
    dnxf_data_device_blocks_nof_links_in_phy_core_get_f nof_links_in_phy_core_get;
    /**
     * returns define data of nof_fmacs_in_fsrd
     */
    dnxf_data_device_blocks_nof_fmacs_in_fsrd_get_f nof_fmacs_in_fsrd_get;
    /**
     * get table override entry 
     */
    dnxf_data_device_blocks_override_get_f override_get;
    /**
     * get general info table about table (for example key size)override info
     */
    dnxc_data_table_info_get_f override_info_get;
} dnxf_data_if_device_blocks_t;

/*
 * }
 */

/*
 * SUBMODULE  - INTERRUPTS:
 * General interrupts information
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_interrupts_feature_nof
} dnxf_data_device_interrupts_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_interrupts_feature_get_f) (
    int unit,
    dnxf_data_device_interrupts_feature_e feature);

/**
 * \brief returns numeric data of nof_interrupts
 * Module - 'device', Submodule - 'interrupts', data - 'nof_interrupts'
 * Number of interrupts.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_interrupts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_interrupts_nof_interrupts_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - INTERRUPTS:
 * {
 */
/**
 * \brief Interface for device interrupts data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_interrupts_feature_get_f feature_get;
    /**
     * returns numeric data of nof_interrupts
     */
    dnxf_data_device_interrupts_nof_interrupts_get_f nof_interrupts_get;
} dnxf_data_if_device_interrupts_t;

/*
 * }
 */

/*
 * SUBMODULE  - CUSTOM_FEATURES:
 * Custom features
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_custom_features_feature_nof
} dnxf_data_device_custom_features_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_custom_features_feature_get_f) (
    int unit,
    dnxf_data_device_custom_features_feature_e feature);

/**
 * \brief returns numeric data of mesh_topology_fast
 * Module - 'device', Submodule - 'custom_features', data - 'mesh_topology_fast'
 * Device is in mesh topology fast mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mesh_topology_fast - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_custom_features_mesh_topology_fast_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - CUSTOM_FEATURES:
 * {
 */
/**
 * \brief Interface for device custom_features data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_custom_features_feature_get_f feature_get;
    /**
     * returns numeric data of mesh_topology_fast
     */
    dnxf_data_device_custom_features_mesh_topology_fast_get_f mesh_topology_fast_get;
} dnxf_data_if_device_custom_features_t;

/*
 * }
 */

/*
 * SUBMODULE  - PROPERTIES:
 * used to store information related to soc properties
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule properties table unsupported
 * Table info:
 * unsupported soc properties
 */
typedef struct
{
    /**
     * soc property name
     */
    char *property;
    
    char *suffix;
    /**
     * max number of index to check in case using suffix_num method
     */
    int num_max;
    /**
     * 1 if the soc property might be read per port
     */
    int per_port;
    /**
     * detailed error message with instructions what to do instead
     */
    char *err_msg;
} dnxf_data_device_properties_unsupported_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_properties_feature_nof
} dnxf_data_device_properties_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_properties_feature_get_f) (
    int unit,
    dnxf_data_device_properties_feature_e feature);

/**
 * \brief get table unsupported entry 
 * unsupported soc properties
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     unsupported - returns the relevant entry values grouped in struct - see dnxf_data_device_properties_unsupported_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_device_properties_unsupported_t *(
    *dnxf_data_device_properties_unsupported_get_f) (
    int unit,
    int index);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - PROPERTIES:
 * {
 */
/**
 * \brief Interface for device properties data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_properties_feature_get_f feature_get;
    /**
     * get table unsupported entry 
     */
    dnxf_data_device_properties_unsupported_get_f unsupported_get;
    /**
     * get general info table about table (for example key size)unsupported info
     */
    dnxc_data_table_info_get_f unsupported_info_get;
} dnxf_data_if_device_properties_t;

/*
 * }
 */

/*
 * SUBMODULE  - HA:
 * values for sw state and high availability init
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_ha_feature_nof
} dnxf_data_device_ha_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_ha_feature_get_f) (
    int unit,
    dnxf_data_device_ha_feature_e feature);

/**
 * \brief returns numeric data of warmboot_support
 * Module - 'device', Submodule - 'ha', data - 'warmboot_support'
 * specify if unit should support wb
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     warmboot_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_ha_warmboot_support_get_f) (
    int unit);

/**
 * \brief returns numeric data of sw_state_max_size
 * Module - 'device', Submodule - 'ha', data - 'sw_state_max_size'
 * specify the amount of memory (in bytes) preallocated for sw state
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sw_state_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_ha_sw_state_max_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - HA:
 * {
 */
/**
 * \brief Interface for device ha data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_ha_feature_get_f feature_get;
    /**
     * returns numeric data of warmboot_support
     */
    dnxf_data_device_ha_warmboot_support_get_f warmboot_support_get;
    /**
     * returns numeric data of sw_state_max_size
     */
    dnxf_data_device_ha_sw_state_max_size_get_f sw_state_max_size_get;
} dnxf_data_if_device_ha_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNXF_DATA_IF_DEVICE:
 * {
 */
/**
 * \brief Interface for device data
 */
typedef struct
{
    /**
     * Interface for device general data
     */
    dnxf_data_if_device_general_t general;
    /**
     * Interface for device access data
     */
    dnxf_data_if_device_access_t access;
    /**
     * Interface for device blocks data
     */
    dnxf_data_if_device_blocks_t blocks;
    /**
     * Interface for device interrupts data
     */
    dnxf_data_if_device_interrupts_t interrupts;
    /**
     * Interface for device custom_features data
     */
    dnxf_data_if_device_custom_features_t custom_features;
    /**
     * Interface for device properties data
     */
    dnxf_data_if_device_properties_t properties;
    /**
     * Interface for device ha data
     */
    dnxf_data_if_device_ha_t ha;
} dnxf_data_if_device_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnxf_data_if_device_t dnxf_data_device;
/*
 * }
 */
/*}*/
#endif /*_DNXF_DATA_DEVICE_H_*/
/* *INDENT-ON* */
