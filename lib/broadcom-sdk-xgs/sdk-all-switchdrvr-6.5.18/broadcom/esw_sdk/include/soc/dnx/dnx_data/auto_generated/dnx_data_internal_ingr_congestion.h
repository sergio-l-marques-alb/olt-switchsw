/** \file dnx_data_internal_ingr_congestion.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_INGR_CONGESTION_H_
/*{*/
#define _DNX_DATA_INTERNAL_INGR_CONGESTION_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_ingr_congestion.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_ingr_congestion_submodule_config,
    dnx_data_ingr_congestion_submodule_info,
    dnx_data_ingr_congestion_submodule_fadt_tail_drop,
    dnx_data_ingr_congestion_submodule_dram_bound,
    dnx_data_ingr_congestion_submodule_voq,
    dnx_data_ingr_congestion_submodule_vsq,
    dnx_data_ingr_congestion_submodule_init,
    dnx_data_ingr_congestion_submodule_dbal,
    dnx_data_ingr_congestion_submodule_mirror_on_drop,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_submodule_nof
} dnx_data_ingr_congestion_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE CONFIG:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_ingr_congestion_config_feature_get(
    int unit,
    dnx_data_ingr_congestion_config_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_ingr_congestion_config_define_guarantee_mode,
    dnx_data_ingr_congestion_config_define_wred_packet_size,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_config_define_nof
} dnx_data_ingr_congestion_config_define_e;

/* Get Data */
/**
 * \brief returns numeric data of guarantee_mode
 * Module - 'ingr_congestion', Submodule - 'config', data - 'guarantee_mode'
 * guarantee mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     guarantee_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_config_guarantee_mode_get(
    int unit);

/**
 * \brief returns numeric data of wred_packet_size
 * Module - 'ingr_congestion', Submodule - 'config', data - 'wred_packet_size'
 * max packet size used in WRED parameters computation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wred_packet_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_config_wred_packet_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_config_table_nof
} dnx_data_ingr_congestion_config_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE INFO:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_ingr_congestion_info_feature_get(
    int unit,
    dnx_data_ingr_congestion_info_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_ingr_congestion_info_define_threshold_granularity,
    dnx_data_ingr_congestion_info_define_words_resolution,
    dnx_data_ingr_congestion_info_define_bytes_threshold_granularity,
    dnx_data_ingr_congestion_info_define_nof_dropped_reasons_cgm,
    dnx_data_ingr_congestion_info_define_wred_max_gain,
    dnx_data_ingr_congestion_info_define_wred_granularity,
    dnx_data_ingr_congestion_info_define_nof_pds_in_pdb,
    dnx_data_ingr_congestion_info_define_max_sram_pdbs,
    dnx_data_ingr_congestion_info_define_max_dram_bdbs,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_info_define_nof
} dnx_data_ingr_congestion_info_define_e;

/* Get Data */
/**
 * \brief returns define data of threshold_granularity
 * Module - 'ingr_congestion', Submodule - 'info', data - 'threshold_granularity'
 * Granularity (non bytes) thresholds are written to HW with
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     threshold_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_info_threshold_granularity_get(
    int unit);

/**
 * \brief returns define data of words_resolution
 * Module - 'ingr_congestion', Submodule - 'info', data - 'words_resolution'
 * Size of each HW word in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     words_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_info_words_resolution_get(
    int unit);

/**
 * \brief returns define data of bytes_threshold_granularity
 * Module - 'ingr_congestion', Submodule - 'info', data - 'bytes_threshold_granularity'
 * Granularity bytes thresholds are written to HW with
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bytes_threshold_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_info_bytes_threshold_granularity_get(
    int unit);

/**
 * \brief returns define data of nof_dropped_reasons_cgm
 * Module - 'ingr_congestion', Submodule - 'info', data - 'nof_dropped_reasons_cgm'
 * number of reasons for the dropped packets in CGM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dropped_reasons_cgm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_info_nof_dropped_reasons_cgm_get(
    int unit);

/**
 * \brief returns define data of wred_max_gain
 * Module - 'ingr_congestion', Submodule - 'info', data - 'wred_max_gain'
 * maximal allowed value of gain for WRED
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wred_max_gain - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_info_wred_max_gain_get(
    int unit);

/**
 * \brief returns define data of wred_granularity
 * Module - 'ingr_congestion', Submodule - 'info', data - 'wred_granularity'
 * granularity of WRED parameters for coefficient calculation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wred_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_info_wred_granularity_get(
    int unit);

/**
 * \brief returns define data of nof_pds_in_pdb
 * Module - 'ingr_congestion', Submodule - 'info', data - 'nof_pds_in_pdb'
 * number of SRAM PDs in PDB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pds_in_pdb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_info_nof_pds_in_pdb_get(
    int unit);

/**
 * \brief returns numeric data of max_sram_pdbs
 * Module - 'ingr_congestion', Submodule - 'info', data - 'max_sram_pdbs'
 * Maximal number of SRAM PDBS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_sram_pdbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_info_max_sram_pdbs_get(
    int unit);

/**
 * \brief returns numeric data of max_dram_bdbs
 * Module - 'ingr_congestion', Submodule - 'info', data - 'max_dram_bdbs'
 * Maximal number of DRAM BDBS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_dram_bdbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_info_max_dram_bdbs_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_ingr_congestion_info_table_resource,
    dnx_data_ingr_congestion_info_table_dp_free_res_presentage_drop,
    dnx_data_ingr_congestion_info_table_admission_preferences,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_info_table_nof
} dnx_data_ingr_congestion_info_table_e;

/* Get Data */
/**
 * \brief get table resource entry 
 * Resource Size - per resource
 * 
 * \param [in] unit - unit #
 * \param [in] type - resource type
 * 
 * \return
 *     resource - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_info_resource_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_info_resource_t * dnx_data_ingr_congestion_info_resource_get(
    int unit,
    int type);

/**
 * \brief get table dp_free_res_presentage_drop entry 
 * Amount of free resource precntage to cause drop per DP
 * 
 * \param [in] unit - unit #
 * \param [in] dp - DP (0-3). 0=Green, 1=Yellow, 2=Red, 3=Black
 * 
 * \return
 *     dp_free_res_presentage_drop - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t * dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_get(
    int unit,
    int dp);

/**
 * \brief get table admission_preferences entry 
 * admission preferences (admit/guaranteed) per DP.
 * 
 * \param [in] unit - unit #
 * \param [in] dp - DP (0-3). 0=Green, 1=Yellow, 2=Red, 3=Black
 * 
 * \return
 *     admission_preferences - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_info_admission_preferences_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_info_admission_preferences_t * dnx_data_ingr_congestion_info_admission_preferences_get(
    int unit,
    int dp);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'info', table - 'resource'
 * Resource Size - per resource
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_info_resource_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'info', table - 'dp_free_res_presentage_drop'
 * Amount of free resource precntage to cause drop per DP
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'info', table - 'admission_preferences'
 * admission preferences (admit/guaranteed) per DP.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_info_admission_preferences_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)resource info
 * Resource Size - per resource
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     resource - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_info_resource_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dp_free_res_presentage_drop info
 * Amount of free resource precntage to cause drop per DP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dp_free_res_presentage_drop - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)admission_preferences info
 * admission preferences (admit/guaranteed) per DP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     admission_preferences - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_info_admission_preferences_info_get(
    int unit);

/*
 * SUBMODULE FADT_TAIL_DROP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_ingr_congestion_fadt_tail_drop_feature_get(
    int unit,
    dnx_data_ingr_congestion_fadt_tail_drop_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_ingr_congestion_fadt_tail_drop_define_default_max_size_byte_threshold_for_ocb_only,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_fadt_tail_drop_define_nof
} dnx_data_ingr_congestion_fadt_tail_drop_define_e;

/* Get Data */
/**
 * \brief returns numeric data of default_max_size_byte_threshold_for_ocb_only
 * Module - 'ingr_congestion', Submodule - 'fadt_tail_drop', data - 'default_max_size_byte_threshold_for_ocb_only'
 * Default for max size threshold for byte resource when rate class is OCB only
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_max_size_byte_threshold_for_ocb_only - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_fadt_tail_drop_default_max_size_byte_threshold_for_ocb_only_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_fadt_tail_drop_table_nof
} dnx_data_ingr_congestion_fadt_tail_drop_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE DRAM_BOUND:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_ingr_congestion_dram_bound_feature_get(
    int unit,
    dnx_data_ingr_congestion_dram_bound_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_ingr_congestion_dram_bound_define_fadt_alpha_min,
    dnx_data_ingr_congestion_dram_bound_define_fadt_alpha_max,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_dram_bound_define_nof
} dnx_data_ingr_congestion_dram_bound_define_e;

/* Get Data */
/**
 * \brief returns define data of fadt_alpha_min
 * Module - 'ingr_congestion', Submodule - 'dram_bound', data - 'fadt_alpha_min'
 * min value for fadt dram thresholds
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fadt_alpha_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dram_bound_fadt_alpha_min_get(
    int unit);

/**
 * \brief returns define data of fadt_alpha_max
 * Module - 'ingr_congestion', Submodule - 'dram_bound', data - 'fadt_alpha_max'
 * max value for fadt dram thresholds
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fadt_alpha_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dram_bound_fadt_alpha_max_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_ingr_congestion_dram_bound_table_resource,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_dram_bound_table_nof
} dnx_data_ingr_congestion_dram_bound_table_e;

/* Get Data */
/**
 * \brief get table resource entry 
 * DRAM Resource info per resource
 * 
 * \param [in] unit - unit #
 * \param [in] type - resource type
 * 
 * \return
 *     resource - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_dram_bound_resource_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_dram_bound_resource_t * dnx_data_ingr_congestion_dram_bound_resource_get(
    int unit,
    int type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'dram_bound', table - 'resource'
 * DRAM Resource info per resource
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_dram_bound_resource_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)resource info
 * DRAM Resource info per resource
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     resource - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_dram_bound_resource_info_get(
    int unit);

/*
 * SUBMODULE VOQ:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_ingr_congestion_voq_feature_get(
    int unit,
    dnx_data_ingr_congestion_voq_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_ingr_congestion_voq_define_nof_rate_class,
    dnx_data_ingr_congestion_voq_define_rate_class_nof_bits,
    dnx_data_ingr_congestion_voq_define_nof_compensation_profiles,
    dnx_data_ingr_congestion_voq_define_default_compensation,
    dnx_data_ingr_congestion_voq_define_latency_bins,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_voq_define_nof
} dnx_data_ingr_congestion_voq_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_rate_class
 * Module - 'ingr_congestion', Submodule - 'voq', data - 'nof_rate_class'
 * number of VOQ rate classes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rate_class - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_voq_nof_rate_class_get(
    int unit);

/**
 * \brief returns define data of rate_class_nof_bits
 * Module - 'ingr_congestion', Submodule - 'voq', data - 'rate_class_nof_bits'
 * number of bits in VOQ rate class
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rate_class_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_voq_rate_class_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_compensation_profiles
 * Module - 'ingr_congestion', Submodule - 'voq', data - 'nof_compensation_profiles'
 * number of VOQ compensation profiles. used for voq compensation calculation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compensation_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_voq_nof_compensation_profiles_get(
    int unit);

/**
 * \brief returns define data of default_compensation
 * Module - 'ingr_congestion', Submodule - 'voq', data - 'default_compensation'
 * set to eth compensation (Preamable + IFG + CRC)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_compensation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_voq_default_compensation_get(
    int unit);

/**
 * \brief returns define data of latency_bins
 * Module - 'ingr_congestion', Submodule - 'voq', data - 'latency_bins'
 * number of latency admission VOQ ranges
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     latency_bins - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_voq_latency_bins_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_voq_table_nof
} dnx_data_ingr_congestion_voq_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE VSQ:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_ingr_congestion_vsq_feature_get(
    int unit,
    dnx_data_ingr_congestion_vsq_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_ingr_congestion_vsq_define_vsq_rate_class_nof,
    dnx_data_ingr_congestion_vsq_define_vsq_a_rate_class_nof,
    dnx_data_ingr_congestion_vsq_define_vsq_a_nof,
    dnx_data_ingr_congestion_vsq_define_vsq_b_nof,
    dnx_data_ingr_congestion_vsq_define_vsq_c_nof,
    dnx_data_ingr_congestion_vsq_define_vsq_d_nof,
    dnx_data_ingr_congestion_vsq_define_vsq_e_nof,
    dnx_data_ingr_congestion_vsq_define_vsq_e_hw_nof,
    dnx_data_ingr_congestion_vsq_define_vsq_f_nof,
    dnx_data_ingr_congestion_vsq_define_vsq_f_hw_nof,
    dnx_data_ingr_congestion_vsq_define_nif_vsq_e_nof,
    dnx_data_ingr_congestion_vsq_define_non_nif_vsq_f_nof,
    dnx_data_ingr_congestion_vsq_define_pool_nof,
    dnx_data_ingr_congestion_vsq_define_connection_class_nof,
    dnx_data_ingr_congestion_vsq_define_tc_pg_profile_nof,
    dnx_data_ingr_congestion_vsq_define_vsq_e_default,
    dnx_data_ingr_congestion_vsq_define_vsq_f_default,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_vsq_define_nof
} dnx_data_ingr_congestion_vsq_define_e;

/* Get Data */
/**
 * \brief returns define data of vsq_rate_class_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_rate_class_nof'
 * Number of VSQ rate classes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_rate_class_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_rate_class_nof_get(
    int unit);

/**
 * \brief returns define data of vsq_a_rate_class_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_a_rate_class_nof'
 * Number of VSQ-A rate classes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_a_rate_class_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_a_rate_class_nof_get(
    int unit);

/**
 * \brief returns define data of vsq_a_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_a_nof'
 * Number of VSQ-A
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_a_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_a_nof_get(
    int unit);

/**
 * \brief returns define data of vsq_b_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_b_nof'
 * Number of VSQ-B
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_b_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_b_nof_get(
    int unit);

/**
 * \brief returns define data of vsq_c_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_c_nof'
 * Number of VSQ-C
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_c_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_c_nof_get(
    int unit);

/**
 * \brief returns define data of vsq_d_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_d_nof'
 * Number of VSQ-D
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_d_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_d_nof_get(
    int unit);

/**
 * \brief returns define data of vsq_e_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_e_nof'
 * Number of VSQ-E
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_e_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_e_nof_get(
    int unit);

/**
 * \brief returns define data of vsq_e_hw_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_e_hw_nof'
 * Number of VSQ-E in HW, including reserved VSQ-E
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_e_hw_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_e_hw_nof_get(
    int unit);

/**
 * \brief returns define data of vsq_f_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_f_nof'
 * Number of VSQ-F
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_f_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_f_nof_get(
    int unit);

/**
 * \brief returns define data of vsq_f_hw_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_f_hw_nof'
 * Number of VSQ-F in HW, including reserved VSQ-F
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_f_hw_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_f_hw_nof_get(
    int unit);

/**
 * \brief returns define data of nif_vsq_e_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'nif_vsq_e_nof'
 * Number of VSQ-E on NIF ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_vsq_e_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_nif_vsq_e_nof_get(
    int unit);

/**
 * \brief returns define data of non_nif_vsq_f_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'non_nif_vsq_f_nof'
 * Number of VSQ-F on non NIF ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     non_nif_vsq_f_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_non_nif_vsq_f_nof_get(
    int unit);

/**
 * \brief returns define data of pool_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'pool_nof'
 * Number of resource pools
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pool_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_pool_nof_get(
    int unit);

/**
 * \brief returns define data of connection_class_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'connection_class_nof'
 * Number of connection classes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     connection_class_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_connection_class_nof_get(
    int unit);

/**
 * \brief returns define data of tc_pg_profile_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'tc_pg_profile_nof'
 * Number of tc->pg profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tc_pg_profile_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_tc_pg_profile_nof_get(
    int unit);

/**
 * \brief returns numeric data of vsq_e_default
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_e_default'
 * Default mapping of VSQ-E
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_e_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_e_default_get(
    int unit);

/**
 * \brief returns numeric data of vsq_f_default
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_f_default'
 * Default mapping of VSQ-F
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_f_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_vsq_vsq_f_default_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_ingr_congestion_vsq_table_info,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_vsq_table_nof
} dnx_data_ingr_congestion_vsq_table_e;

/* Get Data */
/**
 * \brief get table info entry 
 * General VSQ info
 * 
 * \param [in] unit - unit #
 * \param [in] vsq_group - vsq_group id as in enum SOC_DNX_ITM_VSQ_GROUP.
 * 
 * \return
 *     info - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_vsq_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_vsq_info_t * dnx_data_ingr_congestion_vsq_info_get(
    int unit,
    int vsq_group);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'vsq', table - 'info'
 * General VSQ info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_vsq_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)info info
 * General VSQ info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_vsq_info_info_get(
    int unit);

/*
 * SUBMODULE INIT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_ingr_congestion_init_feature_get(
    int unit,
    dnx_data_ingr_congestion_init_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_ingr_congestion_init_define_fifo_size,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_init_define_nof
} dnx_data_ingr_congestion_init_define_e;

/* Get Data */
/**
 * \brief returns define data of fifo_size
 * Module - 'ingr_congestion', Submodule - 'init', data - 'fifo_size'
 * size of each tar fifo
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fifo_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_init_fifo_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_ingr_congestion_init_table_vsq_words_rjct_map,
    dnx_data_ingr_congestion_init_table_vsq_sram_rjct_map,
    dnx_data_ingr_congestion_init_table_dp_global_sram_buffer_drop,
    dnx_data_ingr_congestion_init_table_dp_global_sram_pdb_drop,
    dnx_data_ingr_congestion_init_table_dp_global_dram_bdb_drop,
    dnx_data_ingr_congestion_init_table_equivalent_global_drop,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_init_table_nof
} dnx_data_ingr_congestion_init_table_e;

/* Get Data */
/**
 * \brief get table vsq_words_rjct_map entry 
 * initialization info for VSQ words reject map - defines combinations which should be turn on
 * 
 * \param [in] unit - unit #
 * \param [in] index - arbitrary index
 * 
 * \return
 *     vsq_words_rjct_map - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_vsq_words_rjct_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_init_vsq_words_rjct_map_t * dnx_data_ingr_congestion_init_vsq_words_rjct_map_get(
    int unit,
    int index);

/**
 * \brief get table vsq_sram_rjct_map entry 
 * initialization info for VSQ SRAM reject map - defines combinations which should be turn on
 * 
 * \param [in] unit - unit #
 * \param [in] index - arbitrary index
 * 
 * \return
 *     vsq_sram_rjct_map - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t * dnx_data_ingr_congestion_init_vsq_sram_rjct_map_get(
    int unit,
    int index);

/**
 * \brief get table dp_global_sram_buffer_drop entry 
 * Amount of free sram buffer resource to cause drop per DP
 * 
 * \param [in] unit - unit #
 * \param [in] dp - DP (0-3).
 * 
 * \return
 *     dp_global_sram_buffer_drop - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t * dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_get(
    int unit,
    int dp);

/**
 * \brief get table dp_global_sram_pdb_drop entry 
 * Amount of free sram pdb resource to cause drop per DP
 * 
 * \param [in] unit - unit #
 * \param [in] dp - DP (0-3).
 * 
 * \return
 *     dp_global_sram_pdb_drop - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t * dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_get(
    int unit,
    int dp);

/**
 * \brief get table dp_global_dram_bdb_drop entry 
 * Amount of free dram bdb resource to cause drop per DP
 * 
 * \param [in] unit - unit #
 * \param [in] dp - DP (0-3).
 * 
 * \return
 *     dp_global_dram_bdb_drop - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t * dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_get(
    int unit,
    int dp);

/**
 * \brief get table equivalent_global_drop entry 
 * Equavalent amount per VOQ resource to per-DP global drop (not configurable by user)
 * 
 * \param [in] unit - unit #
 * \param [in] type - VOQ resource
 * 
 * \return
 *     equivalent_global_drop - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_equivalent_global_drop_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_init_equivalent_global_drop_t * dnx_data_ingr_congestion_init_equivalent_global_drop_get(
    int unit,
    int type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'init', table - 'vsq_words_rjct_map'
 * initialization info for VSQ words reject map - defines combinations which should be turn on
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_init_vsq_words_rjct_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'init', table - 'vsq_sram_rjct_map'
 * initialization info for VSQ SRAM reject map - defines combinations which should be turn on
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_init_vsq_sram_rjct_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'init', table - 'dp_global_sram_buffer_drop'
 * Amount of free sram buffer resource to cause drop per DP
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'init', table - 'dp_global_sram_pdb_drop'
 * Amount of free sram pdb resource to cause drop per DP
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'init', table - 'dp_global_dram_bdb_drop'
 * Amount of free dram bdb resource to cause drop per DP
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'init', table - 'equivalent_global_drop'
 * Equavalent amount per VOQ resource to per-DP global drop (not configurable by user)
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_init_equivalent_global_drop_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)vsq_words_rjct_map info
 * initialization info for VSQ words reject map - defines combinations which should be turn on
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_words_rjct_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_init_vsq_words_rjct_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)vsq_sram_rjct_map info
 * initialization info for VSQ SRAM reject map - defines combinations which should be turn on
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_sram_rjct_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_init_vsq_sram_rjct_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dp_global_sram_buffer_drop info
 * Amount of free sram buffer resource to cause drop per DP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dp_global_sram_buffer_drop - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dp_global_sram_pdb_drop info
 * Amount of free sram pdb resource to cause drop per DP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dp_global_sram_pdb_drop - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dp_global_dram_bdb_drop info
 * Amount of free dram bdb resource to cause drop per DP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dp_global_dram_bdb_drop - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)equivalent_global_drop info
 * Equavalent amount per VOQ resource to per-DP global drop (not configurable by user)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     equivalent_global_drop - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_init_equivalent_global_drop_info_get(
    int unit);

/*
 * SUBMODULE DBAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_ingr_congestion_dbal_feature_get(
    int unit,
    dnx_data_ingr_congestion_dbal_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_ingr_congestion_dbal_define_admission_test_nof,
    dnx_data_ingr_congestion_dbal_define_dram_bdbs_th_nof_bits,
    dnx_data_ingr_congestion_dbal_define_sram_pdbs_th_nof_bits,
    dnx_data_ingr_congestion_dbal_define_sram_buffer_th_nof_bits,
    dnx_data_ingr_congestion_dbal_define_sram_buffer_free_th_nof_bits,
    dnx_data_ingr_congestion_dbal_define_sram_pds_th_nof_bits,
    dnx_data_ingr_congestion_dbal_define_total_bytes_th_nof_bits,
    dnx_data_ingr_congestion_dbal_define_dram_bdbs_nof_bits,
    dnx_data_ingr_congestion_dbal_define_sram_pdbs_nof_bits,
    dnx_data_ingr_congestion_dbal_define_sram_buffer_nof_bits,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_dbal_define_nof
} dnx_data_ingr_congestion_dbal_define_e;

/* Get Data */
/**
 * \brief returns numeric data of admission_test_nof
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'admission_test_nof'
 * Number of admission test
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     admission_test_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dbal_admission_test_nof_get(
    int unit);

/**
 * \brief returns numeric data of dram_bdbs_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'dram_bdbs_th_nof_bits'
 * Number of bits dram bdbs set/clear threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_bdbs_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dbal_dram_bdbs_th_nof_bits_get(
    int unit);

/**
 * \brief returns numeric data of sram_pdbs_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_pdbs_th_nof_bits'
 * Number of bits sram pdbs set/clear threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_pdbs_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dbal_sram_pdbs_th_nof_bits_get(
    int unit);

/**
 * \brief returns numeric data of sram_buffer_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_buffer_th_nof_bits'
 * Number of bits sram buffer set/clear threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_buffer_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dbal_sram_buffer_th_nof_bits_get(
    int unit);

/**
 * \brief returns numeric data of sram_buffer_free_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_buffer_free_th_nof_bits'
 * Number of bits sram buffer set/clear threshold for reaching full size of the resource
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_buffer_free_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dbal_sram_buffer_free_th_nof_bits_get(
    int unit);

/**
 * \brief returns numeric data of sram_pds_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_pds_th_nof_bits'
 * Number of bits sram PDs set/clear threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_pds_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dbal_sram_pds_th_nof_bits_get(
    int unit);

/**
 * \brief returns numeric data of total_bytes_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'total_bytes_th_nof_bits'
 * Number of bits total bytes set/clear threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_bytes_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dbal_total_bytes_th_nof_bits_get(
    int unit);

/**
 * \brief returns numeric data of dram_bdbs_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'dram_bdbs_nof_bits'
 * Number of bits for dram bdbs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_bdbs_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dbal_dram_bdbs_nof_bits_get(
    int unit);

/**
 * \brief returns numeric data of sram_pdbs_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_pdbs_nof_bits'
 * Number of bits for sram pdbs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_pdbs_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dbal_sram_pdbs_nof_bits_get(
    int unit);

/**
 * \brief returns numeric data of sram_buffer_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_buffer_nof_bits'
 * Number of bits for sram buffer
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_buffer_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_dbal_sram_buffer_nof_bits_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_ingr_congestion_dbal_table_admission_bits_mapping,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_dbal_table_nof
} dnx_data_ingr_congestion_dbal_table_e;

/* Get Data */
/**
 * \brief get table admission_bits_mapping entry 
 * Mapping of bits in addmission mask
 * 
 * \param [in] unit - unit #
 * \param [in] rjct_bit - admission bit - defined by dnx_ingress_congestion_reject_bit_e
 * 
 * \return
 *     admission_bits_mapping - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_dbal_admission_bits_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_ingr_congestion_dbal_admission_bits_mapping_t * dnx_data_ingr_congestion_dbal_admission_bits_mapping_get(
    int unit,
    int rjct_bit);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'ingr_congestion', Submodule - 'dbal', table - 'admission_bits_mapping'
 * Mapping of bits in addmission mask
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_dbal_admission_bits_mapping_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)admission_bits_mapping info
 * Mapping of bits in addmission mask
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     admission_bits_mapping - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_ingr_congestion_dbal_admission_bits_mapping_info_get(
    int unit);

/*
 * SUBMODULE MIRROR_ON_DROP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_ingr_congestion_mirror_on_drop_feature_get(
    int unit,
    dnx_data_ingr_congestion_mirror_on_drop_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_ingr_congestion_mirror_on_drop_define_nof_groups,
    dnx_data_ingr_congestion_mirror_on_drop_define_aging_clocks_resolution,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_mirror_on_drop_define_nof
} dnx_data_ingr_congestion_mirror_on_drop_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_groups
 * Module - 'ingr_congestion', Submodule - 'mirror_on_drop', data - 'nof_groups'
 * number of drop groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_mirror_on_drop_nof_groups_get(
    int unit);

/**
 * \brief returns define data of aging_clocks_resolution
 * Module - 'ingr_congestion', Submodule - 'mirror_on_drop', data - 'aging_clocks_resolution'
 * resolution of aging clock cycles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aging_clocks_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_ingr_congestion_mirror_on_drop_aging_clocks_resolution_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_mirror_on_drop_table_nof
} dnx_data_ingr_congestion_mirror_on_drop_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_ingr_congestion_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_INGR_CONGESTION_H_*/
/* *INDENT-ON* */
