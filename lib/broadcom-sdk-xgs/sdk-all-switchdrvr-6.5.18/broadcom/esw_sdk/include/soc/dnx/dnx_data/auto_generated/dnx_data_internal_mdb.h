/** \file dnx_data_internal_mdb.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_MDB_H_
/*{*/
#define _DNX_DATA_INTERNAL_MDB_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_mdb.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_mdb_submodule_global,
    dnx_data_mdb_submodule_dh,
    dnx_data_mdb_submodule_pdbs,
    dnx_data_mdb_submodule_em,
    dnx_data_mdb_submodule_direct,
    dnx_data_mdb_submodule_eedb,
    dnx_data_mdb_submodule_kaps,
    dnx_data_mdb_submodule_hw_bug,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_submodule_nof
} dnx_data_mdb_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE GLOBAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_global_feature_get(
    int unit,
    dnx_data_mdb_global_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_global_define_nof
} dnx_data_mdb_global_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_global_table_nof
} dnx_data_mdb_global_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE DH:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_dh_feature_get(
    int unit,
    dnx_data_mdb_dh_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_dh_define_nof_macroes_type_A,
    dnx_data_mdb_dh_define_nof_macroes_type_B,
    dnx_data_mdb_dh_define_total_nof_macroes,
    dnx_data_mdb_dh_define_total_nof_macroes_plus_em_ovf_or_eedb_bank,
    dnx_data_mdb_dh_define_total_nof_macroes_plus_data_width,
    dnx_data_mdb_dh_define_max_nof_cluster_interfaces,
    dnx_data_mdb_dh_define_nof_macro_clusters,
    dnx_data_mdb_dh_define_nof_bucket_clusters,
    dnx_data_mdb_dh_define_nof_buckets_in_macro,
    dnx_data_mdb_dh_define_nof_pair_clusters,
    dnx_data_mdb_dh_define_nof_bits_address_in_macro_a_cluster,
    dnx_data_mdb_dh_define_nof_bits_address_in_macro_b_cluster,
    dnx_data_mdb_dh_define_nof_rows_in_macro_a_cluster,
    dnx_data_mdb_dh_define_nof_rows_in_macro_b_cluster,
    dnx_data_mdb_dh_define_nof_rows_in_eedb_bank,
    dnx_data_mdb_dh_define_nof_data_rows_per_hitbit_row,
    dnx_data_mdb_dh_define_nof_rows_in_eedb_hitbit_bank,
    dnx_data_mdb_dh_define_cluster_row_width_bits,
    dnx_data_mdb_dh_define_has_dhc_type_blocks,
    dnx_data_mdb_dh_define_data_out_granularity,
    dnx_data_mdb_dh_define_bpu_setup_bb_connected,
    dnx_data_mdb_dh_define_bpu_setup_size_120_240_120,
    dnx_data_mdb_dh_define_bpu_setup_size_480_odd,
    dnx_data_mdb_dh_define_bpu_setup_size_480,
    dnx_data_mdb_dh_define_bpu_setup_size_360_120,
    dnx_data_mdb_dh_define_bpu_setup_size_120_360,
    dnx_data_mdb_dh_define_bpu_setup_size_240_240,
    dnx_data_mdb_dh_define_bpu_setup_size_120_120_240,
    dnx_data_mdb_dh_define_bpu_setup_size_240_120_120,
    dnx_data_mdb_dh_define_bpu_setup_size_120_120_120_120,
    dnx_data_mdb_dh_define_ddha_dynamic_memory_access_dpc,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_dh_define_nof
} dnx_data_mdb_dh_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_macroes_type_A
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macroes_type_A'
 * The NOF type A macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macroes_type_A - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_macroes_type_A_get(
    int unit);

/**
 * \brief returns define data of nof_macroes_type_B
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macroes_type_B'
 * The NOF type B macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macroes_type_B - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_macroes_type_B_get(
    int unit);

/**
 * \brief returns define data of total_nof_macroes
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes'
 * the total NOF macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_total_nof_macroes_get(
    int unit);

/**
 * \brief returns define data of total_nof_macroes_plus_em_ovf_or_eedb_bank
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes_plus_em_ovf_or_eedb_bank'
 * the total NOF macroes in the device plus another place for either the OVF buffer for EM tables or banks for EEDB tables.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes_plus_em_ovf_or_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_total_nof_macroes_plus_em_ovf_or_eedb_bank_get(
    int unit);

/**
 * \brief returns define data of total_nof_macroes_plus_data_width
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes_plus_data_width'
 * he total NOF macroes in the device plus another place for the data width.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes_plus_data_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_total_nof_macroes_plus_data_width_get(
    int unit);

/**
 * \brief returns define data of max_nof_cluster_interfaces
 * Module - 'mdb', Submodule - 'dh', data - 'max_nof_cluster_interfaces'
 * max NOF interfaces that can be associated with a single cluster.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_cluster_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_max_nof_cluster_interfaces_get(
    int unit);

/**
 * \brief returns define data of nof_macro_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macro_clusters'
 * nof clusters in a single macro.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macro_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_macro_clusters_get(
    int unit);

/**
 * \brief returns define data of nof_bucket_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_bucket_clusters'
 * nof clusters in a a bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bucket_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_bucket_clusters_get(
    int unit);

/**
 * \brief returns define data of nof_buckets_in_macro
 * Module - 'mdb', Submodule - 'dh', data - 'nof_buckets_in_macro'
 * The NOF buckets in a macro
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_buckets_in_macro - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_buckets_in_macro_get(
    int unit);

/**
 * \brief returns define data of nof_pair_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_pair_clusters'
 * nof clusters in a pair.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pair_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_pair_clusters_get(
    int unit);

/**
 * \brief returns define data of nof_bits_address_in_macro_a_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_bits_address_in_macro_a_cluster'
 * NOF bits needed for a cluster A address.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_address_in_macro_a_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_bits_address_in_macro_a_cluster_get(
    int unit);

/**
 * \brief returns define data of nof_bits_address_in_macro_b_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_bits_address_in_macro_b_cluster'
 * NOF bits needed for a cluster B address.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_address_in_macro_b_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_bits_address_in_macro_b_cluster_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_macro_a_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_macro_a_cluster'
 * NOF rows in a cluster that is places on a macro of type A.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_macro_a_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_rows_in_macro_a_cluster_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_macro_b_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_macro_b_cluster'
 * NOF rows in a cluster that is places on a macro of type B.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_macro_b_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_rows_in_macro_b_cluster_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_eedb_bank
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_eedb_bank'
 * NOF rows in an EEDB bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_rows_in_eedb_bank_get(
    int unit);

/**
 * \brief returns define data of nof_data_rows_per_hitbit_row
 * Module - 'mdb', Submodule - 'dh', data - 'nof_data_rows_per_hitbit_row'
 * How many eedb rows each hitbit row is mapped to
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_data_rows_per_hitbit_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_data_rows_per_hitbit_row_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_eedb_hitbit_bank
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_eedb_hitbit_bank'
 * How many rows in each eedb hitbit bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_eedb_hitbit_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_rows_in_eedb_hitbit_bank_get(
    int unit);

/**
 * \brief returns define data of cluster_row_width_bits
 * Module - 'mdb', Submodule - 'dh', data - 'cluster_row_width_bits'
 * NOF bits in a single cluster row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cluster_row_width_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_cluster_row_width_bits_get(
    int unit);

/**
 * \brief returns define data of has_dhc_type_blocks
 * Module - 'mdb', Submodule - 'dh', data - 'has_dhc_type_blocks'
 * This device uses DHC types blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     has_dhc_type_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_has_dhc_type_blocks_get(
    int unit);

/**
 * \brief returns define data of data_out_granularity
 * Module - 'mdb', Submodule - 'dh', data - 'data_out_granularity'
 * The granularity used for data out.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_out_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_data_out_granularity_get(
    int unit);

/**
 * \brief returns define data of bpu_setup_bb_connected
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_bb_connected'
 * If set, the two buckets are connected, also known as J2 960 mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_bb_connected - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_bpu_setup_bb_connected_get(
    int unit);

/**
 * \brief returns define data of bpu_setup_size_120_240_120
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_120_240_120'
 * The BPU setup size associated with 120_240_120 bucket allocation, requires extended.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_120_240_120 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_bpu_setup_size_120_240_120_get(
    int unit);

/**
 * \brief returns define data of bpu_setup_size_480_odd
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_480_odd'
 * The BPU setup size associated with 480_odd bucket allocation, the odd is used to distinguish between buckets in case of 960 allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_480_odd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_bpu_setup_size_480_odd_get(
    int unit);

/**
 * \brief returns define data of bpu_setup_size_480
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_480'
 * The BPU setup size associated with 480 bucket allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_480 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_bpu_setup_size_480_get(
    int unit);

/**
 * \brief returns define data of bpu_setup_size_360_120
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_360_120'
 * The BPU setup size associated with 360_120 bucket allocation, requires extended.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_360_120 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_bpu_setup_size_360_120_get(
    int unit);

/**
 * \brief returns define data of bpu_setup_size_120_360
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_120_360'
 * The BPU setup size associated with 120_360 bucket allocation, requires extended.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_120_360 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_bpu_setup_size_120_360_get(
    int unit);

/**
 * \brief returns define data of bpu_setup_size_240_240
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_240_240'
 * The BPU setup size associated with 240_240 bucket allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_240_240 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_bpu_setup_size_240_240_get(
    int unit);

/**
 * \brief returns define data of bpu_setup_size_120_120_240
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_120_120_240'
 * The BPU setup size associated with 120_120_240 bucket allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_120_120_240 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_bpu_setup_size_120_120_240_get(
    int unit);

/**
 * \brief returns define data of bpu_setup_size_240_120_120
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_240_120_120'
 * The BPU setup size associated with 240_120_120 bucket allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_240_120_120 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_bpu_setup_size_240_120_120_get(
    int unit);

/**
 * \brief returns define data of bpu_setup_size_120_120_120_120
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_120_120_120_120'
 * The BPU setup size associated with 120_120_120_120 bucket allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_120_120_120_120 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_bpu_setup_size_120_120_120_120_get(
    int unit);

/**
 * \brief returns define data of ddha_dynamic_memory_access_dpc
 * Module - 'mdb', Submodule - 'dh', data - 'ddha_dynamic_memory_access_dpc'
 * The DDHA dynamic memory is of DPC type.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ddha_dynamic_memory_access_dpc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_ddha_dynamic_memory_access_dpc_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_mdb_dh_table_dh_info,
    dnx_data_mdb_dh_table_macro_interface_mapping,
    dnx_data_mdb_dh_table_table_way_to_macro_mapping,
    dnx_data_mdb_dh_table_block_info,
    dnx_data_mdb_dh_table_mdb_75_macro_halved,
    dnx_data_mdb_dh_table_entry_banks_info,
    dnx_data_mdb_dh_table_mdb_1_info,
    dnx_data_mdb_dh_table_mdb_2_info,
    dnx_data_mdb_dh_table_mdb_3_info,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_dh_table_nof
} dnx_data_mdb_dh_table_e;

/* Get Data */
/**
 * \brief get table dh_info entry 
 * general information of the MDB data handlers
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table_id - MDB physical DB.
 * 
 * \return
 *     dh_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_dh_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_dh_info_t * dnx_data_mdb_dh_dh_info_get(
    int unit,
    int mdb_table_id);

/**
 * \brief get table macro_interface_mapping entry 
 * The available interfaces for each macro
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     macro_interface_mapping - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_macro_interface_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_macro_interface_mapping_t * dnx_data_mdb_dh_macro_interface_mapping_get(
    int unit,
    int global_macro_index);

/**
 * \brief get table table_way_to_macro_mapping entry 
 * Maps from table way to global macro index, this is the reverse mapping of dh_info->table_macro_interface_mapping
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table_id - MDB physical DB.
 * 
 * \return
 *     table_way_to_macro_mapping - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_table_way_to_macro_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_table_way_to_macro_mapping_t * dnx_data_mdb_dh_table_way_to_macro_mapping_get(
    int unit,
    int mdb_table_id);

/**
 * \brief get table block_info entry 
 * holds the DH blocks information.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     block_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_block_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_block_info_t * dnx_data_mdb_dh_block_info_get(
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_75_macro_halved entry 
 * holds the mdb_75 macro information.
 * 
 * \param [in] unit - unit #
 * \param [in] macro_index - macro A index
 * 
 * \return
 *     mdb_75_macro_halved - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_75_macro_halved_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_mdb_75_macro_halved_t * dnx_data_mdb_dh_mdb_75_macro_halved_get(
    int unit,
    int macro_index);

/**
 * \brief get table entry_banks_info entry 
 * holds the DHs entry banks and ABK banks information.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     entry_banks_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_entry_banks_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_entry_banks_info_t * dnx_data_mdb_dh_entry_banks_info_get(
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_1_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - no description.
 * 
 * \return
 *     mdb_1_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_1_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_mdb_1_info_t * dnx_data_mdb_dh_mdb_1_info_get(
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_2_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - no description.
 * 
 * \return
 *     mdb_2_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_2_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_mdb_2_info_t * dnx_data_mdb_dh_mdb_2_info_get(
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_3_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - no description.
 * 
 * \return
 *     mdb_3_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_3_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_mdb_3_info_t * dnx_data_mdb_dh_mdb_3_info_get(
    int unit,
    int global_macro_index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'dh_info'
 * general information of the MDB data handlers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_dh_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'macro_interface_mapping'
 * The available interfaces for each macro
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_macro_interface_mapping_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'table_way_to_macro_mapping'
 * Maps from table way to global macro index, this is the reverse mapping of dh_info->table_macro_interface_mapping
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_table_way_to_macro_mapping_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'block_info'
 * holds the DH blocks information.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_block_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'mdb_75_macro_halved'
 * holds the mdb_75 macro information.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_mdb_75_macro_halved_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'entry_banks_info'
 * holds the DHs entry banks and ABK banks information.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_entry_banks_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'mdb_1_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_mdb_1_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'mdb_2_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_mdb_2_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'mdb_3_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_mdb_3_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)dh_info info
 * general information of the MDB data handlers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dh_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_dh_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)macro_interface_mapping info
 * The available interfaces for each macro
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     macro_interface_mapping - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_macro_interface_mapping_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)table_way_to_macro_mapping info
 * Maps from table way to global macro index, this is the reverse mapping of dh_info->table_macro_interface_mapping
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_way_to_macro_mapping - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_table_way_to_macro_mapping_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)block_info info
 * holds the DH blocks information.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     block_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_block_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_75_macro_halved info
 * holds the mdb_75 macro information.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_75_macro_halved - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_mdb_75_macro_halved_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)entry_banks_info info
 * holds the DHs entry banks and ABK banks information.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_banks_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_entry_banks_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_1_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_1_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_mdb_1_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_2_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_2_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_mdb_2_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_3_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_3_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_mdb_3_info_info_get(
    int unit);

/*
 * SUBMODULE PDBS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_pdbs_feature_get(
    int unit,
    dnx_data_mdb_pdbs_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_pdbs_define_max_nof_interface_dhs,
    dnx_data_mdb_pdbs_define_kaps_nof_blocks,
    dnx_data_mdb_pdbs_define_mesh_mode_support,
    dnx_data_mdb_pdbs_define_max_key_size,
    dnx_data_mdb_pdbs_define_max_payload_size,
    dnx_data_mdb_pdbs_define_table_mdb_9_mdb_item_1_array_size,
    dnx_data_mdb_pdbs_define_table_mdb_9_mdb_item_2_array_size,
    dnx_data_mdb_pdbs_define_table_mdb_9_mdb_item_3_array_size,
    dnx_data_mdb_pdbs_define_table_mdb_40_mdb_item_0_array_size,
    dnx_data_mdb_pdbs_define_table_mdb_dynamic_memory_access_memory_access_field_size,
    dnx_data_mdb_pdbs_define_table_mdb_mact_dynamic_memory_access_memory_access_field_size,
    dnx_data_mdb_pdbs_define_table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size,
    dnx_data_mdb_pdbs_define_table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size,
    dnx_data_mdb_pdbs_define_table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size,
    dnx_data_mdb_pdbs_define_table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size,
    dnx_data_mdb_pdbs_define_table_mdb_ddhb_dynamic_memory_access_memory_access_field_size,
    dnx_data_mdb_pdbs_define_mdb_nof_profiles,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_pdbs_define_nof
} dnx_data_mdb_pdbs_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_interface_dhs
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_nof_interface_dhs'
 * Max nof different DHs that can be associated with a single interface
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_interface_dhs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_max_nof_interface_dhs_get(
    int unit);

/**
 * \brief returns define data of kaps_nof_blocks
 * Module - 'mdb', Submodule - 'pdbs', data - 'kaps_nof_blocks'
 * NOF KPAS blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kaps_nof_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_kaps_nof_blocks_get(
    int unit);

/**
 * \brief returns define data of mesh_mode_support
 * Module - 'mdb', Submodule - 'pdbs', data - 'mesh_mode_support'
 * Indicate if the device support mesh mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mesh_mode_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_mesh_mode_support_get(
    int unit);

/**
 * \brief returns define data of max_key_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_key_size'
 * The largest key size from all the PDBs key sizes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_max_key_size_get(
    int unit);

/**
 * \brief returns define data of max_payload_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_payload_size'
 * The largest payload size from all the PDBs payloads sizes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_max_payload_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_1_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_1_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_1_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_9_mdb_item_1_array_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_2_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_2_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_2_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_9_mdb_item_2_array_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_3_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_3_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_3_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_9_mdb_item_3_array_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_40_mdb_item_0_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_40_mdb_item_0_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_40_mdb_item_0_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_40_mdb_item_0_array_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_dynamic_memory_access_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_dynamic_memory_access_memory_access_field_size'
 * The MDB dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_dynamic_memory_access_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_dynamic_memory_access_memory_access_field_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_mact_dynamic_memory_access_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_mact_dynamic_memory_access_memory_access_field_size'
 * The MACT dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_mact_dynamic_memory_access_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_mact_dynamic_memory_access_memory_access_field_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size'
 * The KAPS SBC dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size'
 * The KAPS DPC dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size'
 * The DDHA SBC dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size'
 * The DDHA DPC dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_ddhb_dynamic_memory_access_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_ddhb_dynamic_memory_access_memory_access_field_size'
 * The DDHB dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_ddhb_dynamic_memory_access_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_ddhb_dynamic_memory_access_memory_access_field_size_get(
    int unit);

/**
 * \brief returns define data of mdb_nof_profiles
 * Module - 'mdb', Submodule - 'pdbs', data - 'mdb_nof_profiles'
 * The global number of supported MDB profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_nof_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_mdb_nof_profiles_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_mdb_pdbs_table_mdb_profile,
    dnx_data_mdb_pdbs_table_mdb_profiles_info,
    dnx_data_mdb_pdbs_table_mdb_profile_kaps_cfg,
    dnx_data_mdb_pdbs_table_pdbs_info,
    dnx_data_mdb_pdbs_table_pdb_info,
    dnx_data_mdb_pdbs_table_mdb_11_info,
    dnx_data_mdb_pdbs_table_mdb_12_info,
    dnx_data_mdb_pdbs_table_mdb_26_info,
    dnx_data_mdb_pdbs_table_mdb_adapter_mapping,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_pdbs_table_nof
} dnx_data_mdb_pdbs_table_e;

/* Get Data */
/**
 * \brief get table mdb_profile entry 
 * MDB profile SoC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_profile - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_profile_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_mdb_profile_t * dnx_data_mdb_pdbs_mdb_profile_get(
    int unit);

/**
 * \brief get table mdb_profiles_info entry 
 * MDB info per profile
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_profile_index - The MDB profile index, iterated on using mdb_nof_profiles.
 * 
 * \return
 *     mdb_profiles_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_profiles_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_mdb_profiles_info_t * dnx_data_mdb_pdbs_mdb_profiles_info_get(
    int unit,
    int mdb_profile_index);

/**
 * \brief get table mdb_profile_kaps_cfg entry 
 * KAPS database configuration based on the MDB profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_profile_kaps_cfg - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_profile_kaps_cfg_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_mdb_profile_kaps_cfg_t * dnx_data_mdb_pdbs_mdb_profile_kaps_cfg_get(
    int unit);

/**
 * \brief get table pdbs_info entry 
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table_id - MDB physical DB.
 * 
 * \return
 *     pdbs_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_pdbs_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_pdbs_info_t * dnx_data_mdb_pdbs_pdbs_info_get(
    int unit,
    int mdb_table_id);

/**
 * \brief get table pdb_info entry 
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB
 * 
 * \return
 *     pdb_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_pdb_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_pdb_info_t * dnx_data_mdb_pdbs_pdb_info_get(
    int unit,
    int dbal_id);

/**
 * \brief get table mdb_11_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_11_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_11_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_mdb_11_info_t * dnx_data_mdb_pdbs_mdb_11_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_12_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_12_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_12_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_mdb_12_info_t * dnx_data_mdb_pdbs_mdb_12_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_26_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_26_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_26_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_mdb_26_info_t * dnx_data_mdb_pdbs_mdb_26_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_adapter_mapping entry 
 * Mapping between DBAL MDB physical tables and adapter memory IDs.
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - DBAL MDB physical table
 * 
 * \return
 *     mdb_adapter_mapping - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_adapter_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_mdb_adapter_mapping_t * dnx_data_mdb_pdbs_mdb_adapter_mapping_get(
    int unit,
    int dbal_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'mdb_profile'
 * MDB profile SoC property
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_mdb_profile_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'mdb_profiles_info'
 * MDB info per profile
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_mdb_profiles_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'mdb_profile_kaps_cfg'
 * KAPS database configuration based on the MDB profile
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_mdb_profile_kaps_cfg_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'pdbs_info'
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_pdbs_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'pdb_info'
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_pdb_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'mdb_11_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_mdb_11_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'mdb_12_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_mdb_12_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'mdb_26_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_mdb_26_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'mdb_adapter_mapping'
 * Mapping between DBAL MDB physical tables and adapter memory IDs.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_mdb_adapter_mapping_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)mdb_profile info
 * MDB profile SoC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_profile - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_mdb_profile_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_profiles_info info
 * MDB info per profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_profiles_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_mdb_profiles_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_profile_kaps_cfg info
 * KAPS database configuration based on the MDB profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_profile_kaps_cfg - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_mdb_profile_kaps_cfg_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)pdbs_info info
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pdbs_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_pdbs_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)pdb_info info
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pdb_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_pdb_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_11_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_11_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_mdb_11_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_12_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_12_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_mdb_12_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_26_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_26_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_mdb_26_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_adapter_mapping info
 * Mapping between DBAL MDB physical tables and adapter memory IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_adapter_mapping - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_mdb_adapter_mapping_info_get(
    int unit);

/*
 * SUBMODULE EM:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_em_feature_get(
    int unit,
    dnx_data_mdb_em_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_em_define_total_nof_lem_aging_bits,
    dnx_data_mdb_em_define_total_nof_exem_aging_bits,
    dnx_data_mdb_em_define_age_row_size_bits,
    dnx_data_mdb_em_define_age_ovfcam_row_size_bits,
    dnx_data_mdb_em_define_age_entry_size_bits,
    dnx_data_mdb_em_define_ovf_cam_max_size,
    dnx_data_mdb_em_define_age_support_per_entry_size_ratio,
    dnx_data_mdb_em_define_nof_aging_profiles,
    dnx_data_mdb_em_define_aging_profiles_size_in_bits,
    dnx_data_mdb_em_define_max_tid_size,
    dnx_data_mdb_em_define_max_nof_tids,
    dnx_data_mdb_em_define_flush_support_tids,
    dnx_data_mdb_em_define_flush_max_supported_key,
    dnx_data_mdb_em_define_flush_max_supported_payload,
    dnx_data_mdb_em_define_flush_max_supported_key_plus_payload,
    dnx_data_mdb_em_define_dh_120_entry_encoding_nof_bits,
    dnx_data_mdb_em_define_dh_240_entry_encoding_nof_bits,
    dnx_data_mdb_em_define_format_granularity,
    dnx_data_mdb_em_define_max_nof_vmv_size,
    dnx_data_mdb_em_define_vmv_nof_values,
    dnx_data_mdb_em_define_nof_vmv_size_nof_bits,
    dnx_data_mdb_em_define_esem_nof_vmv_size,
    dnx_data_mdb_em_define_glem_nof_vmv_size,
    dnx_data_mdb_em_define_mact_nof_vmv_size,
    dnx_data_mdb_em_define_mact_max_payload_size,
    dnx_data_mdb_em_define_shift_vmv_max_size,
    dnx_data_mdb_em_define_shift_vmv_max_regs_per_table,
    dnx_data_mdb_em_define_min_nof_app_id_bits,
    dnx_data_mdb_em_define_max_nof_spn_sizes,
    dnx_data_mdb_em_define_nof_lfsr_sizes,
    dnx_data_mdb_em_define_nof_formats,
    dnx_data_mdb_em_define_defragmentation_priority_supported,
    dnx_data_mdb_em_define_disable_cuckoo_loop_detection_support,
    dnx_data_mdb_em_define_disable_cuckoo_hit_bit_sync,
    dnx_data_mdb_em_define_age_profile_per_ratio_support,
    dnx_data_mdb_em_define_flex_mag_supported,
    dnx_data_mdb_em_define_flex_fully_supported,
    dnx_data_mdb_em_define_step_table_max_size,
    dnx_data_mdb_em_define_nof_encoding_values,
    dnx_data_mdb_em_define_nof_encoding_types,
    dnx_data_mdb_em_define_extra_vmv_shift_registers,
    dnx_data_mdb_em_define_interrupt_register,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_em_define_nof
} dnx_data_mdb_em_define_e;

/* Get Data */
/**
 * \brief returns define data of total_nof_lem_aging_bits
 * Module - 'mdb', Submodule - 'em', data - 'total_nof_lem_aging_bits'
 * The total number of bits available for the LEM aging.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_lem_aging_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_total_nof_lem_aging_bits_get(
    int unit);

/**
 * \brief returns define data of total_nof_exem_aging_bits
 * Module - 'mdb', Submodule - 'em', data - 'total_nof_exem_aging_bits'
 * The total number of bits available for the EXEM aging.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_exem_aging_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_total_nof_exem_aging_bits_get(
    int unit);

/**
 * \brief returns define data of age_row_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_row_size_bits'
 * The number of bits in a single aging memory row
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_row_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_age_row_size_bits_get(
    int unit);

/**
 * \brief returns define data of age_ovfcam_row_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_ovfcam_row_size_bits'
 * The number of bits in a single aging ovfcam memory row
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_ovfcam_row_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_age_ovfcam_row_size_bits_get(
    int unit);

/**
 * \brief returns define data of age_entry_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_entry_size_bits'
 * The number of bits in a single aging memory entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_entry_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_age_entry_size_bits_get(
    int unit);

/**
 * \brief returns define data of ovf_cam_max_size
 * Module - 'mdb', Submodule - 'em', data - 'ovf_cam_max_size'
 * the MAX size of an OVF CAM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ovf_cam_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_ovf_cam_max_size_get(
    int unit);

/**
 * \brief returns define data of age_support_per_entry_size_ratio
 * Module - 'mdb', Submodule - 'em', data - 'age_support_per_entry_size_ratio'
 * Indicate if the aging profiles are supported per entry ratio size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_support_per_entry_size_ratio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_age_support_per_entry_size_ratio_get(
    int unit);

/**
 * \brief returns define data of nof_aging_profiles
 * Module - 'mdb', Submodule - 'em', data - 'nof_aging_profiles'
 * The NOF aging profile avialable in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_aging_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_aging_profiles_get(
    int unit);

/**
 * \brief returns define data of aging_profiles_size_in_bits
 * Module - 'mdb', Submodule - 'em', data - 'aging_profiles_size_in_bits'
 * The number of bits needed for the NOF aging profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aging_profiles_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_aging_profiles_size_in_bits_get(
    int unit);

/**
 * \brief returns define data of max_tid_size
 * Module - 'mdb', Submodule - 'em', data - 'max_tid_size'
 * The largest TID size in bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tid_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_max_tid_size_get(
    int unit);

/**
 * \brief returns define data of max_nof_tids
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_tids'
 * max NOF of TIDs for a PDB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_tids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_max_nof_tids_get(
    int unit);

/**
 * \brief returns define data of flush_support_tids
 * Module - 'mdb', Submodule - 'em', data - 'flush_support_tids'
 * The max NOF of TIDs an MDB table that support flush machine could have.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_support_tids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_flush_support_tids_get(
    int unit);

/**
 * \brief returns define data of flush_max_supported_key
 * Module - 'mdb', Submodule - 'em', data - 'flush_max_supported_key'
 * The largest key size that can be used by the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_max_supported_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_flush_max_supported_key_get(
    int unit);

/**
 * \brief returns define data of flush_max_supported_payload
 * Module - 'mdb', Submodule - 'em', data - 'flush_max_supported_payload'
 * The largest payload size that can be used by the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_max_supported_payload - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_flush_max_supported_payload_get(
    int unit);

/**
 * \brief returns define data of flush_max_supported_key_plus_payload
 * Module - 'mdb', Submodule - 'em', data - 'flush_max_supported_key_plus_payload'
 * The largest key+payload size that can be used by the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_max_supported_key_plus_payload - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_flush_max_supported_key_plus_payload_get(
    int unit);

/**
 * \brief returns define data of dh_120_entry_encoding_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'dh_120_entry_encoding_nof_bits'
 * Number of bits representing a EM DH 120 width cluster encoding value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dh_120_entry_encoding_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_dh_120_entry_encoding_nof_bits_get(
    int unit);

/**
 * \brief returns define data of dh_240_entry_encoding_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'dh_240_entry_encoding_nof_bits'
 * Number of bits representing a EM DH 240 width cluster encoding value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dh_240_entry_encoding_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_dh_240_entry_encoding_nof_bits_get(
    int unit);

/**
 * \brief returns define data of format_granularity
 * Module - 'mdb', Submodule - 'em', data - 'format_granularity'
 * The granularity used for the EM format configuration.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     format_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_format_granularity_get(
    int unit);

/**
 * \brief returns define data of max_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_vmv_size'
 * The number of bits used to represent the vmv, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_max_nof_vmv_size_get(
    int unit);

/**
 * \brief returns define data of vmv_nof_values
 * Module - 'mdb', Submodule - 'em', data - 'vmv_nof_values'
 * NOF values available for the VMV (depends on the nof_vmv_size value)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vmv_nof_values - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_vmv_nof_values_get(
    int unit);

/**
 * \brief returns define data of nof_vmv_size_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'nof_vmv_size_nof_bits'
 * the nof_vmv_size size in bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vmv_size_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_vmv_size_nof_bits_get(
    int unit);

/**
 * \brief returns define data of esem_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'esem_nof_vmv_size'
 * The number of bits used to represent the vmv for ESEM only, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     esem_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_esem_nof_vmv_size_get(
    int unit);

/**
 * \brief returns define data of glem_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'glem_nof_vmv_size'
 * The number of bits used to represent the VMV for GLEM only, smaller vmv sizes are simply aligned to the MDB and the configuration iterates on all possible values of the LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     glem_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_glem_nof_vmv_size_get(
    int unit);

/**
 * \brief returns define data of mact_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'mact_nof_vmv_size'
 * The number of bits used to represent the vmv for MACT only, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB;This value is a HW constraint related to MACT LEL, other LEM logical tables can utilize the full MDB_NOF_VMV_BITS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_mact_nof_vmv_size_get(
    int unit);

/**
 * \brief returns define data of mact_max_payload_size
 * Module - 'mdb', Submodule - 'em', data - 'mact_max_payload_size'
 * MACT payload has to be this size or smaller
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_mact_max_payload_size_get(
    int unit);

/**
 * \brief returns define data of shift_vmv_max_size
 * Module - 'mdb', Submodule - 'em', data - 'shift_vmv_max_size'
 * NOF of EM lookup per stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     shift_vmv_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_shift_vmv_max_size_get(
    int unit);

/**
 * \brief returns define data of shift_vmv_max_regs_per_table
 * Module - 'mdb', Submodule - 'em', data - 'shift_vmv_max_regs_per_table'
 * NOF of different shift vmv registers associated with a single EM table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     shift_vmv_max_regs_per_table - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_shift_vmv_max_regs_per_table_get(
    int unit);

/**
 * \brief returns define data of min_nof_app_id_bits
 * Module - 'mdb', Submodule - 'em', data - 'min_nof_app_id_bits'
 * The minimal number of bits used to represent APP ID.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_nof_app_id_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_min_nof_app_id_bits_get(
    int unit);

/**
 * \brief returns define data of max_nof_spn_sizes
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_spn_sizes'
 * The maximal NOF of SPN sizes options for a single EM PDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_spn_sizes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_max_nof_spn_sizes_get(
    int unit);

/**
 * \brief returns define data of nof_lfsr_sizes
 * Module - 'mdb', Submodule - 'em', data - 'nof_lfsr_sizes'
 * The NOF of LFSR sizes options for a single EM PDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lfsr_sizes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_lfsr_sizes_get(
    int unit);

/**
 * \brief returns define data of nof_formats
 * Module - 'mdb', Submodule - 'em', data - 'nof_formats'
 * The NOF formats which the EM application can used, a format define by the key size and address size and the table address space.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_formats - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_formats_get(
    int unit);

/**
 * \brief returns define data of defragmentation_priority_supported
 * Module - 'mdb', Submodule - 'em', data - 'defragmentation_priority_supported'
 * Overflow CAM defrag machine has priority over Host/Ext support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     defragmentation_priority_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_defragmentation_priority_supported_get(
    int unit);

/**
 * \brief returns define data of disable_cuckoo_loop_detection_support
 * Module - 'mdb', Submodule - 'em', data - 'disable_cuckoo_loop_detection_support'
 * indicate if the device has an option to disable loop detectionin cuckoo processing
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     disable_cuckoo_loop_detection_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_disable_cuckoo_loop_detection_support_get(
    int unit);

/**
 * \brief returns define data of disable_cuckoo_hit_bit_sync
 * Module - 'mdb', Submodule - 'em', data - 'disable_cuckoo_hit_bit_sync'
 * indicate if the device has an option to disable cuckoo hit bit handle
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     disable_cuckoo_hit_bit_sync - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_disable_cuckoo_hit_bit_sync_get(
    int unit);

/**
 * \brief returns define data of age_profile_per_ratio_support
 * Module - 'mdb', Submodule - 'em', data - 'age_profile_per_ratio_support'
 * indicate if the device has an age profile per ratio support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_profile_per_ratio_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_age_profile_per_ratio_support_get(
    int unit);

/**
 * \brief returns define data of flex_mag_supported
 * Module - 'mdb', Submodule - 'em', data - 'flex_mag_supported'
 * the flex supported in the MAG but not necessarily fully supported 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flex_mag_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_flex_mag_supported_get(
    int unit);

/**
 * \brief returns define data of flex_fully_supported
 * Module - 'mdb', Submodule - 'em', data - 'flex_fully_supported'
 * flex feature is fully supported (if this is set so does the flex_mag_supported should be).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flex_fully_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_flex_fully_supported_get(
    int unit);

/**
 * \brief returns define data of step_table_max_size
 * Module - 'mdb', Submodule - 'em', data - 'step_table_max_size'
 * The max NOF rows that a step table can hold.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     step_table_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_step_table_max_size_get(
    int unit);

/**
 * \brief returns define data of nof_encoding_values
 * Module - 'mdb', Submodule - 'em', data - 'nof_encoding_values'
 * the NOF encoding values (values that represent the payload size out of row width) in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_encoding_values - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_encoding_values_get(
    int unit);

/**
 * \brief returns define data of nof_encoding_types
 * Module - 'mdb', Submodule - 'em', data - 'nof_encoding_types'
 * the NOF encoding types (ONE/HALF/QUARTER/EIGHTH) in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_encoding_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_encoding_types_get(
    int unit);

/**
 * \brief returns define data of extra_vmv_shift_registers
 * Module - 'mdb', Submodule - 'em', data - 'extra_vmv_shift_registers'
 * Device have a larger NOF VMV shift registers.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     extra_vmv_shift_registers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_extra_vmv_shift_registers_get(
    int unit);

/**
 * \brief returns numeric data of interrupt_register
 * Module - 'mdb', Submodule - 'em', data - 'interrupt_register'
 * EM interrupt register.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     interrupt_register - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_interrupt_register_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_mdb_em_table_spn,
    dnx_data_mdb_em_table_lfsr,
    dnx_data_mdb_em_table_em_aging_cfg,
    dnx_data_mdb_em_table_em_info,
    dnx_data_mdb_em_table_step_table_pdb_max_depth,
    dnx_data_mdb_em_table_step_table_max_depth_possible,
    dnx_data_mdb_em_table_mdb_13_info,
    dnx_data_mdb_em_table_mdb_15_info,
    dnx_data_mdb_em_table_mdb_16_info,
    dnx_data_mdb_em_table_mdb_18_info,
    dnx_data_mdb_em_table_mdb_21_info,
    dnx_data_mdb_em_table_mdb_23_info,
    dnx_data_mdb_em_table_mdb_24_info,
    dnx_data_mdb_em_table_mdb_29_info,
    dnx_data_mdb_em_table_mdb_31_info,
    dnx_data_mdb_em_table_mdb_32_info,
    dnx_data_mdb_em_table_mdb_41_info,
    dnx_data_mdb_em_table_mdb_em_tables_info,
    dnx_data_mdb_em_table_mdb_emp_tables_info,
    dnx_data_mdb_em_table_mdb_em_shift_vmv_regs,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_em_table_nof
} dnx_data_mdb_em_table_e;

/* Get Data */
/**
 * \brief get table spn entry 
 * holds SPN information
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are valid in this case)
 * 
 * \return
 *     spn - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_spn_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_spn_t * dnx_data_mdb_em_spn_get(
    int unit,
    int dbal_id);

/**
 * \brief get table lfsr entry 
 * holds LFSR information
 * 
 * \param [in] unit - unit #
 * \param [in] lfsr_index - the index number of the  requseted LFSR.
 * 
 * \return
 *     lfsr - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_lfsr_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_lfsr_t * dnx_data_mdb_em_lfsr_get(
    int unit,
    int lfsr_index);

/**
 * \brief get table em_aging_cfg entry 
 * aging information
 * 
 * \param [in] unit - unit #
 * \param [in] profile - The aging profile to set.
 * \param [in] emp_table - The EMP table to set.
 * 
 * \return
 *     em_aging_cfg - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_em_aging_cfg_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_em_aging_cfg_t * dnx_data_mdb_em_em_aging_cfg_get(
    int unit,
    int profile,
    int emp_table);

/**
 * \brief get table em_info entry 
 * Holds EM tables information
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are valid in this case)
 * 
 * \return
 *     em_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_em_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_em_info_t * dnx_data_mdb_em_em_info_get(
    int unit,
    int dbal_id);

/**
 * \brief get table step_table_pdb_max_depth entry 
 * hold the maximal depth of the step table that is supported by an EM PDB.
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are valid in this case)
 * 
 * \return
 *     step_table_pdb_max_depth - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_step_table_pdb_max_depth_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_step_table_pdb_max_depth_t * dnx_data_mdb_em_step_table_pdb_max_depth_get(
    int unit,
    int dbal_id);

/**
 * \brief get table step_table_max_depth_possible entry 
 * hold the maximal depth of the step table for different aspect ratio combinations and table sizes
 * 
 * \param [in] unit - unit #
 * \param [in] step_table_size_indication - indicate the step table size where 0> 512, 1->1024 and 2->2048 means rows in the step table.
 * \param [in] aspect_ratio_combination - the aspect ratio that are in the step table where bit to ratio mapping is 0->one, 1->half, 2->quarter, 3->eighth
 * 
 * \return
 *     step_table_max_depth_possible - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_step_table_max_depth_possible_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_step_table_max_depth_possible_t * dnx_data_mdb_em_step_table_max_depth_possible_get(
    int unit,
    int step_table_size_indication,
    int aspect_ratio_combination);

/**
 * \brief get table mdb_13_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_13_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_13_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_13_info_t * dnx_data_mdb_em_mdb_13_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_15_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_15_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_15_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_15_info_t * dnx_data_mdb_em_mdb_15_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_16_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_16_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_16_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_16_info_t * dnx_data_mdb_em_mdb_16_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_18_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_18_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_18_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_18_info_t * dnx_data_mdb_em_mdb_18_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_21_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_21_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_21_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_21_info_t * dnx_data_mdb_em_mdb_21_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_23_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_23_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_23_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_23_info_t * dnx_data_mdb_em_mdb_23_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_24_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_24_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_24_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_24_info_t * dnx_data_mdb_em_mdb_24_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_29_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_29_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_29_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_29_info_t * dnx_data_mdb_em_mdb_29_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_31_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_31_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_31_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_31_info_t * dnx_data_mdb_em_mdb_31_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_32_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_32_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_32_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_32_info_t * dnx_data_mdb_em_mdb_32_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_41_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_41_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_41_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_41_info_t * dnx_data_mdb_em_mdb_41_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_em_tables_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_em_tables_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_em_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_em_tables_info_t * dnx_data_mdb_em_mdb_em_tables_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_emp_tables_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_emp_tables_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_emp_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_emp_tables_info_t * dnx_data_mdb_em_mdb_emp_tables_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_em_shift_vmv_regs entry 
 * Holds the shift vmv DBAL tables associated with each MDB EM table.
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are valid in this case)
 * 
 * \return
 *     mdb_em_shift_vmv_regs - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_em_shift_vmv_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_em_shift_vmv_regs_t * dnx_data_mdb_em_mdb_em_shift_vmv_regs_get(
    int unit,
    int dbal_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'spn'
 * holds SPN information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_spn_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'lfsr'
 * holds LFSR information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_lfsr_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'em_aging_cfg'
 * aging information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_em_aging_cfg_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'em_info'
 * Holds EM tables information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_em_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'step_table_pdb_max_depth'
 * hold the maximal depth of the step table that is supported by an EM PDB.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_step_table_pdb_max_depth_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'step_table_max_depth_possible'
 * hold the maximal depth of the step table for different aspect ratio combinations and table sizes
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_step_table_max_depth_possible_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_13_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_13_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_15_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_15_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_16_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_16_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_18_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_18_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_21_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_21_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_23_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_23_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_24_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_24_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_29_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_29_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_31_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_31_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_32_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_32_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_41_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_41_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_em_tables_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_em_tables_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_emp_tables_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_emp_tables_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_em_shift_vmv_regs'
 * Holds the shift vmv DBAL tables associated with each MDB EM table.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_em_shift_vmv_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)spn info
 * holds SPN information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     spn - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_spn_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)lfsr info
 * holds LFSR information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lfsr - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_lfsr_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)em_aging_cfg info
 * aging information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     em_aging_cfg - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_em_aging_cfg_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)em_info info
 * Holds EM tables information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     em_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_em_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)step_table_pdb_max_depth info
 * hold the maximal depth of the step table that is supported by an EM PDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     step_table_pdb_max_depth - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_step_table_pdb_max_depth_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)step_table_max_depth_possible info
 * hold the maximal depth of the step table for different aspect ratio combinations and table sizes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     step_table_max_depth_possible - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_step_table_max_depth_possible_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_13_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_13_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_13_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_15_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_15_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_15_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_16_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_16_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_16_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_18_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_18_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_18_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_21_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_21_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_21_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_23_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_23_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_23_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_24_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_24_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_24_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_29_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_29_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_29_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_31_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_31_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_31_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_32_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_32_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_32_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_41_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_41_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_41_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_em_tables_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_em_tables_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_em_tables_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_emp_tables_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_emp_tables_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_emp_tables_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_em_shift_vmv_regs info
 * Holds the shift vmv DBAL tables associated with each MDB EM table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_em_shift_vmv_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_em_shift_vmv_regs_info_get(
    int unit);

/*
 * SUBMODULE DIRECT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_direct_feature_get(
    int unit,
    dnx_data_mdb_direct_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_direct_define_physical_address_max_bits,
    dnx_data_mdb_direct_define_physical_address_max_bits_support_single_macro_b_granularity_fec_alloc,
    dnx_data_mdb_direct_define_vsi_physical_address_max_bits,
    dnx_data_mdb_direct_define_fec_address_mapping_bits,
    dnx_data_mdb_direct_define_fec_address_mapping_bits_relevant,
    dnx_data_mdb_direct_define_fec_max_cluster_pairs,
    dnx_data_mdb_direct_define_max_payload_size,
    dnx_data_mdb_direct_define_nof_fecs_in_super_fec,
    dnx_data_mdb_direct_define_nof_fec_ecmp_hierarchies,
    dnx_data_mdb_direct_define_map_payload_size_enum,
    dnx_data_mdb_direct_define_map_payload_type_enum,
    dnx_data_mdb_direct_define_map_payload_size,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_direct_define_nof
} dnx_data_mdb_direct_define_e;

/* Get Data */
/**
 * \brief returns define data of physical_address_max_bits
 * Module - 'mdb', Submodule - 'direct', data - 'physical_address_max_bits'
 * The number of DB_ATR_PHYSICAL_ADDRESS_SPACE bits associated with encoding 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_max_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_physical_address_max_bits_get(
    int unit);

/**
 * \brief returns define data of physical_address_max_bits_support_single_macro_b_granularity_fec_alloc
 * Module - 'mdb', Submodule - 'direct', data - 'physical_address_max_bits_support_single_macro_b_granularity_fec_alloc'
 * The largest address space value which can support a single macro B granularity for the FEC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_max_bits_support_single_macro_b_granularity_fec_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_physical_address_max_bits_support_single_macro_b_granularity_fec_alloc_get(
    int unit);

/**
 * \brief returns define data of vsi_physical_address_max_bits
 * Module - 'mdb', Submodule - 'direct', data - 'vsi_physical_address_max_bits'
 * The VSI number of DB_ATR_PHYSICAL_ADDRESS_SPACE bits associated with encoding 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsi_physical_address_max_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_vsi_physical_address_max_bits_get(
    int unit);

/**
 * \brief returns define data of fec_address_mapping_bits
 * Module - 'mdb', Submodule - 'direct', data - 'fec_address_mapping_bits'
 * The FEC address mapping bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_address_mapping_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_fec_address_mapping_bits_get(
    int unit);

/**
 * \brief returns define data of fec_address_mapping_bits_relevant
 * Module - 'mdb', Submodule - 'direct', data - 'fec_address_mapping_bits_relevant'
 * The FEC relevant mapping bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_address_mapping_bits_relevant - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_fec_address_mapping_bits_relevant_get(
    int unit);

/**
 * \brief returns define data of fec_max_cluster_pairs
 * Module - 'mdb', Submodule - 'direct', data - 'fec_max_cluster_pairs'
 * The maximal NOF cluster that can be associated to two FEC hierarchies.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_max_cluster_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_fec_max_cluster_pairs_get(
    int unit);

/**
 * \brief returns define data of max_payload_size
 * Module - 'mdb', Submodule - 'direct', data - 'max_payload_size'
 * The largest payload size associated with a direct table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_max_payload_size_get(
    int unit);

/**
 * \brief returns define data of nof_fecs_in_super_fec
 * Module - 'mdb', Submodule - 'direct', data - 'nof_fecs_in_super_fec'
 * NOF of FECs contained in a single super FEC.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fecs_in_super_fec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_nof_fecs_in_super_fec_get(
    int unit);

/**
 * \brief returns define data of nof_fec_ecmp_hierarchies
 * Module - 'mdb', Submodule - 'direct', data - 'nof_fec_ecmp_hierarchies'
 * NOF of FEC/ECMP hierarchies.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_ecmp_hierarchies - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_nof_fec_ecmp_hierarchies_get(
    int unit);

/**
 * \brief returns numeric data of map_payload_size_enum
 * Module - 'mdb', Submodule - 'direct', data - 'map_payload_size_enum'
 * Payload size Enum of PMF MAPS DB, configured using pmf_maps_payload_size SOC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     map_payload_size_enum - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_map_payload_size_enum_get(
    int unit);

/**
 * \brief returns numeric data of map_payload_type_enum
 * Module - 'mdb', Submodule - 'direct', data - 'map_payload_type_enum'
 * Payload type Enum of PMF MAPS DB, configured using pmf_maps_payload_size SOC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     map_payload_type_enum - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_map_payload_type_enum_get(
    int unit);

/**
 * \brief returns numeric data of map_payload_size
 * Module - 'mdb', Submodule - 'direct', data - 'map_payload_size'
 * Payload size of PMF MAPS DB, configured using pmf_maps_payload_size SOC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     map_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_map_payload_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_mdb_direct_table_direct_info,
    dnx_data_mdb_direct_table_hit_bit_pos_in_abk,
    dnx_data_mdb_direct_table_mdb_42_info,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_direct_table_nof
} dnx_data_mdb_direct_table_e;

/* Get Data */
/**
 * \brief get table direct_info entry 
 * general information of the direct table PDBs
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB
 * 
 * \return
 *     direct_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_direct_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_direct_direct_info_t * dnx_data_mdb_direct_direct_info_get(
    int unit,
    int dbal_id);

/**
 * \brief get table hit_bit_pos_in_abk entry 
 * Each 30 bits of each entry has a matching ABK bit, this table matches hit bit option to an ABK hit bit position.
 * 
 * \param [in] unit - unit #
 * \param [in] hit_bit_index - the hit bit index
 * 
 * \return
 *     hit_bit_pos_in_abk - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_hit_bit_pos_in_abk_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_direct_hit_bit_pos_in_abk_t * dnx_data_mdb_direct_hit_bit_pos_in_abk_get(
    int unit,
    int hit_bit_index);

/**
 * \brief get table mdb_42_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_42_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_mdb_42_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_direct_mdb_42_info_t * dnx_data_mdb_direct_mdb_42_info_get(
    int unit,
    int mdb_table);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'direct', table - 'direct_info'
 * general information of the direct table PDBs
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_direct_direct_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'direct', table - 'hit_bit_pos_in_abk'
 * Each 30 bits of each entry has a matching ABK bit, this table matches hit bit option to an ABK hit bit position.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_direct_hit_bit_pos_in_abk_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'direct', table - 'mdb_42_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_direct_mdb_42_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)direct_info info
 * general information of the direct table PDBs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     direct_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_direct_direct_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)hit_bit_pos_in_abk info
 * Each 30 bits of each entry has a matching ABK bit, this table matches hit bit option to an ABK hit bit position.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hit_bit_pos_in_abk - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_direct_hit_bit_pos_in_abk_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_42_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_42_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_direct_mdb_42_info_info_get(
    int unit);

/*
 * SUBMODULE EEDB:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_eedb_feature_get(
    int unit,
    dnx_data_mdb_eedb_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_eedb_define_phase_map_bits,
    dnx_data_mdb_eedb_define_phase_map_array_size,
    dnx_data_mdb_eedb_define_nof_phase_per_mag,
    dnx_data_mdb_eedb_define_nof_phases,
    dnx_data_mdb_eedb_define_nof_eedb_mags,
    dnx_data_mdb_eedb_define_nof_eedb_banks,
    dnx_data_mdb_eedb_define_nof_phases_per_eedb_bank,
    dnx_data_mdb_eedb_define_nof_phases_per_eedb_bank_size,
    dnx_data_mdb_eedb_define_phase_bank_select_default,
    dnx_data_mdb_eedb_define_entry_format_bits,
    dnx_data_mdb_eedb_define_entry_format_encoding_bits,
    dnx_data_mdb_eedb_define_bank_id_bits,
    dnx_data_mdb_eedb_define_entry_bank,
    dnx_data_mdb_eedb_define_abk_bank,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_eedb_define_nof
} dnx_data_mdb_eedb_define_e;

/* Get Data */
/**
 * \brief returns define data of phase_map_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_map_bits'
 * number of msbits used for the phase mapping.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_map_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_phase_map_bits_get(
    int unit);

/**
 * \brief returns define data of phase_map_array_size
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_map_array_size'
 * Size of phase map array.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_map_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_phase_map_array_size_get(
    int unit);

/**
 * \brief returns define data of nof_phase_per_mag
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phase_per_mag'
 * the NOF phases each MAGs Is associated with.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phase_per_mag - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_phase_per_mag_get(
    int unit);

/**
 * \brief returns define data of nof_phases
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases'
 * NOF of EEDB phases.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_phases_get(
    int unit);

/**
 * \brief returns define data of nof_eedb_mags
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_eedb_mags'
 * NOF of EEDB MAGs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eedb_mags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_eedb_mags_get(
    int unit);

/**
 * \brief returns define data of nof_eedb_banks
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_eedb_banks'
 * NOF of EEDB banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eedb_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_eedb_banks_get(
    int unit);

/**
 * \brief returns define data of nof_phases_per_eedb_bank
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases_per_eedb_bank'
 * Each EEDB bank can be associated with one of this amount of phases
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases_per_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_phases_per_eedb_bank_get(
    int unit);

/**
 * \brief returns define data of nof_phases_per_eedb_bank_size
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases_per_eedb_bank_size'
 * nof_phases_per_eedb_bank size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases_per_eedb_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_phases_per_eedb_bank_size_get(
    int unit);

/**
 * \brief returns define data of phase_bank_select_default
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_bank_select_default'
 * the default phase value for a bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_bank_select_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_phase_bank_select_default_get(
    int unit);

/**
 * \brief returns define data of entry_format_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'entry_format_bits'
 * Number of MSbits used to determine the payload size in MDB_ENTRY_FORMATr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_format_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_entry_format_bits_get(
    int unit);

/**
 * \brief returns define data of entry_format_encoding_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'entry_format_encoding_bits'
 * Number of bits used to represent the payload size (30/60/90/120) in MDB_ENTRY_FORMATr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_format_encoding_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_entry_format_encoding_bits_get(
    int unit);

/**
 * \brief returns define data of bank_id_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'bank_id_bits'
 * Number of bits used for bank_id comparison.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_id_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_bank_id_bits_get(
    int unit);

/**
 * \brief returns numeric data of entry_bank
 * Module - 'mdb', Submodule - 'eedb', data - 'entry_bank'
 * the EEDB entry bank memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_entry_bank_get(
    int unit);

/**
 * \brief returns numeric data of abk_bank
 * Module - 'mdb', Submodule - 'eedb', data - 'abk_bank'
 * the EEDB abk bank memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     abk_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_abk_bank_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_mdb_eedb_table_phase_info,
    dnx_data_mdb_eedb_table_outlif_physical_phase_granularity,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_eedb_table_nof
} dnx_data_mdb_eedb_table_e;

/* Get Data */
/**
 * \brief get table phase_info entry 
 * general information per EEDB phase.
 * 
 * \param [in] unit - unit #
 * \param [in] phase_number - the phase number.
 * 
 * \return
 *     phase_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_eedb_phase_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_eedb_phase_info_t * dnx_data_mdb_eedb_phase_info_get(
    int unit,
    int phase_number);

/**
 * \brief get table outlif_physical_phase_granularity entry 
 * Assign an outlif physical phase granularity.
 * 
 * \param [in] unit - unit #
 * \param [in] outlif_physical_phase - Physical phase.
 * 
 * \return
 *     outlif_physical_phase_granularity - returns the relevant entry values grouped in struct - see dnx_data_mdb_eedb_outlif_physical_phase_granularity_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_eedb_outlif_physical_phase_granularity_t * dnx_data_mdb_eedb_outlif_physical_phase_granularity_get(
    int unit,
    int outlif_physical_phase);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'eedb', table - 'phase_info'
 * general information per EEDB phase.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_eedb_phase_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'eedb', table - 'outlif_physical_phase_granularity'
 * Assign an outlif physical phase granularity.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_eedb_outlif_physical_phase_granularity_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)phase_info info
 * general information per EEDB phase.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_eedb_phase_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)outlif_physical_phase_granularity info
 * Assign an outlif physical phase granularity.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_physical_phase_granularity - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_eedb_outlif_physical_phase_granularity_info_get(
    int unit);

/*
 * SUBMODULE KAPS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_kaps_feature_get(
    int unit,
    dnx_data_mdb_kaps_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_kaps_define_nof_small_bbs,
    dnx_data_mdb_kaps_define_nof_big_bbs_blk_ids,
    dnx_data_mdb_kaps_define_nof_rows_in_small_bb,
    dnx_data_mdb_kaps_define_nof_rows_in_small_rpb_hitbits,
    dnx_data_mdb_kaps_define_nof_bytes_in_hitbit_row,
    dnx_data_mdb_kaps_define_key_lsn_bits,
    dnx_data_mdb_kaps_define_key_prefix_length,
    dnx_data_mdb_kaps_define_max_prefix_in_bb_row,
    dnx_data_mdb_kaps_define_key_width_in_bits,
    dnx_data_mdb_kaps_define_ad_width_in_bits,
    dnx_data_mdb_kaps_define_bb_byte_width,
    dnx_data_mdb_kaps_define_rpb_byte_width,
    dnx_data_mdb_kaps_define_ads_byte_width,
    dnx_data_mdb_kaps_define_rpb_valid_bits,
    dnx_data_mdb_kaps_define_dynamic_memory_access_dpc,
    dnx_data_mdb_kaps_define_rpb_field,
    dnx_data_mdb_kaps_define_result_core0_db0_reg,
    dnx_data_mdb_kaps_define_result_core0_db1_reg,
    dnx_data_mdb_kaps_define_result_core1_db0_reg,
    dnx_data_mdb_kaps_define_result_core1_db1_reg,
    dnx_data_mdb_kaps_define_big_kaps_revision_val,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_kaps_define_nof
} dnx_data_mdb_kaps_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_small_bbs
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_small_bbs'
 * nof small BBs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_bbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_nof_small_bbs_get(
    int unit);

/**
 * \brief returns define data of nof_big_bbs_blk_ids
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_big_bbs_blk_ids'
 * nof KBPSDK blk_ids associated with big BBs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_bbs_blk_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_nof_big_bbs_blk_ids_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_small_bb
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_rows_in_small_bb'
 * nof row in a small BB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_small_bb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_nof_rows_in_small_bb_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_small_rpb_hitbits
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_rows_in_small_rpb_hitbits'
 * nof row in a small RPB hitbits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_small_rpb_hitbits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_nof_rows_in_small_rpb_hitbits_get(
    int unit);

/**
 * \brief returns define data of nof_bytes_in_hitbit_row
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_bytes_in_hitbit_row'
 * nof bytes in a hitbit database row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bytes_in_hitbit_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_nof_bytes_in_hitbit_row_get(
    int unit);

/**
 * \brief returns define data of key_lsn_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'key_lsn_bits'
 * RPB input = {key, search_lsn}.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_lsn_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_key_lsn_bits_get(
    int unit);

/**
 * \brief returns define data of key_prefix_length
 * Module - 'mdb', Submodule - 'kaps', data - 'key_prefix_length'
 * The KAPS DB prefix length.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_prefix_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_key_prefix_length_get(
    int unit);

/**
 * \brief returns define data of max_prefix_in_bb_row
 * Module - 'mdb', Submodule - 'kaps', data - 'max_prefix_in_bb_row'
 * The maximum number of prefixes in a single KAPS BB row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_in_bb_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_max_prefix_in_bb_row_get(
    int unit);

/**
 * \brief returns define data of key_width_in_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'key_width_in_bits'
 * The KAPS(LPM) key size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_width_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_key_width_in_bits_get(
    int unit);

/**
 * \brief returns define data of ad_width_in_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'ad_width_in_bits'
 * The KAPS(LPM) payload size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ad_width_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_ad_width_in_bits_get(
    int unit);

/**
 * \brief returns define data of bb_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'bb_byte_width'
 * the BB width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bb_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_bb_byte_width_get(
    int unit);

/**
 * \brief returns define data of rpb_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_byte_width'
 * the RPB width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_rpb_byte_width_get(
    int unit);

/**
 * \brief returns define data of ads_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'ads_byte_width'
 * the ADS width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ads_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_ads_byte_width_get(
    int unit);

/**
 * \brief returns define data of rpb_valid_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_valid_bits'
 * the RPB valid size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_valid_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_rpb_valid_bits_get(
    int unit);

/**
 * \brief returns define data of dynamic_memory_access_dpc
 * Module - 'mdb', Submodule - 'kaps', data - 'dynamic_memory_access_dpc'
 * The KAPS dynamic memory is of DPC type.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dynamic_memory_access_dpc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_dynamic_memory_access_dpc_get(
    int unit);

/**
 * \brief returns numeric data of rpb_field
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_field'
 * LPM RPB field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_rpb_field_get(
    int unit);

/**
 * \brief returns numeric data of result_core0_db0_reg
 * Module - 'mdb', Submodule - 'kaps', data - 'result_core0_db0_reg'
 * The LPM search interface result for core 0 db 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     result_core0_db0_reg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_result_core0_db0_reg_get(
    int unit);

/**
 * \brief returns numeric data of result_core0_db1_reg
 * Module - 'mdb', Submodule - 'kaps', data - 'result_core0_db1_reg'
 * The LPM search interface result for core 0 db 1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     result_core0_db1_reg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_result_core0_db1_reg_get(
    int unit);

/**
 * \brief returns numeric data of result_core1_db0_reg
 * Module - 'mdb', Submodule - 'kaps', data - 'result_core1_db0_reg'
 * The LPM search interface result for core 1 db 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     result_core1_db0_reg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_result_core1_db0_reg_get(
    int unit);

/**
 * \brief returns numeric data of result_core1_db1_reg
 * Module - 'mdb', Submodule - 'kaps', data - 'result_core1_db1_reg'
 * The LPM search interface result for core 1 db 1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     result_core1_db1_reg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_result_core1_db1_reg_get(
    int unit);

/**
 * \brief returns numeric data of big_kaps_revision_val
 * Module - 'mdb', Submodule - 'kaps', data - 'big_kaps_revision_val'
 * The big KAPS revision register value to pass on to the KBPSDK.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     big_kaps_revision_val - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_big_kaps_revision_val_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_mdb_kaps_table_big_bb_blk_id_mapping,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_kaps_table_nof
} dnx_data_mdb_kaps_table_e;

/* Get Data */
/**
 * \brief get table big_bb_blk_id_mapping entry 
 * Mapping from KBPSDK blk_id to global_macro_index
 * 
 * \param [in] unit - unit #
 * \param [in] blk_id - The KBPSDK blk_id, first big BB blk_id is 0
 * 
 * \return
 *     big_bb_blk_id_mapping - returns the relevant entry values grouped in struct - see dnx_data_mdb_kaps_big_bb_blk_id_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_kaps_big_bb_blk_id_mapping_t * dnx_data_mdb_kaps_big_bb_blk_id_mapping_get(
    int unit,
    int blk_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'kaps', table - 'big_bb_blk_id_mapping'
 * Mapping from KBPSDK blk_id to global_macro_index
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_kaps_big_bb_blk_id_mapping_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)big_bb_blk_id_mapping info
 * Mapping from KBPSDK blk_id to global_macro_index
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     big_bb_blk_id_mapping - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_kaps_big_bb_blk_id_mapping_info_get(
    int unit);

/*
 * SUBMODULE HW_BUG:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_hw_bug_feature_get(
    int unit,
    dnx_data_mdb_hw_bug_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_hw_bug_define_nof
} dnx_data_mdb_hw_bug_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_hw_bug_table_nof
} dnx_data_mdb_hw_bug_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_MDB_H_*/
/* *INDENT-ON* */
