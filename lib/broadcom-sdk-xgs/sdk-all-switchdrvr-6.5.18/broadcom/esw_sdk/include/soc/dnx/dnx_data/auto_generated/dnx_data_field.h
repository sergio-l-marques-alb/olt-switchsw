/** \file dnx_data_field.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_FIELD_H_
/*{*/
#define _DNX_DATA_FIELD_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_field.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_field
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_field_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - BASE_IPMF1:
 * Ingress PMF_1 data. For internal DNX DATA use only. Use stage submodule instead.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf1_feature_nof
} dnx_data_field_base_ipmf1_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_base_ipmf1_feature_get_f) (
    int unit,
    dnx_data_field_base_ipmf1_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_ffc'
 * Number of FFC's per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_ffc_groups_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_ffc_group_one_lower_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_ffc_group_one_upper_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_two_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_two_lower'
 * Min FFC Index for Second FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_two_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_ffc_group_two_lower_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_two_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_two_upper'
 * Max FFC Index for Second FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_two_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_ffc_group_two_upper_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_three_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_three_lower'
 * Min FFC Index for Thirth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_three_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_ffc_group_three_lower_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_three_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_three_upper'
 * Max FFC Index for Thirth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_three_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_ffc_group_three_upper_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_four_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_four_lower'
 * Min FFC Index for Fourth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_four_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_ffc_group_four_lower_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_four_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_four_upper'
 * Max FFC Index for Fourth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_four_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_ffc_group_four_upper_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_keys_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_keys_alloc_for_tcam_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_keys_alloc_for_exem_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_mdb_dt
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc_for_mdb_dt'
 * Number of keys available for allocation for use by this specific PMF stage for MDB_DT access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_mdb_dt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_keys_alloc_for_mdb_dt_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fes_programs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_prog_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_program_selection_cam_mask_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of cs_container_5_selected_bits_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'cs_container_5_selected_bits_size'
 * Number of bits taken from general data for context selection.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cs_container_5_selected_bits_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_cs_container_5_selected_bits_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_contexts'
 * Number of Ingress PMF_A programs (contexts). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of nof_link_profiles
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_link_profiles'
 * Number of profiles assigned to iPMF1 contexts in order to create links between iPMF1 and iPMF2 contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_link_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_link_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_cs_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_actions_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_qualifiers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groupsv
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_80B_zones_get_f) (
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_key_zones_get_f) (
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_key_zone_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fes_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fes_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can go into one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fes_key_selects_on_one_actions_line_get_f) (
    int unit);

/**
 * \brief returns define data of fem_condition_ms_bit_min_value
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fem_condition_ms_bit_min_value'
 * The minumum legal value to be set in bit select for a FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_condition_ms_bit_min_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fem_condition_ms_bit_min_value_get_f) (
    int unit);

/**
 * \brief returns define data of fem_condition_ms_bit_max_value
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fem_condition_ms_bit_max_value'
 * The maximum legal value to be set in bit select for a FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_condition_ms_bit_max_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fem_condition_ms_bit_max_value_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_programs
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_programs'
 * Number of bit in FEM program representation. This is log2 of the number of fem programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_programs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_programs
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_programs'
 * Total number FEM programs available. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_programs_get_f) (
    int unit);

/**
 * \brief returns define data of log_nof_bits_in_fem_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'log_nof_bits_in_fem_key_select'
 * Log2 of number of bits on one 'chunk' of input to FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     log_nof_bits_in_fem_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_log_nof_bits_in_fem_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_key_select'
 * Number of bits on one 'chunk' of input to FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of fem_key_select_resolution_in_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fem_key_select_resolution_in_bits'
 * Number of bits in the 'step' from one 'key select' to the following. See dbal_enum_value_field_field_pmf_a_fem_key_select_e. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_key_select_resolution_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fem_key_select_resolution_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of log_nof_bits_in_fem_map_data_field
 * Module - 'field', Submodule - 'base_ipmf1', data - 'log_nof_bits_in_fem_map_data_field'
 * Log2 of number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     log_nof_bits_in_fem_map_data_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_log_nof_bits_in_fem_map_data_field_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_map_data_field
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_map_data_field'
 * Number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_map_data_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_map_data_field_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action_fems_2_15
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action_fems_2_15'
 * Number of bits on action value in IPPC_FEM_*_24B_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action_fems_2_15 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_2_15_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action_fems_0_1
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action_fems_0_1'
 * Number of bits on action value in IPPC_FEM_*_4B_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action_fems_0_1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_0_1_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action'
 * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_condition
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_condition'
 * Number of bits on fem condition. This is log2 of the number of conditions that may be assigned to each (fem_id,fem_program) combination. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_condition - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_condition_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_condition
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_condition'
 * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_condition - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_condition_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_map_index
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_map_index'
 * Number of bits on fem map index. This represents log2 of the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_map_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_map_index_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_map_index
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_map_index'
 * Total number fem map indices. This represents the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_map_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_map_index_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_id
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_id'
 * Number of bits on fem identifier. This represents the number of FEMs in the system: No. of FEMs is 2^nof_bits_in_fem_id. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_id_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_id
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_id'
 * Total number 'FEM id's available. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_id_get_f) (
    int unit);

/**
 * \brief returns define data of num_fems_with_short_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'num_fems_with_short_action'
 * Number of FEMs, starting from 'fem_id=0', which have only 4 bits on action value. The rest have 24 bits on action value. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_fems_with_short_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_num_fems_with_short_action_get_f) (
    int unit);

/**
 * \brief returns define data of num_bits_in_fem_field_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'num_bits_in_fem_field_select'
 * Number of bits on each of the HW field marked FIELD_SELECT_MAP_*. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_bits_in_fem_field_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_num_bits_in_fem_field_select_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_id_per_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_id_per_array'
 * Number FEMes in each FEM array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_array'
 * Number FEM arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fems_per_context
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fems_per_context'
 * Number of FEMs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fems_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fems_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_strength
 * Module - 'field', Submodule - 'base_ipmf1', data - 'default_strength'
 * Default value for PMF strength. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_default_strength_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compare_pairs_in_compare_mode
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_compare_pairs_in_compare_mode'
 * Number compare pairs in compare mode. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_compare_pairs_in_compare_mode_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compare_keys_in_compare_mode
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_compare_keys_in_compare_mode'
 * Number compare keys in compare mode. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_keys_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_compare_keys_in_compare_mode_get_f) (
    int unit);

/**
 * \brief returns define data of compare_key_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'compare_key_size'
 * Size of the compare key in the system. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     compare_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_compare_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges_legacy
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_l4_ops_ranges_legacy'
 * Number of ranges for L4 Ops legacy. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges_legacy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_l4_ops_ranges_legacy_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ext_l4_ops_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_ext_l4_ops_ranges'
 * Number of ranges for External L4 Ops. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ext_l4_ops_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_ext_l4_ops_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of nof_pkt_hdr_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_pkt_hdr_ranges'
 * Number of ranges for PKT HDR. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pkt_hdr_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_pkt_hdr_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_out_lif_ranges'
 * Number of ranges for Out Lif. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_out_lif_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fes_key_select_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fes_shift_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_uses_small_exem_get_f) (
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_uses_large_exem_get_f) (
    int unit);

/**
 * \brief returns define data of cmp_selection
 * Module - 'field', Submodule - 'base_ipmf1', data - 'cmp_selection'
 * Compare selection for both keys of 2nd compare, See the CMP_SELECTION field in IPPC_PMF_GENERAL register for additional information. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cmp_selection - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_cmp_selection_get_f) (
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fes_instruction_size_get_f) (
    int unit);

/**
 * \brief returns define data of fes_pgm_id_offset
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_pgm_id_offset'
 * FES Program ID offset pointing to IPPC_PMF_FES_PROGRAMm->FES_2ND_INSTRUCTION_LSB_ADDRESSf.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_pgm_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fes_pgm_id_offset_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - BASE_IPMF1:
 * {
 */
/**
 * \brief Interface for field base_ipmf1 data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_base_ipmf1_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_base_ipmf1_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_ffc_groups
     */
    dnx_data_field_base_ipmf1_nof_ffc_groups_get_f nof_ffc_groups_get;
    /**
     * returns define data of ffc_group_one_lower
     */
    dnx_data_field_base_ipmf1_ffc_group_one_lower_get_f ffc_group_one_lower_get;
    /**
     * returns define data of ffc_group_one_upper
     */
    dnx_data_field_base_ipmf1_ffc_group_one_upper_get_f ffc_group_one_upper_get;
    /**
     * returns define data of ffc_group_two_lower
     */
    dnx_data_field_base_ipmf1_ffc_group_two_lower_get_f ffc_group_two_lower_get;
    /**
     * returns define data of ffc_group_two_upper
     */
    dnx_data_field_base_ipmf1_ffc_group_two_upper_get_f ffc_group_two_upper_get;
    /**
     * returns define data of ffc_group_three_lower
     */
    dnx_data_field_base_ipmf1_ffc_group_three_lower_get_f ffc_group_three_lower_get;
    /**
     * returns define data of ffc_group_three_upper
     */
    dnx_data_field_base_ipmf1_ffc_group_three_upper_get_f ffc_group_three_upper_get;
    /**
     * returns define data of ffc_group_four_lower
     */
    dnx_data_field_base_ipmf1_ffc_group_four_lower_get_f ffc_group_four_lower_get;
    /**
     * returns define data of ffc_group_four_upper
     */
    dnx_data_field_base_ipmf1_ffc_group_four_upper_get_f ffc_group_four_upper_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_base_ipmf1_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_keys_alloc
     */
    dnx_data_field_base_ipmf1_nof_keys_alloc_get_f nof_keys_alloc_get;
    /**
     * returns define data of nof_keys_alloc_for_tcam
     */
    dnx_data_field_base_ipmf1_nof_keys_alloc_for_tcam_get_f nof_keys_alloc_for_tcam_get;
    /**
     * returns define data of nof_keys_alloc_for_exem
     */
    dnx_data_field_base_ipmf1_nof_keys_alloc_for_exem_get_f nof_keys_alloc_for_exem_get;
    /**
     * returns define data of nof_keys_alloc_for_mdb_dt
     */
    dnx_data_field_base_ipmf1_nof_keys_alloc_for_mdb_dt_get_f nof_keys_alloc_for_mdb_dt_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_base_ipmf1_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_base_ipmf1_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_base_ipmf1_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_base_ipmf1_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_fes_programs
     */
    dnx_data_field_base_ipmf1_nof_fes_programs_get_f nof_fes_programs_get;
    /**
     * returns define data of nof_prog_per_fes
     */
    dnx_data_field_base_ipmf1_nof_prog_per_fes_get_f nof_prog_per_fes_get;
    /**
     * returns define data of program_selection_cam_mask_nof_bits
     */
    dnx_data_field_base_ipmf1_program_selection_cam_mask_nof_bits_get_f program_selection_cam_mask_nof_bits_get;
    /**
     * returns define data of cs_container_5_selected_bits_size
     */
    dnx_data_field_base_ipmf1_cs_container_5_selected_bits_size_get_f cs_container_5_selected_bits_size_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_base_ipmf1_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of nof_link_profiles
     */
    dnx_data_field_base_ipmf1_nof_link_profiles_get_f nof_link_profiles_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_base_ipmf1_nof_cs_lines_get_f nof_cs_lines_get;
    /**
     * returns define data of nof_actions
     */
    dnx_data_field_base_ipmf1_nof_actions_get_f nof_actions_get;
    /**
     * returns define data of nof_qualifiers
     */
    dnx_data_field_base_ipmf1_nof_qualifiers_get_f nof_qualifiers_get;
    /**
     * returns define data of nof_80B_zones
     */
    dnx_data_field_base_ipmf1_nof_80B_zones_get_f nof_80B_zones_get;
    /**
     * returns define data of nof_key_zones
     */
    dnx_data_field_base_ipmf1_nof_key_zones_get_f nof_key_zones_get;
    /**
     * returns define data of nof_key_zone_bits
     */
    dnx_data_field_base_ipmf1_nof_key_zone_bits_get_f nof_key_zone_bits_get;
    /**
     * returns define data of nof_bits_in_fes_action
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fes_action_get_f nof_bits_in_fes_action_get;
    /**
     * returns define data of nof_bits_in_fes_key_select
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fes_key_select_get_f nof_bits_in_fes_key_select_get;
    /**
     * returns define data of nof_fes_key_selects_on_one_actions_line
     */
    dnx_data_field_base_ipmf1_nof_fes_key_selects_on_one_actions_line_get_f nof_fes_key_selects_on_one_actions_line_get;
    /**
     * returns define data of fem_condition_ms_bit_min_value
     */
    dnx_data_field_base_ipmf1_fem_condition_ms_bit_min_value_get_f fem_condition_ms_bit_min_value_get;
    /**
     * returns define data of fem_condition_ms_bit_max_value
     */
    dnx_data_field_base_ipmf1_fem_condition_ms_bit_max_value_get_f fem_condition_ms_bit_max_value_get;
    /**
     * returns define data of nof_bits_in_fem_programs
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_programs_get_f nof_bits_in_fem_programs_get;
    /**
     * returns define data of nof_fem_programs
     */
    dnx_data_field_base_ipmf1_nof_fem_programs_get_f nof_fem_programs_get;
    /**
     * returns define data of log_nof_bits_in_fem_key_select
     */
    dnx_data_field_base_ipmf1_log_nof_bits_in_fem_key_select_get_f log_nof_bits_in_fem_key_select_get;
    /**
     * returns define data of nof_bits_in_fem_key_select
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_key_select_get_f nof_bits_in_fem_key_select_get;
    /**
     * returns define data of fem_key_select_resolution_in_bits
     */
    dnx_data_field_base_ipmf1_fem_key_select_resolution_in_bits_get_f fem_key_select_resolution_in_bits_get;
    /**
     * returns define data of log_nof_bits_in_fem_map_data_field
     */
    dnx_data_field_base_ipmf1_log_nof_bits_in_fem_map_data_field_get_f log_nof_bits_in_fem_map_data_field_get;
    /**
     * returns define data of nof_bits_in_fem_map_data_field
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_map_data_field_get_f nof_bits_in_fem_map_data_field_get;
    /**
     * returns define data of nof_bits_in_fem_action_fems_2_15
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_2_15_get_f nof_bits_in_fem_action_fems_2_15_get;
    /**
     * returns define data of nof_bits_in_fem_action_fems_0_1
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_0_1_get_f nof_bits_in_fem_action_fems_0_1_get;
    /**
     * returns define data of nof_bits_in_fem_action
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_action_get_f nof_bits_in_fem_action_get;
    /**
     * returns define data of nof_bits_in_fem_condition
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_condition_get_f nof_bits_in_fem_condition_get;
    /**
     * returns define data of nof_fem_condition
     */
    dnx_data_field_base_ipmf1_nof_fem_condition_get_f nof_fem_condition_get;
    /**
     * returns define data of nof_bits_in_fem_map_index
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_map_index_get_f nof_bits_in_fem_map_index_get;
    /**
     * returns define data of nof_fem_map_index
     */
    dnx_data_field_base_ipmf1_nof_fem_map_index_get_f nof_fem_map_index_get;
    /**
     * returns define data of nof_bits_in_fem_id
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_id_get_f nof_bits_in_fem_id_get;
    /**
     * returns define data of nof_fem_id
     */
    dnx_data_field_base_ipmf1_nof_fem_id_get_f nof_fem_id_get;
    /**
     * returns define data of num_fems_with_short_action
     */
    dnx_data_field_base_ipmf1_num_fems_with_short_action_get_f num_fems_with_short_action_get;
    /**
     * returns define data of num_bits_in_fem_field_select
     */
    dnx_data_field_base_ipmf1_num_bits_in_fem_field_select_get_f num_bits_in_fem_field_select_get;
    /**
     * returns define data of nof_fem_id_per_array
     */
    dnx_data_field_base_ipmf1_nof_fem_id_per_array_get_f nof_fem_id_per_array_get;
    /**
     * returns define data of nof_fem_array
     */
    dnx_data_field_base_ipmf1_nof_fem_array_get_f nof_fem_array_get;
    /**
     * returns define data of nof_fems_per_context
     */
    dnx_data_field_base_ipmf1_nof_fems_per_context_get_f nof_fems_per_context_get;
    /**
     * returns define data of default_strength
     */
    dnx_data_field_base_ipmf1_default_strength_get_f default_strength_get;
    /**
     * returns define data of nof_compare_pairs_in_compare_mode
     */
    dnx_data_field_base_ipmf1_nof_compare_pairs_in_compare_mode_get_f nof_compare_pairs_in_compare_mode_get;
    /**
     * returns define data of nof_compare_keys_in_compare_mode
     */
    dnx_data_field_base_ipmf1_nof_compare_keys_in_compare_mode_get_f nof_compare_keys_in_compare_mode_get;
    /**
     * returns define data of compare_key_size
     */
    dnx_data_field_base_ipmf1_compare_key_size_get_f compare_key_size_get;
    /**
     * returns define data of nof_l4_ops_ranges_legacy
     */
    dnx_data_field_base_ipmf1_nof_l4_ops_ranges_legacy_get_f nof_l4_ops_ranges_legacy_get;
    /**
     * returns define data of nof_ext_l4_ops_ranges
     */
    dnx_data_field_base_ipmf1_nof_ext_l4_ops_ranges_get_f nof_ext_l4_ops_ranges_get;
    /**
     * returns define data of nof_pkt_hdr_ranges
     */
    dnx_data_field_base_ipmf1_nof_pkt_hdr_ranges_get_f nof_pkt_hdr_ranges_get;
    /**
     * returns define data of nof_out_lif_ranges
     */
    dnx_data_field_base_ipmf1_nof_out_lif_ranges_get_f nof_out_lif_ranges_get;
    /**
     * returns define data of fes_key_select_for_zero_bit
     */
    dnx_data_field_base_ipmf1_fes_key_select_for_zero_bit_get_f fes_key_select_for_zero_bit_get;
    /**
     * returns define data of fes_shift_for_zero_bit
     */
    dnx_data_field_base_ipmf1_fes_shift_for_zero_bit_get_f fes_shift_for_zero_bit_get;
    /**
     * returns define data of uses_small_exem
     */
    dnx_data_field_base_ipmf1_uses_small_exem_get_f uses_small_exem_get;
    /**
     * returns define data of uses_large_exem
     */
    dnx_data_field_base_ipmf1_uses_large_exem_get_f uses_large_exem_get;
    /**
     * returns define data of cmp_selection
     */
    dnx_data_field_base_ipmf1_cmp_selection_get_f cmp_selection_get;
    /**
     * returns define data of fes_instruction_size
     */
    dnx_data_field_base_ipmf1_fes_instruction_size_get_f fes_instruction_size_get;
    /**
     * returns define data of fes_pgm_id_offset
     */
    dnx_data_field_base_ipmf1_fes_pgm_id_offset_get_f fes_pgm_id_offset_get;
} dnx_data_if_field_base_ipmf1_t;

/*
 * }
 */

/*
 * SUBMODULE  - BASE_IPMF2:
 * Ingress PMF_2 data. For internal DNX DATA use only. Use stage submodule instead.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf2_feature_nof
} dnx_data_field_base_ipmf2_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_base_ipmf2_feature_get_f) (
    int unit,
    dnx_data_field_base_ipmf2_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_ffc'
 * Number of FFC's per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_ffc_groups_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ipmf2', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_ffc_group_one_lower_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ipmf2', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_ffc_group_one_upper_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_alloc_for_tcam_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_alloc_for_exem_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_dir_ext
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_dir_ext'
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_dir_ext - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_alloc_for_dir_ext_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_mdb_dt
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_mdb_dt'
 * Number of keys available for allocation for use by this specific PMF stage for MDB_DT access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_mdb_dt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_alloc_for_mdb_dt_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_cs_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_contexts'
 * Number of contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_ipmf2', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_program_selection_cam_mask_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_qualifiers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_80B_zones_get_f) (
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_key_zones_get_f) (
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_key_zone_bits_get_f) (
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf2', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_fes_key_select_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf2', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_fes_shift_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_uses_small_exem_get_f) (
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_uses_large_exem_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - BASE_IPMF2:
 * {
 */
/**
 * \brief Interface for field base_ipmf2 data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_base_ipmf2_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_base_ipmf2_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_ffc_groups
     */
    dnx_data_field_base_ipmf2_nof_ffc_groups_get_f nof_ffc_groups_get;
    /**
     * returns define data of ffc_group_one_lower
     */
    dnx_data_field_base_ipmf2_ffc_group_one_lower_get_f ffc_group_one_lower_get;
    /**
     * returns define data of ffc_group_one_upper
     */
    dnx_data_field_base_ipmf2_ffc_group_one_upper_get_f ffc_group_one_upper_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_base_ipmf2_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_keys_alloc
     */
    dnx_data_field_base_ipmf2_nof_keys_alloc_get_f nof_keys_alloc_get;
    /**
     * returns define data of nof_keys_alloc_for_tcam
     */
    dnx_data_field_base_ipmf2_nof_keys_alloc_for_tcam_get_f nof_keys_alloc_for_tcam_get;
    /**
     * returns define data of nof_keys_alloc_for_exem
     */
    dnx_data_field_base_ipmf2_nof_keys_alloc_for_exem_get_f nof_keys_alloc_for_exem_get;
    /**
     * returns define data of nof_keys_alloc_for_dir_ext
     */
    dnx_data_field_base_ipmf2_nof_keys_alloc_for_dir_ext_get_f nof_keys_alloc_for_dir_ext_get;
    /**
     * returns define data of nof_keys_alloc_for_mdb_dt
     */
    dnx_data_field_base_ipmf2_nof_keys_alloc_for_mdb_dt_get_f nof_keys_alloc_for_mdb_dt_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_base_ipmf2_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_base_ipmf2_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_base_ipmf2_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_base_ipmf2_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_base_ipmf2_nof_cs_lines_get_f nof_cs_lines_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_base_ipmf2_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of program_selection_cam_mask_nof_bits
     */
    dnx_data_field_base_ipmf2_program_selection_cam_mask_nof_bits_get_f program_selection_cam_mask_nof_bits_get;
    /**
     * returns define data of nof_qualifiers
     */
    dnx_data_field_base_ipmf2_nof_qualifiers_get_f nof_qualifiers_get;
    /**
     * returns define data of nof_80B_zones
     */
    dnx_data_field_base_ipmf2_nof_80B_zones_get_f nof_80B_zones_get;
    /**
     * returns define data of nof_key_zones
     */
    dnx_data_field_base_ipmf2_nof_key_zones_get_f nof_key_zones_get;
    /**
     * returns define data of nof_key_zone_bits
     */
    dnx_data_field_base_ipmf2_nof_key_zone_bits_get_f nof_key_zone_bits_get;
    /**
     * returns define data of fes_key_select_for_zero_bit
     */
    dnx_data_field_base_ipmf2_fes_key_select_for_zero_bit_get_f fes_key_select_for_zero_bit_get;
    /**
     * returns define data of fes_shift_for_zero_bit
     */
    dnx_data_field_base_ipmf2_fes_shift_for_zero_bit_get_f fes_shift_for_zero_bit_get;
    /**
     * returns define data of uses_small_exem
     */
    dnx_data_field_base_ipmf2_uses_small_exem_get_f uses_small_exem_get;
    /**
     * returns define data of uses_large_exem
     */
    dnx_data_field_base_ipmf2_uses_large_exem_get_f uses_large_exem_get;
} dnx_data_if_field_base_ipmf2_t;

/*
 * }
 */

/*
 * SUBMODULE  - BASE_IPMF3:
 * Ingress PMF_3 (PMF_B) data. For internal DNX DATA use only. Use stage submodule instead.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf3_feature_nof
} dnx_data_field_base_ipmf3_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_base_ipmf3_feature_get_f) (
    int unit,
    dnx_data_field_base_ipmf3_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_ffc'
 * Number of FFC's. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_ffc_groups_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ipmf3', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_ffc_group_one_lower_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ipmf3', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_ffc_group_one_upper_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_alloc_for_tcam_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_alloc_for_exem_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_dir_ext
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_dir_ext'
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_dir_ext - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_alloc_for_dir_ext_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_mdb_dt
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_mdb_dt'
 * Number of keys available for allocation for use by this specific PMF stage for MDB_DT access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_mdb_dt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_alloc_for_mdb_dt_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_fes_programs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_prog_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_ipmf3', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_program_selection_cam_mask_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of cs_scratch_pad_size
 * Module - 'field', Submodule - 'base_ipmf3', data - 'cs_scratch_pad_size'
 * Number of bits taken from general data for context selection.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cs_scratch_pad_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_cs_scratch_pad_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_contexts'
 * Number of Ingress PMF_B programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_cs_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_actions_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_qualifiers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_80B_zones_get_f) (
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_key_zones_get_f) (
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_key_zone_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_bits_in_fes_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_bits_in_fes_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can go into one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_fes_key_selects_on_one_actions_line_get_f) (
    int unit);

/**
 * \brief returns define data of default_strength
 * Module - 'field', Submodule - 'base_ipmf3', data - 'default_strength'
 * Default value for PMF strength. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_default_strength_get_f) (
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_out_lif_ranges'
 * Number of ranges for Out Lif. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_out_lif_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_fes_key_select_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_fes_shift_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_uses_small_exem_get_f) (
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_uses_large_exem_get_f) (
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_fes_instruction_size_get_f) (
    int unit);

/**
 * \brief returns define data of fes_pgm_id_offset
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_pgm_id_offset'
 * FES Program ID offset pointing to IPPD_PMF_FES_PROGRAMm->FES_2ND_INSTRUCTION_LSB_ADDRESSf.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_pgm_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_fes_pgm_id_offset_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_fes_used_by_sdk
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_used_by_sdk'
 * nof fe used by sdk in ipmf3 can be changed per system header soc property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_used_by_sdk - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_fes_used_by_sdk_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - BASE_IPMF3:
 * {
 */
/**
 * \brief Interface for field base_ipmf3 data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_base_ipmf3_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_base_ipmf3_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_ffc_groups
     */
    dnx_data_field_base_ipmf3_nof_ffc_groups_get_f nof_ffc_groups_get;
    /**
     * returns define data of ffc_group_one_lower
     */
    dnx_data_field_base_ipmf3_ffc_group_one_lower_get_f ffc_group_one_lower_get;
    /**
     * returns define data of ffc_group_one_upper
     */
    dnx_data_field_base_ipmf3_ffc_group_one_upper_get_f ffc_group_one_upper_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_base_ipmf3_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_keys_alloc
     */
    dnx_data_field_base_ipmf3_nof_keys_alloc_get_f nof_keys_alloc_get;
    /**
     * returns define data of nof_keys_alloc_for_tcam
     */
    dnx_data_field_base_ipmf3_nof_keys_alloc_for_tcam_get_f nof_keys_alloc_for_tcam_get;
    /**
     * returns define data of nof_keys_alloc_for_exem
     */
    dnx_data_field_base_ipmf3_nof_keys_alloc_for_exem_get_f nof_keys_alloc_for_exem_get;
    /**
     * returns define data of nof_keys_alloc_for_dir_ext
     */
    dnx_data_field_base_ipmf3_nof_keys_alloc_for_dir_ext_get_f nof_keys_alloc_for_dir_ext_get;
    /**
     * returns define data of nof_keys_alloc_for_mdb_dt
     */
    dnx_data_field_base_ipmf3_nof_keys_alloc_for_mdb_dt_get_f nof_keys_alloc_for_mdb_dt_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_base_ipmf3_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_base_ipmf3_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_base_ipmf3_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_base_ipmf3_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_fes_programs
     */
    dnx_data_field_base_ipmf3_nof_fes_programs_get_f nof_fes_programs_get;
    /**
     * returns define data of nof_prog_per_fes
     */
    dnx_data_field_base_ipmf3_nof_prog_per_fes_get_f nof_prog_per_fes_get;
    /**
     * returns define data of program_selection_cam_mask_nof_bits
     */
    dnx_data_field_base_ipmf3_program_selection_cam_mask_nof_bits_get_f program_selection_cam_mask_nof_bits_get;
    /**
     * returns define data of cs_scratch_pad_size
     */
    dnx_data_field_base_ipmf3_cs_scratch_pad_size_get_f cs_scratch_pad_size_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_base_ipmf3_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_base_ipmf3_nof_cs_lines_get_f nof_cs_lines_get;
    /**
     * returns define data of nof_actions
     */
    dnx_data_field_base_ipmf3_nof_actions_get_f nof_actions_get;
    /**
     * returns define data of nof_qualifiers
     */
    dnx_data_field_base_ipmf3_nof_qualifiers_get_f nof_qualifiers_get;
    /**
     * returns define data of nof_80B_zones
     */
    dnx_data_field_base_ipmf3_nof_80B_zones_get_f nof_80B_zones_get;
    /**
     * returns define data of nof_key_zones
     */
    dnx_data_field_base_ipmf3_nof_key_zones_get_f nof_key_zones_get;
    /**
     * returns define data of nof_key_zone_bits
     */
    dnx_data_field_base_ipmf3_nof_key_zone_bits_get_f nof_key_zone_bits_get;
    /**
     * returns define data of nof_bits_in_fes_action
     */
    dnx_data_field_base_ipmf3_nof_bits_in_fes_action_get_f nof_bits_in_fes_action_get;
    /**
     * returns define data of nof_bits_in_fes_key_select
     */
    dnx_data_field_base_ipmf3_nof_bits_in_fes_key_select_get_f nof_bits_in_fes_key_select_get;
    /**
     * returns define data of nof_fes_key_selects_on_one_actions_line
     */
    dnx_data_field_base_ipmf3_nof_fes_key_selects_on_one_actions_line_get_f nof_fes_key_selects_on_one_actions_line_get;
    /**
     * returns define data of default_strength
     */
    dnx_data_field_base_ipmf3_default_strength_get_f default_strength_get;
    /**
     * returns define data of nof_out_lif_ranges
     */
    dnx_data_field_base_ipmf3_nof_out_lif_ranges_get_f nof_out_lif_ranges_get;
    /**
     * returns define data of fes_key_select_for_zero_bit
     */
    dnx_data_field_base_ipmf3_fes_key_select_for_zero_bit_get_f fes_key_select_for_zero_bit_get;
    /**
     * returns define data of fes_shift_for_zero_bit
     */
    dnx_data_field_base_ipmf3_fes_shift_for_zero_bit_get_f fes_shift_for_zero_bit_get;
    /**
     * returns define data of uses_small_exem
     */
    dnx_data_field_base_ipmf3_uses_small_exem_get_f uses_small_exem_get;
    /**
     * returns define data of uses_large_exem
     */
    dnx_data_field_base_ipmf3_uses_large_exem_get_f uses_large_exem_get;
    /**
     * returns define data of fes_instruction_size
     */
    dnx_data_field_base_ipmf3_fes_instruction_size_get_f fes_instruction_size_get;
    /**
     * returns define data of fes_pgm_id_offset
     */
    dnx_data_field_base_ipmf3_fes_pgm_id_offset_get_f fes_pgm_id_offset_get;
    /**
     * returns numeric data of nof_fes_used_by_sdk
     */
    dnx_data_field_base_ipmf3_nof_fes_used_by_sdk_get_f nof_fes_used_by_sdk_get;
} dnx_data_if_field_base_ipmf3_t;

/*
 * }
 */

/*
 * SUBMODULE  - BASE_EPMF:
 * Egress PMF data. For internal DNX DATA use only. Use stage submodule instead.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_epmf_feature_nof
} dnx_data_field_base_epmf_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_base_epmf_feature_get_f) (
    int unit,
    dnx_data_field_base_epmf_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_ffc'
 * Number of FFC's. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_ffc_groups_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_epmf', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_ffc_group_one_lower_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_epmf', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_ffc_group_one_upper_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_keys_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_keys_alloc_for_tcam_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_keys_alloc_for_exem_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_fes_programs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_prog_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_epmf', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory EGQ_PMF_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_program_selection_cam_mask_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_cs_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_contexts'
 * Number of Egress contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_actions_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_qualifiers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_80B_zones'
 * Number of Egress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_80B_zones_get_f) (
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_key_zones'
 * Number of Egress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_key_zones_get_f) (
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_key_zone_bits'
 * Number of Egress PMF key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_key_zone_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_bits_in_fes_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_bits_in_fes_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can applied on one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_fes_key_selects_on_one_actions_line_get_f) (
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges_legacy
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_l4_ops_ranges_legacy'
 * Number of ranges for L4 Ops legacy. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges_legacy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_l4_ops_ranges_legacy_get_f) (
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_fes_key_select_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_fes_shift_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_uses_small_exem_get_f) (
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_uses_large_exem_get_f) (
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_fes_instruction_size_get_f) (
    int unit);

/**
 * \brief returns define data of fes_pgm_id_offset
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_pgm_id_offset'
 * FES Program ID offset pointing to ERPP_PMF_FES_PROGRAMmm->FES_2ND_INSTRUCTION_LSB_ADDRESSf.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_pgm_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_fes_pgm_id_offset_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - BASE_EPMF:
 * {
 */
/**
 * \brief Interface for field base_epmf data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_base_epmf_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_base_epmf_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_ffc_groups
     */
    dnx_data_field_base_epmf_nof_ffc_groups_get_f nof_ffc_groups_get;
    /**
     * returns define data of ffc_group_one_lower
     */
    dnx_data_field_base_epmf_ffc_group_one_lower_get_f ffc_group_one_lower_get;
    /**
     * returns define data of ffc_group_one_upper
     */
    dnx_data_field_base_epmf_ffc_group_one_upper_get_f ffc_group_one_upper_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_base_epmf_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_keys_alloc
     */
    dnx_data_field_base_epmf_nof_keys_alloc_get_f nof_keys_alloc_get;
    /**
     * returns define data of nof_keys_alloc_for_tcam
     */
    dnx_data_field_base_epmf_nof_keys_alloc_for_tcam_get_f nof_keys_alloc_for_tcam_get;
    /**
     * returns define data of nof_keys_alloc_for_exem
     */
    dnx_data_field_base_epmf_nof_keys_alloc_for_exem_get_f nof_keys_alloc_for_exem_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_base_epmf_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_base_epmf_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_base_epmf_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_base_epmf_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_fes_programs
     */
    dnx_data_field_base_epmf_nof_fes_programs_get_f nof_fes_programs_get;
    /**
     * returns define data of nof_prog_per_fes
     */
    dnx_data_field_base_epmf_nof_prog_per_fes_get_f nof_prog_per_fes_get;
    /**
     * returns define data of program_selection_cam_mask_nof_bits
     */
    dnx_data_field_base_epmf_program_selection_cam_mask_nof_bits_get_f program_selection_cam_mask_nof_bits_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_base_epmf_nof_cs_lines_get_f nof_cs_lines_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_base_epmf_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of nof_actions
     */
    dnx_data_field_base_epmf_nof_actions_get_f nof_actions_get;
    /**
     * returns define data of nof_qualifiers
     */
    dnx_data_field_base_epmf_nof_qualifiers_get_f nof_qualifiers_get;
    /**
     * returns define data of nof_80B_zones
     */
    dnx_data_field_base_epmf_nof_80B_zones_get_f nof_80B_zones_get;
    /**
     * returns define data of nof_key_zones
     */
    dnx_data_field_base_epmf_nof_key_zones_get_f nof_key_zones_get;
    /**
     * returns define data of nof_key_zone_bits
     */
    dnx_data_field_base_epmf_nof_key_zone_bits_get_f nof_key_zone_bits_get;
    /**
     * returns define data of nof_bits_in_fes_action
     */
    dnx_data_field_base_epmf_nof_bits_in_fes_action_get_f nof_bits_in_fes_action_get;
    /**
     * returns define data of nof_bits_in_fes_key_select
     */
    dnx_data_field_base_epmf_nof_bits_in_fes_key_select_get_f nof_bits_in_fes_key_select_get;
    /**
     * returns define data of nof_fes_key_selects_on_one_actions_line
     */
    dnx_data_field_base_epmf_nof_fes_key_selects_on_one_actions_line_get_f nof_fes_key_selects_on_one_actions_line_get;
    /**
     * returns define data of nof_l4_ops_ranges_legacy
     */
    dnx_data_field_base_epmf_nof_l4_ops_ranges_legacy_get_f nof_l4_ops_ranges_legacy_get;
    /**
     * returns define data of fes_key_select_for_zero_bit
     */
    dnx_data_field_base_epmf_fes_key_select_for_zero_bit_get_f fes_key_select_for_zero_bit_get;
    /**
     * returns define data of fes_shift_for_zero_bit
     */
    dnx_data_field_base_epmf_fes_shift_for_zero_bit_get_f fes_shift_for_zero_bit_get;
    /**
     * returns define data of uses_small_exem
     */
    dnx_data_field_base_epmf_uses_small_exem_get_f uses_small_exem_get;
    /**
     * returns define data of uses_large_exem
     */
    dnx_data_field_base_epmf_uses_large_exem_get_f uses_large_exem_get;
    /**
     * returns define data of fes_instruction_size
     */
    dnx_data_field_base_epmf_fes_instruction_size_get_f fes_instruction_size_get;
    /**
     * returns define data of fes_pgm_id_offset
     */
    dnx_data_field_base_epmf_fes_pgm_id_offset_get_f fes_pgm_id_offset_get;
} dnx_data_if_field_base_epmf_t;

/*
 * }
 */

/*
 * SUBMODULE  - BASE_IFWD2:
 * IFWD2 data. For internal DNX DATA use only. Use stage submodule instead.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ifwd2_feature_nof
} dnx_data_field_base_ifwd2_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_base_ifwd2_feature_get_f) (
    int unit,
    dnx_data_field_base_ifwd2_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_ffc'
 * Number of FFC's in this specific IFWD2 stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ifwd2_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ifwd2_nof_ffc_groups_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ifwd2', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ifwd2_ffc_group_one_lower_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ifwd2', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ifwd2_ffc_group_one_upper_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_keys'
 * Number of keys available for allocation for use by this specific IFWD2 stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ifwd2_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_contexts'
 * Number of KBP ACL contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ifwd2_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ifwd2_nof_cs_lines_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - BASE_IFWD2:
 * {
 */
/**
 * \brief Interface for field base_ifwd2 data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_base_ifwd2_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_base_ifwd2_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_ffc_groups
     */
    dnx_data_field_base_ifwd2_nof_ffc_groups_get_f nof_ffc_groups_get;
    /**
     * returns define data of ffc_group_one_lower
     */
    dnx_data_field_base_ifwd2_ffc_group_one_lower_get_f ffc_group_one_lower_get;
    /**
     * returns define data of ffc_group_one_upper
     */
    dnx_data_field_base_ifwd2_ffc_group_one_upper_get_f ffc_group_one_upper_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_base_ifwd2_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_base_ifwd2_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_base_ifwd2_nof_cs_lines_get_f nof_cs_lines_get;
} dnx_data_if_field_base_ifwd2_t;

/*
 * }
 */

/*
 * SUBMODULE  - STAGE:
 * Data regarding the field stages
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule stage table stage_info
 * Table info:
 * Per stage information
 */
typedef struct
{
    /**
     * Whether the field_stage is supported on the device
     */
    int valid;
    /**
     * Number of FFC's per context
     */
    int nof_ffc;
    /**
     * Number of FFC Groups
     */
    int nof_ffc_groups;
    /**
     * Min FFC Index for First FFC Group
     */
    int ffc_group_one_lower;
    /**
     * Max FFC Index for First FFC Group
     */
    int ffc_group_one_upper;
    /**
     * Min FFC Index for Second FFC Group
     */
    int ffc_group_two_lower;
    /**
     * Max FFC Index for Second FFC Group
     */
    int ffc_group_two_upper;
    /**
     * Min FFC Index for Thirth FFC Group
     */
    int ffc_group_three_lower;
    /**
     * Max FFC Index for Thirth FFC Group
     */
    int ffc_group_three_upper;
    /**
     * Min FFC Index for Fourth FFC Group
     */
    int ffc_group_four_lower;
    /**
     * Max FFC Index for Fourth FFC Group
     */
    int ffc_group_four_upper;
    /**
     * Number of keys for the this PMF stage
     */
    int nof_keys;
    /**
     * Number of keys available for allocation for use by this specific PMF stage
     */
    int nof_keys_alloc;
    /**
     * Number of keys available for allocation for use by this specific PMF stage for TCAM access
     */
    int nof_keys_alloc_for_tcam;
    /**
     * Number of keys available for allocation for use by this specific PMF stage for EXEM access
     */
    int nof_keys_alloc_for_exem;
    /**
     * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION
     */
    int nof_keys_alloc_for_dir_ext;
    /**
     * Number of keys available for allocation for use by this specific PMF stage for Direct Table MDB access
     */
    int nof_keys_alloc_for_mdb_dt;
    /**
     * Number of masks per FES
     */
    int nof_masks_per_fes;
    /**
     * Number FESes in each FES array
     */
    int nof_fes_id_per_array;
    /**
     * Number of FES arrays
     */
    int nof_fes_array;
    /**
     * Number of FES INSTRUCTIONs per context
     */
    int nof_fes_instruction_per_context;
    /**
     * Number of FES programs
     */
    int nof_fes_programs;
    /**
     * Number of MS bits instruction programs per FES
     */
    int nof_prog_per_fes;
    /**
     * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM
     */
    int program_selection_cam_mask_nof_bits;
    /**
     * Number of bits taken from general data for context selection.
     */
    int cs_scratch_pad_size;
    /**
     * Number of bits taken from general data for context selection.
     */
    int cs_container_5_selected_bits_size;
    /**
     * Number of Ingress PMF_A programs (contexts)
     */
    int nof_contexts;
    /**
     * Number of profiles assigned to iPMF1 contexts in order to create links between iPMF1 and iPMF2 contexts
     */
    int nof_link_profiles;
    /**
     * Number of program selection lines
     */
    int nof_cs_lines;
    /**
     * Number of actions
     */
    int nof_actions;
    /**
     * Number of qualifiers
     */
    int nof_qualifiers;
    /**
     * Number of Ingress PMF 80b dedicated instruction groups
     */
    int nof_80B_zones;
    /**
     * Number of Ingress PMF 80b key zones
     */
    int nof_key_zones;
    /**
     * Number of Ingress PMF 80b key zone bits
     */
    int nof_key_zone_bits;
    /**
     * Number of bits on the output of a FES.
     */
    int nof_bits_in_fes_action;
    /**
     * Number of bits on input to FES.
     */
    int nof_bits_in_fes_key_select;
    /**
     * Number of 'key select's that can go into one line on actions table.('double key' actions are considered one line)
     */
    int nof_fes_key_selects_on_one_actions_line;
    /**
     * The minumum legal value to be set in bit select for a FEM.
     */
    int fem_condition_ms_bit_min_value;
    /**
     * The maximum legal value to be set in bit select for a FEM.
     */
    int fem_condition_ms_bit_max_value;
    /**
     * Number of bit in FEM program representation. This is log2 of the number of fem programs
     */
    int nof_bits_in_fem_programs;
    /**
     * Total number FEM programs available.
     */
    int nof_fem_programs;
    /**
     * Log2 of number of bits on one 'chunk' of input to FEM.
     */
    int log_nof_bits_in_fem_key_select;
    /**
     * Number of bits on one 'chunk' of input to FEM.
     */
    int nof_bits_in_fem_key_select;
    /**
     * Number of bits in the 'step' from one 'key select' to the following. See dbal_enum_value_field_field_pmf_a_fem_key_select_e.
     */
    int fem_key_select_resolution_in_bits;
    /**
     * Log2 of number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table).
     */
    int log_nof_bits_in_fem_map_data_field;
    /**
     * Number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table).
     */
    int nof_bits_in_fem_map_data_field;
    /**
     * Number of bits on action value in IPPC_FEM_*_24B_MAP_TABLE.
     */
    int nof_bits_in_fem_action_fems_2_15;
    /**
     * Number of bits on action value in IPPC_FEM_*_4B_MAP_TABLE.
     */
    int nof_bits_in_fem_action_fems_0_1;
    /**
     * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE.
     */
    int nof_bits_in_fem_action;
    /**
     * Number of bits on fem condition. This is log2 of the number of conditions that may be assigned to each (fem_id,fem_program) combination.
     */
    int nof_bits_in_fem_condition;
    /**
     * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination.
     */
    int nof_fem_condition;
    /**
     * Number of bits on fem map index. This represents log2 of the number of actions that may be assigned to each condition.
     */
    int nof_bits_in_fem_map_index;
    /**
     * Total number fem map indices. This represents the number of actions that may be assigned to each condition.
     */
    int nof_fem_map_index;
    /**
     * Number of bits on fem identifier. This represents the number of FEMs in the system: No. of FEMs is 2^nof_bits_in_fem_id
     */
    int nof_bits_in_fem_id;
    /**
     * Total number 'FEM id's available.
     */
    int nof_fem_id;
    /**
     * Number of FEMs, starting from 'fem_id=0', which have only 4 bits on action value. The rest have 24 bits on action value
     */
    int num_fems_with_short_action;
    /**
     * Number of bits on each of the HW field marked FIELD_SELECT_MAP_*
     */
    int num_bits_in_fem_field_select;
    /**
     * Number of FEMs in each FEM array
     */
    int nof_fem_id_per_array;
    /**
     * Number of FEM arrays
     */
    int nof_fem_array;
    /**
     * Total number of FEMs on all arrays
     */
    int nof_fems_per_context;
    /**
     * Default value for PMF strength
     */
    int default_strength;
    /**
     * Number of bits reserved in Ingress PBUS for header
     */
    int pbus_header_length;
    /**
     * Number of layer records taken from the parser.
     */
    int nof_layer_records;
    /**
     * Number of bits in each layer record.
     */
    int layer_record_size;
    /**
     * Number compare pairs in compare mode
     */
    int nof_compare_pairs_in_compare_mode;
    /**
     * Number compare keys in compare mode
     */
    int nof_compare_keys_in_compare_mode;
    /**
     * Size of the compare key in the system
     */
    int compare_key_size;
    /**
     * Number of ranges for L4 Ops legacy
     */
    int nof_l4_ops_ranges_legacy;
    /**
     * Number of ranges for Extended L4 Ops
     */
    int nof_ext_l4_ops_ranges;
    /**
     * Number of ranges for PKT HDR
     */
    int nof_pkt_hdr_ranges;
    /**
     * Number of ranges for Out Lif
     */
    int nof_out_lif_ranges;
    /**
     * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit).
     */
    int fes_key_select_for_zero_bit;
    /**
     * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit).
     */
    int fes_shift_for_zero_bit;
    /**
     * Indicated if the stage can perform a SEXEM lookup.
     */
    int uses_small_exem;
    /**
     * Indicated if the stage can perform a LEXEM lookup.
     */
    int uses_large_exem;
    /**
     * Compare selection for both keys of 2nd compare, See the CMP_SELECTION field in IPPC_PMF_GENERAL register for additional information
     */
    int cmp_selection;
    /**
     * Number of bits in the main PBUS of the stage (the one used by METADATA qualifiers). Only iPMF2 uses the iPMF1 PBUs as it's main PBUS.
     */
    int nof_bits_main_pbus;
    /**
     * Number of bits in the native PBUS of the stage, if it is different from the main PBUS. Only iPMF2 has a separate native PBUS.
     */
    int nof_bits_native_pbus;
} dnx_data_field_stage_stage_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_stage_feature_nof
} dnx_data_field_stage_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_stage_feature_get_f) (
    int unit,
    dnx_data_field_stage_feature_e feature);

/**
 * \brief get table stage_info entry 
 * Per stage information
 * 
 * \param [in] unit - unit #
 * \param [in] stage - Field stage enum
 * 
 * \return
 *     stage_info - returns the relevant entry values grouped in struct - see dnx_data_field_stage_stage_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_stage_stage_info_t *(
    *dnx_data_field_stage_stage_info_get_f) (
    int unit,
    int stage);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - STAGE:
 * {
 */
/**
 * \brief Interface for field stage data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_stage_feature_get_f feature_get;
    /**
     * get table stage_info entry 
     */
    dnx_data_field_stage_stage_info_get_f stage_info_get;
    /**
     * get general info table about table (for example key size)stage_info info
     */
    dnxc_data_table_info_get_f stage_info_info_get;
} dnx_data_if_field_stage_t;

/*
 * }
 */

/*
 * SUBMODULE  - KBP:
 * KBP data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule kbp table ffc_to_quad_and_group_map
 * Table info:
 * Mapping of the ffc id to its quad anad group
 */
typedef struct
{
    /**
     * Id of the relevant quad for the given ffc id
     */
    uint32 quad_id;
    /**
     * Id of the relevant group for the given ffc id
     */
    uint32 group_id;
} dnx_data_field_kbp_ffc_to_quad_and_group_map_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_kbp_feature_nof
} dnx_data_field_kbp_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_kbp_feature_get_f) (
    int unit,
    dnx_data_field_kbp_feature_e feature);

/**
 * \brief returns define data of nof_fgs
 * Module - 'field', Submodule - 'kbp', data - 'nof_fgs'
 * Number of External TCAM Field Groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fgs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_nof_fgs_get_f) (
    int unit);

/**
 * \brief returns define data of max_single_key_size
 * Module - 'field', Submodule - 'kbp', data - 'max_single_key_size'
 * Maximum single key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_max_single_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_acl_keys_master_max
 * Module - 'field', Submodule - 'kbp', data - 'nof_acl_keys_master_max'
 * The maximum number of keys that can be used by ACL (not FWD) in KBP for a single context
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_acl_keys_master_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_nof_acl_keys_master_max_get_f) (
    int unit);

/**
 * \brief returns define data of nof_acl_keys_fg_max
 * Module - 'field', Submodule - 'kbp', data - 'nof_acl_keys_fg_max'
 * The maximum number of keys that can be used by ACL (not FWD) in KBP for a single field group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_acl_keys_fg_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_nof_acl_keys_fg_max_get_f) (
    int unit);

/**
 * \brief returns define data of min_acl_nof_ffc
 * Module - 'field', Submodule - 'kbp', data - 'min_acl_nof_ffc'
 * Minimum number of FFC's that should be allocated for each context for ACL purposes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_acl_nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_min_acl_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of max_fwd_context_num_for_one_apptype
 * Module - 'field', Submodule - 'kbp', data - 'max_fwd_context_num_for_one_apptype'
 * Maximum number of fwd contexts that could be mapped to an apptype 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fwd_context_num_for_one_apptype - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_max_fwd_context_num_for_one_apptype_get_f) (
    int unit);

/**
 * \brief returns define data of max_acl_context_num
 * Module - 'field', Submodule - 'kbp', data - 'max_acl_context_num'
 * Maximum number of ACL contexts in the KBP 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_acl_context_num - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_max_acl_context_num_get_f) (
    int unit);

/**
 * \brief returns define data of size_apptype_profile_id
 * Module - 'field', Submodule - 'kbp', data - 'size_apptype_profile_id'
 * Size in bits of the apptype profile ID (based on iFED2 ACL context)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     size_apptype_profile_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_size_apptype_profile_id_get_f) (
    int unit);

/**
 * \brief returns define data of key_bmp
 * Module - 'field', Submodule - 'kbp', data - 'key_bmp'
 * bitmap of the key IDs used by the KBP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_bmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_key_bmp_get_f) (
    int unit);

/**
 * \brief returns define data of apptype_user_1st
 * Module - 'field', Submodule - 'kbp', data - 'apptype_user_1st'
 * First User defined Apptype id to avoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     apptype_user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_apptype_user_1st_get_f) (
    int unit);

/**
 * \brief returns define data of apptype_user_nof
 * Module - 'field', Submodule - 'kbp', data - 'apptype_user_nof'
 * Number of user Defined apptypes that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     apptype_user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_apptype_user_nof_get_f) (
    int unit);

/**
 * \brief returns define data of max_payload_size_per_opcode
 * Module - 'field', Submodule - 'kbp', data - 'max_payload_size_per_opcode'
 * The total payload size of the KBP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_payload_size_per_opcode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_max_payload_size_per_opcode_get_f) (
    int unit);

/**
 * \brief get table ffc_to_quad_and_group_map entry 
 * Mapping of the ffc id to its quad anad group
 * 
 * \param [in] unit - unit #
 * \param [in] ffc_id - Id of the required ffc
 * 
 * \return
 *     ffc_to_quad_and_group_map - returns the relevant entry values grouped in struct - see dnx_data_field_kbp_ffc_to_quad_and_group_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_kbp_ffc_to_quad_and_group_map_t *(
    *dnx_data_field_kbp_ffc_to_quad_and_group_map_get_f) (
    int unit,
    int ffc_id);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - KBP:
 * {
 */
/**
 * \brief Interface for field kbp data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_kbp_feature_get_f feature_get;
    /**
     * returns define data of nof_fgs
     */
    dnx_data_field_kbp_nof_fgs_get_f nof_fgs_get;
    /**
     * returns define data of max_single_key_size
     */
    dnx_data_field_kbp_max_single_key_size_get_f max_single_key_size_get;
    /**
     * returns define data of nof_acl_keys_master_max
     */
    dnx_data_field_kbp_nof_acl_keys_master_max_get_f nof_acl_keys_master_max_get;
    /**
     * returns define data of nof_acl_keys_fg_max
     */
    dnx_data_field_kbp_nof_acl_keys_fg_max_get_f nof_acl_keys_fg_max_get;
    /**
     * returns define data of min_acl_nof_ffc
     */
    dnx_data_field_kbp_min_acl_nof_ffc_get_f min_acl_nof_ffc_get;
    /**
     * returns define data of max_fwd_context_num_for_one_apptype
     */
    dnx_data_field_kbp_max_fwd_context_num_for_one_apptype_get_f max_fwd_context_num_for_one_apptype_get;
    /**
     * returns define data of max_acl_context_num
     */
    dnx_data_field_kbp_max_acl_context_num_get_f max_acl_context_num_get;
    /**
     * returns define data of size_apptype_profile_id
     */
    dnx_data_field_kbp_size_apptype_profile_id_get_f size_apptype_profile_id_get;
    /**
     * returns define data of key_bmp
     */
    dnx_data_field_kbp_key_bmp_get_f key_bmp_get;
    /**
     * returns define data of apptype_user_1st
     */
    dnx_data_field_kbp_apptype_user_1st_get_f apptype_user_1st_get;
    /**
     * returns define data of apptype_user_nof
     */
    dnx_data_field_kbp_apptype_user_nof_get_f apptype_user_nof_get;
    /**
     * returns define data of max_payload_size_per_opcode
     */
    dnx_data_field_kbp_max_payload_size_per_opcode_get_f max_payload_size_per_opcode_get;
    /**
     * get table ffc_to_quad_and_group_map entry 
     */
    dnx_data_field_kbp_ffc_to_quad_and_group_map_get_f ffc_to_quad_and_group_map_get;
    /**
     * get general info table about table (for example key size)ffc_to_quad_and_group_map info
     */
    dnxc_data_table_info_get_f ffc_to_quad_and_group_map_info_get;
} dnx_data_if_field_kbp_t;

/*
 * }
 */

/*
 * SUBMODULE  - TCAM:
 * TCAM data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_tcam_feature_nof
} dnx_data_field_tcam_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_tcam_feature_get_f) (
    int unit,
    dnx_data_field_tcam_feature_e feature);

/**
 * \brief returns define data of key_size_half
 * Module - 'field', Submodule - 'tcam', data - 'key_size_half'
 * Half TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_half - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_key_size_half_get_f) (
    int unit);

/**
 * \brief returns define data of key_size_single
 * Module - 'field', Submodule - 'tcam', data - 'key_size_single'
 * Single TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_single - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_key_size_single_get_f) (
    int unit);

/**
 * \brief returns define data of key_size_double
 * Module - 'field', Submodule - 'tcam', data - 'key_size_double'
 * Double TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_double - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_key_size_double_get_f) (
    int unit);

/**
 * \brief returns define data of dt_max_key_size
 * Module - 'field', Submodule - 'tcam', data - 'dt_max_key_size'
 * Maximum key size for TCAM DT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dt_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_dt_max_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of action_size_half
 * Module - 'field', Submodule - 'tcam', data - 'action_size_half'
 * When the key size is half key (80b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_half - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_action_size_half_get_f) (
    int unit);

/**
 * \brief returns define data of action_size_single
 * Module - 'field', Submodule - 'tcam', data - 'action_size_single'
 * When the key size is single key (160b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_single - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_action_size_single_get_f) (
    int unit);

/**
 * \brief returns define data of action_size_double
 * Module - 'field', Submodule - 'tcam', data - 'action_size_double'
 * When the key size is double key (320b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_double - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_action_size_double_get_f) (
    int unit);

/**
 * \brief returns define data of key_mode_size
 * Module - 'field', Submodule - 'tcam', data - 'key_mode_size'
 * Number of bits representing the entry size for each half entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_mode_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_key_mode_size_get_f) (
    int unit);

/**
 * \brief returns define data of entry_size_single_key_hw
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_single_key_hw'
 * The full key size in HW, includingd entry size field, not including payload and valid bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_single_key_hw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_entry_size_single_key_hw_get_f) (
    int unit);

/**
 * \brief returns define data of entry_size_single_valid_bits_hw
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_single_valid_bits_hw'
 * The size of the valid bits in HW.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_single_valid_bits_hw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_entry_size_single_valid_bits_hw_get_f) (
    int unit);

/**
 * \brief returns define data of entry_size_half_payload_hw
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_half_payload_hw'
 * The full payload size in HW for half an entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_half_payload_hw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_entry_size_half_payload_hw_get_f) (
    int unit);

/**
 * \brief returns define data of hw_bank_size
 * Module - 'field', Submodule - 'tcam', data - 'hw_bank_size'
 * Size of a TCAM bank in HW
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hw_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_hw_bank_size_get_f) (
    int unit);

/**
 * \brief returns define data of small_bank_size
 * Module - 'field', Submodule - 'tcam', data - 'small_bank_size'
 * Number of entries per small TCAM bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_small_bank_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_big_bank_lines
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_bank_lines'
 * Number of TCAM big bank lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_bank_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_big_bank_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_small_bank_lines
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_bank_lines'
 * Number of TCAM small bank lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_bank_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_small_bank_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_big_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_banks'
 * Number of TCAM big banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_big_banks_get_f) (
    int unit);

/**
 * \brief returns define data of nof_small_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_banks'
 * Number of TCAM small banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_small_banks_get_f) (
    int unit);

/**
 * \brief returns define data of nof_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_banks'
 * Number of TCAM banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_banks_get_f) (
    int unit);

/**
 * \brief returns define data of nof_payload_tables
 * Module - 'field', Submodule - 'tcam', data - 'nof_payload_tables'
 * Number of action tables
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_payload_tables - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_payload_tables_get_f) (
    int unit);

/**
 * \brief returns define data of nof_access_profiles
 * Module - 'field', Submodule - 'tcam', data - 'nof_access_profiles'
 * Number of TCAM access profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_access_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_access_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of action_width_selector_size
 * Module - 'field', Submodule - 'tcam', data - 'action_width_selector_size'
 * The action width selector size for each bank in each access profile, each bit represents the corresponding 32 bit in the action table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_width_selector_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_action_width_selector_size_get_f) (
    int unit);

/**
 * \brief returns define data of cascaded_data_nof_bits
 * Module - 'field', Submodule - 'tcam', data - 'cascaded_data_nof_bits'
 * Number of TCAM cascaded data bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cascaded_data_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_cascaded_data_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of big_bank_key_nof_bits
 * Module - 'field', Submodule - 'tcam', data - 'big_bank_key_nof_bits'
 * Number of TCAM big bank key bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     big_bank_key_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_big_bank_key_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_entries_160_bits
 * Module - 'field', Submodule - 'tcam', data - 'nof_entries_160_bits'
 * Number of 160 bits TCAM entries; Value: (nof_big_banks*nof_big_bank_lines)+(nof_small_banks*nof_small_bank_lines)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_entries_160_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_entries_160_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_entries_80_bits
 * Module - 'field', Submodule - 'tcam', data - 'nof_entries_80_bits'
 * Number of 80 bits TCAM entries; Value: (2*nof_big_banks*nof_big_bank_lines)+(2*nof_small_banks*nof_small_bank_lines)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_entries_80_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_entries_80_bits_get_f) (
    int unit);

/**
 * \brief returns define data of tcam_banks_size
 * Module - 'field', Submodule - 'tcam', data - 'tcam_banks_size'
 * The size of TCAM_TCAM_BANK which is equal to (nof_big_banks + nof_small_banks) * nof_big_bank_lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_banks_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_tcam_banks_size_get_f) (
    int unit);

/**
 * \brief returns define data of tcam_banks_last_index
 * Module - 'field', Submodule - 'tcam', data - 'tcam_banks_last_index'
 * Last index available in TCAM banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_banks_last_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_tcam_banks_last_index_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tcam_handlers
 * Module - 'field', Submodule - 'tcam', data - 'nof_tcam_handlers'
 * Number of TCAM handlers in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_handlers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_tcam_handlers_get_f) (
    int unit);

/**
 * \brief returns define data of max_prefix_size
 * Module - 'field', Submodule - 'tcam', data - 'max_prefix_size'
 * Maximum prefix size in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_max_prefix_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_prefix_value
 * Module - 'field', Submodule - 'tcam', data - 'max_prefix_value'
 * Maximum prefix value in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_max_prefix_value_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_in_double_key
 * Module - 'field', Submodule - 'tcam', data - 'nof_keys_in_double_key'
 * Number of 160'b key's in double key
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_in_double_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_keys_in_double_key_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_max
 * Module - 'field', Submodule - 'tcam', data - 'nof_keys_max'
 * Number of 160'b key's in one search lookup
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_keys_max_get_f) (
    int unit);

/**
 * \brief returns define data of access_profile_half_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_half_key_mode'
 * Half key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_half_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_access_profile_half_key_mode_get_f) (
    int unit);

/**
 * \brief returns define data of access_profile_single_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_single_key_mode'
 * Single key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_single_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_access_profile_single_key_mode_get_f) (
    int unit);

/**
 * \brief returns define data of access_profile_double_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_double_key_mode'
 * Double key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_double_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_access_profile_double_key_mode_get_f) (
    int unit);

/**
 * \brief returns define data of hit_indication_entries_per_byte
 * Module - 'field', Submodule - 'tcam', data - 'hit_indication_entries_per_byte'
 * Number of entries in byte, in TCAM and CS TCAM HIT and indication memories.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hit_indication_entries_per_byte - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_hit_indication_entries_per_byte_get_f) (
    int unit);

/**
 * \brief returns define data of max_tcam_priority
 * Module - 'field', Submodule - 'tcam', data - 'max_tcam_priority'
 * The biggest valid value for the priority of a TCAM entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tcam_priority - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_max_tcam_priority_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - TCAM:
 * {
 */
/**
 * \brief Interface for field tcam data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_tcam_feature_get_f feature_get;
    /**
     * returns define data of key_size_half
     */
    dnx_data_field_tcam_key_size_half_get_f key_size_half_get;
    /**
     * returns define data of key_size_single
     */
    dnx_data_field_tcam_key_size_single_get_f key_size_single_get;
    /**
     * returns define data of key_size_double
     */
    dnx_data_field_tcam_key_size_double_get_f key_size_double_get;
    /**
     * returns define data of dt_max_key_size
     */
    dnx_data_field_tcam_dt_max_key_size_get_f dt_max_key_size_get;
    /**
     * returns define data of action_size_half
     */
    dnx_data_field_tcam_action_size_half_get_f action_size_half_get;
    /**
     * returns define data of action_size_single
     */
    dnx_data_field_tcam_action_size_single_get_f action_size_single_get;
    /**
     * returns define data of action_size_double
     */
    dnx_data_field_tcam_action_size_double_get_f action_size_double_get;
    /**
     * returns define data of key_mode_size
     */
    dnx_data_field_tcam_key_mode_size_get_f key_mode_size_get;
    /**
     * returns define data of entry_size_single_key_hw
     */
    dnx_data_field_tcam_entry_size_single_key_hw_get_f entry_size_single_key_hw_get;
    /**
     * returns define data of entry_size_single_valid_bits_hw
     */
    dnx_data_field_tcam_entry_size_single_valid_bits_hw_get_f entry_size_single_valid_bits_hw_get;
    /**
     * returns define data of entry_size_half_payload_hw
     */
    dnx_data_field_tcam_entry_size_half_payload_hw_get_f entry_size_half_payload_hw_get;
    /**
     * returns define data of hw_bank_size
     */
    dnx_data_field_tcam_hw_bank_size_get_f hw_bank_size_get;
    /**
     * returns define data of small_bank_size
     */
    dnx_data_field_tcam_small_bank_size_get_f small_bank_size_get;
    /**
     * returns define data of nof_big_bank_lines
     */
    dnx_data_field_tcam_nof_big_bank_lines_get_f nof_big_bank_lines_get;
    /**
     * returns define data of nof_small_bank_lines
     */
    dnx_data_field_tcam_nof_small_bank_lines_get_f nof_small_bank_lines_get;
    /**
     * returns define data of nof_big_banks
     */
    dnx_data_field_tcam_nof_big_banks_get_f nof_big_banks_get;
    /**
     * returns define data of nof_small_banks
     */
    dnx_data_field_tcam_nof_small_banks_get_f nof_small_banks_get;
    /**
     * returns define data of nof_banks
     */
    dnx_data_field_tcam_nof_banks_get_f nof_banks_get;
    /**
     * returns define data of nof_payload_tables
     */
    dnx_data_field_tcam_nof_payload_tables_get_f nof_payload_tables_get;
    /**
     * returns define data of nof_access_profiles
     */
    dnx_data_field_tcam_nof_access_profiles_get_f nof_access_profiles_get;
    /**
     * returns define data of action_width_selector_size
     */
    dnx_data_field_tcam_action_width_selector_size_get_f action_width_selector_size_get;
    /**
     * returns define data of cascaded_data_nof_bits
     */
    dnx_data_field_tcam_cascaded_data_nof_bits_get_f cascaded_data_nof_bits_get;
    /**
     * returns define data of big_bank_key_nof_bits
     */
    dnx_data_field_tcam_big_bank_key_nof_bits_get_f big_bank_key_nof_bits_get;
    /**
     * returns define data of nof_entries_160_bits
     */
    dnx_data_field_tcam_nof_entries_160_bits_get_f nof_entries_160_bits_get;
    /**
     * returns define data of nof_entries_80_bits
     */
    dnx_data_field_tcam_nof_entries_80_bits_get_f nof_entries_80_bits_get;
    /**
     * returns define data of tcam_banks_size
     */
    dnx_data_field_tcam_tcam_banks_size_get_f tcam_banks_size_get;
    /**
     * returns define data of tcam_banks_last_index
     */
    dnx_data_field_tcam_tcam_banks_last_index_get_f tcam_banks_last_index_get;
    /**
     * returns define data of nof_tcam_handlers
     */
    dnx_data_field_tcam_nof_tcam_handlers_get_f nof_tcam_handlers_get;
    /**
     * returns define data of max_prefix_size
     */
    dnx_data_field_tcam_max_prefix_size_get_f max_prefix_size_get;
    /**
     * returns define data of max_prefix_value
     */
    dnx_data_field_tcam_max_prefix_value_get_f max_prefix_value_get;
    /**
     * returns define data of nof_keys_in_double_key
     */
    dnx_data_field_tcam_nof_keys_in_double_key_get_f nof_keys_in_double_key_get;
    /**
     * returns define data of nof_keys_max
     */
    dnx_data_field_tcam_nof_keys_max_get_f nof_keys_max_get;
    /**
     * returns define data of access_profile_half_key_mode
     */
    dnx_data_field_tcam_access_profile_half_key_mode_get_f access_profile_half_key_mode_get;
    /**
     * returns define data of access_profile_single_key_mode
     */
    dnx_data_field_tcam_access_profile_single_key_mode_get_f access_profile_single_key_mode_get;
    /**
     * returns define data of access_profile_double_key_mode
     */
    dnx_data_field_tcam_access_profile_double_key_mode_get_f access_profile_double_key_mode_get;
    /**
     * returns define data of hit_indication_entries_per_byte
     */
    dnx_data_field_tcam_hit_indication_entries_per_byte_get_f hit_indication_entries_per_byte_get;
    /**
     * returns define data of max_tcam_priority
     */
    dnx_data_field_tcam_max_tcam_priority_get_f max_tcam_priority_get;
} dnx_data_if_field_tcam_t;

/*
 * }
 */

/*
 * SUBMODULE  - GROUP:
 * Field Group
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_group_feature_nof
} dnx_data_field_group_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_group_feature_get_f) (
    int unit,
    dnx_data_field_group_feature_e feature);

/**
 * \brief returns define data of nof_fgs
 * Module - 'field', Submodule - 'group', data - 'nof_fgs'
 * Number of Field Groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fgs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_group_nof_fgs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_action_per_fg
 * Module - 'field', Submodule - 'group', data - 'nof_action_per_fg'
 * Number of action per Field Group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_fg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_group_nof_action_per_fg_get_f) (
    int unit);

/**
 * \brief returns define data of nof_quals_per_fg
 * Module - 'field', Submodule - 'group', data - 'nof_quals_per_fg'
 * Number of qualifiers per Field Group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_quals_per_fg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_group_nof_quals_per_fg_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_per_fg_max
 * Module - 'field', Submodule - 'group', data - 'nof_keys_per_fg_max'
 * Maximum number of keys (KBRs) a field group can have.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_per_fg_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_group_nof_keys_per_fg_max_get_f) (
    int unit);

/**
 * \brief returns define data of id_fec_wa
 * Module - 'field', Submodule - 'group', data - 'id_fec_wa'
 * FEC WA is being used in more then one WA context, hence must be created with_id so that other WA can re-use the FG
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     id_fec_wa - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_group_id_fec_wa_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - GROUP:
 * {
 */
/**
 * \brief Interface for field group data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_group_feature_get_f feature_get;
    /**
     * returns define data of nof_fgs
     */
    dnx_data_field_group_nof_fgs_get_f nof_fgs_get;
    /**
     * returns define data of nof_action_per_fg
     */
    dnx_data_field_group_nof_action_per_fg_get_f nof_action_per_fg_get;
    /**
     * returns define data of nof_quals_per_fg
     */
    dnx_data_field_group_nof_quals_per_fg_get_f nof_quals_per_fg_get;
    /**
     * returns define data of nof_keys_per_fg_max
     */
    dnx_data_field_group_nof_keys_per_fg_max_get_f nof_keys_per_fg_max_get;
    /**
     * returns define data of id_fec_wa
     */
    dnx_data_field_group_id_fec_wa_get_f id_fec_wa_get;
} dnx_data_if_field_group_t;

/*
 * }
 */

/*
 * SUBMODULE  - EFES:
 * EFES data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule efes table key_select_properties
 * Table info:
 * The properties of the different key select options
 */
typedef struct
{
    /**
     * Represents the DBAL key select enums of the different stages
     */
    uint8 key_select[DNX_DATA_MAX_FIELD_EFES_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * Number of bits on key select for field IO. If zero than entry is invalid.
     */
    uint8 num_bits[DNX_DATA_MAX_FIELD_EFES_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * The offset on the field IO of the key select
     */
    uint16 lsb[DNX_DATA_MAX_FIELD_EFES_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * The number of LS bits on key select not on the field IO
     */
    uint8 num_bits_not_on_key[DNX_DATA_MAX_FIELD_EFES_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
} dnx_data_field_efes_key_select_properties_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_efes_feature_nof
} dnx_data_field_efes_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_efes_feature_get_f) (
    int unit,
    dnx_data_field_efes_feature_e feature);

/**
 * \brief returns define data of max_nof_key_selects_per_field_io
 * Module - 'field', Submodule - 'efes', data - 'max_nof_key_selects_per_field_io'
 * Number of key selects in table for each field IO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_key_selects_per_field_io - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_efes_max_nof_key_selects_per_field_io_get_f) (
    int unit);

/**
 * \brief get table key_select_properties entry 
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * \param [in] stage - Field stage enum
 * \param [in] field_io - Identifies the source of the information
 * 
 * \return
 *     key_select_properties - returns the relevant entry values grouped in struct - see dnx_data_field_efes_key_select_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_efes_key_select_properties_t *(
    *dnx_data_field_efes_key_select_properties_get_f) (
    int unit,
    int stage,
    int field_io);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - EFES:
 * {
 */
/**
 * \brief Interface for field efes data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_efes_feature_get_f feature_get;
    /**
     * returns define data of max_nof_key_selects_per_field_io
     */
    dnx_data_field_efes_max_nof_key_selects_per_field_io_get_f max_nof_key_selects_per_field_io_get;
    /**
     * get table key_select_properties entry 
     */
    dnx_data_field_efes_key_select_properties_get_f key_select_properties_get;
    /**
     * get general info table about table (for example key size)key_select_properties info
     */
    dnxc_data_table_info_get_f key_select_properties_info_get;
} dnx_data_if_field_efes_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEM:
 * FEM data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule fem table key_select_properties
 * Table info:
 * The properties of the different key select options
 */
typedef struct
{
    /**
     * Represents the DBAL key select enums of the different stages
     */
    uint8 key_select[DNX_DATA_MAX_FIELD_FEM_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * Number of bits on key select for field IO. If zero than entry is invalid.
     */
    uint8 num_bits[DNX_DATA_MAX_FIELD_FEM_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * The offset on the field IO of the key select
     */
    uint16 lsb[DNX_DATA_MAX_FIELD_FEM_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * The number of LS bits on key select not on the field IO
     */
    uint8 num_bits_not_on_key[DNX_DATA_MAX_FIELD_FEM_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
} dnx_data_field_fem_key_select_properties_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_fem_feature_nof
} dnx_data_field_fem_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_fem_feature_get_f) (
    int unit,
    dnx_data_field_fem_feature_e feature);

/**
 * \brief returns define data of max_nof_key_selects_per_field_io
 * Module - 'field', Submodule - 'fem', data - 'max_nof_key_selects_per_field_io'
 * Number of key selects in table for each field IO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_key_selects_per_field_io - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_fem_max_nof_key_selects_per_field_io_get_f) (
    int unit);

/**
 * \brief get table key_select_properties entry 
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * \param [in] field_io - Identifies the source of the information
 * 
 * \return
 *     key_select_properties - returns the relevant entry values grouped in struct - see dnx_data_field_fem_key_select_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_fem_key_select_properties_t *(
    *dnx_data_field_fem_key_select_properties_get_f) (
    int unit,
    int field_io);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - FEM:
 * {
 */
/**
 * \brief Interface for field fem data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_fem_feature_get_f feature_get;
    /**
     * returns define data of max_nof_key_selects_per_field_io
     */
    dnx_data_field_fem_max_nof_key_selects_per_field_io_get_f max_nof_key_selects_per_field_io_get;
    /**
     * get table key_select_properties entry 
     */
    dnx_data_field_fem_key_select_properties_get_f key_select_properties_get;
    /**
     * get general info table about table (for example key size)key_select_properties info
     */
    dnxc_data_table_info_get_f key_select_properties_info_get;
} dnx_data_if_field_fem_t;

/*
 * }
 */

/*
 * SUBMODULE  - CONTEXT:
 * Field Context
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_context_feature_nof
} dnx_data_field_context_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_context_feature_get_f) (
    int unit,
    dnx_data_field_context_feature_e feature);

/**
 * \brief returns define data of default_context
 * Module - 'field', Submodule - 'context', data - 'default_context'
 * Default Context Id (used for Ethernet Packets)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_context
 * Module - 'field', Submodule - 'context', data - 'default_itmh_context'
 * Default Context Id for ITMH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_itmh_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_pph_context
 * Module - 'field', Submodule - 'context', data - 'default_itmh_pph_context'
 * Default Context Id for ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_itmh_pph_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_context
 * Module - 'field', Submodule - 'context', data - 'default_j1_itmh_context'
 * Default Context Id for J1 ITMH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_j1_itmh_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_context
 * Module - 'field', Submodule - 'context', data - 'default_j1_itmh_pph_context'
 * Default Context Id for J1 ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_j1_itmh_pph_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_stacking_context
 * Module - 'field', Submodule - 'context', data - 'default_stacking_context'
 * Default Context Id for Stacking Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_stacking_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_stacking_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_context
 * Module - 'field', Submodule - 'context', data - 'default_oam_context'
 * Default Context Id for OAM Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_oam_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_reflector_context
 * Module - 'field', Submodule - 'context', data - 'default_oam_reflector_context'
 * Default Context Id for OAM downmep reflector Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_reflector_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_oam_reflector_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_learning_2ndpass_context
 * Module - 'field', Submodule - 'context', data - 'default_j1_learning_2ndpass_context'
 * Default Context Id for 2nd pass of J1 Learning WA
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_learning_2ndpass_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_j1_learning_2ndpass_context_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - CONTEXT:
 * {
 */
/**
 * \brief Interface for field context data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_context_feature_get_f feature_get;
    /**
     * returns define data of default_context
     */
    dnx_data_field_context_default_context_get_f default_context_get;
    /**
     * returns define data of default_itmh_context
     */
    dnx_data_field_context_default_itmh_context_get_f default_itmh_context_get;
    /**
     * returns define data of default_itmh_pph_context
     */
    dnx_data_field_context_default_itmh_pph_context_get_f default_itmh_pph_context_get;
    /**
     * returns define data of default_j1_itmh_context
     */
    dnx_data_field_context_default_j1_itmh_context_get_f default_j1_itmh_context_get;
    /**
     * returns define data of default_j1_itmh_pph_context
     */
    dnx_data_field_context_default_j1_itmh_pph_context_get_f default_j1_itmh_pph_context_get;
    /**
     * returns define data of default_stacking_context
     */
    dnx_data_field_context_default_stacking_context_get_f default_stacking_context_get;
    /**
     * returns define data of default_oam_context
     */
    dnx_data_field_context_default_oam_context_get_f default_oam_context_get;
    /**
     * returns define data of default_oam_reflector_context
     */
    dnx_data_field_context_default_oam_reflector_context_get_f default_oam_reflector_context_get;
    /**
     * returns define data of default_j1_learning_2ndpass_context
     */
    dnx_data_field_context_default_j1_learning_2ndpass_context_get_f default_j1_learning_2ndpass_context_get;
} dnx_data_if_field_context_t;

/*
 * }
 */

/*
 * SUBMODULE  - PRESELECTOR:
 * Field Presel
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_preselector_feature_nof
} dnx_data_field_preselector_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_preselector_feature_get_f) (
    int unit,
    dnx_data_field_preselector_feature_e feature);

/**
 * \brief returns define data of default_oam_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for OAM Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_itmh_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_pph_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMHoPPH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH_J1 injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_itmh_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_pph_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH_J1oPPH_J1 injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_oamp_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_pph_oamp_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH_J1oPPH_J1 injected Packets from OAMP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_oamp_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_itmh_pph_oamp_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_stacking_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_stacking_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for Stacking Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_stacking_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_stacking_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_learn_wa_presel_id_1st_pass_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_learn_wa_presel_id_1st_pass_ipmf1'
 * Default Presel in iPMF1 Learn WA 1st Pass
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_learn_wa_presel_id_1st_pass_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_learn_wa_presel_id_1st_pass_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_learn_wa_presel_id_2nd_pass_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_learn_wa_presel_id_2nd_pass_ipmf1'
 * Default Presel in iPMF1 Learn WA 2nd Pass
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_learn_wa_presel_id_2nd_pass_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_learn_wa_presel_id_2nd_pass_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_pph_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_presel_id_ipmf3'
 * Default Presel Id in iPMF1 for ITMHoPPH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_pph_presel_id_ipmf3'
 * Default Presel Id in iPMF1 for ITMH_J1oPPH_J1 injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_roo_ipv4_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_roo_ipv4_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 with ROO Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_roo_ipv4_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_roo_ipv4_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_roo_ipv6_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_roo_ipv6_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 with ROO Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_roo_ipv6_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_roo_ipv6_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 without ROO Packets no RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 without ROO Packets no RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 without ROO Packets with RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 without ROO Packets with RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_ipv4_mc_in_lif_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_ipv4_mc_in_lif_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 MC Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_ipv4_mc_in_lif_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_ipv4_mc_in_lif_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_ipv6_mc_in_lif_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_ipv6_mc_in_lif_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 MC Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_ipv6_mc_in_lif_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_ipv6_mc_in_lif_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_php_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_php_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for MPLS PHP Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_php_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_php_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_swap_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_swap_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for MPLS SWAP Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_swap_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_swap_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_same_port_wa_presel_id_epmf
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_same_port_wa_presel_id_epmf'
 * Default Presel in ePMF Same port WA
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_same_port_wa_presel_id_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_same_port_wa_presel_id_epmf_get_f) (
    int unit);

/**
 * \brief returns define data of default_learn_limit_wa_presel_id_epmf
 * Module - 'field', Submodule - 'preselector', data - 'default_learn_limit_wa_presel_id_epmf'
 * Default Presel in ePMF Learn WA
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_learn_limit_wa_presel_id_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_learn_limit_wa_presel_id_epmf_get_f) (
    int unit);

/**
 * \brief returns define data of num_cs_inlif_profile_entries
 * Module - 'field', Submodule - 'preselector', data - 'num_cs_inlif_profile_entries'
 * The number of CS entries which are used for inlif profile mapping
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_cs_inlif_profile_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_num_cs_inlif_profile_entries_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - PRESELECTOR:
 * {
 */
/**
 * \brief Interface for field preselector data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_preselector_feature_get_f feature_get;
    /**
     * returns define data of default_oam_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_oam_presel_id_ipmf1_get_f default_oam_presel_id_ipmf1_get;
    /**
     * returns define data of default_itmh_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_itmh_presel_id_ipmf1_get_f default_itmh_presel_id_ipmf1_get;
    /**
     * returns define data of default_itmh_pph_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf1_get_f default_itmh_pph_presel_id_ipmf1_get;
    /**
     * returns define data of default_j1_itmh_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_j1_itmh_presel_id_ipmf1_get_f default_j1_itmh_presel_id_ipmf1_get;
    /**
     * returns define data of default_j1_itmh_pph_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf1_get_f default_j1_itmh_pph_presel_id_ipmf1_get;
    /**
     * returns define data of default_j1_itmh_pph_oamp_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_j1_itmh_pph_oamp_presel_id_ipmf1_get_f default_j1_itmh_pph_oamp_presel_id_ipmf1_get;
    /**
     * returns define data of default_stacking_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_stacking_presel_id_ipmf1_get_f default_stacking_presel_id_ipmf1_get;
    /**
     * returns define data of default_j1_learn_wa_presel_id_1st_pass_ipmf1
     */
    dnx_data_field_preselector_default_j1_learn_wa_presel_id_1st_pass_ipmf1_get_f default_j1_learn_wa_presel_id_1st_pass_ipmf1_get;
    /**
     * returns define data of default_j1_learn_wa_presel_id_2nd_pass_ipmf1
     */
    dnx_data_field_preselector_default_j1_learn_wa_presel_id_2nd_pass_ipmf1_get_f default_j1_learn_wa_presel_id_2nd_pass_ipmf1_get;
    /**
     * returns define data of default_itmh_pph_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf3_get_f default_itmh_pph_presel_id_ipmf3_get;
    /**
     * returns define data of default_j1_itmh_pph_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf3_get_f default_j1_itmh_pph_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_roo_ipv4_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_roo_ipv4_presel_id_ipmf3_get_f default_oam_roo_ipv4_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_roo_ipv6_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_roo_ipv6_presel_id_ipmf3_get_f default_oam_roo_ipv6_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3_get_f default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3_get_f default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3_get_f default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3_get_f default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3_get;
    /**
     * returns define data of default_j1_ipv4_mc_in_lif_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_j1_ipv4_mc_in_lif_presel_id_ipmf3_get_f default_j1_ipv4_mc_in_lif_presel_id_ipmf3_get;
    /**
     * returns define data of default_j1_ipv6_mc_in_lif_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_j1_ipv6_mc_in_lif_presel_id_ipmf3_get_f default_j1_ipv6_mc_in_lif_presel_id_ipmf3_get;
    /**
     * returns define data of default_j1_php_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_j1_php_presel_id_ipmf3_get_f default_j1_php_presel_id_ipmf3_get;
    /**
     * returns define data of default_j1_swap_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_j1_swap_presel_id_ipmf3_get_f default_j1_swap_presel_id_ipmf3_get;
    /**
     * returns define data of default_j1_same_port_wa_presel_id_epmf
     */
    dnx_data_field_preselector_default_j1_same_port_wa_presel_id_epmf_get_f default_j1_same_port_wa_presel_id_epmf_get;
    /**
     * returns define data of default_learn_limit_wa_presel_id_epmf
     */
    dnx_data_field_preselector_default_learn_limit_wa_presel_id_epmf_get_f default_learn_limit_wa_presel_id_epmf_get;
    /**
     * returns define data of num_cs_inlif_profile_entries
     */
    dnx_data_field_preselector_num_cs_inlif_profile_entries_get_f num_cs_inlif_profile_entries_get;
} dnx_data_if_field_preselector_t;

/*
 * }
 */

/*
 * SUBMODULE  - QUAL:
 * User Defined Data Qualifiers
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule qual table params
 * Table info:
 * Per stage Per qualifier properties
 */
typedef struct
{
    /**
     * offset on PBUS
     */
    int offset;
    /**
     * signal representing specific qualifier on stage entry
     */
    char *signal;
} dnx_data_field_qual_params_t;

/**
 * \brief Holds values of submodule qual table layer_record_info_ingress
 * Table info:
 * Information about layer record qualifiers in the ingress
 */
typedef struct
{
    /**
     * Whether the layer record is supported on the device
     */
    int valid;
    /**
     * The size of the qualifier in bits
     */
    int size;
    /**
     * The lsb of the qualifier within the layer record
     */
    int offset;
} dnx_data_field_qual_layer_record_info_ingress_t;

/**
 * \brief Holds values of submodule qual table layer_record_info_egress
 * Table info:
 * Information about layer record qualifiers in the egress
 */
typedef struct
{
    /**
     * Whether the layer record is supported on the device
     */
    int valid;
    /**
     * The size of the qualifier in bits
     */
    int size;
    /**
     * The lsb of the qualifier within the layer record
     */
    int offset;
} dnx_data_field_qual_layer_record_info_egress_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_qual_feature_nof
} dnx_data_field_qual_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_qual_feature_get_f) (
    int unit,
    dnx_data_field_qual_feature_e feature);

/**
 * \brief returns define data of user_1st
 * Module - 'field', Submodule - 'qual', data - 'user_1st'
 * First User qualifier id to avoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_user_1st_get_f) (
    int unit);

/**
 * \brief returns define data of user_nof
 * Module - 'field', Submodule - 'qual', data - 'user_nof'
 * Number of User Define Data qualifiers that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_user_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vw_1st
 * Module - 'field', Submodule - 'qual', data - 'vw_1st'
 * First VW qualifier id to avoid overlapping with static or user defined qualifiers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_vw_1st_get_f) (
    int unit);

/**
 * \brief returns define data of vw_nof
 * Module - 'field', Submodule - 'qual', data - 'vw_nof'
 * Number of VW qualifiers that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_vw_nof_get_f) (
    int unit);

/**
 * \brief returns define data of max_bits_in_qual
 * Module - 'field', Submodule - 'qual', data - 'max_bits_in_qual'
 * Maximum number of bits that any qualifier can have
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_bits_in_qual - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_max_bits_in_qual_get_f) (
    int unit);

/**
 * \brief returns define data of ingress_pbus_header_length
 * Module - 'field', Submodule - 'qual', data - 'ingress_pbus_header_length'
 * Number of bits reserved in ingress PBUS for header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_pbus_header_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ingress_pbus_header_length_get_f) (
    int unit);

/**
 * \brief returns define data of egress_pbus_header_length
 * Module - 'field', Submodule - 'qual', data - 'egress_pbus_header_length'
 * Number of bits reserved in egress PBUS for header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_pbus_header_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_egress_pbus_header_length_get_f) (
    int unit);

/**
 * \brief returns define data of ifwd2_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ifwd2_pbus_size'
 * Number of bits in the PBUS of iFWD2
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ifwd2_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ifwd2_pbus_size_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf1_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf1_pbus_size'
 * Number of bits in the PBUS of iPMF1
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf1_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ipmf1_pbus_size_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf2_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf2_pbus_size'
 * Number of bits in the PBUS of iPMF3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf2_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ipmf2_pbus_size_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf3_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf3_pbus_size'
 * Number of bits in the PBUS of iPMF3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf3_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ipmf3_pbus_size_get_f) (
    int unit);

/**
 * \brief returns define data of epmf_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'epmf_pbus_size'
 * Number of bits in the PBUS of ePMF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     epmf_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_epmf_pbus_size_get_f) (
    int unit);

/**
 * \brief returns define data of ingress_nof_layer_records
 * Module - 'field', Submodule - 'qual', data - 'ingress_nof_layer_records'
 * Number of layer records taken from the parser in ingress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ingress_nof_layer_records_get_f) (
    int unit);

/**
 * \brief returns define data of ingress_layer_record_size
 * Module - 'field', Submodule - 'qual', data - 'ingress_layer_record_size'
 * Number of bits in each layer record in ingress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_layer_record_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ingress_layer_record_size_get_f) (
    int unit);

/**
 * \brief returns define data of egress_nof_layer_records
 * Module - 'field', Submodule - 'qual', data - 'egress_nof_layer_records'
 * Number of layer records taken from the parser in egress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_egress_nof_layer_records_get_f) (
    int unit);

/**
 * \brief returns define data of egress_layer_record_size
 * Module - 'field', Submodule - 'qual', data - 'egress_layer_record_size'
 * Number of bits in each layer record in egress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_layer_record_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_egress_layer_record_size_get_f) (
    int unit);

/**
 * \brief returns define data of ac_lif_wide_size
 * Module - 'field', Submodule - 'qual', data - 'ac_lif_wide_size'
 * Size of AC_LIF_WIDE data size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ac_lif_wide_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ac_lif_wide_size_get_f) (
    int unit);

/**
 * \brief get table params entry 
 * Per stage Per qualifier properties
 * 
 * \param [in] unit - unit #
 * \param [in] stage - stage enum
 * \param [in] qual - dnx qualifier
 * 
 * \return
 *     params - returns the relevant entry values grouped in struct - see dnx_data_field_qual_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_qual_params_t *(
    *dnx_data_field_qual_params_get_f) (
    int unit,
    int stage,
    int qual);

/**
 * \brief get table layer_record_info_ingress entry 
 * Information about layer record qualifiers in the ingress
 * 
 * \param [in] unit - unit #
 * \param [in] layer_record - layer record enum
 * 
 * \return
 *     layer_record_info_ingress - returns the relevant entry values grouped in struct - see dnx_data_field_qual_layer_record_info_ingress_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_qual_layer_record_info_ingress_t *(
    *dnx_data_field_qual_layer_record_info_ingress_get_f) (
    int unit,
    int layer_record);

/**
 * \brief get table layer_record_info_egress entry 
 * Information about layer record qualifiers in the egress
 * 
 * \param [in] unit - unit #
 * \param [in] layer_record - layer record enum
 * 
 * \return
 *     layer_record_info_egress - returns the relevant entry values grouped in struct - see dnx_data_field_qual_layer_record_info_egress_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_qual_layer_record_info_egress_t *(
    *dnx_data_field_qual_layer_record_info_egress_get_f) (
    int unit,
    int layer_record);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - QUAL:
 * {
 */
/**
 * \brief Interface for field qual data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_qual_feature_get_f feature_get;
    /**
     * returns define data of user_1st
     */
    dnx_data_field_qual_user_1st_get_f user_1st_get;
    /**
     * returns define data of user_nof
     */
    dnx_data_field_qual_user_nof_get_f user_nof_get;
    /**
     * returns define data of vw_1st
     */
    dnx_data_field_qual_vw_1st_get_f vw_1st_get;
    /**
     * returns define data of vw_nof
     */
    dnx_data_field_qual_vw_nof_get_f vw_nof_get;
    /**
     * returns define data of max_bits_in_qual
     */
    dnx_data_field_qual_max_bits_in_qual_get_f max_bits_in_qual_get;
    /**
     * returns define data of ingress_pbus_header_length
     */
    dnx_data_field_qual_ingress_pbus_header_length_get_f ingress_pbus_header_length_get;
    /**
     * returns define data of egress_pbus_header_length
     */
    dnx_data_field_qual_egress_pbus_header_length_get_f egress_pbus_header_length_get;
    /**
     * returns define data of ifwd2_pbus_size
     */
    dnx_data_field_qual_ifwd2_pbus_size_get_f ifwd2_pbus_size_get;
    /**
     * returns define data of ipmf1_pbus_size
     */
    dnx_data_field_qual_ipmf1_pbus_size_get_f ipmf1_pbus_size_get;
    /**
     * returns define data of ipmf2_pbus_size
     */
    dnx_data_field_qual_ipmf2_pbus_size_get_f ipmf2_pbus_size_get;
    /**
     * returns define data of ipmf3_pbus_size
     */
    dnx_data_field_qual_ipmf3_pbus_size_get_f ipmf3_pbus_size_get;
    /**
     * returns define data of epmf_pbus_size
     */
    dnx_data_field_qual_epmf_pbus_size_get_f epmf_pbus_size_get;
    /**
     * returns define data of ingress_nof_layer_records
     */
    dnx_data_field_qual_ingress_nof_layer_records_get_f ingress_nof_layer_records_get;
    /**
     * returns define data of ingress_layer_record_size
     */
    dnx_data_field_qual_ingress_layer_record_size_get_f ingress_layer_record_size_get;
    /**
     * returns define data of egress_nof_layer_records
     */
    dnx_data_field_qual_egress_nof_layer_records_get_f egress_nof_layer_records_get;
    /**
     * returns define data of egress_layer_record_size
     */
    dnx_data_field_qual_egress_layer_record_size_get_f egress_layer_record_size_get;
    /**
     * returns define data of ac_lif_wide_size
     */
    dnx_data_field_qual_ac_lif_wide_size_get_f ac_lif_wide_size_get;
    /**
     * get table params entry 
     */
    dnx_data_field_qual_params_get_f params_get;
    /**
     * get general info table about table (for example key size)params info
     */
    dnxc_data_table_info_get_f params_info_get;
    /**
     * get table layer_record_info_ingress entry 
     */
    dnx_data_field_qual_layer_record_info_ingress_get_f layer_record_info_ingress_get;
    /**
     * get general info table about table (for example key size)layer_record_info_ingress info
     */
    dnxc_data_table_info_get_f layer_record_info_ingress_info_get;
    /**
     * get table layer_record_info_egress entry 
     */
    dnx_data_field_qual_layer_record_info_egress_get_f layer_record_info_egress_get;
    /**
     * get general info table about table (for example key size)layer_record_info_egress info
     */
    dnxc_data_table_info_get_f layer_record_info_egress_info_get;
} dnx_data_if_field_qual_t;

/*
 * }
 */

/*
 * SUBMODULE  - ACTION:
 * User Define Data Actions
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_action_feature_nof
} dnx_data_field_action_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_action_feature_get_f) (
    int unit,
    dnx_data_field_action_feature_e feature);

/**
 * \brief returns define data of user_1st
 * Module - 'field', Submodule - 'action', data - 'user_1st'
 * First user action id to avaoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_action_user_1st_get_f) (
    int unit);

/**
 * \brief returns define data of user_nof
 * Module - 'field', Submodule - 'action', data - 'user_nof'
 * Number of User Define Data actions that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_action_user_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vw_1st
 * Module - 'field', Submodule - 'action', data - 'vw_1st'
 * First VW action id to avoid overlapping with static or user defined qualifiers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_action_vw_1st_get_f) (
    int unit);

/**
 * \brief returns define data of vw_nof
 * Module - 'field', Submodule - 'action', data - 'vw_nof'
 * Number of VW action that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_action_vw_nof_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - ACTION:
 * {
 */
/**
 * \brief Interface for field action data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_action_feature_get_f feature_get;
    /**
     * returns define data of user_1st
     */
    dnx_data_field_action_user_1st_get_f user_1st_get;
    /**
     * returns define data of user_nof
     */
    dnx_data_field_action_user_nof_get_f user_nof_get;
    /**
     * returns define data of vw_1st
     */
    dnx_data_field_action_vw_1st_get_f vw_1st_get;
    /**
     * returns define data of vw_nof
     */
    dnx_data_field_action_vw_nof_get_f vw_nof_get;
} dnx_data_if_field_action_t;

/*
 * }
 */

/*
 * SUBMODULE  - VIRTUAL_WIRE:
 * virtual_wires
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule virtual_wire table signal_mapping
 * Table info:
 * Per stage per signal, how it maps to standard 1 qualifiers and actions
 */
typedef struct
{
    /**
     * Name of the signal.
     */
    char *signal_name;
    /**
     * Standard 1 qualifier that correlates to the signal
     */
    int mapped_qual;
    /**
     * Offset on from the start of the standard 1 qualifier
     */
    int offset_from_qual;
    /**
     * Standard 1 action that correlates to the signal
     */
    int mapped_action[DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF];
    /**
     * Offset on from the start of the signal for the action
     */
    int action_offset[DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF];
} dnx_data_field_virtual_wire_signal_mapping_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_virtual_wire_feature_nof
} dnx_data_field_virtual_wire_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_virtual_wire_feature_get_f) (
    int unit,
    dnx_data_field_virtual_wire_feature_e feature);

/**
 * \brief returns define data of signals_nof
 * Module - 'field', Submodule - 'virtual_wire', data - 'signals_nof'
 * Number of elements in the table vw_quals.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     signals_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_virtual_wire_signals_nof_get_f) (
    int unit);

/**
 * \brief returns define data of actions_per_signal_nof
 * Module - 'field', Submodule - 'virtual_wire', data - 'actions_per_signal_nof'
 * Maximum number of actions that write to a signal.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     actions_per_signal_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_virtual_wire_actions_per_signal_nof_get_f) (
    int unit);

/**
 * \brief returns define data of general_data_user_general_containers_size
 * Module - 'field', Submodule - 'virtual_wire', data - 'general_data_user_general_containers_size'
 * The size in bits of the user_general part of the general_data (before the comp_general_data part).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     general_data_user_general_containers_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_virtual_wire_general_data_user_general_containers_size_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf1_general_data_index
 * Module - 'field', Submodule - 'virtual_wire', data - 'ipmf1_general_data_index'
 * The index in signal_qual_mapping table of the general data signal for iPMF1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf1_general_data_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_virtual_wire_ipmf1_general_data_index_get_f) (
    int unit);

/**
 * \brief get table signal_mapping entry 
 * Per stage per signal, how it maps to standard 1 qualifiers and actions
 * 
 * \param [in] unit - unit #
 * \param [in] stage - stage enum
 * \param [in] signal_id - A local index for the entry
 * 
 * \return
 *     signal_mapping - returns the relevant entry values grouped in struct - see dnx_data_field_virtual_wire_signal_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_virtual_wire_signal_mapping_t *(
    *dnx_data_field_virtual_wire_signal_mapping_get_f) (
    int unit,
    int stage,
    int signal_id);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - VIRTUAL_WIRE:
 * {
 */
/**
 * \brief Interface for field virtual_wire data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_virtual_wire_feature_get_f feature_get;
    /**
     * returns define data of signals_nof
     */
    dnx_data_field_virtual_wire_signals_nof_get_f signals_nof_get;
    /**
     * returns define data of actions_per_signal_nof
     */
    dnx_data_field_virtual_wire_actions_per_signal_nof_get_f actions_per_signal_nof_get;
    /**
     * returns define data of general_data_user_general_containers_size
     */
    dnx_data_field_virtual_wire_general_data_user_general_containers_size_get_f general_data_user_general_containers_size_get;
    /**
     * returns define data of ipmf1_general_data_index
     */
    dnx_data_field_virtual_wire_ipmf1_general_data_index_get_f ipmf1_general_data_index_get;
    /**
     * get table signal_mapping entry 
     */
    dnx_data_field_virtual_wire_signal_mapping_get_f signal_mapping_get;
    /**
     * get general info table about table (for example key size)signal_mapping info
     */
    dnxc_data_table_info_get_f signal_mapping_info_get;
} dnx_data_if_field_virtual_wire_t;

/*
 * }
 */

/*
 * SUBMODULE  - PROFILE_BITS:
 * PMF Dedicated bits in profiles
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_profile_bits_feature_nof
} dnx_data_field_profile_bits_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_profile_bits_feature_get_f) (
    int unit,
    dnx_data_field_profile_bits_feature_e feature);

/**
 * \brief returns define data of nof_ing_in_lif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_ing_in_lif'
 * Number of reserved bits for Ingress FP in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ing_in_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_nof_ing_in_lif_get_f) (
    int unit);

/**
 * \brief returns define data of nof_eg_in_lif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_eg_in_lif'
 * Number of reserved bits for Egress FP in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eg_in_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_nof_eg_in_lif_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ing_eth_rif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_ing_eth_rif'
 * Number of reserved bits for Ingress FP in in_rif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ing_eth_rif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_nof_ing_eth_rif_get_f) (
    int unit);

/**
 * \brief returns define data of nof_eg_eth_rif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_eg_eth_rif'
 * Number of reserved bits for Egress FP in in_rif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eg_eth_rif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_nof_eg_eth_rif_get_f) (
    int unit);

/**
 * \brief returns define data of ingress_pp_port_key_gen_var_size
 * Module - 'field', Submodule - 'profile_bits', data - 'ingress_pp_port_key_gen_var_size'
 * Number of bits available on the key_ken_per per PP port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_pp_port_key_gen_var_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_ingress_pp_port_key_gen_var_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_port_profile_size
 * Module - 'field', Submodule - 'profile_bits', data - 'max_port_profile_size'
 * The maximum number in bits of all port profiles hw memories possible
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_port_profile_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_max_port_profile_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_port_profile
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_bits_in_port_profile'
 * The number of bits used by the PMF for port profiles. Note that the actual number may be lower in some stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_port_profile - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_nof_bits_in_port_profile_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_ingress_pp_port_general_data
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_bits_in_ingress_pp_port_general_data'
 * The number of bits used by the PMF for per PP port general data.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_ingress_pp_port_general_data - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_nof_bits_in_ingress_pp_port_general_data_get_f) (
    int unit);

/**
 * \brief returns numeric data of pmf_sexem3_stage
 * Module - 'field', Submodule - 'profile_bits', data - 'pmf_sexem3_stage'
 * Determines using SOC property if we use SEXEM3 in iPMF2 or iPMF3.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pmf_sexem3_stage - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_pmf_sexem3_stage_get_f) (
    int unit);

/**
 * \brief returns numeric data of pmf_map_stage
 * Module - 'field', Submodule - 'profile_bits', data - 'pmf_map_stage'
 * Determines using SOC property if we use MAP in iPMF1/iPMF2 or iPMF3.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pmf_map_stage - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_pmf_map_stage_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - PROFILE_BITS:
 * {
 */
/**
 * \brief Interface for field profile_bits data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_profile_bits_feature_get_f feature_get;
    /**
     * returns define data of nof_ing_in_lif
     */
    dnx_data_field_profile_bits_nof_ing_in_lif_get_f nof_ing_in_lif_get;
    /**
     * returns define data of nof_eg_in_lif
     */
    dnx_data_field_profile_bits_nof_eg_in_lif_get_f nof_eg_in_lif_get;
    /**
     * returns define data of nof_ing_eth_rif
     */
    dnx_data_field_profile_bits_nof_ing_eth_rif_get_f nof_ing_eth_rif_get;
    /**
     * returns define data of nof_eg_eth_rif
     */
    dnx_data_field_profile_bits_nof_eg_eth_rif_get_f nof_eg_eth_rif_get;
    /**
     * returns define data of ingress_pp_port_key_gen_var_size
     */
    dnx_data_field_profile_bits_ingress_pp_port_key_gen_var_size_get_f ingress_pp_port_key_gen_var_size_get;
    /**
     * returns define data of max_port_profile_size
     */
    dnx_data_field_profile_bits_max_port_profile_size_get_f max_port_profile_size_get;
    /**
     * returns define data of nof_bits_in_port_profile
     */
    dnx_data_field_profile_bits_nof_bits_in_port_profile_get_f nof_bits_in_port_profile_get;
    /**
     * returns define data of nof_bits_in_ingress_pp_port_general_data
     */
    dnx_data_field_profile_bits_nof_bits_in_ingress_pp_port_general_data_get_f nof_bits_in_ingress_pp_port_general_data_get;
    /**
     * returns numeric data of pmf_sexem3_stage
     */
    dnx_data_field_profile_bits_pmf_sexem3_stage_get_f pmf_sexem3_stage_get;
    /**
     * returns numeric data of pmf_map_stage
     */
    dnx_data_field_profile_bits_pmf_map_stage_get_f pmf_map_stage_get;
} dnx_data_if_field_profile_bits_t;

/*
 * }
 */

/*
 * SUBMODULE  - DIR_EXT:
 * Direct Extraction Data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_dir_ext_feature_nof
} dnx_data_field_dir_ext_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_dir_ext_feature_get_f) (
    int unit,
    dnx_data_field_dir_ext_feature_e feature);

/**
 * \brief returns define data of half_key_size
 * Module - 'field', Submodule - 'dir_ext', data - 'half_key_size'
 * Half key size of direct extraction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     half_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_dir_ext_half_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of single_key_size
 * Module - 'field', Submodule - 'dir_ext', data - 'single_key_size'
 * Single key size of direct extraction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_dir_ext_single_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of double_key_size
 * Module - 'field', Submodule - 'dir_ext', data - 'double_key_size'
 * Double key size of direct extraction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     double_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_dir_ext_double_key_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - DIR_EXT:
 * {
 */
/**
 * \brief Interface for field dir_ext data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_dir_ext_feature_get_f feature_get;
    /**
     * returns define data of half_key_size
     */
    dnx_data_field_dir_ext_half_key_size_get_f half_key_size_get;
    /**
     * returns define data of single_key_size
     */
    dnx_data_field_dir_ext_single_key_size_get_f single_key_size_get;
    /**
     * returns define data of double_key_size
     */
    dnx_data_field_dir_ext_double_key_size_get_f double_key_size_get;
} dnx_data_if_field_dir_ext_t;

/*
 * }
 */

/*
 * SUBMODULE  - STATE_TABLE:
 * State Table data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_state_table_feature_nof
} dnx_data_field_state_table_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_state_table_feature_get_f) (
    int unit,
    dnx_data_field_state_table_feature_e feature);

/**
 * \brief returns define data of key_size
 * Module - 'field', Submodule - 'state_table', data - 'key_size'
 * Size of the state table key in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of address_max
 * Module - 'field', Submodule - 'state_table', data - 'address_max'
 * Max address for the state table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_address_max_get_f) (
    int unit);

/**
 * \brief returns define data of address_size
 * Module - 'field', Submodule - 'state_table', data - 'address_size'
 * Size of the address field in State Table in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_address_size_get_f) (
    int unit);

/**
 * \brief returns define data of data_size
 * Module - 'field', Submodule - 'state_table', data - 'data_size'
 * Size of the data field in State Table in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_data_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - STATE_TABLE:
 * {
 */
/**
 * \brief Interface for field state_table data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_state_table_feature_get_f feature_get;
    /**
     * returns define data of key_size
     */
    dnx_data_field_state_table_key_size_get_f key_size_get;
    /**
     * returns define data of address_max
     */
    dnx_data_field_state_table_address_max_get_f address_max_get;
    /**
     * returns define data of address_size
     */
    dnx_data_field_state_table_address_size_get_f address_size_get;
    /**
     * returns define data of data_size
     */
    dnx_data_field_state_table_data_size_get_f data_size_get;
} dnx_data_if_field_state_table_t;

/*
 * }
 */

/*
 * SUBMODULE  - MAP:
 * MAP data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_map_feature_nof
} dnx_data_field_map_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_map_feature_get_f) (
    int unit,
    dnx_data_field_map_feature_e feature);

/**
 * \brief returns define data of key_size
 * Module - 'field', Submodule - 'map', data - 'key_size'
 * Size of the MAP key in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of action_size_small
 * Module - 'field', Submodule - 'map', data - 'action_size_small'
 * Size of the small MAP action in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_small - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_action_size_small_get_f) (
    int unit);

/**
 * \brief returns define data of action_size_mid
 * Module - 'field', Submodule - 'map', data - 'action_size_mid'
 * Size of the mid MAP action in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_mid - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_action_size_mid_get_f) (
    int unit);

/**
 * \brief returns define data of action_size_large
 * Module - 'field', Submodule - 'map', data - 'action_size_large'
 * Size of the large MAP action in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_large - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_action_size_large_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf1_key_select
 * Module - 'field', Submodule - 'map', data - 'ipmf1_key_select'
 * The PMF key used for MAP lookup by iPMF1. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf1_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_ipmf1_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf2_key_select
 * Module - 'field', Submodule - 'map', data - 'ipmf2_key_select'
 * The PMF key used for MAP lookup by iPMF2. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf2_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_ipmf2_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf3_key_select
 * Module - 'field', Submodule - 'map', data - 'ipmf3_key_select'
 * The PMF key used for MAP lookup by iPMF3. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf3_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_ipmf3_key_select_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - MAP:
 * {
 */
/**
 * \brief Interface for field map data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_map_feature_get_f feature_get;
    /**
     * returns define data of key_size
     */
    dnx_data_field_map_key_size_get_f key_size_get;
    /**
     * returns define data of action_size_small
     */
    dnx_data_field_map_action_size_small_get_f action_size_small_get;
    /**
     * returns define data of action_size_mid
     */
    dnx_data_field_map_action_size_mid_get_f action_size_mid_get;
    /**
     * returns define data of action_size_large
     */
    dnx_data_field_map_action_size_large_get_f action_size_large_get;
    /**
     * returns define data of ipmf1_key_select
     */
    dnx_data_field_map_ipmf1_key_select_get_f ipmf1_key_select_get;
    /**
     * returns define data of ipmf2_key_select
     */
    dnx_data_field_map_ipmf2_key_select_get_f ipmf2_key_select_get;
    /**
     * returns define data of ipmf3_key_select
     */
    dnx_data_field_map_ipmf3_key_select_get_f ipmf3_key_select_get;
} dnx_data_if_field_map_t;

/*
 * }
 */

/*
 * SUBMODULE  - HASH:
 * Hash (CRC) values
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_hash_feature_nof
} dnx_data_field_hash_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_hash_feature_get_f) (
    int unit,
    dnx_data_field_hash_feature_e feature);

/**
 * \brief returns define data of max_key_size
 * Module - 'field', Submodule - 'hash', data - 'max_key_size'
 * maximal key size Field Group type 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_hash_max_key_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - HASH:
 * {
 */
/**
 * \brief Interface for field hash data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_hash_feature_get_f feature_get;
    /**
     * returns define data of max_key_size
     */
    dnx_data_field_hash_max_key_size_get_f max_key_size_get;
} dnx_data_if_field_hash_t;

/*
 * }
 */

/*
 * SUBMODULE  - UDH:
 * User Defined Headers defines
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_udh_feature_nof
} dnx_data_field_udh_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_udh_feature_get_f) (
    int unit,
    dnx_data_field_udh_feature_e feature);

/**
 * \brief returns define data of type_count
 * Module - 'field', Submodule - 'udh', data - 'type_count'
 * UDH Type count
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_count - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_type_count_get_f) (
    int unit);

/**
 * \brief returns define data of type_0_length
 * Module - 'field', Submodule - 'udh', data - 'type_0_length'
 * UDH Type 0 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_0_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_type_0_length_get_f) (
    int unit);

/**
 * \brief returns define data of type_1_length
 * Module - 'field', Submodule - 'udh', data - 'type_1_length'
 * UDH Type 1 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_1_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_type_1_length_get_f) (
    int unit);

/**
 * \brief returns define data of type_2_length
 * Module - 'field', Submodule - 'udh', data - 'type_2_length'
 * UDH Type 2 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_2_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_type_2_length_get_f) (
    int unit);

/**
 * \brief returns define data of type_3_length
 * Module - 'field', Submodule - 'udh', data - 'type_3_length'
 * UDH Type 3 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_3_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_type_3_length_get_f) (
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_0
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_0'
 * J1 Mode UDH related size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_0 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_field_class_id_size_0_get_f) (
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_1
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_1'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_field_class_id_size_1_get_f) (
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_2
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_2'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_field_class_id_size_2_get_f) (
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_3
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_3'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_field_class_id_size_3_get_f) (
    int unit);

/**
 * \brief returns numeric data of field_class_id_total_size
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_total_size'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_total_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_field_class_id_total_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - UDH:
 * {
 */
/**
 * \brief Interface for field udh data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_udh_feature_get_f feature_get;
    /**
     * returns define data of type_count
     */
    dnx_data_field_udh_type_count_get_f type_count_get;
    /**
     * returns define data of type_0_length
     */
    dnx_data_field_udh_type_0_length_get_f type_0_length_get;
    /**
     * returns define data of type_1_length
     */
    dnx_data_field_udh_type_1_length_get_f type_1_length_get;
    /**
     * returns define data of type_2_length
     */
    dnx_data_field_udh_type_2_length_get_f type_2_length_get;
    /**
     * returns define data of type_3_length
     */
    dnx_data_field_udh_type_3_length_get_f type_3_length_get;
    /**
     * returns numeric data of field_class_id_size_0
     */
    dnx_data_field_udh_field_class_id_size_0_get_f field_class_id_size_0_get;
    /**
     * returns numeric data of field_class_id_size_1
     */
    dnx_data_field_udh_field_class_id_size_1_get_f field_class_id_size_1_get;
    /**
     * returns numeric data of field_class_id_size_2
     */
    dnx_data_field_udh_field_class_id_size_2_get_f field_class_id_size_2_get;
    /**
     * returns numeric data of field_class_id_size_3
     */
    dnx_data_field_udh_field_class_id_size_3_get_f field_class_id_size_3_get;
    /**
     * returns numeric data of field_class_id_total_size
     */
    dnx_data_field_udh_field_class_id_total_size_get_f field_class_id_total_size_get;
} dnx_data_if_field_udh_t;

/*
 * }
 */

/*
 * SUBMODULE  - SYSTEM_HEADERS:
 * System headers definitions
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule system_headers table system_header_profiles
 * Table info:
 * Contains all system headers profiles defined in this device
 */
typedef struct
{
    /**
     * profile name
     */
    char *name;
    /**
     * Defines whether to build FTMH header or not
     */
    uint8 build_ftmh;
    /**
     * Defines whether to build TSH header or not
     */
    uint8 build_tsh;
    /**
     * Defines whether to build PPH header or not
     */
    uint8 build_pph;
    /**
     * Defines whether to build UDH header or not
     */
    uint8 build_udh;
    /**
     * Defines whether to never add PPH Learn Ext.
     */
    uint8 never_add_pph_learn_ext;
} dnx_data_field_system_headers_system_header_profiles_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_system_headers_feature_nof
} dnx_data_field_system_headers_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_system_headers_feature_get_f) (
    int unit,
    dnx_data_field_system_headers_feature_e feature);

/**
 * \brief returns define data of nof_profiles
 * Module - 'field', Submodule - 'system_headers', data - 'nof_profiles'
 * Number of system headers in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_system_headers_nof_profiles_get_f) (
    int unit);

/**
 * \brief returns numeric data of pph_learn_ext_disable
 * Module - 'field', Submodule - 'system_headers', data - 'pph_learn_ext_disable'
 * Never add learn_ext in system headers unlesee FP required. Used by default header_profile only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pph_learn_ext_disable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_system_headers_pph_learn_ext_disable_get_f) (
    int unit);

/**
 * \brief get table system_header_profiles entry 
 * Contains all system headers profiles defined in this device
 * 
 * \param [in] unit - unit #
 * \param [in] system_header_profile - System header profile number
 * 
 * \return
 *     system_header_profiles - returns the relevant entry values grouped in struct - see dnx_data_field_system_headers_system_header_profiles_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_system_headers_system_header_profiles_t *(
    *dnx_data_field_system_headers_system_header_profiles_get_f) (
    int unit,
    int system_header_profile);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - SYSTEM_HEADERS:
 * {
 */
/**
 * \brief Interface for field system_headers data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_system_headers_feature_get_f feature_get;
    /**
     * returns define data of nof_profiles
     */
    dnx_data_field_system_headers_nof_profiles_get_f nof_profiles_get;
    /**
     * returns numeric data of pph_learn_ext_disable
     */
    dnx_data_field_system_headers_pph_learn_ext_disable_get_f pph_learn_ext_disable_get;
    /**
     * get table system_header_profiles entry 
     */
    dnx_data_field_system_headers_system_header_profiles_get_f system_header_profiles_get;
    /**
     * get general info table about table (for example key size)system_header_profiles info
     */
    dnxc_data_table_info_get_f system_header_profiles_info_get;
} dnx_data_if_field_system_headers_t;

/*
 * }
 */

/*
 * SUBMODULE  - EXEM:
 * exem values
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_exem_feature_nof
} dnx_data_field_exem_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_exem_feature_get_f) (
    int unit,
    dnx_data_field_exem_feature_e feature);

/**
 * \brief returns define data of small_app_db_id_size
 * Module - 'field', Submodule - 'exem', data - 'small_app_db_id_size'
 * Number of bits used application db
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_app_db_id_size_get_f) (
    int unit);

/**
 * \brief returns define data of large_app_db_id_size
 * Module - 'field', Submodule - 'exem', data - 'large_app_db_id_size'
 * Number of bits used application db
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_app_db_id_size_get_f) (
    int unit);

/**
 * \brief returns define data of small_max_key_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_key_size'
 * Small EXEM key size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_max_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of large_max_key_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_key_size'
 * Large EXEM key size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_max_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of small_max_result_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_result_size'
 * Small EXEM result (payload) size in bits, including VMV
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_result_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_max_result_size_get_f) (
    int unit);

/**
 * \brief returns define data of large_max_result_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_result_size'
 * Large EXEM result (payload) size in bits, including VMV
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_result_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_max_result_size_get_f) (
    int unit);

/**
 * \brief returns define data of small_max_container_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_container_size'
 * Large EXEM maximal container size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_container_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_max_container_size_get_f) (
    int unit);

/**
 * \brief returns define data of large_max_container_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_container_size'
 * Large EXEM result (payload) size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_container_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_max_container_size_get_f) (
    int unit);

/**
 * \brief returns define data of small_key_hash_size
 * Module - 'field', Submodule - 'exem', data - 'small_key_hash_size'
 * number of bits out of key used for hashing (these bits are spared from saving in container)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_key_hash_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_key_hash_size_get_f) (
    int unit);

/**
 * \brief returns define data of large_key_hash_size
 * Module - 'field', Submodule - 'exem', data - 'large_key_hash_size'
 * number of bits out of key used for hashing (these bits are spared from saving in container)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_key_hash_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_key_hash_size_get_f) (
    int unit);

/**
 * \brief returns define data of small_min_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'small_min_app_db_id_range'
 * Small EXEM first APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_min_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_min_app_db_id_range_get_f) (
    int unit);

/**
 * \brief returns define data of large_min_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'large_min_app_db_id_range'
 * Large EXEM first APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_min_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_min_app_db_id_range_get_f) (
    int unit);

/**
 * \brief returns define data of small_max_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'small_max_app_db_id_range'
 * Small EXEM last APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_max_app_db_id_range_get_f) (
    int unit);

/**
 * \brief returns define data of large_max_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'large_max_app_db_id_range'
 * Large EXEM last APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_max_app_db_id_range_get_f) (
    int unit);

/**
 * \brief returns define data of small_ipmf2_key
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key'
 * The PMF key used for EXEM lookup by iPMF2. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_ipmf2_key_get_f) (
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_part
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_part'
 * The PMF key part used for EXEM lookup by iPMF2. 0 means the LSB half, 1 the MSB half.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_part - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_ipmf2_key_part_get_f) (
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_hw_value
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_hw_value'
 * The HW value to provide for selecting small_ipmf2_key and small_ipmf2_key_part.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_hw_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_ipmf2_key_hw_value_get_f) (
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_hw_bits
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_hw_bits'
 * The number of bits used by the HW for selecting small_ipmf2_key and small_ipmf2_key_part.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_hw_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_ipmf2_key_hw_bits_get_f) (
    int unit);

/**
 * \brief returns define data of large_ipmf1_key_configurable
 * Module - 'field', Submodule - 'exem', data - 'large_ipmf1_key_configurable'
 * Whether or not the EXEM key for iPMF1 can be configured on a chip wide basis.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_ipmf1_key_configurable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_ipmf1_key_configurable_get_f) (
    int unit);

/**
 * \brief returns define data of large_ipmf1_key
 * Module - 'field', Submodule - 'exem', data - 'large_ipmf1_key'
 * The PMF key used for EXEM lookup by iPMF1. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_ipmf1_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_ipmf1_key_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - EXEM:
 * {
 */
/**
 * \brief Interface for field exem data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_exem_feature_get_f feature_get;
    /**
     * returns define data of small_app_db_id_size
     */
    dnx_data_field_exem_small_app_db_id_size_get_f small_app_db_id_size_get;
    /**
     * returns define data of large_app_db_id_size
     */
    dnx_data_field_exem_large_app_db_id_size_get_f large_app_db_id_size_get;
    /**
     * returns define data of small_max_key_size
     */
    dnx_data_field_exem_small_max_key_size_get_f small_max_key_size_get;
    /**
     * returns define data of large_max_key_size
     */
    dnx_data_field_exem_large_max_key_size_get_f large_max_key_size_get;
    /**
     * returns define data of small_max_result_size
     */
    dnx_data_field_exem_small_max_result_size_get_f small_max_result_size_get;
    /**
     * returns define data of large_max_result_size
     */
    dnx_data_field_exem_large_max_result_size_get_f large_max_result_size_get;
    /**
     * returns define data of small_max_container_size
     */
    dnx_data_field_exem_small_max_container_size_get_f small_max_container_size_get;
    /**
     * returns define data of large_max_container_size
     */
    dnx_data_field_exem_large_max_container_size_get_f large_max_container_size_get;
    /**
     * returns define data of small_key_hash_size
     */
    dnx_data_field_exem_small_key_hash_size_get_f small_key_hash_size_get;
    /**
     * returns define data of large_key_hash_size
     */
    dnx_data_field_exem_large_key_hash_size_get_f large_key_hash_size_get;
    /**
     * returns define data of small_min_app_db_id_range
     */
    dnx_data_field_exem_small_min_app_db_id_range_get_f small_min_app_db_id_range_get;
    /**
     * returns define data of large_min_app_db_id_range
     */
    dnx_data_field_exem_large_min_app_db_id_range_get_f large_min_app_db_id_range_get;
    /**
     * returns define data of small_max_app_db_id_range
     */
    dnx_data_field_exem_small_max_app_db_id_range_get_f small_max_app_db_id_range_get;
    /**
     * returns define data of large_max_app_db_id_range
     */
    dnx_data_field_exem_large_max_app_db_id_range_get_f large_max_app_db_id_range_get;
    /**
     * returns define data of small_ipmf2_key
     */
    dnx_data_field_exem_small_ipmf2_key_get_f small_ipmf2_key_get;
    /**
     * returns define data of small_ipmf2_key_part
     */
    dnx_data_field_exem_small_ipmf2_key_part_get_f small_ipmf2_key_part_get;
    /**
     * returns define data of small_ipmf2_key_hw_value
     */
    dnx_data_field_exem_small_ipmf2_key_hw_value_get_f small_ipmf2_key_hw_value_get;
    /**
     * returns define data of small_ipmf2_key_hw_bits
     */
    dnx_data_field_exem_small_ipmf2_key_hw_bits_get_f small_ipmf2_key_hw_bits_get;
    /**
     * returns define data of large_ipmf1_key_configurable
     */
    dnx_data_field_exem_large_ipmf1_key_configurable_get_f large_ipmf1_key_configurable_get;
    /**
     * returns define data of large_ipmf1_key
     */
    dnx_data_field_exem_large_ipmf1_key_get_f large_ipmf1_key_get;
} dnx_data_if_field_exem_t;

/*
 * }
 */

/*
 * SUBMODULE  - ACE:
 * ACE values, for ACE expansion done by the PPMC DB and ACE ACR, for both MC replication ID pointers and ACE pointers
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_ace_feature_nof
} dnx_data_field_ace_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_ace_feature_get_f) (
    int unit,
    dnx_data_field_ace_feature_e feature);

/**
 * \brief returns define data of ace_id_size
 * Module - 'field', Submodule - 'ace', data - 'ace_id_size'
 * Number of bits used for the ACE ID (result type), which serves as an ID for the ACE format and context ID for the ACE EFES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_ace_id_size_get_f) (
    int unit);

/**
 * \brief returns define data of key_size
 * Module - 'field', Submodule - 'ace', data - 'key_size'
 * Number of bits in the key of the PPMC table, including the prefix that indicates the type to the entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of key_hash_size
 * Module - 'field', Submodule - 'ace', data - 'key_hash_size'
 * Number of bits in the key that are only used in the hash and aren't placed in the entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_hash_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_key_hash_size_get_f) (
    int unit);

/**
 * \brief returns define data of app_db_id_size
 * Module - 'field', Submodule - 'ace', data - 'app_db_id_size'
 * Number of bits Used for the APP DB ID.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_app_db_id_size_get_f) (
    int unit);

/**
 * \brief returns define data of payload_size
 * Module - 'field', Submodule - 'ace', data - 'payload_size'
 * Number of bits used to encode the container size, including the result type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_payload_size_get_f) (
    int unit);

/**
 * \brief returns define data of min_key_range_pmf
 * Module - 'field', Submodule - 'ace', data - 'min_key_range_pmf'
 * The first entry in the range of ACE keys allocated to ACE pointers (but not to MC replication ID).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_key_range_pmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_min_key_range_pmf_get_f) (
    int unit);

/**
 * \brief returns define data of max_key_range_pmf
 * Module - 'field', Submodule - 'ace', data - 'max_key_range_pmf'
 * The last entry in the range of ACE keys allocated to ACE pointers (but not to MC replication ID).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_range_pmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_max_key_range_pmf_get_f) (
    int unit);

/**
 * \brief returns define data of min_ace_id_dynamic_range
 * Module - 'field', Submodule - 'ace', data - 'min_ace_id_dynamic_range'
 * Minimal number of ACE ID that can be allocated dynamically.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_ace_id_dynamic_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_min_ace_id_dynamic_range_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ace_id
 * Module - 'field', Submodule - 'ace', data - 'nof_ace_id'
 * Number of ACE IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ace_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_ace_id_get_f) (
    int unit);

/**
 * \brief returns define data of nof_action_per_ace_format
 * Module - 'field', Submodule - 'ace', data - 'nof_action_per_ace_format'
 * Number of action per ACE Format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_ace_format - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_action_per_ace_format_get_f) (
    int unit);

/**
 * \brief returns define data of row_size
 * Module - 'field', Submodule - 'ace', data - 'row_size'
 * Number of bits per raw, entry size is number row size times VMV encoding meaning, e.g. half row encoding VMV would mean 60 bits entry size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     row_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_row_size_get_f) (
    int unit);

/**
 * \brief returns define data of min_entry_size
 * Module - 'field', Submodule - 'ace', data - 'min_entry_size'
 * Minimum number of bits in entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_min_entry_size_get_f) (
    int unit);

/**
 * \brief returns define data of ace_id_pmf_alloc_first
 * Module - 'field', Submodule - 'ace', data - 'ace_id_pmf_alloc_first'
 * The first ACE ID allocated to ACE, that is to ePMF extension.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_pmf_alloc_first - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_ace_id_pmf_alloc_first_get_f) (
    int unit);

/**
 * \brief returns define data of ace_id_pmf_alloc_last
 * Module - 'field', Submodule - 'ace', data - 'ace_id_pmf_alloc_last'
 * The last ACE ID allocated to ACE, that is to ePMF extension.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_pmf_alloc_last - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_ace_id_pmf_alloc_last_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'ace', data - 'nof_masks_per_fes'
 * Number of masks per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_array'
 * Number FES arrays
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per ACE ID, also the number of FESes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_programs'
 * Number of FES programs. For ACE the FES program is the same as ACE ID. Used here for compatibility with PMF FESes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_fes_programs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'ace', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_prog_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'ace', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_bits_in_fes_action_get_f) (
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'ace', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES. Uses the zero padding at the end of the payload, expected to work only if EFES field type=1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_shift_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'ace', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_instruction_size_get_f) (
    int unit);

/**
 * \brief returns define data of fes_shift_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_shift_offset'
 * FES shift offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_shift_offset_get_f) (
    int unit);

/**
 * \brief returns define data of fes_invalid_bits_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_invalid_bits_offset'
 * FES invalid bits offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_invalid_bits_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_invalid_bits_offset_get_f) (
    int unit);

/**
 * \brief returns define data of fes_type_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_type_offset'
 * FES type offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_type_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_type_offset_get_f) (
    int unit);

/**
 * \brief returns define data of fes_ace_action_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_ace_action_offset'
 * FES ace action offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_ace_action_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_ace_action_offset_get_f) (
    int unit);

/**
 * \brief returns define data of fes_chosen_mask_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_chosen_mask_offset'
 * FES chosen mask offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_chosen_mask_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_chosen_mask_offset_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - ACE:
 * {
 */
/**
 * \brief Interface for field ace data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_ace_feature_get_f feature_get;
    /**
     * returns define data of ace_id_size
     */
    dnx_data_field_ace_ace_id_size_get_f ace_id_size_get;
    /**
     * returns define data of key_size
     */
    dnx_data_field_ace_key_size_get_f key_size_get;
    /**
     * returns define data of key_hash_size
     */
    dnx_data_field_ace_key_hash_size_get_f key_hash_size_get;
    /**
     * returns define data of app_db_id_size
     */
    dnx_data_field_ace_app_db_id_size_get_f app_db_id_size_get;
    /**
     * returns define data of payload_size
     */
    dnx_data_field_ace_payload_size_get_f payload_size_get;
    /**
     * returns define data of min_key_range_pmf
     */
    dnx_data_field_ace_min_key_range_pmf_get_f min_key_range_pmf_get;
    /**
     * returns define data of max_key_range_pmf
     */
    dnx_data_field_ace_max_key_range_pmf_get_f max_key_range_pmf_get;
    /**
     * returns define data of min_ace_id_dynamic_range
     */
    dnx_data_field_ace_min_ace_id_dynamic_range_get_f min_ace_id_dynamic_range_get;
    /**
     * returns define data of nof_ace_id
     */
    dnx_data_field_ace_nof_ace_id_get_f nof_ace_id_get;
    /**
     * returns define data of nof_action_per_ace_format
     */
    dnx_data_field_ace_nof_action_per_ace_format_get_f nof_action_per_ace_format_get;
    /**
     * returns define data of row_size
     */
    dnx_data_field_ace_row_size_get_f row_size_get;
    /**
     * returns define data of min_entry_size
     */
    dnx_data_field_ace_min_entry_size_get_f min_entry_size_get;
    /**
     * returns define data of ace_id_pmf_alloc_first
     */
    dnx_data_field_ace_ace_id_pmf_alloc_first_get_f ace_id_pmf_alloc_first_get;
    /**
     * returns define data of ace_id_pmf_alloc_last
     */
    dnx_data_field_ace_ace_id_pmf_alloc_last_get_f ace_id_pmf_alloc_last_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_ace_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_ace_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_ace_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_ace_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_fes_programs
     */
    dnx_data_field_ace_nof_fes_programs_get_f nof_fes_programs_get;
    /**
     * returns define data of nof_prog_per_fes
     */
    dnx_data_field_ace_nof_prog_per_fes_get_f nof_prog_per_fes_get;
    /**
     * returns define data of nof_bits_in_fes_action
     */
    dnx_data_field_ace_nof_bits_in_fes_action_get_f nof_bits_in_fes_action_get;
    /**
     * returns define data of fes_shift_for_zero_bit
     */
    dnx_data_field_ace_fes_shift_for_zero_bit_get_f fes_shift_for_zero_bit_get;
    /**
     * returns define data of fes_instruction_size
     */
    dnx_data_field_ace_fes_instruction_size_get_f fes_instruction_size_get;
    /**
     * returns define data of fes_shift_offset
     */
    dnx_data_field_ace_fes_shift_offset_get_f fes_shift_offset_get;
    /**
     * returns define data of fes_invalid_bits_offset
     */
    dnx_data_field_ace_fes_invalid_bits_offset_get_f fes_invalid_bits_offset_get;
    /**
     * returns define data of fes_type_offset
     */
    dnx_data_field_ace_fes_type_offset_get_f fes_type_offset_get;
    /**
     * returns define data of fes_ace_action_offset
     */
    dnx_data_field_ace_fes_ace_action_offset_get_f fes_ace_action_offset_get;
    /**
     * returns define data of fes_chosen_mask_offset
     */
    dnx_data_field_ace_fes_chosen_mask_offset_get_f fes_chosen_mask_offset_get;
} dnx_data_if_field_ace_t;

/*
 * }
 */

/*
 * SUBMODULE  - ENTRY:
 * Entry data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_entry_feature_nof
} dnx_data_field_entry_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_entry_feature_get_f) (
    int unit,
    dnx_data_field_entry_feature_e feature);

/**
 * \brief returns define data of dir_ext_nof_fields
 * Module - 'field', Submodule - 'entry', data - 'dir_ext_nof_fields'
 * The maximum number of fields in a direct extraction request. \n                                                   (e.g. if we want the action to be composed of 3 bits of constant value, 5 bits from the key, \n                                                   5 bits of constant value and then 4 bits from the key we need at least 4 fields.)\n                                                   Used by dnx_field_dir_ext_action_t for the array size of the fields. \n                                                   Arbitrary value, can be increased.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_nof_fields - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_entry_dir_ext_nof_fields_get_f) (
    int unit);

/**
 * \brief returns define data of nof_action_params_per_entry
 * Module - 'field', Submodule - 'entry', data - 'nof_action_params_per_entry'
 * Number of action parameters can be given for each action \n                                                             e.g. action values that are filled for TCAM action result
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_params_per_entry - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_entry_nof_action_params_per_entry_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qual_params_per_entry
 * Module - 'field', Submodule - 'entry', data - 'nof_qual_params_per_entry'
 * Number of qualifiers parameters can be given for each qualifier type \n                                                             e.g. qualifier/key values that are filled for TCAM key
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qual_params_per_entry - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_entry_nof_qual_params_per_entry_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - ENTRY:
 * {
 */
/**
 * \brief Interface for field entry data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_entry_feature_get_f feature_get;
    /**
     * returns define data of dir_ext_nof_fields
     */
    dnx_data_field_entry_dir_ext_nof_fields_get_f dir_ext_nof_fields_get;
    /**
     * returns define data of nof_action_params_per_entry
     */
    dnx_data_field_entry_nof_action_params_per_entry_get_f nof_action_params_per_entry_get;
    /**
     * returns define data of nof_qual_params_per_entry
     */
    dnx_data_field_entry_nof_qual_params_per_entry_get_f nof_qual_params_per_entry_get;
} dnx_data_if_field_entry_t;

/*
 * }
 */

/*
 * SUBMODULE  - L4_OPS:
 * L4 Ops data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_L4_Ops_feature_nof
} dnx_data_field_L4_Ops_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_L4_Ops_feature_get_f) (
    int unit,
    dnx_data_field_L4_Ops_feature_e feature);

/**
 * \brief returns define data of udp_position
 * Module - 'field', Submodule - 'L4_Ops', data - 'udp_position'
 * The position of the UDP protocol in the register
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     udp_position - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_L4_Ops_udp_position_get_f) (
    int unit);

/**
 * \brief returns define data of tcp_position
 * Module - 'field', Submodule - 'L4_Ops', data - 'tcp_position'
 * The position of the UDP protocol in the register
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcp_position - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_L4_Ops_tcp_position_get_f) (
    int unit);

/**
 * \brief returns define data of nof_range_entries
 * Module - 'field', Submodule - 'L4_Ops', data - 'nof_range_entries'
 * number of range entries in L4 Ops
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_range_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_L4_Ops_nof_range_entries_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ext_encoders
 * Module - 'field', Submodule - 'L4_Ops', data - 'nof_ext_encoders'
 * Number of range result encoders in extended L4 OPs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ext_encoders - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_L4_Ops_nof_ext_encoders_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ext_types
 * Module - 'field', Submodule - 'L4_Ops', data - 'nof_ext_types'
 * Number of range types in extended L4 OPs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ext_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_L4_Ops_nof_ext_types_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - L4_OPS:
 * {
 */
/**
 * \brief Interface for field L4_Ops data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_L4_Ops_feature_get_f feature_get;
    /**
     * returns define data of udp_position
     */
    dnx_data_field_L4_Ops_udp_position_get_f udp_position_get;
    /**
     * returns define data of tcp_position
     */
    dnx_data_field_L4_Ops_tcp_position_get_f tcp_position_get;
    /**
     * returns define data of nof_range_entries
     */
    dnx_data_field_L4_Ops_nof_range_entries_get_f nof_range_entries_get;
    /**
     * returns define data of nof_ext_encoders
     */
    dnx_data_field_L4_Ops_nof_ext_encoders_get_f nof_ext_encoders_get;
    /**
     * returns define data of nof_ext_types
     */
    dnx_data_field_L4_Ops_nof_ext_types_get_f nof_ext_types_get;
} dnx_data_if_field_L4_Ops_t;

/*
 * }
 */

/*
 * SUBMODULE  - ENCODED_QUAL_ACTIONS_OFFSET:
 * Encoded qualfiers and actions offsets
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_encoded_qual_actions_offset_feature_nof
} dnx_data_field_encoded_qual_actions_offset_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_encoded_qual_actions_offset_feature_get_f) (
    int unit,
    dnx_data_field_encoded_qual_actions_offset_feature_e feature);

/**
 * \brief returns define data of trap_strength_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'trap_strength_offset'
 * The offset of the Trap Strength in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     trap_strength_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_encoded_qual_actions_offset_trap_strength_offset_get_f) (
    int unit);

/**
 * \brief returns define data of trap_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'trap_qualifier_offset'
 * The offset of the Trap Qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     trap_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_encoded_qual_actions_offset_trap_qualifier_offset_get_f) (
    int unit);

/**
 * \brief returns define data of sniff_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'sniff_qualifier_offset'
 * The offset of the Snoop qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sniff_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_encoded_qual_actions_offset_sniff_qualifier_offset_get_f) (
    int unit);

/**
 * \brief returns define data of mirror_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'mirror_qualifier_offset'
 * The offset of the Mirror Qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mirror_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_encoded_qual_actions_offset_mirror_qualifier_offset_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - ENCODED_QUAL_ACTIONS_OFFSET:
 * {
 */
/**
 * \brief Interface for field encoded_qual_actions_offset data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_encoded_qual_actions_offset_feature_get_f feature_get;
    /**
     * returns define data of trap_strength_offset
     */
    dnx_data_field_encoded_qual_actions_offset_trap_strength_offset_get_f trap_strength_offset_get;
    /**
     * returns define data of trap_qualifier_offset
     */
    dnx_data_field_encoded_qual_actions_offset_trap_qualifier_offset_get_f trap_qualifier_offset_get;
    /**
     * returns define data of sniff_qualifier_offset
     */
    dnx_data_field_encoded_qual_actions_offset_sniff_qualifier_offset_get_f sniff_qualifier_offset_get;
    /**
     * returns define data of mirror_qualifier_offset
     */
    dnx_data_field_encoded_qual_actions_offset_mirror_qualifier_offset_get_f mirror_qualifier_offset_get;
} dnx_data_if_field_encoded_qual_actions_offset_t;

/*
 * }
 */

/*
 * SUBMODULE  - COMPARE_OPERAND:
 * The offset of the compare_operand
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_Compare_operand_feature_nof
} dnx_data_field_Compare_operand_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_Compare_operand_feature_get_f) (
    int unit,
    dnx_data_field_Compare_operand_feature_e feature);

/**
 * \brief returns define data of equal
 * Module - 'field', Submodule - 'Compare_operand', data - 'equal'
 * The position in the qual showing that the result of compare is equal
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     equal - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_Compare_operand_equal_get_f) (
    int unit);

/**
 * \brief returns define data of not_equal
 * Module - 'field', Submodule - 'Compare_operand', data - 'not_equal'
 * The position in the qual showing that the result of compare is not equal
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_equal - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_Compare_operand_not_equal_get_f) (
    int unit);

/**
 * \brief returns define data of smaller
 * Module - 'field', Submodule - 'Compare_operand', data - 'smaller'
 * The position in the qual showing that the first compare value is smaller then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     smaller - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_Compare_operand_smaller_get_f) (
    int unit);

/**
 * \brief returns define data of not_smaller
 * Module - 'field', Submodule - 'Compare_operand', data - 'not_smaller'
 * The position in the qual showing that the first compare value is not smaller then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_smaller - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_Compare_operand_not_smaller_get_f) (
    int unit);

/**
 * \brief returns define data of bigger
 * Module - 'field', Submodule - 'Compare_operand', data - 'bigger'
 * The position in the qual showing that the first compare value is bigger then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bigger - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_Compare_operand_bigger_get_f) (
    int unit);

/**
 * \brief returns define data of not_bigger
 * Module - 'field', Submodule - 'Compare_operand', data - 'not_bigger'
 * The position in the qual showing that the first compare value is not bigger then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_bigger - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_Compare_operand_not_bigger_get_f) (
    int unit);

/**
 * \brief returns define data of nof_operands
 * Module - 'field', Submodule - 'Compare_operand', data - 'nof_operands'
 * The number of all operands
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_operands - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_Compare_operand_nof_operands_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - COMPARE_OPERAND:
 * {
 */
/**
 * \brief Interface for field Compare_operand data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_Compare_operand_feature_get_f feature_get;
    /**
     * returns define data of equal
     */
    dnx_data_field_Compare_operand_equal_get_f equal_get;
    /**
     * returns define data of not_equal
     */
    dnx_data_field_Compare_operand_not_equal_get_f not_equal_get;
    /**
     * returns define data of smaller
     */
    dnx_data_field_Compare_operand_smaller_get_f smaller_get;
    /**
     * returns define data of not_smaller
     */
    dnx_data_field_Compare_operand_not_smaller_get_f not_smaller_get;
    /**
     * returns define data of bigger
     */
    dnx_data_field_Compare_operand_bigger_get_f bigger_get;
    /**
     * returns define data of not_bigger
     */
    dnx_data_field_Compare_operand_not_bigger_get_f not_bigger_get;
    /**
     * returns define data of nof_operands
     */
    dnx_data_field_Compare_operand_nof_operands_get_f nof_operands_get;
} dnx_data_if_field_Compare_operand_t;

/*
 * }
 */

/*
 * SUBMODULE  - DIAG:
 * Field diagnostics related defines and features.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indicates if the TCAM Context Selection hit bit indication is supported.
     */
    dnx_data_field_diag_tcam_cs_hit_bit_support,

    /**
     * Must be last one!
     */
    _dnx_data_field_diag_feature_nof
} dnx_data_field_diag_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_diag_feature_get_f) (
    int unit,
    dnx_data_field_diag_feature_e feature);

/**
 * \brief returns define data of bytes_to_remove_mask
 * Module - 'field', Submodule - 'diag', data - 'bytes_to_remove_mask'
 * Mask of bits, which are related to the value of bytes to remove, from the signal.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bytes_to_remove_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_bytes_to_remove_mask_get_f) (
    int unit);

/**
 * \brief returns define data of layers_to_remove_size_in_bit
 * Module - 'field', Submodule - 'diag', data - 'layers_to_remove_size_in_bit'
 * Size of the layers to remove value in bits, to be used for shifting the signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layers_to_remove_size_in_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_layers_to_remove_size_in_bit_get_f) (
    int unit);

/**
 * \brief returns define data of layers_to_remove_mask
 * Module - 'field', Submodule - 'diag', data - 'layers_to_remove_mask'
 * Mask of bits, which are related to the value of layers to remove, from the signal.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layers_to_remove_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_layers_to_remove_mask_get_f) (
    int unit);

/**
 * \brief returns define data of nof_signals_per_action
 * Module - 'field', Submodule - 'diag', data - 'nof_signals_per_action'
 * Maximum number of signals per action.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_signals_per_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_nof_signals_per_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_signals_per_qualifier
 * Module - 'field', Submodule - 'diag', data - 'nof_signals_per_qualifier'
 * Maximum number of signals per qualifier.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_signals_per_qualifier - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_nof_signals_per_qualifier_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - DIAG:
 * {
 */
/**
 * \brief Interface for field diag data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_diag_feature_get_f feature_get;
    /**
     * returns define data of bytes_to_remove_mask
     */
    dnx_data_field_diag_bytes_to_remove_mask_get_f bytes_to_remove_mask_get;
    /**
     * returns define data of layers_to_remove_size_in_bit
     */
    dnx_data_field_diag_layers_to_remove_size_in_bit_get_f layers_to_remove_size_in_bit_get;
    /**
     * returns define data of layers_to_remove_mask
     */
    dnx_data_field_diag_layers_to_remove_mask_get_f layers_to_remove_mask_get;
    /**
     * returns define data of nof_signals_per_action
     */
    dnx_data_field_diag_nof_signals_per_action_get_f nof_signals_per_action_get;
    /**
     * returns define data of nof_signals_per_qualifier
     */
    dnx_data_field_diag_nof_signals_per_qualifier_get_f nof_signals_per_qualifier_get;
} dnx_data_if_field_diag_t;

/*
 * }
 */

/*
 * SUBMODULE  - COMMON_MAX_VAL:
 * Common max values over all PMF stages (IPMF1/IPMF2/IPMF3/EPMF) or over all IO types (TCAM, EXAM, ...)
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule common_max_val table array_id_type
 * Table info:
 * Contains indications on whether a specific 'array_id' is for FESes or for FEMs
 */
typedef struct
{
    /**
     * Non-zero if 'array_id' is for FESes. Zero otherwise
     */
    int is_fes;
    /**
     * Non-zero if 'array_id' is for FEMs. Zero otherwise
     */
    int is_fem;
    /**
     * Converts 'array_id' to number of FES arrays so far. 'array_id' 0 converts to 0, 2 converts to 1
     */
    int fes_array_index;
    /**
     * Converts 'array_id' to number of FEM arrays so far. 'array_id' 1 converts to 0, 3 converts to 1
     */
    int fem_array_index;
} dnx_data_field_common_max_val_array_id_type_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_common_max_val_feature_nof
} dnx_data_field_common_max_val_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_common_max_val_feature_get_f) (
    int unit,
    dnx_data_field_common_max_val_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_ffc'
 * Maximal number of FFC's in all stages
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_keys'
 * Number of keys for the entire PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_masks_per_fes'
 * Number of masks per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_array'
 * Number FES arrays
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_programs'
 * Number of FES programs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fes_programs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_prog_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_program_selection_lines
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_program_selection_lines'
 * Number of Ingress context selection lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_program_selection_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_program_selection_lines_get_f) (
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'common_max_val', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_program_selection_cam_mask_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_cs_lines'
 * Number of program selection lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_cs_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_contexts'
 * Number of contexts per PMF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_actions'
 * Number of actions
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_actions_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_qualifiers'
 * Number of qualifiers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_qualifiers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_80B_zones_get_f) (
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_key_zones_get_f) (
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_key_zone_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fes_action'
 * Number of bits on the outpus of a FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_bits_in_fes_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_bits_in_fes_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can be applied on one line on actions table. ('double key' actions are considered one line)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fes_key_selects_on_one_actions_line_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ffc_in_qual
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_ffc_in_qual'
 * Maximal number of ffc for one qualifier.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_in_qual - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_ffc_in_qual_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_ffc
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_ffc'
 * Number of bits in ffc.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_bits_in_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ffc_in_uint32
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_ffc_in_uint32'
 * Number of uint32 needed to hold bitmap for maximum number of FFC's.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_in_uint32 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_ffc_in_uint32_get_f) (
    int unit);

/**
 * \brief returns define data of nof_action_per_group
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_action_per_group'
 * Maxmimal number of actions between both Field Group and ACE format. Used for arrays in functions that serve both.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_action_per_group_get_f) (
    int unit);

/**
 * \brief returns define data of nof_layer_records
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_layer_records'
 * Maximal number of layer records.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_layer_records_get_f) (
    int unit);

/**
 * \brief returns define data of layer_record_size
 * Module - 'field', Submodule - 'common_max_val', data - 'layer_record_size'
 * Maximal size of layer records.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layer_record_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_layer_record_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges_legacy
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_l4_ops_ranges_legacy'
 * Maximal number of ranges for L4 Ops legacy.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges_legacy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_l4_ops_ranges_legacy_get_f) (
    int unit);

/**
 * \brief returns define data of nof_pkt_hdr_ranges
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_pkt_hdr_ranges'
 * Maximal number of ranges for packet header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pkt_hdr_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_pkt_hdr_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_out_lif_ranges'
 * Maximal number of ranges for Out Lif.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_out_lif_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of kbr_size
 * Module - 'field', Submodule - 'common_max_val', data - 'kbr_size'
 * Maximal KBR size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kbr_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_kbr_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compare_pairs
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_compare_pairs'
 * Maximal number of pairs used for compare.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_compare_pairs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compare_pairs_in_compare_mode
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_compare_pairs_in_compare_mode'
 * Number compare pairs in compare mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_compare_pairs_in_compare_mode_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compare_keys_in_compare_mode
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_compare_keys_in_compare_mode'
 * Number compare keys in compare mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_keys_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_compare_keys_in_compare_mode_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fem_action'
 * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_bits_in_fem_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_condition
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fem_condition'
 * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_condition - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fem_condition_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_map_index
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fem_map_index'
 * Total number fem map indices. This represents the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_map_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fem_map_index_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_id
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fem_id'
 * Total number 'FEM id's available.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fem_id_get_f) (
    int unit);

/**
 * \brief returns define data of nof_array_ids
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_array_ids'
 * Total number of 'array_is's which are used to identify a range of FESes or FEMs. See BCM_FIELD_ACTION_POSITION.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_array_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_array_ids_get_f) (
    int unit);

/**
 * \brief returns define data of dbal_pairs
 * Module - 'field', Submodule - 'common_max_val', data - 'dbal_pairs'
 * Maximum number of pairs which are used to identify the DBAL key/result field in dnx_field_dbal_entry_set function. 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbal_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_dbal_pairs_get_f) (
    int unit);

/**
 * \brief get table array_id_type entry 
 * Contains indications on whether a specific 'array_id' is for FESes or for FEMs
 * 
 * \param [in] unit - unit #
 * \param [in] array_id - Index identifier of 'array_id'
 * 
 * \return
 *     array_id_type - returns the relevant entry values grouped in struct - see dnx_data_field_common_max_val_array_id_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_common_max_val_array_id_type_t *(
    *dnx_data_field_common_max_val_array_id_type_get_f) (
    int unit,
    int array_id);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - COMMON_MAX_VAL:
 * {
 */
/**
 * \brief Interface for field common_max_val data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_common_max_val_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_common_max_val_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_common_max_val_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_common_max_val_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_common_max_val_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_common_max_val_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_common_max_val_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_fes_programs
     */
    dnx_data_field_common_max_val_nof_fes_programs_get_f nof_fes_programs_get;
    /**
     * returns define data of nof_prog_per_fes
     */
    dnx_data_field_common_max_val_nof_prog_per_fes_get_f nof_prog_per_fes_get;
    /**
     * returns define data of nof_program_selection_lines
     */
    dnx_data_field_common_max_val_nof_program_selection_lines_get_f nof_program_selection_lines_get;
    /**
     * returns define data of program_selection_cam_mask_nof_bits
     */
    dnx_data_field_common_max_val_program_selection_cam_mask_nof_bits_get_f program_selection_cam_mask_nof_bits_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_common_max_val_nof_cs_lines_get_f nof_cs_lines_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_common_max_val_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of nof_actions
     */
    dnx_data_field_common_max_val_nof_actions_get_f nof_actions_get;
    /**
     * returns define data of nof_qualifiers
     */
    dnx_data_field_common_max_val_nof_qualifiers_get_f nof_qualifiers_get;
    /**
     * returns define data of nof_80B_zones
     */
    dnx_data_field_common_max_val_nof_80B_zones_get_f nof_80B_zones_get;
    /**
     * returns define data of nof_key_zones
     */
    dnx_data_field_common_max_val_nof_key_zones_get_f nof_key_zones_get;
    /**
     * returns define data of nof_key_zone_bits
     */
    dnx_data_field_common_max_val_nof_key_zone_bits_get_f nof_key_zone_bits_get;
    /**
     * returns define data of nof_bits_in_fes_action
     */
    dnx_data_field_common_max_val_nof_bits_in_fes_action_get_f nof_bits_in_fes_action_get;
    /**
     * returns define data of nof_bits_in_fes_key_select
     */
    dnx_data_field_common_max_val_nof_bits_in_fes_key_select_get_f nof_bits_in_fes_key_select_get;
    /**
     * returns define data of nof_fes_key_selects_on_one_actions_line
     */
    dnx_data_field_common_max_val_nof_fes_key_selects_on_one_actions_line_get_f nof_fes_key_selects_on_one_actions_line_get;
    /**
     * returns define data of nof_ffc_in_qual
     */
    dnx_data_field_common_max_val_nof_ffc_in_qual_get_f nof_ffc_in_qual_get;
    /**
     * returns define data of nof_bits_in_ffc
     */
    dnx_data_field_common_max_val_nof_bits_in_ffc_get_f nof_bits_in_ffc_get;
    /**
     * returns define data of nof_ffc_in_uint32
     */
    dnx_data_field_common_max_val_nof_ffc_in_uint32_get_f nof_ffc_in_uint32_get;
    /**
     * returns define data of nof_action_per_group
     */
    dnx_data_field_common_max_val_nof_action_per_group_get_f nof_action_per_group_get;
    /**
     * returns define data of nof_layer_records
     */
    dnx_data_field_common_max_val_nof_layer_records_get_f nof_layer_records_get;
    /**
     * returns define data of layer_record_size
     */
    dnx_data_field_common_max_val_layer_record_size_get_f layer_record_size_get;
    /**
     * returns define data of nof_l4_ops_ranges_legacy
     */
    dnx_data_field_common_max_val_nof_l4_ops_ranges_legacy_get_f nof_l4_ops_ranges_legacy_get;
    /**
     * returns define data of nof_pkt_hdr_ranges
     */
    dnx_data_field_common_max_val_nof_pkt_hdr_ranges_get_f nof_pkt_hdr_ranges_get;
    /**
     * returns define data of nof_out_lif_ranges
     */
    dnx_data_field_common_max_val_nof_out_lif_ranges_get_f nof_out_lif_ranges_get;
    /**
     * returns define data of kbr_size
     */
    dnx_data_field_common_max_val_kbr_size_get_f kbr_size_get;
    /**
     * returns define data of nof_compare_pairs
     */
    dnx_data_field_common_max_val_nof_compare_pairs_get_f nof_compare_pairs_get;
    /**
     * returns define data of nof_compare_pairs_in_compare_mode
     */
    dnx_data_field_common_max_val_nof_compare_pairs_in_compare_mode_get_f nof_compare_pairs_in_compare_mode_get;
    /**
     * returns define data of nof_compare_keys_in_compare_mode
     */
    dnx_data_field_common_max_val_nof_compare_keys_in_compare_mode_get_f nof_compare_keys_in_compare_mode_get;
    /**
     * returns define data of nof_bits_in_fem_action
     */
    dnx_data_field_common_max_val_nof_bits_in_fem_action_get_f nof_bits_in_fem_action_get;
    /**
     * returns define data of nof_fem_condition
     */
    dnx_data_field_common_max_val_nof_fem_condition_get_f nof_fem_condition_get;
    /**
     * returns define data of nof_fem_map_index
     */
    dnx_data_field_common_max_val_nof_fem_map_index_get_f nof_fem_map_index_get;
    /**
     * returns define data of nof_fem_id
     */
    dnx_data_field_common_max_val_nof_fem_id_get_f nof_fem_id_get;
    /**
     * returns define data of nof_array_ids
     */
    dnx_data_field_common_max_val_nof_array_ids_get_f nof_array_ids_get;
    /**
     * returns define data of dbal_pairs
     */
    dnx_data_field_common_max_val_dbal_pairs_get_f dbal_pairs_get;
    /**
     * get table array_id_type entry 
     */
    dnx_data_field_common_max_val_array_id_type_get_f array_id_type_get;
    /**
     * get general info table about table (for example key size)array_id_type info
     */
    dnxc_data_table_info_get_f array_id_type_info_get;
} dnx_data_if_field_common_max_val_t;

/*
 * }
 */

/*
 * SUBMODULE  - INIT:
 * Field defines and features related to init.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_init_feature_nof
} dnx_data_field_init_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_init_feature_get_f) (
    int unit,
    dnx_data_field_init_feature_e feature);

/**
 * \brief returns define data of wa_fec_dest
 * Module - 'field', Submodule - 'init', data - 'wa_fec_dest'
 * APP WA for fec destination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_fec_dest - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_wa_fec_dest_get_f) (
    int unit);

/**
 * \brief returns define data of wa_l4_trap
 * Module - 'field', Submodule - 'init', data - 'wa_l4_trap'
 * APP WA for L4 Trap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_l4_trap - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_wa_l4_trap_get_f) (
    int unit);

/**
 * \brief returns define data of wa_oam_layer_index
 * Module - 'field', Submodule - 'init', data - 'wa_oam_layer_index'
 * APP WA for OAM Layer Index
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_oam_layer_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_wa_oam_layer_index_get_f) (
    int unit);

/**
 * \brief returns define data of wa_oam_stat
 * Module - 'field', Submodule - 'init', data - 'wa_oam_stat'
 * APP WA for OAM Statistics
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_oam_stat - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_wa_oam_stat_get_f) (
    int unit);

/**
 * \brief returns define data of wa_flow_id
 * Module - 'field', Submodule - 'init', data - 'wa_flow_id'
 * APP WA for Flow ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_flow_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_wa_flow_id_get_f) (
    int unit);

/**
 * \brief returns define data of wa_roo
 * Module - 'field', Submodule - 'init', data - 'wa_roo'
 * APP WA for Roo
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_roo - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_wa_roo_get_f) (
    int unit);

/**
 * \brief returns define data of wa_jr1_ipmc_inlif
 * Module - 'field', Submodule - 'init', data - 'wa_jr1_ipmc_inlif'
 * APP WA for IPMC In LIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_jr1_ipmc_inlif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_wa_jr1_ipmc_inlif_get_f) (
    int unit);

/**
 * \brief returns define data of wa_j1_same_port
 * Module - 'field', Submodule - 'init', data - 'wa_j1_same_port'
 * APP WA for J1 Same port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_j1_same_port - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_wa_j1_same_port_get_f) (
    int unit);

/**
 * \brief returns define data of wa_j1_learning
 * Module - 'field', Submodule - 'init', data - 'wa_j1_learning'
 * APP WA for J1 Learning
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_j1_learning - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_wa_j1_learning_get_f) (
    int unit);

/**
 * \brief returns define data of wa_learn_limit
 * Module - 'field', Submodule - 'init', data - 'wa_learn_limit'
 * APP WA for Learn Limit
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_learn_limit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_wa_learn_limit_get_f) (
    int unit);

/**
 * \brief returns define data of wa_j1_php
 * Module - 'field', Submodule - 'init', data - 'wa_j1_php'
 * APP WA for J1 MPLS PHP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_j1_php - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_wa_j1_php_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - INIT:
 * {
 */
/**
 * \brief Interface for field init data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_init_feature_get_f feature_get;
    /**
     * returns define data of wa_fec_dest
     */
    dnx_data_field_init_wa_fec_dest_get_f wa_fec_dest_get;
    /**
     * returns define data of wa_l4_trap
     */
    dnx_data_field_init_wa_l4_trap_get_f wa_l4_trap_get;
    /**
     * returns define data of wa_oam_layer_index
     */
    dnx_data_field_init_wa_oam_layer_index_get_f wa_oam_layer_index_get;
    /**
     * returns define data of wa_oam_stat
     */
    dnx_data_field_init_wa_oam_stat_get_f wa_oam_stat_get;
    /**
     * returns define data of wa_flow_id
     */
    dnx_data_field_init_wa_flow_id_get_f wa_flow_id_get;
    /**
     * returns define data of wa_roo
     */
    dnx_data_field_init_wa_roo_get_f wa_roo_get;
    /**
     * returns define data of wa_jr1_ipmc_inlif
     */
    dnx_data_field_init_wa_jr1_ipmc_inlif_get_f wa_jr1_ipmc_inlif_get;
    /**
     * returns define data of wa_j1_same_port
     */
    dnx_data_field_init_wa_j1_same_port_get_f wa_j1_same_port_get;
    /**
     * returns define data of wa_j1_learning
     */
    dnx_data_field_init_wa_j1_learning_get_f wa_j1_learning_get;
    /**
     * returns define data of wa_learn_limit
     */
    dnx_data_field_init_wa_learn_limit_get_f wa_learn_limit_get;
    /**
     * returns define data of wa_j1_php
     */
    dnx_data_field_init_wa_j1_php_get_f wa_j1_php_get;
} dnx_data_if_field_init_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEATURES:
 * All device specific features
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_features_feature_nof
} dnx_data_field_features_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_features_feature_get_f) (
    int unit,
    dnx_data_field_features_feature_e feature);

/**
 * \brief returns define data of ecc_wa_enable
 * Module - 'field', Submodule - 'features', data - 'ecc_wa_enable'
 * ECC is calculated per whole entry on each entry write, therefore, when writing half-entries\n                      wrong ECC values is being calculated, this workaround enables read-modify-write of the whole\n                      entry instead of writing half-entries to have correct ECC calculated on each write.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecc_wa_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_ecc_wa_enable_get_f) (
    int unit);

/**
 * \brief returns define data of switch_to_acl_context
 * Module - 'field', Submodule - 'features', data - 'switch_to_acl_context'
 * Allows to swap the acl_context and fwd_context signals after iPMF1/2 using IPPC_PMF_GENERAL.SWITCH_TO_ACL_CONTEXT.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     switch_to_acl_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_switch_to_acl_context_get_f) (
    int unit);

/**
 * \brief returns define data of per_pp_port_pmf_profile_cs_offset
 * Module - 'field', Submodule - 'features', data - 'per_pp_port_pmf_profile_cs_offset'
 * The placement of PMF_PROFILE field within ERPP_PER_PORT_TABLE. Used because DBAL mapping by device didn't work.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     per_pp_port_pmf_profile_cs_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_per_pp_port_pmf_profile_cs_offset_get_f) (
    int unit);

/**
 * \brief returns define data of tcam_result_flip_eco
 * Module - 'field', Submodule - 'features', data - 'tcam_result_flip_eco'
 * The TCAM result flip ECO is about flippiing lsb and msb parts of the TCAM-result in order to support 80b result being parsed by ARR
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_result_flip_eco - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_tcam_result_flip_eco_get_f) (
    int unit);

/**
 * \brief returns define data of tcam_result_half_payload_on_msb
 * Module - 'field', Submodule - 'features', data - 'tcam_result_half_payload_on_msb'
 * Indicates that for half payload lookup the result is on the MSB half, but not using the tcam_result_flip_eco.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_result_half_payload_on_msb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_tcam_result_half_payload_on_msb_get_f) (
    int unit);

/**
 * \brief returns define data of parsing_start_offset_msb_meaningless
 * Module - 'field', Submodule - 'features', data - 'parsing_start_offset_msb_meaningless'
 * In JR2, the parsing_start_offset signal is 8 bit in ingress but only 7 in egress, so we make the action smaller so as not to have a meaningles MSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     parsing_start_offset_msb_meaningless - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_parsing_start_offset_msb_meaningless_get_f) (
    int unit);

/**
 * \brief returns define data of kbp_opcode_in_ipmf1_cs
 * Module - 'field', Submodule - 'features', data - 'kbp_opcode_in_ipmf1_cs'
 * Indicates whether the context selection of iPMF1 takes the KBP opcode into account.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kbp_opcode_in_ipmf1_cs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_kbp_opcode_in_ipmf1_cs_get_f) (
    int unit);

/**
 * \brief returns define data of kbp_hitbits_correct_in_ipmf1_cs
 * Module - 'field', Submodule - 'features', data - 'kbp_hitbits_correct_in_ipmf1_cs'
 * Indicates whether the context selection of iPMF1 takes the KBP hitbits from the correct place of the elk payload. Assumed to be either 0 or 1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kbp_hitbits_correct_in_ipmf1_cs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_kbp_hitbits_correct_in_ipmf1_cs_get_f) (
    int unit);

/**
 * \brief returns define data of exem_vmv_removable_from_payload
 * Module - 'field', Submodule - 'features', data - 'exem_vmv_removable_from_payload'
 * Indicates whether it is possible to configure a shift to remove the from the EXEM payload.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_vmv_removable_from_payload - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_exem_vmv_removable_from_payload_get_f) (
    int unit);

/**
 * \brief returns define data of multiple_dynamic_mem_enablers
 * Module - 'field', Submodule - 'features', data - 'multiple_dynamic_mem_enablers'
 * Indicates whether it is possible to configure dynamic memory enablers for ST, CS hit, TCAM entry protection etc.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     multiple_dynamic_mem_enablers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_multiple_dynamic_mem_enablers_get_f) (
    int unit);

/**
 * \brief returns define data of aacl_super_group_handler_enable
 * Module - 'field', Submodule - 'features', data - 'aacl_super_group_handler_enable'
 * Indicates whether it is possible to configure Super Group Handler for AACL
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aacl_super_group_handler_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_aacl_super_group_handler_enable_get_f) (
    int unit);

/**
 * \brief returns define data of aacl_tcam_swap_enable
 * Module - 'field', Submodule - 'features', data - 'aacl_tcam_swap_enable'
 * Indicates whether it is possible to configure TCAM swap for AACL
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aacl_tcam_swap_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_aacl_tcam_swap_enable_get_f) (
    int unit);

/**
 * \brief returns define data of extended_l4_ops
 * Module - 'field', Submodule - 'features', data - 'extended_l4_ops'
 * Whether extended L4 Ops is supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     extended_l4_ops - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_extended_l4_ops_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - FEATURES:
 * {
 */
/**
 * \brief Interface for field features data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_features_feature_get_f feature_get;
    /**
     * returns define data of ecc_wa_enable
     */
    dnx_data_field_features_ecc_wa_enable_get_f ecc_wa_enable_get;
    /**
     * returns define data of switch_to_acl_context
     */
    dnx_data_field_features_switch_to_acl_context_get_f switch_to_acl_context_get;
    /**
     * returns define data of per_pp_port_pmf_profile_cs_offset
     */
    dnx_data_field_features_per_pp_port_pmf_profile_cs_offset_get_f per_pp_port_pmf_profile_cs_offset_get;
    /**
     * returns define data of tcam_result_flip_eco
     */
    dnx_data_field_features_tcam_result_flip_eco_get_f tcam_result_flip_eco_get;
    /**
     * returns define data of tcam_result_half_payload_on_msb
     */
    dnx_data_field_features_tcam_result_half_payload_on_msb_get_f tcam_result_half_payload_on_msb_get;
    /**
     * returns define data of parsing_start_offset_msb_meaningless
     */
    dnx_data_field_features_parsing_start_offset_msb_meaningless_get_f parsing_start_offset_msb_meaningless_get;
    /**
     * returns define data of kbp_opcode_in_ipmf1_cs
     */
    dnx_data_field_features_kbp_opcode_in_ipmf1_cs_get_f kbp_opcode_in_ipmf1_cs_get;
    /**
     * returns define data of kbp_hitbits_correct_in_ipmf1_cs
     */
    dnx_data_field_features_kbp_hitbits_correct_in_ipmf1_cs_get_f kbp_hitbits_correct_in_ipmf1_cs_get;
    /**
     * returns define data of exem_vmv_removable_from_payload
     */
    dnx_data_field_features_exem_vmv_removable_from_payload_get_f exem_vmv_removable_from_payload_get;
    /**
     * returns define data of multiple_dynamic_mem_enablers
     */
    dnx_data_field_features_multiple_dynamic_mem_enablers_get_f multiple_dynamic_mem_enablers_get;
    /**
     * returns define data of aacl_super_group_handler_enable
     */
    dnx_data_field_features_aacl_super_group_handler_enable_get_f aacl_super_group_handler_enable_get;
    /**
     * returns define data of aacl_tcam_swap_enable
     */
    dnx_data_field_features_aacl_tcam_swap_enable_get_f aacl_tcam_swap_enable_get;
    /**
     * returns define data of extended_l4_ops
     */
    dnx_data_field_features_extended_l4_ops_get_f extended_l4_ops_get;
} dnx_data_if_field_features_t;

/*
 * }
 */

/*
 * SUBMODULE  - SIGNAL_SIZES:
 * signal sizes that change by device, as needed for qualifier and action sizes.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_signal_sizes_feature_nof
} dnx_data_field_signal_sizes_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_signal_sizes_feature_get_f) (
    int unit,
    dnx_data_field_signal_sizes_feature_e feature);

/**
 * \brief returns define data of dual_queue_size
 * Module - 'field', Submodule - 'signal_sizes', data - 'dual_queue_size'
 * Dual queue added by HWJERICHO2C-55 and increased in size in HWJERICHO2P-127. Not supported in J2, but we still configure a value because the DBAL field needs a size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dual_queue_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_signal_sizes_dual_queue_size_get_f) (
    int unit);

/**
 * \brief returns define data of packet_header_size
 * Module - 'field', Submodule - 'signal_sizes', data - 'packet_header_size'
 * packet_header_size. Changed in HWJERICHO2P-384.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     packet_header_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_signal_sizes_packet_header_size_get_f) (
    int unit);

/**
 * \brief returns define data of ecn
 * Module - 'field', Submodule - 'signal_sizes', data - 'ecn'
 * ECN signal. Changed in HWJERICHO2C-565.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecn - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_signal_sizes_ecn_get_f) (
    int unit);

/**
 * \brief returns define data of congestion_info
 * Module - 'field', Submodule - 'signal_sizes', data - 'congestion_info'
 * CONGESTION_INFO signal. Takes ECN by default, and changed with it.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     congestion_info - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_signal_sizes_congestion_info_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - SIGNAL_SIZES:
 * {
 */
/**
 * \brief Interface for field signal_sizes data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_signal_sizes_feature_get_f feature_get;
    /**
     * returns define data of dual_queue_size
     */
    dnx_data_field_signal_sizes_dual_queue_size_get_f dual_queue_size_get;
    /**
     * returns define data of packet_header_size
     */
    dnx_data_field_signal_sizes_packet_header_size_get_f packet_header_size_get;
    /**
     * returns define data of ecn
     */
    dnx_data_field_signal_sizes_ecn_get_f ecn_get;
    /**
     * returns define data of congestion_info
     */
    dnx_data_field_signal_sizes_congestion_info_get_f congestion_info_get;
} dnx_data_if_field_signal_sizes_t;

/*
 * }
 */

/*
 * SUBMODULE  - DNX_DATA_INTERNAL:
 * For internal DNX DATA usage only
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_dnx_data_internal_feature_nof
} dnx_data_field_dnx_data_internal_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_dnx_data_internal_feature_get_f) (
    int unit,
    dnx_data_field_dnx_data_internal_feature_e feature);

/**
 * \brief returns define data of lr_eth_is_da_mac_valid
 * Module - 'field', Submodule - 'dnx_data_internal', data - 'lr_eth_is_da_mac_valid'
 * Whether layer record ETH_IS_DA_MAC works on device (works on JR2_B0 but not on JR2_A0).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lr_eth_is_da_mac_valid - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_dnx_data_internal_lr_eth_is_da_mac_valid_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - DNX_DATA_INTERNAL:
 * {
 */
/**
 * \brief Interface for field dnx_data_internal data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_dnx_data_internal_feature_get_f feature_get;
    /**
     * returns define data of lr_eth_is_da_mac_valid
     */
    dnx_data_field_dnx_data_internal_lr_eth_is_da_mac_valid_get_f lr_eth_is_da_mac_valid_get;
} dnx_data_if_field_dnx_data_internal_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_FIELD:
 * {
 */
/**
 * \brief Interface for field data
 */
typedef struct
{
    /**
     * Interface for field base_ipmf1 data
     */
    dnx_data_if_field_base_ipmf1_t base_ipmf1;
    /**
     * Interface for field base_ipmf2 data
     */
    dnx_data_if_field_base_ipmf2_t base_ipmf2;
    /**
     * Interface for field base_ipmf3 data
     */
    dnx_data_if_field_base_ipmf3_t base_ipmf3;
    /**
     * Interface for field base_epmf data
     */
    dnx_data_if_field_base_epmf_t base_epmf;
    /**
     * Interface for field base_ifwd2 data
     */
    dnx_data_if_field_base_ifwd2_t base_ifwd2;
    /**
     * Interface for field stage data
     */
    dnx_data_if_field_stage_t stage;
    /**
     * Interface for field kbp data
     */
    dnx_data_if_field_kbp_t kbp;
    /**
     * Interface for field tcam data
     */
    dnx_data_if_field_tcam_t tcam;
    /**
     * Interface for field group data
     */
    dnx_data_if_field_group_t group;
    /**
     * Interface for field efes data
     */
    dnx_data_if_field_efes_t efes;
    /**
     * Interface for field fem data
     */
    dnx_data_if_field_fem_t fem;
    /**
     * Interface for field context data
     */
    dnx_data_if_field_context_t context;
    /**
     * Interface for field preselector data
     */
    dnx_data_if_field_preselector_t preselector;
    /**
     * Interface for field qual data
     */
    dnx_data_if_field_qual_t qual;
    /**
     * Interface for field action data
     */
    dnx_data_if_field_action_t action;
    /**
     * Interface for field virtual_wire data
     */
    dnx_data_if_field_virtual_wire_t virtual_wire;
    /**
     * Interface for field profile_bits data
     */
    dnx_data_if_field_profile_bits_t profile_bits;
    /**
     * Interface for field dir_ext data
     */
    dnx_data_if_field_dir_ext_t dir_ext;
    /**
     * Interface for field state_table data
     */
    dnx_data_if_field_state_table_t state_table;
    /**
     * Interface for field map data
     */
    dnx_data_if_field_map_t map;
    /**
     * Interface for field hash data
     */
    dnx_data_if_field_hash_t hash;
    /**
     * Interface for field udh data
     */
    dnx_data_if_field_udh_t udh;
    /**
     * Interface for field system_headers data
     */
    dnx_data_if_field_system_headers_t system_headers;
    /**
     * Interface for field exem data
     */
    dnx_data_if_field_exem_t exem;
    /**
     * Interface for field ace data
     */
    dnx_data_if_field_ace_t ace;
    /**
     * Interface for field entry data
     */
    dnx_data_if_field_entry_t entry;
    /**
     * Interface for field L4_Ops data
     */
    dnx_data_if_field_L4_Ops_t L4_Ops;
    /**
     * Interface for field encoded_qual_actions_offset data
     */
    dnx_data_if_field_encoded_qual_actions_offset_t encoded_qual_actions_offset;
    /**
     * Interface for field Compare_operand data
     */
    dnx_data_if_field_Compare_operand_t Compare_operand;
    /**
     * Interface for field diag data
     */
    dnx_data_if_field_diag_t diag;
    /**
     * Interface for field common_max_val data
     */
    dnx_data_if_field_common_max_val_t common_max_val;
    /**
     * Interface for field init data
     */
    dnx_data_if_field_init_t init;
    /**
     * Interface for field features data
     */
    dnx_data_if_field_features_t features;
    /**
     * Interface for field signal_sizes data
     */
    dnx_data_if_field_signal_sizes_t signal_sizes;
    /**
     * Interface for field dnx_data_internal data
     */
    dnx_data_if_field_dnx_data_internal_t dnx_data_internal;
} dnx_data_if_field_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_field_t dnx_data_field;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_FIELD_H_*/
/* *INDENT-ON* */
