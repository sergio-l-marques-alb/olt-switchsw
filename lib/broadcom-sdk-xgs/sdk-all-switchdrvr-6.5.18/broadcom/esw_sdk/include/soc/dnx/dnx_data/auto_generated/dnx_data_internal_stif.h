/** \file dnx_data_internal_stif.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_STIF_H_
/*{*/
#define _DNX_DATA_INTERNAL_STIF_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_stif.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_stif_submodule_config,
    dnx_data_stif_submodule_port,
    dnx_data_stif_submodule_report,
    dnx_data_stif_submodule_flow_control,

    /**
     * Must be last one!
     */
    _dnx_data_stif_submodule_nof
} dnx_data_stif_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE CONFIG:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_stif_config_feature_get(
    int unit,
    dnx_data_stif_config_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_stif_config_define_sram_buffers_resolution,
    dnx_data_stif_config_define_sram_pdbs_resolution,
    dnx_data_stif_config_define_dram_bdb_resolution,
    dnx_data_stif_config_define_stif_packet_size,
    dnx_data_stif_config_define_stif_scrubber_queue_min,
    dnx_data_stif_config_define_stif_scrubber_queue_max,
    dnx_data_stif_config_define_stif_scrubber_rate_min,
    dnx_data_stif_config_define_stif_scrubber_rate_max,
    dnx_data_stif_config_define_stif_report_mode,
    dnx_data_stif_config_define_stif_report_size_ingress,
    dnx_data_stif_config_define_stif_report_size_egress,
    dnx_data_stif_config_define_stif_idle_report,
    dnx_data_stif_config_define_nof_valid_sources,

    /**
     * Must be last one!
     */
    _dnx_data_stif_config_define_nof
} dnx_data_stif_config_define_e;

/* Get Data */
/**
 * \brief returns define data of sram_buffers_resolution
 * Module - 'stif', Submodule - 'config', data - 'sram_buffers_resolution'
 * scrubber sram buffers threshold resolution
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_buffers_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_sram_buffers_resolution_get(
    int unit);

/**
 * \brief returns define data of sram_pdbs_resolution
 * Module - 'stif', Submodule - 'config', data - 'sram_pdbs_resolution'
 * scrubber sram pdbs threshold resolution
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_pdbs_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_sram_pdbs_resolution_get(
    int unit);

/**
 * \brief returns define data of dram_bdb_resolution
 * Module - 'stif', Submodule - 'config', data - 'dram_bdb_resolution'
 * scrubber dram bdb threshold resolution
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_bdb_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_dram_bdb_resolution_get(
    int unit);

/**
 * \brief returns numeric data of stif_packet_size
 * Module - 'stif', Submodule - 'config', data - 'stif_packet_size'
 * Configure the packet size - for all report modes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stif_packet_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_stif_packet_size_get(
    int unit);

/**
 * \brief returns numeric data of stif_scrubber_queue_min
 * Module - 'stif', Submodule - 'config', data - 'stif_scrubber_queue_min'
 * Scrubber queue minimum - for QSIZE
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stif_scrubber_queue_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_stif_scrubber_queue_min_get(
    int unit);

/**
 * \brief returns numeric data of stif_scrubber_queue_max
 * Module - 'stif', Submodule - 'config', data - 'stif_scrubber_queue_max'
 * Scrubber queue maximum - for QSIZE
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stif_scrubber_queue_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_stif_scrubber_queue_max_get(
    int unit);

/**
 * \brief returns numeric data of stif_scrubber_rate_min
 * Module - 'stif', Submodule - 'config', data - 'stif_scrubber_rate_min'
 * The minimal period between two conscutive scrubber reports in nanoseconds - for QSIZE
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stif_scrubber_rate_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_stif_scrubber_rate_min_get(
    int unit);

/**
 * \brief returns numeric data of stif_scrubber_rate_max
 * Module - 'stif', Submodule - 'config', data - 'stif_scrubber_rate_max'
 * It indicates the maximal period between two consecutive scrubber reports in nanoseconds - for QSIZE
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stif_scrubber_rate_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_stif_scrubber_rate_max_get(
    int unit);

/**
 * \brief returns numeric data of stif_report_mode
 * Module - 'stif', Submodule - 'config', data - 'stif_report_mode'
 * stif report mode value - qsize/billing/ billing ingress
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stif_report_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_stif_report_mode_get(
    int unit);

/**
 * \brief returns numeric data of stif_report_size_ingress
 * Module - 'stif', Submodule - 'config', data - 'stif_report_size_ingress'
 * ingress stif report size in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stif_report_size_ingress - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_stif_report_size_ingress_get(
    int unit);

/**
 * \brief returns numeric data of stif_report_size_egress
 * Module - 'stif', Submodule - 'config', data - 'stif_report_size_egress'
 * egress stif report size in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stif_report_size_egress - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_stif_report_size_egress_get(
    int unit);

/**
 * \brief returns numeric data of stif_idle_report
 * Module - 'stif', Submodule - 'config', data - 'stif_idle_report'
 * Configure if empty reports will be sent; if they will - the period will be 256
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stif_idle_report - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_stif_idle_report_get(
    int unit);

/**
 * \brief returns numeric data of nof_valid_sources
 * Module - 'stif', Submodule - 'config', data - 'nof_valid_sources'
 * qsize valid sources inq/deq/scrubber; billing valid sources - inq/deq/egr 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_valid_sources - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_config_nof_valid_sources_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_stif_config_table_scrubber_buffers,
    dnx_data_stif_config_table_selective_report_range,

    /**
     * Must be last one!
     */
    _dnx_data_stif_config_table_nof
} dnx_data_stif_config_table_e;

/* Get Data */
/**
 * \brief get table scrubber_buffers entry 
 * scrubber buffer limits
 * 
 * \param [in] unit - unit #
 * \param [in] thresh_id - threshold id
 * 
 * \return
 *     scrubber_buffers - returns the relevant entry values grouped in struct - see dnx_data_stif_config_scrubber_buffers_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_stif_config_scrubber_buffers_t * dnx_data_stif_config_scrubber_buffers_get(
    int unit,
    int thresh_id);

/**
 * \brief get table selective_report_range entry 
 * select the range of queues for qsize report - 2 ranges
 * 
 * \param [in] unit - unit #
 * \param [in] range_id - range id - 0/1
 * 
 * \return
 *     selective_report_range - returns the relevant entry values grouped in struct - see dnx_data_stif_config_selective_report_range_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_stif_config_selective_report_range_t * dnx_data_stif_config_selective_report_range_get(
    int unit,
    int range_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'stif', Submodule - 'config', table - 'scrubber_buffers'
 * scrubber buffer limits
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_stif_config_scrubber_buffers_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'stif', Submodule - 'config', table - 'selective_report_range'
 * select the range of queues for qsize report - 2 ranges
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_stif_config_selective_report_range_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)scrubber_buffers info
 * scrubber buffer limits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     scrubber_buffers - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_stif_config_scrubber_buffers_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)selective_report_range info
 * select the range of queues for qsize report - 2 ranges
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     selective_report_range - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_stif_config_selective_report_range_info_get(
    int unit);

/*
 * SUBMODULE PORT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_stif_port_feature_get(
    int unit,
    dnx_data_stif_port_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_stif_port_define_max_nof_instances,
    dnx_data_stif_port_define_stif_ethu_select_size,
    dnx_data_stif_port_define_stif_lane_mapping_size,

    /**
     * Must be last one!
     */
    _dnx_data_stif_port_define_nof
} dnx_data_stif_port_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_instances
 * Module - 'stif', Submodule - 'port', data - 'max_nof_instances'
 * stif-nif port instances
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_instances - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_port_max_nof_instances_get(
    int unit);

/**
 * \brief returns define data of stif_ethu_select_size
 * Module - 'stif', Submodule - 'port', data - 'stif_ethu_select_size'
 * used for dbal - size of stif ethu select in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stif_ethu_select_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_port_stif_ethu_select_size_get(
    int unit);

/**
 * \brief returns define data of stif_lane_mapping_size
 * Module - 'stif', Submodule - 'port', data - 'stif_lane_mapping_size'
 * used for dbal - size of stif to lane bitmap in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stif_lane_mapping_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_port_stif_lane_mapping_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_stif_port_table_ethu_id_stif_valid,

    /**
     * Must be last one!
     */
    _dnx_data_stif_port_table_nof
} dnx_data_stif_port_table_e;

/* Get Data */
/**
 * \brief get table ethu_id_stif_valid entry 
 * stif-nif valid ethu ids for stif and their according hw value to be set
 * 
 * \param [in] unit - unit #
 * \param [in] ethu_id - ethu id
 * 
 * \return
 *     ethu_id_stif_valid - returns the relevant entry values grouped in struct - see dnx_data_stif_port_ethu_id_stif_valid_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_stif_port_ethu_id_stif_valid_t * dnx_data_stif_port_ethu_id_stif_valid_get(
    int unit,
    int ethu_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'stif', Submodule - 'port', table - 'ethu_id_stif_valid'
 * stif-nif valid ethu ids for stif and their according hw value to be set
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_stif_port_ethu_id_stif_valid_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)ethu_id_stif_valid info
 * stif-nif valid ethu ids for stif and their according hw value to be set
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ethu_id_stif_valid - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_stif_port_ethu_id_stif_valid_info_get(
    int unit);

/*
 * SUBMODULE REPORT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_stif_report_feature_get(
    int unit,
    dnx_data_stif_report_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_stif_report_define_qsize_idle_report_size,
    dnx_data_stif_report_define_qsize_idle_report_period,
    dnx_data_stif_report_define_qsize_idle_report_period_invalid,
    dnx_data_stif_report_define_qsize_scrubber_report_cycles_unit,
    dnx_data_stif_report_define_max_thresholds_per_buffer,
    dnx_data_stif_report_define_incoming_tc,
    dnx_data_stif_report_define_record_two_msb,
    dnx_data_stif_report_define_nof_source_types,
    dnx_data_stif_report_define_stat_id_max_count,
    dnx_data_stif_report_define_stat_object_size,
    dnx_data_stif_report_define_billing_format_element_packet_size,
    dnx_data_stif_report_define_billing_format_msb_opcode_size,
    dnx_data_stif_report_define_billing_format_etpp_metadata_size,
    dnx_data_stif_report_define_billing_opsize_use_one_type_mask,
    dnx_data_stif_report_define_billing_opsize_use_two_types_mask,
    dnx_data_stif_report_define_billing_opsize_use_three_types_mask,
    dnx_data_stif_report_define_billing_opsize_use_four_types_mask,
    dnx_data_stif_report_define_billing_enq_ing_size_wa_shift,

    /**
     * Must be last one!
     */
    _dnx_data_stif_report_define_nof
} dnx_data_stif_report_define_e;

/* Get Data */
/**
 * \brief returns define data of qsize_idle_report_size
 * Module - 'stif', Submodule - 'report', data - 'qsize_idle_report_size'
 * default value for qsize idle report size in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     qsize_idle_report_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_qsize_idle_report_size_get(
    int unit);

/**
 * \brief returns define data of qsize_idle_report_period
 * Module - 'stif', Submodule - 'report', data - 'qsize_idle_report_period'
 * default value for the QSIZE report period
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     qsize_idle_report_period - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_qsize_idle_report_period_get(
    int unit);

/**
 * \brief returns define data of qsize_idle_report_period_invalid
 * Module - 'stif', Submodule - 'report', data - 'qsize_idle_report_period_invalid'
 * disable the idle report generation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     qsize_idle_report_period_invalid - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_qsize_idle_report_period_invalid_get(
    int unit);

/**
 * \brief returns define data of qsize_scrubber_report_cycles_unit
 * Module - 'stif', Submodule - 'report', data - 'qsize_scrubber_report_cycles_unit'
 * Period between consecutive scrubber records is in units - unit = defined cycle periods
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     qsize_scrubber_report_cycles_unit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_qsize_scrubber_report_cycles_unit_get(
    int unit);

/**
 * \brief returns define data of max_thresholds_per_buffer
 * Module - 'stif', Submodule - 'report', data - 'max_thresholds_per_buffer'
 * scrubber buffer thresholds - the thresholds define 16 ranges of buffer occupancy
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_thresholds_per_buffer - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_max_thresholds_per_buffer_get(
    int unit);

/**
 * \brief returns define data of incoming_tc
 * Module - 'stif', Submodule - 'report', data - 'incoming_tc'
 * STIF uses incoming TC (tc reported by PP) and cannot be changed by the user - hw value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     incoming_tc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_incoming_tc_get(
    int unit);

/**
 * \brief returns define data of record_two_msb
 * Module - 'stif', Submodule - 'report', data - 'record_two_msb'
 * two MSB of the record should be 2'b11
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     record_two_msb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_record_two_msb_get(
    int unit);

/**
 * \brief returns define data of nof_source_types
 * Module - 'stif', Submodule - 'report', data - 'nof_source_types'
 * number of source types - ingress enq/deq/scrubber, egress - regarding bcm_stat_stif_source_type_t struct
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_source_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_nof_source_types_get(
    int unit);

/**
 * \brief returns define data of stat_id_max_count
 * Module - 'stif', Submodule - 'report', data - 'stat_id_max_count'
 * max count of possible statistics ids
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stat_id_max_count - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_stat_id_max_count_get(
    int unit);

/**
 * \brief returns define data of stat_object_size
 * Module - 'stif', Submodule - 'report', data - 'stat_object_size'
 * the size of a statistic object (0,1,2,3) - size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stat_object_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_stat_object_size_get(
    int unit);

/**
 * \brief returns define data of billing_format_element_packet_size
 * Module - 'stif', Submodule - 'report', data - 'billing_format_element_packet_size'
 * get size of the  billing element for packet size - size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_format_element_packet_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_billing_format_element_packet_size_get(
    int unit);

/**
 * \brief returns define data of billing_format_msb_opcode_size
 * Module - 'stif', Submodule - 'report', data - 'billing_format_msb_opcode_size'
 * get size of the  billing element opcode which the user cannot change - size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_format_msb_opcode_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_billing_format_msb_opcode_size_get(
    int unit);

/**
 * \brief returns define data of billing_format_etpp_metadata_size
 * Module - 'stif', Submodule - 'report', data - 'billing_format_etpp_metadata_size'
 * billing record format ETPP metadata size - size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_format_etpp_metadata_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_billing_format_etpp_metadata_size_get(
    int unit);

/**
 * \brief returns define data of billing_opsize_use_one_type_mask
 * Module - 'stif', Submodule - 'report', data - 'billing_opsize_use_one_type_mask'
 * billing record format opsize mask to use one type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_opsize_use_one_type_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_billing_opsize_use_one_type_mask_get(
    int unit);

/**
 * \brief returns define data of billing_opsize_use_two_types_mask
 * Module - 'stif', Submodule - 'report', data - 'billing_opsize_use_two_types_mask'
 * billing record format mask to use two types
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_opsize_use_two_types_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_billing_opsize_use_two_types_mask_get(
    int unit);

/**
 * \brief returns define data of billing_opsize_use_three_types_mask
 * Module - 'stif', Submodule - 'report', data - 'billing_opsize_use_three_types_mask'
 * billing record format mask to use three types
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_opsize_use_three_types_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_billing_opsize_use_three_types_mask_get(
    int unit);

/**
 * \brief returns define data of billing_opsize_use_four_types_mask
 * Module - 'stif', Submodule - 'report', data - 'billing_opsize_use_four_types_mask'
 * billing record format mask to use four types
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_opsize_use_four_types_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_billing_opsize_use_four_types_mask_get(
    int unit);

/**
 * \brief returns define data of billing_enq_ing_size_wa_shift
 * Module - 'stif', Submodule - 'report', data - 'billing_enq_ing_size_wa_shift'
 * billing record ingress enqueu size=96. need to reduce wa_shift value from each element sgift value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_enq_ing_size_wa_shift - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_report_billing_enq_ing_size_wa_shift_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_stif_report_table_etpp_metadata,
    dnx_data_stif_report_table_report_size,

    /**
     * Must be last one!
     */
    _dnx_data_stif_report_table_nof
} dnx_data_stif_report_table_e;

/* Get Data */
/**
 * \brief get table etpp_metadata entry 
 * etpp metadata elements and their size in bits
 * 
 * \param [in] unit - unit #
 * \param [in] element - metadata element type
 * 
 * \return
 *     etpp_metadata - returns the relevant entry values grouped in struct - see dnx_data_stif_report_etpp_metadata_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_stif_report_etpp_metadata_t * dnx_data_stif_report_etpp_metadata_get(
    int unit,
    int element);

/**
 * \brief get table report_size entry 
 * connect the soc property mapped value of the report size to the real value in bits
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_enum - the value that will get from the soc property
 * 
 * \return
 *     report_size - returns the relevant entry values grouped in struct - see dnx_data_stif_report_report_size_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_stif_report_report_size_t * dnx_data_stif_report_report_size_get(
    int unit,
    int dbal_enum);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'stif', Submodule - 'report', table - 'etpp_metadata'
 * etpp metadata elements and their size in bits
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_stif_report_etpp_metadata_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'stif', Submodule - 'report', table - 'report_size'
 * connect the soc property mapped value of the report size to the real value in bits
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_stif_report_report_size_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)etpp_metadata info
 * etpp metadata elements and their size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     etpp_metadata - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_stif_report_etpp_metadata_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)report_size info
 * connect the soc property mapped value of the report size to the real value in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     report_size - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_stif_report_report_size_info_get(
    int unit);

/*
 * SUBMODULE FLOW_CONTROL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_stif_flow_control_feature_get(
    int unit,
    dnx_data_stif_flow_control_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_stif_flow_control_define_etpp_pipe_length,
    dnx_data_stif_flow_control_define_etpp_deq_size_of_fifo,
    dnx_data_stif_flow_control_define_cgm_pipe_length,
    dnx_data_stif_flow_control_define_cgm_size_of_fifo,
    dnx_data_stif_flow_control_define_billing_level_sampling,
    dnx_data_stif_flow_control_define_fc_disable_value,
    dnx_data_stif_flow_control_define_billing_etpp_flow_control_high,
    dnx_data_stif_flow_control_define_billing_etpp_flow_control_low,
    dnx_data_stif_flow_control_define_billing_cgm_flow_control_high,
    dnx_data_stif_flow_control_define_billing_cgm_flow_control_low,
    dnx_data_stif_flow_control_define_qsize_cgm_flow_control_high,
    dnx_data_stif_flow_control_define_qsize_cgm_flow_control_low,

    /**
     * Must be last one!
     */
    _dnx_data_stif_flow_control_define_nof
} dnx_data_stif_flow_control_define_e;

/* Get Data */
/**
 * \brief returns define data of etpp_pipe_length
 * Module - 'stif', Submodule - 'flow_control', data - 'etpp_pipe_length'
 * pipe length size in clocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     etpp_pipe_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_etpp_pipe_length_get(
    int unit);

/**
 * \brief returns define data of etpp_deq_size_of_fifo
 * Module - 'stif', Submodule - 'flow_control', data - 'etpp_deq_size_of_fifo'
 * etpp dequeue size of fifo - reports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     etpp_deq_size_of_fifo - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_etpp_deq_size_of_fifo_get(
    int unit);

/**
 * \brief returns define data of cgm_pipe_length
 * Module - 'stif', Submodule - 'flow_control', data - 'cgm_pipe_length'
 * cgm pipe length in clocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cgm_pipe_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_cgm_pipe_length_get(
    int unit);

/**
 * \brief returns define data of cgm_size_of_fifo
 * Module - 'stif', Submodule - 'flow_control', data - 'cgm_size_of_fifo'
 * cgm size of fifo - reports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cgm_size_of_fifo - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_cgm_size_of_fifo_get(
    int unit);

/**
 * \brief returns define data of billing_level_sampling
 * Module - 'stif', Submodule - 'flow_control', data - 'billing_level_sampling'
 * level sampling value - used for billing flow control calculation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_level_sampling - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_billing_level_sampling_get(
    int unit);

/**
 * \brief returns define data of fc_disable_value
 * Module - 'stif', Submodule - 'flow_control', data - 'fc_disable_value'
 * disable flow control value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fc_disable_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_fc_disable_value_get(
    int unit);

/**
 * \brief returns define data of billing_etpp_flow_control_high
 * Module - 'stif', Submodule - 'flow_control', data - 'billing_etpp_flow_control_high'
 * billing etpp flow control max value - calculated with formula given from the architecture
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_etpp_flow_control_high - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_billing_etpp_flow_control_high_get(
    int unit);

/**
 * \brief returns define data of billing_etpp_flow_control_low
 * Module - 'stif', Submodule - 'flow_control', data - 'billing_etpp_flow_control_low'
 * billing etpp flow control min value - calculated with formula given from the architecture
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_etpp_flow_control_low - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_billing_etpp_flow_control_low_get(
    int unit);

/**
 * \brief returns define data of billing_cgm_flow_control_high
 * Module - 'stif', Submodule - 'flow_control', data - 'billing_cgm_flow_control_high'
 * billing cgm flow control max value - calculated with formula given from the architecture
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_cgm_flow_control_high - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_billing_cgm_flow_control_high_get(
    int unit);

/**
 * \brief returns define data of billing_cgm_flow_control_low
 * Module - 'stif', Submodule - 'flow_control', data - 'billing_cgm_flow_control_low'
 * billing cgm flow control min value - calculated with formula given from the architecture
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     billing_cgm_flow_control_low - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_billing_cgm_flow_control_low_get(
    int unit);

/**
 * \brief returns define data of qsize_cgm_flow_control_high
 * Module - 'stif', Submodule - 'flow_control', data - 'qsize_cgm_flow_control_high'
 * qsize cgm flow control max value - calculated with formula given from the architecture
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     qsize_cgm_flow_control_high - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_qsize_cgm_flow_control_high_get(
    int unit);

/**
 * \brief returns define data of qsize_cgm_flow_control_low
 * Module - 'stif', Submodule - 'flow_control', data - 'qsize_cgm_flow_control_low'
 * qsize cgm flow control min value - calculated with formula given from the architecture
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     qsize_cgm_flow_control_low - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_stif_flow_control_qsize_cgm_flow_control_low_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_stif_flow_control_table_nof
} dnx_data_stif_flow_control_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_stif_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_STIF_H_*/
/* *INDENT-ON* */
