/** \file dnx_data_internal_dram.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_DRAM_H_
/*{*/
#define _DNX_DATA_INTERNAL_DRAM_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_dram.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_dram_submodule_hbm,
    dnx_data_dram_submodule_gddr6,
    dnx_data_dram_submodule_general_info,
    dnx_data_dram_submodule_address_translation,
    dnx_data_dram_submodule_buffers,
    dnx_data_dram_submodule_dram_block,
    dnx_data_dram_submodule_dbal,

    /**
     * Must be last one!
     */
    _dnx_data_dram_submodule_nof
} dnx_data_dram_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE HBM:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_hbm_feature_get(
    int unit,
    dnx_data_dram_hbm_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_hbm_define_burst_length,
    dnx_data_dram_hbm_define_stop_traffic_temp_threshold,
    dnx_data_dram_hbm_define_stop_traffic_low_temp_threshold,
    dnx_data_dram_hbm_define_restore_traffic_temp_threshold,
    dnx_data_dram_hbm_define_restore_traffic_low_temp_threshold,
    dnx_data_dram_hbm_define_usec_between_temp_samples,
    dnx_data_dram_hbm_define_power_down_temp_threshold,
    dnx_data_dram_hbm_define_power_down_low_temp_threshold,
    dnx_data_dram_hbm_define_dram_temp_monitor_enable,
    dnx_data_dram_hbm_define_channel_broadcast_id,
    dnx_data_dram_hbm_define_hbc_physical_last_in_chain,
    dnx_data_dram_hbm_define_default_model_part_num,

    /**
     * Must be last one!
     */
    _dnx_data_dram_hbm_define_nof
} dnx_data_dram_hbm_define_e;

/* Get Data */
/**
 * \brief returns numeric data of burst_length
 * Module - 'dram', Submodule - 'hbm', data - 'burst_length'
 * burst length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     burst_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_burst_length_get(
    int unit);

/**
 * \brief returns numeric data of stop_traffic_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'stop_traffic_temp_threshold'
 * temperature threshold (C degrees) above which the HBM should not recieve packets anymore
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stop_traffic_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_stop_traffic_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of stop_traffic_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'stop_traffic_low_temp_threshold'
 * Low temperature threshold (C degrees) below which the HBM should not recieve packets anymore
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stop_traffic_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_stop_traffic_low_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of restore_traffic_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'restore_traffic_temp_threshold'
 * temperature threshold (C degrees) below which the HBM should be reassigned to usage in the traffic flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     restore_traffic_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_restore_traffic_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of restore_traffic_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'restore_traffic_low_temp_threshold'
 * Low temperature threshold (C degrees) above which the HBM should be reassigned to usage in the traffic flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     restore_traffic_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_restore_traffic_low_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of usec_between_temp_samples
 * Module - 'dram', Submodule - 'hbm', data - 'usec_between_temp_samples'
 * time in usecs to wait between HBM temperature sampling
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     usec_between_temp_samples - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_usec_between_temp_samples_get(
    int unit);

/**
 * \brief returns numeric data of power_down_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'power_down_temp_threshold'
 * temperature threshold, for doing DRAM shut down
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     power_down_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_power_down_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of power_down_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'power_down_low_temp_threshold'
 * Low temperature threshold, for doing DRAM shut down
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     power_down_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_power_down_low_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of dram_temp_monitor_enable
 * Module - 'dram', Submodule - 'hbm', data - 'dram_temp_monitor_enable'
 * enable/disable driver temperature monitoring
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_temp_monitor_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_dram_temp_monitor_enable_get(
    int unit);

/**
 * \brief returns define data of channel_broadcast_id
 * Module - 'dram', Submodule - 'hbm', data - 'channel_broadcast_id'
 * channel id to use in dbal when trying to broadcast
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_broadcast_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_channel_broadcast_id_get(
    int unit);

/**
 * \brief returns define data of hbc_physical_last_in_chain
 * Module - 'dram', Submodule - 'hbm', data - 'hbc_physical_last_in_chain'
 * block index of the physically last in chain hbc, provided all hbms are active
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbc_physical_last_in_chain - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_hbc_physical_last_in_chain_get(
    int unit);

/**
 * \brief returns define data of default_model_part_num
 * Module - 'dram', Submodule - 'hbm', data - 'default_model_part_num'
 * default model part number
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_model_part_num - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_default_model_part_num_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_hbm_table_channel_symmetric_regs,
    dnx_data_dram_hbm_table_channel_not_symmetric_regs,
    dnx_data_dram_hbm_table_controller_symmetric_regs,
    dnx_data_dram_hbm_table_controller_not_symmetric_regs,
    dnx_data_dram_hbm_table_channel_interrupt_regs,
    dnx_data_dram_hbm_table_controller_interrupt_regs,
    dnx_data_dram_hbm_table_channel_debug_regs,
    dnx_data_dram_hbm_table_channel_counter_regs,
    dnx_data_dram_hbm_table_channel_type_regs,
    dnx_data_dram_hbm_table_controller_info_regs,

    /**
     * Must be last one!
     */
    _dnx_data_dram_hbm_table_nof
} dnx_data_dram_hbm_table_e;

/* Get Data */
/**
 * \brief get table channel_symmetric_regs entry 
 * per channel list of symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_symmetric_regs_t * dnx_data_dram_hbm_channel_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_not_symmetric_regs entry 
 * per channel list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_not_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_not_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_not_symmetric_regs_t * dnx_data_dram_hbm_channel_not_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_symmetric_regs entry 
 * per controller list of symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_symmetric_regs_t * dnx_data_dram_hbm_controller_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_not_symmetric_regs entry 
 * per controller list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_not_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_not_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_not_symmetric_regs_t * dnx_data_dram_hbm_controller_not_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_interrupt_regs entry 
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_interrupt_regs_t * dnx_data_dram_hbm_channel_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_interrupt_regs entry 
 * per controller list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_interrupt_regs_t * dnx_data_dram_hbm_controller_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_debug_regs entry 
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_debug_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_debug_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_debug_regs_t * dnx_data_dram_hbm_channel_debug_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_counter_regs entry 
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_counter_regs_t * dnx_data_dram_hbm_channel_counter_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_type_regs entry 
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_type_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_type_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_type_regs_t * dnx_data_dram_hbm_channel_type_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_info_regs entry 
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_info_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_info_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_info_regs_t * dnx_data_dram_hbm_controller_info_regs_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_symmetric_regs'
 * per channel list of symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_not_symmetric_regs'
 * per channel list of not symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_not_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_symmetric_regs'
 * per controller list of symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_not_symmetric_regs'
 * per controller list of not symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_not_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_interrupt_regs'
 * per channel list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_interrupt_regs'
 * per controller list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_debug_regs'
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_debug_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_counter_regs'
 * per channel list of counter registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_counter_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_type_regs'
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_type_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_info_regs'
 * per contorller list of info registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_info_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)channel_symmetric_regs info
 * per channel list of symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_not_symmetric_regs info
 * per channel list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_not_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_not_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_symmetric_regs info
 * per controller list of symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_not_symmetric_regs info
 * per controller list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_not_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_not_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_interrupt_regs info
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_interrupt_regs info
 * per controller list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_debug_regs info
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_debug_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_debug_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_counter_regs info
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_counter_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_counter_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_type_regs info
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_type_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_type_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_info_regs info
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_info_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_info_regs_info_get(
    int unit);

/*
 * SUBMODULE GDDR6:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_gddr6_feature_get(
    int unit,
    dnx_data_dram_gddr6_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_gddr6_define_nof_ca_bits,
    dnx_data_dram_gddr6_define_bytes_per_channel,
    dnx_data_dram_gddr6_define_training_fifo_depth,
    dnx_data_dram_gddr6_define_refresh_mechanism_enable,
    dnx_data_dram_gddr6_define_bist_enable,
    dnx_data_dram_gddr6_define_write_recovery,
    dnx_data_dram_gddr6_define_cabi,
    dnx_data_dram_gddr6_define_dram_mode,
    dnx_data_dram_gddr6_define_cal_termination,
    dnx_data_dram_gddr6_define_cah_termination,
    dnx_data_dram_gddr6_define_command_pipe_extra_delay,
    dnx_data_dram_gddr6_define_use_11bits_ca,
    dnx_data_dram_gddr6_define_ck_odt,
    dnx_data_dram_gddr6_define_dynamic_calibration_period,

    /**
     * Must be last one!
     */
    _dnx_data_dram_gddr6_define_nof
} dnx_data_dram_gddr6_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ca_bits
 * Module - 'dram', Submodule - 'gddr6', data - 'nof_ca_bits'
 * number of command address bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ca_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_nof_ca_bits_get(
    int unit);

/**
 * \brief returns define data of bytes_per_channel
 * Module - 'dram', Submodule - 'gddr6', data - 'bytes_per_channel'
 * bytes per channel in GDDR6 dram
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bytes_per_channel - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_bytes_per_channel_get(
    int unit);

/**
 * \brief returns define data of training_fifo_depth
 * Module - 'dram', Submodule - 'gddr6', data - 'training_fifo_depth'
 * the depth of the training fifo in GDDR6 dram
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     training_fifo_depth - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_training_fifo_depth_get(
    int unit);

/**
 * \brief returns numeric data of refresh_mechanism_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'refresh_mechanism_enable'
 * TSM refresh mechanism enable
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_mechanism_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_refresh_mechanism_enable_get(
    int unit);

/**
 * \brief returns numeric data of bist_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'bist_enable'
 * DRAM bist enable
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bist_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_bist_enable_get(
    int unit);

/**
 * \brief returns numeric data of write_recovery
 * Module - 'dram', Submodule - 'gddr6', data - 'write_recovery'
 * write recovery
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     write_recovery - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_write_recovery_get(
    int unit);

/**
 * \brief returns numeric data of cabi
 * Module - 'dram', Submodule - 'gddr6', data - 'cabi'
 * enable cabi
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cabi - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_cabi_get(
    int unit);

/**
 * \brief returns numeric data of dram_mode
 * Module - 'dram', Submodule - 'gddr6', data - 'dram_mode'
 * dram mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_dram_mode_get(
    int unit);

/**
 * \brief returns numeric data of cal_termination
 * Module - 'dram', Submodule - 'gddr6', data - 'cal_termination'
 * CAL Termination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_termination - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_cal_termination_get(
    int unit);

/**
 * \brief returns numeric data of cah_termination
 * Module - 'dram', Submodule - 'gddr6', data - 'cah_termination'
 * CAH Termination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cah_termination - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_cah_termination_get(
    int unit);

/**
 * \brief returns numeric data of command_pipe_extra_delay
 * Module - 'dram', Submodule - 'gddr6', data - 'command_pipe_extra_delay'
 * command pipe extra delay
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_pipe_extra_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_command_pipe_extra_delay_get(
    int unit);

/**
 * \brief returns numeric data of use_11bits_ca
 * Module - 'dram', Submodule - 'gddr6', data - 'use_11bits_ca'
 * use 11bits for command address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     use_11bits_ca - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_use_11bits_ca_get(
    int unit);

/**
 * \brief returns numeric data of ck_odt
 * Module - 'dram', Submodule - 'gddr6', data - 'ck_odt'
 * CK ODT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ck_odt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_ck_odt_get(
    int unit);

/**
 * \brief returns numeric data of dynamic_calibration_period
 * Module - 'dram', Submodule - 'gddr6', data - 'dynamic_calibration_period'
 * time between 2 iterations of dynamic calibration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dynamic_calibration_period - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_dynamic_calibration_period_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_gddr6_table_refresh_intervals,
    dnx_data_dram_gddr6_table_dq_map,
    dnx_data_dram_gddr6_table_dq_channel_swap,
    dnx_data_dram_gddr6_table_dq_byte_map,
    dnx_data_dram_gddr6_table_ca_map,
    dnx_data_dram_gddr6_table_cadt_byte_map,
    dnx_data_dram_gddr6_table_channel_regs,
    dnx_data_dram_gddr6_table_controller_regs,
    dnx_data_dram_gddr6_table_channel_interrupt_regs,
    dnx_data_dram_gddr6_table_controller_interrupt_regs,
    dnx_data_dram_gddr6_table_channel_debug_regs,
    dnx_data_dram_gddr6_table_channel_counter_regs,
    dnx_data_dram_gddr6_table_channel_type_regs,
    dnx_data_dram_gddr6_table_controller_info_regs,

    /**
     * Must be last one!
     */
    _dnx_data_dram_gddr6_table_nof
} dnx_data_dram_gddr6_table_e;

/* Get Data */
/**
 * \brief get table refresh_intervals entry 
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_intervals - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_refresh_intervals_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_refresh_intervals_t * dnx_data_dram_gddr6_refresh_intervals_get(
    int unit);

/**
 * \brief get table dq_map entry 
 * DQ swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] byte - bit on dram
 * 
 * \return
 *     dq_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_dq_map_t * dnx_data_dram_gddr6_dq_map_get(
    int unit,
    int dram_index,
    int byte);

/**
 * \brief get table dq_channel_swap entry 
 * DQ channel swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * 
 * \return
 *     dq_channel_swap - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_channel_swap_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_dq_channel_swap_t * dnx_data_dram_gddr6_dq_channel_swap_get(
    int unit,
    int dram_index);

/**
 * \brief get table dq_byte_map entry 
 * DQ bytes swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] byte - byte on dram
 * 
 * \return
 *     dq_byte_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_byte_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_dq_byte_map_t * dnx_data_dram_gddr6_dq_byte_map_get(
    int unit,
    int dram_index,
    int byte);

/**
 * \brief get table ca_map entry 
 * command address bit swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] channel - command address bit
 * 
 * \return
 *     ca_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_ca_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_ca_map_t * dnx_data_dram_gddr6_ca_map_get(
    int unit,
    int dram_index,
    int channel);

/**
 * \brief get table cadt_byte_map entry 
 * bytes swapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] channel - dram controller channel
 * 
 * \return
 *     cadt_byte_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_cadt_byte_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_cadt_byte_map_t * dnx_data_dram_gddr6_cadt_byte_map_get(
    int unit,
    int dram_index,
    int channel);

/**
 * \brief get table channel_regs entry 
 * per channel list of registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_channel_regs_t * dnx_data_dram_gddr6_channel_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_regs entry 
 * per phy controller list of registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_controller_regs_t * dnx_data_dram_gddr6_controller_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_interrupt_regs entry 
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_channel_interrupt_regs_t * dnx_data_dram_gddr6_channel_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_interrupt_regs entry 
 * per phy list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_controller_interrupt_regs_t * dnx_data_dram_gddr6_controller_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_debug_regs entry 
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_debug_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_debug_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_channel_debug_regs_t * dnx_data_dram_gddr6_channel_debug_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_counter_regs entry 
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_channel_counter_regs_t * dnx_data_dram_gddr6_channel_counter_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_type_regs entry 
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_type_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_type_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_channel_type_regs_t * dnx_data_dram_gddr6_channel_type_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_info_regs entry 
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_info_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_info_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_controller_info_regs_t * dnx_data_dram_gddr6_controller_info_regs_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'refresh_intervals'
 * refresh intervals timing parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_refresh_intervals_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'dq_map'
 * DQ swap mapping on boards
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_dq_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'dq_channel_swap'
 * DQ channel swap mapping on boards
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_dq_channel_swap_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'dq_byte_map'
 * DQ bytes swap mapping on boards
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_dq_byte_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'ca_map'
 * command address bit swap mapping on boards
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_ca_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'cadt_byte_map'
 * bytes swapping on boards
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_cadt_byte_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'channel_regs'
 * per channel list of registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_channel_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'controller_regs'
 * per phy controller list of registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_controller_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'channel_interrupt_regs'
 * per channel list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_channel_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'controller_interrupt_regs'
 * per phy list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_controller_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'channel_debug_regs'
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_channel_debug_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'channel_counter_regs'
 * per channel list of counter registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_channel_counter_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'channel_type_regs'
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_channel_type_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'controller_info_regs'
 * per contorller list of info registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_controller_info_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)refresh_intervals info
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_intervals - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_refresh_intervals_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dq_map info
 * DQ swap mapping on boards
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_dq_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dq_channel_swap info
 * DQ channel swap mapping on boards
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_channel_swap - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_dq_channel_swap_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dq_byte_map info
 * DQ bytes swap mapping on boards
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_byte_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_dq_byte_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ca_map info
 * command address bit swap mapping on boards
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ca_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_ca_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)cadt_byte_map info
 * bytes swapping on boards
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cadt_byte_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_cadt_byte_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_regs info
 * per channel list of registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_channel_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_regs info
 * per phy controller list of registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_controller_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_interrupt_regs info
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_channel_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_interrupt_regs info
 * per phy list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_controller_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_debug_regs info
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_debug_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_channel_debug_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_counter_regs info
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_counter_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_channel_counter_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_type_regs info
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_type_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_channel_type_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_info_regs info
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_info_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_controller_info_regs_info_get(
    int unit);

/*
 * SUBMODULE GENERAL_INFO:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_general_info_feature_get(
    int unit,
    dnx_data_dram_general_info_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_general_info_define_otp_restore_version,
    dnx_data_dram_general_info_define_max_nof_drams,
    dnx_data_dram_general_info_define_nof_channels,
    dnx_data_dram_general_info_define_mr_mask,
    dnx_data_dram_general_info_define_nof_mrs,
    dnx_data_dram_general_info_define_phy_address_mask,
    dnx_data_dram_general_info_define_max_dram_index,
    dnx_data_dram_general_info_define_min_dram_index,
    dnx_data_dram_general_info_define_frequency,
    dnx_data_dram_general_info_define_buffer_size,
    dnx_data_dram_general_info_define_command_address_parity,
    dnx_data_dram_general_info_define_dq_write_parity,
    dnx_data_dram_general_info_define_dq_read_parity,
    dnx_data_dram_general_info_define_dbi_read,
    dnx_data_dram_general_info_define_dbi_write,
    dnx_data_dram_general_info_define_write_latency,
    dnx_data_dram_general_info_define_read_latency,
    dnx_data_dram_general_info_define_parity_latency,
    dnx_data_dram_general_info_define_actual_parity_latency,
    dnx_data_dram_general_info_define_tune_mode_on_init,
    dnx_data_dram_general_info_define_command_parity_latency,
    dnx_data_dram_general_info_define_crc_write_latency,
    dnx_data_dram_general_info_define_crc_read_latency,
    dnx_data_dram_general_info_define_crc_write,
    dnx_data_dram_general_info_define_crc_read,
    dnx_data_dram_general_info_define_device_size,

    /**
     * Must be last one!
     */
    _dnx_data_dram_general_info_define_nof
} dnx_data_dram_general_info_define_e;

/* Get Data */
/**
 * \brief returns define data of otp_restore_version
 * Module - 'dram', Submodule - 'general_info', data - 'otp_restore_version'
 * when restoring from OTP the tune data, do it according to the given version format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     otp_restore_version - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_otp_restore_version_get(
    int unit);

/**
 * \brief returns define data of max_nof_drams
 * Module - 'dram', Submodule - 'general_info', data - 'max_nof_drams'
 * max number of drams supported for this device - in other words the size of the dram bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_drams - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_max_nof_drams_get(
    int unit);

/**
 * \brief returns define data of nof_channels
 * Module - 'dram', Submodule - 'general_info', data - 'nof_channels'
 * max number of dram channels supported for this device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_channels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_nof_channels_get(
    int unit);

/**
 * \brief returns define data of mr_mask
 * Module - 'dram', Submodule - 'general_info', data - 'mr_mask'
 * mode register bit mask
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mr_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_mr_mask_get(
    int unit);

/**
 * \brief returns define data of nof_mrs
 * Module - 'dram', Submodule - 'general_info', data - 'nof_mrs'
 * number of mode registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mrs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_nof_mrs_get(
    int unit);

/**
 * \brief returns define data of phy_address_mask
 * Module - 'dram', Submodule - 'general_info', data - 'phy_address_mask'
 * bit mask to describe the relevant bits in phy register address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_address_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_phy_address_mask_get(
    int unit);

/**
 * \brief returns numeric data of max_dram_index
 * Module - 'dram', Submodule - 'general_info', data - 'max_dram_index'
 * max dram index from bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_dram_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_max_dram_index_get(
    int unit);

/**
 * \brief returns numeric data of min_dram_index
 * Module - 'dram', Submodule - 'general_info', data - 'min_dram_index'
 * min dram index from bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_dram_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_min_dram_index_get(
    int unit);

/**
 * \brief returns numeric data of frequency
 * Module - 'dram', Submodule - 'general_info', data - 'frequency'
 * dram frequency (in MHZ), used to calculated data_rate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     frequency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_frequency_get(
    int unit);

/**
 * \brief returns numeric data of buffer_size
 * Module - 'dram', Submodule - 'general_info', data - 'buffer_size'
 * dram buffer size in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     buffer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_buffer_size_get(
    int unit);

/**
 * \brief returns numeric data of command_address_parity
 * Module - 'dram', Submodule - 'general_info', data - 'command_address_parity'
 * command address parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_address_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_command_address_parity_get(
    int unit);

/**
 * \brief returns numeric data of dq_write_parity
 * Module - 'dram', Submodule - 'general_info', data - 'dq_write_parity'
 * dq write parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_write_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dq_write_parity_get(
    int unit);

/**
 * \brief returns numeric data of dq_read_parity
 * Module - 'dram', Submodule - 'general_info', data - 'dq_read_parity'
 * dq read parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_read_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dq_read_parity_get(
    int unit);

/**
 * \brief returns numeric data of dbi_read
 * Module - 'dram', Submodule - 'general_info', data - 'dbi_read'
 * dbi read
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbi_read - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dbi_read_get(
    int unit);

/**
 * \brief returns numeric data of dbi_write
 * Module - 'dram', Submodule - 'general_info', data - 'dbi_write'
 * dbi write
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbi_write - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dbi_write_get(
    int unit);

/**
 * \brief returns numeric data of write_latency
 * Module - 'dram', Submodule - 'general_info', data - 'write_latency'
 * write latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     write_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_write_latency_get(
    int unit);

/**
 * \brief returns numeric data of read_latency
 * Module - 'dram', Submodule - 'general_info', data - 'read_latency'
 * read latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     read_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_read_latency_get(
    int unit);

/**
 * \brief returns numeric data of parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'parity_latency'
 * parity latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_parity_latency_get(
    int unit);

/**
 * \brief returns numeric data of actual_parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'actual_parity_latency'
 * parity latency to be used after factoring in the effect of other numerics
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     actual_parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_actual_parity_latency_get(
    int unit);

/**
 * \brief returns numeric data of tune_mode_on_init
 * Module - 'dram', Submodule - 'general_info', data - 'tune_mode_on_init'
 * tune mode during init sequence
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tune_mode_on_init - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_tune_mode_on_init_get(
    int unit);

/**
 * \brief returns numeric data of command_parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'command_parity_latency'
 * command parity latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_command_parity_latency_get(
    int unit);

/**
 * \brief returns numeric data of crc_write_latency
 * Module - 'dram', Submodule - 'general_info', data - 'crc_write_latency'
 * crc write latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_write_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_crc_write_latency_get(
    int unit);

/**
 * \brief returns numeric data of crc_read_latency
 * Module - 'dram', Submodule - 'general_info', data - 'crc_read_latency'
 * crc read latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_read_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_crc_read_latency_get(
    int unit);

/**
 * \brief returns numeric data of crc_write
 * Module - 'dram', Submodule - 'general_info', data - 'crc_write'
 * write crc
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_write - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_crc_write_get(
    int unit);

/**
 * \brief returns numeric data of crc_read
 * Module - 'dram', Submodule - 'general_info', data - 'crc_read'
 * read crc
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_read - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_crc_read_get(
    int unit);

/**
 * \brief returns numeric data of device_size
 * Module - 'dram', Submodule - 'general_info', data - 'device_size'
 * device size for each dram die
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     device_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_device_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_general_info_table_mr_defaults,
    dnx_data_dram_general_info_table_dram_info,
    dnx_data_dram_general_info_table_timing_params,
    dnx_data_dram_general_info_table_refresh_intervals,

    /**
     * Must be last one!
     */
    _dnx_data_dram_general_info_table_nof
} dnx_data_dram_general_info_table_e;

/* Get Data */
/**
 * \brief get table mr_defaults entry 
 * mode registers default values
 * 
 * \param [in] unit - unit #
 * \param [in] index - mode register index
 * 
 * \return
 *     mr_defaults - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_mr_defaults_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_general_info_mr_defaults_t * dnx_data_dram_general_info_mr_defaults_get(
    int unit,
    int index);

/**
 * \brief get table dram_info entry 
 * general information regarding the dram in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_info - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_dram_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_general_info_dram_info_t * dnx_data_dram_general_info_dram_info_get(
    int unit);

/**
 * \brief get table timing_params entry 
 * timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     timing_params - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_timing_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_general_info_timing_params_t * dnx_data_dram_general_info_timing_params_get(
    int unit);

/**
 * \brief get table refresh_intervals entry 
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * \param [in] temp_index - temperature index
 * 
 * \return
 *     refresh_intervals - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_refresh_intervals_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_general_info_refresh_intervals_t * dnx_data_dram_general_info_refresh_intervals_get(
    int unit,
    int temp_index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'general_info', table - 'mr_defaults'
 * mode registers default values
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_general_info_mr_defaults_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'general_info', table - 'dram_info'
 * general information regarding the dram in the system
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_general_info_dram_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'general_info', table - 'timing_params'
 * timing parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_general_info_timing_params_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'general_info', table - 'refresh_intervals'
 * refresh intervals timing parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_general_info_refresh_intervals_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)mr_defaults info
 * mode registers default values
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mr_defaults - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_general_info_mr_defaults_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dram_info info
 * general information regarding the dram in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_general_info_dram_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)timing_params info
 * timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     timing_params - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_general_info_timing_params_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)refresh_intervals info
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_intervals - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_general_info_refresh_intervals_info_get(
    int unit);

/*
 * SUBMODULE ADDRESS_TRANSLATION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_address_translation_feature_get(
    int unit,
    dnx_data_dram_address_translation_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_address_translation_define_matrix_column_size,
    dnx_data_dram_address_translation_define_physical_address_transaction_size,
    dnx_data_dram_address_translation_define_nof_atms,

    /**
     * Must be last one!
     */
    _dnx_data_dram_address_translation_define_nof
} dnx_data_dram_address_translation_define_e;

/* Get Data */
/**
 * \brief returns define data of matrix_column_size
 * Module - 'dram', Submodule - 'address_translation', data - 'matrix_column_size'
 * the number of rows in the ATM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     matrix_column_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_address_translation_matrix_column_size_get(
    int unit);

/**
 * \brief returns define data of physical_address_transaction_size
 * Module - 'dram', Submodule - 'address_translation', data - 'physical_address_transaction_size'
 * nof bytes in each read/write from/to physical address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_transaction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_address_translation_physical_address_transaction_size_get(
    int unit);

/**
 * \brief returns define data of nof_atms
 * Module - 'dram', Submodule - 'address_translation', data - 'nof_atms'
 * number of address translation matrix
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_atms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_address_translation_nof_atms_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_address_translation_table_matrix_configuration,
    dnx_data_dram_address_translation_table_interrupt_regs,
    dnx_data_dram_address_translation_table_counter_regs,

    /**
     * Must be last one!
     */
    _dnx_data_dram_address_translation_table_nof
} dnx_data_dram_address_translation_table_e;

/* Get Data */
/**
 * \brief get table matrix_configuration entry 
 * address translation matrix(ATM) configuration options
 * 
 * \param [in] unit - unit #
 * \param [in] matrix_option - matrix selector
 * 
 * \return
 *     matrix_configuration - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_matrix_configuration_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_address_translation_matrix_configuration_t * dnx_data_dram_address_translation_matrix_configuration_get(
    int unit,
    int matrix_option);

/**
 * \brief get table interrupt_regs entry 
 * per address translation unit list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_address_translation_interrupt_regs_t * dnx_data_dram_address_translation_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table counter_regs entry 
 * per address translation unit list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_address_translation_counter_regs_t * dnx_data_dram_address_translation_counter_regs_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'address_translation', table - 'matrix_configuration'
 * address translation matrix(ATM) configuration options
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_address_translation_matrix_configuration_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'address_translation', table - 'interrupt_regs'
 * per address translation unit list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_address_translation_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'address_translation', table - 'counter_regs'
 * per address translation unit list of counter registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_address_translation_counter_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)matrix_configuration info
 * address translation matrix(ATM) configuration options
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     matrix_configuration - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_address_translation_matrix_configuration_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)interrupt_regs info
 * per address translation unit list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_address_translation_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)counter_regs info
 * per address translation unit list of counter registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     counter_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_address_translation_counter_regs_info_get(
    int unit);

/*
 * SUBMODULE BUFFERS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_buffers_feature_get(
    int unit,
    dnx_data_dram_buffers_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_buffers_define_allowed_errors,
    dnx_data_dram_buffers_define_nof_bdbs,
    dnx_data_dram_buffers_define_nof_fpc_banks,

    /**
     * Must be last one!
     */
    _dnx_data_dram_buffers_define_nof
} dnx_data_dram_buffers_define_e;

/* Get Data */
/**
 * \brief returns numeric data of allowed_errors
 * Module - 'dram', Submodule - 'buffers', data - 'allowed_errors'
 * number of times a buffer is allowed into the quarantine FIFO before it is deleted instead of restored
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     allowed_errors - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_buffers_allowed_errors_get(
    int unit);

/**
 * \brief returns define data of nof_bdbs
 * Module - 'dram', Submodule - 'buffers', data - 'nof_bdbs'
 * number of BDBs per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bdbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_buffers_nof_bdbs_get(
    int unit);

/**
 * \brief returns define data of nof_fpc_banks
 * Module - 'dram', Submodule - 'buffers', data - 'nof_fpc_banks'
 * number of free pointer controler banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fpc_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_buffers_nof_fpc_banks_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_buffers_table_deleted_buffers_info,

    /**
     * Must be last one!
     */
    _dnx_data_dram_buffers_table_nof
} dnx_data_dram_buffers_table_e;

/* Get Data */
/**
 * \brief get table deleted_buffers_info entry 
 * deleted buffers info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     deleted_buffers_info - returns the relevant entry values grouped in struct - see dnx_data_dram_buffers_deleted_buffers_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_buffers_deleted_buffers_info_t * dnx_data_dram_buffers_deleted_buffers_info_get(
    int unit);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'buffers', table - 'deleted_buffers_info'
 * deleted buffers info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_buffers_deleted_buffers_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)deleted_buffers_info info
 * deleted buffers info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     deleted_buffers_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_buffers_deleted_buffers_info_info_get(
    int unit);

/*
 * SUBMODULE DRAM_BLOCK:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_dram_block_feature_get(
    int unit,
    dnx_data_dram_dram_block_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_dram_block_define_leaky_bucket_window_size,
    dnx_data_dram_dram_block_define_wmr_reset_on_deassert,
    dnx_data_dram_dram_block_define_wmr_full_size,
    dnx_data_dram_dram_block_define_wmr_decrement_thr_factor,
    dnx_data_dram_dram_block_define_wpr_increment_thr_factor,

    /**
     * Must be last one!
     */
    _dnx_data_dram_dram_block_define_nof
} dnx_data_dram_dram_block_define_e;

/* Get Data */
/**
 * \brief returns define data of leaky_bucket_window_size
 * Module - 'dram', Submodule - 'dram_block', data - 'leaky_bucket_window_size'
 * window size for DRAM block calculation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     leaky_bucket_window_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_leaky_bucket_window_size_get(
    int unit);

/**
 * \brief returns define data of wmr_reset_on_deassert
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_reset_on_deassert'
 * indication whether to reset on deassert of write-minus-read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_reset_on_deassert - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_wmr_reset_on_deassert_get(
    int unit);

/**
 * \brief returns define data of wmr_full_size
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_full_size'
 * write-minus-read leaky bucket full size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_full_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_wmr_full_size_get(
    int unit);

/**
 * \brief returns numeric data of wmr_decrement_thr_factor
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_decrement_thr_factor'
 * factor for calculating decrement threshold for write_minus_read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_decrement_thr_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_wmr_decrement_thr_factor_get(
    int unit);

/**
 * \brief returns numeric data of wpr_increment_thr_factor
 * Module - 'dram', Submodule - 'dram_block', data - 'wpr_increment_thr_factor'
 * factor for calculating increment threshold for write-plus-read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wpr_increment_thr_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_wpr_increment_thr_factor_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_dram_block_table_nof
} dnx_data_dram_dram_block_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE DBAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_dbal_feature_get(
    int unit,
    dnx_data_dram_dbal_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_dbal_define_hbmc_index_nof_bits,

    /**
     * Must be last one!
     */
    _dnx_data_dram_dbal_define_nof
} dnx_data_dram_dbal_define_e;

/* Get Data */
/**
 * \brief returns numeric data of hbmc_index_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbmc_index_nof_bits'
 * The size (number of bits) of HBMC_INDEX dbal field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbmc_index_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbmc_index_nof_bits_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_dbal_table_nof
} dnx_data_dram_dbal_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_DRAM_H_*/
/* *INDENT-ON* */
