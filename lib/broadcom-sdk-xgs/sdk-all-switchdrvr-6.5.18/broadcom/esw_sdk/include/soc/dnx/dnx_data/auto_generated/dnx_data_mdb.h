/** \file dnx_data_mdb.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_MDB_H_
/*{*/
#define _DNX_DATA_MDB_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/dbal/dbal.h>
#include <soc/dnx/dbal/auto_generated/dbal_defines_tables.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_mdb.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_mdb
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_mdb_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - GLOBAL:
 * MDB global defines
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * If enabled, use the adapter logical stub interface.
     */
    dnx_data_mdb_global_adapter_use_stub,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_global_feature_nof
} dnx_data_mdb_global_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_global_feature_get_f) (
    int unit,
    dnx_data_mdb_global_feature_e feature);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - GLOBAL:
 * {
 */
/**
 * \brief Interface for mdb global data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_global_feature_get_f feature_get;
} dnx_data_if_mdb_global_t;

/*
 * }
 */

/*
 * SUBMODULE  - DH:
 * Data handlers information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule dh table dh_info
 * Table info:
 * general information of the MDB data handlers
 */
typedef struct
{
    /**
     * This is a mapping from a PDB MAG to the available DHs that connected to it.Each row represent a MAG and each column the MACROs  A0, A1, A2 .... A11, B0, B1 ... B7.The last column in every row is the position after the last available DH which used for the OVF (relevant for EM only).0xF means that the MAG isn't connected to the MACRO otherwise the number represent the serialconnection number of the MACRO to the MAGThere are some DHs which have 2 interfaces to the same MAG, in that case the difference between two legal interface values will be 2.
     */
    uint32 table_macro_interface_mapping[DNX_DATA_MAX_MDB_DH_TOTAL_NOF_MACROES_PLUS_EM_OVF_OR_EEDB_BANK];
    /**
     * The following array maps a PDB into his data in offset position (byte granularity) in a macro.Each column represent a macro A0, A1 ... A11, B0, .. B7 and the last column is the PDB data size (byte granularity).
     */
    uint32 cluster_if_offsets_values[DNX_DATA_MAX_MDB_DH_TOTAL_NOF_MACROES_PLUS_DATA_WIDTH];
    /**
     * This table holds the position of all the 30 bits chunks of a PDB in the IF cluster offset register.Each column represent a macro A0, A1 ... A11, B0, .. B7 and the last column is the PDB data size (30 bits granularity).
     */
    uint32 if_cluster_offsets_values[DNX_DATA_MAX_MDB_DH_TOTAL_NOF_MACROES_PLUS_DATA_WIDTH];
    /**
     * The table row width in bits.
     */
    uint32 row_width;
    /**
     * The data handler in size.
     */
    uint32 dh_in_width;
    /**
     * The data handler out size.
     */
    uint32 dh_out_width;
    /**
     * Bit map of all the DHs that have two ways for a given PDB.
     */
    uint32 two_ways_connectivity_bm;
} dnx_data_mdb_dh_dh_info_t;

/**
 * \brief Holds values of submodule dh table macro_interface_mapping
 * Table info:
 * The available interfaces for each macro
 */
typedef struct
{
    /**
     * array of available interfaces.
     */
    dbal_enum_value_field_mdb_physical_table_e interfaces[DNX_DATA_MAX_MDB_DH_MAX_NOF_CLUSTER_INTERFACES];
} dnx_data_mdb_dh_macro_interface_mapping_t;

/**
 * \brief Holds values of submodule dh table table_way_to_macro_mapping
 * Table info:
 * Maps from table way to global macro index, this is the reverse mapping of dh_info->table_macro_interface_mapping
 */
typedef struct
{
    /**
     * This is a mapping from a table way to global macro index, assumes no table is connected to more than NOF_MACROES_TYPE_A macros. Default value is NOF_MACRO_A + NOF_MACRO_B
     */
    uint32 table_way_to_macro_mapping[DNX_DATA_MAX_MDB_DH_NOF_MACROES_TYPE_A];
} dnx_data_mdb_dh_table_way_to_macro_mapping_t;

/**
 * \brief Holds values of submodule dh table block_info
 * Table info:
 * holds the DH blocks information.
 */
typedef struct
{
    /**
     * the block type that used by the DH macro (e.g. DDHA, DDHB or DHC)
     */
    dbal_enum_value_field_mdb_block_types_e block_type;
    /**
     * each block type have several blocks, this is the instance of the block type used by this DH
     */
    int block_index;
} dnx_data_mdb_dh_block_info_t;

/**
 * \brief Holds values of submodule dh table mdb_75_macro_halved
 * Table info:
 * holds the mdb_75 macro information.
 */
typedef struct
{
    /**
     * TRUE/FALSE if the macro is halved
     */
    uint8 macro_halved;
} dnx_data_mdb_dh_mdb_75_macro_halved_t;

/**
 * \brief Holds values of submodule dh table entry_banks_info
 * Table info:
 * holds the DHs entry banks and ABK banks information.
 */
typedef struct
{
    /**
     * the entries bank memory.
     */
    soc_mem_t entry_bank;
    /**
     * The overflow buffer used to hold the overflowed data of the last entry in the bank.
     */
    soc_reg_t overflow_reg;
    /**
     * The ABK memory of type A (destination hit bit)
     */
    soc_mem_t abk_bank_a;
    /**
     * The ABK memory of type B ()source hit bit)
     */
    soc_mem_t abk_bank_b;
} dnx_data_mdb_dh_entry_banks_info_t;

/**
 * \brief Holds values of submodule dh table mdb_1_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_2_field_size;
    /**
     * no description.
     */
    uint32 mdb_item_3_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_4_field_size;
} dnx_data_mdb_dh_mdb_1_info_t;

/**
 * \brief Holds values of submodule dh table mdb_2_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_1_field_size;
} dnx_data_mdb_dh_mdb_2_info_t;

/**
 * \brief Holds values of submodule dh table mdb_3_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_array_size;
} dnx_data_mdb_dh_mdb_3_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * If enabled, macro A only supports half the nof_macro_clusters.
     */
    dnx_data_mdb_dh_macro_A_half_nof_clusters_enable,
    /**
     * If enabled, macro A (1,2,3,4,7,8,9,11) only supports half the nof_macro_clusters.
     */
    dnx_data_mdb_dh_macro_A_75_nof_clusters_enable,
    /**
     * If enabled, supports extended bpu setup options such as 120_240_120 and 120_360.
     */
    dnx_data_mdb_dh_bpu_setup_extended_support,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_dh_feature_nof
} dnx_data_mdb_dh_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_dh_feature_get_f) (
    int unit,
    dnx_data_mdb_dh_feature_e feature);

/**
 * \brief returns define data of nof_macroes_type_A
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macroes_type_A'
 * The NOF type A macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macroes_type_A - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_macroes_type_A_get_f) (
    int unit);

/**
 * \brief returns define data of nof_macroes_type_B
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macroes_type_B'
 * The NOF type B macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macroes_type_B - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_macroes_type_B_get_f) (
    int unit);

/**
 * \brief returns define data of total_nof_macroes
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes'
 * the total NOF macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_total_nof_macroes_get_f) (
    int unit);

/**
 * \brief returns define data of total_nof_macroes_plus_em_ovf_or_eedb_bank
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes_plus_em_ovf_or_eedb_bank'
 * the total NOF macroes in the device plus another place for either the OVF buffer for EM tables or banks for EEDB tables.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes_plus_em_ovf_or_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_total_nof_macroes_plus_em_ovf_or_eedb_bank_get_f) (
    int unit);

/**
 * \brief returns define data of total_nof_macroes_plus_data_width
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes_plus_data_width'
 * he total NOF macroes in the device plus another place for the data width.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes_plus_data_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_total_nof_macroes_plus_data_width_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_cluster_interfaces
 * Module - 'mdb', Submodule - 'dh', data - 'max_nof_cluster_interfaces'
 * max NOF interfaces that can be associated with a single cluster.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_cluster_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_max_nof_cluster_interfaces_get_f) (
    int unit);

/**
 * \brief returns define data of nof_macro_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macro_clusters'
 * nof clusters in a single macro.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macro_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_macro_clusters_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bucket_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_bucket_clusters'
 * nof clusters in a a bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bucket_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_bucket_clusters_get_f) (
    int unit);

/**
 * \brief returns define data of nof_buckets_in_macro
 * Module - 'mdb', Submodule - 'dh', data - 'nof_buckets_in_macro'
 * The NOF buckets in a macro
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_buckets_in_macro - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_buckets_in_macro_get_f) (
    int unit);

/**
 * \brief returns define data of nof_pair_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_pair_clusters'
 * nof clusters in a pair.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pair_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_pair_clusters_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_address_in_macro_a_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_bits_address_in_macro_a_cluster'
 * NOF bits needed for a cluster A address.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_address_in_macro_a_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_bits_address_in_macro_a_cluster_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_address_in_macro_b_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_bits_address_in_macro_b_cluster'
 * NOF bits needed for a cluster B address.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_address_in_macro_b_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_bits_address_in_macro_b_cluster_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_macro_a_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_macro_a_cluster'
 * NOF rows in a cluster that is places on a macro of type A.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_macro_a_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_rows_in_macro_a_cluster_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_macro_b_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_macro_b_cluster'
 * NOF rows in a cluster that is places on a macro of type B.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_macro_b_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_rows_in_macro_b_cluster_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_eedb_bank
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_eedb_bank'
 * NOF rows in an EEDB bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_rows_in_eedb_bank_get_f) (
    int unit);

/**
 * \brief returns define data of nof_data_rows_per_hitbit_row
 * Module - 'mdb', Submodule - 'dh', data - 'nof_data_rows_per_hitbit_row'
 * How many eedb rows each hitbit row is mapped to
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_data_rows_per_hitbit_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_data_rows_per_hitbit_row_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_eedb_hitbit_bank
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_eedb_hitbit_bank'
 * How many rows in each eedb hitbit bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_eedb_hitbit_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_rows_in_eedb_hitbit_bank_get_f) (
    int unit);

/**
 * \brief returns define data of cluster_row_width_bits
 * Module - 'mdb', Submodule - 'dh', data - 'cluster_row_width_bits'
 * NOF bits in a single cluster row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cluster_row_width_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_cluster_row_width_bits_get_f) (
    int unit);

/**
 * \brief returns define data of has_dhc_type_blocks
 * Module - 'mdb', Submodule - 'dh', data - 'has_dhc_type_blocks'
 * This device uses DHC types blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     has_dhc_type_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_has_dhc_type_blocks_get_f) (
    int unit);

/**
 * \brief returns define data of data_out_granularity
 * Module - 'mdb', Submodule - 'dh', data - 'data_out_granularity'
 * The granularity used for data out.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_out_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_data_out_granularity_get_f) (
    int unit);

/**
 * \brief returns define data of bpu_setup_bb_connected
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_bb_connected'
 * If set, the two buckets are connected, also known as J2 960 mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_bb_connected - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_bpu_setup_bb_connected_get_f) (
    int unit);

/**
 * \brief returns define data of bpu_setup_size_120_240_120
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_120_240_120'
 * The BPU setup size associated with 120_240_120 bucket allocation, requires extended.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_120_240_120 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_bpu_setup_size_120_240_120_get_f) (
    int unit);

/**
 * \brief returns define data of bpu_setup_size_480_odd
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_480_odd'
 * The BPU setup size associated with 480_odd bucket allocation, the odd is used to distinguish between buckets in case of 960 allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_480_odd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_bpu_setup_size_480_odd_get_f) (
    int unit);

/**
 * \brief returns define data of bpu_setup_size_480
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_480'
 * The BPU setup size associated with 480 bucket allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_480 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_bpu_setup_size_480_get_f) (
    int unit);

/**
 * \brief returns define data of bpu_setup_size_360_120
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_360_120'
 * The BPU setup size associated with 360_120 bucket allocation, requires extended.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_360_120 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_bpu_setup_size_360_120_get_f) (
    int unit);

/**
 * \brief returns define data of bpu_setup_size_120_360
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_120_360'
 * The BPU setup size associated with 120_360 bucket allocation, requires extended.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_120_360 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_bpu_setup_size_120_360_get_f) (
    int unit);

/**
 * \brief returns define data of bpu_setup_size_240_240
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_240_240'
 * The BPU setup size associated with 240_240 bucket allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_240_240 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_bpu_setup_size_240_240_get_f) (
    int unit);

/**
 * \brief returns define data of bpu_setup_size_120_120_240
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_120_120_240'
 * The BPU setup size associated with 120_120_240 bucket allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_120_120_240 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_bpu_setup_size_120_120_240_get_f) (
    int unit);

/**
 * \brief returns define data of bpu_setup_size_240_120_120
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_240_120_120'
 * The BPU setup size associated with 240_120_120 bucket allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_240_120_120 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_bpu_setup_size_240_120_120_get_f) (
    int unit);

/**
 * \brief returns define data of bpu_setup_size_120_120_120_120
 * Module - 'mdb', Submodule - 'dh', data - 'bpu_setup_size_120_120_120_120'
 * The BPU setup size associated with 120_120_120_120 bucket allocation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bpu_setup_size_120_120_120_120 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_bpu_setup_size_120_120_120_120_get_f) (
    int unit);

/**
 * \brief returns define data of ddha_dynamic_memory_access_dpc
 * Module - 'mdb', Submodule - 'dh', data - 'ddha_dynamic_memory_access_dpc'
 * The DDHA dynamic memory is of DPC type.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ddha_dynamic_memory_access_dpc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_ddha_dynamic_memory_access_dpc_get_f) (
    int unit);

/**
 * \brief get table dh_info entry 
 * general information of the MDB data handlers
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table_id - MDB physical DB.
 * 
 * \return
 *     dh_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_dh_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_dh_info_t *(
    *dnx_data_mdb_dh_dh_info_get_f) (
    int unit,
    int mdb_table_id);

/**
 * \brief get table macro_interface_mapping entry 
 * The available interfaces for each macro
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     macro_interface_mapping - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_macro_interface_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_macro_interface_mapping_t *(
    *dnx_data_mdb_dh_macro_interface_mapping_get_f) (
    int unit,
    int global_macro_index);

/**
 * \brief get table table_way_to_macro_mapping entry 
 * Maps from table way to global macro index, this is the reverse mapping of dh_info->table_macro_interface_mapping
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table_id - MDB physical DB.
 * 
 * \return
 *     table_way_to_macro_mapping - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_table_way_to_macro_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_table_way_to_macro_mapping_t *(
    *dnx_data_mdb_dh_table_way_to_macro_mapping_get_f) (
    int unit,
    int mdb_table_id);

/**
 * \brief get table block_info entry 
 * holds the DH blocks information.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     block_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_block_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_block_info_t *(
    *dnx_data_mdb_dh_block_info_get_f) (
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_75_macro_halved entry 
 * holds the mdb_75 macro information.
 * 
 * \param [in] unit - unit #
 * \param [in] macro_index - macro A index
 * 
 * \return
 *     mdb_75_macro_halved - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_75_macro_halved_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_mdb_75_macro_halved_t *(
    *dnx_data_mdb_dh_mdb_75_macro_halved_get_f) (
    int unit,
    int macro_index);

/**
 * \brief get table entry_banks_info entry 
 * holds the DHs entry banks and ABK banks information.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     entry_banks_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_entry_banks_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_entry_banks_info_t *(
    *dnx_data_mdb_dh_entry_banks_info_get_f) (
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_1_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - no description.
 * 
 * \return
 *     mdb_1_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_1_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_mdb_1_info_t *(
    *dnx_data_mdb_dh_mdb_1_info_get_f) (
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_2_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - no description.
 * 
 * \return
 *     mdb_2_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_2_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_mdb_2_info_t *(
    *dnx_data_mdb_dh_mdb_2_info_get_f) (
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_3_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - no description.
 * 
 * \return
 *     mdb_3_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_3_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_mdb_3_info_t *(
    *dnx_data_mdb_dh_mdb_3_info_get_f) (
    int unit,
    int global_macro_index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - DH:
 * {
 */
/**
 * \brief Interface for mdb dh data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_dh_feature_get_f feature_get;
    /**
     * returns define data of nof_macroes_type_A
     */
    dnx_data_mdb_dh_nof_macroes_type_A_get_f nof_macroes_type_A_get;
    /**
     * returns define data of nof_macroes_type_B
     */
    dnx_data_mdb_dh_nof_macroes_type_B_get_f nof_macroes_type_B_get;
    /**
     * returns define data of total_nof_macroes
     */
    dnx_data_mdb_dh_total_nof_macroes_get_f total_nof_macroes_get;
    /**
     * returns define data of total_nof_macroes_plus_em_ovf_or_eedb_bank
     */
    dnx_data_mdb_dh_total_nof_macroes_plus_em_ovf_or_eedb_bank_get_f total_nof_macroes_plus_em_ovf_or_eedb_bank_get;
    /**
     * returns define data of total_nof_macroes_plus_data_width
     */
    dnx_data_mdb_dh_total_nof_macroes_plus_data_width_get_f total_nof_macroes_plus_data_width_get;
    /**
     * returns define data of max_nof_cluster_interfaces
     */
    dnx_data_mdb_dh_max_nof_cluster_interfaces_get_f max_nof_cluster_interfaces_get;
    /**
     * returns define data of nof_macro_clusters
     */
    dnx_data_mdb_dh_nof_macro_clusters_get_f nof_macro_clusters_get;
    /**
     * returns define data of nof_bucket_clusters
     */
    dnx_data_mdb_dh_nof_bucket_clusters_get_f nof_bucket_clusters_get;
    /**
     * returns define data of nof_buckets_in_macro
     */
    dnx_data_mdb_dh_nof_buckets_in_macro_get_f nof_buckets_in_macro_get;
    /**
     * returns define data of nof_pair_clusters
     */
    dnx_data_mdb_dh_nof_pair_clusters_get_f nof_pair_clusters_get;
    /**
     * returns define data of nof_bits_address_in_macro_a_cluster
     */
    dnx_data_mdb_dh_nof_bits_address_in_macro_a_cluster_get_f nof_bits_address_in_macro_a_cluster_get;
    /**
     * returns define data of nof_bits_address_in_macro_b_cluster
     */
    dnx_data_mdb_dh_nof_bits_address_in_macro_b_cluster_get_f nof_bits_address_in_macro_b_cluster_get;
    /**
     * returns define data of nof_rows_in_macro_a_cluster
     */
    dnx_data_mdb_dh_nof_rows_in_macro_a_cluster_get_f nof_rows_in_macro_a_cluster_get;
    /**
     * returns define data of nof_rows_in_macro_b_cluster
     */
    dnx_data_mdb_dh_nof_rows_in_macro_b_cluster_get_f nof_rows_in_macro_b_cluster_get;
    /**
     * returns define data of nof_rows_in_eedb_bank
     */
    dnx_data_mdb_dh_nof_rows_in_eedb_bank_get_f nof_rows_in_eedb_bank_get;
    /**
     * returns define data of nof_data_rows_per_hitbit_row
     */
    dnx_data_mdb_dh_nof_data_rows_per_hitbit_row_get_f nof_data_rows_per_hitbit_row_get;
    /**
     * returns define data of nof_rows_in_eedb_hitbit_bank
     */
    dnx_data_mdb_dh_nof_rows_in_eedb_hitbit_bank_get_f nof_rows_in_eedb_hitbit_bank_get;
    /**
     * returns define data of cluster_row_width_bits
     */
    dnx_data_mdb_dh_cluster_row_width_bits_get_f cluster_row_width_bits_get;
    /**
     * returns define data of has_dhc_type_blocks
     */
    dnx_data_mdb_dh_has_dhc_type_blocks_get_f has_dhc_type_blocks_get;
    /**
     * returns define data of data_out_granularity
     */
    dnx_data_mdb_dh_data_out_granularity_get_f data_out_granularity_get;
    /**
     * returns define data of bpu_setup_bb_connected
     */
    dnx_data_mdb_dh_bpu_setup_bb_connected_get_f bpu_setup_bb_connected_get;
    /**
     * returns define data of bpu_setup_size_120_240_120
     */
    dnx_data_mdb_dh_bpu_setup_size_120_240_120_get_f bpu_setup_size_120_240_120_get;
    /**
     * returns define data of bpu_setup_size_480_odd
     */
    dnx_data_mdb_dh_bpu_setup_size_480_odd_get_f bpu_setup_size_480_odd_get;
    /**
     * returns define data of bpu_setup_size_480
     */
    dnx_data_mdb_dh_bpu_setup_size_480_get_f bpu_setup_size_480_get;
    /**
     * returns define data of bpu_setup_size_360_120
     */
    dnx_data_mdb_dh_bpu_setup_size_360_120_get_f bpu_setup_size_360_120_get;
    /**
     * returns define data of bpu_setup_size_120_360
     */
    dnx_data_mdb_dh_bpu_setup_size_120_360_get_f bpu_setup_size_120_360_get;
    /**
     * returns define data of bpu_setup_size_240_240
     */
    dnx_data_mdb_dh_bpu_setup_size_240_240_get_f bpu_setup_size_240_240_get;
    /**
     * returns define data of bpu_setup_size_120_120_240
     */
    dnx_data_mdb_dh_bpu_setup_size_120_120_240_get_f bpu_setup_size_120_120_240_get;
    /**
     * returns define data of bpu_setup_size_240_120_120
     */
    dnx_data_mdb_dh_bpu_setup_size_240_120_120_get_f bpu_setup_size_240_120_120_get;
    /**
     * returns define data of bpu_setup_size_120_120_120_120
     */
    dnx_data_mdb_dh_bpu_setup_size_120_120_120_120_get_f bpu_setup_size_120_120_120_120_get;
    /**
     * returns define data of ddha_dynamic_memory_access_dpc
     */
    dnx_data_mdb_dh_ddha_dynamic_memory_access_dpc_get_f ddha_dynamic_memory_access_dpc_get;
    /**
     * get table dh_info entry 
     */
    dnx_data_mdb_dh_dh_info_get_f dh_info_get;
    /**
     * get general info table about table (for example key size)dh_info info
     */
    dnxc_data_table_info_get_f dh_info_info_get;
    /**
     * get table macro_interface_mapping entry 
     */
    dnx_data_mdb_dh_macro_interface_mapping_get_f macro_interface_mapping_get;
    /**
     * get general info table about table (for example key size)macro_interface_mapping info
     */
    dnxc_data_table_info_get_f macro_interface_mapping_info_get;
    /**
     * get table table_way_to_macro_mapping entry 
     */
    dnx_data_mdb_dh_table_way_to_macro_mapping_get_f table_way_to_macro_mapping_get;
    /**
     * get general info table about table (for example key size)table_way_to_macro_mapping info
     */
    dnxc_data_table_info_get_f table_way_to_macro_mapping_info_get;
    /**
     * get table block_info entry 
     */
    dnx_data_mdb_dh_block_info_get_f block_info_get;
    /**
     * get general info table about table (for example key size)block_info info
     */
    dnxc_data_table_info_get_f block_info_info_get;
    /**
     * get table mdb_75_macro_halved entry 
     */
    dnx_data_mdb_dh_mdb_75_macro_halved_get_f mdb_75_macro_halved_get;
    /**
     * get general info table about table (for example key size)mdb_75_macro_halved info
     */
    dnxc_data_table_info_get_f mdb_75_macro_halved_info_get;
    /**
     * get table entry_banks_info entry 
     */
    dnx_data_mdb_dh_entry_banks_info_get_f entry_banks_info_get;
    /**
     * get general info table about table (for example key size)entry_banks_info info
     */
    dnxc_data_table_info_get_f entry_banks_info_info_get;
    /**
     * get table mdb_1_info entry 
     */
    dnx_data_mdb_dh_mdb_1_info_get_f mdb_1_info_get;
    /**
     * get general info table about table (for example key size)mdb_1_info info
     */
    dnxc_data_table_info_get_f mdb_1_info_info_get;
    /**
     * get table mdb_2_info entry 
     */
    dnx_data_mdb_dh_mdb_2_info_get_f mdb_2_info_get;
    /**
     * get general info table about table (for example key size)mdb_2_info info
     */
    dnxc_data_table_info_get_f mdb_2_info_info_get;
    /**
     * get table mdb_3_info entry 
     */
    dnx_data_mdb_dh_mdb_3_info_get_f mdb_3_info_get;
    /**
     * get general info table about table (for example key size)mdb_3_info info
     */
    dnxc_data_table_info_get_f mdb_3_info_info_get;
} dnx_data_if_mdb_dh_t;

/*
 * }
 */

/*
 * SUBMODULE  - PDBS:
 * general physical data bases information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule pdbs table mdb_profile
 * Table info:
 * MDB profile SoC property
 */
typedef struct
{
    /**
     * The MDB profile
     */
    char *profile;
} dnx_data_mdb_pdbs_mdb_profile_t;

/**
 * \brief Holds values of submodule pdbs table mdb_profiles_info
 * Table info:
 * MDB info per profile
 */
typedef struct
{
    /**
     * TRUE/FALSE valid indication per profile. Different devices/SKUs support different profiles.
     */
    uint8 supported;
    /**
     * The profile name, compared with the mdb_profile soc property.
     */
    char *name;
} dnx_data_mdb_pdbs_mdb_profiles_info_t;

/**
 * \brief Holds values of submodule pdbs table mdb_profile_kaps_cfg
 * Table info:
 * KAPS database configuration based on the MDB profile
 */
typedef struct
{
    /**
     * The KAPS configuration
     */
    uint32 val;
} dnx_data_mdb_pdbs_mdb_profile_kaps_cfg_t;

/**
 * \brief Holds values of submodule pdbs table pdbs_info
 * Table info:
 * general information of the MDB physical data bases
 */
typedef struct
{
    /**
     * the DB type EM, direct, KAPS, TCAM or EEDB
     */
    dbal_enum_value_field_mdb_db_type_e db_type;
    /**
     * The table row width in bits.
     */
    uint32 row_width;
    /**
     * the direct payload size.
     */
    dbal_enum_value_field_direct_payload_sizes_e direct_payload_type;
    /**
     * the direct max payload size. Different from payload size for INLIF (60 vs. 120/180)
     */
    dbal_enum_value_field_direct_payload_sizes_e direct_max_payload_type;
} dnx_data_mdb_pdbs_pdbs_info_t;

/**
 * \brief Holds values of submodule pdbs table pdb_info
 * Table info:
 * general information of the MDB physical data bases
 */
typedef struct
{
    /**
     * map between MDB logical DB into a physical DB.
     */
    dbal_enum_value_field_mdb_physical_table_e logical_to_physical;
    /**
     * the DB type EM, direct, KAPS, TCAM or EEDB
     */
    dbal_enum_value_field_mdb_db_type_e db_type;
    /**
     * The table row width in bits.
     */
    uint32 row_width;
    /**
     * The maximal key size used for this PDB.
     */
    uint32 max_key_size;
    /**
     * The maximal payload size used from this PDB.
     */
    uint32 max_payload_size;
} dnx_data_mdb_pdbs_pdb_info_t;

/**
 * \brief Holds values of submodule pdbs table mdb_11_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
    /**
     * no description.
     */
    uint32 mdb_item_1_field_size;
    /**
     * no description.
     */
    uint32 mdb_item_3_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_3_field_size;
    /**
     * no description.
     */
    uint32 mdb_item_4_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_4_field_size;
} dnx_data_mdb_pdbs_mdb_11_info_t;

/**
 * \brief Holds values of submodule pdbs table mdb_12_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
} dnx_data_mdb_pdbs_mdb_12_info_t;

/**
 * \brief Holds values of submodule pdbs table mdb_26_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
    /**
     * no description.
     */
    uint32 mdb_item_1_field_size;
} dnx_data_mdb_pdbs_mdb_26_info_t;

/**
 * \brief Holds values of submodule pdbs table mdb_adapter_mapping
 * Table info:
 * Mapping between DBAL MDB physical tables and adapter memory IDs.
 */
typedef struct
{
    /**
     * adapter memory ID
     */
    uint8 memory_id;
} dnx_data_mdb_pdbs_mdb_adapter_mapping_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_pdbs_feature_nof
} dnx_data_mdb_pdbs_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_pdbs_feature_get_f) (
    int unit,
    dnx_data_mdb_pdbs_feature_e feature);

/**
 * \brief returns define data of max_nof_interface_dhs
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_nof_interface_dhs'
 * Max nof different DHs that can be associated with a single interface
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_interface_dhs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_max_nof_interface_dhs_get_f) (
    int unit);

/**
 * \brief returns define data of kaps_nof_blocks
 * Module - 'mdb', Submodule - 'pdbs', data - 'kaps_nof_blocks'
 * NOF KPAS blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kaps_nof_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_kaps_nof_blocks_get_f) (
    int unit);

/**
 * \brief returns define data of mesh_mode_support
 * Module - 'mdb', Submodule - 'pdbs', data - 'mesh_mode_support'
 * Indicate if the device support mesh mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mesh_mode_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_mesh_mode_support_get_f) (
    int unit);

/**
 * \brief returns define data of max_key_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_key_size'
 * The largest key size from all the PDBs key sizes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_max_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_payload_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_payload_size'
 * The largest payload size from all the PDBs payloads sizes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_max_payload_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_1_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_1_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_1_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_9_mdb_item_1_array_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_2_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_2_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_2_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_9_mdb_item_2_array_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_3_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_3_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_3_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_9_mdb_item_3_array_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_40_mdb_item_0_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_40_mdb_item_0_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_40_mdb_item_0_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_40_mdb_item_0_array_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_dynamic_memory_access_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_dynamic_memory_access_memory_access_field_size'
 * The MDB dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_dynamic_memory_access_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_dynamic_memory_access_memory_access_field_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_mact_dynamic_memory_access_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_mact_dynamic_memory_access_memory_access_field_size'
 * The MACT dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_mact_dynamic_memory_access_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_mact_dynamic_memory_access_memory_access_field_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size'
 * The KAPS SBC dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size'
 * The KAPS DPC dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size'
 * The DDHA SBC dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size'
 * The DDHA DPC dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_ddhb_dynamic_memory_access_memory_access_field_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_ddhb_dynamic_memory_access_memory_access_field_size'
 * The DDHB dynamic memory access register size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_ddhb_dynamic_memory_access_memory_access_field_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_ddhb_dynamic_memory_access_memory_access_field_size_get_f) (
    int unit);

/**
 * \brief returns define data of mdb_nof_profiles
 * Module - 'mdb', Submodule - 'pdbs', data - 'mdb_nof_profiles'
 * The global number of supported MDB profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_nof_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_mdb_nof_profiles_get_f) (
    int unit);

/**
 * \brief get table mdb_profile entry 
 * MDB profile SoC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_profile - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_profile_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_mdb_profile_t *(
    *dnx_data_mdb_pdbs_mdb_profile_get_f) (
    int unit);

/**
 * \brief get table mdb_profiles_info entry 
 * MDB info per profile
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_profile_index - The MDB profile index, iterated on using mdb_nof_profiles.
 * 
 * \return
 *     mdb_profiles_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_profiles_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_mdb_profiles_info_t *(
    *dnx_data_mdb_pdbs_mdb_profiles_info_get_f) (
    int unit,
    int mdb_profile_index);

/**
 * \brief get table mdb_profile_kaps_cfg entry 
 * KAPS database configuration based on the MDB profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_profile_kaps_cfg - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_profile_kaps_cfg_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_mdb_profile_kaps_cfg_t *(
    *dnx_data_mdb_pdbs_mdb_profile_kaps_cfg_get_f) (
    int unit);

/**
 * \brief get table pdbs_info entry 
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table_id - MDB physical DB.
 * 
 * \return
 *     pdbs_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_pdbs_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_pdbs_info_t *(
    *dnx_data_mdb_pdbs_pdbs_info_get_f) (
    int unit,
    int mdb_table_id);

/**
 * \brief get table pdb_info entry 
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB
 * 
 * \return
 *     pdb_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_pdb_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_pdb_info_t *(
    *dnx_data_mdb_pdbs_pdb_info_get_f) (
    int unit,
    int dbal_id);

/**
 * \brief get table mdb_11_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_11_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_11_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_mdb_11_info_t *(
    *dnx_data_mdb_pdbs_mdb_11_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_12_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_12_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_12_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_mdb_12_info_t *(
    *dnx_data_mdb_pdbs_mdb_12_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_26_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_26_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_26_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_mdb_26_info_t *(
    *dnx_data_mdb_pdbs_mdb_26_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_adapter_mapping entry 
 * Mapping between DBAL MDB physical tables and adapter memory IDs.
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - DBAL MDB physical table
 * 
 * \return
 *     mdb_adapter_mapping - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_adapter_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_mdb_adapter_mapping_t *(
    *dnx_data_mdb_pdbs_mdb_adapter_mapping_get_f) (
    int unit,
    int dbal_id);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - PDBS:
 * {
 */
/**
 * \brief Interface for mdb pdbs data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_pdbs_feature_get_f feature_get;
    /**
     * returns define data of max_nof_interface_dhs
     */
    dnx_data_mdb_pdbs_max_nof_interface_dhs_get_f max_nof_interface_dhs_get;
    /**
     * returns define data of kaps_nof_blocks
     */
    dnx_data_mdb_pdbs_kaps_nof_blocks_get_f kaps_nof_blocks_get;
    /**
     * returns define data of mesh_mode_support
     */
    dnx_data_mdb_pdbs_mesh_mode_support_get_f mesh_mode_support_get;
    /**
     * returns define data of max_key_size
     */
    dnx_data_mdb_pdbs_max_key_size_get_f max_key_size_get;
    /**
     * returns define data of max_payload_size
     */
    dnx_data_mdb_pdbs_max_payload_size_get_f max_payload_size_get;
    /**
     * returns define data of table_mdb_9_mdb_item_1_array_size
     */
    dnx_data_mdb_pdbs_table_mdb_9_mdb_item_1_array_size_get_f table_mdb_9_mdb_item_1_array_size_get;
    /**
     * returns define data of table_mdb_9_mdb_item_2_array_size
     */
    dnx_data_mdb_pdbs_table_mdb_9_mdb_item_2_array_size_get_f table_mdb_9_mdb_item_2_array_size_get;
    /**
     * returns define data of table_mdb_9_mdb_item_3_array_size
     */
    dnx_data_mdb_pdbs_table_mdb_9_mdb_item_3_array_size_get_f table_mdb_9_mdb_item_3_array_size_get;
    /**
     * returns define data of table_mdb_40_mdb_item_0_array_size
     */
    dnx_data_mdb_pdbs_table_mdb_40_mdb_item_0_array_size_get_f table_mdb_40_mdb_item_0_array_size_get;
    /**
     * returns define data of table_mdb_dynamic_memory_access_memory_access_field_size
     */
    dnx_data_mdb_pdbs_table_mdb_dynamic_memory_access_memory_access_field_size_get_f table_mdb_dynamic_memory_access_memory_access_field_size_get;
    /**
     * returns define data of table_mdb_mact_dynamic_memory_access_memory_access_field_size
     */
    dnx_data_mdb_pdbs_table_mdb_mact_dynamic_memory_access_memory_access_field_size_get_f table_mdb_mact_dynamic_memory_access_memory_access_field_size_get;
    /**
     * returns define data of table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size
     */
    dnx_data_mdb_pdbs_table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size_get_f table_mdb_kaps_dynamic_memory_access_sbc_memory_access_field_size_get;
    /**
     * returns define data of table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size
     */
    dnx_data_mdb_pdbs_table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size_get_f table_mdb_kaps_dynamic_memory_access_dpc_memory_access_field_size_get;
    /**
     * returns define data of table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size
     */
    dnx_data_mdb_pdbs_table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size_get_f table_mdb_ddha_dynamic_memory_access_sbc_memory_access_field_size_get;
    /**
     * returns define data of table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size
     */
    dnx_data_mdb_pdbs_table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size_get_f table_mdb_ddha_dynamic_memory_access_dpc_memory_access_field_size_get;
    /**
     * returns define data of table_mdb_ddhb_dynamic_memory_access_memory_access_field_size
     */
    dnx_data_mdb_pdbs_table_mdb_ddhb_dynamic_memory_access_memory_access_field_size_get_f table_mdb_ddhb_dynamic_memory_access_memory_access_field_size_get;
    /**
     * returns define data of mdb_nof_profiles
     */
    dnx_data_mdb_pdbs_mdb_nof_profiles_get_f mdb_nof_profiles_get;
    /**
     * get table mdb_profile entry 
     */
    dnx_data_mdb_pdbs_mdb_profile_get_f mdb_profile_get;
    /**
     * get general info table about table (for example key size)mdb_profile info
     */
    dnxc_data_table_info_get_f mdb_profile_info_get;
    /**
     * get table mdb_profiles_info entry 
     */
    dnx_data_mdb_pdbs_mdb_profiles_info_get_f mdb_profiles_info_get;
    /**
     * get general info table about table (for example key size)mdb_profiles_info info
     */
    dnxc_data_table_info_get_f mdb_profiles_info_info_get;
    /**
     * get table mdb_profile_kaps_cfg entry 
     */
    dnx_data_mdb_pdbs_mdb_profile_kaps_cfg_get_f mdb_profile_kaps_cfg_get;
    /**
     * get general info table about table (for example key size)mdb_profile_kaps_cfg info
     */
    dnxc_data_table_info_get_f mdb_profile_kaps_cfg_info_get;
    /**
     * get table pdbs_info entry 
     */
    dnx_data_mdb_pdbs_pdbs_info_get_f pdbs_info_get;
    /**
     * get general info table about table (for example key size)pdbs_info info
     */
    dnxc_data_table_info_get_f pdbs_info_info_get;
    /**
     * get table pdb_info entry 
     */
    dnx_data_mdb_pdbs_pdb_info_get_f pdb_info_get;
    /**
     * get general info table about table (for example key size)pdb_info info
     */
    dnxc_data_table_info_get_f pdb_info_info_get;
    /**
     * get table mdb_11_info entry 
     */
    dnx_data_mdb_pdbs_mdb_11_info_get_f mdb_11_info_get;
    /**
     * get general info table about table (for example key size)mdb_11_info info
     */
    dnxc_data_table_info_get_f mdb_11_info_info_get;
    /**
     * get table mdb_12_info entry 
     */
    dnx_data_mdb_pdbs_mdb_12_info_get_f mdb_12_info_get;
    /**
     * get general info table about table (for example key size)mdb_12_info info
     */
    dnxc_data_table_info_get_f mdb_12_info_info_get;
    /**
     * get table mdb_26_info entry 
     */
    dnx_data_mdb_pdbs_mdb_26_info_get_f mdb_26_info_get;
    /**
     * get general info table about table (for example key size)mdb_26_info info
     */
    dnxc_data_table_info_get_f mdb_26_info_info_get;
    /**
     * get table mdb_adapter_mapping entry 
     */
    dnx_data_mdb_pdbs_mdb_adapter_mapping_get_f mdb_adapter_mapping_get;
    /**
     * get general info table about table (for example key size)mdb_adapter_mapping info
     */
    dnxc_data_table_info_get_f mdb_adapter_mapping_info_get;
} dnx_data_if_mdb_pdbs_t;

/*
 * }
 */

/*
 * SUBMODULE  - EM:
 * EM information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule em table spn
 * Table info:
 * holds SPN information
 */
typedef struct
{
    /**
     * The NOF SPNs sizes available for a given EM table.
     */
    uint8 nof_spn_size;
    /**
     * the given table SPN sizes.
     */
    uint8 spn_array[DNX_DATA_MAX_MDB_EM_MAX_NOF_SPN_SIZES];
} dnx_data_mdb_em_spn_t;

/**
 * \brief Holds values of submodule em table lfsr
 * Table info:
 * holds LFSR information
 */
typedef struct
{
    /**
     * The LFSR size.
     */
    int lfsr_size;
} dnx_data_mdb_em_lfsr_t;

/**
 * \brief Holds values of submodule em table em_aging_cfg
 * Table info:
 * aging information
 */
typedef struct
{
    /**
     * When an entry is entered/learned this is the initial age value that it received.
     */
    uint8 init_value;
    /**
     * Allows updating the age value in multiplication of scan cycles.
     */
    uint8 global_value;
    /**
     * Allows updating the age value in multiplication of scan cycles.
     */
    uint8 global_mask;
    /**
     * Whether to take the age configuration from this register or externally (e.g. MACT age configuration).
     */
    uint8 external_profile;
    /**
     * Disable ageing.
     */
    uint8 aging_disable;
    /**
     * Disable elephant option.
     */
    uint8 elephant_disable;
    /**
     * A lower age threshold which an entry that reaches/pass this age threshold get some dedicated payload.
     */
    uint8 elephant_values;
    /**
     * An upper age threshold which an entry that reaches/pass this age threshold get some dedicated payload.
     */
    uint8 mouse_values;
    /**
     * An entry age can be update up to this value.
     */
    uint8 age_max_values;
    /**
     * In case of an entry hit the age will be incremented by this value.
     */
    uint8 increment_values;
    /**
     * In case the age scan found the an entry was not accessed (no hit) the age value will be decremented by this value.
     */
    uint8 decrement_values;
    /**
     * The age of entry that trigger entry removal (usually it will be zero).
     */
    uint8 out_values;
    /**
     * The hit bit mode that will determine an age hit.
     */
    dbal_enum_value_field_mdb_em_aging_hit_bit_e hit_bit_mode;
} dnx_data_mdb_em_em_aging_cfg_t;

/**
 * \brief Holds values of submodule em table em_info
 * Table info:
 * Holds EM tables information
 */
typedef struct
{
    /**
     * The MDB table TID size.
     */
    uint32 tid_size;
    /**
     * no description.
     */
    soc_mem_t em_interface;
    /**
     * no description.
     */
    soc_mem_t age_mem;
    /**
     * no description.
     */
    soc_mem_t age_ovf_cam_mem;
    /**
     * no description.
     */
    soc_reg_t status_reg;
    /**
     * no description.
     */
    soc_field_t interrupt_field;
    /**
     * step table NOF rows
     */
    uint32 step_table_size;
    /**
     * overflow CAM NOF rows
     */
    uint32 ovf_cam_size;
} dnx_data_mdb_em_em_info_t;

/**
 * \brief Holds values of submodule em table step_table_pdb_max_depth
 * Table info:
 * hold the maximal depth of the step table that is supported by an EM PDB.
 */
typedef struct
{
    /**
     * the step table max depth.
     */
    uint32 max_depth;
} dnx_data_mdb_em_step_table_pdb_max_depth_t;

/**
 * \brief Holds values of submodule em table step_table_max_depth_possible
 * Table info:
 * hold the maximal depth of the step table for different aspect ratio combinations and table sizes
 */
typedef struct
{
    /**
     * the step table max depth.
     */
    uint32 max_depth;
} dnx_data_mdb_em_step_table_max_depth_possible_t;

/**
 * \brief Holds values of submodule em table mdb_13_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
} dnx_data_mdb_em_mdb_13_info_t;

/**
 * \brief Holds values of submodule em table mdb_15_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_5_field_size;
} dnx_data_mdb_em_mdb_15_info_t;

/**
 * \brief Holds values of submodule em table mdb_16_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
} dnx_data_mdb_em_mdb_16_info_t;

/**
 * \brief Holds values of submodule em table mdb_18_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
} dnx_data_mdb_em_mdb_18_info_t;

/**
 * \brief Holds values of submodule em table mdb_21_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
} dnx_data_mdb_em_mdb_21_info_t;

/**
 * \brief Holds values of submodule em table mdb_23_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
    /**
     * no description.
     */
    uint32 mdb_item_1_field_size;
} dnx_data_mdb_em_mdb_23_info_t;

/**
 * \brief Holds values of submodule em table mdb_24_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_1_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_1_field_size;
} dnx_data_mdb_em_mdb_24_info_t;

/**
 * \brief Holds values of submodule em table mdb_29_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_1_array_size;
} dnx_data_mdb_em_mdb_29_info_t;

/**
 * \brief Holds values of submodule em table mdb_31_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 array_size;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
} dnx_data_mdb_em_mdb_31_info_t;

/**
 * \brief Holds values of submodule em table mdb_32_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
} dnx_data_mdb_em_mdb_32_info_t;

/**
 * \brief Holds values of submodule em table mdb_41_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 array_size;
    /**
     * no description.
     */
    uint32 mdb_item_2_field_size;
    /**
     * no description.
     */
    uint32 mdb_item_3_field_size;
} dnx_data_mdb_em_mdb_41_info_t;

/**
 * \brief Holds values of submodule em table mdb_em_tables_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e mdb_14_table;
    /**
     * no description.
     */
    dbal_tables_e mdb_15_table;
    /**
     * no description.
     */
    dbal_tables_e mdb_17_table;
    /**
     * no description.
     */
    dbal_tables_e mdb_step_table;
    /**
     * no description.
     */
    dbal_tables_e mdb_32_table;
} dnx_data_mdb_em_mdb_em_tables_info_t;

/**
 * \brief Holds values of submodule em table mdb_emp_tables_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e emp_age_cfg_table;
    /**
     * no description.
     */
    dbal_tables_e mdb_22_table;
} dnx_data_mdb_em_mdb_emp_tables_info_t;

/**
 * \brief Holds values of submodule em table mdb_em_shift_vmv_regs
 * Table info:
 * Holds the shift vmv DBAL tables associated with each MDB EM table.
 */
typedef struct
{
    /**
     * The NOF valid shift vmv regs associated with this table.
     */
    uint8 nof_valid_regs;
    /**
     * The associated DBAL table names.
     */
    dbal_tables_e table_name_arr[DNX_DATA_MAX_MDB_EM_SHIFT_VMV_MAX_REGS_PER_TABLE];
    /**
     * The associated DBAL field names.
     */
    dbal_fields_e field_name_arr[DNX_DATA_MAX_MDB_EM_SHIFT_VMV_MAX_REGS_PER_TABLE];
    /**
     * The associated DBAL key names.
     */
    dbal_fields_e key_name_arr[DNX_DATA_MAX_MDB_EM_SHIFT_VMV_MAX_REGS_PER_TABLE];
    /**
     * The index within the specific register.
     */
    uint8 stage_index_arr[DNX_DATA_MAX_MDB_EM_SHIFT_VMV_MAX_REGS_PER_TABLE];
} dnx_data_mdb_em_mdb_em_shift_vmv_regs_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is the entry type parsed by HW (or needs to be provided)?
     */
    dnx_data_mdb_em_entry_type_parser,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_em_feature_nof
} dnx_data_mdb_em_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_em_feature_get_f) (
    int unit,
    dnx_data_mdb_em_feature_e feature);

/**
 * \brief returns define data of total_nof_lem_aging_bits
 * Module - 'mdb', Submodule - 'em', data - 'total_nof_lem_aging_bits'
 * The total number of bits available for the LEM aging.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_lem_aging_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_total_nof_lem_aging_bits_get_f) (
    int unit);

/**
 * \brief returns define data of total_nof_exem_aging_bits
 * Module - 'mdb', Submodule - 'em', data - 'total_nof_exem_aging_bits'
 * The total number of bits available for the EXEM aging.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_exem_aging_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_total_nof_exem_aging_bits_get_f) (
    int unit);

/**
 * \brief returns define data of age_row_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_row_size_bits'
 * The number of bits in a single aging memory row
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_row_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_age_row_size_bits_get_f) (
    int unit);

/**
 * \brief returns define data of age_ovfcam_row_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_ovfcam_row_size_bits'
 * The number of bits in a single aging ovfcam memory row
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_ovfcam_row_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_age_ovfcam_row_size_bits_get_f) (
    int unit);

/**
 * \brief returns define data of age_entry_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_entry_size_bits'
 * The number of bits in a single aging memory entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_entry_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_age_entry_size_bits_get_f) (
    int unit);

/**
 * \brief returns define data of ovf_cam_max_size
 * Module - 'mdb', Submodule - 'em', data - 'ovf_cam_max_size'
 * the MAX size of an OVF CAM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ovf_cam_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_ovf_cam_max_size_get_f) (
    int unit);

/**
 * \brief returns define data of age_support_per_entry_size_ratio
 * Module - 'mdb', Submodule - 'em', data - 'age_support_per_entry_size_ratio'
 * Indicate if the aging profiles are supported per entry ratio size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_support_per_entry_size_ratio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_age_support_per_entry_size_ratio_get_f) (
    int unit);

/**
 * \brief returns define data of nof_aging_profiles
 * Module - 'mdb', Submodule - 'em', data - 'nof_aging_profiles'
 * The NOF aging profile avialable in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_aging_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_aging_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of aging_profiles_size_in_bits
 * Module - 'mdb', Submodule - 'em', data - 'aging_profiles_size_in_bits'
 * The number of bits needed for the NOF aging profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aging_profiles_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_aging_profiles_size_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of max_tid_size
 * Module - 'mdb', Submodule - 'em', data - 'max_tid_size'
 * The largest TID size in bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tid_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_max_tid_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_tids
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_tids'
 * max NOF of TIDs for a PDB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_tids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_max_nof_tids_get_f) (
    int unit);

/**
 * \brief returns define data of flush_support_tids
 * Module - 'mdb', Submodule - 'em', data - 'flush_support_tids'
 * The max NOF of TIDs an MDB table that support flush machine could have.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_support_tids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_flush_support_tids_get_f) (
    int unit);

/**
 * \brief returns define data of flush_max_supported_key
 * Module - 'mdb', Submodule - 'em', data - 'flush_max_supported_key'
 * The largest key size that can be used by the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_max_supported_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_flush_max_supported_key_get_f) (
    int unit);

/**
 * \brief returns define data of flush_max_supported_payload
 * Module - 'mdb', Submodule - 'em', data - 'flush_max_supported_payload'
 * The largest payload size that can be used by the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_max_supported_payload - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_flush_max_supported_payload_get_f) (
    int unit);

/**
 * \brief returns define data of flush_max_supported_key_plus_payload
 * Module - 'mdb', Submodule - 'em', data - 'flush_max_supported_key_plus_payload'
 * The largest key+payload size that can be used by the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_max_supported_key_plus_payload - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_flush_max_supported_key_plus_payload_get_f) (
    int unit);

/**
 * \brief returns define data of dh_120_entry_encoding_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'dh_120_entry_encoding_nof_bits'
 * Number of bits representing a EM DH 120 width cluster encoding value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dh_120_entry_encoding_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_dh_120_entry_encoding_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of dh_240_entry_encoding_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'dh_240_entry_encoding_nof_bits'
 * Number of bits representing a EM DH 240 width cluster encoding value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dh_240_entry_encoding_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_dh_240_entry_encoding_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of format_granularity
 * Module - 'mdb', Submodule - 'em', data - 'format_granularity'
 * The granularity used for the EM format configuration.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     format_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_format_granularity_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_vmv_size'
 * The number of bits used to represent the vmv, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_max_nof_vmv_size_get_f) (
    int unit);

/**
 * \brief returns define data of vmv_nof_values
 * Module - 'mdb', Submodule - 'em', data - 'vmv_nof_values'
 * NOF values available for the VMV (depends on the nof_vmv_size value)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vmv_nof_values - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_vmv_nof_values_get_f) (
    int unit);

/**
 * \brief returns define data of nof_vmv_size_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'nof_vmv_size_nof_bits'
 * the nof_vmv_size size in bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vmv_size_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_vmv_size_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of esem_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'esem_nof_vmv_size'
 * The number of bits used to represent the vmv for ESEM only, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     esem_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_esem_nof_vmv_size_get_f) (
    int unit);

/**
 * \brief returns define data of glem_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'glem_nof_vmv_size'
 * The number of bits used to represent the VMV for GLEM only, smaller vmv sizes are simply aligned to the MDB and the configuration iterates on all possible values of the LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     glem_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_glem_nof_vmv_size_get_f) (
    int unit);

/**
 * \brief returns define data of mact_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'mact_nof_vmv_size'
 * The number of bits used to represent the vmv for MACT only, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB;This value is a HW constraint related to MACT LEL, other LEM logical tables can utilize the full MDB_NOF_VMV_BITS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_mact_nof_vmv_size_get_f) (
    int unit);

/**
 * \brief returns define data of mact_max_payload_size
 * Module - 'mdb', Submodule - 'em', data - 'mact_max_payload_size'
 * MACT payload has to be this size or smaller
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_mact_max_payload_size_get_f) (
    int unit);

/**
 * \brief returns define data of shift_vmv_max_size
 * Module - 'mdb', Submodule - 'em', data - 'shift_vmv_max_size'
 * NOF of EM lookup per stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     shift_vmv_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_shift_vmv_max_size_get_f) (
    int unit);

/**
 * \brief returns define data of shift_vmv_max_regs_per_table
 * Module - 'mdb', Submodule - 'em', data - 'shift_vmv_max_regs_per_table'
 * NOF of different shift vmv registers associated with a single EM table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     shift_vmv_max_regs_per_table - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_shift_vmv_max_regs_per_table_get_f) (
    int unit);

/**
 * \brief returns define data of min_nof_app_id_bits
 * Module - 'mdb', Submodule - 'em', data - 'min_nof_app_id_bits'
 * The minimal number of bits used to represent APP ID.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_nof_app_id_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_min_nof_app_id_bits_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_spn_sizes
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_spn_sizes'
 * The maximal NOF of SPN sizes options for a single EM PDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_spn_sizes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_max_nof_spn_sizes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_lfsr_sizes
 * Module - 'mdb', Submodule - 'em', data - 'nof_lfsr_sizes'
 * The NOF of LFSR sizes options for a single EM PDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lfsr_sizes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_lfsr_sizes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_formats
 * Module - 'mdb', Submodule - 'em', data - 'nof_formats'
 * The NOF formats which the EM application can used, a format define by the key size and address size and the table address space.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_formats - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_formats_get_f) (
    int unit);

/**
 * \brief returns define data of defragmentation_priority_supported
 * Module - 'mdb', Submodule - 'em', data - 'defragmentation_priority_supported'
 * Overflow CAM defrag machine has priority over Host/Ext support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     defragmentation_priority_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_defragmentation_priority_supported_get_f) (
    int unit);

/**
 * \brief returns define data of disable_cuckoo_loop_detection_support
 * Module - 'mdb', Submodule - 'em', data - 'disable_cuckoo_loop_detection_support'
 * indicate if the device has an option to disable loop detectionin cuckoo processing
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     disable_cuckoo_loop_detection_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_disable_cuckoo_loop_detection_support_get_f) (
    int unit);

/**
 * \brief returns define data of disable_cuckoo_hit_bit_sync
 * Module - 'mdb', Submodule - 'em', data - 'disable_cuckoo_hit_bit_sync'
 * indicate if the device has an option to disable cuckoo hit bit handle
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     disable_cuckoo_hit_bit_sync - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_disable_cuckoo_hit_bit_sync_get_f) (
    int unit);

/**
 * \brief returns define data of age_profile_per_ratio_support
 * Module - 'mdb', Submodule - 'em', data - 'age_profile_per_ratio_support'
 * indicate if the device has an age profile per ratio support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_profile_per_ratio_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_age_profile_per_ratio_support_get_f) (
    int unit);

/**
 * \brief returns define data of flex_mag_supported
 * Module - 'mdb', Submodule - 'em', data - 'flex_mag_supported'
 * the flex supported in the MAG but not necessarily fully supported 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flex_mag_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_flex_mag_supported_get_f) (
    int unit);

/**
 * \brief returns define data of flex_fully_supported
 * Module - 'mdb', Submodule - 'em', data - 'flex_fully_supported'
 * flex feature is fully supported (if this is set so does the flex_mag_supported should be).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flex_fully_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_flex_fully_supported_get_f) (
    int unit);

/**
 * \brief returns define data of step_table_max_size
 * Module - 'mdb', Submodule - 'em', data - 'step_table_max_size'
 * The max NOF rows that a step table can hold.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     step_table_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_step_table_max_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_encoding_values
 * Module - 'mdb', Submodule - 'em', data - 'nof_encoding_values'
 * the NOF encoding values (values that represent the payload size out of row width) in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_encoding_values - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_encoding_values_get_f) (
    int unit);

/**
 * \brief returns define data of nof_encoding_types
 * Module - 'mdb', Submodule - 'em', data - 'nof_encoding_types'
 * the NOF encoding types (ONE/HALF/QUARTER/EIGHTH) in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_encoding_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_encoding_types_get_f) (
    int unit);

/**
 * \brief returns define data of extra_vmv_shift_registers
 * Module - 'mdb', Submodule - 'em', data - 'extra_vmv_shift_registers'
 * Device have a larger NOF VMV shift registers.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     extra_vmv_shift_registers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_extra_vmv_shift_registers_get_f) (
    int unit);

/**
 * \brief returns numeric data of interrupt_register
 * Module - 'mdb', Submodule - 'em', data - 'interrupt_register'
 * EM interrupt register.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     interrupt_register - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_interrupt_register_get_f) (
    int unit);

/**
 * \brief get table spn entry 
 * holds SPN information
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are valid in this case)
 * 
 * \return
 *     spn - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_spn_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_spn_t *(
    *dnx_data_mdb_em_spn_get_f) (
    int unit,
    int dbal_id);

/**
 * \brief get table lfsr entry 
 * holds LFSR information
 * 
 * \param [in] unit - unit #
 * \param [in] lfsr_index - the index number of the  requseted LFSR.
 * 
 * \return
 *     lfsr - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_lfsr_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_lfsr_t *(
    *dnx_data_mdb_em_lfsr_get_f) (
    int unit,
    int lfsr_index);

/**
 * \brief get table em_aging_cfg entry 
 * aging information
 * 
 * \param [in] unit - unit #
 * \param [in] profile - The aging profile to set.
 * \param [in] emp_table - The EMP table to set.
 * 
 * \return
 *     em_aging_cfg - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_em_aging_cfg_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_em_aging_cfg_t *(
    *dnx_data_mdb_em_em_aging_cfg_get_f) (
    int unit,
    int profile,
    int emp_table);

/**
 * \brief get table em_info entry 
 * Holds EM tables information
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are valid in this case)
 * 
 * \return
 *     em_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_em_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_em_info_t *(
    *dnx_data_mdb_em_em_info_get_f) (
    int unit,
    int dbal_id);

/**
 * \brief get table step_table_pdb_max_depth entry 
 * hold the maximal depth of the step table that is supported by an EM PDB.
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are valid in this case)
 * 
 * \return
 *     step_table_pdb_max_depth - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_step_table_pdb_max_depth_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_step_table_pdb_max_depth_t *(
    *dnx_data_mdb_em_step_table_pdb_max_depth_get_f) (
    int unit,
    int dbal_id);

/**
 * \brief get table step_table_max_depth_possible entry 
 * hold the maximal depth of the step table for different aspect ratio combinations and table sizes
 * 
 * \param [in] unit - unit #
 * \param [in] step_table_size_indication - indicate the step table size where 0> 512, 1->1024 and 2->2048 means rows in the step table.
 * \param [in] aspect_ratio_combination - the aspect ratio that are in the step table where bit to ratio mapping is 0->one, 1->half, 2->quarter, 3->eighth
 * 
 * \return
 *     step_table_max_depth_possible - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_step_table_max_depth_possible_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_step_table_max_depth_possible_t *(
    *dnx_data_mdb_em_step_table_max_depth_possible_get_f) (
    int unit,
    int step_table_size_indication,
    int aspect_ratio_combination);

/**
 * \brief get table mdb_13_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_13_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_13_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_13_info_t *(
    *dnx_data_mdb_em_mdb_13_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_15_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_15_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_15_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_15_info_t *(
    *dnx_data_mdb_em_mdb_15_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_16_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_16_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_16_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_16_info_t *(
    *dnx_data_mdb_em_mdb_16_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_18_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_18_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_18_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_18_info_t *(
    *dnx_data_mdb_em_mdb_18_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_21_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_21_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_21_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_21_info_t *(
    *dnx_data_mdb_em_mdb_21_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_23_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_23_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_23_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_23_info_t *(
    *dnx_data_mdb_em_mdb_23_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_24_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_24_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_24_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_24_info_t *(
    *dnx_data_mdb_em_mdb_24_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_29_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_29_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_29_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_29_info_t *(
    *dnx_data_mdb_em_mdb_29_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_31_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_31_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_31_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_31_info_t *(
    *dnx_data_mdb_em_mdb_31_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_32_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_32_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_32_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_32_info_t *(
    *dnx_data_mdb_em_mdb_32_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_41_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_41_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_41_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_41_info_t *(
    *dnx_data_mdb_em_mdb_41_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_em_tables_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_em_tables_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_em_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_em_tables_info_t *(
    *dnx_data_mdb_em_mdb_em_tables_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_emp_tables_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_emp_tables_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_emp_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_emp_tables_info_t *(
    *dnx_data_mdb_em_mdb_emp_tables_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_em_shift_vmv_regs entry 
 * Holds the shift vmv DBAL tables associated with each MDB EM table.
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are valid in this case)
 * 
 * \return
 *     mdb_em_shift_vmv_regs - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_em_shift_vmv_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_em_shift_vmv_regs_t *(
    *dnx_data_mdb_em_mdb_em_shift_vmv_regs_get_f) (
    int unit,
    int dbal_id);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - EM:
 * {
 */
/**
 * \brief Interface for mdb em data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_em_feature_get_f feature_get;
    /**
     * returns define data of total_nof_lem_aging_bits
     */
    dnx_data_mdb_em_total_nof_lem_aging_bits_get_f total_nof_lem_aging_bits_get;
    /**
     * returns define data of total_nof_exem_aging_bits
     */
    dnx_data_mdb_em_total_nof_exem_aging_bits_get_f total_nof_exem_aging_bits_get;
    /**
     * returns define data of age_row_size_bits
     */
    dnx_data_mdb_em_age_row_size_bits_get_f age_row_size_bits_get;
    /**
     * returns define data of age_ovfcam_row_size_bits
     */
    dnx_data_mdb_em_age_ovfcam_row_size_bits_get_f age_ovfcam_row_size_bits_get;
    /**
     * returns define data of age_entry_size_bits
     */
    dnx_data_mdb_em_age_entry_size_bits_get_f age_entry_size_bits_get;
    /**
     * returns define data of ovf_cam_max_size
     */
    dnx_data_mdb_em_ovf_cam_max_size_get_f ovf_cam_max_size_get;
    /**
     * returns define data of age_support_per_entry_size_ratio
     */
    dnx_data_mdb_em_age_support_per_entry_size_ratio_get_f age_support_per_entry_size_ratio_get;
    /**
     * returns define data of nof_aging_profiles
     */
    dnx_data_mdb_em_nof_aging_profiles_get_f nof_aging_profiles_get;
    /**
     * returns define data of aging_profiles_size_in_bits
     */
    dnx_data_mdb_em_aging_profiles_size_in_bits_get_f aging_profiles_size_in_bits_get;
    /**
     * returns define data of max_tid_size
     */
    dnx_data_mdb_em_max_tid_size_get_f max_tid_size_get;
    /**
     * returns define data of max_nof_tids
     */
    dnx_data_mdb_em_max_nof_tids_get_f max_nof_tids_get;
    /**
     * returns define data of flush_support_tids
     */
    dnx_data_mdb_em_flush_support_tids_get_f flush_support_tids_get;
    /**
     * returns define data of flush_max_supported_key
     */
    dnx_data_mdb_em_flush_max_supported_key_get_f flush_max_supported_key_get;
    /**
     * returns define data of flush_max_supported_payload
     */
    dnx_data_mdb_em_flush_max_supported_payload_get_f flush_max_supported_payload_get;
    /**
     * returns define data of flush_max_supported_key_plus_payload
     */
    dnx_data_mdb_em_flush_max_supported_key_plus_payload_get_f flush_max_supported_key_plus_payload_get;
    /**
     * returns define data of dh_120_entry_encoding_nof_bits
     */
    dnx_data_mdb_em_dh_120_entry_encoding_nof_bits_get_f dh_120_entry_encoding_nof_bits_get;
    /**
     * returns define data of dh_240_entry_encoding_nof_bits
     */
    dnx_data_mdb_em_dh_240_entry_encoding_nof_bits_get_f dh_240_entry_encoding_nof_bits_get;
    /**
     * returns define data of format_granularity
     */
    dnx_data_mdb_em_format_granularity_get_f format_granularity_get;
    /**
     * returns define data of max_nof_vmv_size
     */
    dnx_data_mdb_em_max_nof_vmv_size_get_f max_nof_vmv_size_get;
    /**
     * returns define data of vmv_nof_values
     */
    dnx_data_mdb_em_vmv_nof_values_get_f vmv_nof_values_get;
    /**
     * returns define data of nof_vmv_size_nof_bits
     */
    dnx_data_mdb_em_nof_vmv_size_nof_bits_get_f nof_vmv_size_nof_bits_get;
    /**
     * returns define data of esem_nof_vmv_size
     */
    dnx_data_mdb_em_esem_nof_vmv_size_get_f esem_nof_vmv_size_get;
    /**
     * returns define data of glem_nof_vmv_size
     */
    dnx_data_mdb_em_glem_nof_vmv_size_get_f glem_nof_vmv_size_get;
    /**
     * returns define data of mact_nof_vmv_size
     */
    dnx_data_mdb_em_mact_nof_vmv_size_get_f mact_nof_vmv_size_get;
    /**
     * returns define data of mact_max_payload_size
     */
    dnx_data_mdb_em_mact_max_payload_size_get_f mact_max_payload_size_get;
    /**
     * returns define data of shift_vmv_max_size
     */
    dnx_data_mdb_em_shift_vmv_max_size_get_f shift_vmv_max_size_get;
    /**
     * returns define data of shift_vmv_max_regs_per_table
     */
    dnx_data_mdb_em_shift_vmv_max_regs_per_table_get_f shift_vmv_max_regs_per_table_get;
    /**
     * returns define data of min_nof_app_id_bits
     */
    dnx_data_mdb_em_min_nof_app_id_bits_get_f min_nof_app_id_bits_get;
    /**
     * returns define data of max_nof_spn_sizes
     */
    dnx_data_mdb_em_max_nof_spn_sizes_get_f max_nof_spn_sizes_get;
    /**
     * returns define data of nof_lfsr_sizes
     */
    dnx_data_mdb_em_nof_lfsr_sizes_get_f nof_lfsr_sizes_get;
    /**
     * returns define data of nof_formats
     */
    dnx_data_mdb_em_nof_formats_get_f nof_formats_get;
    /**
     * returns define data of defragmentation_priority_supported
     */
    dnx_data_mdb_em_defragmentation_priority_supported_get_f defragmentation_priority_supported_get;
    /**
     * returns define data of disable_cuckoo_loop_detection_support
     */
    dnx_data_mdb_em_disable_cuckoo_loop_detection_support_get_f disable_cuckoo_loop_detection_support_get;
    /**
     * returns define data of disable_cuckoo_hit_bit_sync
     */
    dnx_data_mdb_em_disable_cuckoo_hit_bit_sync_get_f disable_cuckoo_hit_bit_sync_get;
    /**
     * returns define data of age_profile_per_ratio_support
     */
    dnx_data_mdb_em_age_profile_per_ratio_support_get_f age_profile_per_ratio_support_get;
    /**
     * returns define data of flex_mag_supported
     */
    dnx_data_mdb_em_flex_mag_supported_get_f flex_mag_supported_get;
    /**
     * returns define data of flex_fully_supported
     */
    dnx_data_mdb_em_flex_fully_supported_get_f flex_fully_supported_get;
    /**
     * returns define data of step_table_max_size
     */
    dnx_data_mdb_em_step_table_max_size_get_f step_table_max_size_get;
    /**
     * returns define data of nof_encoding_values
     */
    dnx_data_mdb_em_nof_encoding_values_get_f nof_encoding_values_get;
    /**
     * returns define data of nof_encoding_types
     */
    dnx_data_mdb_em_nof_encoding_types_get_f nof_encoding_types_get;
    /**
     * returns define data of extra_vmv_shift_registers
     */
    dnx_data_mdb_em_extra_vmv_shift_registers_get_f extra_vmv_shift_registers_get;
    /**
     * returns numeric data of interrupt_register
     */
    dnx_data_mdb_em_interrupt_register_get_f interrupt_register_get;
    /**
     * get table spn entry 
     */
    dnx_data_mdb_em_spn_get_f spn_get;
    /**
     * get general info table about table (for example key size)spn info
     */
    dnxc_data_table_info_get_f spn_info_get;
    /**
     * get table lfsr entry 
     */
    dnx_data_mdb_em_lfsr_get_f lfsr_get;
    /**
     * get general info table about table (for example key size)lfsr info
     */
    dnxc_data_table_info_get_f lfsr_info_get;
    /**
     * get table em_aging_cfg entry 
     */
    dnx_data_mdb_em_em_aging_cfg_get_f em_aging_cfg_get;
    /**
     * get general info table about table (for example key size)em_aging_cfg info
     */
    dnxc_data_table_info_get_f em_aging_cfg_info_get;
    /**
     * get table em_info entry 
     */
    dnx_data_mdb_em_em_info_get_f em_info_get;
    /**
     * get general info table about table (for example key size)em_info info
     */
    dnxc_data_table_info_get_f em_info_info_get;
    /**
     * get table step_table_pdb_max_depth entry 
     */
    dnx_data_mdb_em_step_table_pdb_max_depth_get_f step_table_pdb_max_depth_get;
    /**
     * get general info table about table (for example key size)step_table_pdb_max_depth info
     */
    dnxc_data_table_info_get_f step_table_pdb_max_depth_info_get;
    /**
     * get table step_table_max_depth_possible entry 
     */
    dnx_data_mdb_em_step_table_max_depth_possible_get_f step_table_max_depth_possible_get;
    /**
     * get general info table about table (for example key size)step_table_max_depth_possible info
     */
    dnxc_data_table_info_get_f step_table_max_depth_possible_info_get;
    /**
     * get table mdb_13_info entry 
     */
    dnx_data_mdb_em_mdb_13_info_get_f mdb_13_info_get;
    /**
     * get general info table about table (for example key size)mdb_13_info info
     */
    dnxc_data_table_info_get_f mdb_13_info_info_get;
    /**
     * get table mdb_15_info entry 
     */
    dnx_data_mdb_em_mdb_15_info_get_f mdb_15_info_get;
    /**
     * get general info table about table (for example key size)mdb_15_info info
     */
    dnxc_data_table_info_get_f mdb_15_info_info_get;
    /**
     * get table mdb_16_info entry 
     */
    dnx_data_mdb_em_mdb_16_info_get_f mdb_16_info_get;
    /**
     * get general info table about table (for example key size)mdb_16_info info
     */
    dnxc_data_table_info_get_f mdb_16_info_info_get;
    /**
     * get table mdb_18_info entry 
     */
    dnx_data_mdb_em_mdb_18_info_get_f mdb_18_info_get;
    /**
     * get general info table about table (for example key size)mdb_18_info info
     */
    dnxc_data_table_info_get_f mdb_18_info_info_get;
    /**
     * get table mdb_21_info entry 
     */
    dnx_data_mdb_em_mdb_21_info_get_f mdb_21_info_get;
    /**
     * get general info table about table (for example key size)mdb_21_info info
     */
    dnxc_data_table_info_get_f mdb_21_info_info_get;
    /**
     * get table mdb_23_info entry 
     */
    dnx_data_mdb_em_mdb_23_info_get_f mdb_23_info_get;
    /**
     * get general info table about table (for example key size)mdb_23_info info
     */
    dnxc_data_table_info_get_f mdb_23_info_info_get;
    /**
     * get table mdb_24_info entry 
     */
    dnx_data_mdb_em_mdb_24_info_get_f mdb_24_info_get;
    /**
     * get general info table about table (for example key size)mdb_24_info info
     */
    dnxc_data_table_info_get_f mdb_24_info_info_get;
    /**
     * get table mdb_29_info entry 
     */
    dnx_data_mdb_em_mdb_29_info_get_f mdb_29_info_get;
    /**
     * get general info table about table (for example key size)mdb_29_info info
     */
    dnxc_data_table_info_get_f mdb_29_info_info_get;
    /**
     * get table mdb_31_info entry 
     */
    dnx_data_mdb_em_mdb_31_info_get_f mdb_31_info_get;
    /**
     * get general info table about table (for example key size)mdb_31_info info
     */
    dnxc_data_table_info_get_f mdb_31_info_info_get;
    /**
     * get table mdb_32_info entry 
     */
    dnx_data_mdb_em_mdb_32_info_get_f mdb_32_info_get;
    /**
     * get general info table about table (for example key size)mdb_32_info info
     */
    dnxc_data_table_info_get_f mdb_32_info_info_get;
    /**
     * get table mdb_41_info entry 
     */
    dnx_data_mdb_em_mdb_41_info_get_f mdb_41_info_get;
    /**
     * get general info table about table (for example key size)mdb_41_info info
     */
    dnxc_data_table_info_get_f mdb_41_info_info_get;
    /**
     * get table mdb_em_tables_info entry 
     */
    dnx_data_mdb_em_mdb_em_tables_info_get_f mdb_em_tables_info_get;
    /**
     * get general info table about table (for example key size)mdb_em_tables_info info
     */
    dnxc_data_table_info_get_f mdb_em_tables_info_info_get;
    /**
     * get table mdb_emp_tables_info entry 
     */
    dnx_data_mdb_em_mdb_emp_tables_info_get_f mdb_emp_tables_info_get;
    /**
     * get general info table about table (for example key size)mdb_emp_tables_info info
     */
    dnxc_data_table_info_get_f mdb_emp_tables_info_info_get;
    /**
     * get table mdb_em_shift_vmv_regs entry 
     */
    dnx_data_mdb_em_mdb_em_shift_vmv_regs_get_f mdb_em_shift_vmv_regs_get;
    /**
     * get general info table about table (for example key size)mdb_em_shift_vmv_regs info
     */
    dnxc_data_table_info_get_f mdb_em_shift_vmv_regs_info_get;
} dnx_data_if_mdb_em_t;

/*
 * }
 */

/*
 * SUBMODULE  - DIRECT:
 * direct information.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule direct table direct_info
 * Table info:
 * general information of the direct table PDBs
 */
typedef struct
{
    /**
     * the type of the direct payload
     */
    dbal_enum_value_field_mdb_direct_payload_e payload_type;
} dnx_data_mdb_direct_direct_info_t;

/**
 * \brief Holds values of submodule direct table hit_bit_pos_in_abk
 * Table info:
 * Each 30 bits of each entry has a matching ABK bit, this table matches hit bit option to an ABK hit bit position.
 */
typedef struct
{
    /**
     * The hit bit position in the ABK (relative to the entry).
     */
    uint8 hit_bit_position;
} dnx_data_mdb_direct_hit_bit_pos_in_abk_t;

/**
 * \brief Holds values of submodule direct table mdb_42_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
} dnx_data_mdb_direct_mdb_42_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_direct_feature_nof
} dnx_data_mdb_direct_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_direct_feature_get_f) (
    int unit,
    dnx_data_mdb_direct_feature_e feature);

/**
 * \brief returns define data of physical_address_max_bits
 * Module - 'mdb', Submodule - 'direct', data - 'physical_address_max_bits'
 * The number of DB_ATR_PHYSICAL_ADDRESS_SPACE bits associated with encoding 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_max_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_physical_address_max_bits_get_f) (
    int unit);

/**
 * \brief returns define data of physical_address_max_bits_support_single_macro_b_granularity_fec_alloc
 * Module - 'mdb', Submodule - 'direct', data - 'physical_address_max_bits_support_single_macro_b_granularity_fec_alloc'
 * The largest address space value which can support a single macro B granularity for the FEC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_max_bits_support_single_macro_b_granularity_fec_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_physical_address_max_bits_support_single_macro_b_granularity_fec_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of vsi_physical_address_max_bits
 * Module - 'mdb', Submodule - 'direct', data - 'vsi_physical_address_max_bits'
 * The VSI number of DB_ATR_PHYSICAL_ADDRESS_SPACE bits associated with encoding 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsi_physical_address_max_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_vsi_physical_address_max_bits_get_f) (
    int unit);

/**
 * \brief returns define data of fec_address_mapping_bits
 * Module - 'mdb', Submodule - 'direct', data - 'fec_address_mapping_bits'
 * The FEC address mapping bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_address_mapping_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_fec_address_mapping_bits_get_f) (
    int unit);

/**
 * \brief returns define data of fec_address_mapping_bits_relevant
 * Module - 'mdb', Submodule - 'direct', data - 'fec_address_mapping_bits_relevant'
 * The FEC relevant mapping bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_address_mapping_bits_relevant - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_fec_address_mapping_bits_relevant_get_f) (
    int unit);

/**
 * \brief returns define data of fec_max_cluster_pairs
 * Module - 'mdb', Submodule - 'direct', data - 'fec_max_cluster_pairs'
 * The maximal NOF cluster that can be associated to two FEC hierarchies.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_max_cluster_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_fec_max_cluster_pairs_get_f) (
    int unit);

/**
 * \brief returns define data of max_payload_size
 * Module - 'mdb', Submodule - 'direct', data - 'max_payload_size'
 * The largest payload size associated with a direct table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_max_payload_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fecs_in_super_fec
 * Module - 'mdb', Submodule - 'direct', data - 'nof_fecs_in_super_fec'
 * NOF of FECs contained in a single super FEC.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fecs_in_super_fec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_nof_fecs_in_super_fec_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fec_ecmp_hierarchies
 * Module - 'mdb', Submodule - 'direct', data - 'nof_fec_ecmp_hierarchies'
 * NOF of FEC/ECMP hierarchies.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_ecmp_hierarchies - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_nof_fec_ecmp_hierarchies_get_f) (
    int unit);

/**
 * \brief returns numeric data of map_payload_size_enum
 * Module - 'mdb', Submodule - 'direct', data - 'map_payload_size_enum'
 * Payload size Enum of PMF MAPS DB, configured using pmf_maps_payload_size SOC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     map_payload_size_enum - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_map_payload_size_enum_get_f) (
    int unit);

/**
 * \brief returns numeric data of map_payload_type_enum
 * Module - 'mdb', Submodule - 'direct', data - 'map_payload_type_enum'
 * Payload type Enum of PMF MAPS DB, configured using pmf_maps_payload_size SOC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     map_payload_type_enum - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_map_payload_type_enum_get_f) (
    int unit);

/**
 * \brief returns numeric data of map_payload_size
 * Module - 'mdb', Submodule - 'direct', data - 'map_payload_size'
 * Payload size of PMF MAPS DB, configured using pmf_maps_payload_size SOC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     map_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_map_payload_size_get_f) (
    int unit);

/**
 * \brief get table direct_info entry 
 * general information of the direct table PDBs
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB
 * 
 * \return
 *     direct_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_direct_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_direct_direct_info_t *(
    *dnx_data_mdb_direct_direct_info_get_f) (
    int unit,
    int dbal_id);

/**
 * \brief get table hit_bit_pos_in_abk entry 
 * Each 30 bits of each entry has a matching ABK bit, this table matches hit bit option to an ABK hit bit position.
 * 
 * \param [in] unit - unit #
 * \param [in] hit_bit_index - the hit bit index
 * 
 * \return
 *     hit_bit_pos_in_abk - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_hit_bit_pos_in_abk_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_direct_hit_bit_pos_in_abk_t *(
    *dnx_data_mdb_direct_hit_bit_pos_in_abk_get_f) (
    int unit,
    int hit_bit_index);

/**
 * \brief get table mdb_42_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_42_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_mdb_42_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_direct_mdb_42_info_t *(
    *dnx_data_mdb_direct_mdb_42_info_get_f) (
    int unit,
    int mdb_table);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - DIRECT:
 * {
 */
/**
 * \brief Interface for mdb direct data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_direct_feature_get_f feature_get;
    /**
     * returns define data of physical_address_max_bits
     */
    dnx_data_mdb_direct_physical_address_max_bits_get_f physical_address_max_bits_get;
    /**
     * returns define data of physical_address_max_bits_support_single_macro_b_granularity_fec_alloc
     */
    dnx_data_mdb_direct_physical_address_max_bits_support_single_macro_b_granularity_fec_alloc_get_f physical_address_max_bits_support_single_macro_b_granularity_fec_alloc_get;
    /**
     * returns define data of vsi_physical_address_max_bits
     */
    dnx_data_mdb_direct_vsi_physical_address_max_bits_get_f vsi_physical_address_max_bits_get;
    /**
     * returns define data of fec_address_mapping_bits
     */
    dnx_data_mdb_direct_fec_address_mapping_bits_get_f fec_address_mapping_bits_get;
    /**
     * returns define data of fec_address_mapping_bits_relevant
     */
    dnx_data_mdb_direct_fec_address_mapping_bits_relevant_get_f fec_address_mapping_bits_relevant_get;
    /**
     * returns define data of fec_max_cluster_pairs
     */
    dnx_data_mdb_direct_fec_max_cluster_pairs_get_f fec_max_cluster_pairs_get;
    /**
     * returns define data of max_payload_size
     */
    dnx_data_mdb_direct_max_payload_size_get_f max_payload_size_get;
    /**
     * returns define data of nof_fecs_in_super_fec
     */
    dnx_data_mdb_direct_nof_fecs_in_super_fec_get_f nof_fecs_in_super_fec_get;
    /**
     * returns define data of nof_fec_ecmp_hierarchies
     */
    dnx_data_mdb_direct_nof_fec_ecmp_hierarchies_get_f nof_fec_ecmp_hierarchies_get;
    /**
     * returns numeric data of map_payload_size_enum
     */
    dnx_data_mdb_direct_map_payload_size_enum_get_f map_payload_size_enum_get;
    /**
     * returns numeric data of map_payload_type_enum
     */
    dnx_data_mdb_direct_map_payload_type_enum_get_f map_payload_type_enum_get;
    /**
     * returns numeric data of map_payload_size
     */
    dnx_data_mdb_direct_map_payload_size_get_f map_payload_size_get;
    /**
     * get table direct_info entry 
     */
    dnx_data_mdb_direct_direct_info_get_f direct_info_get;
    /**
     * get general info table about table (for example key size)direct_info info
     */
    dnxc_data_table_info_get_f direct_info_info_get;
    /**
     * get table hit_bit_pos_in_abk entry 
     */
    dnx_data_mdb_direct_hit_bit_pos_in_abk_get_f hit_bit_pos_in_abk_get;
    /**
     * get general info table about table (for example key size)hit_bit_pos_in_abk info
     */
    dnxc_data_table_info_get_f hit_bit_pos_in_abk_info_get;
    /**
     * get table mdb_42_info entry 
     */
    dnx_data_mdb_direct_mdb_42_info_get_f mdb_42_info_get;
    /**
     * get general info table about table (for example key size)mdb_42_info info
     */
    dnxc_data_table_info_get_f mdb_42_info_info_get;
} dnx_data_if_mdb_direct_t;

/*
 * }
 */

/*
 * SUBMODULE  - EEDB:
 * EEDB information.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule eedb table phase_info
 * Table info:
 * general information per EEDB phase.
 */
typedef struct
{
    /**
     * NOF available banks for the phase.
     */
    uint32 nof_available_banks;
} dnx_data_mdb_eedb_phase_info_t;

/**
 * \brief Holds values of submodule eedb table outlif_physical_phase_granularity
 * Table info:
 * Assign an outlif physical phase granularity.
 */
typedef struct
{
    /**
     * The granularity of the EEDB data.
     */
    uint32 data_granularity;
} dnx_data_mdb_eedb_outlif_physical_phase_granularity_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * If enabled, it is possible to do a masked hitbit clear on the eedb abk bank.
     */
    dnx_data_mdb_eedb_eedb_bank_hitbit_masked_clear,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_eedb_feature_nof
} dnx_data_mdb_eedb_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_eedb_feature_get_f) (
    int unit,
    dnx_data_mdb_eedb_feature_e feature);

/**
 * \brief returns define data of phase_map_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_map_bits'
 * number of msbits used for the phase mapping.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_map_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_phase_map_bits_get_f) (
    int unit);

/**
 * \brief returns define data of phase_map_array_size
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_map_array_size'
 * Size of phase map array.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_map_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_phase_map_array_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_phase_per_mag
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phase_per_mag'
 * the NOF phases each MAGs Is associated with.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phase_per_mag - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_phase_per_mag_get_f) (
    int unit);

/**
 * \brief returns define data of nof_phases
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases'
 * NOF of EEDB phases.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_phases_get_f) (
    int unit);

/**
 * \brief returns define data of nof_eedb_mags
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_eedb_mags'
 * NOF of EEDB MAGs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eedb_mags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_eedb_mags_get_f) (
    int unit);

/**
 * \brief returns define data of nof_eedb_banks
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_eedb_banks'
 * NOF of EEDB banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eedb_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_eedb_banks_get_f) (
    int unit);

/**
 * \brief returns define data of nof_phases_per_eedb_bank
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases_per_eedb_bank'
 * Each EEDB bank can be associated with one of this amount of phases
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases_per_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_phases_per_eedb_bank_get_f) (
    int unit);

/**
 * \brief returns define data of nof_phases_per_eedb_bank_size
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases_per_eedb_bank_size'
 * nof_phases_per_eedb_bank size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases_per_eedb_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_phases_per_eedb_bank_size_get_f) (
    int unit);

/**
 * \brief returns define data of phase_bank_select_default
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_bank_select_default'
 * the default phase value for a bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_bank_select_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_phase_bank_select_default_get_f) (
    int unit);

/**
 * \brief returns define data of entry_format_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'entry_format_bits'
 * Number of MSbits used to determine the payload size in MDB_ENTRY_FORMATr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_format_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_entry_format_bits_get_f) (
    int unit);

/**
 * \brief returns define data of entry_format_encoding_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'entry_format_encoding_bits'
 * Number of bits used to represent the payload size (30/60/90/120) in MDB_ENTRY_FORMATr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_format_encoding_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_entry_format_encoding_bits_get_f) (
    int unit);

/**
 * \brief returns define data of bank_id_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'bank_id_bits'
 * Number of bits used for bank_id comparison.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_id_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_bank_id_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of entry_bank
 * Module - 'mdb', Submodule - 'eedb', data - 'entry_bank'
 * the EEDB entry bank memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_entry_bank_get_f) (
    int unit);

/**
 * \brief returns numeric data of abk_bank
 * Module - 'mdb', Submodule - 'eedb', data - 'abk_bank'
 * the EEDB abk bank memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     abk_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_abk_bank_get_f) (
    int unit);

/**
 * \brief get table phase_info entry 
 * general information per EEDB phase.
 * 
 * \param [in] unit - unit #
 * \param [in] phase_number - the phase number.
 * 
 * \return
 *     phase_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_eedb_phase_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_eedb_phase_info_t *(
    *dnx_data_mdb_eedb_phase_info_get_f) (
    int unit,
    int phase_number);

/**
 * \brief get table outlif_physical_phase_granularity entry 
 * Assign an outlif physical phase granularity.
 * 
 * \param [in] unit - unit #
 * \param [in] outlif_physical_phase - Physical phase.
 * 
 * \return
 *     outlif_physical_phase_granularity - returns the relevant entry values grouped in struct - see dnx_data_mdb_eedb_outlif_physical_phase_granularity_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_eedb_outlif_physical_phase_granularity_t *(
    *dnx_data_mdb_eedb_outlif_physical_phase_granularity_get_f) (
    int unit,
    int outlif_physical_phase);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - EEDB:
 * {
 */
/**
 * \brief Interface for mdb eedb data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_eedb_feature_get_f feature_get;
    /**
     * returns define data of phase_map_bits
     */
    dnx_data_mdb_eedb_phase_map_bits_get_f phase_map_bits_get;
    /**
     * returns define data of phase_map_array_size
     */
    dnx_data_mdb_eedb_phase_map_array_size_get_f phase_map_array_size_get;
    /**
     * returns define data of nof_phase_per_mag
     */
    dnx_data_mdb_eedb_nof_phase_per_mag_get_f nof_phase_per_mag_get;
    /**
     * returns define data of nof_phases
     */
    dnx_data_mdb_eedb_nof_phases_get_f nof_phases_get;
    /**
     * returns define data of nof_eedb_mags
     */
    dnx_data_mdb_eedb_nof_eedb_mags_get_f nof_eedb_mags_get;
    /**
     * returns define data of nof_eedb_banks
     */
    dnx_data_mdb_eedb_nof_eedb_banks_get_f nof_eedb_banks_get;
    /**
     * returns define data of nof_phases_per_eedb_bank
     */
    dnx_data_mdb_eedb_nof_phases_per_eedb_bank_get_f nof_phases_per_eedb_bank_get;
    /**
     * returns define data of nof_phases_per_eedb_bank_size
     */
    dnx_data_mdb_eedb_nof_phases_per_eedb_bank_size_get_f nof_phases_per_eedb_bank_size_get;
    /**
     * returns define data of phase_bank_select_default
     */
    dnx_data_mdb_eedb_phase_bank_select_default_get_f phase_bank_select_default_get;
    /**
     * returns define data of entry_format_bits
     */
    dnx_data_mdb_eedb_entry_format_bits_get_f entry_format_bits_get;
    /**
     * returns define data of entry_format_encoding_bits
     */
    dnx_data_mdb_eedb_entry_format_encoding_bits_get_f entry_format_encoding_bits_get;
    /**
     * returns define data of bank_id_bits
     */
    dnx_data_mdb_eedb_bank_id_bits_get_f bank_id_bits_get;
    /**
     * returns numeric data of entry_bank
     */
    dnx_data_mdb_eedb_entry_bank_get_f entry_bank_get;
    /**
     * returns numeric data of abk_bank
     */
    dnx_data_mdb_eedb_abk_bank_get_f abk_bank_get;
    /**
     * get table phase_info entry 
     */
    dnx_data_mdb_eedb_phase_info_get_f phase_info_get;
    /**
     * get general info table about table (for example key size)phase_info info
     */
    dnxc_data_table_info_get_f phase_info_info_get;
    /**
     * get table outlif_physical_phase_granularity entry 
     */
    dnx_data_mdb_eedb_outlif_physical_phase_granularity_get_f outlif_physical_phase_granularity_get;
    /**
     * get general info table about table (for example key size)outlif_physical_phase_granularity info
     */
    dnxc_data_table_info_get_f outlif_physical_phase_granularity_info_get;
} dnx_data_if_mdb_eedb_t;

/*
 * }
 */

/*
 * SUBMODULE  - KAPS:
 * kaps information.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule kaps table big_bb_blk_id_mapping
 * Table info:
 * Mapping from KBPSDK blk_id to global_macro_index
 */
typedef struct
{
    /**
     * The global_macro_index associated with the blk_id
     */
    uint32 global_macro_index;
} dnx_data_mdb_kaps_big_bb_blk_id_mapping_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_kaps_feature_nof
} dnx_data_mdb_kaps_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_kaps_feature_get_f) (
    int unit,
    dnx_data_mdb_kaps_feature_e feature);

/**
 * \brief returns define data of nof_small_bbs
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_small_bbs'
 * nof small BBs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_bbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_nof_small_bbs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_big_bbs_blk_ids
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_big_bbs_blk_ids'
 * nof KBPSDK blk_ids associated with big BBs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_bbs_blk_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_nof_big_bbs_blk_ids_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_small_bb
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_rows_in_small_bb'
 * nof row in a small BB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_small_bb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_nof_rows_in_small_bb_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_small_rpb_hitbits
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_rows_in_small_rpb_hitbits'
 * nof row in a small RPB hitbits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_small_rpb_hitbits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_nof_rows_in_small_rpb_hitbits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bytes_in_hitbit_row
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_bytes_in_hitbit_row'
 * nof bytes in a hitbit database row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bytes_in_hitbit_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_nof_bytes_in_hitbit_row_get_f) (
    int unit);

/**
 * \brief returns define data of key_lsn_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'key_lsn_bits'
 * RPB input = {key, search_lsn}.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_lsn_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_key_lsn_bits_get_f) (
    int unit);

/**
 * \brief returns define data of key_prefix_length
 * Module - 'mdb', Submodule - 'kaps', data - 'key_prefix_length'
 * The KAPS DB prefix length.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_prefix_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_key_prefix_length_get_f) (
    int unit);

/**
 * \brief returns define data of max_prefix_in_bb_row
 * Module - 'mdb', Submodule - 'kaps', data - 'max_prefix_in_bb_row'
 * The maximum number of prefixes in a single KAPS BB row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_in_bb_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_max_prefix_in_bb_row_get_f) (
    int unit);

/**
 * \brief returns define data of key_width_in_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'key_width_in_bits'
 * The KAPS(LPM) key size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_width_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_key_width_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of ad_width_in_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'ad_width_in_bits'
 * The KAPS(LPM) payload size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ad_width_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_ad_width_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of bb_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'bb_byte_width'
 * the BB width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bb_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_bb_byte_width_get_f) (
    int unit);

/**
 * \brief returns define data of rpb_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_byte_width'
 * the RPB width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_rpb_byte_width_get_f) (
    int unit);

/**
 * \brief returns define data of ads_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'ads_byte_width'
 * the ADS width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ads_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_ads_byte_width_get_f) (
    int unit);

/**
 * \brief returns define data of rpb_valid_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_valid_bits'
 * the RPB valid size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_valid_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_rpb_valid_bits_get_f) (
    int unit);

/**
 * \brief returns define data of dynamic_memory_access_dpc
 * Module - 'mdb', Submodule - 'kaps', data - 'dynamic_memory_access_dpc'
 * The KAPS dynamic memory is of DPC type.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dynamic_memory_access_dpc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_dynamic_memory_access_dpc_get_f) (
    int unit);

/**
 * \brief returns numeric data of rpb_field
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_field'
 * LPM RPB field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_rpb_field_get_f) (
    int unit);

/**
 * \brief returns numeric data of result_core0_db0_reg
 * Module - 'mdb', Submodule - 'kaps', data - 'result_core0_db0_reg'
 * The LPM search interface result for core 0 db 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     result_core0_db0_reg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_result_core0_db0_reg_get_f) (
    int unit);

/**
 * \brief returns numeric data of result_core0_db1_reg
 * Module - 'mdb', Submodule - 'kaps', data - 'result_core0_db1_reg'
 * The LPM search interface result for core 0 db 1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     result_core0_db1_reg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_result_core0_db1_reg_get_f) (
    int unit);

/**
 * \brief returns numeric data of result_core1_db0_reg
 * Module - 'mdb', Submodule - 'kaps', data - 'result_core1_db0_reg'
 * The LPM search interface result for core 1 db 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     result_core1_db0_reg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_result_core1_db0_reg_get_f) (
    int unit);

/**
 * \brief returns numeric data of result_core1_db1_reg
 * Module - 'mdb', Submodule - 'kaps', data - 'result_core1_db1_reg'
 * The LPM search interface result for core 1 db 1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     result_core1_db1_reg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_result_core1_db1_reg_get_f) (
    int unit);

/**
 * \brief returns numeric data of big_kaps_revision_val
 * Module - 'mdb', Submodule - 'kaps', data - 'big_kaps_revision_val'
 * The big KAPS revision register value to pass on to the KBPSDK.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     big_kaps_revision_val - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_big_kaps_revision_val_get_f) (
    int unit);

/**
 * \brief get table big_bb_blk_id_mapping entry 
 * Mapping from KBPSDK blk_id to global_macro_index
 * 
 * \param [in] unit - unit #
 * \param [in] blk_id - The KBPSDK blk_id, first big BB blk_id is 0
 * 
 * \return
 *     big_bb_blk_id_mapping - returns the relevant entry values grouped in struct - see dnx_data_mdb_kaps_big_bb_blk_id_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_kaps_big_bb_blk_id_mapping_t *(
    *dnx_data_mdb_kaps_big_bb_blk_id_mapping_get_f) (
    int unit,
    int blk_id);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - KAPS:
 * {
 */
/**
 * \brief Interface for mdb kaps data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_kaps_feature_get_f feature_get;
    /**
     * returns define data of nof_small_bbs
     */
    dnx_data_mdb_kaps_nof_small_bbs_get_f nof_small_bbs_get;
    /**
     * returns define data of nof_big_bbs_blk_ids
     */
    dnx_data_mdb_kaps_nof_big_bbs_blk_ids_get_f nof_big_bbs_blk_ids_get;
    /**
     * returns define data of nof_rows_in_small_bb
     */
    dnx_data_mdb_kaps_nof_rows_in_small_bb_get_f nof_rows_in_small_bb_get;
    /**
     * returns define data of nof_rows_in_small_rpb_hitbits
     */
    dnx_data_mdb_kaps_nof_rows_in_small_rpb_hitbits_get_f nof_rows_in_small_rpb_hitbits_get;
    /**
     * returns define data of nof_bytes_in_hitbit_row
     */
    dnx_data_mdb_kaps_nof_bytes_in_hitbit_row_get_f nof_bytes_in_hitbit_row_get;
    /**
     * returns define data of key_lsn_bits
     */
    dnx_data_mdb_kaps_key_lsn_bits_get_f key_lsn_bits_get;
    /**
     * returns define data of key_prefix_length
     */
    dnx_data_mdb_kaps_key_prefix_length_get_f key_prefix_length_get;
    /**
     * returns define data of max_prefix_in_bb_row
     */
    dnx_data_mdb_kaps_max_prefix_in_bb_row_get_f max_prefix_in_bb_row_get;
    /**
     * returns define data of key_width_in_bits
     */
    dnx_data_mdb_kaps_key_width_in_bits_get_f key_width_in_bits_get;
    /**
     * returns define data of ad_width_in_bits
     */
    dnx_data_mdb_kaps_ad_width_in_bits_get_f ad_width_in_bits_get;
    /**
     * returns define data of bb_byte_width
     */
    dnx_data_mdb_kaps_bb_byte_width_get_f bb_byte_width_get;
    /**
     * returns define data of rpb_byte_width
     */
    dnx_data_mdb_kaps_rpb_byte_width_get_f rpb_byte_width_get;
    /**
     * returns define data of ads_byte_width
     */
    dnx_data_mdb_kaps_ads_byte_width_get_f ads_byte_width_get;
    /**
     * returns define data of rpb_valid_bits
     */
    dnx_data_mdb_kaps_rpb_valid_bits_get_f rpb_valid_bits_get;
    /**
     * returns define data of dynamic_memory_access_dpc
     */
    dnx_data_mdb_kaps_dynamic_memory_access_dpc_get_f dynamic_memory_access_dpc_get;
    /**
     * returns numeric data of rpb_field
     */
    dnx_data_mdb_kaps_rpb_field_get_f rpb_field_get;
    /**
     * returns numeric data of result_core0_db0_reg
     */
    dnx_data_mdb_kaps_result_core0_db0_reg_get_f result_core0_db0_reg_get;
    /**
     * returns numeric data of result_core0_db1_reg
     */
    dnx_data_mdb_kaps_result_core0_db1_reg_get_f result_core0_db1_reg_get;
    /**
     * returns numeric data of result_core1_db0_reg
     */
    dnx_data_mdb_kaps_result_core1_db0_reg_get_f result_core1_db0_reg_get;
    /**
     * returns numeric data of result_core1_db1_reg
     */
    dnx_data_mdb_kaps_result_core1_db1_reg_get_f result_core1_db1_reg_get;
    /**
     * returns numeric data of big_kaps_revision_val
     */
    dnx_data_mdb_kaps_big_kaps_revision_val_get_f big_kaps_revision_val_get;
    /**
     * get table big_bb_blk_id_mapping entry 
     */
    dnx_data_mdb_kaps_big_bb_blk_id_mapping_get_f big_bb_blk_id_mapping_get;
    /**
     * get general info table about table (for example key size)big_bb_blk_id_mapping info
     */
    dnxc_data_table_info_get_f big_bb_blk_id_mapping_info_get;
} dnx_data_if_mdb_kaps_t;

/*
 * }
 */

/*
 * SUBMODULE  - HW_BUG:
 * MDB related hw bug
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * step table fully support mix aspect ratio algorithm. HWJERICHO2-2156
     */
    dnx_data_mdb_hw_bug_step_table_supports_mix_ar_algo,
    /**
     * Unable to write to eedb after traffic has been sent through it. HWJERICHO2-2622
     */
    dnx_data_mdb_hw_bug_eedb_bank_traffic_lock,
    /**
     * EM overflow CAM DFG is disabled. HWJERICHO2-2208
     */
    dnx_data_mdb_hw_bug_em_dfg_ovf_cam_disabled,
    /**
     * EM MACT transplant does not generate reply. HWJERICHO2-2481
     */
    dnx_data_mdb_hw_bug_em_mact_transplant_no_reply,
    /**
     * EM MACT add entry should use refresh command instead of insert command. HWJERICHO2-2600
     */
    dnx_data_mdb_hw_bug_em_mact_use_refresh_on_insert,
    /**
     * EM MACT insert that exceeds limit returns fail_reason == FLUSH_DROP instead of EXCEED_LIMIT. HWJERICHO2-2581
     */
    dnx_data_mdb_hw_bug_em_mact_insert_flush_drop_on_exceed_limit,
    /**
     * EM interface shuts down SW interface to the ASIC until EM process ends. HWJERICHO2-2091
     */
    dnx_data_mdb_hw_bug_em_sbus_interface_shutdown,
    /**
     * EM simple command interface deadlocks in case it encounters an ECC error when DMA-mode is set. HWJERICHO2-2695
     */
    dnx_data_mdb_hw_bug_em_ecc_simple_command_deadlock,
    /**
     * EM compare init requires HW read. HWJERICHO2-2734
     */
    dnx_data_mdb_hw_bug_em_compare_init,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_hw_bug_feature_nof
} dnx_data_mdb_hw_bug_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_hw_bug_feature_get_f) (
    int unit,
    dnx_data_mdb_hw_bug_feature_e feature);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - HW_BUG:
 * {
 */
/**
 * \brief Interface for mdb hw_bug data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_hw_bug_feature_get_f feature_get;
} dnx_data_if_mdb_hw_bug_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_MDB:
 * {
 */
/**
 * \brief Interface for mdb data
 */
typedef struct
{
    /**
     * Interface for mdb global data
     */
    dnx_data_if_mdb_global_t global;
    /**
     * Interface for mdb dh data
     */
    dnx_data_if_mdb_dh_t dh;
    /**
     * Interface for mdb pdbs data
     */
    dnx_data_if_mdb_pdbs_t pdbs;
    /**
     * Interface for mdb em data
     */
    dnx_data_if_mdb_em_t em;
    /**
     * Interface for mdb direct data
     */
    dnx_data_if_mdb_direct_t direct;
    /**
     * Interface for mdb eedb data
     */
    dnx_data_if_mdb_eedb_t eedb;
    /**
     * Interface for mdb kaps data
     */
    dnx_data_if_mdb_kaps_t kaps;
    /**
     * Interface for mdb hw_bug data
     */
    dnx_data_if_mdb_hw_bug_t hw_bug;
} dnx_data_if_mdb_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_mdb_t dnx_data_mdb;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_MDB_H_*/
/* *INDENT-ON* */
