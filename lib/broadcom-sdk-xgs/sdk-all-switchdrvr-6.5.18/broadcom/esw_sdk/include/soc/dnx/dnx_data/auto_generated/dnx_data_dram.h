/** \file dnx_data_dram.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_DRAM_H_
/*{*/
#define _DNX_DATA_DRAM_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <bcm_int/dnx/dram/hbmc/hbmc.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_dram.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_dram
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_dram_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - HBM:
 * HBM parameters and defines
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule hbm table channel_symmetric_regs
 * Table info:
 * per channel list of symmetric registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_channel_symmetric_regs_t;

/**
 * \brief Holds values of submodule hbm table channel_not_symmetric_regs
 * Table info:
 * per channel list of not symmetric registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_channel_not_symmetric_regs_t;

/**
 * \brief Holds values of submodule hbm table controller_symmetric_regs
 * Table info:
 * per controller list of symmetric registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_controller_symmetric_regs_t;

/**
 * \brief Holds values of submodule hbm table controller_not_symmetric_regs
 * Table info:
 * per controller list of not symmetric registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_controller_not_symmetric_regs_t;

/**
 * \brief Holds values of submodule hbm table channel_interrupt_regs
 * Table info:
 * per channel list of interrupt registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_channel_interrupt_regs_t;

/**
 * \brief Holds values of submodule hbm table controller_interrupt_regs
 * Table info:
 * per controller list of interrupt registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_controller_interrupt_regs_t;

/**
 * \brief Holds values of submodule hbm table channel_debug_regs
 * Table info:
 * per channel list of debug registers - should be preented if value is not reset value
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
    /**
     * string to explain that this register's value is as expected (reset value)
     */
    char *reassuring_str;
} dnx_data_dram_hbm_channel_debug_regs_t;

/**
 * \brief Holds values of submodule hbm table channel_counter_regs
 * Table info:
 * per channel list of counter registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_channel_counter_regs_t;

/**
 * \brief Holds values of submodule hbm table channel_type_regs
 * Table info:
 * per channel list of registers that require per type printing
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
    /**
     * printing type
     */
    dnx_hbmc_diag_registers_type_t type;
} dnx_data_dram_hbm_channel_type_regs_t;

/**
 * \brief Holds values of submodule hbm table controller_info_regs
 * Table info:
 * per contorller list of info registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_controller_info_regs_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * hbm supported indication
     */
    dnx_data_dram_hbm_is_supported,
    /**
     * indication if dword alignemnt check is required for this architecture
     */
    dnx_data_dram_hbm_dword_alignment_check,
    /**
     * Indicates whether there is a 'low-temperature' forbidden range for HBM
     */
    dnx_data_dram_hbm_low_temperature_dram_protction,
    /**
     * Deleting dram buffers (marking them as faulty) is possible during 'init sequence'
     */
    dnx_data_dram_hbm_is_delete_bdb_supported,
    /**
     * Indication whether cpu2tap access to the HBM is supported
     */
    dnx_data_dram_hbm_cpu2tap_access,
    /**
     * Indication whether seamless commands to same bank control is supported
     */
    dnx_data_dram_hbm_seamless_commands_to_same_bank_control,

    /**
     * Must be last one!
     */
    _dnx_data_dram_hbm_feature_nof
} dnx_data_dram_hbm_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_hbm_feature_get_f) (
    int unit,
    dnx_data_dram_hbm_feature_e feature);

/**
 * \brief returns numeric data of burst_length
 * Module - 'dram', Submodule - 'hbm', data - 'burst_length'
 * burst length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     burst_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_burst_length_get_f) (
    int unit);

/**
 * \brief returns numeric data of stop_traffic_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'stop_traffic_temp_threshold'
 * temperature threshold (C degrees) above which the HBM should not recieve packets anymore
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stop_traffic_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_stop_traffic_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of stop_traffic_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'stop_traffic_low_temp_threshold'
 * Low temperature threshold (C degrees) below which the HBM should not recieve packets anymore
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stop_traffic_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_stop_traffic_low_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of restore_traffic_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'restore_traffic_temp_threshold'
 * temperature threshold (C degrees) below which the HBM should be reassigned to usage in the traffic flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     restore_traffic_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_restore_traffic_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of restore_traffic_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'restore_traffic_low_temp_threshold'
 * Low temperature threshold (C degrees) above which the HBM should be reassigned to usage in the traffic flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     restore_traffic_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_restore_traffic_low_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of usec_between_temp_samples
 * Module - 'dram', Submodule - 'hbm', data - 'usec_between_temp_samples'
 * time in usecs to wait between HBM temperature sampling
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     usec_between_temp_samples - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_usec_between_temp_samples_get_f) (
    int unit);

/**
 * \brief returns numeric data of power_down_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'power_down_temp_threshold'
 * temperature threshold, for doing DRAM shut down
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     power_down_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_power_down_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of power_down_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'power_down_low_temp_threshold'
 * Low temperature threshold, for doing DRAM shut down
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     power_down_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_power_down_low_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of dram_temp_monitor_enable
 * Module - 'dram', Submodule - 'hbm', data - 'dram_temp_monitor_enable'
 * enable/disable driver temperature monitoring
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_temp_monitor_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_dram_temp_monitor_enable_get_f) (
    int unit);

/**
 * \brief returns define data of channel_broadcast_id
 * Module - 'dram', Submodule - 'hbm', data - 'channel_broadcast_id'
 * channel id to use in dbal when trying to broadcast
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_broadcast_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_channel_broadcast_id_get_f) (
    int unit);

/**
 * \brief returns define data of hbc_physical_last_in_chain
 * Module - 'dram', Submodule - 'hbm', data - 'hbc_physical_last_in_chain'
 * block index of the physically last in chain hbc, provided all hbms are active
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbc_physical_last_in_chain - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_hbc_physical_last_in_chain_get_f) (
    int unit);

/**
 * \brief returns define data of default_model_part_num
 * Module - 'dram', Submodule - 'hbm', data - 'default_model_part_num'
 * default model part number
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_model_part_num - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_default_model_part_num_get_f) (
    int unit);

/**
 * \brief get table channel_symmetric_regs entry 
 * per channel list of symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_symmetric_regs_t *(
    *dnx_data_dram_hbm_channel_symmetric_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_not_symmetric_regs entry 
 * per channel list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_not_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_not_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_not_symmetric_regs_t *(
    *dnx_data_dram_hbm_channel_not_symmetric_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_symmetric_regs entry 
 * per controller list of symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_controller_symmetric_regs_t *(
    *dnx_data_dram_hbm_controller_symmetric_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_not_symmetric_regs entry 
 * per controller list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_not_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_not_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_controller_not_symmetric_regs_t *(
    *dnx_data_dram_hbm_controller_not_symmetric_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_interrupt_regs entry 
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_interrupt_regs_t *(
    *dnx_data_dram_hbm_channel_interrupt_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_interrupt_regs entry 
 * per controller list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_controller_interrupt_regs_t *(
    *dnx_data_dram_hbm_controller_interrupt_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_debug_regs entry 
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_debug_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_debug_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_debug_regs_t *(
    *dnx_data_dram_hbm_channel_debug_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_counter_regs entry 
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_counter_regs_t *(
    *dnx_data_dram_hbm_channel_counter_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_type_regs entry 
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_type_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_type_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_type_regs_t *(
    *dnx_data_dram_hbm_channel_type_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_info_regs entry 
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_info_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_info_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_controller_info_regs_t *(
    *dnx_data_dram_hbm_controller_info_regs_get_f) (
    int unit,
    int index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - HBM:
 * {
 */
/**
 * \brief Interface for dram hbm data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_hbm_feature_get_f feature_get;
    /**
     * returns numeric data of burst_length
     */
    dnx_data_dram_hbm_burst_length_get_f burst_length_get;
    /**
     * returns numeric data of stop_traffic_temp_threshold
     */
    dnx_data_dram_hbm_stop_traffic_temp_threshold_get_f stop_traffic_temp_threshold_get;
    /**
     * returns numeric data of stop_traffic_low_temp_threshold
     */
    dnx_data_dram_hbm_stop_traffic_low_temp_threshold_get_f stop_traffic_low_temp_threshold_get;
    /**
     * returns numeric data of restore_traffic_temp_threshold
     */
    dnx_data_dram_hbm_restore_traffic_temp_threshold_get_f restore_traffic_temp_threshold_get;
    /**
     * returns numeric data of restore_traffic_low_temp_threshold
     */
    dnx_data_dram_hbm_restore_traffic_low_temp_threshold_get_f restore_traffic_low_temp_threshold_get;
    /**
     * returns numeric data of usec_between_temp_samples
     */
    dnx_data_dram_hbm_usec_between_temp_samples_get_f usec_between_temp_samples_get;
    /**
     * returns numeric data of power_down_temp_threshold
     */
    dnx_data_dram_hbm_power_down_temp_threshold_get_f power_down_temp_threshold_get;
    /**
     * returns numeric data of power_down_low_temp_threshold
     */
    dnx_data_dram_hbm_power_down_low_temp_threshold_get_f power_down_low_temp_threshold_get;
    /**
     * returns numeric data of dram_temp_monitor_enable
     */
    dnx_data_dram_hbm_dram_temp_monitor_enable_get_f dram_temp_monitor_enable_get;
    /**
     * returns define data of channel_broadcast_id
     */
    dnx_data_dram_hbm_channel_broadcast_id_get_f channel_broadcast_id_get;
    /**
     * returns define data of hbc_physical_last_in_chain
     */
    dnx_data_dram_hbm_hbc_physical_last_in_chain_get_f hbc_physical_last_in_chain_get;
    /**
     * returns define data of default_model_part_num
     */
    dnx_data_dram_hbm_default_model_part_num_get_f default_model_part_num_get;
    /**
     * get table channel_symmetric_regs entry 
     */
    dnx_data_dram_hbm_channel_symmetric_regs_get_f channel_symmetric_regs_get;
    /**
     * get general info table about table (for example key size)channel_symmetric_regs info
     */
    dnxc_data_table_info_get_f channel_symmetric_regs_info_get;
    /**
     * get table channel_not_symmetric_regs entry 
     */
    dnx_data_dram_hbm_channel_not_symmetric_regs_get_f channel_not_symmetric_regs_get;
    /**
     * get general info table about table (for example key size)channel_not_symmetric_regs info
     */
    dnxc_data_table_info_get_f channel_not_symmetric_regs_info_get;
    /**
     * get table controller_symmetric_regs entry 
     */
    dnx_data_dram_hbm_controller_symmetric_regs_get_f controller_symmetric_regs_get;
    /**
     * get general info table about table (for example key size)controller_symmetric_regs info
     */
    dnxc_data_table_info_get_f controller_symmetric_regs_info_get;
    /**
     * get table controller_not_symmetric_regs entry 
     */
    dnx_data_dram_hbm_controller_not_symmetric_regs_get_f controller_not_symmetric_regs_get;
    /**
     * get general info table about table (for example key size)controller_not_symmetric_regs info
     */
    dnxc_data_table_info_get_f controller_not_symmetric_regs_info_get;
    /**
     * get table channel_interrupt_regs entry 
     */
    dnx_data_dram_hbm_channel_interrupt_regs_get_f channel_interrupt_regs_get;
    /**
     * get general info table about table (for example key size)channel_interrupt_regs info
     */
    dnxc_data_table_info_get_f channel_interrupt_regs_info_get;
    /**
     * get table controller_interrupt_regs entry 
     */
    dnx_data_dram_hbm_controller_interrupt_regs_get_f controller_interrupt_regs_get;
    /**
     * get general info table about table (for example key size)controller_interrupt_regs info
     */
    dnxc_data_table_info_get_f controller_interrupt_regs_info_get;
    /**
     * get table channel_debug_regs entry 
     */
    dnx_data_dram_hbm_channel_debug_regs_get_f channel_debug_regs_get;
    /**
     * get general info table about table (for example key size)channel_debug_regs info
     */
    dnxc_data_table_info_get_f channel_debug_regs_info_get;
    /**
     * get table channel_counter_regs entry 
     */
    dnx_data_dram_hbm_channel_counter_regs_get_f channel_counter_regs_get;
    /**
     * get general info table about table (for example key size)channel_counter_regs info
     */
    dnxc_data_table_info_get_f channel_counter_regs_info_get;
    /**
     * get table channel_type_regs entry 
     */
    dnx_data_dram_hbm_channel_type_regs_get_f channel_type_regs_get;
    /**
     * get general info table about table (for example key size)channel_type_regs info
     */
    dnxc_data_table_info_get_f channel_type_regs_info_get;
    /**
     * get table controller_info_regs entry 
     */
    dnx_data_dram_hbm_controller_info_regs_get_f controller_info_regs_get;
    /**
     * get general info table about table (for example key size)controller_info_regs info
     */
    dnxc_data_table_info_get_f controller_info_regs_info_get;
} dnx_data_if_dram_hbm_t;

/*
 * }
 */

/*
 * SUBMODULE  - GDDR6:
 * GDDR6 parameters and defines
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule gddr6 table refresh_intervals
 * Table info:
 * refresh intervals timing parameters
 */
typedef struct
{
    /**
     * trefiab timing parameters
     */
    uint32 trefiab;
    /**
     * trefiab_acc timing parameters
     */
    uint32 trefiab_acc;
    /**
     * trefisb timing parameters
     */
    uint32 trefisb;
} dnx_data_dram_gddr6_refresh_intervals_t;

/**
 * \brief Holds values of submodule gddr6 table dq_map
 * Table info:
 * DQ swap mapping on boards
 */
typedef struct
{
    /**
     * dq map
     */
    uint8 dq_map[8];
} dnx_data_dram_gddr6_dq_map_t;

/**
 * \brief Holds values of submodule gddr6 table dq_channel_swap
 * Table info:
 * DQ channel swap mapping on boards
 */
typedef struct
{
    /**
     * dq map
     */
    uint8 dq_channel_swap;
} dnx_data_dram_gddr6_dq_channel_swap_t;

/**
 * \brief Holds values of submodule gddr6 table dq_byte_map
 * Table info:
 * DQ bytes swap mapping on boards
 */
typedef struct
{
    /**
     * dq byte map
     */
    uint8 dq_byte_map;
} dnx_data_dram_gddr6_dq_byte_map_t;

/**
 * \brief Holds values of submodule gddr6 table ca_map
 * Table info:
 * command address bit swap mapping on boards
 */
typedef struct
{
    /**
     * ca map
     */
    uint8 ca_map[12];
} dnx_data_dram_gddr6_ca_map_t;

/**
 * \brief Holds values of submodule gddr6 table cadt_byte_map
 * Table info:
 * bytes swapping on boards
 */
typedef struct
{
    /**
     * cadt byte map
     */
    uint8 cadt_byte_map;
} dnx_data_dram_gddr6_cadt_byte_map_t;

/**
 * \brief Holds values of submodule gddr6 table channel_regs
 * Table info:
 * per channel list of registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_channel_regs_t;

/**
 * \brief Holds values of submodule gddr6 table controller_regs
 * Table info:
 * per phy controller list of registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_controller_regs_t;

/**
 * \brief Holds values of submodule gddr6 table channel_interrupt_regs
 * Table info:
 * per channel list of interrupt registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_channel_interrupt_regs_t;

/**
 * \brief Holds values of submodule gddr6 table controller_interrupt_regs
 * Table info:
 * per phy list of interrupt registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_controller_interrupt_regs_t;

/**
 * \brief Holds values of submodule gddr6 table channel_debug_regs
 * Table info:
 * per channel list of debug registers - should be preented if value is not reset value
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
    /**
     * string to explain that this register's value is as expected (reset value)
     */
    char *reassuring_str;
} dnx_data_dram_gddr6_channel_debug_regs_t;

/**
 * \brief Holds values of submodule gddr6 table channel_counter_regs
 * Table info:
 * per channel list of counter registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_channel_counter_regs_t;

/**
 * \brief Holds values of submodule gddr6 table channel_type_regs
 * Table info:
 * per channel list of registers that require per type printing
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
    /**
     * printing type
     */
    dnx_hbmc_diag_registers_type_t type;
} dnx_data_dram_gddr6_channel_type_regs_t;

/**
 * \brief Holds values of submodule gddr6 table controller_info_regs
 * Table info:
 * per contorller list of info registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_controller_info_regs_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * gddr supported indication
     */
    dnx_data_dram_gddr6_is_supported,
    /**
     * allow disabling read crc
     */
    dnx_data_dram_gddr6_allow_disable_read_crc,
    /**
     * allow per bank and all banks refresh to be interleaved
     */
    dnx_data_dram_gddr6_interleaved_refresh_cycles,
    /**
     * allow wait for Wr/Rd swith to perform AB refresh
     */
    dnx_data_dram_gddr6_refresh_pend_switch,
    /**
     * Indication whether dynamic calibration is supported
     */
    dnx_data_dram_gddr6_dynamic_calibration,

    /**
     * Must be last one!
     */
    _dnx_data_dram_gddr6_feature_nof
} dnx_data_dram_gddr6_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_gddr6_feature_get_f) (
    int unit,
    dnx_data_dram_gddr6_feature_e feature);

/**
 * \brief returns define data of nof_ca_bits
 * Module - 'dram', Submodule - 'gddr6', data - 'nof_ca_bits'
 * number of command address bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ca_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_nof_ca_bits_get_f) (
    int unit);

/**
 * \brief returns define data of bytes_per_channel
 * Module - 'dram', Submodule - 'gddr6', data - 'bytes_per_channel'
 * bytes per channel in GDDR6 dram
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bytes_per_channel - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_bytes_per_channel_get_f) (
    int unit);

/**
 * \brief returns define data of training_fifo_depth
 * Module - 'dram', Submodule - 'gddr6', data - 'training_fifo_depth'
 * the depth of the training fifo in GDDR6 dram
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     training_fifo_depth - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_training_fifo_depth_get_f) (
    int unit);

/**
 * \brief returns numeric data of refresh_mechanism_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'refresh_mechanism_enable'
 * TSM refresh mechanism enable
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_mechanism_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_refresh_mechanism_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of bist_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'bist_enable'
 * DRAM bist enable
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bist_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_bist_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of write_recovery
 * Module - 'dram', Submodule - 'gddr6', data - 'write_recovery'
 * write recovery
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     write_recovery - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_write_recovery_get_f) (
    int unit);

/**
 * \brief returns numeric data of cabi
 * Module - 'dram', Submodule - 'gddr6', data - 'cabi'
 * enable cabi
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cabi - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_cabi_get_f) (
    int unit);

/**
 * \brief returns numeric data of dram_mode
 * Module - 'dram', Submodule - 'gddr6', data - 'dram_mode'
 * dram mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_dram_mode_get_f) (
    int unit);

/**
 * \brief returns numeric data of cal_termination
 * Module - 'dram', Submodule - 'gddr6', data - 'cal_termination'
 * CAL Termination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_termination - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_cal_termination_get_f) (
    int unit);

/**
 * \brief returns numeric data of cah_termination
 * Module - 'dram', Submodule - 'gddr6', data - 'cah_termination'
 * CAH Termination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cah_termination - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_cah_termination_get_f) (
    int unit);

/**
 * \brief returns numeric data of command_pipe_extra_delay
 * Module - 'dram', Submodule - 'gddr6', data - 'command_pipe_extra_delay'
 * command pipe extra delay
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_pipe_extra_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_command_pipe_extra_delay_get_f) (
    int unit);

/**
 * \brief returns numeric data of use_11bits_ca
 * Module - 'dram', Submodule - 'gddr6', data - 'use_11bits_ca'
 * use 11bits for command address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     use_11bits_ca - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_use_11bits_ca_get_f) (
    int unit);

/**
 * \brief returns numeric data of ck_odt
 * Module - 'dram', Submodule - 'gddr6', data - 'ck_odt'
 * CK ODT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ck_odt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_ck_odt_get_f) (
    int unit);

/**
 * \brief returns numeric data of dynamic_calibration_period
 * Module - 'dram', Submodule - 'gddr6', data - 'dynamic_calibration_period'
 * time between 2 iterations of dynamic calibration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dynamic_calibration_period - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_dynamic_calibration_period_get_f) (
    int unit);

/**
 * \brief get table refresh_intervals entry 
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_intervals - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_refresh_intervals_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_refresh_intervals_t *(
    *dnx_data_dram_gddr6_refresh_intervals_get_f) (
    int unit);

/**
 * \brief get table dq_map entry 
 * DQ swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] byte - bit on dram
 * 
 * \return
 *     dq_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_dq_map_t *(
    *dnx_data_dram_gddr6_dq_map_get_f) (
    int unit,
    int dram_index,
    int byte);

/**
 * \brief get table dq_channel_swap entry 
 * DQ channel swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * 
 * \return
 *     dq_channel_swap - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_channel_swap_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_dq_channel_swap_t *(
    *dnx_data_dram_gddr6_dq_channel_swap_get_f) (
    int unit,
    int dram_index);

/**
 * \brief get table dq_byte_map entry 
 * DQ bytes swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] byte - byte on dram
 * 
 * \return
 *     dq_byte_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_byte_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_dq_byte_map_t *(
    *dnx_data_dram_gddr6_dq_byte_map_get_f) (
    int unit,
    int dram_index,
    int byte);

/**
 * \brief get table ca_map entry 
 * command address bit swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] channel - command address bit
 * 
 * \return
 *     ca_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_ca_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_ca_map_t *(
    *dnx_data_dram_gddr6_ca_map_get_f) (
    int unit,
    int dram_index,
    int channel);

/**
 * \brief get table cadt_byte_map entry 
 * bytes swapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] channel - dram controller channel
 * 
 * \return
 *     cadt_byte_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_cadt_byte_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_cadt_byte_map_t *(
    *dnx_data_dram_gddr6_cadt_byte_map_get_f) (
    int unit,
    int dram_index,
    int channel);

/**
 * \brief get table channel_regs entry 
 * per channel list of registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_channel_regs_t *(
    *dnx_data_dram_gddr6_channel_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_regs entry 
 * per phy controller list of registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_controller_regs_t *(
    *dnx_data_dram_gddr6_controller_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_interrupt_regs entry 
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_channel_interrupt_regs_t *(
    *dnx_data_dram_gddr6_channel_interrupt_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_interrupt_regs entry 
 * per phy list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_controller_interrupt_regs_t *(
    *dnx_data_dram_gddr6_controller_interrupt_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_debug_regs entry 
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_debug_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_debug_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_channel_debug_regs_t *(
    *dnx_data_dram_gddr6_channel_debug_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_counter_regs entry 
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_channel_counter_regs_t *(
    *dnx_data_dram_gddr6_channel_counter_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_type_regs entry 
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_type_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_type_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_channel_type_regs_t *(
    *dnx_data_dram_gddr6_channel_type_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_info_regs entry 
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_info_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_info_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_controller_info_regs_t *(
    *dnx_data_dram_gddr6_controller_info_regs_get_f) (
    int unit,
    int index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - GDDR6:
 * {
 */
/**
 * \brief Interface for dram gddr6 data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_gddr6_feature_get_f feature_get;
    /**
     * returns define data of nof_ca_bits
     */
    dnx_data_dram_gddr6_nof_ca_bits_get_f nof_ca_bits_get;
    /**
     * returns define data of bytes_per_channel
     */
    dnx_data_dram_gddr6_bytes_per_channel_get_f bytes_per_channel_get;
    /**
     * returns define data of training_fifo_depth
     */
    dnx_data_dram_gddr6_training_fifo_depth_get_f training_fifo_depth_get;
    /**
     * returns numeric data of refresh_mechanism_enable
     */
    dnx_data_dram_gddr6_refresh_mechanism_enable_get_f refresh_mechanism_enable_get;
    /**
     * returns numeric data of bist_enable
     */
    dnx_data_dram_gddr6_bist_enable_get_f bist_enable_get;
    /**
     * returns numeric data of write_recovery
     */
    dnx_data_dram_gddr6_write_recovery_get_f write_recovery_get;
    /**
     * returns numeric data of cabi
     */
    dnx_data_dram_gddr6_cabi_get_f cabi_get;
    /**
     * returns numeric data of dram_mode
     */
    dnx_data_dram_gddr6_dram_mode_get_f dram_mode_get;
    /**
     * returns numeric data of cal_termination
     */
    dnx_data_dram_gddr6_cal_termination_get_f cal_termination_get;
    /**
     * returns numeric data of cah_termination
     */
    dnx_data_dram_gddr6_cah_termination_get_f cah_termination_get;
    /**
     * returns numeric data of command_pipe_extra_delay
     */
    dnx_data_dram_gddr6_command_pipe_extra_delay_get_f command_pipe_extra_delay_get;
    /**
     * returns numeric data of use_11bits_ca
     */
    dnx_data_dram_gddr6_use_11bits_ca_get_f use_11bits_ca_get;
    /**
     * returns numeric data of ck_odt
     */
    dnx_data_dram_gddr6_ck_odt_get_f ck_odt_get;
    /**
     * returns numeric data of dynamic_calibration_period
     */
    dnx_data_dram_gddr6_dynamic_calibration_period_get_f dynamic_calibration_period_get;
    /**
     * get table refresh_intervals entry 
     */
    dnx_data_dram_gddr6_refresh_intervals_get_f refresh_intervals_get;
    /**
     * get general info table about table (for example key size)refresh_intervals info
     */
    dnxc_data_table_info_get_f refresh_intervals_info_get;
    /**
     * get table dq_map entry 
     */
    dnx_data_dram_gddr6_dq_map_get_f dq_map_get;
    /**
     * get general info table about table (for example key size)dq_map info
     */
    dnxc_data_table_info_get_f dq_map_info_get;
    /**
     * get table dq_channel_swap entry 
     */
    dnx_data_dram_gddr6_dq_channel_swap_get_f dq_channel_swap_get;
    /**
     * get general info table about table (for example key size)dq_channel_swap info
     */
    dnxc_data_table_info_get_f dq_channel_swap_info_get;
    /**
     * get table dq_byte_map entry 
     */
    dnx_data_dram_gddr6_dq_byte_map_get_f dq_byte_map_get;
    /**
     * get general info table about table (for example key size)dq_byte_map info
     */
    dnxc_data_table_info_get_f dq_byte_map_info_get;
    /**
     * get table ca_map entry 
     */
    dnx_data_dram_gddr6_ca_map_get_f ca_map_get;
    /**
     * get general info table about table (for example key size)ca_map info
     */
    dnxc_data_table_info_get_f ca_map_info_get;
    /**
     * get table cadt_byte_map entry 
     */
    dnx_data_dram_gddr6_cadt_byte_map_get_f cadt_byte_map_get;
    /**
     * get general info table about table (for example key size)cadt_byte_map info
     */
    dnxc_data_table_info_get_f cadt_byte_map_info_get;
    /**
     * get table channel_regs entry 
     */
    dnx_data_dram_gddr6_channel_regs_get_f channel_regs_get;
    /**
     * get general info table about table (for example key size)channel_regs info
     */
    dnxc_data_table_info_get_f channel_regs_info_get;
    /**
     * get table controller_regs entry 
     */
    dnx_data_dram_gddr6_controller_regs_get_f controller_regs_get;
    /**
     * get general info table about table (for example key size)controller_regs info
     */
    dnxc_data_table_info_get_f controller_regs_info_get;
    /**
     * get table channel_interrupt_regs entry 
     */
    dnx_data_dram_gddr6_channel_interrupt_regs_get_f channel_interrupt_regs_get;
    /**
     * get general info table about table (for example key size)channel_interrupt_regs info
     */
    dnxc_data_table_info_get_f channel_interrupt_regs_info_get;
    /**
     * get table controller_interrupt_regs entry 
     */
    dnx_data_dram_gddr6_controller_interrupt_regs_get_f controller_interrupt_regs_get;
    /**
     * get general info table about table (for example key size)controller_interrupt_regs info
     */
    dnxc_data_table_info_get_f controller_interrupt_regs_info_get;
    /**
     * get table channel_debug_regs entry 
     */
    dnx_data_dram_gddr6_channel_debug_regs_get_f channel_debug_regs_get;
    /**
     * get general info table about table (for example key size)channel_debug_regs info
     */
    dnxc_data_table_info_get_f channel_debug_regs_info_get;
    /**
     * get table channel_counter_regs entry 
     */
    dnx_data_dram_gddr6_channel_counter_regs_get_f channel_counter_regs_get;
    /**
     * get general info table about table (for example key size)channel_counter_regs info
     */
    dnxc_data_table_info_get_f channel_counter_regs_info_get;
    /**
     * get table channel_type_regs entry 
     */
    dnx_data_dram_gddr6_channel_type_regs_get_f channel_type_regs_get;
    /**
     * get general info table about table (for example key size)channel_type_regs info
     */
    dnxc_data_table_info_get_f channel_type_regs_info_get;
    /**
     * get table controller_info_regs entry 
     */
    dnx_data_dram_gddr6_controller_info_regs_get_f controller_info_regs_get;
    /**
     * get general info table about table (for example key size)controller_info_regs info
     */
    dnxc_data_table_info_get_f controller_info_regs_info_get;
} dnx_data_if_dram_gddr6_t;

/*
 * }
 */

/*
 * SUBMODULE  - GENERAL_INFO:
 * general info derived from defaults or soc properties which is relevant also for other types of drams, not only to HBM
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule general_info table mr_defaults
 * Table info:
 * mode registers default values
 */
typedef struct
{
    /**
     * default value for mode register
     */
    uint32 value;
} dnx_data_dram_general_info_mr_defaults_t;

/**
 * \brief Holds values of submodule general_info table dram_info
 * Table info:
 * general information regarding the dram in the system
 */
typedef struct
{
    /**
     * dram type as defined by tuning infrastructure
     */
    uint32 dram_type;
    /**
     * bitmap of currently available drams
     */
    uint32 dram_bitmap;
    /**
     * number of columns in the dram
     */
    uint32 nof_columns;
    /**
     * number of rows in the dram
     */
    uint32 nof_rows;
    /**
     * number of banks in the dram
     */
    uint32 nof_banks;
    /**
     * (in MHZ)data rate in mbps, in DDRs equal 2 * frequency
     */
    uint32 data_rate;
    /**
     * ref clock for the dram phy
     */
    uint32 ref_clock;
    /**
     * shmoo input - which actions to perform
     */
    uint32 ctl_type;
} dnx_data_dram_general_info_dram_info_t;

/**
 * \brief Holds values of submodule general_info table timing_params
 * Table info:
 * timing parameters
 */
typedef struct
{
    /**
     * twr timing parameter
     */
    uint32 twr;
    /**
     * trp timing parameter
     */
    uint32 trp;
    /**
     * trtps timing parameter
     */
    uint32 trtps;
    /**
     * trtpl timing parameter
     */
    uint32 trtpl;
    /**
     * trrds timing parameter
     */
    uint32 trrds;
    /**
     * trrdl timing parameter
     */
    uint32 trrdl;
    /**
     * tfaw timing parameter
     */
    uint32 tfaw;
    /**
     * trcdwr timing parameter
     */
    uint32 trcdwr;
    /**
     * trcdrd timing parameter
     */
    uint32 trcdrd;
    /**
     * tras timing parameter
     */
    uint32 tras;
    /**
     * trc timing parameter
     */
    uint32 trc;
    /**
     * twtrl timing parameter
     */
    uint32 twtrl;
    /**
     * twtrs timing parameter
     */
    uint32 twtrs;
    /**
     * trtw timing parameter
     */
    uint32 trtw;
    /**
     * tccdr timing parameter
     */
    uint32 tccdr;
    /**
     * tccds timing parameter
     */
    uint32 tccds;
    /**
     * tccdl timing parameter
     */
    uint32 tccdl;
    /**
     * trrefd timing parameter
     */
    uint32 trrefd;
    /**
     * trfcsb timing parameter
     */
    uint32 trfcsb;
    /**
     * trfc timing parameter
     */
    uint32 trfc;
    /**
     * tmrd timing parameter
     */
    uint32 tmrd;
    /**
     * tmod timing parameter
     */
    uint32 tmod;
    /**
     * twtrtr timing parameter
     */
    uint32 twtrtr;
    /**
     * twrwtr timing parameter
     */
    uint32 twrwtr;
    /**
     * treftr timing parameter
     */
    uint32 treftr;
    /**
     * trdtlt timing parameter
     */
    uint32 trdtlt;
    /**
     * trcdwtr timing parameter
     */
    uint32 trcdwtr;
    /**
     * trcdrtr timing parameter
     */
    uint32 trcdrtr;
    /**
     * trcdltr timing parameter
     */
    uint32 trcdltr;
    /**
     * tltrtr timing parameter
     */
    uint32 tltrtr;
    /**
     * tltltr timing parameter
     */
    uint32 tltltr;
} dnx_data_dram_general_info_timing_params_t;

/**
 * \brief Holds values of submodule general_info table refresh_intervals
 * Table info:
 * refresh intervals timing parameters
 */
typedef struct
{
    /**
     * trefi timing parameters
     */
    uint32 trefi;
    /**
     * trefisb timing parameters
     */
    uint32 trefisb;
} dnx_data_dram_general_info_refresh_intervals_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_general_info_feature_nof
} dnx_data_dram_general_info_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_general_info_feature_get_f) (
    int unit,
    dnx_data_dram_general_info_feature_e feature);

/**
 * \brief returns define data of otp_restore_version
 * Module - 'dram', Submodule - 'general_info', data - 'otp_restore_version'
 * when restoring from OTP the tune data, do it according to the given version format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     otp_restore_version - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_otp_restore_version_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_drams
 * Module - 'dram', Submodule - 'general_info', data - 'max_nof_drams'
 * max number of drams supported for this device - in other words the size of the dram bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_drams - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_max_nof_drams_get_f) (
    int unit);

/**
 * \brief returns define data of nof_channels
 * Module - 'dram', Submodule - 'general_info', data - 'nof_channels'
 * max number of dram channels supported for this device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_channels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_nof_channels_get_f) (
    int unit);

/**
 * \brief returns define data of mr_mask
 * Module - 'dram', Submodule - 'general_info', data - 'mr_mask'
 * mode register bit mask
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mr_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_mr_mask_get_f) (
    int unit);

/**
 * \brief returns define data of nof_mrs
 * Module - 'dram', Submodule - 'general_info', data - 'nof_mrs'
 * number of mode registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mrs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_nof_mrs_get_f) (
    int unit);

/**
 * \brief returns define data of phy_address_mask
 * Module - 'dram', Submodule - 'general_info', data - 'phy_address_mask'
 * bit mask to describe the relevant bits in phy register address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_address_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_phy_address_mask_get_f) (
    int unit);

/**
 * \brief returns numeric data of max_dram_index
 * Module - 'dram', Submodule - 'general_info', data - 'max_dram_index'
 * max dram index from bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_dram_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_max_dram_index_get_f) (
    int unit);

/**
 * \brief returns numeric data of min_dram_index
 * Module - 'dram', Submodule - 'general_info', data - 'min_dram_index'
 * min dram index from bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_dram_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_min_dram_index_get_f) (
    int unit);

/**
 * \brief returns numeric data of frequency
 * Module - 'dram', Submodule - 'general_info', data - 'frequency'
 * dram frequency (in MHZ), used to calculated data_rate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     frequency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_frequency_get_f) (
    int unit);

/**
 * \brief returns numeric data of buffer_size
 * Module - 'dram', Submodule - 'general_info', data - 'buffer_size'
 * dram buffer size in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     buffer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_buffer_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of command_address_parity
 * Module - 'dram', Submodule - 'general_info', data - 'command_address_parity'
 * command address parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_address_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_command_address_parity_get_f) (
    int unit);

/**
 * \brief returns numeric data of dq_write_parity
 * Module - 'dram', Submodule - 'general_info', data - 'dq_write_parity'
 * dq write parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_write_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_dq_write_parity_get_f) (
    int unit);

/**
 * \brief returns numeric data of dq_read_parity
 * Module - 'dram', Submodule - 'general_info', data - 'dq_read_parity'
 * dq read parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_read_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_dq_read_parity_get_f) (
    int unit);

/**
 * \brief returns numeric data of dbi_read
 * Module - 'dram', Submodule - 'general_info', data - 'dbi_read'
 * dbi read
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbi_read - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_dbi_read_get_f) (
    int unit);

/**
 * \brief returns numeric data of dbi_write
 * Module - 'dram', Submodule - 'general_info', data - 'dbi_write'
 * dbi write
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbi_write - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_dbi_write_get_f) (
    int unit);

/**
 * \brief returns numeric data of write_latency
 * Module - 'dram', Submodule - 'general_info', data - 'write_latency'
 * write latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     write_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_write_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of read_latency
 * Module - 'dram', Submodule - 'general_info', data - 'read_latency'
 * read latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     read_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_read_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'parity_latency'
 * parity latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_parity_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of actual_parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'actual_parity_latency'
 * parity latency to be used after factoring in the effect of other numerics
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     actual_parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_actual_parity_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of tune_mode_on_init
 * Module - 'dram', Submodule - 'general_info', data - 'tune_mode_on_init'
 * tune mode during init sequence
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tune_mode_on_init - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_tune_mode_on_init_get_f) (
    int unit);

/**
 * \brief returns numeric data of command_parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'command_parity_latency'
 * command parity latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_command_parity_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of crc_write_latency
 * Module - 'dram', Submodule - 'general_info', data - 'crc_write_latency'
 * crc write latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_write_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_crc_write_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of crc_read_latency
 * Module - 'dram', Submodule - 'general_info', data - 'crc_read_latency'
 * crc read latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_read_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_crc_read_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of crc_write
 * Module - 'dram', Submodule - 'general_info', data - 'crc_write'
 * write crc
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_write - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_crc_write_get_f) (
    int unit);

/**
 * \brief returns numeric data of crc_read
 * Module - 'dram', Submodule - 'general_info', data - 'crc_read'
 * read crc
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_read - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_crc_read_get_f) (
    int unit);

/**
 * \brief returns numeric data of device_size
 * Module - 'dram', Submodule - 'general_info', data - 'device_size'
 * device size for each dram die
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     device_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_device_size_get_f) (
    int unit);

/**
 * \brief get table mr_defaults entry 
 * mode registers default values
 * 
 * \param [in] unit - unit #
 * \param [in] index - mode register index
 * 
 * \return
 *     mr_defaults - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_mr_defaults_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_general_info_mr_defaults_t *(
    *dnx_data_dram_general_info_mr_defaults_get_f) (
    int unit,
    int index);

/**
 * \brief get table dram_info entry 
 * general information regarding the dram in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_info - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_dram_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_general_info_dram_info_t *(
    *dnx_data_dram_general_info_dram_info_get_f) (
    int unit);

/**
 * \brief get table timing_params entry 
 * timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     timing_params - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_timing_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_general_info_timing_params_t *(
    *dnx_data_dram_general_info_timing_params_get_f) (
    int unit);

/**
 * \brief get table refresh_intervals entry 
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * \param [in] temp_index - temperature index
 * 
 * \return
 *     refresh_intervals - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_refresh_intervals_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_general_info_refresh_intervals_t *(
    *dnx_data_dram_general_info_refresh_intervals_get_f) (
    int unit,
    int temp_index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - GENERAL_INFO:
 * {
 */
/**
 * \brief Interface for dram general_info data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_general_info_feature_get_f feature_get;
    /**
     * returns define data of otp_restore_version
     */
    dnx_data_dram_general_info_otp_restore_version_get_f otp_restore_version_get;
    /**
     * returns define data of max_nof_drams
     */
    dnx_data_dram_general_info_max_nof_drams_get_f max_nof_drams_get;
    /**
     * returns define data of nof_channels
     */
    dnx_data_dram_general_info_nof_channels_get_f nof_channels_get;
    /**
     * returns define data of mr_mask
     */
    dnx_data_dram_general_info_mr_mask_get_f mr_mask_get;
    /**
     * returns define data of nof_mrs
     */
    dnx_data_dram_general_info_nof_mrs_get_f nof_mrs_get;
    /**
     * returns define data of phy_address_mask
     */
    dnx_data_dram_general_info_phy_address_mask_get_f phy_address_mask_get;
    /**
     * returns numeric data of max_dram_index
     */
    dnx_data_dram_general_info_max_dram_index_get_f max_dram_index_get;
    /**
     * returns numeric data of min_dram_index
     */
    dnx_data_dram_general_info_min_dram_index_get_f min_dram_index_get;
    /**
     * returns numeric data of frequency
     */
    dnx_data_dram_general_info_frequency_get_f frequency_get;
    /**
     * returns numeric data of buffer_size
     */
    dnx_data_dram_general_info_buffer_size_get_f buffer_size_get;
    /**
     * returns numeric data of command_address_parity
     */
    dnx_data_dram_general_info_command_address_parity_get_f command_address_parity_get;
    /**
     * returns numeric data of dq_write_parity
     */
    dnx_data_dram_general_info_dq_write_parity_get_f dq_write_parity_get;
    /**
     * returns numeric data of dq_read_parity
     */
    dnx_data_dram_general_info_dq_read_parity_get_f dq_read_parity_get;
    /**
     * returns numeric data of dbi_read
     */
    dnx_data_dram_general_info_dbi_read_get_f dbi_read_get;
    /**
     * returns numeric data of dbi_write
     */
    dnx_data_dram_general_info_dbi_write_get_f dbi_write_get;
    /**
     * returns numeric data of write_latency
     */
    dnx_data_dram_general_info_write_latency_get_f write_latency_get;
    /**
     * returns numeric data of read_latency
     */
    dnx_data_dram_general_info_read_latency_get_f read_latency_get;
    /**
     * returns numeric data of parity_latency
     */
    dnx_data_dram_general_info_parity_latency_get_f parity_latency_get;
    /**
     * returns numeric data of actual_parity_latency
     */
    dnx_data_dram_general_info_actual_parity_latency_get_f actual_parity_latency_get;
    /**
     * returns numeric data of tune_mode_on_init
     */
    dnx_data_dram_general_info_tune_mode_on_init_get_f tune_mode_on_init_get;
    /**
     * returns numeric data of command_parity_latency
     */
    dnx_data_dram_general_info_command_parity_latency_get_f command_parity_latency_get;
    /**
     * returns numeric data of crc_write_latency
     */
    dnx_data_dram_general_info_crc_write_latency_get_f crc_write_latency_get;
    /**
     * returns numeric data of crc_read_latency
     */
    dnx_data_dram_general_info_crc_read_latency_get_f crc_read_latency_get;
    /**
     * returns numeric data of crc_write
     */
    dnx_data_dram_general_info_crc_write_get_f crc_write_get;
    /**
     * returns numeric data of crc_read
     */
    dnx_data_dram_general_info_crc_read_get_f crc_read_get;
    /**
     * returns numeric data of device_size
     */
    dnx_data_dram_general_info_device_size_get_f device_size_get;
    /**
     * get table mr_defaults entry 
     */
    dnx_data_dram_general_info_mr_defaults_get_f mr_defaults_get;
    /**
     * get general info table about table (for example key size)mr_defaults info
     */
    dnxc_data_table_info_get_f mr_defaults_info_get;
    /**
     * get table dram_info entry 
     */
    dnx_data_dram_general_info_dram_info_get_f dram_info_get;
    /**
     * get general info table about table (for example key size)dram_info info
     */
    dnxc_data_table_info_get_f dram_info_info_get;
    /**
     * get table timing_params entry 
     */
    dnx_data_dram_general_info_timing_params_get_f timing_params_get;
    /**
     * get general info table about table (for example key size)timing_params info
     */
    dnxc_data_table_info_get_f timing_params_info_get;
    /**
     * get table refresh_intervals entry 
     */
    dnx_data_dram_general_info_refresh_intervals_get_f refresh_intervals_get;
    /**
     * get general info table about table (for example key size)refresh_intervals info
     */
    dnxc_data_table_info_get_f refresh_intervals_info_get;
} dnx_data_if_dram_general_info_t;

/*
 * }
 */

/*
 * SUBMODULE  - ADDRESS_TRANSLATION:
 * information regarding the address translation scheme between logical to physical buffer
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule address_translation table matrix_configuration
 * Table info:
 * address translation matrix(ATM) configuration options
 */
typedef struct
{
    /**
     * the values of the ATM
     */
    uint32 logical_to_physical[DNX_DATA_MAX_DRAM_ADDRESS_TRANSLATION_MATRIX_COLUMN_SIZE];
} dnx_data_dram_address_translation_matrix_configuration_t;

/**
 * \brief Holds values of submodule address_translation table interrupt_regs
 * Table info:
 * per address translation unit list of interrupt registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_address_translation_interrupt_regs_t;

/**
 * \brief Holds values of submodule address_translation table counter_regs
 * Table info:
 * per address translation unit list of counter registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_address_translation_counter_regs_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_address_translation_feature_nof
} dnx_data_dram_address_translation_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_address_translation_feature_get_f) (
    int unit,
    dnx_data_dram_address_translation_feature_e feature);

/**
 * \brief returns define data of matrix_column_size
 * Module - 'dram', Submodule - 'address_translation', data - 'matrix_column_size'
 * the number of rows in the ATM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     matrix_column_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_address_translation_matrix_column_size_get_f) (
    int unit);

/**
 * \brief returns define data of physical_address_transaction_size
 * Module - 'dram', Submodule - 'address_translation', data - 'physical_address_transaction_size'
 * nof bytes in each read/write from/to physical address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_transaction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_address_translation_physical_address_transaction_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_atms
 * Module - 'dram', Submodule - 'address_translation', data - 'nof_atms'
 * number of address translation matrix
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_atms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_address_translation_nof_atms_get_f) (
    int unit);

/**
 * \brief get table matrix_configuration entry 
 * address translation matrix(ATM) configuration options
 * 
 * \param [in] unit - unit #
 * \param [in] matrix_option - matrix selector
 * 
 * \return
 *     matrix_configuration - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_matrix_configuration_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_address_translation_matrix_configuration_t *(
    *dnx_data_dram_address_translation_matrix_configuration_get_f) (
    int unit,
    int matrix_option);

/**
 * \brief get table interrupt_regs entry 
 * per address translation unit list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_address_translation_interrupt_regs_t *(
    *dnx_data_dram_address_translation_interrupt_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table counter_regs entry 
 * per address translation unit list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_address_translation_counter_regs_t *(
    *dnx_data_dram_address_translation_counter_regs_get_f) (
    int unit,
    int index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - ADDRESS_TRANSLATION:
 * {
 */
/**
 * \brief Interface for dram address_translation data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_address_translation_feature_get_f feature_get;
    /**
     * returns define data of matrix_column_size
     */
    dnx_data_dram_address_translation_matrix_column_size_get_f matrix_column_size_get;
    /**
     * returns define data of physical_address_transaction_size
     */
    dnx_data_dram_address_translation_physical_address_transaction_size_get_f physical_address_transaction_size_get;
    /**
     * returns define data of nof_atms
     */
    dnx_data_dram_address_translation_nof_atms_get_f nof_atms_get;
    /**
     * get table matrix_configuration entry 
     */
    dnx_data_dram_address_translation_matrix_configuration_get_f matrix_configuration_get;
    /**
     * get general info table about table (for example key size)matrix_configuration info
     */
    dnxc_data_table_info_get_f matrix_configuration_info_get;
    /**
     * get table interrupt_regs entry 
     */
    dnx_data_dram_address_translation_interrupt_regs_get_f interrupt_regs_get;
    /**
     * get general info table about table (for example key size)interrupt_regs info
     */
    dnxc_data_table_info_get_f interrupt_regs_info_get;
    /**
     * get table counter_regs entry 
     */
    dnx_data_dram_address_translation_counter_regs_get_f counter_regs_get;
    /**
     * get general info table about table (for example key size)counter_regs info
     */
    dnxc_data_table_info_get_f counter_regs_info_get;
} dnx_data_if_dram_address_translation_t;

/*
 * }
 */

/*
 * SUBMODULE  - BUFFERS:
 * information regarding BDs and BDBs
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule buffers table deleted_buffers_info
 * Table info:
 * deleted buffers info
 */
typedef struct
{
    /**
     * full path to file containing deleted buffers for this unit
     */
    char *deleted_buffers_file;
} dnx_data_dram_buffers_deleted_buffers_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * this feature represents sending buffers to quarantine after tdu corrected error event has happend
     */
    dnx_data_dram_buffers_quarantine_buffers_if_tdu_corrected_errors,
    /**
     * this feature represents sending buffers to quarantine after tdu error event has happend
     */
    dnx_data_dram_buffers_quarantine_buffers_if_tdu_errors,

    /**
     * Must be last one!
     */
    _dnx_data_dram_buffers_feature_nof
} dnx_data_dram_buffers_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_buffers_feature_get_f) (
    int unit,
    dnx_data_dram_buffers_feature_e feature);

/**
 * \brief returns numeric data of allowed_errors
 * Module - 'dram', Submodule - 'buffers', data - 'allowed_errors'
 * number of times a buffer is allowed into the quarantine FIFO before it is deleted instead of restored
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     allowed_errors - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_buffers_allowed_errors_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bdbs
 * Module - 'dram', Submodule - 'buffers', data - 'nof_bdbs'
 * number of BDBs per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bdbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_buffers_nof_bdbs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fpc_banks
 * Module - 'dram', Submodule - 'buffers', data - 'nof_fpc_banks'
 * number of free pointer controler banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fpc_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_buffers_nof_fpc_banks_get_f) (
    int unit);

/**
 * \brief get table deleted_buffers_info entry 
 * deleted buffers info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     deleted_buffers_info - returns the relevant entry values grouped in struct - see dnx_data_dram_buffers_deleted_buffers_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_buffers_deleted_buffers_info_t *(
    *dnx_data_dram_buffers_deleted_buffers_info_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - BUFFERS:
 * {
 */
/**
 * \brief Interface for dram buffers data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_buffers_feature_get_f feature_get;
    /**
     * returns numeric data of allowed_errors
     */
    dnx_data_dram_buffers_allowed_errors_get_f allowed_errors_get;
    /**
     * returns define data of nof_bdbs
     */
    dnx_data_dram_buffers_nof_bdbs_get_f nof_bdbs_get;
    /**
     * returns define data of nof_fpc_banks
     */
    dnx_data_dram_buffers_nof_fpc_banks_get_f nof_fpc_banks_get;
    /**
     * get table deleted_buffers_info entry 
     */
    dnx_data_dram_buffers_deleted_buffers_info_get_f deleted_buffers_info_get;
    /**
     * get general info table about table (for example key size)deleted_buffers_info info
     */
    dnxc_data_table_info_get_f deleted_buffers_info_info_get;
} dnx_data_if_dram_buffers_t;

/*
 * }
 */

/*
 * SUBMODULE  - DRAM_BLOCK:
 * information regarding DRAM blocked state.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * indication whether disabling the write minus read leaky bucket is supported
     */
    dnx_data_dram_dram_block_write_minus_read_leaky_bucket_disable,
    /**
     * indication whether disabling the write plus read leaky bucket is supported
     */
    dnx_data_dram_dram_block_write_plus_read_leaky_bucket_disable,
    /**
     * indication whether average read inflights leaky bucket is supported
     */
    dnx_data_dram_dram_block_average_read_inflights_leaky_bucket,

    /**
     * Must be last one!
     */
    _dnx_data_dram_dram_block_feature_nof
} dnx_data_dram_dram_block_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_dram_block_feature_get_f) (
    int unit,
    dnx_data_dram_dram_block_feature_e feature);

/**
 * \brief returns define data of leaky_bucket_window_size
 * Module - 'dram', Submodule - 'dram_block', data - 'leaky_bucket_window_size'
 * window size for DRAM block calculation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     leaky_bucket_window_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_leaky_bucket_window_size_get_f) (
    int unit);

/**
 * \brief returns define data of wmr_reset_on_deassert
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_reset_on_deassert'
 * indication whether to reset on deassert of write-minus-read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_reset_on_deassert - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_wmr_reset_on_deassert_get_f) (
    int unit);

/**
 * \brief returns define data of wmr_full_size
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_full_size'
 * write-minus-read leaky bucket full size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_full_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_wmr_full_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of wmr_decrement_thr_factor
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_decrement_thr_factor'
 * factor for calculating decrement threshold for write_minus_read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_decrement_thr_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_wmr_decrement_thr_factor_get_f) (
    int unit);

/**
 * \brief returns numeric data of wpr_increment_thr_factor
 * Module - 'dram', Submodule - 'dram_block', data - 'wpr_increment_thr_factor'
 * factor for calculating increment threshold for write-plus-read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wpr_increment_thr_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_wpr_increment_thr_factor_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - DRAM_BLOCK:
 * {
 */
/**
 * \brief Interface for dram dram_block data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_dram_block_feature_get_f feature_get;
    /**
     * returns define data of leaky_bucket_window_size
     */
    dnx_data_dram_dram_block_leaky_bucket_window_size_get_f leaky_bucket_window_size_get;
    /**
     * returns define data of wmr_reset_on_deassert
     */
    dnx_data_dram_dram_block_wmr_reset_on_deassert_get_f wmr_reset_on_deassert_get;
    /**
     * returns define data of wmr_full_size
     */
    dnx_data_dram_dram_block_wmr_full_size_get_f wmr_full_size_get;
    /**
     * returns numeric data of wmr_decrement_thr_factor
     */
    dnx_data_dram_dram_block_wmr_decrement_thr_factor_get_f wmr_decrement_thr_factor_get;
    /**
     * returns numeric data of wpr_increment_thr_factor
     */
    dnx_data_dram_dram_block_wpr_increment_thr_factor_get_f wpr_increment_thr_factor_get;
} dnx_data_if_dram_dram_block_t;

/*
 * }
 */

/*
 * SUBMODULE  - DBAL:
 * information regarding DRAM dbal.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_dbal_feature_nof
} dnx_data_dram_dbal_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_dbal_feature_get_f) (
    int unit,
    dnx_data_dram_dbal_feature_e feature);

/**
 * \brief returns numeric data of hbmc_index_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbmc_index_nof_bits'
 * The size (number of bits) of HBMC_INDEX dbal field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbmc_index_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_hbmc_index_nof_bits_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - DBAL:
 * {
 */
/**
 * \brief Interface for dram dbal data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_dbal_feature_get_f feature_get;
    /**
     * returns numeric data of hbmc_index_nof_bits
     */
    dnx_data_dram_dbal_hbmc_index_nof_bits_get_f hbmc_index_nof_bits_get;
} dnx_data_if_dram_dbal_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_DRAM:
 * {
 */
/**
 * \brief Interface for dram data
 */
typedef struct
{
    /**
     * Interface for dram hbm data
     */
    dnx_data_if_dram_hbm_t hbm;
    /**
     * Interface for dram gddr6 data
     */
    dnx_data_if_dram_gddr6_t gddr6;
    /**
     * Interface for dram general_info data
     */
    dnx_data_if_dram_general_info_t general_info;
    /**
     * Interface for dram address_translation data
     */
    dnx_data_if_dram_address_translation_t address_translation;
    /**
     * Interface for dram buffers data
     */
    dnx_data_if_dram_buffers_t buffers;
    /**
     * Interface for dram dram_block data
     */
    dnx_data_if_dram_dram_block_t dram_block;
    /**
     * Interface for dram dbal data
     */
    dnx_data_if_dram_dbal_t dbal;
} dnx_data_if_dram_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_dram_t dnx_data_dram;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_DRAM_H_*/
/* *INDENT-ON* */
