/** \file include/soc/dnx/pemladrv/auto_generated/pemladrv.h
 *
 * sw state functions definitions
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 */
/*
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
/* *INDENT-OFF* */
#ifndef _PEMLADRV_H_
#define _PEMLADRV_H_

typedef unsigned int table_id_t;
typedef unsigned int field_id_t;
typedef unsigned int reg_id_t;
typedef unsigned int tcam_id_t;
#define MAX_VW_NAME_LENGTH 100
#define PEM_CFG_API_NOF_SPARE_REGISTERS 8
#define MAX_NAME_LENGTH    100

typedef enum DbType_e
{
  PEMLA_DB_TYPE_DIRECT_DB,
  PEMLA_DB_TYPE_TCAM_DB,
  PEMLA_DB_TYPE_EM_DB,
  PEMLA_DB_TYPE_LPM_DB
}DbType_t;

typedef struct pemladrv_field_s {
    field_id_t          field_id;
    unsigned int*       fldbuf;
    unsigned int        flags;
} pemladrv_field_t;

typedef struct pemladrv_mem_s {
    unsigned short          nof_fields;
    pemladrv_field_t        **fields;
    unsigned int            flags;
} pemladrv_mem_t;

typedef struct pemladrv_reg_field_info{
  char* field_name;
  unsigned int field_id;
  unsigned int field_size_in_bits;
}pemladrv_reg_field_info;

typedef struct pemladrv_reg_info{
  char* reg_name;
  unsigned int is_binded;
  unsigned int reg_id;
  unsigned int nof_fields;
  pemladrv_reg_field_info* ptr;    /*pointer to an array with the size nof_fields*/
}pemladrv_reg_info;

typedef struct pemladrv_db_field_info{
  unsigned int is_field_mapped;
  unsigned int field_id;
  unsigned int field_size_in_bits;
}pemladrv_db_field_info;

typedef struct pemladrv_db_info{
  char* db_name;
  DbType_t db_type;
  unsigned int db_id;
  unsigned int nof_fields;
  pemladrv_db_field_info* ptr;    /*pointer to an array with the size nof_fields*/
}pemladrv_db_info;

typedef struct VirtualWireMappingInfo{
  unsigned int virtual_wire_lsb;
  unsigned int virtual_wire_msb;
  unsigned int physical_wire_lsb;
  char         physical_wire_name[MAX_VW_NAME_LENGTH];
}VirtualWireMappingInfo;

typedef struct VirtualWireInfo{
  char         virtual_wire_name[MAX_VW_NAME_LENGTH];
  unsigned int start_stage;
  unsigned int end_stage;
  unsigned int width_in_bits;
  unsigned int nof_mappings;
  VirtualWireMappingInfo* vw_mappings_arr;    /*pointer to an array with the size nof_mappings*/
}VirtualWireInfo;

typedef struct VirtualWiresContainer {
  unsigned int           nof_virtual_wires;
  VirtualWireInfo*       vw_info_arr;
} VirtualWiresContainer;

typedef struct VersionInfo{
  unsigned int iterator;
  unsigned int spare_registers_values_arr[PEM_CFG_API_NOF_SPARE_REGISTERS];
  char         spare_registers_addr_arr[PEM_CFG_API_NOF_SPARE_REGISTERS][MAX_NAME_LENGTH];
  char         version_info_str[5000];
  char         version_str[MAX_NAME_LENGTH];
  char         device_str[MAX_NAME_LENGTH];
  char         chuck_lib_date_str[MAX_NAME_LENGTH];
  char         device_lib_date_str[MAX_NAME_LENGTH];
  char         chuck_lib_signature_str[MAX_NAME_LENGTH];
  char         device_lib_signature_str[MAX_NAME_LENGTH];
} VersionInfo;

/* Read/Write function to (logical) access the PEM Logical Db Direct Data-Bases */
int pemladrv_direct_write(int unit, table_id_t db_id, unsigned int row_index, pemladrv_mem_t *data);
int pemladrv_direct_read(int unit, table_id_t db_id, unsigned int row_index, pemladrv_mem_t *result);

/* Read/Write function to (logical) access the PEM Logical Registers */
int pemladrv_reg_write(int unit, reg_id_t reg_id, pemladrv_mem_t *data);
int pemladrv_reg_read(int unit,  reg_id_t reg_id, pemladrv_mem_t *result);

/* Read/Write function to (logical) access the PEM Logical DB TCAM  */
int pemladrv_tcam_write(int unit, tcam_id_t tcam_id, unsigned int row_index, pemladrv_mem_t *key, pemladrv_mem_t *mask, pemladrv_mem_t *valid, pemladrv_mem_t *data);
int pemladrv_tcam_read(int unit,  tcam_id_t tcam_id, unsigned int row_index, pemladrv_mem_t *key, pemladrv_mem_t *mask, pemladrv_mem_t *valid, pemladrv_mem_t *result);

/* Write all fields of a register */
int dnx_pemladrv_full_reg_write(int unit, const int reg_id, const int size, const unsigned int* data);

/* get the size of a field in a specific register */
int dnx_pemladrv_virtual_register_size_in_bits_get(const int unit, const int reg_id, const int field_id, int* size);
/* pemladrv_reg_info_allocate */
unsigned int dnx_pemladrv_reg_info_allocate(int unit, pemladrv_reg_info** ptr, int* size);
/* pemladrv_reg_info_de_allocate*/
unsigned int dnx_pemladrv_reg_info_de_allocate(int unit, pemladrv_reg_info* ptr);
/* pemladrv_direct_info_allocate */
unsigned int dnx_pemladrv_direct_info_allocate(int unit, pemladrv_db_info** ptr, int* size);
/* pemladrv_direct_info_de_allocate*/
unsigned int dnx_pemladrv_direct_info_de_allocate(int unit, pemladrv_db_info* ptr);
/* get all virtual wires mappings and info*/
VirtualWiresContainer* dnx_pemladrv_get_virtual_wires_info(const int unit);


/*
 * The following functions are higher logical access to logical Databases.
 * Which means that user do not know how actually this memory are implemented (sram/tcam,...)
 * Implementation of those function are using the above memories access.
 *
 * All the following function return '0' on success or negative number indicating error.
 */

/* EM (Exact Match) access functions */
/*************************************/

/* add entry,
 * returns the index (in 'index' parameter) in the EM table
 * The function return '0' on success, or  number indicating error:
 * - key already exists returns error and the index of existed entry,
 * - table is full
 */
int pemladrv_em_insert(int unit, table_id_t table_id,  pemladrv_mem_t* key,  pemladrv_mem_t* result, int *index);

/* remove entry,
 * returns the index (in 'index'  parameter) in the EM table that was cleared.
 * The function return '0' on success or  number indicating error:
 * - entry not exists.
 */
int pemladrv_em_remove(int unit, table_id_t table_id,  pemladrv_mem_t* key, int *index);

/* lookup entry,
 * returns the index (in 'index' parameter) in the EM table that was found, the key and the result.
 * Function return '0' on success or number indicating error:
 */
int pemladrv_em_lookup(int unit, table_id_t table_id,  pemladrv_mem_t* key, pemladrv_mem_t* result, int *index);

/* get next EM entry,
 * returns the index (in 'index' parameter) in the EM table of the next valid entry,
 * to receive the first entry use index=0, if no more entries exists returns index=-1.
 * Return '0' on success, or number indicating error:
 */
int pemladrv_em_get_next_index(int unit, table_id_t table_id, int* index);

/* get EM entry key and result by index,
 * Return '0' on success, or number indicating error:
 * - entry not valid
 */
int pemladrv_em_entry_get_by_id(int unit, table_id_t table_id,  int index,  pemladrv_mem_t* key, pemladrv_mem_t* result);

/* set EM entry key and result by index, override existing entry.
 * Return '0' on success, or number indicating error:
 */
int pemladrv_em_entry_set_by_id(int unit, table_id_t table_id,  int index, pemladrv_mem_t* key, pemladrv_mem_t* result);

/* remove all EM entries in DB */
int pemladrv_em_remove_all(int unit, table_id_t table_id);

/* remove EM entry by index (invalidate).
 * Return '0' on success, or number indicating error:
 * - not exists.
 */
int pemladrv_em_remove_by_index (int unit, table_id_t table_id, int index);


/* LPM (Longest Prefix Match) access functions */
/***********************************************/

/* add entry,
 * returns the index (in 'index' parameter) in the LPM table.
 * The function return '0' on success, or  number indicating error:
 * - key already exists returns error and the index of existed entry,
 * - table is full
 */
int pemladrv_lpm_insert(int unit, table_id_t table_id,  pemladrv_mem_t* key, int length_in_bits,  pemladrv_mem_t* result, int *index);

/* remove entry,
 * returns the index (in 'index'  parameter) in the LPM table that was cleared.
 * The function return '0' on success or  number indicating error:
 * - entry not exists.
 */
int pemladrv_lpm_remove(int unit, table_id_t table_id,  pemladrv_mem_t* key,  int length_in_bits, int *index);

/* lookup entry,
 * returns the index (in 'index' parameter) in the LPM table that was found, the key and the result.
 * Function return '0' on success or number indicating error:
 */
int pemladrv_lpm_lookup(int unit, table_id_t table_id,  pemladrv_mem_t* key,  pemladrv_mem_t* result, int *index);

/*remove all LPM entries in DB */
int pemladrv_lpm_remove_all(int unit, table_id_t table_id);




/******************************/
/* Memory Management functions*/
/******************************/

/*allocating pem_mem_access struct with pem_field_access** arr with size of nof_fields*/
pemladrv_mem_t* pemladrv_mem_alloc(const unsigned int nof_fields);

/*The function receives  a pointer to specific field and the size of the field buffer in bits and allocates memory for the field buffer*/
void              pemladrv_mem_alloc_field(pemladrv_field_t* pem_field_access, const unsigned int field_width_in_bits);

/*allocating pem_mem_access struct for result with nof_fields and fldbuf size matching the fields_num and nof_bits per field in direct db with db_id. Return '0' on success, or number indicating error*/
unsigned int      pemladrv_mem_alloc_direct(const int unit, const int db_id, pemladrv_mem_t** result);

/*allocating pem_mem_access struct for key, mask, valid and result with nof_fields and fldbuf size matching the fields_num and nof_bits per field in tcam db with db_id. Return '0' on success, or number indicating error*/
unsigned int      pemladrv_mem_alloc_tcam(const int unit, const int db_id, pemladrv_mem_t** key, pemladrv_mem_t** mask, pemladrv_mem_t** valid, pemladrv_mem_t** result);

/*allocating pem_mem_access struct for result with nof_fields and fldbuf size matching the fields_num and nof_bits per field in lpm db with db_id. Return '0' on success, or number indicating error*/
unsigned int      pemladrv_mem_alloc_lpm(const int unit, const int db_id, pemladrv_mem_t** key, pemladrv_mem_t** result);

/*allocating pem_mem_access struct for result with nof_fields and fldbuf size matching the fields_num and nof_bits per field in em db with db_id. Return '0' on success, or number indicating error*/
unsigned int      pemladrv_mem_alloc_em(const int unit, const int db_id, pemladrv_mem_t** key, pemladrv_mem_t** result);

/*freeing memory allocated in pem_mem_access struct*/
void              pemladrv_mem_free(pemladrv_mem_t* pem_mem_access);

int dnx_pemladrv_init(int unit, int restore_after_reset, const char *vmem_definition_file_name /* in case of null, PEM_DEFAULT_DB_MEMORY_MAP_FILE is taken */);
int dnx_pemladrv_deinit(int unit);
VersionInfo* dnx_get_version(int unit, int print_to_cout);

#endif /*_PEMLADRV_H_*/
/* *INDENT-ON* */
