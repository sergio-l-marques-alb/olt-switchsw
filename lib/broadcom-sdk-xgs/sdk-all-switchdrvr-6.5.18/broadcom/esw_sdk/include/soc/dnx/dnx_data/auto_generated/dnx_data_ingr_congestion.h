/** \file dnx_data_ingr_congestion.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INGR_CONGESTION_H_
/*{*/
#define _DNX_DATA_INGR_CONGESTION_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_ingr_congestion.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_ingr_congestion
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_ingr_congestion_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - CONFIG:
 * Ingress congestion configuration
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is PP port in CGM overwritten by Reassembly
     */
    dnx_data_ingr_congestion_config_pp_port_by_reassembly_overwrite,
    /**
     * Is inband telemetry FTMH extension issue fixed by ECO
     */
    dnx_data_ingr_congestion_config_inband_telemetry_ftmh_extension_eco_fix,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_config_feature_nof
} dnx_data_ingr_congestion_config_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_ingr_congestion_config_feature_get_f) (
    int unit,
    dnx_data_ingr_congestion_config_feature_e feature);

/**
 * \brief returns numeric data of guarantee_mode
 * Module - 'ingr_congestion', Submodule - 'config', data - 'guarantee_mode'
 * guarantee mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     guarantee_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_config_guarantee_mode_get_f) (
    int unit);

/**
 * \brief returns numeric data of wred_packet_size
 * Module - 'ingr_congestion', Submodule - 'config', data - 'wred_packet_size'
 * max packet size used in WRED parameters computation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wred_packet_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_config_wred_packet_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_INGR_CONGESTION - CONFIG:
 * {
 */
/**
 * \brief Interface for ingr_congestion config data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_ingr_congestion_config_feature_get_f feature_get;
    /**
     * returns numeric data of guarantee_mode
     */
    dnx_data_ingr_congestion_config_guarantee_mode_get_f guarantee_mode_get;
    /**
     * returns numeric data of wred_packet_size
     */
    dnx_data_ingr_congestion_config_wred_packet_size_get_f wred_packet_size_get;
} dnx_data_if_ingr_congestion_config_t;

/*
 * }
 */

/*
 * SUBMODULE  - INFO:
 * Ingress congestion info
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule info table resource
 * Table info:
 * Resource Size - per resource
 */
typedef struct
{
    /**
     * Maximal resource size
     */
    uint32 max;
    /**
     * Maximal resource size in HW granularity
     */
    uint32 hw_resolution_max;
    /**
     * Maximal nf bits to describe resource size in HW granularity
     */
    uint32 hw_resolution_nof_bits;
    /**
     * fadt alpha min value per resource type
     */
    int fadt_alpha_min;
    /**
     * fadt alpha max value per resource type
     */
    int fadt_alpha_max;
} dnx_data_ingr_congestion_info_resource_t;

/**
 * \brief Holds values of submodule info table dp_free_res_presentage_drop
 * Table info:
 * Amount of free resource precntage to cause drop per DP
 */
typedef struct
{
    /**
     * precentage of free resources to cause drop
     */
    uint32 drop_precentage;
} dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t;

/**
 * \brief Holds values of submodule info table admission_preferences
 * Table info:
 * admission preferences (admit/guaranteed) per DP.
 */
typedef struct
{
    /**
     * if set, than in case statistic admission tests fail (for example WRED), but the queue level is within the guaranteed, it will enter.
     */
    uint32 is_guarantee_over_admit;
} dnx_data_ingr_congestion_info_admission_preferences_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Soft DRAM block state supported
     */
    dnx_data_ingr_congestion_info_soft_dram_block_supported,
    /**
     * Is latency based admission supported
     */
    dnx_data_ingr_congestion_info_latency_based_admission,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_info_feature_nof
} dnx_data_ingr_congestion_info_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_ingr_congestion_info_feature_get_f) (
    int unit,
    dnx_data_ingr_congestion_info_feature_e feature);

/**
 * \brief returns define data of threshold_granularity
 * Module - 'ingr_congestion', Submodule - 'info', data - 'threshold_granularity'
 * Granularity (non bytes) thresholds are written to HW with
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     threshold_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_info_threshold_granularity_get_f) (
    int unit);

/**
 * \brief returns define data of words_resolution
 * Module - 'ingr_congestion', Submodule - 'info', data - 'words_resolution'
 * Size of each HW word in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     words_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_info_words_resolution_get_f) (
    int unit);

/**
 * \brief returns define data of bytes_threshold_granularity
 * Module - 'ingr_congestion', Submodule - 'info', data - 'bytes_threshold_granularity'
 * Granularity bytes thresholds are written to HW with
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bytes_threshold_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_info_bytes_threshold_granularity_get_f) (
    int unit);

/**
 * \brief returns define data of nof_dropped_reasons_cgm
 * Module - 'ingr_congestion', Submodule - 'info', data - 'nof_dropped_reasons_cgm'
 * number of reasons for the dropped packets in CGM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dropped_reasons_cgm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_info_nof_dropped_reasons_cgm_get_f) (
    int unit);

/**
 * \brief returns define data of wred_max_gain
 * Module - 'ingr_congestion', Submodule - 'info', data - 'wred_max_gain'
 * maximal allowed value of gain for WRED
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wred_max_gain - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_info_wred_max_gain_get_f) (
    int unit);

/**
 * \brief returns define data of wred_granularity
 * Module - 'ingr_congestion', Submodule - 'info', data - 'wred_granularity'
 * granularity of WRED parameters for coefficient calculation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wred_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_info_wred_granularity_get_f) (
    int unit);

/**
 * \brief returns define data of nof_pds_in_pdb
 * Module - 'ingr_congestion', Submodule - 'info', data - 'nof_pds_in_pdb'
 * number of SRAM PDs in PDB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pds_in_pdb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_info_nof_pds_in_pdb_get_f) (
    int unit);

/**
 * \brief returns numeric data of max_sram_pdbs
 * Module - 'ingr_congestion', Submodule - 'info', data - 'max_sram_pdbs'
 * Maximal number of SRAM PDBS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_sram_pdbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_info_max_sram_pdbs_get_f) (
    int unit);

/**
 * \brief returns numeric data of max_dram_bdbs
 * Module - 'ingr_congestion', Submodule - 'info', data - 'max_dram_bdbs'
 * Maximal number of DRAM BDBS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_dram_bdbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_info_max_dram_bdbs_get_f) (
    int unit);

/**
 * \brief get table resource entry 
 * Resource Size - per resource
 * 
 * \param [in] unit - unit #
 * \param [in] type - resource type
 * 
 * \return
 *     resource - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_info_resource_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_info_resource_t *(
    *dnx_data_ingr_congestion_info_resource_get_f) (
    int unit,
    int type);

/**
 * \brief get table dp_free_res_presentage_drop entry 
 * Amount of free resource precntage to cause drop per DP
 * 
 * \param [in] unit - unit #
 * \param [in] dp - DP (0-3). 0=Green, 1=Yellow, 2=Red, 3=Black
 * 
 * \return
 *     dp_free_res_presentage_drop - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t *(
    *dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_get_f) (
    int unit,
    int dp);

/**
 * \brief get table admission_preferences entry 
 * admission preferences (admit/guaranteed) per DP.
 * 
 * \param [in] unit - unit #
 * \param [in] dp - DP (0-3). 0=Green, 1=Yellow, 2=Red, 3=Black
 * 
 * \return
 *     admission_preferences - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_info_admission_preferences_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_info_admission_preferences_t *(
    *dnx_data_ingr_congestion_info_admission_preferences_get_f) (
    int unit,
    int dp);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_INGR_CONGESTION - INFO:
 * {
 */
/**
 * \brief Interface for ingr_congestion info data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_ingr_congestion_info_feature_get_f feature_get;
    /**
     * returns define data of threshold_granularity
     */
    dnx_data_ingr_congestion_info_threshold_granularity_get_f threshold_granularity_get;
    /**
     * returns define data of words_resolution
     */
    dnx_data_ingr_congestion_info_words_resolution_get_f words_resolution_get;
    /**
     * returns define data of bytes_threshold_granularity
     */
    dnx_data_ingr_congestion_info_bytes_threshold_granularity_get_f bytes_threshold_granularity_get;
    /**
     * returns define data of nof_dropped_reasons_cgm
     */
    dnx_data_ingr_congestion_info_nof_dropped_reasons_cgm_get_f nof_dropped_reasons_cgm_get;
    /**
     * returns define data of wred_max_gain
     */
    dnx_data_ingr_congestion_info_wred_max_gain_get_f wred_max_gain_get;
    /**
     * returns define data of wred_granularity
     */
    dnx_data_ingr_congestion_info_wred_granularity_get_f wred_granularity_get;
    /**
     * returns define data of nof_pds_in_pdb
     */
    dnx_data_ingr_congestion_info_nof_pds_in_pdb_get_f nof_pds_in_pdb_get;
    /**
     * returns numeric data of max_sram_pdbs
     */
    dnx_data_ingr_congestion_info_max_sram_pdbs_get_f max_sram_pdbs_get;
    /**
     * returns numeric data of max_dram_bdbs
     */
    dnx_data_ingr_congestion_info_max_dram_bdbs_get_f max_dram_bdbs_get;
    /**
     * get table resource entry 
     */
    dnx_data_ingr_congestion_info_resource_get_f resource_get;
    /**
     * get general info table about table (for example key size)resource info
     */
    dnxc_data_table_info_get_f resource_info_get;
    /**
     * get table dp_free_res_presentage_drop entry 
     */
    dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_get_f dp_free_res_presentage_drop_get;
    /**
     * get general info table about table (for example key size)dp_free_res_presentage_drop info
     */
    dnxc_data_table_info_get_f dp_free_res_presentage_drop_info_get;
    /**
     * get table admission_preferences entry 
     */
    dnx_data_ingr_congestion_info_admission_preferences_get_f admission_preferences_get;
    /**
     * get general info table about table (for example key size)admission_preferences info
     */
    dnxc_data_table_info_get_f admission_preferences_info_get;
} dnx_data_if_ingr_congestion_info_t;

/*
 * }
 */

/*
 * SUBMODULE  - FADT_TAIL_DROP:
 * FADT tail drop thresholds and related sizes
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_fadt_tail_drop_feature_nof
} dnx_data_ingr_congestion_fadt_tail_drop_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_ingr_congestion_fadt_tail_drop_feature_get_f) (
    int unit,
    dnx_data_ingr_congestion_fadt_tail_drop_feature_e feature);

/**
 * \brief returns numeric data of default_max_size_byte_threshold_for_ocb_only
 * Module - 'ingr_congestion', Submodule - 'fadt_tail_drop', data - 'default_max_size_byte_threshold_for_ocb_only'
 * Default for max size threshold for byte resource when rate class is OCB only
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_max_size_byte_threshold_for_ocb_only - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_fadt_tail_drop_default_max_size_byte_threshold_for_ocb_only_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_INGR_CONGESTION - FADT_TAIL_DROP:
 * {
 */
/**
 * \brief Interface for ingr_congestion fadt_tail_drop data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_ingr_congestion_fadt_tail_drop_feature_get_f feature_get;
    /**
     * returns numeric data of default_max_size_byte_threshold_for_ocb_only
     */
    dnx_data_ingr_congestion_fadt_tail_drop_default_max_size_byte_threshold_for_ocb_only_get_f default_max_size_byte_threshold_for_ocb_only_get;
} dnx_data_if_ingr_congestion_fadt_tail_drop_t;

/*
 * }
 */

/*
 * SUBMODULE  - DRAM_BOUND:
 * dram bound thresholds and related sizes
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule dram_bound table resource
 * Table info:
 * DRAM Resource info per resource
 */
typedef struct
{
    /**
     * Maximal resource size
     */
    uint32 max;
    /**
     * if set, FADT threshold algorithm for the resource type is limited to a specific free resources range
     */
    int is_resource_range;
} dnx_data_ingr_congestion_dram_bound_resource_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_dram_bound_feature_nof
} dnx_data_ingr_congestion_dram_bound_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_ingr_congestion_dram_bound_feature_get_f) (
    int unit,
    dnx_data_ingr_congestion_dram_bound_feature_e feature);

/**
 * \brief returns define data of fadt_alpha_min
 * Module - 'ingr_congestion', Submodule - 'dram_bound', data - 'fadt_alpha_min'
 * min value for fadt dram thresholds
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fadt_alpha_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dram_bound_fadt_alpha_min_get_f) (
    int unit);

/**
 * \brief returns define data of fadt_alpha_max
 * Module - 'ingr_congestion', Submodule - 'dram_bound', data - 'fadt_alpha_max'
 * max value for fadt dram thresholds
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fadt_alpha_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dram_bound_fadt_alpha_max_get_f) (
    int unit);

/**
 * \brief get table resource entry 
 * DRAM Resource info per resource
 * 
 * \param [in] unit - unit #
 * \param [in] type - resource type
 * 
 * \return
 *     resource - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_dram_bound_resource_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_dram_bound_resource_t *(
    *dnx_data_ingr_congestion_dram_bound_resource_get_f) (
    int unit,
    int type);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_INGR_CONGESTION - DRAM_BOUND:
 * {
 */
/**
 * \brief Interface for ingr_congestion dram_bound data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_ingr_congestion_dram_bound_feature_get_f feature_get;
    /**
     * returns define data of fadt_alpha_min
     */
    dnx_data_ingr_congestion_dram_bound_fadt_alpha_min_get_f fadt_alpha_min_get;
    /**
     * returns define data of fadt_alpha_max
     */
    dnx_data_ingr_congestion_dram_bound_fadt_alpha_max_get_f fadt_alpha_max_get;
    /**
     * get table resource entry 
     */
    dnx_data_ingr_congestion_dram_bound_resource_get_f resource_get;
    /**
     * get general info table about table (for example key size)resource info
     */
    dnxc_data_table_info_get_f resource_info_get;
} dnx_data_if_ingr_congestion_dram_bound_t;

/*
 * }
 */

/*
 * SUBMODULE  - VOQ:
 * VOQ info
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_voq_feature_nof
} dnx_data_ingr_congestion_voq_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_ingr_congestion_voq_feature_get_f) (
    int unit,
    dnx_data_ingr_congestion_voq_feature_e feature);

/**
 * \brief returns define data of nof_rate_class
 * Module - 'ingr_congestion', Submodule - 'voq', data - 'nof_rate_class'
 * number of VOQ rate classes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rate_class - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_voq_nof_rate_class_get_f) (
    int unit);

/**
 * \brief returns define data of rate_class_nof_bits
 * Module - 'ingr_congestion', Submodule - 'voq', data - 'rate_class_nof_bits'
 * number of bits in VOQ rate class
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rate_class_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_voq_rate_class_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compensation_profiles
 * Module - 'ingr_congestion', Submodule - 'voq', data - 'nof_compensation_profiles'
 * number of VOQ compensation profiles. used for voq compensation calculation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compensation_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_voq_nof_compensation_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of default_compensation
 * Module - 'ingr_congestion', Submodule - 'voq', data - 'default_compensation'
 * set to eth compensation (Preamable + IFG + CRC)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_compensation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_voq_default_compensation_get_f) (
    int unit);

/**
 * \brief returns define data of latency_bins
 * Module - 'ingr_congestion', Submodule - 'voq', data - 'latency_bins'
 * number of latency admission VOQ ranges
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     latency_bins - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_voq_latency_bins_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_INGR_CONGESTION - VOQ:
 * {
 */
/**
 * \brief Interface for ingr_congestion voq data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_ingr_congestion_voq_feature_get_f feature_get;
    /**
     * returns define data of nof_rate_class
     */
    dnx_data_ingr_congestion_voq_nof_rate_class_get_f nof_rate_class_get;
    /**
     * returns define data of rate_class_nof_bits
     */
    dnx_data_ingr_congestion_voq_rate_class_nof_bits_get_f rate_class_nof_bits_get;
    /**
     * returns define data of nof_compensation_profiles
     */
    dnx_data_ingr_congestion_voq_nof_compensation_profiles_get_f nof_compensation_profiles_get;
    /**
     * returns define data of default_compensation
     */
    dnx_data_ingr_congestion_voq_default_compensation_get_f default_compensation_get;
    /**
     * returns define data of latency_bins
     */
    dnx_data_ingr_congestion_voq_latency_bins_get_f latency_bins_get;
} dnx_data_if_ingr_congestion_voq_t;

/*
 * }
 */

/*
 * SUBMODULE  - VSQ:
 * VSQ info
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule vsq table info
 * Table info:
 * General VSQ info
 */
typedef struct
{
    /**
     * Number of VSQs in this group.
     */
    uint32 nof;
} dnx_data_ingr_congestion_vsq_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * support for VSQ size watermark retrieval
     */
    dnx_data_ingr_congestion_vsq_size_watermark_support,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_vsq_feature_nof
} dnx_data_ingr_congestion_vsq_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_ingr_congestion_vsq_feature_get_f) (
    int unit,
    dnx_data_ingr_congestion_vsq_feature_e feature);

/**
 * \brief returns define data of vsq_rate_class_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_rate_class_nof'
 * Number of VSQ rate classes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_rate_class_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_rate_class_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vsq_a_rate_class_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_a_rate_class_nof'
 * Number of VSQ-A rate classes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_a_rate_class_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_a_rate_class_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vsq_a_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_a_nof'
 * Number of VSQ-A
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_a_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_a_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vsq_b_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_b_nof'
 * Number of VSQ-B
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_b_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_b_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vsq_c_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_c_nof'
 * Number of VSQ-C
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_c_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_c_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vsq_d_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_d_nof'
 * Number of VSQ-D
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_d_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_d_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vsq_e_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_e_nof'
 * Number of VSQ-E
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_e_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_e_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vsq_e_hw_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_e_hw_nof'
 * Number of VSQ-E in HW, including reserved VSQ-E
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_e_hw_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_e_hw_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vsq_f_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_f_nof'
 * Number of VSQ-F
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_f_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_f_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vsq_f_hw_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_f_hw_nof'
 * Number of VSQ-F in HW, including reserved VSQ-F
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_f_hw_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_f_hw_nof_get_f) (
    int unit);

/**
 * \brief returns define data of nif_vsq_e_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'nif_vsq_e_nof'
 * Number of VSQ-E on NIF ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_vsq_e_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_nif_vsq_e_nof_get_f) (
    int unit);

/**
 * \brief returns define data of non_nif_vsq_f_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'non_nif_vsq_f_nof'
 * Number of VSQ-F on non NIF ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     non_nif_vsq_f_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_non_nif_vsq_f_nof_get_f) (
    int unit);

/**
 * \brief returns define data of pool_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'pool_nof'
 * Number of resource pools
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pool_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_pool_nof_get_f) (
    int unit);

/**
 * \brief returns define data of connection_class_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'connection_class_nof'
 * Number of connection classes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     connection_class_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_connection_class_nof_get_f) (
    int unit);

/**
 * \brief returns define data of tc_pg_profile_nof
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'tc_pg_profile_nof'
 * Number of tc->pg profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tc_pg_profile_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_tc_pg_profile_nof_get_f) (
    int unit);

/**
 * \brief returns numeric data of vsq_e_default
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_e_default'
 * Default mapping of VSQ-E
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_e_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_e_default_get_f) (
    int unit);

/**
 * \brief returns numeric data of vsq_f_default
 * Module - 'ingr_congestion', Submodule - 'vsq', data - 'vsq_f_default'
 * Default mapping of VSQ-F
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsq_f_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_vsq_vsq_f_default_get_f) (
    int unit);

/**
 * \brief get table info entry 
 * General VSQ info
 * 
 * \param [in] unit - unit #
 * \param [in] vsq_group - vsq_group id as in enum SOC_DNX_ITM_VSQ_GROUP.
 * 
 * \return
 *     info - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_vsq_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_vsq_info_t *(
    *dnx_data_ingr_congestion_vsq_info_get_f) (
    int unit,
    int vsq_group);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_INGR_CONGESTION - VSQ:
 * {
 */
/**
 * \brief Interface for ingr_congestion vsq data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_ingr_congestion_vsq_feature_get_f feature_get;
    /**
     * returns define data of vsq_rate_class_nof
     */
    dnx_data_ingr_congestion_vsq_vsq_rate_class_nof_get_f vsq_rate_class_nof_get;
    /**
     * returns define data of vsq_a_rate_class_nof
     */
    dnx_data_ingr_congestion_vsq_vsq_a_rate_class_nof_get_f vsq_a_rate_class_nof_get;
    /**
     * returns define data of vsq_a_nof
     */
    dnx_data_ingr_congestion_vsq_vsq_a_nof_get_f vsq_a_nof_get;
    /**
     * returns define data of vsq_b_nof
     */
    dnx_data_ingr_congestion_vsq_vsq_b_nof_get_f vsq_b_nof_get;
    /**
     * returns define data of vsq_c_nof
     */
    dnx_data_ingr_congestion_vsq_vsq_c_nof_get_f vsq_c_nof_get;
    /**
     * returns define data of vsq_d_nof
     */
    dnx_data_ingr_congestion_vsq_vsq_d_nof_get_f vsq_d_nof_get;
    /**
     * returns define data of vsq_e_nof
     */
    dnx_data_ingr_congestion_vsq_vsq_e_nof_get_f vsq_e_nof_get;
    /**
     * returns define data of vsq_e_hw_nof
     */
    dnx_data_ingr_congestion_vsq_vsq_e_hw_nof_get_f vsq_e_hw_nof_get;
    /**
     * returns define data of vsq_f_nof
     */
    dnx_data_ingr_congestion_vsq_vsq_f_nof_get_f vsq_f_nof_get;
    /**
     * returns define data of vsq_f_hw_nof
     */
    dnx_data_ingr_congestion_vsq_vsq_f_hw_nof_get_f vsq_f_hw_nof_get;
    /**
     * returns define data of nif_vsq_e_nof
     */
    dnx_data_ingr_congestion_vsq_nif_vsq_e_nof_get_f nif_vsq_e_nof_get;
    /**
     * returns define data of non_nif_vsq_f_nof
     */
    dnx_data_ingr_congestion_vsq_non_nif_vsq_f_nof_get_f non_nif_vsq_f_nof_get;
    /**
     * returns define data of pool_nof
     */
    dnx_data_ingr_congestion_vsq_pool_nof_get_f pool_nof_get;
    /**
     * returns define data of connection_class_nof
     */
    dnx_data_ingr_congestion_vsq_connection_class_nof_get_f connection_class_nof_get;
    /**
     * returns define data of tc_pg_profile_nof
     */
    dnx_data_ingr_congestion_vsq_tc_pg_profile_nof_get_f tc_pg_profile_nof_get;
    /**
     * returns numeric data of vsq_e_default
     */
    dnx_data_ingr_congestion_vsq_vsq_e_default_get_f vsq_e_default_get;
    /**
     * returns numeric data of vsq_f_default
     */
    dnx_data_ingr_congestion_vsq_vsq_f_default_get_f vsq_f_default_get;
    /**
     * get table info entry 
     */
    dnx_data_ingr_congestion_vsq_info_get_f info_get;
    /**
     * get general info table about table (for example key size)info info
     */
    dnxc_data_table_info_get_f info_info_get;
} dnx_data_if_ingr_congestion_vsq_t;

/*
 * }
 */

/*
 * SUBMODULE  - INIT:
 * init info
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule init table vsq_words_rjct_map
 * Table info:
 * initialization info for VSQ words reject map - defines combinations which should be turn on
 */
typedef struct
{
    /**
     * is total shared blocked
     */
    uint32 is_total_shared_blocked;
    /**
     * is port pg shared blocked
     */
    uint32 is_port_pg_shared_blocked;
    /**
     * is total headroom blocked
     */
    uint32 is_total_headroom_blocked;
    /**
     * is port pg headroom blocked
     */
    uint32 is_port_pg_headroom_blocked;
    /**
     * is voq in guaranteed
     */
    uint32 is_voq_in_guaranteed;
    /**
     * vsq guaranteed status
     */
    uint32 vsq_guaranteed_status;
} dnx_data_ingr_congestion_init_vsq_words_rjct_map_t;

/**
 * \brief Holds values of submodule init table vsq_sram_rjct_map
 * Table info:
 * initialization info for VSQ SRAM reject map - defines combinations which should be turn on
 */
typedef struct
{
    /**
     * is total shared blocked
     */
    uint32 is_total_shared_blocked;
    /**
     * is port pg shared blocked
     */
    uint32 is_port_pg_shared_blocked;
    /**
     * is headroom extension blocked
     */
    uint32 is_headroom_extension_blocked;
    /**
     * is total headroom blocked
     */
    uint32 is_total_headroom_blocked;
    /**
     * is port headroom blocked
     */
    uint32 is_port_headroom_blocked;
    /**
     * is PG headroom blocked
     */
    uint32 is_pg_headroom_blocked;
    /**
     * is voq in guaranteed
     */
    uint32 is_voq_in_guaranteed;
    /**
     * vsq guaranteed status
     */
    uint32 vsq_guaranteed_status;
} dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t;

/**
 * \brief Holds values of submodule init table dp_global_sram_buffer_drop
 * Table info:
 * Amount of free sram buffer resource to cause drop per DP
 */
typedef struct
{
    /**
     * Amount of free sram buffer resource to set the drop (to support hysteresis)
     */
    uint32 set_threshold;
    /**
     * Amount of free sram buffer resource to clear the drop (to support hysteresis)
     */
    uint32 clear_threshold;
} dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t;

/**
 * \brief Holds values of submodule init table dp_global_sram_pdb_drop
 * Table info:
 * Amount of free sram pdb resource to cause drop per DP
 */
typedef struct
{
    /**
     * Amount of free sram pdb resource to set the drop (to support hysteresis)
     */
    uint32 set_threshold;
    /**
     * Amount of free sram pdb resource to clear the drop (to support hysteresis)
     */
    uint32 clear_threshold;
} dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t;

/**
 * \brief Holds values of submodule init table dp_global_dram_bdb_drop
 * Table info:
 * Amount of free dram bdb resource to cause drop per DP
 */
typedef struct
{
    /**
     * Amount of free dram bdb resource to set the drop (to support hysteresis)
     */
    uint32 set_threshold;
    /**
     * Amount of free dram bdb resource to clear the drop (to support hysteresis)
     */
    uint32 clear_threshold;
} dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t;

/**
 * \brief Holds values of submodule init table equivalent_global_drop
 * Table info:
 * Equavalent amount per VOQ resource to per-DP global drop (not configurable by user)
 */
typedef struct
{
    /**
     * Equavalent amount in VOQ resource to per-DP global drop (not configurable by user) 
     */
    uint32 drop;
} dnx_data_ingr_congestion_init_equivalent_global_drop_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_init_feature_nof
} dnx_data_ingr_congestion_init_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_ingr_congestion_init_feature_get_f) (
    int unit,
    dnx_data_ingr_congestion_init_feature_e feature);

/**
 * \brief returns define data of fifo_size
 * Module - 'ingr_congestion', Submodule - 'init', data - 'fifo_size'
 * size of each tar fifo
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fifo_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_init_fifo_size_get_f) (
    int unit);

/**
 * \brief get table vsq_words_rjct_map entry 
 * initialization info for VSQ words reject map - defines combinations which should be turn on
 * 
 * \param [in] unit - unit #
 * \param [in] index - arbitrary index
 * 
 * \return
 *     vsq_words_rjct_map - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_vsq_words_rjct_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_init_vsq_words_rjct_map_t *(
    *dnx_data_ingr_congestion_init_vsq_words_rjct_map_get_f) (
    int unit,
    int index);

/**
 * \brief get table vsq_sram_rjct_map entry 
 * initialization info for VSQ SRAM reject map - defines combinations which should be turn on
 * 
 * \param [in] unit - unit #
 * \param [in] index - arbitrary index
 * 
 * \return
 *     vsq_sram_rjct_map - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *(
    *dnx_data_ingr_congestion_init_vsq_sram_rjct_map_get_f) (
    int unit,
    int index);

/**
 * \brief get table dp_global_sram_buffer_drop entry 
 * Amount of free sram buffer resource to cause drop per DP
 * 
 * \param [in] unit - unit #
 * \param [in] dp - DP (0-3).
 * 
 * \return
 *     dp_global_sram_buffer_drop - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t *(
    *dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_get_f) (
    int unit,
    int dp);

/**
 * \brief get table dp_global_sram_pdb_drop entry 
 * Amount of free sram pdb resource to cause drop per DP
 * 
 * \param [in] unit - unit #
 * \param [in] dp - DP (0-3).
 * 
 * \return
 *     dp_global_sram_pdb_drop - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t *(
    *dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_get_f) (
    int unit,
    int dp);

/**
 * \brief get table dp_global_dram_bdb_drop entry 
 * Amount of free dram bdb resource to cause drop per DP
 * 
 * \param [in] unit - unit #
 * \param [in] dp - DP (0-3).
 * 
 * \return
 *     dp_global_dram_bdb_drop - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t *(
    *dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_get_f) (
    int unit,
    int dp);

/**
 * \brief get table equivalent_global_drop entry 
 * Equavalent amount per VOQ resource to per-DP global drop (not configurable by user)
 * 
 * \param [in] unit - unit #
 * \param [in] type - VOQ resource
 * 
 * \return
 *     equivalent_global_drop - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_init_equivalent_global_drop_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_init_equivalent_global_drop_t *(
    *dnx_data_ingr_congestion_init_equivalent_global_drop_get_f) (
    int unit,
    int type);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_INGR_CONGESTION - INIT:
 * {
 */
/**
 * \brief Interface for ingr_congestion init data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_ingr_congestion_init_feature_get_f feature_get;
    /**
     * returns define data of fifo_size
     */
    dnx_data_ingr_congestion_init_fifo_size_get_f fifo_size_get;
    /**
     * get table vsq_words_rjct_map entry 
     */
    dnx_data_ingr_congestion_init_vsq_words_rjct_map_get_f vsq_words_rjct_map_get;
    /**
     * get general info table about table (for example key size)vsq_words_rjct_map info
     */
    dnxc_data_table_info_get_f vsq_words_rjct_map_info_get;
    /**
     * get table vsq_sram_rjct_map entry 
     */
    dnx_data_ingr_congestion_init_vsq_sram_rjct_map_get_f vsq_sram_rjct_map_get;
    /**
     * get general info table about table (for example key size)vsq_sram_rjct_map info
     */
    dnxc_data_table_info_get_f vsq_sram_rjct_map_info_get;
    /**
     * get table dp_global_sram_buffer_drop entry 
     */
    dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_get_f dp_global_sram_buffer_drop_get;
    /**
     * get general info table about table (for example key size)dp_global_sram_buffer_drop info
     */
    dnxc_data_table_info_get_f dp_global_sram_buffer_drop_info_get;
    /**
     * get table dp_global_sram_pdb_drop entry 
     */
    dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_get_f dp_global_sram_pdb_drop_get;
    /**
     * get general info table about table (for example key size)dp_global_sram_pdb_drop info
     */
    dnxc_data_table_info_get_f dp_global_sram_pdb_drop_info_get;
    /**
     * get table dp_global_dram_bdb_drop entry 
     */
    dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_get_f dp_global_dram_bdb_drop_get;
    /**
     * get general info table about table (for example key size)dp_global_dram_bdb_drop info
     */
    dnxc_data_table_info_get_f dp_global_dram_bdb_drop_info_get;
    /**
     * get table equivalent_global_drop entry 
     */
    dnx_data_ingr_congestion_init_equivalent_global_drop_get_f equivalent_global_drop_get;
    /**
     * get general info table about table (for example key size)equivalent_global_drop info
     */
    dnxc_data_table_info_get_f equivalent_global_drop_info_get;
} dnx_data_if_ingr_congestion_init_t;

/*
 * }
 */

/*
 * SUBMODULE  - DBAL:
 * dbal info
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule dbal table admission_bits_mapping
 * Table info:
 * Mapping of bits in addmission mask
 */
typedef struct
{
    /**
     * the offset of the bit in the mask
     */
    int index;
} dnx_data_ingr_congestion_dbal_admission_bits_mapping_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_dbal_feature_nof
} dnx_data_ingr_congestion_dbal_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_ingr_congestion_dbal_feature_get_f) (
    int unit,
    dnx_data_ingr_congestion_dbal_feature_e feature);

/**
 * \brief returns numeric data of admission_test_nof
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'admission_test_nof'
 * Number of admission test
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     admission_test_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dbal_admission_test_nof_get_f) (
    int unit);

/**
 * \brief returns numeric data of dram_bdbs_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'dram_bdbs_th_nof_bits'
 * Number of bits dram bdbs set/clear threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_bdbs_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dbal_dram_bdbs_th_nof_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of sram_pdbs_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_pdbs_th_nof_bits'
 * Number of bits sram pdbs set/clear threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_pdbs_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dbal_sram_pdbs_th_nof_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of sram_buffer_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_buffer_th_nof_bits'
 * Number of bits sram buffer set/clear threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_buffer_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dbal_sram_buffer_th_nof_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of sram_buffer_free_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_buffer_free_th_nof_bits'
 * Number of bits sram buffer set/clear threshold for reaching full size of the resource
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_buffer_free_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dbal_sram_buffer_free_th_nof_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of sram_pds_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_pds_th_nof_bits'
 * Number of bits sram PDs set/clear threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_pds_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dbal_sram_pds_th_nof_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of total_bytes_th_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'total_bytes_th_nof_bits'
 * Number of bits total bytes set/clear threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_bytes_th_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dbal_total_bytes_th_nof_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of dram_bdbs_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'dram_bdbs_nof_bits'
 * Number of bits for dram bdbs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_bdbs_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dbal_dram_bdbs_nof_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of sram_pdbs_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_pdbs_nof_bits'
 * Number of bits for sram pdbs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_pdbs_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dbal_sram_pdbs_nof_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of sram_buffer_nof_bits
 * Module - 'ingr_congestion', Submodule - 'dbal', data - 'sram_buffer_nof_bits'
 * Number of bits for sram buffer
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sram_buffer_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_dbal_sram_buffer_nof_bits_get_f) (
    int unit);

/**
 * \brief get table admission_bits_mapping entry 
 * Mapping of bits in addmission mask
 * 
 * \param [in] unit - unit #
 * \param [in] rjct_bit - admission bit - defined by dnx_ingress_congestion_reject_bit_e
 * 
 * \return
 *     admission_bits_mapping - returns the relevant entry values grouped in struct - see dnx_data_ingr_congestion_dbal_admission_bits_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *(
    *dnx_data_ingr_congestion_dbal_admission_bits_mapping_get_f) (
    int unit,
    int rjct_bit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_INGR_CONGESTION - DBAL:
 * {
 */
/**
 * \brief Interface for ingr_congestion dbal data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_ingr_congestion_dbal_feature_get_f feature_get;
    /**
     * returns numeric data of admission_test_nof
     */
    dnx_data_ingr_congestion_dbal_admission_test_nof_get_f admission_test_nof_get;
    /**
     * returns numeric data of dram_bdbs_th_nof_bits
     */
    dnx_data_ingr_congestion_dbal_dram_bdbs_th_nof_bits_get_f dram_bdbs_th_nof_bits_get;
    /**
     * returns numeric data of sram_pdbs_th_nof_bits
     */
    dnx_data_ingr_congestion_dbal_sram_pdbs_th_nof_bits_get_f sram_pdbs_th_nof_bits_get;
    /**
     * returns numeric data of sram_buffer_th_nof_bits
     */
    dnx_data_ingr_congestion_dbal_sram_buffer_th_nof_bits_get_f sram_buffer_th_nof_bits_get;
    /**
     * returns numeric data of sram_buffer_free_th_nof_bits
     */
    dnx_data_ingr_congestion_dbal_sram_buffer_free_th_nof_bits_get_f sram_buffer_free_th_nof_bits_get;
    /**
     * returns numeric data of sram_pds_th_nof_bits
     */
    dnx_data_ingr_congestion_dbal_sram_pds_th_nof_bits_get_f sram_pds_th_nof_bits_get;
    /**
     * returns numeric data of total_bytes_th_nof_bits
     */
    dnx_data_ingr_congestion_dbal_total_bytes_th_nof_bits_get_f total_bytes_th_nof_bits_get;
    /**
     * returns numeric data of dram_bdbs_nof_bits
     */
    dnx_data_ingr_congestion_dbal_dram_bdbs_nof_bits_get_f dram_bdbs_nof_bits_get;
    /**
     * returns numeric data of sram_pdbs_nof_bits
     */
    dnx_data_ingr_congestion_dbal_sram_pdbs_nof_bits_get_f sram_pdbs_nof_bits_get;
    /**
     * returns numeric data of sram_buffer_nof_bits
     */
    dnx_data_ingr_congestion_dbal_sram_buffer_nof_bits_get_f sram_buffer_nof_bits_get;
    /**
     * get table admission_bits_mapping entry 
     */
    dnx_data_ingr_congestion_dbal_admission_bits_mapping_get_f admission_bits_mapping_get;
    /**
     * get general info table about table (for example key size)admission_bits_mapping info
     */
    dnxc_data_table_info_get_f admission_bits_mapping_info_get;
} dnx_data_if_ingr_congestion_dbal_t;

/*
 * }
 */

/*
 * SUBMODULE  - MIRROR_ON_DROP:
 * mirror on drop feature
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indication whether mirror on drop feature is supported
     */
    dnx_data_ingr_congestion_mirror_on_drop_is_supported,

    /**
     * Must be last one!
     */
    _dnx_data_ingr_congestion_mirror_on_drop_feature_nof
} dnx_data_ingr_congestion_mirror_on_drop_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_ingr_congestion_mirror_on_drop_feature_get_f) (
    int unit,
    dnx_data_ingr_congestion_mirror_on_drop_feature_e feature);

/**
 * \brief returns define data of nof_groups
 * Module - 'ingr_congestion', Submodule - 'mirror_on_drop', data - 'nof_groups'
 * number of drop groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_mirror_on_drop_nof_groups_get_f) (
    int unit);

/**
 * \brief returns define data of aging_clocks_resolution
 * Module - 'ingr_congestion', Submodule - 'mirror_on_drop', data - 'aging_clocks_resolution'
 * resolution of aging clock cycles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aging_clocks_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_ingr_congestion_mirror_on_drop_aging_clocks_resolution_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_INGR_CONGESTION - MIRROR_ON_DROP:
 * {
 */
/**
 * \brief Interface for ingr_congestion mirror_on_drop data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_ingr_congestion_mirror_on_drop_feature_get_f feature_get;
    /**
     * returns define data of nof_groups
     */
    dnx_data_ingr_congestion_mirror_on_drop_nof_groups_get_f nof_groups_get;
    /**
     * returns define data of aging_clocks_resolution
     */
    dnx_data_ingr_congestion_mirror_on_drop_aging_clocks_resolution_get_f aging_clocks_resolution_get;
} dnx_data_if_ingr_congestion_mirror_on_drop_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_INGR_CONGESTION:
 * {
 */
/**
 * \brief Interface for ingr_congestion data
 */
typedef struct
{
    /**
     * Interface for ingr_congestion config data
     */
    dnx_data_if_ingr_congestion_config_t config;
    /**
     * Interface for ingr_congestion info data
     */
    dnx_data_if_ingr_congestion_info_t info;
    /**
     * Interface for ingr_congestion fadt_tail_drop data
     */
    dnx_data_if_ingr_congestion_fadt_tail_drop_t fadt_tail_drop;
    /**
     * Interface for ingr_congestion dram_bound data
     */
    dnx_data_if_ingr_congestion_dram_bound_t dram_bound;
    /**
     * Interface for ingr_congestion voq data
     */
    dnx_data_if_ingr_congestion_voq_t voq;
    /**
     * Interface for ingr_congestion vsq data
     */
    dnx_data_if_ingr_congestion_vsq_t vsq;
    /**
     * Interface for ingr_congestion init data
     */
    dnx_data_if_ingr_congestion_init_t init;
    /**
     * Interface for ingr_congestion dbal data
     */
    dnx_data_if_ingr_congestion_dbal_t dbal;
    /**
     * Interface for ingr_congestion mirror_on_drop data
     */
    dnx_data_if_ingr_congestion_mirror_on_drop_t mirror_on_drop;
} dnx_data_if_ingr_congestion_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_ingr_congestion_t dnx_data_ingr_congestion;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INGR_CONGESTION_H_*/
/* *INDENT-ON* */
