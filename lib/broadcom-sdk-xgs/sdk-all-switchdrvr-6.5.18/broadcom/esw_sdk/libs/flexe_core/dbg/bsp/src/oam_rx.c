

/******************************************************************************
*INCLUDE FILES
******************************************************************************/
#include "reg_operate.h"
#include "hal.h"
#include <stdio.h>
/******************************************************************************
*CONSTANT AND MACRO DEFINE
******************************************************************************/
unsigned long int oam_rx_para_debug = 0;


const CHIP_REG oam_rx_cfg_reg[]=
{
	{RX_GLB_BIPERR_BIT_CFG,OAM_RX_BASE_ADDR,0x0,0,0},
	{RX_GLB_BEIERR_BIT_CFG,OAM_RX_BASE_ADDR,0x0,1,1},
	{CRC_INVERT,OAM_RX_BASE_ADDR,0x0,3,3},
	{BYPASS_OAM_RX,OAM_RX_BASE_ADDR,0x0,4,4},
	{OAM_RX_RDI_BLK,OAM_RX_BASE_ADDR,0x0,6,5},
	{OAM_IDFY_37_34_CFG,OAM_RX_BASE_ADDR,0x0,11,8},
	{BAS_POS_CNT,OAM_RX_BASE_ADDR,0x0,13,12},
	{CRC_BASE_CNT_EN,OAM_RX_BASE_ADDR,0x0,14,14},
	{CRC_OAM_CAL_EN,OAM_RX_BASE_ADDR,0x0,15,15},
	{BYPASS_OAM_ALM_ALL,OAM_RX_BASE_ADDR,0x0,16,16},
	{OAM_RX_BASE_LOS_SEL,OAM_RX_BASE_ADDR,0x0,17,17},
	{OAM_CNT_CLR_NUM,OAM_RX_BASE_ADDR,0x0,24,18},
	{BASE_OAM_CNT_CLR_NUM,OAM_RX_BASE_ADDR,0x0,31,25},
};
const CHIP_REG rx_biperr_cnt_clr_reg[]=
{
	{RX_BIPERR_CNT_CLR_0,OAM_RX_BASE_ADDR,0x1,31,0},
	{RX_BIPERR_CNT_CLR_1,OAM_RX_BASE_ADDR,0x2,31,0},
	{RX_BIPERR_CNT_CLR_2,OAM_RX_BASE_ADDR,0x3,15,0},
};
const CHIP_REG rx_beierr_cnt_clr_reg[]=
{
	{RX_BEIERR_CNT_CLR_0,OAM_RX_BASE_ADDR,0x4,31,0},
	{RX_BEIERR_CNT_CLR_1,OAM_RX_BASE_ADDR,0x5,31,0},
	{RX_BEIERR_CNT_CLR_2,OAM_RX_BASE_ADDR,0x6,15,0},
};
const CHIP_REG rx_sdbip_reg[]=
{
	{RX_SDBIP_0,OAM_RX_BASE_ADDR,0x7,31,0},
	{RX_SDBIP_1,OAM_RX_BASE_ADDR,0x8,31,0},
	{RX_SDBIP_2,OAM_RX_BASE_ADDR,0x9,15,0},
};
const CHIP_REG rx_idle_rpl_en_reg[]=
{
	{RX_IDLE_RPL_EN_0,OAM_RX_BASE_ADDR,0xf,31,0},
	{RX_IDLE_RPL_EN_1,OAM_RX_BASE_ADDR,0x10,31,0},
	{RX_IDLE_RPL_EN_2,OAM_RX_BASE_ADDR,0x11,15,0},
};
const CHIP_REG bypass_chnl_reg[]=
{
	{BYPASS_CHNL_0,OAM_RX_BASE_ADDR,0x15,31,0},
	{BYPASS_CHNL_1,OAM_RX_BASE_ADDR,0x16,31,0},
	{BYPASS_CHNL_2,OAM_RX_BASE_ADDR,0x17,15,0},
};
const CHIP_REG period_cfg_reg[]=
{
	{PERIOD_CFG_0,OAM_RX_BASE_ADDR,0x18,31,0},
	{PERIOD_CFG_1,OAM_RX_BASE_ADDR,0x19,31,0},
	{PERIOD_CFG_2,OAM_RX_BASE_ADDR,0x1a,31,0},
	{PERIOD_CFG_3,OAM_RX_BASE_ADDR,0x1b,31,0},
	{PERIOD_CFG_4,OAM_RX_BASE_ADDR,0x1c,31,0},
};
const CHIP_REG period_sel_reg[]=
{
	{PERIOD_SEL_0,OAM_RX_BASE_ADDR,0x1d,31,0},
	{PERIOD_SEL_1,OAM_RX_BASE_ADDR,0x1e,31,0},
	{PERIOD_SEL_2,OAM_RX_BASE_ADDR,0x1f,31,0},
	{PERIOD_SEL_3,OAM_RX_BASE_ADDR,0x20,31,0},
	{PERIOD_SEL_4,OAM_RX_BASE_ADDR,0x21,31,0},
};
const CHIP_REG oam_clr_ram_init_reg[]=
{
	{OAM_CNT_CLR,OAM_RX_BASE_ADDR,0x24,0,0},
	{OAM_CNT_ALL_CLR,OAM_RX_BASE_ADDR,0x24,1,1},
	{OAMRX_TS_RAM_INIT,OAM_RX_BASE_ADDR,0x24,2,2},
	{BASE_OAM_CNT_CLR,OAM_RX_BASE_ADDR,0x24,3,3},
	{BASE_OAM_CNT_ALL_CLR,OAM_RX_BASE_ADDR,0x24,4,4},
	{BASE_OAM_RAM_CLR,OAM_RX_BASE_ADDR,0x24,5,5},
	{FIFO_CNT_CLR,OAM_RX_BASE_ADDR,0x24,6,6},
};
const CHIP_REG oam_cnt_clr_done_reg[]=
{
	{OAM_CNT_CLR_DONE,OAM_RX_BASE_ADDR,0x26,0,0},
	{OAMRX_TS_RAM_INIT_DONE,OAM_RX_BASE_ADDR,0x26,1,1},
	{BASE_OAM_CNT_CLR_DONE,OAM_RX_BASE_ADDR,0x26,2,2},
	{FIFO_CNT_MAX,OAM_RX_BASE_ADDR,0x26,14,4},
};
const CHIP_REG oam_rx_alm_en_reg[]=
{
    {BASE_LOS_ALM_EN,OAM_RX_BASE_ADDR,0x28,0,0},
    {BAS_CS_LF_ALM_EN,OAM_RX_BASE_ADDR,0x28,1,1},
    {BAS_CS_RF_ALM_EN,OAM_RX_BASE_ADDR,0x28,2,2},
    {BAS_CSF_LPI_ALM_EN,OAM_RX_BASE_ADDR,0x28,3,3},
    {SDBIP_ALM_EN,OAM_RX_BASE_ADDR,0x28,4,4},
    {SDBEI_ALM_EN,OAM_RX_BASE_ADDR,0x28,5,5},
    {CLIENT_LF_ALM_EN,OAM_RX_BASE_ADDR,0x28,6,6},
    {CLIENT_RF_ALM_EN,OAM_RX_BASE_ADDR,0x28,7,7},
    {CLIENT_LPI_ALM_EN,OAM_RX_BASE_ADDR,0x28,8,8},
    {BAS_RDI_ALM_EN,OAM_RX_BASE_ADDR,0x28,9,9},
    {CLIENT_FAIL_ALM_EN,OAM_RX_BASE_ADDR,0x28,10,10},
    {TX_SDBIP_ALM_EN,OAM_RX_BASE_ADDR,0x28,11,11},
    {TX_SDBEI_ALM_EN,OAM_RX_BASE_ADDR,0x28,12,12},
    {TX_BASE_LOS_ALM_EN,OAM_RX_BASE_ADDR,0x28,13,13},
    {TX_BAS_PERIOD_ALM_EN,OAM_RX_BASE_ADDR,0x28,14,14},
    {TX_CLIENT_LF_ALM_EN,OAM_RX_BASE_ADDR,0x28,15,15},
    {TX_CLIENT_RF_ALM_EN,OAM_RX_BASE_ADDR,0x28,16,16},
    {TX_CLIENT_LPI_ALM_EN,OAM_RX_BASE_ADDR,0x28,17,17},   
	{RX_LPI_ALM_EN,OAM_RX_BASE_ADDR,0x28,18,18},	
	{TX_SFBIP_ALM_EN,OAM_RX_BASE_ADDR,0x28,19,19},	
	{TX_SFBEI_ALM_EN,OAM_RX_BASE_ADDR,0x28,20,20},
	{SFBIP_ALM_EN,OAM_RX_BASE_ADDR,0x28,21,21},
	{SFBEI_ALM_EN,OAM_RX_BASE_ADDR,0x28,22,22},
	{BAS_PERIOD_ALM_EN,OAM_RX_BASE_ADDR,0x28,23,23},
};
const CHIP_REG base_period_reg[]=
{
	{BASE_PERIOD_0,OAM_RX_BASE_ADDR,0x39,31,0},
	{BASE_PERIOD_1,OAM_RX_BASE_ADDR,0x3a,31,0},
	{BASE_PERIOD_2,OAM_RX_BASE_ADDR,0x3b,31,0},
	{BASE_PERIOD_3,OAM_RX_BASE_ADDR,0x3c,31,0},
	{BASE_PERIOD_4,OAM_RX_BASE_ADDR,0x3d,31,0},
};
const CHIP_REG demux_client_alm_reg[]=
{
	{DEMUX_CLIENT_ALM_0,OAM_RX_BASE_ADDR,0x3e,31,0},
	{DEMUX_CLIENT_ALM_1,OAM_RX_BASE_ADDR,0x3f,31,0},
	{DEMUX_CLIENT_ALM_2,OAM_RX_BASE_ADDR,0x40,15,0},
};
const CHIP_REG oam_rx_rdi_reg[]=
{
	{OAM_RX_RDI,OAM_RX_BASE_ADDR,0x22,19,0},
	{OAM_RX_FULL_1,OAM_RX_BASE_ADDR,0x22,20,20},
	{ECC_ERR_CORRECT,OAM_RX_BASE_ADDR,0x22,21,21},
	{ECC_ERR_UNCORRECT,OAM_RX_BASE_ADDR,0x22,22,22},
};
const CHIP_REG rx_sfbip_reg[]=
{
	{RX_SFBIP_0,OAM_RX_BASE_ADDR,0x12,31,0},
	{RX_SFBIP_1,OAM_RX_BASE_ADDR,0x13,31,0},
	{RX_SFBIP_2,OAM_RX_BASE_ADDR,0x14,15,0},
};
const CHIP_REG rx_sfbei_reg[]=
{
	{RX_SFBEI_0,OAM_RX_BASE_ADDR,0x29,31,0},
	{RX_SFBEI_1,OAM_RX_BASE_ADDR,0x2a,31,0},
	{RX_SFBEI_2,OAM_RX_BASE_ADDR,0x2b,15,0},
};
const CHIP_REG crc_alm_out_reg[]=
{
	{CRC_ALM_OUT_0,OAM_RX_BASE_ADDR,0x41,31,0},
	{CRC_ALM_OUT_1,OAM_RX_BASE_ADDR,0x42,31,0},
	{CRC_ALM_OUT_2,OAM_RX_BASE_ADDR,0x43,15,0},
};
const CHIP_REG bas_rdi_reg[]=
{
	{BAS_RDI_0,OAM_RX_BASE_ADDR,0x44,31,0},
	{BAS_RDI_1,OAM_RX_BASE_ADDR,0x45,31,0},
	{BAS_RDI_2,OAM_RX_BASE_ADDR,0x46,15,0},
};
const CHIP_REG bas_csf_lpi_reg[]=
{
	{BAS_CSF_LPI_0,OAM_RX_BASE_ADDR,0x47,31,0},
	{BAS_CSF_LPI_1,OAM_RX_BASE_ADDR,0x48,31,0},
	{BAS_CSF_LPI_2,OAM_RX_BASE_ADDR,0x49,15,0},
};
const CHIP_REG bas_cs_lf_reg[]=
{
	{BAS_CS_LF_0,OAM_RX_BASE_ADDR,0x4a,31,0},
	{BAS_CS_LF_1,OAM_RX_BASE_ADDR,0x4b,31,0},
	{BAS_CS_LF_2,OAM_RX_BASE_ADDR,0x4c,15,0},
};
const CHIP_REG bas_cs_rf_reg[]=
{
	{BAS_CS_RF_0,OAM_RX_BASE_ADDR,0x4d,31,0},
	{BAS_CS_RF_1,OAM_RX_BASE_ADDR,0x4e,31,0},
	{BAS_CS_RF_2,OAM_RX_BASE_ADDR,0x4f,15,0},
};
const CHIP_REG bas_crc_err_reg[]=
{
	{BAS_CRC_ERR_0,OAM_RX_BASE_ADDR,0x50,31,0},
	{BAS_CRC_ERR_1,OAM_RX_BASE_ADDR,0x51,31,0},
	{BAS_CRC_ERR_2,OAM_RX_BASE_ADDR,0x52,15,0},
};
const CHIP_REG bas_no_receive_alm_reg[]=
{
	{BAS_NO_RECEIVE_ALM_0,OAM_RX_BASE_ADDR,0x53,31,0},
	{BAS_NO_RECEIVE_ALM_1,OAM_RX_BASE_ADDR,0x54,31,0},
	{BAS_NO_RECEIVE_ALM_2,OAM_RX_BASE_ADDR,0x55,15,0},
};
const CHIP_REG rdi_lf_reg[]=
{
	{RDI_LF_0,OAM_RX_BASE_ADDR,0x56,31,0},
	{RDI_LF_1,OAM_RX_BASE_ADDR,0x57,31,0},
	{RDI_LF_2,OAM_RX_BASE_ADDR,0x58,15,0},
};
const CHIP_REG rx_sdbei_reg[]=
{
	{RX_SDBEI_0,OAM_RX_BASE_ADDR,0x5b,31,0},
	{RX_SDBEI_1,OAM_RX_BASE_ADDR,0x5c,31,0},
	{RX_SDBEI_2,OAM_RX_BASE_ADDR,0x5d,15,0},
};
const CHIP_REG rf_alm_reg[]=
{
	{RF_ALM_0,OAM_RX_BASE_ADDR,0x5e,31,0},
	{RF_ALM_1,OAM_RX_BASE_ADDR,0x5f,31,0},
	{RF_ALM_2,OAM_RX_BASE_ADDR,0x60,15,0},
};
const CHIP_REG lpi_alm_reg[]=
{
	{LPI_ALM_0,OAM_RX_BASE_ADDR,0x61,31,0},
	{LPI_ALM_1,OAM_RX_BASE_ADDR,0x62,31,0},
	{LPI_ALM_2,OAM_RX_BASE_ADDR,0x63,15,0},
};
const CHIP_REG bypass_xgmii_reg[]=
{
	{BYPASS_XGMII_0,OAM_RX_BASE_ADDR,0x68,31,0},
	{BYPASS_XGMII_1,OAM_RX_BASE_ADDR,0x69,31,0},
	{BYPASS_XGMII_2,OAM_RX_BASE_ADDR,0x6a,15,0},
};
const CHIP_REG rx_lpi_rpl_en_reg[]=
{
	{RX_LPI_RPL_EN_0,OAM_RX_BASE_ADDR,0x6b,31,0},
	{RX_LPI_RPL_EN_1,OAM_RX_BASE_ADDR,0x6c,31,0},
	{RX_LPI_RPL_EN_2,OAM_RX_BASE_ADDR,0x6d,15,0},
};
const CHIP_REG bas_period_a_REG[]=
{
	{BAS_PERIOD_0,OAM_RX_BASE_ADDR,0x6f,9,0},
	{BAS_PERIOD_1,OAM_RX_BASE_ADDR,0x6f,21,12},
};
const CHIP_REG bas_period_b_REG[]=
{
	{BAS_PERIOD_2,OAM_RX_BASE_ADDR,0x70,9,0},
	{BAS_PERIOD_3,OAM_RX_BASE_ADDR,0x70,21,12},
};
const CHIP_REG bypass_oam_alm_ch_REG[]=
{
	{BYPASS_OAM_ALM_CH_0,OAM_RX_BASE_ADDR,0x72,31,0},
	{BYPASS_OAM_ALM_CH_1,OAM_RX_BASE_ADDR,0x73,31,0},
	{BYPASS_OAM_ALM_CH_2,OAM_RX_BASE_ADDR,0x74,15,0},
};
const CHIP_REG bas_period_alm_REG[]=
{
	{BAS_PERIOD_ALM_0,OAM_RX_BASE_ADDR,0x77,31,0},
	{BAS_PERIOD_ALM_1,OAM_RX_BASE_ADDR,0x78,31,0},
	{BAS_PERIOD_ALM_2,OAM_RX_BASE_ADDR,0x79,15,0},
};
const CHIP_REG oam_rx_config_reg[]=
{
	{BAS_RAM_CLR_CH,OAM_RX_BASE_ADDR,0x7e,6,0},
	{TIMESTAMP_SEL,OAM_RX_BASE_ADDR,0x7e,8,8},
	{OAM_RX_LPI_PRE_CNT,OAM_RX_BASE_ADDR,0x7e,14,12},
	{OAM_RX_LPI_POS_CNT,OAM_RX_BASE_ADDR,0x7e,18,16},
	{BASE_LOS_RPL_EN,OAM_RX_BASE_ADDR,0x7e,9,9},
	{BIP_RECAL_EN,OAM_RX_BASE_ADDR,0x7e,10,10},
	{BASE_BIP_CRC_EN,OAM_RX_BASE_ADDR,0x7e,11,11},
};
const CHIP_REG oam_type_bip_cal_en_reg[]=
{
	{OAM_TYPE_BIP_CAL_EN_0,OAM_RX_BASE_ADDR,0x7f,31,0},
	{OAM_TYPE_BIP_CAL_EN_1,OAM_RX_BASE_ADDR,0x8c,31,16},
	{OAM_TYPE_BIP_CAL_EN_2,OAM_RX_BASE_ADDR,0x8f,31,16},
};
const CHIP_REG lf_manual_insert_reg[]=
{
	{LF_MANUAL_INSERT_0,OAM_RX_BASE_ADDR,0x8a,31,0},
	{LF_MANUAL_INSERT_1,OAM_RX_BASE_ADDR,0x8b,31,0},
	{LF_MANUAL_INSERT_2,OAM_RX_BASE_ADDR,0x8c,15,0},
};
const CHIP_REG rf_manual_insert_reg[]=
{
	{RF_MANUAL_INSERT_0,OAM_RX_BASE_ADDR,0x8d,31,0},
	{RF_MANUAL_INSERT_1,OAM_RX_BASE_ADDR,0x8e,31,0},
	{RF_MANUAL_INSERT_2,OAM_RX_BASE_ADDR,0x8f,15,0},
};
const CHIP_REG lpi_manual_insert_reg[]=
{
	{LPI_MANUAL_INSERT_0,OAM_RX_BASE_ADDR,0x90,31,0},
	{LPI_MANUAL_INSERT_1,OAM_RX_BASE_ADDR,0x91,31,0},
	{LPI_MANUAL_INSERT_2,OAM_RX_BASE_ADDR,0x92,15,0},
};
const CHIP_REG rx_sfbei_i0_INT_REG[]=
{
	{RX_SFBEI_0_INT,OAM_RX_BASE_ADDR,0x25,1,0},
	{RX_SFBEI_1_INT,OAM_RX_BASE_ADDR,0x25,3,2},
	{RX_SFBEI_2_INT,OAM_RX_BASE_ADDR,0x25,5,4},
	{RX_SFBEI_3_INT,OAM_RX_BASE_ADDR,0x25,7,6},
	{RX_SFBEI_4_INT,OAM_RX_BASE_ADDR,0x25,9,8},
	{RX_SFBEI_5_INT,OAM_RX_BASE_ADDR,0x25,11,10},
	{RX_SFBEI_6_INT,OAM_RX_BASE_ADDR,0x25,13,12},
	{RX_SFBEI_7_INT,OAM_RX_BASE_ADDR,0x25,15,14},
	{RX_SFBEI_8_INT,OAM_RX_BASE_ADDR,0x25,17,16},
	{RX_SFBEI_9_INT,OAM_RX_BASE_ADDR,0x25,19,18},
	{RX_SFBEI_10_INT,OAM_RX_BASE_ADDR,0x25,21,20},
	{RX_SFBEI_11_INT,OAM_RX_BASE_ADDR,0x25,23,22},
	{RX_SFBEI_12_INT,OAM_RX_BASE_ADDR,0x25,25,24},
	{RX_SFBEI_13_INT,OAM_RX_BASE_ADDR,0x25,27,26},
	{RX_SFBEI_14_INT,OAM_RX_BASE_ADDR,0x25,29,28},
	{RX_SFBEI_15_INT,OAM_RX_BASE_ADDR,0x25,31,30},
};
const CHIP_REG rx_sfbei_i0_INT_MASK_REG[]=
{
	{RX_SFBEI_0_INT_MASK,OAM_RX_BASE_ADDR,0x27,1,0},
	{RX_SFBEI_1_INT_MASK,OAM_RX_BASE_ADDR,0x27,3,2},
	{RX_SFBEI_2_INT_MASK,OAM_RX_BASE_ADDR,0x27,5,4},
	{RX_SFBEI_3_INT_MASK,OAM_RX_BASE_ADDR,0x27,7,6},
	{RX_SFBEI_4_INT_MASK,OAM_RX_BASE_ADDR,0x27,9,8},
	{RX_SFBEI_5_INT_MASK,OAM_RX_BASE_ADDR,0x27,11,10},
	{RX_SFBEI_6_INT_MASK,OAM_RX_BASE_ADDR,0x27,13,12},
	{RX_SFBEI_7_INT_MASK,OAM_RX_BASE_ADDR,0x27,15,14},
	{RX_SFBEI_8_INT_MASK,OAM_RX_BASE_ADDR,0x27,17,16},
	{RX_SFBEI_9_INT_MASK,OAM_RX_BASE_ADDR,0x27,19,18},
	{RX_SFBEI_10_INT_MASK,OAM_RX_BASE_ADDR,0x27,21,20},
	{RX_SFBEI_11_INT_MASK,OAM_RX_BASE_ADDR,0x27,23,22},
	{RX_SFBEI_12_INT_MASK,OAM_RX_BASE_ADDR,0x27,25,24},
	{RX_SFBEI_13_INT_MASK,OAM_RX_BASE_ADDR,0x27,27,26},
	{RX_SFBEI_14_INT_MASK,OAM_RX_BASE_ADDR,0x27,29,28},
	{RX_SFBEI_15_INT_MASK,OAM_RX_BASE_ADDR,0x27,31,30},
};
const CHIP_REG rx_sfbip_i0_INT_REG[]=
{
	{RX_SFBIP_0_INT,OAM_RX_BASE_ADDR,0x2c,1,0},
	{RX_SFBIP_1_INT,OAM_RX_BASE_ADDR,0x2c,3,2},
	{RX_SFBIP_2_INT,OAM_RX_BASE_ADDR,0x2c,5,4},
	{RX_SFBIP_3_INT,OAM_RX_BASE_ADDR,0x2c,7,6},
	{RX_SFBIP_4_INT,OAM_RX_BASE_ADDR,0x2c,9,8},
	{RX_SFBIP_5_INT,OAM_RX_BASE_ADDR,0x2c,11,10},
	{RX_SFBIP_6_INT,OAM_RX_BASE_ADDR,0x2c,13,12},
	{RX_SFBIP_7_INT,OAM_RX_BASE_ADDR,0x2c,15,14},
	{RX_SFBIP_8_INT,OAM_RX_BASE_ADDR,0x2c,17,16},
	{RX_SFBIP_9_INT,OAM_RX_BASE_ADDR,0x2c,19,18},
	{RX_SFBIP_10_INT,OAM_RX_BASE_ADDR,0x2c,21,20},
	{RX_SFBIP_11_INT,OAM_RX_BASE_ADDR,0x2c,23,22},
	{RX_SFBIP_12_INT,OAM_RX_BASE_ADDR,0x2c,25,24},
	{RX_SFBIP_13_INT,OAM_RX_BASE_ADDR,0x2c,27,26},
	{RX_SFBIP_14_INT,OAM_RX_BASE_ADDR,0x2c,29,28},
	{RX_SFBIP_15_INT,OAM_RX_BASE_ADDR,0x2c,31,30},
};
const CHIP_REG rx_sfbip_i0_INT_MASK_REG[]=
{
	{RX_SFBIP_0_INT_MASK,OAM_RX_BASE_ADDR,0x2d,1,0},
	{RX_SFBIP_1_INT_MASK,OAM_RX_BASE_ADDR,0x2d,3,2},
	{RX_SFBIP_2_INT_MASK,OAM_RX_BASE_ADDR,0x2d,5,4},
	{RX_SFBIP_3_INT_MASK,OAM_RX_BASE_ADDR,0x2d,7,6},
	{RX_SFBIP_4_INT_MASK,OAM_RX_BASE_ADDR,0x2d,9,8},
	{RX_SFBIP_5_INT_MASK,OAM_RX_BASE_ADDR,0x2d,11,10},
	{RX_SFBIP_6_INT_MASK,OAM_RX_BASE_ADDR,0x2d,13,12},
	{RX_SFBIP_7_INT_MASK,OAM_RX_BASE_ADDR,0x2d,15,14},
	{RX_SFBIP_8_INT_MASK,OAM_RX_BASE_ADDR,0x2d,17,16},
	{RX_SFBIP_9_INT_MASK,OAM_RX_BASE_ADDR,0x2d,19,18},
	{RX_SFBIP_10_INT_MASK,OAM_RX_BASE_ADDR,0x2d,21,20},
	{RX_SFBIP_11_INT_MASK,OAM_RX_BASE_ADDR,0x2d,23,22},
	{RX_SFBIP_12_INT_MASK,OAM_RX_BASE_ADDR,0x2d,25,24},
	{RX_SFBIP_13_INT_MASK,OAM_RX_BASE_ADDR,0x2d,27,26},
	{RX_SFBIP_14_INT_MASK,OAM_RX_BASE_ADDR,0x2d,29,28},
	{RX_SFBIP_15_INT_MASK,OAM_RX_BASE_ADDR,0x2d,31,30},
};
const CHIP_REG rx_sfbip_i1_INT_REG[]=
{
	{RX_SFBIP_16_INT,OAM_RX_BASE_ADDR,0x2e,1,0},
	{RX_SFBIP_17_INT,OAM_RX_BASE_ADDR,0x2e,3,2},
	{RX_SFBIP_18_INT,OAM_RX_BASE_ADDR,0x2e,5,4},
	{RX_SFBIP_19_INT,OAM_RX_BASE_ADDR,0x2e,7,6},
	{RX_SFBIP_20_INT,OAM_RX_BASE_ADDR,0x2e,9,8},
	{RX_SFBIP_21_INT,OAM_RX_BASE_ADDR,0x2e,11,10},
	{RX_SFBIP_22_INT,OAM_RX_BASE_ADDR,0x2e,13,12},
	{RX_SFBIP_23_INT,OAM_RX_BASE_ADDR,0x2e,15,14},
	{RX_SFBIP_24_INT,OAM_RX_BASE_ADDR,0x2e,17,16},
	{RX_SFBIP_25_INT,OAM_RX_BASE_ADDR,0x2e,19,18},
	{RX_SFBIP_26_INT,OAM_RX_BASE_ADDR,0x2e,21,20},
	{RX_SFBIP_27_INT,OAM_RX_BASE_ADDR,0x2e,23,22},
	{RX_SFBIP_28_INT,OAM_RX_BASE_ADDR,0x2e,25,24},
	{RX_SFBIP_29_INT,OAM_RX_BASE_ADDR,0x2e,27,26},
	{RX_SFBIP_30_INT,OAM_RX_BASE_ADDR,0x2e,29,28},
	{RX_SFBIP_31_INT,OAM_RX_BASE_ADDR,0x2e,31,30},
};
const CHIP_REG rx_sfbip_i1_INT_MASK_REG[]=
{
	{RX_SFBIP_16_INT_MASK,OAM_RX_BASE_ADDR,0x2f,1,0},
	{RX_SFBIP_17_INT_MASK,OAM_RX_BASE_ADDR,0x2f,3,2},
	{RX_SFBIP_18_INT_MASK,OAM_RX_BASE_ADDR,0x2f,5,4},
	{RX_SFBIP_19_INT_MASK,OAM_RX_BASE_ADDR,0x2f,7,6},
	{RX_SFBIP_20_INT_MASK,OAM_RX_BASE_ADDR,0x2f,9,8},
	{RX_SFBIP_21_INT_MASK,OAM_RX_BASE_ADDR,0x2f,11,10},
	{RX_SFBIP_22_INT_MASK,OAM_RX_BASE_ADDR,0x2f,13,12},
	{RX_SFBIP_23_INT_MASK,OAM_RX_BASE_ADDR,0x2f,15,14},
	{RX_SFBIP_24_INT_MASK,OAM_RX_BASE_ADDR,0x2f,17,16},
	{RX_SFBIP_25_INT_MASK,OAM_RX_BASE_ADDR,0x2f,19,18},
	{RX_SFBIP_26_INT_MASK,OAM_RX_BASE_ADDR,0x2f,21,20},
	{RX_SFBIP_27_INT_MASK,OAM_RX_BASE_ADDR,0x2f,23,22},
	{RX_SFBIP_28_INT_MASK,OAM_RX_BASE_ADDR,0x2f,25,24},
	{RX_SFBIP_29_INT_MASK,OAM_RX_BASE_ADDR,0x2f,27,26},
	{RX_SFBIP_30_INT_MASK,OAM_RX_BASE_ADDR,0x2f,29,28},
	{RX_SFBIP_31_INT_MASK,OAM_RX_BASE_ADDR,0x2f,31,30},
};
const CHIP_REG rx_sfbip_i2_INT_REG[]=
{
	{RX_SFBIP_32_INT,OAM_RX_BASE_ADDR,0x30,1,0},
	{RX_SFBIP_33_INT,OAM_RX_BASE_ADDR,0x30,3,2},
	{RX_SFBIP_34_INT,OAM_RX_BASE_ADDR,0x30,5,4},
	{RX_SFBIP_35_INT,OAM_RX_BASE_ADDR,0x30,7,6},
	{RX_SFBIP_36_INT,OAM_RX_BASE_ADDR,0x30,9,8},
	{RX_SFBIP_37_INT,OAM_RX_BASE_ADDR,0x30,11,10},
	{RX_SFBIP_38_INT,OAM_RX_BASE_ADDR,0x30,13,12},
	{RX_SFBIP_39_INT,OAM_RX_BASE_ADDR,0x30,15,14},
	{RX_SFBIP_40_INT,OAM_RX_BASE_ADDR,0x30,17,16},
	{RX_SFBIP_41_INT,OAM_RX_BASE_ADDR,0x30,19,18},
	{RX_SFBIP_42_INT,OAM_RX_BASE_ADDR,0x30,21,20},
	{RX_SFBIP_43_INT,OAM_RX_BASE_ADDR,0x30,23,22},
	{RX_SFBIP_44_INT,OAM_RX_BASE_ADDR,0x30,25,24},
	{RX_SFBIP_45_INT,OAM_RX_BASE_ADDR,0x30,27,26},
	{RX_SFBIP_46_INT,OAM_RX_BASE_ADDR,0x30,29,28},
	{RX_SFBIP_47_INT,OAM_RX_BASE_ADDR,0x30,31,30},
};
const CHIP_REG rx_sfbip_i2_INT_MASK_REG[]=
{
	{RX_SFBIP_32_INT_MASK,OAM_RX_BASE_ADDR,0x31,1,0},
	{RX_SFBIP_33_INT_MASK,OAM_RX_BASE_ADDR,0x31,3,2},
	{RX_SFBIP_34_INT_MASK,OAM_RX_BASE_ADDR,0x31,5,4},
	{RX_SFBIP_35_INT_MASK,OAM_RX_BASE_ADDR,0x31,7,6},
	{RX_SFBIP_36_INT_MASK,OAM_RX_BASE_ADDR,0x31,9,8},
	{RX_SFBIP_37_INT_MASK,OAM_RX_BASE_ADDR,0x31,11,10},
	{RX_SFBIP_38_INT_MASK,OAM_RX_BASE_ADDR,0x31,13,12},
	{RX_SFBIP_39_INT_MASK,OAM_RX_BASE_ADDR,0x31,15,14},
	{RX_SFBIP_40_INT_MASK,OAM_RX_BASE_ADDR,0x31,17,16},
	{RX_SFBIP_41_INT_MASK,OAM_RX_BASE_ADDR,0x31,19,18},
	{RX_SFBIP_42_INT_MASK,OAM_RX_BASE_ADDR,0x31,21,20},
	{RX_SFBIP_43_INT_MASK,OAM_RX_BASE_ADDR,0x31,23,22},
	{RX_SFBIP_44_INT_MASK,OAM_RX_BASE_ADDR,0x31,25,24},
	{RX_SFBIP_45_INT_MASK,OAM_RX_BASE_ADDR,0x31,27,26},
	{RX_SFBIP_46_INT_MASK,OAM_RX_BASE_ADDR,0x31,29,28},
	{RX_SFBIP_47_INT_MASK,OAM_RX_BASE_ADDR,0x31,31,30},
};
const CHIP_REG rx_sfbip_i3_INT_REG[]=
{
	{RX_SFBIP_48_INT,OAM_RX_BASE_ADDR,0x32,1,0},
	{RX_SFBIP_49_INT,OAM_RX_BASE_ADDR,0x32,3,2},
	{RX_SFBIP_50_INT,OAM_RX_BASE_ADDR,0x32,5,4},
	{RX_SFBIP_51_INT,OAM_RX_BASE_ADDR,0x32,7,6},
	{RX_SFBIP_52_INT,OAM_RX_BASE_ADDR,0x32,9,8},
	{RX_SFBIP_53_INT,OAM_RX_BASE_ADDR,0x32,11,10},
	{RX_SFBIP_54_INT,OAM_RX_BASE_ADDR,0x32,13,12},
	{RX_SFBIP_55_INT,OAM_RX_BASE_ADDR,0x32,15,14},
	{RX_SFBIP_56_INT,OAM_RX_BASE_ADDR,0x32,17,16},
	{RX_SFBIP_57_INT,OAM_RX_BASE_ADDR,0x32,19,18},
	{RX_SFBIP_58_INT,OAM_RX_BASE_ADDR,0x32,21,20},
	{RX_SFBIP_59_INT,OAM_RX_BASE_ADDR,0x32,23,22},
	{RX_SFBIP_60_INT,OAM_RX_BASE_ADDR,0x32,25,24},
	{RX_SFBIP_61_INT,OAM_RX_BASE_ADDR,0x32,27,26},
	{RX_SFBIP_62_INT,OAM_RX_BASE_ADDR,0x32,29,28},
	{RX_SFBIP_63_INT,OAM_RX_BASE_ADDR,0x32,31,30},
};
const CHIP_REG rx_sfbip_i3_INT_MASK_REG[]=
{
	{RX_SFBIP_48_INT_MASK,OAM_RX_BASE_ADDR,0x33,1,0},
	{RX_SFBIP_49_INT_MASK,OAM_RX_BASE_ADDR,0x33,3,2},
	{RX_SFBIP_50_INT_MASK,OAM_RX_BASE_ADDR,0x33,5,4},
	{RX_SFBIP_51_INT_MASK,OAM_RX_BASE_ADDR,0x33,7,6},
	{RX_SFBIP_52_INT_MASK,OAM_RX_BASE_ADDR,0x33,9,8},
	{RX_SFBIP_53_INT_MASK,OAM_RX_BASE_ADDR,0x33,11,10},
	{RX_SFBIP_54_INT_MASK,OAM_RX_BASE_ADDR,0x33,13,12},
	{RX_SFBIP_55_INT_MASK,OAM_RX_BASE_ADDR,0x33,15,14},
	{RX_SFBIP_56_INT_MASK,OAM_RX_BASE_ADDR,0x33,17,16},
	{RX_SFBIP_57_INT_MASK,OAM_RX_BASE_ADDR,0x33,19,18},
	{RX_SFBIP_58_INT_MASK,OAM_RX_BASE_ADDR,0x33,21,20},
	{RX_SFBIP_59_INT_MASK,OAM_RX_BASE_ADDR,0x33,23,22},
	{RX_SFBIP_60_INT_MASK,OAM_RX_BASE_ADDR,0x33,25,24},
	{RX_SFBIP_61_INT_MASK,OAM_RX_BASE_ADDR,0x33,27,26},
	{RX_SFBIP_62_INT_MASK,OAM_RX_BASE_ADDR,0x33,29,28},
	{RX_SFBIP_63_INT_MASK,OAM_RX_BASE_ADDR,0x33,31,30},
};
const CHIP_REG rx_sfbip_i4_INT_REG[]=
{
	{RX_SFBIP_64_INT,OAM_RX_BASE_ADDR,0x34,1,0},
	{RX_SFBIP_65_INT,OAM_RX_BASE_ADDR,0x34,3,2},
	{RX_SFBIP_66_INT,OAM_RX_BASE_ADDR,0x34,5,4},
	{RX_SFBIP_67_INT,OAM_RX_BASE_ADDR,0x34,7,6},
	{RX_SFBIP_68_INT,OAM_RX_BASE_ADDR,0x34,9,8},
	{RX_SFBIP_69_INT,OAM_RX_BASE_ADDR,0x34,11,10},
	{RX_SFBIP_70_INT,OAM_RX_BASE_ADDR,0x34,13,12},
	{RX_SFBIP_71_INT,OAM_RX_BASE_ADDR,0x34,15,14},
	{RX_SFBIP_72_INT,OAM_RX_BASE_ADDR,0x34,17,16},
	{RX_SFBIP_73_INT,OAM_RX_BASE_ADDR,0x34,19,18},
	{RX_SFBIP_74_INT,OAM_RX_BASE_ADDR,0x34,21,20},
	{RX_SFBIP_75_INT,OAM_RX_BASE_ADDR,0x34,23,22},
	{RX_SFBIP_76_INT,OAM_RX_BASE_ADDR,0x34,25,24},
	{RX_SFBIP_77_INT,OAM_RX_BASE_ADDR,0x34,27,26},
	{RX_SFBIP_78_INT,OAM_RX_BASE_ADDR,0x34,29,28},
	{RX_SFBIP_79_INT,OAM_RX_BASE_ADDR,0x34,31,30},
};
const CHIP_REG rx_sfbip_i4_INT_MASK_REG[]=
{
	{RX_SFBIP_64_INT_MASK,OAM_RX_BASE_ADDR,0x35,1,0},
	{RX_SFBIP_65_INT_MASK,OAM_RX_BASE_ADDR,0x35,3,2},
	{RX_SFBIP_66_INT_MASK,OAM_RX_BASE_ADDR,0x35,5,4},
	{RX_SFBIP_67_INT_MASK,OAM_RX_BASE_ADDR,0x35,7,6},
	{RX_SFBIP_68_INT_MASK,OAM_RX_BASE_ADDR,0x35,9,8},
	{RX_SFBIP_69_INT_MASK,OAM_RX_BASE_ADDR,0x35,11,10},
	{RX_SFBIP_70_INT_MASK,OAM_RX_BASE_ADDR,0x35,13,12},
	{RX_SFBIP_71_INT_MASK,OAM_RX_BASE_ADDR,0x35,15,14},
	{RX_SFBIP_72_INT_MASK,OAM_RX_BASE_ADDR,0x35,17,16},
	{RX_SFBIP_73_INT_MASK,OAM_RX_BASE_ADDR,0x35,19,18},
	{RX_SFBIP_74_INT_MASK,OAM_RX_BASE_ADDR,0x35,21,20},
	{RX_SFBIP_75_INT_MASK,OAM_RX_BASE_ADDR,0x35,23,22},
	{RX_SFBIP_76_INT_MASK,OAM_RX_BASE_ADDR,0x35,25,24},
	{RX_SFBIP_77_INT_MASK,OAM_RX_BASE_ADDR,0x35,27,26},
	{RX_SFBIP_78_INT_MASK,OAM_RX_BASE_ADDR,0x35,29,28},
	{RX_SFBIP_79_INT_MASK,OAM_RX_BASE_ADDR,0x35,31,30},
};
const CHIP_REG rx_sfbei_i1_INT_REG[]=
{
	{RX_SFBEI_16_INT,OAM_RX_BASE_ADDR,0x36,1,0},
	{RX_SFBEI_17_INT,OAM_RX_BASE_ADDR,0x36,3,2},
	{RX_SFBEI_18_INT,OAM_RX_BASE_ADDR,0x36,5,4},
	{RX_SFBEI_19_INT,OAM_RX_BASE_ADDR,0x36,7,6},
	{RX_SFBEI_20_INT,OAM_RX_BASE_ADDR,0x36,9,8},
	{RX_SFBEI_21_INT,OAM_RX_BASE_ADDR,0x36,11,10},
	{RX_SFBEI_22_INT,OAM_RX_BASE_ADDR,0x36,13,12},
	{RX_SFBEI_23_INT,OAM_RX_BASE_ADDR,0x36,15,14},
	{RX_SFBEI_24_INT,OAM_RX_BASE_ADDR,0x36,17,16},
	{RX_SFBEI_25_INT,OAM_RX_BASE_ADDR,0x36,19,18},
	{RX_SFBEI_26_INT,OAM_RX_BASE_ADDR,0x36,21,20},
	{RX_SFBEI_27_INT,OAM_RX_BASE_ADDR,0x36,23,22},
	{RX_SFBEI_28_INT,OAM_RX_BASE_ADDR,0x36,25,24},
	{RX_SFBEI_29_INT,OAM_RX_BASE_ADDR,0x36,27,26},
	{RX_SFBEI_30_INT,OAM_RX_BASE_ADDR,0x36,29,28},
	{RX_SFBEI_31_INT,OAM_RX_BASE_ADDR,0x36,31,30},
};
const CHIP_REG rx_sfbei_i1_INT_MASK_REG[]=
{
	{RX_SFBEI_16_INT_MASK,OAM_RX_BASE_ADDR,0x37,1,0},
	{RX_SFBEI_17_INT_MASK,OAM_RX_BASE_ADDR,0x37,3,2},
	{RX_SFBEI_18_INT_MASK,OAM_RX_BASE_ADDR,0x37,5,4},
	{RX_SFBEI_19_INT_MASK,OAM_RX_BASE_ADDR,0x37,7,6},
	{RX_SFBEI_20_INT_MASK,OAM_RX_BASE_ADDR,0x37,9,8},
	{RX_SFBEI_21_INT_MASK,OAM_RX_BASE_ADDR,0x37,11,10},
	{RX_SFBEI_22_INT_MASK,OAM_RX_BASE_ADDR,0x37,13,12},
	{RX_SFBEI_23_INT_MASK,OAM_RX_BASE_ADDR,0x37,15,14},
	{RX_SFBEI_24_INT_MASK,OAM_RX_BASE_ADDR,0x37,17,16},
	{RX_SFBEI_25_INT_MASK,OAM_RX_BASE_ADDR,0x37,19,18},
	{RX_SFBEI_26_INT_MASK,OAM_RX_BASE_ADDR,0x37,21,20},
	{RX_SFBEI_27_INT_MASK,OAM_RX_BASE_ADDR,0x37,23,22},
	{RX_SFBEI_28_INT_MASK,OAM_RX_BASE_ADDR,0x37,25,24},
	{RX_SFBEI_29_INT_MASK,OAM_RX_BASE_ADDR,0x37,27,26},
	{RX_SFBEI_30_INT_MASK,OAM_RX_BASE_ADDR,0x37,29,28},
	{RX_SFBEI_31_INT_MASK,OAM_RX_BASE_ADDR,0x37,31,30},
};
const CHIP_REG rx_sfbei_i2_INT_REG[]=
{
	{RX_SFBEI_32_INT,OAM_RX_BASE_ADDR,0x38,1,0},
	{RX_SFBEI_33_INT,OAM_RX_BASE_ADDR,0x38,3,2},
	{RX_SFBEI_34_INT,OAM_RX_BASE_ADDR,0x38,5,4},
	{RX_SFBEI_35_INT,OAM_RX_BASE_ADDR,0x38,7,6},
	{RX_SFBEI_36_INT,OAM_RX_BASE_ADDR,0x38,9,8},
	{RX_SFBEI_37_INT,OAM_RX_BASE_ADDR,0x38,11,10},
	{RX_SFBEI_38_INT,OAM_RX_BASE_ADDR,0x38,13,12},
	{RX_SFBEI_39_INT,OAM_RX_BASE_ADDR,0x38,15,14},
	{RX_SFBEI_40_INT,OAM_RX_BASE_ADDR,0x38,17,16},
	{RX_SFBEI_41_INT,OAM_RX_BASE_ADDR,0x38,19,18},
	{RX_SFBEI_42_INT,OAM_RX_BASE_ADDR,0x38,21,20},
	{RX_SFBEI_43_INT,OAM_RX_BASE_ADDR,0x38,23,22},
	{RX_SFBEI_44_INT,OAM_RX_BASE_ADDR,0x38,25,24},
	{RX_SFBEI_45_INT,OAM_RX_BASE_ADDR,0x38,27,26},
	{RX_SFBEI_46_INT,OAM_RX_BASE_ADDR,0x38,29,28},
	{RX_SFBEI_47_INT,OAM_RX_BASE_ADDR,0x38,31,30},
};
const CHIP_REG rx_sfbei_i2_INT_MASK_REG[]=
{
	{RX_SFBEI_32_INT_MASK,OAM_RX_BASE_ADDR,0x59,1,0},
	{RX_SFBEI_33_INT_MASK,OAM_RX_BASE_ADDR,0x59,3,2},
	{RX_SFBEI_34_INT_MASK,OAM_RX_BASE_ADDR,0x59,5,4},
	{RX_SFBEI_35_INT_MASK,OAM_RX_BASE_ADDR,0x59,7,6},
	{RX_SFBEI_36_INT_MASK,OAM_RX_BASE_ADDR,0x59,9,8},
	{RX_SFBEI_37_INT_MASK,OAM_RX_BASE_ADDR,0x59,11,10},
	{RX_SFBEI_38_INT_MASK,OAM_RX_BASE_ADDR,0x59,13,12},
	{RX_SFBEI_39_INT_MASK,OAM_RX_BASE_ADDR,0x59,15,14},
	{RX_SFBEI_40_INT_MASK,OAM_RX_BASE_ADDR,0x59,17,16},
	{RX_SFBEI_41_INT_MASK,OAM_RX_BASE_ADDR,0x59,19,18},
	{RX_SFBEI_42_INT_MASK,OAM_RX_BASE_ADDR,0x59,21,20},
	{RX_SFBEI_43_INT_MASK,OAM_RX_BASE_ADDR,0x59,23,22},
	{RX_SFBEI_44_INT_MASK,OAM_RX_BASE_ADDR,0x59,25,24},
	{RX_SFBEI_45_INT_MASK,OAM_RX_BASE_ADDR,0x59,27,26},
	{RX_SFBEI_46_INT_MASK,OAM_RX_BASE_ADDR,0x59,29,28},
	{RX_SFBEI_47_INT_MASK,OAM_RX_BASE_ADDR,0x59,31,30},
};
const CHIP_REG rx_sfbei_i3_INT_REG[]=
{
	{RX_SFBEI_48_INT,OAM_RX_BASE_ADDR,0x66,1,0},
	{RX_SFBEI_49_INT,OAM_RX_BASE_ADDR,0x66,3,2},
	{RX_SFBEI_50_INT,OAM_RX_BASE_ADDR,0x66,5,4},
	{RX_SFBEI_51_INT,OAM_RX_BASE_ADDR,0x66,7,6},
	{RX_SFBEI_52_INT,OAM_RX_BASE_ADDR,0x66,9,8},
	{RX_SFBEI_53_INT,OAM_RX_BASE_ADDR,0x66,11,10},
	{RX_SFBEI_54_INT,OAM_RX_BASE_ADDR,0x66,13,12},
	{RX_SFBEI_55_INT,OAM_RX_BASE_ADDR,0x66,15,14},
	{RX_SFBEI_56_INT,OAM_RX_BASE_ADDR,0x66,17,16},
	{RX_SFBEI_57_INT,OAM_RX_BASE_ADDR,0x66,19,18},
	{RX_SFBEI_58_INT,OAM_RX_BASE_ADDR,0x66,21,20},
	{RX_SFBEI_59_INT,OAM_RX_BASE_ADDR,0x66,23,22},
	{RX_SFBEI_60_INT,OAM_RX_BASE_ADDR,0x66,25,24},
	{RX_SFBEI_61_INT,OAM_RX_BASE_ADDR,0x66,27,26},
	{RX_SFBEI_62_INT,OAM_RX_BASE_ADDR,0x66,29,28},
	{RX_SFBEI_63_INT,OAM_RX_BASE_ADDR,0x66,31,30},
};
const CHIP_REG rx_sfbei_i3_INT_MASK_REG[]=
{
	{RX_SFBEI_48_INT_MASK,OAM_RX_BASE_ADDR,0x67,1,0},
	{RX_SFBEI_49_INT_MASK,OAM_RX_BASE_ADDR,0x67,3,2},
	{RX_SFBEI_50_INT_MASK,OAM_RX_BASE_ADDR,0x67,5,4},
	{RX_SFBEI_51_INT_MASK,OAM_RX_BASE_ADDR,0x67,7,6},
	{RX_SFBEI_52_INT_MASK,OAM_RX_BASE_ADDR,0x67,9,8},
	{RX_SFBEI_53_INT_MASK,OAM_RX_BASE_ADDR,0x67,11,10},
	{RX_SFBEI_54_INT_MASK,OAM_RX_BASE_ADDR,0x67,13,12},
	{RX_SFBEI_55_INT_MASK,OAM_RX_BASE_ADDR,0x67,15,14},
	{RX_SFBEI_56_INT_MASK,OAM_RX_BASE_ADDR,0x67,17,16},
	{RX_SFBEI_57_INT_MASK,OAM_RX_BASE_ADDR,0x67,19,18},
	{RX_SFBEI_58_INT_MASK,OAM_RX_BASE_ADDR,0x67,21,20},
	{RX_SFBEI_59_INT_MASK,OAM_RX_BASE_ADDR,0x67,23,22},
	{RX_SFBEI_60_INT_MASK,OAM_RX_BASE_ADDR,0x67,25,24},
	{RX_SFBEI_61_INT_MASK,OAM_RX_BASE_ADDR,0x67,27,26},
	{RX_SFBEI_62_INT_MASK,OAM_RX_BASE_ADDR,0x67,29,28},
	{RX_SFBEI_63_INT_MASK,OAM_RX_BASE_ADDR,0x67,31,30},
};
const CHIP_REG rx_sfbei_i4_INT_REG[]=
{
	{RX_SFBEI_64_INT,OAM_RX_BASE_ADDR,0x6e,1,0},
	{RX_SFBEI_65_INT,OAM_RX_BASE_ADDR,0x6e,3,2},
	{RX_SFBEI_66_INT,OAM_RX_BASE_ADDR,0x6e,5,4},
	{RX_SFBEI_67_INT,OAM_RX_BASE_ADDR,0x6e,7,6},
	{RX_SFBEI_68_INT,OAM_RX_BASE_ADDR,0x6e,9,8},
	{RX_SFBEI_69_INT,OAM_RX_BASE_ADDR,0x6e,11,10},
	{RX_SFBEI_70_INT,OAM_RX_BASE_ADDR,0x6e,13,12},
	{RX_SFBEI_71_INT,OAM_RX_BASE_ADDR,0x6e,15,14},
	{RX_SFBEI_72_INT,OAM_RX_BASE_ADDR,0x6e,17,16},
	{RX_SFBEI_73_INT,OAM_RX_BASE_ADDR,0x6e,19,18},
	{RX_SFBEI_74_INT,OAM_RX_BASE_ADDR,0x6e,21,20},
	{RX_SFBEI_75_INT,OAM_RX_BASE_ADDR,0x6e,23,22},
	{RX_SFBEI_76_INT,OAM_RX_BASE_ADDR,0x6e,25,24},
	{RX_SFBEI_77_INT,OAM_RX_BASE_ADDR,0x6e,27,26},
	{RX_SFBEI_78_INT,OAM_RX_BASE_ADDR,0x6e,29,28},
	{RX_SFBEI_79_INT,OAM_RX_BASE_ADDR,0x6e,31,30},
};
const CHIP_REG rx_sfbei_i4_INT_MASK_REG[]=
{
	{RX_SFBEI_64_INT_MASK,OAM_RX_BASE_ADDR,0x75,1,0},
	{RX_SFBEI_65_INT_MASK,OAM_RX_BASE_ADDR,0x75,3,2},
	{RX_SFBEI_66_INT_MASK,OAM_RX_BASE_ADDR,0x75,5,4},
	{RX_SFBEI_67_INT_MASK,OAM_RX_BASE_ADDR,0x75,7,6},
	{RX_SFBEI_68_INT_MASK,OAM_RX_BASE_ADDR,0x75,9,8},
	{RX_SFBEI_69_INT_MASK,OAM_RX_BASE_ADDR,0x75,11,10},
	{RX_SFBEI_70_INT_MASK,OAM_RX_BASE_ADDR,0x75,13,12},
	{RX_SFBEI_71_INT_MASK,OAM_RX_BASE_ADDR,0x75,15,14},
	{RX_SFBEI_72_INT_MASK,OAM_RX_BASE_ADDR,0x75,17,16},
	{RX_SFBEI_73_INT_MASK,OAM_RX_BASE_ADDR,0x75,19,18},
	{RX_SFBEI_74_INT_MASK,OAM_RX_BASE_ADDR,0x75,21,20},
	{RX_SFBEI_75_INT_MASK,OAM_RX_BASE_ADDR,0x75,23,22},
	{RX_SFBEI_76_INT_MASK,OAM_RX_BASE_ADDR,0x75,25,24},
	{RX_SFBEI_77_INT_MASK,OAM_RX_BASE_ADDR,0x75,27,26},
	{RX_SFBEI_78_INT_MASK,OAM_RX_BASE_ADDR,0x75,29,28},
	{RX_SFBEI_79_INT_MASK,OAM_RX_BASE_ADDR,0x75,31,30},
};
const CHIP_REG bas_period_alm_i3_INT_REG[]=
{
	{BAS_PERIOD_ALM48_INT,OAM_RX_BASE_ADDR,0x7a,1,0},
	{BAS_PERIOD_ALM49_INT,OAM_RX_BASE_ADDR,0x7a,3,2},
	{BAS_PERIOD_ALM50_INT,OAM_RX_BASE_ADDR,0x7a,5,4},
	{BAS_PERIOD_ALM51_INT,OAM_RX_BASE_ADDR,0x7a,7,6},
	{BAS_PERIOD_ALM52_INT,OAM_RX_BASE_ADDR,0x7a,9,8},
	{BAS_PERIOD_ALM53_INT,OAM_RX_BASE_ADDR,0x7a,11,10},
	{BAS_PERIOD_ALM54_INT,OAM_RX_BASE_ADDR,0x7a,13,12},
	{BAS_PERIOD_ALM55_INT,OAM_RX_BASE_ADDR,0x7a,15,14},
	{BAS_PERIOD_ALM56_INT,OAM_RX_BASE_ADDR,0x7a,17,16},
	{BAS_PERIOD_ALM57_INT,OAM_RX_BASE_ADDR,0x7a,19,18},
	{BAS_PERIOD_ALM58_INT,OAM_RX_BASE_ADDR,0x7a,21,20},
	{BAS_PERIOD_ALM59_INT,OAM_RX_BASE_ADDR,0x7a,23,22},
	{BAS_PERIOD_ALM60_INT,OAM_RX_BASE_ADDR,0x7a,25,24},
	{BAS_PERIOD_ALM61_INT,OAM_RX_BASE_ADDR,0x7a,27,26},
	{BAS_PERIOD_ALM62_INT,OAM_RX_BASE_ADDR,0x7a,29,28},
	{BAS_PERIOD_ALM63_INT,OAM_RX_BASE_ADDR,0x7a,31,30},
};
const CHIP_REG bas_period_alm_i3_INT_MASK_REG[]=
{
	{BAS_PERIOD_ALM48_INT_MASK,OAM_RX_BASE_ADDR,0x7b,1,0},
	{BAS_PERIOD_ALM49_INT_MASK,OAM_RX_BASE_ADDR,0x7b,3,2},
	{BAS_PERIOD_ALM50_INT_MASK,OAM_RX_BASE_ADDR,0x7b,5,4},
	{BAS_PERIOD_ALM51_INT_MASK,OAM_RX_BASE_ADDR,0x7b,7,6},
	{BAS_PERIOD_ALM52_INT_MASK,OAM_RX_BASE_ADDR,0x7b,9,8},
	{BAS_PERIOD_ALM53_INT_MASK,OAM_RX_BASE_ADDR,0x7b,11,10},
	{BAS_PERIOD_ALM54_INT_MASK,OAM_RX_BASE_ADDR,0x7b,13,12},
	{BAS_PERIOD_ALM55_INT_MASK,OAM_RX_BASE_ADDR,0x7b,15,14},
	{BAS_PERIOD_ALM56_INT_MASK,OAM_RX_BASE_ADDR,0x7b,17,16},
	{BAS_PERIOD_ALM57_INT_MASK,OAM_RX_BASE_ADDR,0x7b,19,18},
	{BAS_PERIOD_ALM58_INT_MASK,OAM_RX_BASE_ADDR,0x7b,21,20},
	{BAS_PERIOD_ALM59_INT_MASK,OAM_RX_BASE_ADDR,0x7b,23,22},
	{BAS_PERIOD_ALM60_INT_MASK,OAM_RX_BASE_ADDR,0x7b,25,24},
	{BAS_PERIOD_ALM61_INT_MASK,OAM_RX_BASE_ADDR,0x7b,27,26},
	{BAS_PERIOD_ALM62_INT_MASK,OAM_RX_BASE_ADDR,0x7b,29,28},
	{BAS_PERIOD_ALM63_INT_MASK,OAM_RX_BASE_ADDR,0x7b,31,30},
};
const CHIP_REG bas_period_alm_i4_INT_REG[]=
{
	{BAS_PERIOD_ALM64_INT,OAM_RX_BASE_ADDR,0x7c,1,0},
	{BAS_PERIOD_ALM65_INT,OAM_RX_BASE_ADDR,0x7c,3,2},
	{BAS_PERIOD_ALM66_INT,OAM_RX_BASE_ADDR,0x7c,5,4},
	{BAS_PERIOD_ALM67_INT,OAM_RX_BASE_ADDR,0x7c,7,6},
	{BAS_PERIOD_ALM68_INT,OAM_RX_BASE_ADDR,0x7c,9,8},
	{BAS_PERIOD_ALM69_INT,OAM_RX_BASE_ADDR,0x7c,11,10},
	{BAS_PERIOD_ALM70_INT,OAM_RX_BASE_ADDR,0x7c,13,12},
	{BAS_PERIOD_ALM71_INT,OAM_RX_BASE_ADDR,0x7c,15,14},
	{BAS_PERIOD_ALM72_INT,OAM_RX_BASE_ADDR,0x7c,17,16},
	{BAS_PERIOD_ALM73_INT,OAM_RX_BASE_ADDR,0x7c,19,18},
	{BAS_PERIOD_ALM74_INT,OAM_RX_BASE_ADDR,0x7c,21,20},
	{BAS_PERIOD_ALM75_INT,OAM_RX_BASE_ADDR,0x7c,23,22},
	{BAS_PERIOD_ALM76_INT,OAM_RX_BASE_ADDR,0x7c,25,24},
	{BAS_PERIOD_ALM77_INT,OAM_RX_BASE_ADDR,0x7c,27,26},
	{BAS_PERIOD_ALM78_INT,OAM_RX_BASE_ADDR,0x7c,29,28},
	{BAS_PERIOD_ALM79_INT,OAM_RX_BASE_ADDR,0x7c,31,30},
};
const CHIP_REG bas_period_alm_i4_INT_MASK_REG[]=
{
	{BAS_PERIOD_ALM64_INT_MASK,OAM_RX_BASE_ADDR,0x7d,1,0},
	{BAS_PERIOD_ALM65_INT_MASK,OAM_RX_BASE_ADDR,0x7d,3,2},
	{BAS_PERIOD_ALM66_INT_MASK,OAM_RX_BASE_ADDR,0x7d,5,4},
	{BAS_PERIOD_ALM67_INT_MASK,OAM_RX_BASE_ADDR,0x7d,7,6},
	{BAS_PERIOD_ALM68_INT_MASK,OAM_RX_BASE_ADDR,0x7d,9,8},
	{BAS_PERIOD_ALM69_INT_MASK,OAM_RX_BASE_ADDR,0x7d,11,10},
	{BAS_PERIOD_ALM70_INT_MASK,OAM_RX_BASE_ADDR,0x7d,13,12},
	{BAS_PERIOD_ALM71_INT_MASK,OAM_RX_BASE_ADDR,0x7d,15,14},
	{BAS_PERIOD_ALM72_INT_MASK,OAM_RX_BASE_ADDR,0x7d,17,16},
	{BAS_PERIOD_ALM73_INT_MASK,OAM_RX_BASE_ADDR,0x7d,19,18},
	{BAS_PERIOD_ALM74_INT_MASK,OAM_RX_BASE_ADDR,0x7d,21,20},
	{BAS_PERIOD_ALM75_INT_MASK,OAM_RX_BASE_ADDR,0x7d,23,22},
	{BAS_PERIOD_ALM76_INT_MASK,OAM_RX_BASE_ADDR,0x7d,25,24},
	{BAS_PERIOD_ALM77_INT_MASK,OAM_RX_BASE_ADDR,0x7d,27,26},
	{BAS_PERIOD_ALM78_INT_MASK,OAM_RX_BASE_ADDR,0x7d,29,28},
	{BAS_PERIOD_ALM79_INT_MASK,OAM_RX_BASE_ADDR,0x7d,31,30},
};
const CHIP_REG rx_sdbip_i0_INT_REG[]=
{
	{RX_SDBIP_0_INT,OAM_RX_BASE_ADDR,0x80,1,0},
	{RX_SDBIP_1_INT,OAM_RX_BASE_ADDR,0x80,3,2},
	{RX_SDBIP_2_INT,OAM_RX_BASE_ADDR,0x80,5,4},
	{RX_SDBIP_3_INT,OAM_RX_BASE_ADDR,0x80,7,6},
	{RX_SDBIP_4_INT,OAM_RX_BASE_ADDR,0x80,9,8},
	{RX_SDBIP_5_INT,OAM_RX_BASE_ADDR,0x80,11,10},
	{RX_SDBIP_6_INT,OAM_RX_BASE_ADDR,0x80,13,12},
	{RX_SDBIP_7_INT,OAM_RX_BASE_ADDR,0x80,15,14},
	{RX_SDBIP_8_INT,OAM_RX_BASE_ADDR,0x80,17,16},
	{RX_SDBIP_9_INT,OAM_RX_BASE_ADDR,0x80,19,18},
	{RX_SDBIP_10_INT,OAM_RX_BASE_ADDR,0x80,21,20},
	{RX_SDBIP_11_INT,OAM_RX_BASE_ADDR,0x80,23,22},
	{RX_SDBIP_12_INT,OAM_RX_BASE_ADDR,0x80,25,24},
	{RX_SDBIP_13_INT,OAM_RX_BASE_ADDR,0x80,27,26},
	{RX_SDBIP_14_INT,OAM_RX_BASE_ADDR,0x80,29,28},
	{RX_SDBIP_15_INT,OAM_RX_BASE_ADDR,0x80,31,30},
};
const CHIP_REG rx_sdbip_i0_INT_MASK_REG[]=
{
	{RX_SDBIP_0_INT_MASK,OAM_RX_BASE_ADDR,0x81,1,0},
	{RX_SDBIP_1_INT_MASK,OAM_RX_BASE_ADDR,0x81,3,2},
	{RX_SDBIP_2_INT_MASK,OAM_RX_BASE_ADDR,0x81,5,4},
	{RX_SDBIP_3_INT_MASK,OAM_RX_BASE_ADDR,0x81,7,6},
	{RX_SDBIP_4_INT_MASK,OAM_RX_BASE_ADDR,0x81,9,8},
	{RX_SDBIP_5_INT_MASK,OAM_RX_BASE_ADDR,0x81,11,10},
	{RX_SDBIP_6_INT_MASK,OAM_RX_BASE_ADDR,0x81,13,12},
	{RX_SDBIP_7_INT_MASK,OAM_RX_BASE_ADDR,0x81,15,14},
	{RX_SDBIP_8_INT_MASK,OAM_RX_BASE_ADDR,0x81,17,16},
	{RX_SDBIP_9_INT_MASK,OAM_RX_BASE_ADDR,0x81,19,18},
	{RX_SDBIP_10_INT_MASK,OAM_RX_BASE_ADDR,0x81,21,20},
	{RX_SDBIP_11_INT_MASK,OAM_RX_BASE_ADDR,0x81,23,22},
	{RX_SDBIP_12_INT_MASK,OAM_RX_BASE_ADDR,0x81,25,24},
	{RX_SDBIP_13_INT_MASK,OAM_RX_BASE_ADDR,0x81,27,26},
	{RX_SDBIP_14_INT_MASK,OAM_RX_BASE_ADDR,0x81,29,28},
	{RX_SDBIP_15_INT_MASK,OAM_RX_BASE_ADDR,0x81,31,30},
};
const CHIP_REG rx_sdbip_i1_INT_REG[]=
{
	{RX_SDBIP_16_INT,OAM_RX_BASE_ADDR,0x82,1,0},
	{RX_SDBIP_17_INT,OAM_RX_BASE_ADDR,0x82,3,2},
	{RX_SDBIP_18_INT,OAM_RX_BASE_ADDR,0x82,5,4},
	{RX_SDBIP_19_INT,OAM_RX_BASE_ADDR,0x82,7,6},
	{RX_SDBIP_20_INT,OAM_RX_BASE_ADDR,0x82,9,8},
	{RX_SDBIP_21_INT,OAM_RX_BASE_ADDR,0x82,11,10},
	{RX_SDBIP_22_INT,OAM_RX_BASE_ADDR,0x82,13,12},
	{RX_SDBIP_23_INT,OAM_RX_BASE_ADDR,0x82,15,14},
	{RX_SDBIP_24_INT,OAM_RX_BASE_ADDR,0x82,17,16},
	{RX_SDBIP_25_INT,OAM_RX_BASE_ADDR,0x82,19,18},
	{RX_SDBIP_26_INT,OAM_RX_BASE_ADDR,0x82,21,20},
	{RX_SDBIP_27_INT,OAM_RX_BASE_ADDR,0x82,23,22},
	{RX_SDBIP_28_INT,OAM_RX_BASE_ADDR,0x82,25,24},
	{RX_SDBIP_29_INT,OAM_RX_BASE_ADDR,0x82,27,26},
	{RX_SDBIP_30_INT,OAM_RX_BASE_ADDR,0x82,29,28},
	{RX_SDBIP_31_INT,OAM_RX_BASE_ADDR,0x82,31,30},
};
const CHIP_REG rx_sdbip_i1_INT_MASK_REG[]=
{
	{RX_SDBIP_16_INT_MASK,OAM_RX_BASE_ADDR,0x83,1,0},
	{RX_SDBIP_17_INT_MASK,OAM_RX_BASE_ADDR,0x83,3,2},
	{RX_SDBIP_18_INT_MASK,OAM_RX_BASE_ADDR,0x83,5,4},
	{RX_SDBIP_19_INT_MASK,OAM_RX_BASE_ADDR,0x83,7,6},
	{RX_SDBIP_20_INT_MASK,OAM_RX_BASE_ADDR,0x83,9,8},
	{RX_SDBIP_21_INT_MASK,OAM_RX_BASE_ADDR,0x83,11,10},
	{RX_SDBIP_22_INT_MASK,OAM_RX_BASE_ADDR,0x83,13,12},
	{RX_SDBIP_23_INT_MASK,OAM_RX_BASE_ADDR,0x83,15,14},
	{RX_SDBIP_24_INT_MASK,OAM_RX_BASE_ADDR,0x83,17,16},
	{RX_SDBIP_25_INT_MASK,OAM_RX_BASE_ADDR,0x83,19,18},
	{RX_SDBIP_26_INT_MASK,OAM_RX_BASE_ADDR,0x83,21,20},
	{RX_SDBIP_27_INT_MASK,OAM_RX_BASE_ADDR,0x83,23,22},
	{RX_SDBIP_28_INT_MASK,OAM_RX_BASE_ADDR,0x83,25,24},
	{RX_SDBIP_29_INT_MASK,OAM_RX_BASE_ADDR,0x83,27,26},
	{RX_SDBIP_30_INT_MASK,OAM_RX_BASE_ADDR,0x83,29,28},
	{RX_SDBIP_31_INT_MASK,OAM_RX_BASE_ADDR,0x83,31,30},
};
const CHIP_REG rx_sdbip_i2_INT_REG[]=
{
	{RX_SDBIP_32_INT,OAM_RX_BASE_ADDR,0x84,1,0},
	{RX_SDBIP_33_INT,OAM_RX_BASE_ADDR,0x84,3,2},
	{RX_SDBIP_34_INT,OAM_RX_BASE_ADDR,0x84,5,4},
	{RX_SDBIP_35_INT,OAM_RX_BASE_ADDR,0x84,7,6},
	{RX_SDBIP_36_INT,OAM_RX_BASE_ADDR,0x84,9,8},
	{RX_SDBIP_37_INT,OAM_RX_BASE_ADDR,0x84,11,10},
	{RX_SDBIP_38_INT,OAM_RX_BASE_ADDR,0x84,13,12},
	{RX_SDBIP_39_INT,OAM_RX_BASE_ADDR,0x84,15,14},
	{RX_SDBIP_40_INT,OAM_RX_BASE_ADDR,0x84,17,16},
	{RX_SDBIP_41_INT,OAM_RX_BASE_ADDR,0x84,19,18},
	{RX_SDBIP_42_INT,OAM_RX_BASE_ADDR,0x84,21,20},
	{RX_SDBIP_43_INT,OAM_RX_BASE_ADDR,0x84,23,22},
	{RX_SDBIP_44_INT,OAM_RX_BASE_ADDR,0x84,25,24},
	{RX_SDBIP_45_INT,OAM_RX_BASE_ADDR,0x84,27,26},
	{RX_SDBIP_46_INT,OAM_RX_BASE_ADDR,0x84,29,28},
	{RX_SDBIP_47_INT,OAM_RX_BASE_ADDR,0x84,31,30},
};
const CHIP_REG rx_sdbip_i2_INT_MASK_REG[]=
{
	{RX_SDBIP_32_INT_MASK,OAM_RX_BASE_ADDR,0x85,1,0},
	{RX_SDBIP_33_INT_MASK,OAM_RX_BASE_ADDR,0x85,3,2},
	{RX_SDBIP_34_INT_MASK,OAM_RX_BASE_ADDR,0x85,5,4},
	{RX_SDBIP_35_INT_MASK,OAM_RX_BASE_ADDR,0x85,7,6},
	{RX_SDBIP_36_INT_MASK,OAM_RX_BASE_ADDR,0x85,9,8},
	{RX_SDBIP_37_INT_MASK,OAM_RX_BASE_ADDR,0x85,11,10},
	{RX_SDBIP_38_INT_MASK,OAM_RX_BASE_ADDR,0x85,13,12},
	{RX_SDBIP_39_INT_MASK,OAM_RX_BASE_ADDR,0x85,15,14},
	{RX_SDBIP_40_INT_MASK,OAM_RX_BASE_ADDR,0x85,17,16},
	{RX_SDBIP_41_INT_MASK,OAM_RX_BASE_ADDR,0x85,19,18},
	{RX_SDBIP_42_INT_MASK,OAM_RX_BASE_ADDR,0x85,21,20},
	{RX_SDBIP_43_INT_MASK,OAM_RX_BASE_ADDR,0x85,23,22},
	{RX_SDBIP_44_INT_MASK,OAM_RX_BASE_ADDR,0x85,25,24},
	{RX_SDBIP_45_INT_MASK,OAM_RX_BASE_ADDR,0x85,27,26},
	{RX_SDBIP_46_INT_MASK,OAM_RX_BASE_ADDR,0x85,29,28},
	{RX_SDBIP_47_INT_MASK,OAM_RX_BASE_ADDR,0x85,31,30},
};
const CHIP_REG rx_sdbip_i3_INT_REG[]=
{
	{RX_SDBIP_48_INT,OAM_RX_BASE_ADDR,0x86,1,0},
	{RX_SDBIP_49_INT,OAM_RX_BASE_ADDR,0x86,3,2},
	{RX_SDBIP_50_INT,OAM_RX_BASE_ADDR,0x86,5,4},
	{RX_SDBIP_51_INT,OAM_RX_BASE_ADDR,0x86,7,6},
	{RX_SDBIP_52_INT,OAM_RX_BASE_ADDR,0x86,9,8},
	{RX_SDBIP_53_INT,OAM_RX_BASE_ADDR,0x86,11,10},
	{RX_SDBIP_54_INT,OAM_RX_BASE_ADDR,0x86,13,12},
	{RX_SDBIP_55_INT,OAM_RX_BASE_ADDR,0x86,15,14},
	{RX_SDBIP_56_INT,OAM_RX_BASE_ADDR,0x86,17,16},
	{RX_SDBIP_57_INT,OAM_RX_BASE_ADDR,0x86,19,18},
	{RX_SDBIP_58_INT,OAM_RX_BASE_ADDR,0x86,21,20},
	{RX_SDBIP_59_INT,OAM_RX_BASE_ADDR,0x86,23,22},
	{RX_SDBIP_60_INT,OAM_RX_BASE_ADDR,0x86,25,24},
	{RX_SDBIP_61_INT,OAM_RX_BASE_ADDR,0x86,27,26},
	{RX_SDBIP_62_INT,OAM_RX_BASE_ADDR,0x86,29,28},
	{RX_SDBIP_63_INT,OAM_RX_BASE_ADDR,0x86,31,30},
};
const CHIP_REG rx_sdbip_i3_INT_MASK_REG[]=
{
	{RX_SDBIP_48_INT_MASK,OAM_RX_BASE_ADDR,0x87,1,0},
	{RX_SDBIP_49_INT_MASK,OAM_RX_BASE_ADDR,0x87,3,2},
	{RX_SDBIP_50_INT_MASK,OAM_RX_BASE_ADDR,0x87,5,4},
	{RX_SDBIP_51_INT_MASK,OAM_RX_BASE_ADDR,0x87,7,6},
	{RX_SDBIP_52_INT_MASK,OAM_RX_BASE_ADDR,0x87,9,8},
	{RX_SDBIP_53_INT_MASK,OAM_RX_BASE_ADDR,0x87,11,10},
	{RX_SDBIP_54_INT_MASK,OAM_RX_BASE_ADDR,0x87,13,12},
	{RX_SDBIP_55_INT_MASK,OAM_RX_BASE_ADDR,0x87,15,14},
	{RX_SDBIP_56_INT_MASK,OAM_RX_BASE_ADDR,0x87,17,16},
	{RX_SDBIP_57_INT_MASK,OAM_RX_BASE_ADDR,0x87,19,18},
	{RX_SDBIP_58_INT_MASK,OAM_RX_BASE_ADDR,0x87,21,20},
	{RX_SDBIP_59_INT_MASK,OAM_RX_BASE_ADDR,0x87,23,22},
	{RX_SDBIP_60_INT_MASK,OAM_RX_BASE_ADDR,0x87,25,24},
	{RX_SDBIP_61_INT_MASK,OAM_RX_BASE_ADDR,0x87,27,26},
	{RX_SDBIP_62_INT_MASK,OAM_RX_BASE_ADDR,0x87,29,28},
	{RX_SDBIP_63_INT_MASK,OAM_RX_BASE_ADDR,0x87,31,30},
};
const CHIP_REG rx_sdbip_i4_INT_REG[]=
{
	{RX_SDBIP_64_INT,OAM_RX_BASE_ADDR,0x88,1,0},
	{RX_SDBIP_65_INT,OAM_RX_BASE_ADDR,0x88,3,2},
	{RX_SDBIP_66_INT,OAM_RX_BASE_ADDR,0x88,5,4},
	{RX_SDBIP_67_INT,OAM_RX_BASE_ADDR,0x88,7,6},
	{RX_SDBIP_68_INT,OAM_RX_BASE_ADDR,0x88,9,8},
	{RX_SDBIP_69_INT,OAM_RX_BASE_ADDR,0x88,11,10},
	{RX_SDBIP_70_INT,OAM_RX_BASE_ADDR,0x88,13,12},
	{RX_SDBIP_71_INT,OAM_RX_BASE_ADDR,0x88,15,14},
	{RX_SDBIP_72_INT,OAM_RX_BASE_ADDR,0x88,17,16},
	{RX_SDBIP_73_INT,OAM_RX_BASE_ADDR,0x88,19,18},
	{RX_SDBIP_74_INT,OAM_RX_BASE_ADDR,0x88,21,20},
	{RX_SDBIP_75_INT,OAM_RX_BASE_ADDR,0x88,23,22},
	{RX_SDBIP_76_INT,OAM_RX_BASE_ADDR,0x88,25,24},
	{RX_SDBIP_77_INT,OAM_RX_BASE_ADDR,0x88,27,26},
	{RX_SDBIP_78_INT,OAM_RX_BASE_ADDR,0x88,29,28},
	{RX_SDBIP_79_INT,OAM_RX_BASE_ADDR,0x88,31,30},
};
const CHIP_REG rx_sdbip_i4_INT_MASK_REG[]=
{
	{RX_SDBIP_64_INT_MASK,OAM_RX_BASE_ADDR,0x89,1,0},
	{RX_SDBIP_65_INT_MASK,OAM_RX_BASE_ADDR,0x89,3,2},
	{RX_SDBIP_66_INT_MASK,OAM_RX_BASE_ADDR,0x89,5,4},
	{RX_SDBIP_67_INT_MASK,OAM_RX_BASE_ADDR,0x89,7,6},
	{RX_SDBIP_68_INT_MASK,OAM_RX_BASE_ADDR,0x89,9,8},
	{RX_SDBIP_69_INT_MASK,OAM_RX_BASE_ADDR,0x89,11,10},
	{RX_SDBIP_70_INT_MASK,OAM_RX_BASE_ADDR,0x89,13,12},
	{RX_SDBIP_71_INT_MASK,OAM_RX_BASE_ADDR,0x89,15,14},
	{RX_SDBIP_72_INT_MASK,OAM_RX_BASE_ADDR,0x89,17,16},
	{RX_SDBIP_73_INT_MASK,OAM_RX_BASE_ADDR,0x89,19,18},
	{RX_SDBIP_74_INT_MASK,OAM_RX_BASE_ADDR,0x89,21,20},
	{RX_SDBIP_75_INT_MASK,OAM_RX_BASE_ADDR,0x89,23,22},
	{RX_SDBIP_76_INT_MASK,OAM_RX_BASE_ADDR,0x89,25,24},
	{RX_SDBIP_77_INT_MASK,OAM_RX_BASE_ADDR,0x89,27,26},
	{RX_SDBIP_78_INT_MASK,OAM_RX_BASE_ADDR,0x89,29,28},
	{RX_SDBIP_79_INT_MASK,OAM_RX_BASE_ADDR,0x89,31,30},
};
const CHIP_REG bas_rdi_i0_INT_REG[]=
{
	{BAS_RDI_0_INT,OAM_RX_BASE_ADDR,0x94,1,0},
	{BAS_RDI_1_INT,OAM_RX_BASE_ADDR,0x94,3,2},
	{BAS_RDI_2_INT,OAM_RX_BASE_ADDR,0x94,5,4},
	{BAS_RDI_3_INT,OAM_RX_BASE_ADDR,0x94,7,6},
	{BAS_RDI_4_INT,OAM_RX_BASE_ADDR,0x94,9,8},
	{BAS_RDI_5_INT,OAM_RX_BASE_ADDR,0x94,11,10},
	{BAS_RDI_6_INT,OAM_RX_BASE_ADDR,0x94,13,12},
	{BAS_RDI_7_INT,OAM_RX_BASE_ADDR,0x94,15,14},
	{BAS_RDI_8_INT,OAM_RX_BASE_ADDR,0x94,17,16},
	{BAS_RDI_9_INT,OAM_RX_BASE_ADDR,0x94,19,18},
	{BAS_RDI_10_INT,OAM_RX_BASE_ADDR,0x94,21,20},
	{BAS_RDI_11_INT,OAM_RX_BASE_ADDR,0x94,23,22},
	{BAS_RDI_12_INT,OAM_RX_BASE_ADDR,0x94,25,24},
	{BAS_RDI_13_INT,OAM_RX_BASE_ADDR,0x94,27,26},
	{BAS_RDI_14_INT,OAM_RX_BASE_ADDR,0x94,29,28},
	{BAS_RDI_15_INT,OAM_RX_BASE_ADDR,0x94,31,30},
};
const CHIP_REG bas_rdi_i0_INT_MASK_REG[]=
{
	{BAS_RDI_0_INT_MASK,OAM_RX_BASE_ADDR,0x95,1,0},
	{BAS_RDI_1_INT_MASK,OAM_RX_BASE_ADDR,0x95,3,2},
	{BAS_RDI_2_INT_MASK,OAM_RX_BASE_ADDR,0x95,5,4},
	{BAS_RDI_3_INT_MASK,OAM_RX_BASE_ADDR,0x95,7,6},
	{BAS_RDI_4_INT_MASK,OAM_RX_BASE_ADDR,0x95,9,8},
	{BAS_RDI_5_INT_MASK,OAM_RX_BASE_ADDR,0x95,11,10},
	{BAS_RDI_6_INT_MASK,OAM_RX_BASE_ADDR,0x95,13,12},
	{BAS_RDI_7_INT_MASK,OAM_RX_BASE_ADDR,0x95,15,14},
	{BAS_RDI_8_INT_MASK,OAM_RX_BASE_ADDR,0x95,17,16},
	{BAS_RDI_9_INT_MASK,OAM_RX_BASE_ADDR,0x95,19,18},
	{BAS_RDI_10_INT_MASK,OAM_RX_BASE_ADDR,0x95,21,20},
	{BAS_RDI_11_INT_MASK,OAM_RX_BASE_ADDR,0x95,23,22},
	{BAS_RDI_12_INT_MASK,OAM_RX_BASE_ADDR,0x95,25,24},
	{BAS_RDI_13_INT_MASK,OAM_RX_BASE_ADDR,0x95,27,26},
	{BAS_RDI_14_INT_MASK,OAM_RX_BASE_ADDR,0x95,29,28},
	{BAS_RDI_15_INT_MASK,OAM_RX_BASE_ADDR,0x95,31,30},
};
const CHIP_REG bas_rdi_i1_INT_REG[]=
{
	{BAS_RDI_16_INT,OAM_RX_BASE_ADDR,0x96,1,0},
	{BAS_RDI_17_INT,OAM_RX_BASE_ADDR,0x96,3,2},
	{BAS_RDI_18_INT,OAM_RX_BASE_ADDR,0x96,5,4},
	{BAS_RDI_19_INT,OAM_RX_BASE_ADDR,0x96,7,6},
	{BAS_RDI_20_INT,OAM_RX_BASE_ADDR,0x96,9,8},
	{BAS_RDI_21_INT,OAM_RX_BASE_ADDR,0x96,11,10},
	{BAS_RDI_22_INT,OAM_RX_BASE_ADDR,0x96,13,12},
	{BAS_RDI_23_INT,OAM_RX_BASE_ADDR,0x96,15,14},
	{BAS_RDI_24_INT,OAM_RX_BASE_ADDR,0x96,17,16},
	{BAS_RDI_25_INT,OAM_RX_BASE_ADDR,0x96,19,18},
	{BAS_RDI_26_INT,OAM_RX_BASE_ADDR,0x96,21,20},
	{BAS_RDI_27_INT,OAM_RX_BASE_ADDR,0x96,23,22},
	{BAS_RDI_28_INT,OAM_RX_BASE_ADDR,0x96,25,24},
	{BAS_RDI_29_INT,OAM_RX_BASE_ADDR,0x96,27,26},
	{BAS_RDI_30_INT,OAM_RX_BASE_ADDR,0x96,29,28},
	{BAS_RDI_31_INT,OAM_RX_BASE_ADDR,0x96,31,30},
};
const CHIP_REG bas_rdi_i1_INT_MASK_REG[]=
{
	{BAS_RDI_16_INT_MASK,OAM_RX_BASE_ADDR,0x97,1,0},
	{BAS_RDI_17_INT_MASK,OAM_RX_BASE_ADDR,0x97,3,2},
	{BAS_RDI_18_INT_MASK,OAM_RX_BASE_ADDR,0x97,5,4},
	{BAS_RDI_19_INT_MASK,OAM_RX_BASE_ADDR,0x97,7,6},
	{BAS_RDI_20_INT_MASK,OAM_RX_BASE_ADDR,0x97,9,8},
	{BAS_RDI_21_INT_MASK,OAM_RX_BASE_ADDR,0x97,11,10},
	{BAS_RDI_22_INT_MASK,OAM_RX_BASE_ADDR,0x97,13,12},
	{BAS_RDI_23_INT_MASK,OAM_RX_BASE_ADDR,0x97,15,14},
	{BAS_RDI_24_INT_MASK,OAM_RX_BASE_ADDR,0x97,17,16},
	{BAS_RDI_25_INT_MASK,OAM_RX_BASE_ADDR,0x97,19,18},
	{BAS_RDI_26_INT_MASK,OAM_RX_BASE_ADDR,0x97,21,20},
	{BAS_RDI_27_INT_MASK,OAM_RX_BASE_ADDR,0x97,23,22},
	{BAS_RDI_28_INT_MASK,OAM_RX_BASE_ADDR,0x97,25,24},
	{BAS_RDI_29_INT_MASK,OAM_RX_BASE_ADDR,0x97,27,26},
	{BAS_RDI_30_INT_MASK,OAM_RX_BASE_ADDR,0x97,29,28},
	{BAS_RDI_31_INT_MASK,OAM_RX_BASE_ADDR,0x97,31,30},
};
const CHIP_REG bas_rdi_i2_INT_REG[]=
{
	{BAS_RDI_32_INT,OAM_RX_BASE_ADDR,0x98,1,0},
	{BAS_RDI_33_INT,OAM_RX_BASE_ADDR,0x98,3,2},
	{BAS_RDI_34_INT,OAM_RX_BASE_ADDR,0x98,5,4},
	{BAS_RDI_35_INT,OAM_RX_BASE_ADDR,0x98,7,6},
	{BAS_RDI_36_INT,OAM_RX_BASE_ADDR,0x98,9,8},
	{BAS_RDI_37_INT,OAM_RX_BASE_ADDR,0x98,11,10},
	{BAS_RDI_38_INT,OAM_RX_BASE_ADDR,0x98,13,12},
	{BAS_RDI_39_INT,OAM_RX_BASE_ADDR,0x98,15,14},
	{BAS_RDI_40_INT,OAM_RX_BASE_ADDR,0x98,17,16},
	{BAS_RDI_41_INT,OAM_RX_BASE_ADDR,0x98,19,18},
	{BAS_RDI_42_INT,OAM_RX_BASE_ADDR,0x98,21,20},
	{BAS_RDI_43_INT,OAM_RX_BASE_ADDR,0x98,23,22},
	{BAS_RDI_44_INT,OAM_RX_BASE_ADDR,0x98,25,24},
	{BAS_RDI_45_INT,OAM_RX_BASE_ADDR,0x98,27,26},
	{BAS_RDI_46_INT,OAM_RX_BASE_ADDR,0x98,29,28},
	{BAS_RDI_47_INT,OAM_RX_BASE_ADDR,0x98,31,30},
};
const CHIP_REG bas_rdi_i2_INT_MASK_REG[]=
{
	{BAS_RDI_32_INT_MASK,OAM_RX_BASE_ADDR,0x99,1,0},
	{BAS_RDI_33_INT_MASK,OAM_RX_BASE_ADDR,0x99,3,2},
	{BAS_RDI_34_INT_MASK,OAM_RX_BASE_ADDR,0x99,5,4},
	{BAS_RDI_35_INT_MASK,OAM_RX_BASE_ADDR,0x99,7,6},
	{BAS_RDI_36_INT_MASK,OAM_RX_BASE_ADDR,0x99,9,8},
	{BAS_RDI_37_INT_MASK,OAM_RX_BASE_ADDR,0x99,11,10},
	{BAS_RDI_38_INT_MASK,OAM_RX_BASE_ADDR,0x99,13,12},
	{BAS_RDI_39_INT_MASK,OAM_RX_BASE_ADDR,0x99,15,14},
	{BAS_RDI_40_INT_MASK,OAM_RX_BASE_ADDR,0x99,17,16},
	{BAS_RDI_41_INT_MASK,OAM_RX_BASE_ADDR,0x99,19,18},
	{BAS_RDI_42_INT_MASK,OAM_RX_BASE_ADDR,0x99,21,20},
	{BAS_RDI_43_INT_MASK,OAM_RX_BASE_ADDR,0x99,23,22},
	{BAS_RDI_44_INT_MASK,OAM_RX_BASE_ADDR,0x99,25,24},
	{BAS_RDI_45_INT_MASK,OAM_RX_BASE_ADDR,0x99,27,26},
	{BAS_RDI_46_INT_MASK,OAM_RX_BASE_ADDR,0x99,29,28},
	{BAS_RDI_47_INT_MASK,OAM_RX_BASE_ADDR,0x99,31,30},
};
const CHIP_REG bas_rdi_i3_INT_REG[]=
{
	{BAS_RDI_48_INT,OAM_RX_BASE_ADDR,0x9a,1,0},
	{BAS_RDI_49_INT,OAM_RX_BASE_ADDR,0x9a,3,2},
	{BAS_RDI_50_INT,OAM_RX_BASE_ADDR,0x9a,5,4},
	{BAS_RDI_51_INT,OAM_RX_BASE_ADDR,0x9a,7,6},
	{BAS_RDI_52_INT,OAM_RX_BASE_ADDR,0x9a,9,8},
	{BAS_RDI_53_INT,OAM_RX_BASE_ADDR,0x9a,11,10},
	{BAS_RDI_54_INT,OAM_RX_BASE_ADDR,0x9a,13,12},
	{BAS_RDI_55_INT,OAM_RX_BASE_ADDR,0x9a,15,14},
	{BAS_RDI_56_INT,OAM_RX_BASE_ADDR,0x9a,17,16},
	{BAS_RDI_57_INT,OAM_RX_BASE_ADDR,0x9a,19,18},
	{BAS_RDI_58_INT,OAM_RX_BASE_ADDR,0x9a,21,20},
	{BAS_RDI_59_INT,OAM_RX_BASE_ADDR,0x9a,23,22},
	{BAS_RDI_60_INT,OAM_RX_BASE_ADDR,0x9a,25,24},
	{BAS_RDI_61_INT,OAM_RX_BASE_ADDR,0x9a,27,26},
	{BAS_RDI_62_INT,OAM_RX_BASE_ADDR,0x9a,29,28},
	{BAS_RDI_63_INT,OAM_RX_BASE_ADDR,0x9a,31,30},
};
const CHIP_REG bas_rdi_i3_INT_MASK_REG[]=
{
	{BAS_RDI_48_INT_MASK,OAM_RX_BASE_ADDR,0x9b,1,0},
	{BAS_RDI_49_INT_MASK,OAM_RX_BASE_ADDR,0x9b,3,2},
	{BAS_RDI_50_INT_MASK,OAM_RX_BASE_ADDR,0x9b,5,4},
	{BAS_RDI_51_INT_MASK,OAM_RX_BASE_ADDR,0x9b,7,6},
	{BAS_RDI_52_INT_MASK,OAM_RX_BASE_ADDR,0x9b,9,8},
	{BAS_RDI_53_INT_MASK,OAM_RX_BASE_ADDR,0x9b,11,10},
	{BAS_RDI_54_INT_MASK,OAM_RX_BASE_ADDR,0x9b,13,12},
	{BAS_RDI_55_INT_MASK,OAM_RX_BASE_ADDR,0x9b,15,14},
	{BAS_RDI_56_INT_MASK,OAM_RX_BASE_ADDR,0x9b,17,16},
	{BAS_RDI_57_INT_MASK,OAM_RX_BASE_ADDR,0x9b,19,18},
	{BAS_RDI_58_INT_MASK,OAM_RX_BASE_ADDR,0x9b,21,20},
	{BAS_RDI_59_INT_MASK,OAM_RX_BASE_ADDR,0x9b,23,22},
	{BAS_RDI_60_INT_MASK,OAM_RX_BASE_ADDR,0x9b,25,24},
	{BAS_RDI_61_INT_MASK,OAM_RX_BASE_ADDR,0x9b,27,26},
	{BAS_RDI_62_INT_MASK,OAM_RX_BASE_ADDR,0x9b,29,28},
	{BAS_RDI_63_INT_MASK,OAM_RX_BASE_ADDR,0x9b,31,30},
};
const CHIP_REG bas_rdi_i4_INT_REG[]=
{
	{BAS_RDI_64_INT,OAM_RX_BASE_ADDR,0x9c,1,0},
	{BAS_RDI_65_INT,OAM_RX_BASE_ADDR,0x9c,3,2},
	{BAS_RDI_66_INT,OAM_RX_BASE_ADDR,0x9c,5,4},
	{BAS_RDI_67_INT,OAM_RX_BASE_ADDR,0x9c,7,6},
	{BAS_RDI_68_INT,OAM_RX_BASE_ADDR,0x9c,9,8},
	{BAS_RDI_69_INT,OAM_RX_BASE_ADDR,0x9c,11,10},
	{BAS_RDI_70_INT,OAM_RX_BASE_ADDR,0x9c,13,12},
	{BAS_RDI_71_INT,OAM_RX_BASE_ADDR,0x9c,15,14},
	{BAS_RDI_72_INT,OAM_RX_BASE_ADDR,0x9c,17,16},
	{BAS_RDI_73_INT,OAM_RX_BASE_ADDR,0x9c,19,18},
	{BAS_RDI_74_INT,OAM_RX_BASE_ADDR,0x9c,21,20},
	{BAS_RDI_75_INT,OAM_RX_BASE_ADDR,0x9c,23,22},
	{BAS_RDI_76_INT,OAM_RX_BASE_ADDR,0x9c,25,24},
	{BAS_RDI_77_INT,OAM_RX_BASE_ADDR,0x9c,27,26},
	{BAS_RDI_78_INT,OAM_RX_BASE_ADDR,0x9c,29,28},
	{BAS_RDI_79_INT,OAM_RX_BASE_ADDR,0x9c,31,30},
};
const CHIP_REG bas_rdi_i4_INT_MASK_REG[]=
{
	{BAS_RDI_64_INT_MASK,OAM_RX_BASE_ADDR,0x9d,1,0},
	{BAS_RDI_65_INT_MASK,OAM_RX_BASE_ADDR,0x9d,3,2},
	{BAS_RDI_66_INT_MASK,OAM_RX_BASE_ADDR,0x9d,5,4},
	{BAS_RDI_67_INT_MASK,OAM_RX_BASE_ADDR,0x9d,7,6},
	{BAS_RDI_68_INT_MASK,OAM_RX_BASE_ADDR,0x9d,9,8},
	{BAS_RDI_69_INT_MASK,OAM_RX_BASE_ADDR,0x9d,11,10},
	{BAS_RDI_70_INT_MASK,OAM_RX_BASE_ADDR,0x9d,13,12},
	{BAS_RDI_71_INT_MASK,OAM_RX_BASE_ADDR,0x9d,15,14},
	{BAS_RDI_72_INT_MASK,OAM_RX_BASE_ADDR,0x9d,17,16},
	{BAS_RDI_73_INT_MASK,OAM_RX_BASE_ADDR,0x9d,19,18},
	{BAS_RDI_74_INT_MASK,OAM_RX_BASE_ADDR,0x9d,21,20},
	{BAS_RDI_75_INT_MASK,OAM_RX_BASE_ADDR,0x9d,23,22},
	{BAS_RDI_76_INT_MASK,OAM_RX_BASE_ADDR,0x9d,25,24},
	{BAS_RDI_77_INT_MASK,OAM_RX_BASE_ADDR,0x9d,27,26},
	{BAS_RDI_78_INT_MASK,OAM_RX_BASE_ADDR,0x9d,29,28},
	{BAS_RDI_79_INT_MASK,OAM_RX_BASE_ADDR,0x9d,31,30},
};
const CHIP_REG bas_csf_lpi_i0_INT_REG[]=
{
	{BAS_CSF_LPI_0_INT,OAM_RX_BASE_ADDR,0x9e,1,0},
	{BAS_CSF_LPI_1_INT,OAM_RX_BASE_ADDR,0x9e,3,2},
	{BAS_CSF_LPI_2_INT,OAM_RX_BASE_ADDR,0x9e,5,4},
	{BAS_CSF_LPI_3_INT,OAM_RX_BASE_ADDR,0x9e,7,6},
	{BAS_CSF_LPI_4_INT,OAM_RX_BASE_ADDR,0x9e,9,8},
	{BAS_CSF_LPI_5_INT,OAM_RX_BASE_ADDR,0x9e,11,10},
	{BAS_CSF_LPI_6_INT,OAM_RX_BASE_ADDR,0x9e,13,12},
	{BAS_CSF_LPI_7_INT,OAM_RX_BASE_ADDR,0x9e,15,14},
	{BAS_CSF_LPI_8_INT,OAM_RX_BASE_ADDR,0x9e,17,16},
	{BAS_CSF_LPI_9_INT,OAM_RX_BASE_ADDR,0x9e,19,18},
	{BAS_CSF_LPI_10_INT,OAM_RX_BASE_ADDR,0x9e,21,20},
	{BAS_CSF_LPI_11_INT,OAM_RX_BASE_ADDR,0x9e,23,22},
	{BAS_CSF_LPI_12_INT,OAM_RX_BASE_ADDR,0x9e,25,24},
	{BAS_CSF_LPI_13_INT,OAM_RX_BASE_ADDR,0x9e,27,26},
	{BAS_CSF_LPI_14_INT,OAM_RX_BASE_ADDR,0x9e,29,28},
	{BAS_CSF_LPI_15_INT,OAM_RX_BASE_ADDR,0x9e,31,30},
};
const CHIP_REG bas_csf_lpi_i0_INT_MASK_REG[]=
{
	{BAS_CSF_LPI_0_INT_MASK,OAM_RX_BASE_ADDR,0x9f,1,0},
	{BAS_CSF_LPI_1_INT_MASK,OAM_RX_BASE_ADDR,0x9f,3,2},
	{BAS_CSF_LPI_2_INT_MASK,OAM_RX_BASE_ADDR,0x9f,5,4},
	{BAS_CSF_LPI_3_INT_MASK,OAM_RX_BASE_ADDR,0x9f,7,6},
	{BAS_CSF_LPI_4_INT_MASK,OAM_RX_BASE_ADDR,0x9f,9,8},
	{BAS_CSF_LPI_5_INT_MASK,OAM_RX_BASE_ADDR,0x9f,11,10},
	{BAS_CSF_LPI_6_INT_MASK,OAM_RX_BASE_ADDR,0x9f,13,12},
	{BAS_CSF_LPI_7_INT_MASK,OAM_RX_BASE_ADDR,0x9f,15,14},
	{BAS_CSF_LPI_8_INT_MASK,OAM_RX_BASE_ADDR,0x9f,17,16},
	{BAS_CSF_LPI_9_INT_MASK,OAM_RX_BASE_ADDR,0x9f,19,18},
	{BAS_CSF_LPI_10_INT_MASK,OAM_RX_BASE_ADDR,0x9f,21,20},
	{BAS_CSF_LPI_11_INT_MASK,OAM_RX_BASE_ADDR,0x9f,23,22},
	{BAS_CSF_LPI_12_INT_MASK,OAM_RX_BASE_ADDR,0x9f,25,24},
	{BAS_CSF_LPI_13_INT_MASK,OAM_RX_BASE_ADDR,0x9f,27,26},
	{BAS_CSF_LPI_14_INT_MASK,OAM_RX_BASE_ADDR,0x9f,29,28},
	{BAS_CSF_LPI_15_INT_MASK,OAM_RX_BASE_ADDR,0x9f,31,30},
};
const CHIP_REG bas_csf_lpi_i1_INT_REG[]=
{
	{BAS_CSF_LPI_16_INT,OAM_RX_BASE_ADDR,0xa0,1,0},
	{BAS_CSF_LPI_17_INT,OAM_RX_BASE_ADDR,0xa0,3,2},
	{BAS_CSF_LPI_18_INT,OAM_RX_BASE_ADDR,0xa0,5,4},
	{BAS_CSF_LPI_19_INT,OAM_RX_BASE_ADDR,0xa0,7,6},
	{BAS_CSF_LPI_20_INT,OAM_RX_BASE_ADDR,0xa0,9,8},
	{BAS_CSF_LPI_21_INT,OAM_RX_BASE_ADDR,0xa0,11,10},
	{BAS_CSF_LPI_22_INT,OAM_RX_BASE_ADDR,0xa0,13,12},
	{BAS_CSF_LPI_23_INT,OAM_RX_BASE_ADDR,0xa0,15,14},
	{BAS_CSF_LPI_24_INT,OAM_RX_BASE_ADDR,0xa0,17,16},
	{BAS_CSF_LPI_25_INT,OAM_RX_BASE_ADDR,0xa0,19,18},
	{BAS_CSF_LPI_26_INT,OAM_RX_BASE_ADDR,0xa0,21,20},
	{BAS_CSF_LPI_27_INT,OAM_RX_BASE_ADDR,0xa0,23,22},
	{BAS_CSF_LPI_28_INT,OAM_RX_BASE_ADDR,0xa0,25,24},
	{BAS_CSF_LPI_29_INT,OAM_RX_BASE_ADDR,0xa0,27,26},
	{BAS_CSF_LPI_30_INT,OAM_RX_BASE_ADDR,0xa0,29,28},
	{BAS_CSF_LPI_31_INT,OAM_RX_BASE_ADDR,0xa0,31,30},
};
const CHIP_REG bas_csf_lpi_i1_INT_MASK_REG[]=
{
	{BAS_CSF_LPI_16_INT_MASK,OAM_RX_BASE_ADDR,0xa1,1,0},
	{BAS_CSF_LPI_17_INT_MASK,OAM_RX_BASE_ADDR,0xa1,3,2},
	{BAS_CSF_LPI_18_INT_MASK,OAM_RX_BASE_ADDR,0xa1,5,4},
	{BAS_CSF_LPI_19_INT_MASK,OAM_RX_BASE_ADDR,0xa1,7,6},
	{BAS_CSF_LPI_20_INT_MASK,OAM_RX_BASE_ADDR,0xa1,9,8},
	{BAS_CSF_LPI_21_INT_MASK,OAM_RX_BASE_ADDR,0xa1,11,10},
	{BAS_CSF_LPI_22_INT_MASK,OAM_RX_BASE_ADDR,0xa1,13,12},
	{BAS_CSF_LPI_23_INT_MASK,OAM_RX_BASE_ADDR,0xa1,15,14},
	{BAS_CSF_LPI_24_INT_MASK,OAM_RX_BASE_ADDR,0xa1,17,16},
	{BAS_CSF_LPI_25_INT_MASK,OAM_RX_BASE_ADDR,0xa1,19,18},
	{BAS_CSF_LPI_26_INT_MASK,OAM_RX_BASE_ADDR,0xa1,21,20},
	{BAS_CSF_LPI_27_INT_MASK,OAM_RX_BASE_ADDR,0xa1,23,22},
	{BAS_CSF_LPI_28_INT_MASK,OAM_RX_BASE_ADDR,0xa1,25,24},
	{BAS_CSF_LPI_29_INT_MASK,OAM_RX_BASE_ADDR,0xa1,27,26},
	{BAS_CSF_LPI_30_INT_MASK,OAM_RX_BASE_ADDR,0xa1,29,28},
	{BAS_CSF_LPI_31_INT_MASK,OAM_RX_BASE_ADDR,0xa1,31,30},
};
const CHIP_REG bas_csf_lpi_i2_INT_REG[]=
{
	{BAS_CSF_LPI_32_INT,OAM_RX_BASE_ADDR,0xa2,1,0},
	{BAS_CSF_LPI_33_INT,OAM_RX_BASE_ADDR,0xa2,3,2},
	{BAS_CSF_LPI_34_INT,OAM_RX_BASE_ADDR,0xa2,5,4},
	{BAS_CSF_LPI_35_INT,OAM_RX_BASE_ADDR,0xa2,7,6},
	{BAS_CSF_LPI_36_INT,OAM_RX_BASE_ADDR,0xa2,9,8},
	{BAS_CSF_LPI_37_INT,OAM_RX_BASE_ADDR,0xa2,11,10},
	{BAS_CSF_LPI_38_INT,OAM_RX_BASE_ADDR,0xa2,13,12},
	{BAS_CSF_LPI_39_INT,OAM_RX_BASE_ADDR,0xa2,15,14},
	{BAS_CSF_LPI_40_INT,OAM_RX_BASE_ADDR,0xa2,17,16},
	{BAS_CSF_LPI_41_INT,OAM_RX_BASE_ADDR,0xa2,19,18},
	{BAS_CSF_LPI_42_INT,OAM_RX_BASE_ADDR,0xa2,21,20},
	{BAS_CSF_LPI_43_INT,OAM_RX_BASE_ADDR,0xa2,23,22},
	{BAS_CSF_LPI_44_INT,OAM_RX_BASE_ADDR,0xa2,25,24},
	{BAS_CSF_LPI_45_INT,OAM_RX_BASE_ADDR,0xa2,27,26},
	{BAS_CSF_LPI_46_INT,OAM_RX_BASE_ADDR,0xa2,29,28},
	{BAS_CSF_LPI_47_INT,OAM_RX_BASE_ADDR,0xa2,31,30},
};
const CHIP_REG bas_csf_lpi_i2_INT_MASK_REG[]=
{
	{BAS_CSF_LPI_32_INT_MASK,OAM_RX_BASE_ADDR,0xa3,1,0},
	{BAS_CSF_LPI_33_INT_MASK,OAM_RX_BASE_ADDR,0xa3,3,2},
	{BAS_CSF_LPI_34_INT_MASK,OAM_RX_BASE_ADDR,0xa3,5,4},
	{BAS_CSF_LPI_35_INT_MASK,OAM_RX_BASE_ADDR,0xa3,7,6},
	{BAS_CSF_LPI_36_INT_MASK,OAM_RX_BASE_ADDR,0xa3,9,8},
	{BAS_CSF_LPI_37_INT_MASK,OAM_RX_BASE_ADDR,0xa3,11,10},
	{BAS_CSF_LPI_38_INT_MASK,OAM_RX_BASE_ADDR,0xa3,13,12},
	{BAS_CSF_LPI_39_INT_MASK,OAM_RX_BASE_ADDR,0xa3,15,14},
	{BAS_CSF_LPI_40_INT_MASK,OAM_RX_BASE_ADDR,0xa3,17,16},
	{BAS_CSF_LPI_41_INT_MASK,OAM_RX_BASE_ADDR,0xa3,19,18},
	{BAS_CSF_LPI_42_INT_MASK,OAM_RX_BASE_ADDR,0xa3,21,20},
	{BAS_CSF_LPI_43_INT_MASK,OAM_RX_BASE_ADDR,0xa3,23,22},
	{BAS_CSF_LPI_44_INT_MASK,OAM_RX_BASE_ADDR,0xa3,25,24},
	{BAS_CSF_LPI_45_INT_MASK,OAM_RX_BASE_ADDR,0xa3,27,26},
	{BAS_CSF_LPI_46_INT_MASK,OAM_RX_BASE_ADDR,0xa3,29,28},
	{BAS_CSF_LPI_47_INT_MASK,OAM_RX_BASE_ADDR,0xa3,31,30},
};
const CHIP_REG bas_csf_lpi_i3_INT_REG[]=
{
	{BAS_CSF_LPI_48_INT,OAM_RX_BASE_ADDR,0xa4,1,0},
	{BAS_CSF_LPI_49_INT,OAM_RX_BASE_ADDR,0xa4,3,2},
	{BAS_CSF_LPI_50_INT,OAM_RX_BASE_ADDR,0xa4,5,4},
	{BAS_CSF_LPI_51_INT,OAM_RX_BASE_ADDR,0xa4,7,6},
	{BAS_CSF_LPI_52_INT,OAM_RX_BASE_ADDR,0xa4,9,8},
	{BAS_CSF_LPI_53_INT,OAM_RX_BASE_ADDR,0xa4,11,10},
	{BAS_CSF_LPI_54_INT,OAM_RX_BASE_ADDR,0xa4,13,12},
	{BAS_CSF_LPI_55_INT,OAM_RX_BASE_ADDR,0xa4,15,14},
	{BAS_CSF_LPI_56_INT,OAM_RX_BASE_ADDR,0xa4,17,16},
	{BAS_CSF_LPI_57_INT,OAM_RX_BASE_ADDR,0xa4,19,18},
	{BAS_CSF_LPI_58_INT,OAM_RX_BASE_ADDR,0xa4,21,20},
	{BAS_CSF_LPI_59_INT,OAM_RX_BASE_ADDR,0xa4,23,22},
	{BAS_CSF_LPI_60_INT,OAM_RX_BASE_ADDR,0xa4,25,24},
	{BAS_CSF_LPI_61_INT,OAM_RX_BASE_ADDR,0xa4,27,26},
	{BAS_CSF_LPI_62_INT,OAM_RX_BASE_ADDR,0xa4,29,28},
	{BAS_CSF_LPI_63_INT,OAM_RX_BASE_ADDR,0xa4,31,30},
};
const CHIP_REG bas_csf_lpi_i3_INT_MASK_REG[]=
{
	{BAS_CSF_LPI_48_INT_MASK,OAM_RX_BASE_ADDR,0xa5,1,0},
	{BAS_CSF_LPI_49_INT_MASK,OAM_RX_BASE_ADDR,0xa5,3,2},
	{BAS_CSF_LPI_50_INT_MASK,OAM_RX_BASE_ADDR,0xa5,5,4},
	{BAS_CSF_LPI_51_INT_MASK,OAM_RX_BASE_ADDR,0xa5,7,6},
	{BAS_CSF_LPI_52_INT_MASK,OAM_RX_BASE_ADDR,0xa5,9,8},
	{BAS_CSF_LPI_53_INT_MASK,OAM_RX_BASE_ADDR,0xa5,11,10},
	{BAS_CSF_LPI_54_INT_MASK,OAM_RX_BASE_ADDR,0xa5,13,12},
	{BAS_CSF_LPI_55_INT_MASK,OAM_RX_BASE_ADDR,0xa5,15,14},
	{BAS_CSF_LPI_56_INT_MASK,OAM_RX_BASE_ADDR,0xa5,17,16},
	{BAS_CSF_LPI_57_INT_MASK,OAM_RX_BASE_ADDR,0xa5,19,18},
	{BAS_CSF_LPI_58_INT_MASK,OAM_RX_BASE_ADDR,0xa5,21,20},
	{BAS_CSF_LPI_59_INT_MASK,OAM_RX_BASE_ADDR,0xa5,23,22},
	{BAS_CSF_LPI_60_INT_MASK,OAM_RX_BASE_ADDR,0xa5,25,24},
	{BAS_CSF_LPI_61_INT_MASK,OAM_RX_BASE_ADDR,0xa5,27,26},
	{BAS_CSF_LPI_62_INT_MASK,OAM_RX_BASE_ADDR,0xa5,29,28},
	{BAS_CSF_LPI_63_INT_MASK,OAM_RX_BASE_ADDR,0xa5,31,30},
};
const CHIP_REG bas_csf_lpi_i4_INT_REG[]=
{
	{BAS_CSF_LPI_64_INT,OAM_RX_BASE_ADDR,0xa6,1,0},
	{BAS_CSF_LPI_65_INT,OAM_RX_BASE_ADDR,0xa6,3,2},
	{BAS_CSF_LPI_66_INT,OAM_RX_BASE_ADDR,0xa6,5,4},
	{BAS_CSF_LPI_67_INT,OAM_RX_BASE_ADDR,0xa6,7,6},
	{BAS_CSF_LPI_68_INT,OAM_RX_BASE_ADDR,0xa6,9,8},
	{BAS_CSF_LPI_69_INT,OAM_RX_BASE_ADDR,0xa6,11,10},
	{BAS_CSF_LPI_70_INT,OAM_RX_BASE_ADDR,0xa6,13,12},
	{BAS_CSF_LPI_71_INT,OAM_RX_BASE_ADDR,0xa6,15,14},
	{BAS_CSF_LPI_72_INT,OAM_RX_BASE_ADDR,0xa6,17,16},
	{BAS_CSF_LPI_73_INT,OAM_RX_BASE_ADDR,0xa6,19,18},
	{BAS_CSF_LPI_74_INT,OAM_RX_BASE_ADDR,0xa6,21,20},
	{BAS_CSF_LPI_75_INT,OAM_RX_BASE_ADDR,0xa6,23,22},
	{BAS_CSF_LPI_76_INT,OAM_RX_BASE_ADDR,0xa6,25,24},
	{BAS_CSF_LPI_77_INT,OAM_RX_BASE_ADDR,0xa6,27,26},
	{BAS_CSF_LPI_78_INT,OAM_RX_BASE_ADDR,0xa6,29,28},
	{BAS_CSF_LPI_79_INT,OAM_RX_BASE_ADDR,0xa6,31,30},
};
const CHIP_REG bas_csf_lpi_i4_INT_MASK_REG[]=
{
	{BAS_CSF_LPI_64_INT_MASK,OAM_RX_BASE_ADDR,0xa7,1,0},
	{BAS_CSF_LPI_65_INT_MASK,OAM_RX_BASE_ADDR,0xa7,3,2},
	{BAS_CSF_LPI_66_INT_MASK,OAM_RX_BASE_ADDR,0xa7,5,4},
	{BAS_CSF_LPI_67_INT_MASK,OAM_RX_BASE_ADDR,0xa7,7,6},
	{BAS_CSF_LPI_68_INT_MASK,OAM_RX_BASE_ADDR,0xa7,9,8},
	{BAS_CSF_LPI_69_INT_MASK,OAM_RX_BASE_ADDR,0xa7,11,10},
	{BAS_CSF_LPI_70_INT_MASK,OAM_RX_BASE_ADDR,0xa7,13,12},
	{BAS_CSF_LPI_71_INT_MASK,OAM_RX_BASE_ADDR,0xa7,15,14},
	{BAS_CSF_LPI_72_INT_MASK,OAM_RX_BASE_ADDR,0xa7,17,16},
	{BAS_CSF_LPI_73_INT_MASK,OAM_RX_BASE_ADDR,0xa7,19,18},
	{BAS_CSF_LPI_74_INT_MASK,OAM_RX_BASE_ADDR,0xa7,21,20},
	{BAS_CSF_LPI_75_INT_MASK,OAM_RX_BASE_ADDR,0xa7,23,22},
	{BAS_CSF_LPI_76_INT_MASK,OAM_RX_BASE_ADDR,0xa7,25,24},
	{BAS_CSF_LPI_77_INT_MASK,OAM_RX_BASE_ADDR,0xa7,27,26},
	{BAS_CSF_LPI_78_INT_MASK,OAM_RX_BASE_ADDR,0xa7,29,28},
	{BAS_CSF_LPI_79_INT_MASK,OAM_RX_BASE_ADDR,0xa7,31,30},
};
const CHIP_REG bas_cs_lf_i0_INT_REG[]=
{
	{BAS_CS_LF_0_INT,OAM_RX_BASE_ADDR,0xa8,1,0},
	{BAS_CS_LF_1_INT,OAM_RX_BASE_ADDR,0xa8,3,2},
	{BAS_CS_LF_2_INT,OAM_RX_BASE_ADDR,0xa8,5,4},
	{BAS_CS_LF_3_INT,OAM_RX_BASE_ADDR,0xa8,7,6},
	{BAS_CS_LF_4_INT,OAM_RX_BASE_ADDR,0xa8,9,8},
	{BAS_CS_LF_5_INT,OAM_RX_BASE_ADDR,0xa8,11,10},
	{BAS_CS_LF_6_INT,OAM_RX_BASE_ADDR,0xa8,13,12},
	{BAS_CS_LF_7_INT,OAM_RX_BASE_ADDR,0xa8,15,14},
	{BAS_CS_LF_8_INT,OAM_RX_BASE_ADDR,0xa8,17,16},
	{BAS_CS_LF_9_INT,OAM_RX_BASE_ADDR,0xa8,19,18},
	{BAS_CS_LF_10_INT,OAM_RX_BASE_ADDR,0xa8,21,20},
	{BAS_CS_LF_11_INT,OAM_RX_BASE_ADDR,0xa8,23,22},
	{BAS_CS_LF_12_INT,OAM_RX_BASE_ADDR,0xa8,25,24},
	{BAS_CS_LF_13_INT,OAM_RX_BASE_ADDR,0xa8,27,26},
	{BAS_CS_LF_14_INT,OAM_RX_BASE_ADDR,0xa8,29,28},
	{BAS_CS_LF_15_INT,OAM_RX_BASE_ADDR,0xa8,31,30},
};
const CHIP_REG bas_cs_lf_i0_INT_MASK_REG[]=
{
	{BAS_CS_LF_0_INT_MASK,OAM_RX_BASE_ADDR,0xa9,1,0},
	{BAS_CS_LF_1_INT_MASK,OAM_RX_BASE_ADDR,0xa9,3,2},
	{BAS_CS_LF_2_INT_MASK,OAM_RX_BASE_ADDR,0xa9,5,4},
	{BAS_CS_LF_3_INT_MASK,OAM_RX_BASE_ADDR,0xa9,7,6},
	{BAS_CS_LF_4_INT_MASK,OAM_RX_BASE_ADDR,0xa9,9,8},
	{BAS_CS_LF_5_INT_MASK,OAM_RX_BASE_ADDR,0xa9,11,10},
	{BAS_CS_LF_6_INT_MASK,OAM_RX_BASE_ADDR,0xa9,13,12},
	{BAS_CS_LF_7_INT_MASK,OAM_RX_BASE_ADDR,0xa9,15,14},
	{BAS_CS_LF_8_INT_MASK,OAM_RX_BASE_ADDR,0xa9,17,16},
	{BAS_CS_LF_9_INT_MASK,OAM_RX_BASE_ADDR,0xa9,19,18},
	{BAS_CS_LF_10_INT_MASK,OAM_RX_BASE_ADDR,0xa9,21,20},
	{BAS_CS_LF_11_INT_MASK,OAM_RX_BASE_ADDR,0xa9,23,22},
	{BAS_CS_LF_12_INT_MASK,OAM_RX_BASE_ADDR,0xa9,25,24},
	{BAS_CS_LF_13_INT_MASK,OAM_RX_BASE_ADDR,0xa9,27,26},
	{BAS_CS_LF_14_INT_MASK,OAM_RX_BASE_ADDR,0xa9,29,28},
	{BAS_CS_LF_15_INT_MASK,OAM_RX_BASE_ADDR,0xa9,31,30},
};
const CHIP_REG bas_cs_lf_i1_INT_REG[]=
{
	{BAS_CS_LF_16_INT,OAM_RX_BASE_ADDR,0xaa,1,0},
	{BAS_CS_LF_17_INT,OAM_RX_BASE_ADDR,0xaa,3,2},
	{BAS_CS_LF_18_INT,OAM_RX_BASE_ADDR,0xaa,5,4},
	{BAS_CS_LF_19_INT,OAM_RX_BASE_ADDR,0xaa,7,6},
	{BAS_CS_LF_20_INT,OAM_RX_BASE_ADDR,0xaa,9,8},
	{BAS_CS_LF_21_INT,OAM_RX_BASE_ADDR,0xaa,11,10},
	{BAS_CS_LF_22_INT,OAM_RX_BASE_ADDR,0xaa,13,12},
	{BAS_CS_LF_23_INT,OAM_RX_BASE_ADDR,0xaa,15,14},
	{BAS_CS_LF_24_INT,OAM_RX_BASE_ADDR,0xaa,17,16},
	{BAS_CS_LF_25_INT,OAM_RX_BASE_ADDR,0xaa,19,18},
	{BAS_CS_LF_26_INT,OAM_RX_BASE_ADDR,0xaa,21,20},
	{BAS_CS_LF_27_INT,OAM_RX_BASE_ADDR,0xaa,23,22},
	{BAS_CS_LF_28_INT,OAM_RX_BASE_ADDR,0xaa,25,24},
	{BAS_CS_LF_29_INT,OAM_RX_BASE_ADDR,0xaa,27,26},
	{BAS_CS_LF_30_INT,OAM_RX_BASE_ADDR,0xaa,29,28},
	{BAS_CS_LF_31_INT,OAM_RX_BASE_ADDR,0xaa,31,30},
};
const CHIP_REG bas_cs_lf_i1_INT_MASK_REG[]=
{
	{BAS_CS_LF_16_INT_MASK,OAM_RX_BASE_ADDR,0xab,1,0},
	{BAS_CS_LF_17_INT_MASK,OAM_RX_BASE_ADDR,0xab,3,2},
	{BAS_CS_LF_18_INT_MASK,OAM_RX_BASE_ADDR,0xab,5,4},
	{BAS_CS_LF_19_INT_MASK,OAM_RX_BASE_ADDR,0xab,7,6},
	{BAS_CS_LF_20_INT_MASK,OAM_RX_BASE_ADDR,0xab,9,8},
	{BAS_CS_LF_21_INT_MASK,OAM_RX_BASE_ADDR,0xab,11,10},
	{BAS_CS_LF_22_INT_MASK,OAM_RX_BASE_ADDR,0xab,13,12},
	{BAS_CS_LF_23_INT_MASK,OAM_RX_BASE_ADDR,0xab,15,14},
	{BAS_CS_LF_24_INT_MASK,OAM_RX_BASE_ADDR,0xab,17,16},
	{BAS_CS_LF_25_INT_MASK,OAM_RX_BASE_ADDR,0xab,19,18},
	{BAS_CS_LF_26_INT_MASK,OAM_RX_BASE_ADDR,0xab,21,20},
	{BAS_CS_LF_27_INT_MASK,OAM_RX_BASE_ADDR,0xab,23,22},
	{BAS_CS_LF_28_INT_MASK,OAM_RX_BASE_ADDR,0xab,25,24},
	{BAS_CS_LF_29_INT_MASK,OAM_RX_BASE_ADDR,0xab,27,26},
	{BAS_CS_LF_30_INT_MASK,OAM_RX_BASE_ADDR,0xab,29,28},
	{BAS_CS_LF_31_INT_MASK,OAM_RX_BASE_ADDR,0xab,31,30},
};
const CHIP_REG bas_cs_lf_i2_INT_REG[]=
{
	{BAS_CS_LF_32_INT,OAM_RX_BASE_ADDR,0xac,1,0},
	{BAS_CS_LF_33_INT,OAM_RX_BASE_ADDR,0xac,3,2},
	{BAS_CS_LF_34_INT,OAM_RX_BASE_ADDR,0xac,5,4},
	{BAS_CS_LF_35_INT,OAM_RX_BASE_ADDR,0xac,7,6},
	{BAS_CS_LF_36_INT,OAM_RX_BASE_ADDR,0xac,9,8},
	{BAS_CS_LF_37_INT,OAM_RX_BASE_ADDR,0xac,11,10},
	{BAS_CS_LF_38_INT,OAM_RX_BASE_ADDR,0xac,13,12},
	{BAS_CS_LF_39_INT,OAM_RX_BASE_ADDR,0xac,15,14},
	{BAS_CS_LF_40_INT,OAM_RX_BASE_ADDR,0xac,17,16},
	{BAS_CS_LF_41_INT,OAM_RX_BASE_ADDR,0xac,19,18},
	{BAS_CS_LF_42_INT,OAM_RX_BASE_ADDR,0xac,21,20},
	{BAS_CS_LF_43_INT,OAM_RX_BASE_ADDR,0xac,23,22},
	{BAS_CS_LF_44_INT,OAM_RX_BASE_ADDR,0xac,25,24},
	{BAS_CS_LF_45_INT,OAM_RX_BASE_ADDR,0xac,27,26},
	{BAS_CS_LF_46_INT,OAM_RX_BASE_ADDR,0xac,29,28},
	{BAS_CS_LF_47_INT,OAM_RX_BASE_ADDR,0xac,31,30},
};
const CHIP_REG bas_cs_lf_i2_INT_MASK_REG[]=
{
	{BAS_CS_LF_32_INT_MASK,OAM_RX_BASE_ADDR,0xad,1,0},
	{BAS_CS_LF_33_INT_MASK,OAM_RX_BASE_ADDR,0xad,3,2},
	{BAS_CS_LF_34_INT_MASK,OAM_RX_BASE_ADDR,0xad,5,4},
	{BAS_CS_LF_35_INT_MASK,OAM_RX_BASE_ADDR,0xad,7,6},
	{BAS_CS_LF_36_INT_MASK,OAM_RX_BASE_ADDR,0xad,9,8},
	{BAS_CS_LF_37_INT_MASK,OAM_RX_BASE_ADDR,0xad,11,10},
	{BAS_CS_LF_38_INT_MASK,OAM_RX_BASE_ADDR,0xad,13,12},
	{BAS_CS_LF_39_INT_MASK,OAM_RX_BASE_ADDR,0xad,15,14},
	{BAS_CS_LF_40_INT_MASK,OAM_RX_BASE_ADDR,0xad,17,16},
	{BAS_CS_LF_41_INT_MASK,OAM_RX_BASE_ADDR,0xad,19,18},
	{BAS_CS_LF_42_INT_MASK,OAM_RX_BASE_ADDR,0xad,21,20},
	{BAS_CS_LF_43_INT_MASK,OAM_RX_BASE_ADDR,0xad,23,22},
	{BAS_CS_LF_44_INT_MASK,OAM_RX_BASE_ADDR,0xad,25,24},
	{BAS_CS_LF_45_INT_MASK,OAM_RX_BASE_ADDR,0xad,27,26},
	{BAS_CS_LF_46_INT_MASK,OAM_RX_BASE_ADDR,0xad,29,28},
	{BAS_CS_LF_47_INT_MASK,OAM_RX_BASE_ADDR,0xad,31,30},
};
const CHIP_REG bas_cs_lf_i3_INT_REG[]=
{
	{BAS_CS_LF_48_INT,OAM_RX_BASE_ADDR,0xae,1,0},
	{BAS_CS_LF_49_INT,OAM_RX_BASE_ADDR,0xae,3,2},
	{BAS_CS_LF_50_INT,OAM_RX_BASE_ADDR,0xae,5,4},
	{BAS_CS_LF_51_INT,OAM_RX_BASE_ADDR,0xae,7,6},
	{BAS_CS_LF_52_INT,OAM_RX_BASE_ADDR,0xae,9,8},
	{BAS_CS_LF_53_INT,OAM_RX_BASE_ADDR,0xae,11,10},
	{BAS_CS_LF_54_INT,OAM_RX_BASE_ADDR,0xae,13,12},
	{BAS_CS_LF_55_INT,OAM_RX_BASE_ADDR,0xae,15,14},
	{BAS_CS_LF_56_INT,OAM_RX_BASE_ADDR,0xae,17,16},
	{BAS_CS_LF_57_INT,OAM_RX_BASE_ADDR,0xae,19,18},
	{BAS_CS_LF_58_INT,OAM_RX_BASE_ADDR,0xae,21,20},
	{BAS_CS_LF_59_INT,OAM_RX_BASE_ADDR,0xae,23,22},
	{BAS_CS_LF_60_INT,OAM_RX_BASE_ADDR,0xae,25,24},
	{BAS_CS_LF_61_INT,OAM_RX_BASE_ADDR,0xae,27,26},
	{BAS_CS_LF_62_INT,OAM_RX_BASE_ADDR,0xae,29,28},
	{BAS_CS_LF_63_INT,OAM_RX_BASE_ADDR,0xae,31,30},
};
const CHIP_REG bas_cs_lf_i3_INT_MASK_REG[]=
{
	{BAS_CS_LF_48_INT_MASK,OAM_RX_BASE_ADDR,0xaf,1,0},
	{BAS_CS_LF_49_INT_MASK,OAM_RX_BASE_ADDR,0xaf,3,2},
	{BAS_CS_LF_50_INT_MASK,OAM_RX_BASE_ADDR,0xaf,5,4},
	{BAS_CS_LF_51_INT_MASK,OAM_RX_BASE_ADDR,0xaf,7,6},
	{BAS_CS_LF_52_INT_MASK,OAM_RX_BASE_ADDR,0xaf,9,8},
	{BAS_CS_LF_53_INT_MASK,OAM_RX_BASE_ADDR,0xaf,11,10},
	{BAS_CS_LF_54_INT_MASK,OAM_RX_BASE_ADDR,0xaf,13,12},
	{BAS_CS_LF_55_INT_MASK,OAM_RX_BASE_ADDR,0xaf,15,14},
	{BAS_CS_LF_56_INT_MASK,OAM_RX_BASE_ADDR,0xaf,17,16},
	{BAS_CS_LF_57_INT_MASK,OAM_RX_BASE_ADDR,0xaf,19,18},
	{BAS_CS_LF_58_INT_MASK,OAM_RX_BASE_ADDR,0xaf,21,20},
	{BAS_CS_LF_59_INT_MASK,OAM_RX_BASE_ADDR,0xaf,23,22},
	{BAS_CS_LF_60_INT_MASK,OAM_RX_BASE_ADDR,0xaf,25,24},
	{BAS_CS_LF_61_INT_MASK,OAM_RX_BASE_ADDR,0xaf,27,26},
	{BAS_CS_LF_62_INT_MASK,OAM_RX_BASE_ADDR,0xaf,29,28},
	{BAS_CS_LF_63_INT_MASK,OAM_RX_BASE_ADDR,0xaf,31,30},
};
const CHIP_REG bas_cs_lf_i4_INT_REG[]=
{
	{BAS_CS_LF_64_INT,OAM_RX_BASE_ADDR,0xb0,1,0},
	{BAS_CS_LF_65_INT,OAM_RX_BASE_ADDR,0xb0,3,2},
	{BAS_CS_LF_66_INT,OAM_RX_BASE_ADDR,0xb0,5,4},
	{BAS_CS_LF_67_INT,OAM_RX_BASE_ADDR,0xb0,7,6},
	{BAS_CS_LF_68_INT,OAM_RX_BASE_ADDR,0xb0,9,8},
	{BAS_CS_LF_69_INT,OAM_RX_BASE_ADDR,0xb0,11,10},
	{BAS_CS_LF_70_INT,OAM_RX_BASE_ADDR,0xb0,13,12},
	{BAS_CS_LF_71_INT,OAM_RX_BASE_ADDR,0xb0,15,14},
	{BAS_CS_LF_72_INT,OAM_RX_BASE_ADDR,0xb0,17,16},
	{BAS_CS_LF_73_INT,OAM_RX_BASE_ADDR,0xb0,19,18},
	{BAS_CS_LF_74_INT,OAM_RX_BASE_ADDR,0xb0,21,20},
	{BAS_CS_LF_75_INT,OAM_RX_BASE_ADDR,0xb0,23,22},
	{BAS_CS_LF_76_INT,OAM_RX_BASE_ADDR,0xb0,25,24},
	{BAS_CS_LF_77_INT,OAM_RX_BASE_ADDR,0xb0,27,26},
	{BAS_CS_LF_78_INT,OAM_RX_BASE_ADDR,0xb0,29,28},
	{BAS_CS_LF_79_INT,OAM_RX_BASE_ADDR,0xb0,31,30},
};
const CHIP_REG bas_cs_lf_i4_INT_MASK_REG[]=
{
	{BAS_CS_LF_64_INT_MASK,OAM_RX_BASE_ADDR,0xb1,1,0},
	{BAS_CS_LF_65_INT_MASK,OAM_RX_BASE_ADDR,0xb1,3,2},
	{BAS_CS_LF_66_INT_MASK,OAM_RX_BASE_ADDR,0xb1,5,4},
	{BAS_CS_LF_67_INT_MASK,OAM_RX_BASE_ADDR,0xb1,7,6},
	{BAS_CS_LF_68_INT_MASK,OAM_RX_BASE_ADDR,0xb1,9,8},
	{BAS_CS_LF_69_INT_MASK,OAM_RX_BASE_ADDR,0xb1,11,10},
	{BAS_CS_LF_70_INT_MASK,OAM_RX_BASE_ADDR,0xb1,13,12},
	{BAS_CS_LF_71_INT_MASK,OAM_RX_BASE_ADDR,0xb1,15,14},
	{BAS_CS_LF_72_INT_MASK,OAM_RX_BASE_ADDR,0xb1,17,16},
	{BAS_CS_LF_73_INT_MASK,OAM_RX_BASE_ADDR,0xb1,19,18},
	{BAS_CS_LF_74_INT_MASK,OAM_RX_BASE_ADDR,0xb1,21,20},
	{BAS_CS_LF_75_INT_MASK,OAM_RX_BASE_ADDR,0xb1,23,22},
	{BAS_CS_LF_76_INT_MASK,OAM_RX_BASE_ADDR,0xb1,25,24},
	{BAS_CS_LF_77_INT_MASK,OAM_RX_BASE_ADDR,0xb1,27,26},
	{BAS_CS_LF_78_INT_MASK,OAM_RX_BASE_ADDR,0xb1,29,28},
	{BAS_CS_LF_79_INT_MASK,OAM_RX_BASE_ADDR,0xb1,31,30},
};
const CHIP_REG bas_cs_rf_i0_INT_REG[]=
{
	{BAS_CS_RF_0_INT,OAM_RX_BASE_ADDR,0xb2,1,0},
	{BAS_CS_RF_1_INT,OAM_RX_BASE_ADDR,0xb2,3,2},
	{BAS_CS_RF_2_INT,OAM_RX_BASE_ADDR,0xb2,5,4},
	{BAS_CS_RF_3_INT,OAM_RX_BASE_ADDR,0xb2,7,6},
	{BAS_CS_RF_4_INT,OAM_RX_BASE_ADDR,0xb2,9,8},
	{BAS_CS_RF_5_INT,OAM_RX_BASE_ADDR,0xb2,11,10},
	{BAS_CS_RF_6_INT,OAM_RX_BASE_ADDR,0xb2,13,12},
	{BAS_CS_RF_7_INT,OAM_RX_BASE_ADDR,0xb2,15,14},
	{BAS_CS_RF_8_INT,OAM_RX_BASE_ADDR,0xb2,17,16},
	{BAS_CS_RF_9_INT,OAM_RX_BASE_ADDR,0xb2,19,18},
	{BAS_CS_RF_10_INT,OAM_RX_BASE_ADDR,0xb2,21,20},
	{BAS_CS_RF_11_INT,OAM_RX_BASE_ADDR,0xb2,23,22},
	{BAS_CS_RF_12_INT,OAM_RX_BASE_ADDR,0xb2,25,24},
	{BAS_CS_RF_13_INT,OAM_RX_BASE_ADDR,0xb2,27,26},
	{BAS_CS_RF_14_INT,OAM_RX_BASE_ADDR,0xb2,29,28},
	{BAS_CS_RF_15_INT,OAM_RX_BASE_ADDR,0xb2,31,30},
};
const CHIP_REG bas_cs_rf_i0_INT_MASK_REG[]=
{
	{BAS_CS_RF_0_INT_MASK,OAM_RX_BASE_ADDR,0xb3,1,0},
	{BAS_CS_RF_1_INT_MASK,OAM_RX_BASE_ADDR,0xb3,3,2},
	{BAS_CS_RF_2_INT_MASK,OAM_RX_BASE_ADDR,0xb3,5,4},
	{BAS_CS_RF_3_INT_MASK,OAM_RX_BASE_ADDR,0xb3,7,6},
	{BAS_CS_RF_4_INT_MASK,OAM_RX_BASE_ADDR,0xb3,9,8},
	{BAS_CS_RF_5_INT_MASK,OAM_RX_BASE_ADDR,0xb3,11,10},
	{BAS_CS_RF_6_INT_MASK,OAM_RX_BASE_ADDR,0xb3,13,12},
	{BAS_CS_RF_7_INT_MASK,OAM_RX_BASE_ADDR,0xb3,15,14},
	{BAS_CS_RF_8_INT_MASK,OAM_RX_BASE_ADDR,0xb3,17,16},
	{BAS_CS_RF_9_INT_MASK,OAM_RX_BASE_ADDR,0xb3,19,18},
	{BAS_CS_RF_10_INT_MASK,OAM_RX_BASE_ADDR,0xb3,21,20},
	{BAS_CS_RF_11_INT_MASK,OAM_RX_BASE_ADDR,0xb3,23,22},
	{BAS_CS_RF_12_INT_MASK,OAM_RX_BASE_ADDR,0xb3,25,24},
	{BAS_CS_RF_13_INT_MASK,OAM_RX_BASE_ADDR,0xb3,27,26},
	{BAS_CS_RF_14_INT_MASK,OAM_RX_BASE_ADDR,0xb3,29,28},
	{BAS_CS_RF_15_INT_MASK,OAM_RX_BASE_ADDR,0xb3,31,30},
};
const CHIP_REG bas_cs_rf_i1_INT_REG[]=
{
	{BAS_CS_RF_16_INT,OAM_RX_BASE_ADDR,0xb4,1,0},
	{BAS_CS_RF_17_INT,OAM_RX_BASE_ADDR,0xb4,3,2},
	{BAS_CS_RF_18_INT,OAM_RX_BASE_ADDR,0xb4,5,4},
	{BAS_CS_RF_19_INT,OAM_RX_BASE_ADDR,0xb4,7,6},
	{BAS_CS_RF_20_INT,OAM_RX_BASE_ADDR,0xb4,9,8},
	{BAS_CS_RF_21_INT,OAM_RX_BASE_ADDR,0xb4,11,10},
	{BAS_CS_RF_22_INT,OAM_RX_BASE_ADDR,0xb4,13,12},
	{BAS_CS_RF_23_INT,OAM_RX_BASE_ADDR,0xb4,15,14},
	{BAS_CS_RF_24_INT,OAM_RX_BASE_ADDR,0xb4,17,16},
	{BAS_CS_RF_25_INT,OAM_RX_BASE_ADDR,0xb4,19,18},
	{BAS_CS_RF_26_INT,OAM_RX_BASE_ADDR,0xb4,21,20},
	{BAS_CS_RF_27_INT,OAM_RX_BASE_ADDR,0xb4,23,22},
	{BAS_CS_RF_28_INT,OAM_RX_BASE_ADDR,0xb4,25,24},
	{BAS_CS_RF_29_INT,OAM_RX_BASE_ADDR,0xb4,27,26},
	{BAS_CS_RF_30_INT,OAM_RX_BASE_ADDR,0xb4,29,28},
	{BAS_CS_RF_31_INT,OAM_RX_BASE_ADDR,0xb4,31,30},
};
const CHIP_REG bas_cs_rf_i1_INT_MASK_REG[]=
{
	{BAS_CS_RF_16_INT_MASK,OAM_RX_BASE_ADDR,0xb5,1,0},
	{BAS_CS_RF_17_INT_MASK,OAM_RX_BASE_ADDR,0xb5,3,2},
	{BAS_CS_RF_18_INT_MASK,OAM_RX_BASE_ADDR,0xb5,5,4},
	{BAS_CS_RF_19_INT_MASK,OAM_RX_BASE_ADDR,0xb5,7,6},
	{BAS_CS_RF_20_INT_MASK,OAM_RX_BASE_ADDR,0xb5,9,8},
	{BAS_CS_RF_21_INT_MASK,OAM_RX_BASE_ADDR,0xb5,11,10},
	{BAS_CS_RF_22_INT_MASK,OAM_RX_BASE_ADDR,0xb5,13,12},
	{BAS_CS_RF_23_INT_MASK,OAM_RX_BASE_ADDR,0xb5,15,14},
	{BAS_CS_RF_24_INT_MASK,OAM_RX_BASE_ADDR,0xb5,17,16},
	{BAS_CS_RF_25_INT_MASK,OAM_RX_BASE_ADDR,0xb5,19,18},
	{BAS_CS_RF_26_INT_MASK,OAM_RX_BASE_ADDR,0xb5,21,20},
	{BAS_CS_RF_27_INT_MASK,OAM_RX_BASE_ADDR,0xb5,23,22},
	{BAS_CS_RF_28_INT_MASK,OAM_RX_BASE_ADDR,0xb5,25,24},
	{BAS_CS_RF_29_INT_MASK,OAM_RX_BASE_ADDR,0xb5,27,26},
	{BAS_CS_RF_30_INT_MASK,OAM_RX_BASE_ADDR,0xb5,29,28},
	{BAS_CS_RF_31_INT_MASK,OAM_RX_BASE_ADDR,0xb5,31,30},
};
const CHIP_REG bas_cs_rf_i2_INT_REG[]=
{
	{BAS_CS_RF_32_INT,OAM_RX_BASE_ADDR,0xb6,1,0},
	{BAS_CS_RF_33_INT,OAM_RX_BASE_ADDR,0xb6,3,2},
	{BAS_CS_RF_34_INT,OAM_RX_BASE_ADDR,0xb6,5,4},
	{BAS_CS_RF_35_INT,OAM_RX_BASE_ADDR,0xb6,7,6},
	{BAS_CS_RF_36_INT,OAM_RX_BASE_ADDR,0xb6,9,8},
	{BAS_CS_RF_37_INT,OAM_RX_BASE_ADDR,0xb6,11,10},
	{BAS_CS_RF_38_INT,OAM_RX_BASE_ADDR,0xb6,13,12},
	{BAS_CS_RF_39_INT,OAM_RX_BASE_ADDR,0xb6,15,14},
	{BAS_CS_RF_40_INT,OAM_RX_BASE_ADDR,0xb6,17,16},
	{BAS_CS_RF_41_INT,OAM_RX_BASE_ADDR,0xb6,19,18},
	{BAS_CS_RF_42_INT,OAM_RX_BASE_ADDR,0xb6,21,20},
	{BAS_CS_RF_43_INT,OAM_RX_BASE_ADDR,0xb6,23,22},
	{BAS_CS_RF_44_INT,OAM_RX_BASE_ADDR,0xb6,25,24},
	{BAS_CS_RF_45_INT,OAM_RX_BASE_ADDR,0xb6,27,26},
	{BAS_CS_RF_46_INT,OAM_RX_BASE_ADDR,0xb6,29,28},
	{BAS_CS_RF_47_INT,OAM_RX_BASE_ADDR,0xb6,31,30},
};
const CHIP_REG bas_cs_rf_i2_INT_MASK_REG[]=
{
	{BAS_CS_RF_32_INT_MASK,OAM_RX_BASE_ADDR,0xb7,1,0},
	{BAS_CS_RF_33_INT_MASK,OAM_RX_BASE_ADDR,0xb7,3,2},
	{BAS_CS_RF_34_INT_MASK,OAM_RX_BASE_ADDR,0xb7,5,4},
	{BAS_CS_RF_35_INT_MASK,OAM_RX_BASE_ADDR,0xb7,7,6},
	{BAS_CS_RF_36_INT_MASK,OAM_RX_BASE_ADDR,0xb7,9,8},
	{BAS_CS_RF_37_INT_MASK,OAM_RX_BASE_ADDR,0xb7,11,10},
	{BAS_CS_RF_38_INT_MASK,OAM_RX_BASE_ADDR,0xb7,13,12},
	{BAS_CS_RF_39_INT_MASK,OAM_RX_BASE_ADDR,0xb7,15,14},
	{BAS_CS_RF_40_INT_MASK,OAM_RX_BASE_ADDR,0xb7,17,16},
	{BAS_CS_RF_41_INT_MASK,OAM_RX_BASE_ADDR,0xb7,19,18},
	{BAS_CS_RF_42_INT_MASK,OAM_RX_BASE_ADDR,0xb7,21,20},
	{BAS_CS_RF_43_INT_MASK,OAM_RX_BASE_ADDR,0xb7,23,22},
	{BAS_CS_RF_44_INT_MASK,OAM_RX_BASE_ADDR,0xb7,25,24},
	{BAS_CS_RF_45_INT_MASK,OAM_RX_BASE_ADDR,0xb7,27,26},
	{BAS_CS_RF_46_INT_MASK,OAM_RX_BASE_ADDR,0xb7,29,28},
	{BAS_CS_RF_47_INT_MASK,OAM_RX_BASE_ADDR,0xb7,31,30},
};
const CHIP_REG bas_cs_rf_i3_INT_REG[]=
{
	{BAS_CS_RF_48_INT,OAM_RX_BASE_ADDR,0xb8,1,0},
	{BAS_CS_RF_49_INT,OAM_RX_BASE_ADDR,0xb8,3,2},
	{BAS_CS_RF_50_INT,OAM_RX_BASE_ADDR,0xb8,5,4},
	{BAS_CS_RF_51_INT,OAM_RX_BASE_ADDR,0xb8,7,6},
	{BAS_CS_RF_52_INT,OAM_RX_BASE_ADDR,0xb8,9,8},
	{BAS_CS_RF_53_INT,OAM_RX_BASE_ADDR,0xb8,11,10},
	{BAS_CS_RF_54_INT,OAM_RX_BASE_ADDR,0xb8,13,12},
	{BAS_CS_RF_55_INT,OAM_RX_BASE_ADDR,0xb8,15,14},
	{BAS_CS_RF_56_INT,OAM_RX_BASE_ADDR,0xb8,17,16},
	{BAS_CS_RF_57_INT,OAM_RX_BASE_ADDR,0xb8,19,18},
	{BAS_CS_RF_58_INT,OAM_RX_BASE_ADDR,0xb8,21,20},
	{BAS_CS_RF_59_INT,OAM_RX_BASE_ADDR,0xb8,23,22},
	{BAS_CS_RF_60_INT,OAM_RX_BASE_ADDR,0xb8,25,24},
	{BAS_CS_RF_61_INT,OAM_RX_BASE_ADDR,0xb8,27,26},
	{BAS_CS_RF_62_INT,OAM_RX_BASE_ADDR,0xb8,29,28},
	{BAS_CS_RF_63_INT,OAM_RX_BASE_ADDR,0xb8,31,30},
};
const CHIP_REG bas_cs_rf_i3_INT_MASK_REG[]=
{
	{BAS_CS_RF_48_INT_MASK,OAM_RX_BASE_ADDR,0xb9,1,0},
	{BAS_CS_RF_49_INT_MASK,OAM_RX_BASE_ADDR,0xb9,3,2},
	{BAS_CS_RF_50_INT_MASK,OAM_RX_BASE_ADDR,0xb9,5,4},
	{BAS_CS_RF_51_INT_MASK,OAM_RX_BASE_ADDR,0xb9,7,6},
	{BAS_CS_RF_52_INT_MASK,OAM_RX_BASE_ADDR,0xb9,9,8},
	{BAS_CS_RF_53_INT_MASK,OAM_RX_BASE_ADDR,0xb9,11,10},
	{BAS_CS_RF_54_INT_MASK,OAM_RX_BASE_ADDR,0xb9,13,12},
	{BAS_CS_RF_55_INT_MASK,OAM_RX_BASE_ADDR,0xb9,15,14},
	{BAS_CS_RF_56_INT_MASK,OAM_RX_BASE_ADDR,0xb9,17,16},
	{BAS_CS_RF_57_INT_MASK,OAM_RX_BASE_ADDR,0xb9,19,18},
	{BAS_CS_RF_58_INT_MASK,OAM_RX_BASE_ADDR,0xb9,21,20},
	{BAS_CS_RF_59_INT_MASK,OAM_RX_BASE_ADDR,0xb9,23,22},
	{BAS_CS_RF_60_INT_MASK,OAM_RX_BASE_ADDR,0xb9,25,24},
	{BAS_CS_RF_61_INT_MASK,OAM_RX_BASE_ADDR,0xb9,27,26},
	{BAS_CS_RF_62_INT_MASK,OAM_RX_BASE_ADDR,0xb9,29,28},
	{BAS_CS_RF_63_INT_MASK,OAM_RX_BASE_ADDR,0xb9,31,30},
};
const CHIP_REG bas_cs_rf_i4_INT_REG[]=
{
	{BAS_CS_RF_64_INT,OAM_RX_BASE_ADDR,0xba,1,0},
	{BAS_CS_RF_65_INT,OAM_RX_BASE_ADDR,0xba,3,2},
	{BAS_CS_RF_66_INT,OAM_RX_BASE_ADDR,0xba,5,4},
	{BAS_CS_RF_67_INT,OAM_RX_BASE_ADDR,0xba,7,6},
	{BAS_CS_RF_68_INT,OAM_RX_BASE_ADDR,0xba,9,8},
	{BAS_CS_RF_69_INT,OAM_RX_BASE_ADDR,0xba,11,10},
	{BAS_CS_RF_70_INT,OAM_RX_BASE_ADDR,0xba,13,12},
	{BAS_CS_RF_71_INT,OAM_RX_BASE_ADDR,0xba,15,14},
	{BAS_CS_RF_72_INT,OAM_RX_BASE_ADDR,0xba,17,16},
	{BAS_CS_RF_73_INT,OAM_RX_BASE_ADDR,0xba,19,18},
	{BAS_CS_RF_74_INT,OAM_RX_BASE_ADDR,0xba,21,20},
	{BAS_CS_RF_75_INT,OAM_RX_BASE_ADDR,0xba,23,22},
	{BAS_CS_RF_76_INT,OAM_RX_BASE_ADDR,0xba,25,24},
	{BAS_CS_RF_77_INT,OAM_RX_BASE_ADDR,0xba,27,26},
	{BAS_CS_RF_78_INT,OAM_RX_BASE_ADDR,0xba,29,28},
	{BAS_CS_RF_79_INT,OAM_RX_BASE_ADDR,0xba,31,30},
};
const CHIP_REG bas_cs_rf_i4_INT_MASK_REG[]=
{
	{BAS_CS_RF_64_INT_MASK,OAM_RX_BASE_ADDR,0xbb,1,0},
	{BAS_CS_RF_65_INT_MASK,OAM_RX_BASE_ADDR,0xbb,3,2},
	{BAS_CS_RF_66_INT_MASK,OAM_RX_BASE_ADDR,0xbb,5,4},
	{BAS_CS_RF_67_INT_MASK,OAM_RX_BASE_ADDR,0xbb,7,6},
	{BAS_CS_RF_68_INT_MASK,OAM_RX_BASE_ADDR,0xbb,9,8},
	{BAS_CS_RF_69_INT_MASK,OAM_RX_BASE_ADDR,0xbb,11,10},
	{BAS_CS_RF_70_INT_MASK,OAM_RX_BASE_ADDR,0xbb,13,12},
	{BAS_CS_RF_71_INT_MASK,OAM_RX_BASE_ADDR,0xbb,15,14},
	{BAS_CS_RF_72_INT_MASK,OAM_RX_BASE_ADDR,0xbb,17,16},
	{BAS_CS_RF_73_INT_MASK,OAM_RX_BASE_ADDR,0xbb,19,18},
	{BAS_CS_RF_74_INT_MASK,OAM_RX_BASE_ADDR,0xbb,21,20},
	{BAS_CS_RF_75_INT_MASK,OAM_RX_BASE_ADDR,0xbb,23,22},
	{BAS_CS_RF_76_INT_MASK,OAM_RX_BASE_ADDR,0xbb,25,24},
	{BAS_CS_RF_77_INT_MASK,OAM_RX_BASE_ADDR,0xbb,27,26},
	{BAS_CS_RF_78_INT_MASK,OAM_RX_BASE_ADDR,0xbb,29,28},
	{BAS_CS_RF_79_INT_MASK,OAM_RX_BASE_ADDR,0xbb,31,30},
};
const CHIP_REG bas_crc_err_i0_INT_REG[]=
{
	{BAS_CRC_ERR_0_INT,OAM_RX_BASE_ADDR,0xbc,1,0},
	{BAS_CRC_ERR_1_INT,OAM_RX_BASE_ADDR,0xbc,3,2},
	{BAS_CRC_ERR_2_INT,OAM_RX_BASE_ADDR,0xbc,5,4},
	{BAS_CRC_ERR_3_INT,OAM_RX_BASE_ADDR,0xbc,7,6},
	{BAS_CRC_ERR_4_INT,OAM_RX_BASE_ADDR,0xbc,9,8},
	{BAS_CRC_ERR_5_INT,OAM_RX_BASE_ADDR,0xbc,11,10},
	{BAS_CRC_ERR_6_INT,OAM_RX_BASE_ADDR,0xbc,13,12},
	{BAS_CRC_ERR_7_INT,OAM_RX_BASE_ADDR,0xbc,15,14},
	{BAS_CRC_ERR_8_INT,OAM_RX_BASE_ADDR,0xbc,17,16},
	{BAS_CRC_ERR_9_INT,OAM_RX_BASE_ADDR,0xbc,19,18},
	{BAS_CRC_ERR_10_INT,OAM_RX_BASE_ADDR,0xbc,21,20},
	{BAS_CRC_ERR_11_INT,OAM_RX_BASE_ADDR,0xbc,23,22},
	{BAS_CRC_ERR_12_INT,OAM_RX_BASE_ADDR,0xbc,25,24},
	{BAS_CRC_ERR_13_INT,OAM_RX_BASE_ADDR,0xbc,27,26},
	{BAS_CRC_ERR_14_INT,OAM_RX_BASE_ADDR,0xbc,29,28},
	{BAS_CRC_ERR_15_INT,OAM_RX_BASE_ADDR,0xbc,31,30},
};
const CHIP_REG bas_crc_err_i0_INT_MASK_REG[]=
{
	{BAS_CRC_ERR_0_INT_MASK,OAM_RX_BASE_ADDR,0xbd,1,0},
	{BAS_CRC_ERR_1_INT_MASK,OAM_RX_BASE_ADDR,0xbd,3,2},
	{BAS_CRC_ERR_2_INT_MASK,OAM_RX_BASE_ADDR,0xbd,5,4},
	{BAS_CRC_ERR_3_INT_MASK,OAM_RX_BASE_ADDR,0xbd,7,6},
	{BAS_CRC_ERR_4_INT_MASK,OAM_RX_BASE_ADDR,0xbd,9,8},
	{BAS_CRC_ERR_5_INT_MASK,OAM_RX_BASE_ADDR,0xbd,11,10},
	{BAS_CRC_ERR_6_INT_MASK,OAM_RX_BASE_ADDR,0xbd,13,12},
	{BAS_CRC_ERR_7_INT_MASK,OAM_RX_BASE_ADDR,0xbd,15,14},
	{BAS_CRC_ERR_8_INT_MASK,OAM_RX_BASE_ADDR,0xbd,17,16},
	{BAS_CRC_ERR_9_INT_MASK,OAM_RX_BASE_ADDR,0xbd,19,18},
	{BAS_CRC_ERR_10_INT_MASK,OAM_RX_BASE_ADDR,0xbd,21,20},
	{BAS_CRC_ERR_11_INT_MASK,OAM_RX_BASE_ADDR,0xbd,23,22},
	{BAS_CRC_ERR_12_INT_MASK,OAM_RX_BASE_ADDR,0xbd,25,24},
	{BAS_CRC_ERR_13_INT_MASK,OAM_RX_BASE_ADDR,0xbd,27,26},
	{BAS_CRC_ERR_14_INT_MASK,OAM_RX_BASE_ADDR,0xbd,29,28},
	{BAS_CRC_ERR_15_INT_MASK,OAM_RX_BASE_ADDR,0xbd,31,30},
};
const CHIP_REG bas_crc_err_i1_INT_REG[]=
{
	{BAS_CRC_ERR_16_INT,OAM_RX_BASE_ADDR,0xbe,1,0},
	{BAS_CRC_ERR_17_INT,OAM_RX_BASE_ADDR,0xbe,3,2},
	{BAS_CRC_ERR_18_INT,OAM_RX_BASE_ADDR,0xbe,5,4},
	{BAS_CRC_ERR_19_INT,OAM_RX_BASE_ADDR,0xbe,7,6},
	{BAS_CRC_ERR_20_INT,OAM_RX_BASE_ADDR,0xbe,9,8},
	{BAS_CRC_ERR_21_INT,OAM_RX_BASE_ADDR,0xbe,11,10},
	{BAS_CRC_ERR_22_INT,OAM_RX_BASE_ADDR,0xbe,13,12},
	{BAS_CRC_ERR_23_INT,OAM_RX_BASE_ADDR,0xbe,15,14},
	{BAS_CRC_ERR_24_INT,OAM_RX_BASE_ADDR,0xbe,17,16},
	{BAS_CRC_ERR_25_INT,OAM_RX_BASE_ADDR,0xbe,19,18},
	{BAS_CRC_ERR_26_INT,OAM_RX_BASE_ADDR,0xbe,21,20},
	{BAS_CRC_ERR_27_INT,OAM_RX_BASE_ADDR,0xbe,23,22},
	{BAS_CRC_ERR_28_INT,OAM_RX_BASE_ADDR,0xbe,25,24},
	{BAS_CRC_ERR_29_INT,OAM_RX_BASE_ADDR,0xbe,27,26},
	{BAS_CRC_ERR_30_INT,OAM_RX_BASE_ADDR,0xbe,29,28},
	{BAS_CRC_ERR_31_INT,OAM_RX_BASE_ADDR,0xbe,31,30},
};
const CHIP_REG bas_crc_err_i1_INT_MASK_REG[]=
{
	{BAS_CRC_ERR_16_INT_MASK,OAM_RX_BASE_ADDR,0xbf,1,0},
	{BAS_CRC_ERR_17_INT_MASK,OAM_RX_BASE_ADDR,0xbf,3,2},
	{BAS_CRC_ERR_18_INT_MASK,OAM_RX_BASE_ADDR,0xbf,5,4},
	{BAS_CRC_ERR_19_INT_MASK,OAM_RX_BASE_ADDR,0xbf,7,6},
	{BAS_CRC_ERR_20_INT_MASK,OAM_RX_BASE_ADDR,0xbf,9,8},
	{BAS_CRC_ERR_21_INT_MASK,OAM_RX_BASE_ADDR,0xbf,11,10},
	{BAS_CRC_ERR_22_INT_MASK,OAM_RX_BASE_ADDR,0xbf,13,12},
	{BAS_CRC_ERR_23_INT_MASK,OAM_RX_BASE_ADDR,0xbf,15,14},
	{BAS_CRC_ERR_24_INT_MASK,OAM_RX_BASE_ADDR,0xbf,17,16},
	{BAS_CRC_ERR_25_INT_MASK,OAM_RX_BASE_ADDR,0xbf,19,18},
	{BAS_CRC_ERR_26_INT_MASK,OAM_RX_BASE_ADDR,0xbf,21,20},
	{BAS_CRC_ERR_27_INT_MASK,OAM_RX_BASE_ADDR,0xbf,23,22},
	{BAS_CRC_ERR_28_INT_MASK,OAM_RX_BASE_ADDR,0xbf,25,24},
	{BAS_CRC_ERR_29_INT_MASK,OAM_RX_BASE_ADDR,0xbf,27,26},
	{BAS_CRC_ERR_30_INT_MASK,OAM_RX_BASE_ADDR,0xbf,29,28},
	{BAS_CRC_ERR_31_INT_MASK,OAM_RX_BASE_ADDR,0xbf,31,30},
};
const CHIP_REG bas_crc_err_i2_INT_REG[]=
{
	{BAS_CRC_ERR_32_INT,OAM_RX_BASE_ADDR,0xc0,1,0},
	{BAS_CRC_ERR_33_INT,OAM_RX_BASE_ADDR,0xc0,3,2},
	{BAS_CRC_ERR_34_INT,OAM_RX_BASE_ADDR,0xc0,5,4},
	{BAS_CRC_ERR_35_INT,OAM_RX_BASE_ADDR,0xc0,7,6},
	{BAS_CRC_ERR_36_INT,OAM_RX_BASE_ADDR,0xc0,9,8},
	{BAS_CRC_ERR_37_INT,OAM_RX_BASE_ADDR,0xc0,11,10},
	{BAS_CRC_ERR_38_INT,OAM_RX_BASE_ADDR,0xc0,13,12},
	{BAS_CRC_ERR_39_INT,OAM_RX_BASE_ADDR,0xc0,15,14},
	{BAS_CRC_ERR_40_INT,OAM_RX_BASE_ADDR,0xc0,17,16},
	{BAS_CRC_ERR_41_INT,OAM_RX_BASE_ADDR,0xc0,19,18},
	{BAS_CRC_ERR_42_INT,OAM_RX_BASE_ADDR,0xc0,21,20},
	{BAS_CRC_ERR_43_INT,OAM_RX_BASE_ADDR,0xc0,23,22},
	{BAS_CRC_ERR_44_INT,OAM_RX_BASE_ADDR,0xc0,25,24},
	{BAS_CRC_ERR_45_INT,OAM_RX_BASE_ADDR,0xc0,27,26},
	{BAS_CRC_ERR_46_INT,OAM_RX_BASE_ADDR,0xc0,29,28},
	{BAS_CRC_ERR_47_INT,OAM_RX_BASE_ADDR,0xc0,31,30},
};
const CHIP_REG bas_crc_err_i2_INT_MASK_REG[]=
{
	{BAS_CRC_ERR_32_INT_MASK,OAM_RX_BASE_ADDR,0xc1,1,0},
	{BAS_CRC_ERR_33_INT_MASK,OAM_RX_BASE_ADDR,0xc1,3,2},
	{BAS_CRC_ERR_34_INT_MASK,OAM_RX_BASE_ADDR,0xc1,5,4},
	{BAS_CRC_ERR_35_INT_MASK,OAM_RX_BASE_ADDR,0xc1,7,6},
	{BAS_CRC_ERR_36_INT_MASK,OAM_RX_BASE_ADDR,0xc1,9,8},
	{BAS_CRC_ERR_37_INT_MASK,OAM_RX_BASE_ADDR,0xc1,11,10},
	{BAS_CRC_ERR_38_INT_MASK,OAM_RX_BASE_ADDR,0xc1,13,12},
	{BAS_CRC_ERR_39_INT_MASK,OAM_RX_BASE_ADDR,0xc1,15,14},
	{BAS_CRC_ERR_40_INT_MASK,OAM_RX_BASE_ADDR,0xc1,17,16},
	{BAS_CRC_ERR_41_INT_MASK,OAM_RX_BASE_ADDR,0xc1,19,18},
	{BAS_CRC_ERR_42_INT_MASK,OAM_RX_BASE_ADDR,0xc1,21,20},
	{BAS_CRC_ERR_43_INT_MASK,OAM_RX_BASE_ADDR,0xc1,23,22},
	{BAS_CRC_ERR_44_INT_MASK,OAM_RX_BASE_ADDR,0xc1,25,24},
	{BAS_CRC_ERR_45_INT_MASK,OAM_RX_BASE_ADDR,0xc1,27,26},
	{BAS_CRC_ERR_46_INT_MASK,OAM_RX_BASE_ADDR,0xc1,29,28},
	{BAS_CRC_ERR_47_INT_MASK,OAM_RX_BASE_ADDR,0xc1,31,30},
};
const CHIP_REG bas_crc_err_i3_INT_REG[]=
{
	{BAS_CRC_ERR_48_INT,OAM_RX_BASE_ADDR,0xc2,1,0},
	{BAS_CRC_ERR_49_INT,OAM_RX_BASE_ADDR,0xc2,3,2},
	{BAS_CRC_ERR_50_INT,OAM_RX_BASE_ADDR,0xc2,5,4},
	{BAS_CRC_ERR_51_INT,OAM_RX_BASE_ADDR,0xc2,7,6},
	{BAS_CRC_ERR_52_INT,OAM_RX_BASE_ADDR,0xc2,9,8},
	{BAS_CRC_ERR_53_INT,OAM_RX_BASE_ADDR,0xc2,11,10},
	{BAS_CRC_ERR_54_INT,OAM_RX_BASE_ADDR,0xc2,13,12},
	{BAS_CRC_ERR_55_INT,OAM_RX_BASE_ADDR,0xc2,15,14},
	{BAS_CRC_ERR_56_INT,OAM_RX_BASE_ADDR,0xc2,17,16},
	{BAS_CRC_ERR_57_INT,OAM_RX_BASE_ADDR,0xc2,19,18},
	{BAS_CRC_ERR_58_INT,OAM_RX_BASE_ADDR,0xc2,21,20},
	{BAS_CRC_ERR_59_INT,OAM_RX_BASE_ADDR,0xc2,23,22},
	{BAS_CRC_ERR_60_INT,OAM_RX_BASE_ADDR,0xc2,25,24},
	{BAS_CRC_ERR_61_INT,OAM_RX_BASE_ADDR,0xc2,27,26},
	{BAS_CRC_ERR_62_INT,OAM_RX_BASE_ADDR,0xc2,29,28},
	{BAS_CRC_ERR_63_INT,OAM_RX_BASE_ADDR,0xc2,31,30},
};
const CHIP_REG bas_crc_err_i3_INT_MASK_REG[]=
{
	{BAS_CRC_ERR_48_INT_MASK,OAM_RX_BASE_ADDR,0xc3,1,0},
	{BAS_CRC_ERR_49_INT_MASK,OAM_RX_BASE_ADDR,0xc3,3,2},
	{BAS_CRC_ERR_50_INT_MASK,OAM_RX_BASE_ADDR,0xc3,5,4},
	{BAS_CRC_ERR_51_INT_MASK,OAM_RX_BASE_ADDR,0xc3,7,6},
	{BAS_CRC_ERR_52_INT_MASK,OAM_RX_BASE_ADDR,0xc3,9,8},
	{BAS_CRC_ERR_53_INT_MASK,OAM_RX_BASE_ADDR,0xc3,11,10},
	{BAS_CRC_ERR_54_INT_MASK,OAM_RX_BASE_ADDR,0xc3,13,12},
	{BAS_CRC_ERR_55_INT_MASK,OAM_RX_BASE_ADDR,0xc3,15,14},
	{BAS_CRC_ERR_56_INT_MASK,OAM_RX_BASE_ADDR,0xc3,17,16},
	{BAS_CRC_ERR_57_INT_MASK,OAM_RX_BASE_ADDR,0xc3,19,18},
	{BAS_CRC_ERR_58_INT_MASK,OAM_RX_BASE_ADDR,0xc3,21,20},
	{BAS_CRC_ERR_59_INT_MASK,OAM_RX_BASE_ADDR,0xc3,23,22},
	{BAS_CRC_ERR_60_INT_MASK,OAM_RX_BASE_ADDR,0xc3,25,24},
	{BAS_CRC_ERR_61_INT_MASK,OAM_RX_BASE_ADDR,0xc3,27,26},
	{BAS_CRC_ERR_62_INT_MASK,OAM_RX_BASE_ADDR,0xc3,29,28},
	{BAS_CRC_ERR_63_INT_MASK,OAM_RX_BASE_ADDR,0xc3,31,30},
};
const CHIP_REG bas_crc_err_i4_INT_REG[]=
{
	{BAS_CRC_ERR_64_INT,OAM_RX_BASE_ADDR,0xc4,1,0},
	{BAS_CRC_ERR_65_INT,OAM_RX_BASE_ADDR,0xc4,3,2},
	{BAS_CRC_ERR_66_INT,OAM_RX_BASE_ADDR,0xc4,5,4},
	{BAS_CRC_ERR_67_INT,OAM_RX_BASE_ADDR,0xc4,7,6},
	{BAS_CRC_ERR_68_INT,OAM_RX_BASE_ADDR,0xc4,9,8},
	{BAS_CRC_ERR_69_INT,OAM_RX_BASE_ADDR,0xc4,11,10},
	{BAS_CRC_ERR_70_INT,OAM_RX_BASE_ADDR,0xc4,13,12},
	{BAS_CRC_ERR_71_INT,OAM_RX_BASE_ADDR,0xc4,15,14},
	{BAS_CRC_ERR_72_INT,OAM_RX_BASE_ADDR,0xc4,17,16},
	{BAS_CRC_ERR_73_INT,OAM_RX_BASE_ADDR,0xc4,19,18},
	{BAS_CRC_ERR_74_INT,OAM_RX_BASE_ADDR,0xc4,21,20},
	{BAS_CRC_ERR_75_INT,OAM_RX_BASE_ADDR,0xc4,23,22},
	{BAS_CRC_ERR_76_INT,OAM_RX_BASE_ADDR,0xc4,25,24},
	{BAS_CRC_ERR_77_INT,OAM_RX_BASE_ADDR,0xc4,27,26},
	{BAS_CRC_ERR_78_INT,OAM_RX_BASE_ADDR,0xc4,29,28},
	{BAS_CRC_ERR_79_INT,OAM_RX_BASE_ADDR,0xc4,31,30},
};
const CHIP_REG bas_crc_err_i4_INT_MASK_REG[]=
{
	{BAS_CRC_ERR_64_INT_MASK,OAM_RX_BASE_ADDR,0xc5,1,0},
	{BAS_CRC_ERR_65_INT_MASK,OAM_RX_BASE_ADDR,0xc5,3,2},
	{BAS_CRC_ERR_66_INT_MASK,OAM_RX_BASE_ADDR,0xc5,5,4},
	{BAS_CRC_ERR_67_INT_MASK,OAM_RX_BASE_ADDR,0xc5,7,6},
	{BAS_CRC_ERR_68_INT_MASK,OAM_RX_BASE_ADDR,0xc5,9,8},
	{BAS_CRC_ERR_69_INT_MASK,OAM_RX_BASE_ADDR,0xc5,11,10},
	{BAS_CRC_ERR_70_INT_MASK,OAM_RX_BASE_ADDR,0xc5,13,12},
	{BAS_CRC_ERR_71_INT_MASK,OAM_RX_BASE_ADDR,0xc5,15,14},
	{BAS_CRC_ERR_72_INT_MASK,OAM_RX_BASE_ADDR,0xc5,17,16},
	{BAS_CRC_ERR_73_INT_MASK,OAM_RX_BASE_ADDR,0xc5,19,18},
	{BAS_CRC_ERR_74_INT_MASK,OAM_RX_BASE_ADDR,0xc5,21,20},
	{BAS_CRC_ERR_75_INT_MASK,OAM_RX_BASE_ADDR,0xc5,23,22},
	{BAS_CRC_ERR_76_INT_MASK,OAM_RX_BASE_ADDR,0xc5,25,24},
	{BAS_CRC_ERR_77_INT_MASK,OAM_RX_BASE_ADDR,0xc5,27,26},
	{BAS_CRC_ERR_78_INT_MASK,OAM_RX_BASE_ADDR,0xc5,29,28},
	{BAS_CRC_ERR_79_INT_MASK,OAM_RX_BASE_ADDR,0xc5,31,30},
};
const CHIP_REG bas_no_receive_alm_i0_INT_REG[]=
{
	{BAS_NO_RECEIVE_ALM_0_INT,OAM_RX_BASE_ADDR,0xc6,1,0},
	{BAS_NO_RECEIVE_ALM_1_INT,OAM_RX_BASE_ADDR,0xc6,3,2},
	{BAS_NO_RECEIVE_ALM_2_INT,OAM_RX_BASE_ADDR,0xc6,5,4},
	{BAS_NO_RECEIVE_ALM_3_INT,OAM_RX_BASE_ADDR,0xc6,7,6},
	{BAS_NO_RECEIVE_ALM_4_INT,OAM_RX_BASE_ADDR,0xc6,9,8},
	{BAS_NO_RECEIVE_ALM_5_INT,OAM_RX_BASE_ADDR,0xc6,11,10},
	{BAS_NO_RECEIVE_ALM_6_INT,OAM_RX_BASE_ADDR,0xc6,13,12},
	{BAS_NO_RECEIVE_ALM_7_INT,OAM_RX_BASE_ADDR,0xc6,15,14},
	{BAS_NO_RECEIVE_ALM_8_INT,OAM_RX_BASE_ADDR,0xc6,17,16},
	{BAS_NO_RECEIVE_ALM_9_INT,OAM_RX_BASE_ADDR,0xc6,19,18},
	{BAS_NO_RECEIVE_ALM_10_INT,OAM_RX_BASE_ADDR,0xc6,21,20},
	{BAS_NO_RECEIVE_ALM_11_INT,OAM_RX_BASE_ADDR,0xc6,23,22},
	{BAS_NO_RECEIVE_ALM_12_INT,OAM_RX_BASE_ADDR,0xc6,25,24},
	{BAS_NO_RECEIVE_ALM_13_INT,OAM_RX_BASE_ADDR,0xc6,27,26},
	{BAS_NO_RECEIVE_ALM_14_INT,OAM_RX_BASE_ADDR,0xc6,29,28},
	{BAS_NO_RECEIVE_ALM_15_INT,OAM_RX_BASE_ADDR,0xc6,31,30},
};
const CHIP_REG bas_no_receive_alm_i0_INT_MASK_REG[]=
{
	{BAS_NO_RECEIVE_ALM_0_INT_MASK,OAM_RX_BASE_ADDR,0xc7,1,0},
	{BAS_NO_RECEIVE_ALM_1_INT_MASK,OAM_RX_BASE_ADDR,0xc7,3,2},
	{BAS_NO_RECEIVE_ALM_2_INT_MASK,OAM_RX_BASE_ADDR,0xc7,5,4},
	{BAS_NO_RECEIVE_ALM_3_INT_MASK,OAM_RX_BASE_ADDR,0xc7,7,6},
	{BAS_NO_RECEIVE_ALM_4_INT_MASK,OAM_RX_BASE_ADDR,0xc7,9,8},
	{BAS_NO_RECEIVE_ALM_5_INT_MASK,OAM_RX_BASE_ADDR,0xc7,11,10},
	{BAS_NO_RECEIVE_ALM_6_INT_MASK,OAM_RX_BASE_ADDR,0xc7,13,12},
	{BAS_NO_RECEIVE_ALM_7_INT_MASK,OAM_RX_BASE_ADDR,0xc7,15,14},
	{BAS_NO_RECEIVE_ALM_8_INT_MASK,OAM_RX_BASE_ADDR,0xc7,17,16},
	{BAS_NO_RECEIVE_ALM_9_INT_MASK,OAM_RX_BASE_ADDR,0xc7,19,18},
	{BAS_NO_RECEIVE_ALM_10_INT_MASK,OAM_RX_BASE_ADDR,0xc7,21,20},
	{BAS_NO_RECEIVE_ALM_11_INT_MASK,OAM_RX_BASE_ADDR,0xc7,23,22},
	{BAS_NO_RECEIVE_ALM_12_INT_MASK,OAM_RX_BASE_ADDR,0xc7,25,24},
	{BAS_NO_RECEIVE_ALM_13_INT_MASK,OAM_RX_BASE_ADDR,0xc7,27,26},
	{BAS_NO_RECEIVE_ALM_14_INT_MASK,OAM_RX_BASE_ADDR,0xc7,29,28},
	{BAS_NO_RECEIVE_ALM_15_INT_MASK,OAM_RX_BASE_ADDR,0xc7,31,30},
};
const CHIP_REG bas_no_receive_alm_i1_INT_REG[]=
{
	{BAS_NO_RECEIVE_ALM_16_INT,OAM_RX_BASE_ADDR,0xc8,1,0},
	{BAS_NO_RECEIVE_ALM_17_INT,OAM_RX_BASE_ADDR,0xc8,3,2},
	{BAS_NO_RECEIVE_ALM_18_INT,OAM_RX_BASE_ADDR,0xc8,5,4},
	{BAS_NO_RECEIVE_ALM_19_INT,OAM_RX_BASE_ADDR,0xc8,7,6},
	{BAS_NO_RECEIVE_ALM_20_INT,OAM_RX_BASE_ADDR,0xc8,9,8},
	{BAS_NO_RECEIVE_ALM_21_INT,OAM_RX_BASE_ADDR,0xc8,11,10},
	{BAS_NO_RECEIVE_ALM_22_INT,OAM_RX_BASE_ADDR,0xc8,13,12},
	{BAS_NO_RECEIVE_ALM_23_INT,OAM_RX_BASE_ADDR,0xc8,15,14},
	{BAS_NO_RECEIVE_ALM_24_INT,OAM_RX_BASE_ADDR,0xc8,17,16},
	{BAS_NO_RECEIVE_ALM_25_INT,OAM_RX_BASE_ADDR,0xc8,19,18},
	{BAS_NO_RECEIVE_ALM_26_INT,OAM_RX_BASE_ADDR,0xc8,21,20},
	{BAS_NO_RECEIVE_ALM_27_INT,OAM_RX_BASE_ADDR,0xc8,23,22},
	{BAS_NO_RECEIVE_ALM_28_INT,OAM_RX_BASE_ADDR,0xc8,25,24},
	{BAS_NO_RECEIVE_ALM_29_INT,OAM_RX_BASE_ADDR,0xc8,27,26},
	{BAS_NO_RECEIVE_ALM_30_INT,OAM_RX_BASE_ADDR,0xc8,29,28},
	{BAS_NO_RECEIVE_ALM_31_INT,OAM_RX_BASE_ADDR,0xc8,31,30},
};
const CHIP_REG bas_no_receive_alm_i1_INT_MASK_REG[]=
{
	{BAS_NO_RECEIVE_ALM_16_INT_MASK,OAM_RX_BASE_ADDR,0xc9,1,0},
	{BAS_NO_RECEIVE_ALM_17_INT_MASK,OAM_RX_BASE_ADDR,0xc9,3,2},
	{BAS_NO_RECEIVE_ALM_18_INT_MASK,OAM_RX_BASE_ADDR,0xc9,5,4},
	{BAS_NO_RECEIVE_ALM_19_INT_MASK,OAM_RX_BASE_ADDR,0xc9,7,6},
	{BAS_NO_RECEIVE_ALM_20_INT_MASK,OAM_RX_BASE_ADDR,0xc9,9,8},
	{BAS_NO_RECEIVE_ALM_21_INT_MASK,OAM_RX_BASE_ADDR,0xc9,11,10},
	{BAS_NO_RECEIVE_ALM_22_INT_MASK,OAM_RX_BASE_ADDR,0xc9,13,12},
	{BAS_NO_RECEIVE_ALM_23_INT_MASK,OAM_RX_BASE_ADDR,0xc9,15,14},
	{BAS_NO_RECEIVE_ALM_24_INT_MASK,OAM_RX_BASE_ADDR,0xc9,17,16},
	{BAS_NO_RECEIVE_ALM_25_INT_MASK,OAM_RX_BASE_ADDR,0xc9,19,18},
	{BAS_NO_RECEIVE_ALM_26_INT_MASK,OAM_RX_BASE_ADDR,0xc9,21,20},
	{BAS_NO_RECEIVE_ALM_27_INT_MASK,OAM_RX_BASE_ADDR,0xc9,23,22},
	{BAS_NO_RECEIVE_ALM_28_INT_MASK,OAM_RX_BASE_ADDR,0xc9,25,24},
	{BAS_NO_RECEIVE_ALM_29_INT_MASK,OAM_RX_BASE_ADDR,0xc9,27,26},
	{BAS_NO_RECEIVE_ALM_30_INT_MASK,OAM_RX_BASE_ADDR,0xc9,29,28},
	{BAS_NO_RECEIVE_ALM_31_INT_MASK,OAM_RX_BASE_ADDR,0xc9,31,30},
};
const CHIP_REG bas_no_receive_alm_i2_INT_REG[]=
{
	{BAS_NO_RECEIVE_ALM_32_INT,OAM_RX_BASE_ADDR,0xca,1,0},
	{BAS_NO_RECEIVE_ALM_33_INT,OAM_RX_BASE_ADDR,0xca,3,2},
	{BAS_NO_RECEIVE_ALM_34_INT,OAM_RX_BASE_ADDR,0xca,5,4},
	{BAS_NO_RECEIVE_ALM_35_INT,OAM_RX_BASE_ADDR,0xca,7,6},
	{BAS_NO_RECEIVE_ALM_36_INT,OAM_RX_BASE_ADDR,0xca,9,8},
	{BAS_NO_RECEIVE_ALM_37_INT,OAM_RX_BASE_ADDR,0xca,11,10},
	{BAS_NO_RECEIVE_ALM_38_INT,OAM_RX_BASE_ADDR,0xca,13,12},
	{BAS_NO_RECEIVE_ALM_39_INT,OAM_RX_BASE_ADDR,0xca,15,14},
	{BAS_NO_RECEIVE_ALM_40_INT,OAM_RX_BASE_ADDR,0xca,17,16},
	{BAS_NO_RECEIVE_ALM_41_INT,OAM_RX_BASE_ADDR,0xca,19,18},
	{BAS_NO_RECEIVE_ALM_42_INT,OAM_RX_BASE_ADDR,0xca,21,20},
	{BAS_NO_RECEIVE_ALM_43_INT,OAM_RX_BASE_ADDR,0xca,23,22},
	{BAS_NO_RECEIVE_ALM_44_INT,OAM_RX_BASE_ADDR,0xca,25,24},
	{BAS_NO_RECEIVE_ALM_45_INT,OAM_RX_BASE_ADDR,0xca,27,26},
	{BAS_NO_RECEIVE_ALM_46_INT,OAM_RX_BASE_ADDR,0xca,29,28},
	{BAS_NO_RECEIVE_ALM_47_INT,OAM_RX_BASE_ADDR,0xca,31,30},
};
const CHIP_REG bas_no_receive_alm_i2_INT_MASK_REG[]=
{
	{BAS_NO_RECEIVE_ALM_32_INT_MASK,OAM_RX_BASE_ADDR,0xcb,1,0},
	{BAS_NO_RECEIVE_ALM_33_INT_MASK,OAM_RX_BASE_ADDR,0xcb,3,2},
	{BAS_NO_RECEIVE_ALM_34_INT_MASK,OAM_RX_BASE_ADDR,0xcb,5,4},
	{BAS_NO_RECEIVE_ALM_35_INT_MASK,OAM_RX_BASE_ADDR,0xcb,7,6},
	{BAS_NO_RECEIVE_ALM_36_INT_MASK,OAM_RX_BASE_ADDR,0xcb,9,8},
	{BAS_NO_RECEIVE_ALM_37_INT_MASK,OAM_RX_BASE_ADDR,0xcb,11,10},
	{BAS_NO_RECEIVE_ALM_38_INT_MASK,OAM_RX_BASE_ADDR,0xcb,13,12},
	{BAS_NO_RECEIVE_ALM_39_INT_MASK,OAM_RX_BASE_ADDR,0xcb,15,14},
	{BAS_NO_RECEIVE_ALM_40_INT_MASK,OAM_RX_BASE_ADDR,0xcb,17,16},
	{BAS_NO_RECEIVE_ALM_41_INT_MASK,OAM_RX_BASE_ADDR,0xcb,19,18},
	{BAS_NO_RECEIVE_ALM_42_INT_MASK,OAM_RX_BASE_ADDR,0xcb,21,20},
	{BAS_NO_RECEIVE_ALM_43_INT_MASK,OAM_RX_BASE_ADDR,0xcb,23,22},
	{BAS_NO_RECEIVE_ALM_44_INT_MASK,OAM_RX_BASE_ADDR,0xcb,25,24},
	{BAS_NO_RECEIVE_ALM_45_INT_MASK,OAM_RX_BASE_ADDR,0xcb,27,26},
	{BAS_NO_RECEIVE_ALM_46_INT_MASK,OAM_RX_BASE_ADDR,0xcb,29,28},
	{BAS_NO_RECEIVE_ALM_47_INT_MASK,OAM_RX_BASE_ADDR,0xcb,31,30},
};
const CHIP_REG bas_no_receive_alm_i3_INT_REG[]=
{
	{BAS_NO_RECEIVE_ALM_48_INT,OAM_RX_BASE_ADDR,0xcc,1,0},
	{BAS_NO_RECEIVE_ALM_49_INT,OAM_RX_BASE_ADDR,0xcc,3,2},
	{BAS_NO_RECEIVE_ALM_50_INT,OAM_RX_BASE_ADDR,0xcc,5,4},
	{BAS_NO_RECEIVE_ALM_51_INT,OAM_RX_BASE_ADDR,0xcc,7,6},
	{BAS_NO_RECEIVE_ALM_52_INT,OAM_RX_BASE_ADDR,0xcc,9,8},
	{BAS_NO_RECEIVE_ALM_53_INT,OAM_RX_BASE_ADDR,0xcc,11,10},
	{BAS_NO_RECEIVE_ALM_54_INT,OAM_RX_BASE_ADDR,0xcc,13,12},
	{BAS_NO_RECEIVE_ALM_55_INT,OAM_RX_BASE_ADDR,0xcc,15,14},
	{BAS_NO_RECEIVE_ALM_56_INT,OAM_RX_BASE_ADDR,0xcc,17,16},
	{BAS_NO_RECEIVE_ALM_57_INT,OAM_RX_BASE_ADDR,0xcc,19,18},
	{BAS_NO_RECEIVE_ALM_58_INT,OAM_RX_BASE_ADDR,0xcc,21,20},
	{BAS_NO_RECEIVE_ALM_59_INT,OAM_RX_BASE_ADDR,0xcc,23,22},
	{BAS_NO_RECEIVE_ALM_60_INT,OAM_RX_BASE_ADDR,0xcc,25,24},
	{BAS_NO_RECEIVE_ALM_61_INT,OAM_RX_BASE_ADDR,0xcc,27,26},
	{BAS_NO_RECEIVE_ALM_62_INT,OAM_RX_BASE_ADDR,0xcc,29,28},
	{BAS_NO_RECEIVE_ALM_63_INT,OAM_RX_BASE_ADDR,0xcc,31,30},
};
const CHIP_REG bas_no_receive_alm_i3_INT_MASK_REG[]=
{
	{BAS_NO_RECEIVE_ALM_48_INT_MASK,OAM_RX_BASE_ADDR,0xcd,1,0},
	{BAS_NO_RECEIVE_ALM_49_INT_MASK,OAM_RX_BASE_ADDR,0xcd,3,2},
	{BAS_NO_RECEIVE_ALM_50_INT_MASK,OAM_RX_BASE_ADDR,0xcd,5,4},
	{BAS_NO_RECEIVE_ALM_51_INT_MASK,OAM_RX_BASE_ADDR,0xcd,7,6},
	{BAS_NO_RECEIVE_ALM_52_INT_MASK,OAM_RX_BASE_ADDR,0xcd,9,8},
	{BAS_NO_RECEIVE_ALM_53_INT_MASK,OAM_RX_BASE_ADDR,0xcd,11,10},
	{BAS_NO_RECEIVE_ALM_54_INT_MASK,OAM_RX_BASE_ADDR,0xcd,13,12},
	{BAS_NO_RECEIVE_ALM_55_INT_MASK,OAM_RX_BASE_ADDR,0xcd,15,14},
	{BAS_NO_RECEIVE_ALM_56_INT_MASK,OAM_RX_BASE_ADDR,0xcd,17,16},
	{BAS_NO_RECEIVE_ALM_57_INT_MASK,OAM_RX_BASE_ADDR,0xcd,19,18},
	{BAS_NO_RECEIVE_ALM_58_INT_MASK,OAM_RX_BASE_ADDR,0xcd,21,20},
	{BAS_NO_RECEIVE_ALM_59_INT_MASK,OAM_RX_BASE_ADDR,0xcd,23,22},
	{BAS_NO_RECEIVE_ALM_60_INT_MASK,OAM_RX_BASE_ADDR,0xcd,25,24},
	{BAS_NO_RECEIVE_ALM_61_INT_MASK,OAM_RX_BASE_ADDR,0xcd,27,26},
	{BAS_NO_RECEIVE_ALM_62_INT_MASK,OAM_RX_BASE_ADDR,0xcd,29,28},
	{BAS_NO_RECEIVE_ALM_63_INT_MASK,OAM_RX_BASE_ADDR,0xcd,31,30},
};
const CHIP_REG bas_no_receive_alm_i4_INT_REG[]=
{
	{BAS_NO_RECEIVE_ALM_64_INT,OAM_RX_BASE_ADDR,0xce,1,0},
	{BAS_NO_RECEIVE_ALM_65_INT,OAM_RX_BASE_ADDR,0xce,3,2},
	{BAS_NO_RECEIVE_ALM_66_INT,OAM_RX_BASE_ADDR,0xce,5,4},
	{BAS_NO_RECEIVE_ALM_67_INT,OAM_RX_BASE_ADDR,0xce,7,6},
	{BAS_NO_RECEIVE_ALM_68_INT,OAM_RX_BASE_ADDR,0xce,9,8},
	{BAS_NO_RECEIVE_ALM_69_INT,OAM_RX_BASE_ADDR,0xce,11,10},
	{BAS_NO_RECEIVE_ALM_70_INT,OAM_RX_BASE_ADDR,0xce,13,12},
	{BAS_NO_RECEIVE_ALM_71_INT,OAM_RX_BASE_ADDR,0xce,15,14},
	{BAS_NO_RECEIVE_ALM_72_INT,OAM_RX_BASE_ADDR,0xce,17,16},
	{BAS_NO_RECEIVE_ALM_73_INT,OAM_RX_BASE_ADDR,0xce,19,18},
	{BAS_NO_RECEIVE_ALM_74_INT,OAM_RX_BASE_ADDR,0xce,21,20},
	{BAS_NO_RECEIVE_ALM_75_INT,OAM_RX_BASE_ADDR,0xce,23,22},
	{BAS_NO_RECEIVE_ALM_76_INT,OAM_RX_BASE_ADDR,0xce,25,24},
	{BAS_NO_RECEIVE_ALM_77_INT,OAM_RX_BASE_ADDR,0xce,27,26},
	{BAS_NO_RECEIVE_ALM_78_INT,OAM_RX_BASE_ADDR,0xce,29,28},
	{BAS_NO_RECEIVE_ALM_79_INT,OAM_RX_BASE_ADDR,0xce,31,30},
};
const CHIP_REG bas_no_receive_alm_i4_INT_MASK_REG[]=
{
	{BAS_NO_RECEIVE_ALM_64_INT_MASK,OAM_RX_BASE_ADDR,0xcf,1,0},
	{BAS_NO_RECEIVE_ALM_65_INT_MASK,OAM_RX_BASE_ADDR,0xcf,3,2},
	{BAS_NO_RECEIVE_ALM_66_INT_MASK,OAM_RX_BASE_ADDR,0xcf,5,4},
	{BAS_NO_RECEIVE_ALM_67_INT_MASK,OAM_RX_BASE_ADDR,0xcf,7,6},
	{BAS_NO_RECEIVE_ALM_68_INT_MASK,OAM_RX_BASE_ADDR,0xcf,9,8},
	{BAS_NO_RECEIVE_ALM_69_INT_MASK,OAM_RX_BASE_ADDR,0xcf,11,10},
	{BAS_NO_RECEIVE_ALM_70_INT_MASK,OAM_RX_BASE_ADDR,0xcf,13,12},
	{BAS_NO_RECEIVE_ALM_71_INT_MASK,OAM_RX_BASE_ADDR,0xcf,15,14},
	{BAS_NO_RECEIVE_ALM_72_INT_MASK,OAM_RX_BASE_ADDR,0xcf,17,16},
	{BAS_NO_RECEIVE_ALM_73_INT_MASK,OAM_RX_BASE_ADDR,0xcf,19,18},
	{BAS_NO_RECEIVE_ALM_74_INT_MASK,OAM_RX_BASE_ADDR,0xcf,21,20},
	{BAS_NO_RECEIVE_ALM_75_INT_MASK,OAM_RX_BASE_ADDR,0xcf,23,22},
	{BAS_NO_RECEIVE_ALM_76_INT_MASK,OAM_RX_BASE_ADDR,0xcf,25,24},
	{BAS_NO_RECEIVE_ALM_77_INT_MASK,OAM_RX_BASE_ADDR,0xcf,27,26},
	{BAS_NO_RECEIVE_ALM_78_INT_MASK,OAM_RX_BASE_ADDR,0xcf,29,28},
	{BAS_NO_RECEIVE_ALM_79_INT_MASK,OAM_RX_BASE_ADDR,0xcf,31,30},
};
const CHIP_REG rdi_lf_i0_INT_REG[]=
{
	{RDI_LF_0_INT,OAM_RX_BASE_ADDR,0xd0,1,0},
	{RDI_LF_1_INT,OAM_RX_BASE_ADDR,0xd0,3,2},
	{RDI_LF_2_INT,OAM_RX_BASE_ADDR,0xd0,5,4},
	{RDI_LF_3_INT,OAM_RX_BASE_ADDR,0xd0,7,6},
	{RDI_LF_4_INT,OAM_RX_BASE_ADDR,0xd0,9,8},
	{RDI_LF_5_INT,OAM_RX_BASE_ADDR,0xd0,11,10},
	{RDI_LF_6_INT,OAM_RX_BASE_ADDR,0xd0,13,12},
	{RDI_LF_7_INT,OAM_RX_BASE_ADDR,0xd0,15,14},
	{RDI_LF_8_INT,OAM_RX_BASE_ADDR,0xd0,17,16},
	{RDI_LF_9_INT,OAM_RX_BASE_ADDR,0xd0,19,18},
	{RDI_LF_10_INT,OAM_RX_BASE_ADDR,0xd0,21,20},
	{RDI_LF_11_INT,OAM_RX_BASE_ADDR,0xd0,23,22},
	{RDI_LF_12_INT,OAM_RX_BASE_ADDR,0xd0,25,24},
	{RDI_LF_13_INT,OAM_RX_BASE_ADDR,0xd0,27,26},
	{RDI_LF_14_INT,OAM_RX_BASE_ADDR,0xd0,29,28},
	{RDI_LF_15_INT,OAM_RX_BASE_ADDR,0xd0,31,30},
};
const CHIP_REG rdi_lf_i0_INT_MASK_REG[]=
{
	{RDI_LF_0_INT_MASK,OAM_RX_BASE_ADDR,0xd1,1,0},
	{RDI_LF_1_INT_MASK,OAM_RX_BASE_ADDR,0xd1,3,2},
	{RDI_LF_2_INT_MASK,OAM_RX_BASE_ADDR,0xd1,5,4},
	{RDI_LF_3_INT_MASK,OAM_RX_BASE_ADDR,0xd1,7,6},
	{RDI_LF_4_INT_MASK,OAM_RX_BASE_ADDR,0xd1,9,8},
	{RDI_LF_5_INT_MASK,OAM_RX_BASE_ADDR,0xd1,11,10},
	{RDI_LF_6_INT_MASK,OAM_RX_BASE_ADDR,0xd1,13,12},
	{RDI_LF_7_INT_MASK,OAM_RX_BASE_ADDR,0xd1,15,14},
	{RDI_LF_8_INT_MASK,OAM_RX_BASE_ADDR,0xd1,17,16},
	{RDI_LF_9_INT_MASK,OAM_RX_BASE_ADDR,0xd1,19,18},
	{RDI_LF_10_INT_MASK,OAM_RX_BASE_ADDR,0xd1,21,20},
	{RDI_LF_11_INT_MASK,OAM_RX_BASE_ADDR,0xd1,23,22},
	{RDI_LF_12_INT_MASK,OAM_RX_BASE_ADDR,0xd1,25,24},
	{RDI_LF_13_INT_MASK,OAM_RX_BASE_ADDR,0xd1,27,26},
	{RDI_LF_14_INT_MASK,OAM_RX_BASE_ADDR,0xd1,29,28},
	{RDI_LF_15_INT_MASK,OAM_RX_BASE_ADDR,0xd1,31,30},
};
const CHIP_REG rdi_lf_i1_INT_REG[]=
{
	{RDI_LF_16_INT,OAM_RX_BASE_ADDR,0xd2,1,0},
	{RDI_LF_17_INT,OAM_RX_BASE_ADDR,0xd2,3,2},
	{RDI_LF_18_INT,OAM_RX_BASE_ADDR,0xd2,5,4},
	{RDI_LF_19_INT,OAM_RX_BASE_ADDR,0xd2,7,6},
	{RDI_LF_20_INT,OAM_RX_BASE_ADDR,0xd2,9,8},
	{RDI_LF_21_INT,OAM_RX_BASE_ADDR,0xd2,11,10},
	{RDI_LF_22_INT,OAM_RX_BASE_ADDR,0xd2,13,12},
	{RDI_LF_23_INT,OAM_RX_BASE_ADDR,0xd2,15,14},
	{RDI_LF_24_INT,OAM_RX_BASE_ADDR,0xd2,17,16},
	{RDI_LF_25_INT,OAM_RX_BASE_ADDR,0xd2,19,18},
	{RDI_LF_26_INT,OAM_RX_BASE_ADDR,0xd2,21,20},
	{RDI_LF_27_INT,OAM_RX_BASE_ADDR,0xd2,23,22},
	{RDI_LF_28_INT,OAM_RX_BASE_ADDR,0xd2,25,24},
	{RDI_LF_29_INT,OAM_RX_BASE_ADDR,0xd2,27,26},
	{RDI_LF_30_INT,OAM_RX_BASE_ADDR,0xd2,29,28},
	{RDI_LF_31_INT,OAM_RX_BASE_ADDR,0xd2,31,30},
};
const CHIP_REG rdi_lf_i1_INT_MASK_REG[]=
{
	{RDI_LF_16_INT_MASK,OAM_RX_BASE_ADDR,0xd3,1,0},
	{RDI_LF_17_INT_MASK,OAM_RX_BASE_ADDR,0xd3,3,2},
	{RDI_LF_18_INT_MASK,OAM_RX_BASE_ADDR,0xd3,5,4},
	{RDI_LF_19_INT_MASK,OAM_RX_BASE_ADDR,0xd3,7,6},
	{RDI_LF_20_INT_MASK,OAM_RX_BASE_ADDR,0xd3,9,8},
	{RDI_LF_21_INT_MASK,OAM_RX_BASE_ADDR,0xd3,11,10},
	{RDI_LF_22_INT_MASK,OAM_RX_BASE_ADDR,0xd3,13,12},
	{RDI_LF_23_INT_MASK,OAM_RX_BASE_ADDR,0xd3,15,14},
	{RDI_LF_24_INT_MASK,OAM_RX_BASE_ADDR,0xd3,17,16},
	{RDI_LF_25_INT_MASK,OAM_RX_BASE_ADDR,0xd3,19,18},
	{RDI_LF_26_INT_MASK,OAM_RX_BASE_ADDR,0xd3,21,20},
	{RDI_LF_27_INT_MASK,OAM_RX_BASE_ADDR,0xd3,23,22},
	{RDI_LF_28_INT_MASK,OAM_RX_BASE_ADDR,0xd3,25,24},
	{RDI_LF_29_INT_MASK,OAM_RX_BASE_ADDR,0xd3,27,26},
	{RDI_LF_30_INT_MASK,OAM_RX_BASE_ADDR,0xd3,29,28},
	{RDI_LF_31_INT_MASK,OAM_RX_BASE_ADDR,0xd3,31,30},
};
const CHIP_REG rdi_lf_i2_INT_REG[]=
{
	{RDI_LF_32_INT,OAM_RX_BASE_ADDR,0xd4,1,0},
	{RDI_LF_33_INT,OAM_RX_BASE_ADDR,0xd4,3,2},
	{RDI_LF_34_INT,OAM_RX_BASE_ADDR,0xd4,5,4},
	{RDI_LF_35_INT,OAM_RX_BASE_ADDR,0xd4,7,6},
	{RDI_LF_36_INT,OAM_RX_BASE_ADDR,0xd4,9,8},
	{RDI_LF_37_INT,OAM_RX_BASE_ADDR,0xd4,11,10},
	{RDI_LF_38_INT,OAM_RX_BASE_ADDR,0xd4,13,12},
	{RDI_LF_39_INT,OAM_RX_BASE_ADDR,0xd4,15,14},
	{RDI_LF_40_INT,OAM_RX_BASE_ADDR,0xd4,17,16},
	{RDI_LF_41_INT,OAM_RX_BASE_ADDR,0xd4,19,18},
	{RDI_LF_42_INT,OAM_RX_BASE_ADDR,0xd4,21,20},
	{RDI_LF_43_INT,OAM_RX_BASE_ADDR,0xd4,23,22},
	{RDI_LF_44_INT,OAM_RX_BASE_ADDR,0xd4,25,24},
	{RDI_LF_45_INT,OAM_RX_BASE_ADDR,0xd4,27,26},
	{RDI_LF_46_INT,OAM_RX_BASE_ADDR,0xd4,29,28},
	{RDI_LF_47_INT,OAM_RX_BASE_ADDR,0xd4,31,30},
};
const CHIP_REG rdi_lf_i2_INT_MASK_REG[]=
{
	{RDI_LF_32_INT_MASK,OAM_RX_BASE_ADDR,0xd5,1,0},
	{RDI_LF_33_INT_MASK,OAM_RX_BASE_ADDR,0xd5,3,2},
	{RDI_LF_34_INT_MASK,OAM_RX_BASE_ADDR,0xd5,5,4},
	{RDI_LF_35_INT_MASK,OAM_RX_BASE_ADDR,0xd5,7,6},
	{RDI_LF_36_INT_MASK,OAM_RX_BASE_ADDR,0xd5,9,8},
	{RDI_LF_37_INT_MASK,OAM_RX_BASE_ADDR,0xd5,11,10},
	{RDI_LF_38_INT_MASK,OAM_RX_BASE_ADDR,0xd5,13,12},
	{RDI_LF_39_INT_MASK,OAM_RX_BASE_ADDR,0xd5,15,14},
	{RDI_LF_40_INT_MASK,OAM_RX_BASE_ADDR,0xd5,17,16},
	{RDI_LF_41_INT_MASK,OAM_RX_BASE_ADDR,0xd5,19,18},
	{RDI_LF_42_INT_MASK,OAM_RX_BASE_ADDR,0xd5,21,20},
	{RDI_LF_43_INT_MASK,OAM_RX_BASE_ADDR,0xd5,23,22},
	{RDI_LF_44_INT_MASK,OAM_RX_BASE_ADDR,0xd5,25,24},
	{RDI_LF_45_INT_MASK,OAM_RX_BASE_ADDR,0xd5,27,26},
	{RDI_LF_46_INT_MASK,OAM_RX_BASE_ADDR,0xd5,29,28},
	{RDI_LF_47_INT_MASK,OAM_RX_BASE_ADDR,0xd5,31,30},
};
const CHIP_REG rdi_lf_i3_INT_REG[]=
{
	{RDI_LF_48_INT,OAM_RX_BASE_ADDR,0xd6,1,0},
	{RDI_LF_49_INT,OAM_RX_BASE_ADDR,0xd6,3,2},
	{RDI_LF_50_INT,OAM_RX_BASE_ADDR,0xd6,5,4},
	{RDI_LF_51_INT,OAM_RX_BASE_ADDR,0xd6,7,6},
	{RDI_LF_52_INT,OAM_RX_BASE_ADDR,0xd6,9,8},
	{RDI_LF_53_INT,OAM_RX_BASE_ADDR,0xd6,11,10},
	{RDI_LF_54_INT,OAM_RX_BASE_ADDR,0xd6,13,12},
	{RDI_LF_55_INT,OAM_RX_BASE_ADDR,0xd6,15,14},
	{RDI_LF_56_INT,OAM_RX_BASE_ADDR,0xd6,17,16},
	{RDI_LF_57_INT,OAM_RX_BASE_ADDR,0xd6,19,18},
	{RDI_LF_58_INT,OAM_RX_BASE_ADDR,0xd6,21,20},
	{RDI_LF_59_INT,OAM_RX_BASE_ADDR,0xd6,23,22},
	{RDI_LF_60_INT,OAM_RX_BASE_ADDR,0xd6,25,24},
	{RDI_LF_61_INT,OAM_RX_BASE_ADDR,0xd6,27,26},
	{RDI_LF_62_INT,OAM_RX_BASE_ADDR,0xd6,29,28},
	{RDI_LF_63_INT,OAM_RX_BASE_ADDR,0xd6,31,30},
};
const CHIP_REG rdi_lf_i3_INT_MASK_REG[]=
{
	{RDI_LF_48_INT_MASK,OAM_RX_BASE_ADDR,0xd7,1,0},
	{RDI_LF_49_INT_MASK,OAM_RX_BASE_ADDR,0xd7,3,2},
	{RDI_LF_50_INT_MASK,OAM_RX_BASE_ADDR,0xd7,5,4},
	{RDI_LF_51_INT_MASK,OAM_RX_BASE_ADDR,0xd7,7,6},
	{RDI_LF_52_INT_MASK,OAM_RX_BASE_ADDR,0xd7,9,8},
	{RDI_LF_53_INT_MASK,OAM_RX_BASE_ADDR,0xd7,11,10},
	{RDI_LF_54_INT_MASK,OAM_RX_BASE_ADDR,0xd7,13,12},
	{RDI_LF_55_INT_MASK,OAM_RX_BASE_ADDR,0xd7,15,14},
	{RDI_LF_56_INT_MASK,OAM_RX_BASE_ADDR,0xd7,17,16},
	{RDI_LF_57_INT_MASK,OAM_RX_BASE_ADDR,0xd7,19,18},
	{RDI_LF_58_INT_MASK,OAM_RX_BASE_ADDR,0xd7,21,20},
	{RDI_LF_59_INT_MASK,OAM_RX_BASE_ADDR,0xd7,23,22},
	{RDI_LF_60_INT_MASK,OAM_RX_BASE_ADDR,0xd7,25,24},
	{RDI_LF_61_INT_MASK,OAM_RX_BASE_ADDR,0xd7,27,26},
	{RDI_LF_62_INT_MASK,OAM_RX_BASE_ADDR,0xd7,29,28},
	{RDI_LF_63_INT_MASK,OAM_RX_BASE_ADDR,0xd7,31,30},
};
const CHIP_REG rdi_lf_i4_INT_REG[]=
{
	{RDI_LF_64_INT,OAM_RX_BASE_ADDR,0xd8,1,0},
	{RDI_LF_65_INT,OAM_RX_BASE_ADDR,0xd8,3,2},
	{RDI_LF_66_INT,OAM_RX_BASE_ADDR,0xd8,5,4},
	{RDI_LF_67_INT,OAM_RX_BASE_ADDR,0xd8,7,6},
	{RDI_LF_68_INT,OAM_RX_BASE_ADDR,0xd8,9,8},
	{RDI_LF_69_INT,OAM_RX_BASE_ADDR,0xd8,11,10},
	{RDI_LF_70_INT,OAM_RX_BASE_ADDR,0xd8,13,12},
	{RDI_LF_71_INT,OAM_RX_BASE_ADDR,0xd8,15,14},
	{RDI_LF_72_INT,OAM_RX_BASE_ADDR,0xd8,17,16},
	{RDI_LF_73_INT,OAM_RX_BASE_ADDR,0xd8,19,18},
	{RDI_LF_74_INT,OAM_RX_BASE_ADDR,0xd8,21,20},
	{RDI_LF_75_INT,OAM_RX_BASE_ADDR,0xd8,23,22},
	{RDI_LF_76_INT,OAM_RX_BASE_ADDR,0xd8,25,24},
	{RDI_LF_77_INT,OAM_RX_BASE_ADDR,0xd8,27,26},
	{RDI_LF_78_INT,OAM_RX_BASE_ADDR,0xd8,29,28},
	{RDI_LF_79_INT,OAM_RX_BASE_ADDR,0xd8,31,30},
};
const CHIP_REG rdi_lf_i4_INT_MASK_REG[]=
{
	{RDI_LF_64_INT_MASK,OAM_RX_BASE_ADDR,0xd9,1,0},
	{RDI_LF_65_INT_MASK,OAM_RX_BASE_ADDR,0xd9,3,2},
	{RDI_LF_66_INT_MASK,OAM_RX_BASE_ADDR,0xd9,5,4},
	{RDI_LF_67_INT_MASK,OAM_RX_BASE_ADDR,0xd9,7,6},
	{RDI_LF_68_INT_MASK,OAM_RX_BASE_ADDR,0xd9,9,8},
	{RDI_LF_69_INT_MASK,OAM_RX_BASE_ADDR,0xd9,11,10},
	{RDI_LF_70_INT_MASK,OAM_RX_BASE_ADDR,0xd9,13,12},
	{RDI_LF_71_INT_MASK,OAM_RX_BASE_ADDR,0xd9,15,14},
	{RDI_LF_72_INT_MASK,OAM_RX_BASE_ADDR,0xd9,17,16},
	{RDI_LF_73_INT_MASK,OAM_RX_BASE_ADDR,0xd9,19,18},
	{RDI_LF_74_INT_MASK,OAM_RX_BASE_ADDR,0xd9,21,20},
	{RDI_LF_75_INT_MASK,OAM_RX_BASE_ADDR,0xd9,23,22},
	{RDI_LF_76_INT_MASK,OAM_RX_BASE_ADDR,0xd9,25,24},
	{RDI_LF_77_INT_MASK,OAM_RX_BASE_ADDR,0xd9,27,26},
	{RDI_LF_78_INT_MASK,OAM_RX_BASE_ADDR,0xd9,29,28},
	{RDI_LF_79_INT_MASK,OAM_RX_BASE_ADDR,0xd9,31,30},
};
const CHIP_REG rx_sdbei_i0_INT_REG[]=
{
	{RX_SDBEI_0_INT,OAM_RX_BASE_ADDR,0xda,1,0},
	{RX_SDBEI_1_INT,OAM_RX_BASE_ADDR,0xda,3,2},
	{RX_SDBEI_2_INT,OAM_RX_BASE_ADDR,0xda,5,4},
	{RX_SDBEI_3_INT,OAM_RX_BASE_ADDR,0xda,7,6},
	{RX_SDBEI_4_INT,OAM_RX_BASE_ADDR,0xda,9,8},
	{RX_SDBEI_5_INT,OAM_RX_BASE_ADDR,0xda,11,10},
	{RX_SDBEI_6_INT,OAM_RX_BASE_ADDR,0xda,13,12},
	{RX_SDBEI_7_INT,OAM_RX_BASE_ADDR,0xda,15,14},
	{RX_SDBEI_8_INT,OAM_RX_BASE_ADDR,0xda,17,16},
	{RX_SDBEI_9_INT,OAM_RX_BASE_ADDR,0xda,19,18},
	{RX_SDBEI_10_INT,OAM_RX_BASE_ADDR,0xda,21,20},
	{RX_SDBEI_11_INT,OAM_RX_BASE_ADDR,0xda,23,22},
	{RX_SDBEI_12_INT,OAM_RX_BASE_ADDR,0xda,25,24},
	{RX_SDBEI_13_INT,OAM_RX_BASE_ADDR,0xda,27,26},
	{RX_SDBEI_14_INT,OAM_RX_BASE_ADDR,0xda,29,28},
	{RX_SDBEI_15_INT,OAM_RX_BASE_ADDR,0xda,31,30},
};
const CHIP_REG rx_sdbei_i0_INT_MASK_REG[]=
{
	{RX_SDBEI_0_INT_MASK,OAM_RX_BASE_ADDR,0xdb,1,0},
	{RX_SDBEI_1_INT_MASK,OAM_RX_BASE_ADDR,0xdb,3,2},
	{RX_SDBEI_2_INT_MASK,OAM_RX_BASE_ADDR,0xdb,5,4},
	{RX_SDBEI_3_INT_MASK,OAM_RX_BASE_ADDR,0xdb,7,6},
	{RX_SDBEI_4_INT_MASK,OAM_RX_BASE_ADDR,0xdb,9,8},
	{RX_SDBEI_5_INT_MASK,OAM_RX_BASE_ADDR,0xdb,11,10},
	{RX_SDBEI_6_INT_MASK,OAM_RX_BASE_ADDR,0xdb,13,12},
	{RX_SDBEI_7_INT_MASK,OAM_RX_BASE_ADDR,0xdb,15,14},
	{RX_SDBEI_8_INT_MASK,OAM_RX_BASE_ADDR,0xdb,17,16},
	{RX_SDBEI_9_INT_MASK,OAM_RX_BASE_ADDR,0xdb,19,18},
	{RX_SDBEI_10_INT_MASK,OAM_RX_BASE_ADDR,0xdb,21,20},
	{RX_SDBEI_11_INT_MASK,OAM_RX_BASE_ADDR,0xdb,23,22},
	{RX_SDBEI_12_INT_MASK,OAM_RX_BASE_ADDR,0xdb,25,24},
	{RX_SDBEI_13_INT_MASK,OAM_RX_BASE_ADDR,0xdb,27,26},
	{RX_SDBEI_14_INT_MASK,OAM_RX_BASE_ADDR,0xdb,29,28},
	{RX_SDBEI_15_INT_MASK,OAM_RX_BASE_ADDR,0xdb,31,30},
};
const CHIP_REG rx_sdbei_i1_INT_REG[]=
{
	{RX_SDBEI_16_INT,OAM_RX_BASE_ADDR,0xdc,1,0},
	{RX_SDBEI_17_INT,OAM_RX_BASE_ADDR,0xdc,3,2},
	{RX_SDBEI_18_INT,OAM_RX_BASE_ADDR,0xdc,5,4},
	{RX_SDBEI_19_INT,OAM_RX_BASE_ADDR,0xdc,7,6},
	{RX_SDBEI_20_INT,OAM_RX_BASE_ADDR,0xdc,9,8},
	{RX_SDBEI_21_INT,OAM_RX_BASE_ADDR,0xdc,11,10},
	{RX_SDBEI_22_INT,OAM_RX_BASE_ADDR,0xdc,13,12},
	{RX_SDBEI_23_INT,OAM_RX_BASE_ADDR,0xdc,15,14},
	{RX_SDBEI_24_INT,OAM_RX_BASE_ADDR,0xdc,17,16},
	{RX_SDBEI_25_INT,OAM_RX_BASE_ADDR,0xdc,19,18},
	{RX_SDBEI_26_INT,OAM_RX_BASE_ADDR,0xdc,21,20},
	{RX_SDBEI_27_INT,OAM_RX_BASE_ADDR,0xdc,23,22},
	{RX_SDBEI_28_INT,OAM_RX_BASE_ADDR,0xdc,25,24},
	{RX_SDBEI_29_INT,OAM_RX_BASE_ADDR,0xdc,27,26},
	{RX_SDBEI_30_INT,OAM_RX_BASE_ADDR,0xdc,29,28},
	{RX_SDBEI_31_INT,OAM_RX_BASE_ADDR,0xdc,31,30},
};
const CHIP_REG rx_sdbei_i1_INT_MASK_REG[]=
{
	{RX_SDBEI_16_INT_MASK,OAM_RX_BASE_ADDR,0xdd,1,0},
	{RX_SDBEI_17_INT_MASK,OAM_RX_BASE_ADDR,0xdd,3,2},
	{RX_SDBEI_18_INT_MASK,OAM_RX_BASE_ADDR,0xdd,5,4},
	{RX_SDBEI_19_INT_MASK,OAM_RX_BASE_ADDR,0xdd,7,6},
	{RX_SDBEI_20_INT_MASK,OAM_RX_BASE_ADDR,0xdd,9,8},
	{RX_SDBEI_21_INT_MASK,OAM_RX_BASE_ADDR,0xdd,11,10},
	{RX_SDBEI_22_INT_MASK,OAM_RX_BASE_ADDR,0xdd,13,12},
	{RX_SDBEI_23_INT_MASK,OAM_RX_BASE_ADDR,0xdd,15,14},
	{RX_SDBEI_24_INT_MASK,OAM_RX_BASE_ADDR,0xdd,17,16},
	{RX_SDBEI_25_INT_MASK,OAM_RX_BASE_ADDR,0xdd,19,18},
	{RX_SDBEI_26_INT_MASK,OAM_RX_BASE_ADDR,0xdd,21,20},
	{RX_SDBEI_27_INT_MASK,OAM_RX_BASE_ADDR,0xdd,23,22},
	{RX_SDBEI_28_INT_MASK,OAM_RX_BASE_ADDR,0xdd,25,24},
	{RX_SDBEI_29_INT_MASK,OAM_RX_BASE_ADDR,0xdd,27,26},
	{RX_SDBEI_30_INT_MASK,OAM_RX_BASE_ADDR,0xdd,29,28},
	{RX_SDBEI_31_INT_MASK,OAM_RX_BASE_ADDR,0xdd,31,30},
};
const CHIP_REG rx_sdbei_i2_INT_REG[]=
{
	{RX_SDBEI_32_INT,OAM_RX_BASE_ADDR,0xde,1,0},
	{RX_SDBEI_33_INT,OAM_RX_BASE_ADDR,0xde,3,2},
	{RX_SDBEI_34_INT,OAM_RX_BASE_ADDR,0xde,5,4},
	{RX_SDBEI_35_INT,OAM_RX_BASE_ADDR,0xde,7,6},
	{RX_SDBEI_36_INT,OAM_RX_BASE_ADDR,0xde,9,8},
	{RX_SDBEI_37_INT,OAM_RX_BASE_ADDR,0xde,11,10},
	{RX_SDBEI_38_INT,OAM_RX_BASE_ADDR,0xde,13,12},
	{RX_SDBEI_39_INT,OAM_RX_BASE_ADDR,0xde,15,14},
	{RX_SDBEI_40_INT,OAM_RX_BASE_ADDR,0xde,17,16},
	{RX_SDBEI_41_INT,OAM_RX_BASE_ADDR,0xde,19,18},
	{RX_SDBEI_42_INT,OAM_RX_BASE_ADDR,0xde,21,20},
	{RX_SDBEI_43_INT,OAM_RX_BASE_ADDR,0xde,23,22},
	{RX_SDBEI_44_INT,OAM_RX_BASE_ADDR,0xde,25,24},
	{RX_SDBEI_45_INT,OAM_RX_BASE_ADDR,0xde,27,26},
	{RX_SDBEI_46_INT,OAM_RX_BASE_ADDR,0xde,29,28},
	{RX_SDBEI_47_INT,OAM_RX_BASE_ADDR,0xde,31,30},
};
const CHIP_REG rx_sdbei_i2_INT_MASK_REG[]=
{
	{RX_SDBEI_32_INT_MASK,OAM_RX_BASE_ADDR,0xdf,1,0},
	{RX_SDBEI_33_INT_MASK,OAM_RX_BASE_ADDR,0xdf,3,2},
	{RX_SDBEI_34_INT_MASK,OAM_RX_BASE_ADDR,0xdf,5,4},
	{RX_SDBEI_35_INT_MASK,OAM_RX_BASE_ADDR,0xdf,7,6},
	{RX_SDBEI_36_INT_MASK,OAM_RX_BASE_ADDR,0xdf,9,8},
	{RX_SDBEI_37_INT_MASK,OAM_RX_BASE_ADDR,0xdf,11,10},
	{RX_SDBEI_38_INT_MASK,OAM_RX_BASE_ADDR,0xdf,13,12},
	{RX_SDBEI_39_INT_MASK,OAM_RX_BASE_ADDR,0xdf,15,14},
	{RX_SDBEI_40_INT_MASK,OAM_RX_BASE_ADDR,0xdf,17,16},
	{RX_SDBEI_41_INT_MASK,OAM_RX_BASE_ADDR,0xdf,19,18},
	{RX_SDBEI_42_INT_MASK,OAM_RX_BASE_ADDR,0xdf,21,20},
	{RX_SDBEI_43_INT_MASK,OAM_RX_BASE_ADDR,0xdf,23,22},
	{RX_SDBEI_44_INT_MASK,OAM_RX_BASE_ADDR,0xdf,25,24},
	{RX_SDBEI_45_INT_MASK,OAM_RX_BASE_ADDR,0xdf,27,26},
	{RX_SDBEI_46_INT_MASK,OAM_RX_BASE_ADDR,0xdf,29,28},
	{RX_SDBEI_47_INT_MASK,OAM_RX_BASE_ADDR,0xdf,31,30},
};
const CHIP_REG rx_sdbei_i3_INT_REG[]=
{
	{RX_SDBEI_48_INT,OAM_RX_BASE_ADDR,0xe0,1,0},
	{RX_SDBEI_49_INT,OAM_RX_BASE_ADDR,0xe0,3,2},
	{RX_SDBEI_50_INT,OAM_RX_BASE_ADDR,0xe0,5,4},
	{RX_SDBEI_51_INT,OAM_RX_BASE_ADDR,0xe0,7,6},
	{RX_SDBEI_52_INT,OAM_RX_BASE_ADDR,0xe0,9,8},
	{RX_SDBEI_53_INT,OAM_RX_BASE_ADDR,0xe0,11,10},
	{RX_SDBEI_54_INT,OAM_RX_BASE_ADDR,0xe0,13,12},
	{RX_SDBEI_55_INT,OAM_RX_BASE_ADDR,0xe0,15,14},
	{RX_SDBEI_56_INT,OAM_RX_BASE_ADDR,0xe0,17,16},
	{RX_SDBEI_57_INT,OAM_RX_BASE_ADDR,0xe0,19,18},
	{RX_SDBEI_58_INT,OAM_RX_BASE_ADDR,0xe0,21,20},
	{RX_SDBEI_59_INT,OAM_RX_BASE_ADDR,0xe0,23,22},
	{RX_SDBEI_60_INT,OAM_RX_BASE_ADDR,0xe0,25,24},
	{RX_SDBEI_61_INT,OAM_RX_BASE_ADDR,0xe0,27,26},
	{RX_SDBEI_62_INT,OAM_RX_BASE_ADDR,0xe0,29,28},
	{RX_SDBEI_63_INT,OAM_RX_BASE_ADDR,0xe0,31,30},
};
const CHIP_REG rx_sdbei_i3_INT_MASK_REG[]=
{
	{RX_SDBEI_48_INT_MASK,OAM_RX_BASE_ADDR,0xe1,1,0},
	{RX_SDBEI_49_INT_MASK,OAM_RX_BASE_ADDR,0xe1,3,2},
	{RX_SDBEI_50_INT_MASK,OAM_RX_BASE_ADDR,0xe1,5,4},
	{RX_SDBEI_51_INT_MASK,OAM_RX_BASE_ADDR,0xe1,7,6},
	{RX_SDBEI_52_INT_MASK,OAM_RX_BASE_ADDR,0xe1,9,8},
	{RX_SDBEI_53_INT_MASK,OAM_RX_BASE_ADDR,0xe1,11,10},
	{RX_SDBEI_54_INT_MASK,OAM_RX_BASE_ADDR,0xe1,13,12},
	{RX_SDBEI_55_INT_MASK,OAM_RX_BASE_ADDR,0xe1,15,14},
	{RX_SDBEI_56_INT_MASK,OAM_RX_BASE_ADDR,0xe1,17,16},
	{RX_SDBEI_57_INT_MASK,OAM_RX_BASE_ADDR,0xe1,19,18},
	{RX_SDBEI_58_INT_MASK,OAM_RX_BASE_ADDR,0xe1,21,20},
	{RX_SDBEI_59_INT_MASK,OAM_RX_BASE_ADDR,0xe1,23,22},
	{RX_SDBEI_60_INT_MASK,OAM_RX_BASE_ADDR,0xe1,25,24},
	{RX_SDBEI_61_INT_MASK,OAM_RX_BASE_ADDR,0xe1,27,26},
	{RX_SDBEI_62_INT_MASK,OAM_RX_BASE_ADDR,0xe1,29,28},
	{RX_SDBEI_63_INT_MASK,OAM_RX_BASE_ADDR,0xe1,31,30},
};
const CHIP_REG rx_sdbei_i4_INT_REG[]=
{
	{RX_SDBEI_64_INT,OAM_RX_BASE_ADDR,0xe2,1,0},
	{RX_SDBEI_65_INT,OAM_RX_BASE_ADDR,0xe2,3,2},
	{RX_SDBEI_66_INT,OAM_RX_BASE_ADDR,0xe2,5,4},
	{RX_SDBEI_67_INT,OAM_RX_BASE_ADDR,0xe2,7,6},
	{RX_SDBEI_68_INT,OAM_RX_BASE_ADDR,0xe2,9,8},
	{RX_SDBEI_69_INT,OAM_RX_BASE_ADDR,0xe2,11,10},
	{RX_SDBEI_70_INT,OAM_RX_BASE_ADDR,0xe2,13,12},
	{RX_SDBEI_71_INT,OAM_RX_BASE_ADDR,0xe2,15,14},
	{RX_SDBEI_72_INT,OAM_RX_BASE_ADDR,0xe2,17,16},
	{RX_SDBEI_73_INT,OAM_RX_BASE_ADDR,0xe2,19,18},
	{RX_SDBEI_74_INT,OAM_RX_BASE_ADDR,0xe2,21,20},
	{RX_SDBEI_75_INT,OAM_RX_BASE_ADDR,0xe2,23,22},
	{RX_SDBEI_76_INT,OAM_RX_BASE_ADDR,0xe2,25,24},
	{RX_SDBEI_77_INT,OAM_RX_BASE_ADDR,0xe2,27,26},
	{RX_SDBEI_78_INT,OAM_RX_BASE_ADDR,0xe2,29,28},
	{RX_SDBEI_79_INT,OAM_RX_BASE_ADDR,0xe2,31,30},
};
const CHIP_REG rx_sdbei_i4_INT_MASK_REG[]=
{
	{RX_SDBEI_64_INT_MASK,OAM_RX_BASE_ADDR,0xe3,1,0},
	{RX_SDBEI_65_INT_MASK,OAM_RX_BASE_ADDR,0xe3,3,2},
	{RX_SDBEI_66_INT_MASK,OAM_RX_BASE_ADDR,0xe3,5,4},
	{RX_SDBEI_67_INT_MASK,OAM_RX_BASE_ADDR,0xe3,7,6},
	{RX_SDBEI_68_INT_MASK,OAM_RX_BASE_ADDR,0xe3,9,8},
	{RX_SDBEI_69_INT_MASK,OAM_RX_BASE_ADDR,0xe3,11,10},
	{RX_SDBEI_70_INT_MASK,OAM_RX_BASE_ADDR,0xe3,13,12},
	{RX_SDBEI_71_INT_MASK,OAM_RX_BASE_ADDR,0xe3,15,14},
	{RX_SDBEI_72_INT_MASK,OAM_RX_BASE_ADDR,0xe3,17,16},
	{RX_SDBEI_73_INT_MASK,OAM_RX_BASE_ADDR,0xe3,19,18},
	{RX_SDBEI_74_INT_MASK,OAM_RX_BASE_ADDR,0xe3,21,20},
	{RX_SDBEI_75_INT_MASK,OAM_RX_BASE_ADDR,0xe3,23,22},
	{RX_SDBEI_76_INT_MASK,OAM_RX_BASE_ADDR,0xe3,25,24},
	{RX_SDBEI_77_INT_MASK,OAM_RX_BASE_ADDR,0xe3,27,26},
	{RX_SDBEI_78_INT_MASK,OAM_RX_BASE_ADDR,0xe3,29,28},
	{RX_SDBEI_79_INT_MASK,OAM_RX_BASE_ADDR,0xe3,31,30},
};
const CHIP_REG rf_alm_i0_INT_REG[]=
{
	{RF_ALM_0_INT,OAM_RX_BASE_ADDR,0xe4,1,0},
	{RF_ALM_1_INT,OAM_RX_BASE_ADDR,0xe4,3,2},
	{RF_ALM_2_INT,OAM_RX_BASE_ADDR,0xe4,5,4},
	{RF_ALM_3_INT,OAM_RX_BASE_ADDR,0xe4,7,6},
	{RF_ALM_4_INT,OAM_RX_BASE_ADDR,0xe4,9,8},
	{RF_ALM_5_INT,OAM_RX_BASE_ADDR,0xe4,11,10},
	{RF_ALM_6_INT,OAM_RX_BASE_ADDR,0xe4,13,12},
	{RF_ALM_7_INT,OAM_RX_BASE_ADDR,0xe4,15,14},
	{RF_ALM_8_INT,OAM_RX_BASE_ADDR,0xe4,17,16},
	{RF_ALM_9_INT,OAM_RX_BASE_ADDR,0xe4,19,18},
	{RF_ALM_10_INT,OAM_RX_BASE_ADDR,0xe4,21,20},
	{RF_ALM_11_INT,OAM_RX_BASE_ADDR,0xe4,23,22},
	{RF_ALM_12_INT,OAM_RX_BASE_ADDR,0xe4,25,24},
	{RF_ALM_13_INT,OAM_RX_BASE_ADDR,0xe4,27,26},
	{RF_ALM_14_INT,OAM_RX_BASE_ADDR,0xe4,29,28},
	{RF_ALM_15_INT,OAM_RX_BASE_ADDR,0xe4,31,30},
};
const CHIP_REG rf_alm_i0_INT_MASK_REG[]=
{
	{RF_ALM_0_INT_MASK,OAM_RX_BASE_ADDR,0xe5,1,0},
	{RF_ALM_1_INT_MASK,OAM_RX_BASE_ADDR,0xe5,3,2},
	{RF_ALM_2_INT_MASK,OAM_RX_BASE_ADDR,0xe5,5,4},
	{RF_ALM_3_INT_MASK,OAM_RX_BASE_ADDR,0xe5,7,6},
	{RF_ALM_4_INT_MASK,OAM_RX_BASE_ADDR,0xe5,9,8},
	{RF_ALM_5_INT_MASK,OAM_RX_BASE_ADDR,0xe5,11,10},
	{RF_ALM_6_INT_MASK,OAM_RX_BASE_ADDR,0xe5,13,12},
	{RF_ALM_7_INT_MASK,OAM_RX_BASE_ADDR,0xe5,15,14},
	{RF_ALM_8_INT_MASK,OAM_RX_BASE_ADDR,0xe5,17,16},
	{RF_ALM_9_INT_MASK,OAM_RX_BASE_ADDR,0xe5,19,18},
	{RF_ALM_10_INT_MASK,OAM_RX_BASE_ADDR,0xe5,21,20},
	{RF_ALM_11_INT_MASK,OAM_RX_BASE_ADDR,0xe5,23,22},
	{RF_ALM_12_INT_MASK,OAM_RX_BASE_ADDR,0xe5,25,24},
	{RF_ALM_13_INT_MASK,OAM_RX_BASE_ADDR,0xe5,27,26},
	{RF_ALM_14_INT_MASK,OAM_RX_BASE_ADDR,0xe5,29,28},
	{RF_ALM_15_INT_MASK,OAM_RX_BASE_ADDR,0xe5,31,30},
};
const CHIP_REG rf_alm_i1_INT_REG[]=
{
	{RF_ALM_16_INT,OAM_RX_BASE_ADDR,0xe6,1,0},
	{RF_ALM_17_INT,OAM_RX_BASE_ADDR,0xe6,3,2},
	{RF_ALM_18_INT,OAM_RX_BASE_ADDR,0xe6,5,4},
	{RF_ALM_19_INT,OAM_RX_BASE_ADDR,0xe6,7,6},
	{RF_ALM_20_INT,OAM_RX_BASE_ADDR,0xe6,9,8},
	{RF_ALM_21_INT,OAM_RX_BASE_ADDR,0xe6,11,10},
	{RF_ALM_22_INT,OAM_RX_BASE_ADDR,0xe6,13,12},
	{RF_ALM_23_INT,OAM_RX_BASE_ADDR,0xe6,15,14},
	{RF_ALM_24_INT,OAM_RX_BASE_ADDR,0xe6,17,16},
	{RF_ALM_25_INT,OAM_RX_BASE_ADDR,0xe6,19,18},
	{RF_ALM_26_INT,OAM_RX_BASE_ADDR,0xe6,21,20},
	{RF_ALM_27_INT,OAM_RX_BASE_ADDR,0xe6,23,22},
	{RF_ALM_28_INT,OAM_RX_BASE_ADDR,0xe6,25,24},
	{RF_ALM_29_INT,OAM_RX_BASE_ADDR,0xe6,27,26},
	{RF_ALM_30_INT,OAM_RX_BASE_ADDR,0xe6,29,28},
	{RF_ALM_31_INT,OAM_RX_BASE_ADDR,0xe6,31,30},
};
const CHIP_REG rf_alm_i1_INT_MASK_REG[]=
{
	{RF_ALM_16_INT_MASK,OAM_RX_BASE_ADDR,0xe7,1,0},
	{RF_ALM_17_INT_MASK,OAM_RX_BASE_ADDR,0xe7,3,2},
	{RF_ALM_18_INT_MASK,OAM_RX_BASE_ADDR,0xe7,5,4},
	{RF_ALM_19_INT_MASK,OAM_RX_BASE_ADDR,0xe7,7,6},
	{RF_ALM_20_INT_MASK,OAM_RX_BASE_ADDR,0xe7,9,8},
	{RF_ALM_21_INT_MASK,OAM_RX_BASE_ADDR,0xe7,11,10},
	{RF_ALM_22_INT_MASK,OAM_RX_BASE_ADDR,0xe7,13,12},
	{RF_ALM_23_INT_MASK,OAM_RX_BASE_ADDR,0xe7,15,14},
	{RF_ALM_24_INT_MASK,OAM_RX_BASE_ADDR,0xe7,17,16},
	{RF_ALM_25_INT_MASK,OAM_RX_BASE_ADDR,0xe7,19,18},
	{RF_ALM_26_INT_MASK,OAM_RX_BASE_ADDR,0xe7,21,20},
	{RF_ALM_27_INT_MASK,OAM_RX_BASE_ADDR,0xe7,23,22},
	{RF_ALM_28_INT_MASK,OAM_RX_BASE_ADDR,0xe7,25,24},
	{RF_ALM_29_INT_MASK,OAM_RX_BASE_ADDR,0xe7,27,26},
	{RF_ALM_30_INT_MASK,OAM_RX_BASE_ADDR,0xe7,29,28},
	{RF_ALM_31_INT_MASK,OAM_RX_BASE_ADDR,0xe7,31,30},
};
const CHIP_REG rf_alm_i2_INT_REG[]=
{
	{RF_ALM_32_INT,OAM_RX_BASE_ADDR,0xe8,1,0},
	{RF_ALM_33_INT,OAM_RX_BASE_ADDR,0xe8,3,2},
	{RF_ALM_34_INT,OAM_RX_BASE_ADDR,0xe8,5,4},
	{RF_ALM_35_INT,OAM_RX_BASE_ADDR,0xe8,7,6},
	{RF_ALM_36_INT,OAM_RX_BASE_ADDR,0xe8,9,8},
	{RF_ALM_37_INT,OAM_RX_BASE_ADDR,0xe8,11,10},
	{RF_ALM_38_INT,OAM_RX_BASE_ADDR,0xe8,13,12},
	{RF_ALM_39_INT,OAM_RX_BASE_ADDR,0xe8,15,14},
	{RF_ALM_40_INT,OAM_RX_BASE_ADDR,0xe8,17,16},
	{RF_ALM_41_INT,OAM_RX_BASE_ADDR,0xe8,19,18},
	{RF_ALM_42_INT,OAM_RX_BASE_ADDR,0xe8,21,20},
	{RF_ALM_43_INT,OAM_RX_BASE_ADDR,0xe8,23,22},
	{RF_ALM_44_INT,OAM_RX_BASE_ADDR,0xe8,25,24},
	{RF_ALM_45_INT,OAM_RX_BASE_ADDR,0xe8,27,26},
	{RF_ALM_46_INT,OAM_RX_BASE_ADDR,0xe8,29,28},
	{RF_ALM_47_INT,OAM_RX_BASE_ADDR,0xe8,31,30},
};
const CHIP_REG rf_alm_i2_INT_MASK_REG[]=
{
	{RF_ALM_32_INT_MASK,OAM_RX_BASE_ADDR,0xe9,1,0},
	{RF_ALM_33_INT_MASK,OAM_RX_BASE_ADDR,0xe9,3,2},
	{RF_ALM_34_INT_MASK,OAM_RX_BASE_ADDR,0xe9,5,4},
	{RF_ALM_35_INT_MASK,OAM_RX_BASE_ADDR,0xe9,7,6},
	{RF_ALM_36_INT_MASK,OAM_RX_BASE_ADDR,0xe9,9,8},
	{RF_ALM_37_INT_MASK,OAM_RX_BASE_ADDR,0xe9,11,10},
	{RF_ALM_38_INT_MASK,OAM_RX_BASE_ADDR,0xe9,13,12},
	{RF_ALM_39_INT_MASK,OAM_RX_BASE_ADDR,0xe9,15,14},
	{RF_ALM_40_INT_MASK,OAM_RX_BASE_ADDR,0xe9,17,16},
	{RF_ALM_41_INT_MASK,OAM_RX_BASE_ADDR,0xe9,19,18},
	{RF_ALM_42_INT_MASK,OAM_RX_BASE_ADDR,0xe9,21,20},
	{RF_ALM_43_INT_MASK,OAM_RX_BASE_ADDR,0xe9,23,22},
	{RF_ALM_44_INT_MASK,OAM_RX_BASE_ADDR,0xe9,25,24},
	{RF_ALM_45_INT_MASK,OAM_RX_BASE_ADDR,0xe9,27,26},
	{RF_ALM_46_INT_MASK,OAM_RX_BASE_ADDR,0xe9,29,28},
	{RF_ALM_47_INT_MASK,OAM_RX_BASE_ADDR,0xe9,31,30},
};
const CHIP_REG rf_alm_i3_INT_REG[]=
{
	{RF_ALM_48_INT,OAM_RX_BASE_ADDR,0xea,1,0},
	{RF_ALM_49_INT,OAM_RX_BASE_ADDR,0xea,3,2},
	{RF_ALM_50_INT,OAM_RX_BASE_ADDR,0xea,5,4},
	{RF_ALM_51_INT,OAM_RX_BASE_ADDR,0xea,7,6},
	{RF_ALM_52_INT,OAM_RX_BASE_ADDR,0xea,9,8},
	{RF_ALM_53_INT,OAM_RX_BASE_ADDR,0xea,11,10},
	{RF_ALM_54_INT,OAM_RX_BASE_ADDR,0xea,13,12},
	{RF_ALM_55_INT,OAM_RX_BASE_ADDR,0xea,15,14},
	{RF_ALM_56_INT,OAM_RX_BASE_ADDR,0xea,17,16},
	{RF_ALM_57_INT,OAM_RX_BASE_ADDR,0xea,19,18},
	{RF_ALM_58_INT,OAM_RX_BASE_ADDR,0xea,21,20},
	{RF_ALM_59_INT,OAM_RX_BASE_ADDR,0xea,23,22},
	{RF_ALM_60_INT,OAM_RX_BASE_ADDR,0xea,25,24},
	{RF_ALM_61_INT,OAM_RX_BASE_ADDR,0xea,27,26},
	{RF_ALM_62_INT,OAM_RX_BASE_ADDR,0xea,29,28},
	{RF_ALM_63_INT,OAM_RX_BASE_ADDR,0xea,31,30},
};
const CHIP_REG rf_alm_i3_INT_MASK_REG[]=
{
	{RF_ALM_48_INT_MASK,OAM_RX_BASE_ADDR,0xeb,1,0},
	{RF_ALM_49_INT_MASK,OAM_RX_BASE_ADDR,0xeb,3,2},
	{RF_ALM_50_INT_MASK,OAM_RX_BASE_ADDR,0xeb,5,4},
	{RF_ALM_51_INT_MASK,OAM_RX_BASE_ADDR,0xeb,7,6},
	{RF_ALM_52_INT_MASK,OAM_RX_BASE_ADDR,0xeb,9,8},
	{RF_ALM_53_INT_MASK,OAM_RX_BASE_ADDR,0xeb,11,10},
	{RF_ALM_54_INT_MASK,OAM_RX_BASE_ADDR,0xeb,13,12},
	{RF_ALM_55_INT_MASK,OAM_RX_BASE_ADDR,0xeb,15,14},
	{RF_ALM_56_INT_MASK,OAM_RX_BASE_ADDR,0xeb,17,16},
	{RF_ALM_57_INT_MASK,OAM_RX_BASE_ADDR,0xeb,19,18},
	{RF_ALM_58_INT_MASK,OAM_RX_BASE_ADDR,0xeb,21,20},
	{RF_ALM_59_INT_MASK,OAM_RX_BASE_ADDR,0xeb,23,22},
	{RF_ALM_60_INT_MASK,OAM_RX_BASE_ADDR,0xeb,25,24},
	{RF_ALM_61_INT_MASK,OAM_RX_BASE_ADDR,0xeb,27,26},
	{RF_ALM_62_INT_MASK,OAM_RX_BASE_ADDR,0xeb,29,28},
	{RF_ALM_63_INT_MASK,OAM_RX_BASE_ADDR,0xeb,31,30},
};
const CHIP_REG rf_alm_i4_INT_REG[]=
{
	{RF_ALM_64_INT,OAM_RX_BASE_ADDR,0xec,1,0},
	{RF_ALM_65_INT,OAM_RX_BASE_ADDR,0xec,3,2},
	{RF_ALM_66_INT,OAM_RX_BASE_ADDR,0xec,5,4},
	{RF_ALM_67_INT,OAM_RX_BASE_ADDR,0xec,7,6},
	{RF_ALM_68_INT,OAM_RX_BASE_ADDR,0xec,9,8},
	{RF_ALM_69_INT,OAM_RX_BASE_ADDR,0xec,11,10},
	{RF_ALM_70_INT,OAM_RX_BASE_ADDR,0xec,13,12},
	{RF_ALM_71_INT,OAM_RX_BASE_ADDR,0xec,15,14},
	{RF_ALM_72_INT,OAM_RX_BASE_ADDR,0xec,17,16},
	{RF_ALM_73_INT,OAM_RX_BASE_ADDR,0xec,19,18},
	{RF_ALM_74_INT,OAM_RX_BASE_ADDR,0xec,21,20},
	{RF_ALM_75_INT,OAM_RX_BASE_ADDR,0xec,23,22},
	{RF_ALM_76_INT,OAM_RX_BASE_ADDR,0xec,25,24},
	{RF_ALM_77_INT,OAM_RX_BASE_ADDR,0xec,27,26},
	{RF_ALM_78_INT,OAM_RX_BASE_ADDR,0xec,29,28},
	{RF_ALM_79_INT,OAM_RX_BASE_ADDR,0xec,31,30},
};
const CHIP_REG rf_alm_i4_INT_MASK_REG[]=
{
	{RF_ALM_64_INT_MASK,OAM_RX_BASE_ADDR,0xed,1,0},
	{RF_ALM_65_INT_MASK,OAM_RX_BASE_ADDR,0xed,3,2},
	{RF_ALM_66_INT_MASK,OAM_RX_BASE_ADDR,0xed,5,4},
	{RF_ALM_67_INT_MASK,OAM_RX_BASE_ADDR,0xed,7,6},
	{RF_ALM_68_INT_MASK,OAM_RX_BASE_ADDR,0xed,9,8},
	{RF_ALM_69_INT_MASK,OAM_RX_BASE_ADDR,0xed,11,10},
	{RF_ALM_70_INT_MASK,OAM_RX_BASE_ADDR,0xed,13,12},
	{RF_ALM_71_INT_MASK,OAM_RX_BASE_ADDR,0xed,15,14},
	{RF_ALM_72_INT_MASK,OAM_RX_BASE_ADDR,0xed,17,16},
	{RF_ALM_73_INT_MASK,OAM_RX_BASE_ADDR,0xed,19,18},
	{RF_ALM_74_INT_MASK,OAM_RX_BASE_ADDR,0xed,21,20},
	{RF_ALM_75_INT_MASK,OAM_RX_BASE_ADDR,0xed,23,22},
	{RF_ALM_76_INT_MASK,OAM_RX_BASE_ADDR,0xed,25,24},
	{RF_ALM_77_INT_MASK,OAM_RX_BASE_ADDR,0xed,27,26},
	{RF_ALM_78_INT_MASK,OAM_RX_BASE_ADDR,0xed,29,28},
	{RF_ALM_79_INT_MASK,OAM_RX_BASE_ADDR,0xed,31,30},
};
const CHIP_REG lpi_alm_i0_INT_REG[]=
{
	{LPI_ALM_0_INT,OAM_RX_BASE_ADDR,0xee,1,0},
	{LPI_ALM_1_INT,OAM_RX_BASE_ADDR,0xee,3,2},
	{LPI_ALM_2_INT,OAM_RX_BASE_ADDR,0xee,5,4},
	{LPI_ALM_3_INT,OAM_RX_BASE_ADDR,0xee,7,6},
	{LPI_ALM_4_INT,OAM_RX_BASE_ADDR,0xee,9,8},
	{LPI_ALM_5_INT,OAM_RX_BASE_ADDR,0xee,11,10},
	{LPI_ALM_6_INT,OAM_RX_BASE_ADDR,0xee,13,12},
	{LPI_ALM_7_INT,OAM_RX_BASE_ADDR,0xee,15,14},
	{LPI_ALM_8_INT,OAM_RX_BASE_ADDR,0xee,17,16},
	{LPI_ALM_9_INT,OAM_RX_BASE_ADDR,0xee,19,18},
	{LPI_ALM_10_INT,OAM_RX_BASE_ADDR,0xee,21,20},
	{LPI_ALM_11_INT,OAM_RX_BASE_ADDR,0xee,23,22},
	{LPI_ALM_12_INT,OAM_RX_BASE_ADDR,0xee,25,24},
	{LPI_ALM_13_INT,OAM_RX_BASE_ADDR,0xee,27,26},
	{LPI_ALM_14_INT,OAM_RX_BASE_ADDR,0xee,29,28},
	{LPI_ALM_15_INT,OAM_RX_BASE_ADDR,0xee,31,30},
};
const CHIP_REG lpi_alm_i0_INT_MASK_REG[]=
{
	{LPI_ALM_0_INT_MASK,OAM_RX_BASE_ADDR,0xef,1,0},
	{LPI_ALM_1_INT_MASK,OAM_RX_BASE_ADDR,0xef,3,2},
	{LPI_ALM_2_INT_MASK,OAM_RX_BASE_ADDR,0xef,5,4},
	{LPI_ALM_3_INT_MASK,OAM_RX_BASE_ADDR,0xef,7,6},
	{LPI_ALM_4_INT_MASK,OAM_RX_BASE_ADDR,0xef,9,8},
	{LPI_ALM_5_INT_MASK,OAM_RX_BASE_ADDR,0xef,11,10},
	{LPI_ALM_6_INT_MASK,OAM_RX_BASE_ADDR,0xef,13,12},
	{LPI_ALM_7_INT_MASK,OAM_RX_BASE_ADDR,0xef,15,14},
	{LPI_ALM_8_INT_MASK,OAM_RX_BASE_ADDR,0xef,17,16},
	{LPI_ALM_9_INT_MASK,OAM_RX_BASE_ADDR,0xef,19,18},
	{LPI_ALM_10_INT_MASK,OAM_RX_BASE_ADDR,0xef,21,20},
	{LPI_ALM_11_INT_MASK,OAM_RX_BASE_ADDR,0xef,23,22},
	{LPI_ALM_12_INT_MASK,OAM_RX_BASE_ADDR,0xef,25,24},
	{LPI_ALM_13_INT_MASK,OAM_RX_BASE_ADDR,0xef,27,26},
	{LPI_ALM_14_INT_MASK,OAM_RX_BASE_ADDR,0xef,29,28},
	{LPI_ALM_15_INT_MASK,OAM_RX_BASE_ADDR,0xef,31,30},
};
const CHIP_REG lpi_alm_i1_INT_REG[]=
{
	{LPI_ALM_16_INT,OAM_RX_BASE_ADDR,0xf0,1,0},
	{LPI_ALM_17_INT,OAM_RX_BASE_ADDR,0xf0,3,2},
	{LPI_ALM_18_INT,OAM_RX_BASE_ADDR,0xf0,5,4},
	{LPI_ALM_19_INT,OAM_RX_BASE_ADDR,0xf0,7,6},
	{LPI_ALM_20_INT,OAM_RX_BASE_ADDR,0xf0,9,8},
	{LPI_ALM_21_INT,OAM_RX_BASE_ADDR,0xf0,11,10},
	{LPI_ALM_22_INT,OAM_RX_BASE_ADDR,0xf0,13,12},
	{LPI_ALM_23_INT,OAM_RX_BASE_ADDR,0xf0,15,14},
	{LPI_ALM_24_INT,OAM_RX_BASE_ADDR,0xf0,17,16},
	{LPI_ALM_25_INT,OAM_RX_BASE_ADDR,0xf0,19,18},
	{LPI_ALM_26_INT,OAM_RX_BASE_ADDR,0xf0,21,20},
	{LPI_ALM_27_INT,OAM_RX_BASE_ADDR,0xf0,23,22},
	{LPI_ALM_28_INT,OAM_RX_BASE_ADDR,0xf0,25,24},
	{LPI_ALM_29_INT,OAM_RX_BASE_ADDR,0xf0,27,26},
	{LPI_ALM_30_INT,OAM_RX_BASE_ADDR,0xf0,29,28},
	{LPI_ALM_31_INT,OAM_RX_BASE_ADDR,0xf0,31,30},
};
const CHIP_REG lpi_alm_i1_INT_MASK_REG[]=
{
	{LPI_ALM_16_INT_MASK,OAM_RX_BASE_ADDR,0xf1,1,0},
	{LPI_ALM_17_INT_MASK,OAM_RX_BASE_ADDR,0xf1,3,2},
	{LPI_ALM_18_INT_MASK,OAM_RX_BASE_ADDR,0xf1,5,4},
	{LPI_ALM_19_INT_MASK,OAM_RX_BASE_ADDR,0xf1,7,6},
	{LPI_ALM_20_INT_MASK,OAM_RX_BASE_ADDR,0xf1,9,8},
	{LPI_ALM_21_INT_MASK,OAM_RX_BASE_ADDR,0xf1,11,10},
	{LPI_ALM_22_INT_MASK,OAM_RX_BASE_ADDR,0xf1,13,12},
	{LPI_ALM_23_INT_MASK,OAM_RX_BASE_ADDR,0xf1,15,14},
	{LPI_ALM_24_INT_MASK,OAM_RX_BASE_ADDR,0xf1,17,16},
	{LPI_ALM_25_INT_MASK,OAM_RX_BASE_ADDR,0xf1,19,18},
	{LPI_ALM_26_INT_MASK,OAM_RX_BASE_ADDR,0xf1,21,20},
	{LPI_ALM_27_INT_MASK,OAM_RX_BASE_ADDR,0xf1,23,22},
	{LPI_ALM_28_INT_MASK,OAM_RX_BASE_ADDR,0xf1,25,24},
	{LPI_ALM_29_INT_MASK,OAM_RX_BASE_ADDR,0xf1,27,26},
	{LPI_ALM_30_INT_MASK,OAM_RX_BASE_ADDR,0xf1,29,28},
	{LPI_ALM_31_INT_MASK,OAM_RX_BASE_ADDR,0xf1,31,30},
};
const CHIP_REG lpi_alm_i2_INT_REG[]=
{
	{LPI_ALM_32_INT,OAM_RX_BASE_ADDR,0xf2,1,0},
	{LPI_ALM_33_INT,OAM_RX_BASE_ADDR,0xf2,3,2},
	{LPI_ALM_34_INT,OAM_RX_BASE_ADDR,0xf2,5,4},
	{LPI_ALM_35_INT,OAM_RX_BASE_ADDR,0xf2,7,6},
	{LPI_ALM_36_INT,OAM_RX_BASE_ADDR,0xf2,9,8},
	{LPI_ALM_37_INT,OAM_RX_BASE_ADDR,0xf2,11,10},
	{LPI_ALM_38_INT,OAM_RX_BASE_ADDR,0xf2,13,12},
	{LPI_ALM_39_INT,OAM_RX_BASE_ADDR,0xf2,15,14},
	{LPI_ALM_40_INT,OAM_RX_BASE_ADDR,0xf2,17,16},
	{LPI_ALM_41_INT,OAM_RX_BASE_ADDR,0xf2,19,18},
	{LPI_ALM_42_INT,OAM_RX_BASE_ADDR,0xf2,21,20},
	{LPI_ALM_43_INT,OAM_RX_BASE_ADDR,0xf2,23,22},
	{LPI_ALM_44_INT,OAM_RX_BASE_ADDR,0xf2,25,24},
	{LPI_ALM_45_INT,OAM_RX_BASE_ADDR,0xf2,27,26},
	{LPI_ALM_46_INT,OAM_RX_BASE_ADDR,0xf2,29,28},
	{LPI_ALM_47_INT,OAM_RX_BASE_ADDR,0xf2,31,30},
};
const CHIP_REG lpi_alm_i2_INT_MASK_REG[]=
{
	{LPI_ALM_32_INT_MASK,OAM_RX_BASE_ADDR,0xf3,1,0},
	{LPI_ALM_33_INT_MASK,OAM_RX_BASE_ADDR,0xf3,3,2},
	{LPI_ALM_34_INT_MASK,OAM_RX_BASE_ADDR,0xf3,5,4},
	{LPI_ALM_35_INT_MASK,OAM_RX_BASE_ADDR,0xf3,7,6},
	{LPI_ALM_36_INT_MASK,OAM_RX_BASE_ADDR,0xf3,9,8},
	{LPI_ALM_37_INT_MASK,OAM_RX_BASE_ADDR,0xf3,11,10},
	{LPI_ALM_38_INT_MASK,OAM_RX_BASE_ADDR,0xf3,13,12},
	{LPI_ALM_39_INT_MASK,OAM_RX_BASE_ADDR,0xf3,15,14},
	{LPI_ALM_40_INT_MASK,OAM_RX_BASE_ADDR,0xf3,17,16},
	{LPI_ALM_41_INT_MASK,OAM_RX_BASE_ADDR,0xf3,19,18},
	{LPI_ALM_42_INT_MASK,OAM_RX_BASE_ADDR,0xf3,21,20},
	{LPI_ALM_43_INT_MASK,OAM_RX_BASE_ADDR,0xf3,23,22},
	{LPI_ALM_44_INT_MASK,OAM_RX_BASE_ADDR,0xf3,25,24},
	{LPI_ALM_45_INT_MASK,OAM_RX_BASE_ADDR,0xf3,27,26},
	{LPI_ALM_46_INT_MASK,OAM_RX_BASE_ADDR,0xf3,29,28},
	{LPI_ALM_47_INT_MASK,OAM_RX_BASE_ADDR,0xf3,31,30},
};
const CHIP_REG lpi_alm_i3_INT_REG[]=
{
	{LPI_ALM_48_INT,OAM_RX_BASE_ADDR,0xf4,1,0},
	{LPI_ALM_49_INT,OAM_RX_BASE_ADDR,0xf4,3,2},
	{LPI_ALM_50_INT,OAM_RX_BASE_ADDR,0xf4,5,4},
	{LPI_ALM_51_INT,OAM_RX_BASE_ADDR,0xf4,7,6},
	{LPI_ALM_52_INT,OAM_RX_BASE_ADDR,0xf4,9,8},
	{LPI_ALM_53_INT,OAM_RX_BASE_ADDR,0xf4,11,10},
	{LPI_ALM_54_INT,OAM_RX_BASE_ADDR,0xf4,13,12},
	{LPI_ALM_55_INT,OAM_RX_BASE_ADDR,0xf4,15,14},
	{LPI_ALM_56_INT,OAM_RX_BASE_ADDR,0xf4,17,16},
	{LPI_ALM_57_INT,OAM_RX_BASE_ADDR,0xf4,19,18},
	{LPI_ALM_58_INT,OAM_RX_BASE_ADDR,0xf4,21,20},
	{LPI_ALM_59_INT,OAM_RX_BASE_ADDR,0xf4,23,22},
	{LPI_ALM_60_INT,OAM_RX_BASE_ADDR,0xf4,25,24},
	{LPI_ALM_61_INT,OAM_RX_BASE_ADDR,0xf4,27,26},
	{LPI_ALM_62_INT,OAM_RX_BASE_ADDR,0xf4,29,28},
	{LPI_ALM_63_INT,OAM_RX_BASE_ADDR,0xf4,31,30},
};
const CHIP_REG lpi_alm_i3_INT_MASK_REG[]=
{
	{LPI_ALM_48_INT_MASK,OAM_RX_BASE_ADDR,0xf5,1,0},
	{LPI_ALM_49_INT_MASK,OAM_RX_BASE_ADDR,0xf5,3,2},
	{LPI_ALM_50_INT_MASK,OAM_RX_BASE_ADDR,0xf5,5,4},
	{LPI_ALM_51_INT_MASK,OAM_RX_BASE_ADDR,0xf5,7,6},
	{LPI_ALM_52_INT_MASK,OAM_RX_BASE_ADDR,0xf5,9,8},
	{LPI_ALM_53_INT_MASK,OAM_RX_BASE_ADDR,0xf5,11,10},
	{LPI_ALM_54_INT_MASK,OAM_RX_BASE_ADDR,0xf5,13,12},
	{LPI_ALM_55_INT_MASK,OAM_RX_BASE_ADDR,0xf5,15,14},
	{LPI_ALM_56_INT_MASK,OAM_RX_BASE_ADDR,0xf5,17,16},
	{LPI_ALM_57_INT_MASK,OAM_RX_BASE_ADDR,0xf5,19,18},
	{LPI_ALM_58_INT_MASK,OAM_RX_BASE_ADDR,0xf5,21,20},
	{LPI_ALM_59_INT_MASK,OAM_RX_BASE_ADDR,0xf5,23,22},
	{LPI_ALM_60_INT_MASK,OAM_RX_BASE_ADDR,0xf5,25,24},
	{LPI_ALM_61_INT_MASK,OAM_RX_BASE_ADDR,0xf5,27,26},
	{LPI_ALM_62_INT_MASK,OAM_RX_BASE_ADDR,0xf5,29,28},
	{LPI_ALM_63_INT_MASK,OAM_RX_BASE_ADDR,0xf5,31,30},
};
const CHIP_REG lpi_alm_i4_INT_REG[]=
{
	{LPI_ALM_64_INT,OAM_RX_BASE_ADDR,0xf6,1,0},
	{LPI_ALM_65_INT,OAM_RX_BASE_ADDR,0xf6,3,2},
	{LPI_ALM_66_INT,OAM_RX_BASE_ADDR,0xf6,5,4},
	{LPI_ALM_67_INT,OAM_RX_BASE_ADDR,0xf6,7,6},
	{LPI_ALM_68_INT,OAM_RX_BASE_ADDR,0xf6,9,8},
	{LPI_ALM_69_INT,OAM_RX_BASE_ADDR,0xf6,11,10},
	{LPI_ALM_70_INT,OAM_RX_BASE_ADDR,0xf6,13,12},
	{LPI_ALM_71_INT,OAM_RX_BASE_ADDR,0xf6,15,14},
	{LPI_ALM_72_INT,OAM_RX_BASE_ADDR,0xf6,17,16},
	{LPI_ALM_73_INT,OAM_RX_BASE_ADDR,0xf6,19,18},
	{LPI_ALM_74_INT,OAM_RX_BASE_ADDR,0xf6,21,20},
	{LPI_ALM_75_INT,OAM_RX_BASE_ADDR,0xf6,23,22},
	{LPI_ALM_76_INT,OAM_RX_BASE_ADDR,0xf6,25,24},
	{LPI_ALM_77_INT,OAM_RX_BASE_ADDR,0xf6,27,26},
	{LPI_ALM_78_INT,OAM_RX_BASE_ADDR,0xf6,29,28},
	{LPI_ALM_79_INT,OAM_RX_BASE_ADDR,0xf6,31,30},
};
const CHIP_REG lpi_alm_i4_INT_MASK_REG[]=
{
	{LPI_ALM_64_INT_MASK,OAM_RX_BASE_ADDR,0xf7,1,0},
	{LPI_ALM_65_INT_MASK,OAM_RX_BASE_ADDR,0xf7,3,2},
	{LPI_ALM_66_INT_MASK,OAM_RX_BASE_ADDR,0xf7,5,4},
	{LPI_ALM_67_INT_MASK,OAM_RX_BASE_ADDR,0xf7,7,6},
	{LPI_ALM_68_INT_MASK,OAM_RX_BASE_ADDR,0xf7,9,8},
	{LPI_ALM_69_INT_MASK,OAM_RX_BASE_ADDR,0xf7,11,10},
	{LPI_ALM_70_INT_MASK,OAM_RX_BASE_ADDR,0xf7,13,12},
	{LPI_ALM_71_INT_MASK,OAM_RX_BASE_ADDR,0xf7,15,14},
	{LPI_ALM_72_INT_MASK,OAM_RX_BASE_ADDR,0xf7,17,16},
	{LPI_ALM_73_INT_MASK,OAM_RX_BASE_ADDR,0xf7,19,18},
	{LPI_ALM_74_INT_MASK,OAM_RX_BASE_ADDR,0xf7,21,20},
	{LPI_ALM_75_INT_MASK,OAM_RX_BASE_ADDR,0xf7,23,22},
	{LPI_ALM_76_INT_MASK,OAM_RX_BASE_ADDR,0xf7,25,24},
	{LPI_ALM_77_INT_MASK,OAM_RX_BASE_ADDR,0xf7,27,26},
	{LPI_ALM_78_INT_MASK,OAM_RX_BASE_ADDR,0xf7,29,28},
	{LPI_ALM_79_INT_MASK,OAM_RX_BASE_ADDR,0xf7,31,30},
};
const CHIP_REG bas_period_alm_i0_INT_REG[]=
{
	{BAS_PERIOD_ALM0_INT,OAM_RX_BASE_ADDR,0xfa,1,0},
	{BAS_PERIOD_ALM1_INT,OAM_RX_BASE_ADDR,0xfa,3,2},
	{BAS_PERIOD_ALM2_INT,OAM_RX_BASE_ADDR,0xfa,5,4},
	{BAS_PERIOD_ALM3_INT,OAM_RX_BASE_ADDR,0xfa,7,6},
	{BAS_PERIOD_ALM4_INT,OAM_RX_BASE_ADDR,0xfa,9,8},
	{BAS_PERIOD_ALM5_INT,OAM_RX_BASE_ADDR,0xfa,11,10},
	{BAS_PERIOD_ALM6_INT,OAM_RX_BASE_ADDR,0xfa,13,12},
	{BAS_PERIOD_ALM7_INT,OAM_RX_BASE_ADDR,0xfa,15,14},
	{BAS_PERIOD_ALM8_INT,OAM_RX_BASE_ADDR,0xfa,17,16},
	{BAS_PERIOD_ALM9_INT,OAM_RX_BASE_ADDR,0xfa,19,18},
	{BAS_PERIOD_ALM10_INT,OAM_RX_BASE_ADDR,0xfa,21,20},
	{BAS_PERIOD_ALM11_INT,OAM_RX_BASE_ADDR,0xfa,23,22},
	{BAS_PERIOD_ALM12_INT,OAM_RX_BASE_ADDR,0xfa,25,24},
	{BAS_PERIOD_ALM13_INT,OAM_RX_BASE_ADDR,0xfa,27,26},
	{BAS_PERIOD_ALM14_INT,OAM_RX_BASE_ADDR,0xfa,29,28},
	{BAS_PERIOD_ALM15_INT,OAM_RX_BASE_ADDR,0xfa,31,30},
};
const CHIP_REG bas_period_alm_i0_INT_MASK_REG[]=
{
	{BAS_PERIOD_ALM0_INT_MASK,OAM_RX_BASE_ADDR,0xfb,1,0},
	{BAS_PERIOD_ALM1_INT_MASK,OAM_RX_BASE_ADDR,0xfb,3,2},
	{BAS_PERIOD_ALM2_INT_MASK,OAM_RX_BASE_ADDR,0xfb,5,4},
	{BAS_PERIOD_ALM3_INT_MASK,OAM_RX_BASE_ADDR,0xfb,7,6},
	{BAS_PERIOD_ALM4_INT_MASK,OAM_RX_BASE_ADDR,0xfb,9,8},
	{BAS_PERIOD_ALM5_INT_MASK,OAM_RX_BASE_ADDR,0xfb,11,10},
	{BAS_PERIOD_ALM6_INT_MASK,OAM_RX_BASE_ADDR,0xfb,13,12},
	{BAS_PERIOD_ALM7_INT_MASK,OAM_RX_BASE_ADDR,0xfb,15,14},
	{BAS_PERIOD_ALM8_INT_MASK,OAM_RX_BASE_ADDR,0xfb,17,16},
	{BAS_PERIOD_ALM9_INT_MASK,OAM_RX_BASE_ADDR,0xfb,19,18},
	{BAS_PERIOD_ALM10_INT_MASK,OAM_RX_BASE_ADDR,0xfb,21,20},
	{BAS_PERIOD_ALM11_INT_MASK,OAM_RX_BASE_ADDR,0xfb,23,22},
	{BAS_PERIOD_ALM12_INT_MASK,OAM_RX_BASE_ADDR,0xfb,25,24},
	{BAS_PERIOD_ALM13_INT_MASK,OAM_RX_BASE_ADDR,0xfb,27,26},
	{BAS_PERIOD_ALM14_INT_MASK,OAM_RX_BASE_ADDR,0xfb,29,28},
	{BAS_PERIOD_ALM15_INT_MASK,OAM_RX_BASE_ADDR,0xfb,31,30},
};
const CHIP_REG bas_period_alm_i1_INT_REG[]=
{
	{BAS_PERIOD_ALM16_INT,OAM_RX_BASE_ADDR,0xfc,1,0},
	{BAS_PERIOD_ALM17_INT,OAM_RX_BASE_ADDR,0xfc,3,2},
	{BAS_PERIOD_ALM18_INT,OAM_RX_BASE_ADDR,0xfc,5,4},
	{BAS_PERIOD_ALM19_INT,OAM_RX_BASE_ADDR,0xfc,7,6},
	{BAS_PERIOD_ALM20_INT,OAM_RX_BASE_ADDR,0xfc,9,8},
	{BAS_PERIOD_ALM21_INT,OAM_RX_BASE_ADDR,0xfc,11,10},
	{BAS_PERIOD_ALM22_INT,OAM_RX_BASE_ADDR,0xfc,13,12},
	{BAS_PERIOD_ALM23_INT,OAM_RX_BASE_ADDR,0xfc,15,14},
	{BAS_PERIOD_ALM24_INT,OAM_RX_BASE_ADDR,0xfc,17,16},
	{BAS_PERIOD_ALM25_INT,OAM_RX_BASE_ADDR,0xfc,19,18},
	{BAS_PERIOD_ALM26_INT,OAM_RX_BASE_ADDR,0xfc,21,20},
	{BAS_PERIOD_ALM27_INT,OAM_RX_BASE_ADDR,0xfc,23,22},
	{BAS_PERIOD_ALM28_INT,OAM_RX_BASE_ADDR,0xfc,25,24},
	{BAS_PERIOD_ALM29_INT,OAM_RX_BASE_ADDR,0xfc,27,26},
	{BAS_PERIOD_ALM30_INT,OAM_RX_BASE_ADDR,0xfc,29,28},
	{BAS_PERIOD_ALM31_INT,OAM_RX_BASE_ADDR,0xfc,31,30},
};
const CHIP_REG bas_period_alm_i1_INT_MASK_REG[]=
{
	{BAS_PERIOD_ALM16_INT_MASK,OAM_RX_BASE_ADDR,0xfd,1,0},
	{BAS_PERIOD_ALM17_INT_MASK,OAM_RX_BASE_ADDR,0xfd,3,2},
	{BAS_PERIOD_ALM18_INT_MASK,OAM_RX_BASE_ADDR,0xfd,5,4},
	{BAS_PERIOD_ALM19_INT_MASK,OAM_RX_BASE_ADDR,0xfd,7,6},
	{BAS_PERIOD_ALM20_INT_MASK,OAM_RX_BASE_ADDR,0xfd,9,8},
	{BAS_PERIOD_ALM21_INT_MASK,OAM_RX_BASE_ADDR,0xfd,11,10},
	{BAS_PERIOD_ALM22_INT_MASK,OAM_RX_BASE_ADDR,0xfd,13,12},
	{BAS_PERIOD_ALM23_INT_MASK,OAM_RX_BASE_ADDR,0xfd,15,14},
	{BAS_PERIOD_ALM24_INT_MASK,OAM_RX_BASE_ADDR,0xfd,17,16},
	{BAS_PERIOD_ALM25_INT_MASK,OAM_RX_BASE_ADDR,0xfd,19,18},
	{BAS_PERIOD_ALM26_INT_MASK,OAM_RX_BASE_ADDR,0xfd,21,20},
	{BAS_PERIOD_ALM27_INT_MASK,OAM_RX_BASE_ADDR,0xfd,23,22},
	{BAS_PERIOD_ALM28_INT_MASK,OAM_RX_BASE_ADDR,0xfd,25,24},
	{BAS_PERIOD_ALM29_INT_MASK,OAM_RX_BASE_ADDR,0xfd,27,26},
	{BAS_PERIOD_ALM30_INT_MASK,OAM_RX_BASE_ADDR,0xfd,29,28},
	{BAS_PERIOD_ALM31_INT_MASK,OAM_RX_BASE_ADDR,0xfd,31,30},
};
const CHIP_REG bas_period_alm_i2_INT_REG[]=
{
	{BAS_PERIOD_ALM32_INT,OAM_RX_BASE_ADDR,0xfe,1,0},
	{BAS_PERIOD_ALM33_INT,OAM_RX_BASE_ADDR,0xfe,3,2},
	{BAS_PERIOD_ALM34_INT,OAM_RX_BASE_ADDR,0xfe,5,4},
	{BAS_PERIOD_ALM35_INT,OAM_RX_BASE_ADDR,0xfe,7,6},
	{BAS_PERIOD_ALM36_INT,OAM_RX_BASE_ADDR,0xfe,9,8},
	{BAS_PERIOD_ALM37_INT,OAM_RX_BASE_ADDR,0xfe,11,10},
	{BAS_PERIOD_ALM38_INT,OAM_RX_BASE_ADDR,0xfe,13,12},
	{BAS_PERIOD_ALM39_INT,OAM_RX_BASE_ADDR,0xfe,15,14},
	{BAS_PERIOD_ALM40_INT,OAM_RX_BASE_ADDR,0xfe,17,16},
	{BAS_PERIOD_ALM41_INT,OAM_RX_BASE_ADDR,0xfe,19,18},
	{BAS_PERIOD_ALM42_INT,OAM_RX_BASE_ADDR,0xfe,21,20},
	{BAS_PERIOD_ALM43_INT,OAM_RX_BASE_ADDR,0xfe,23,22},
	{BAS_PERIOD_ALM44_INT,OAM_RX_BASE_ADDR,0xfe,25,24},
	{BAS_PERIOD_ALM45_INT,OAM_RX_BASE_ADDR,0xfe,27,26},
	{BAS_PERIOD_ALM46_INT,OAM_RX_BASE_ADDR,0xfe,29,28},
	{BAS_PERIOD_ALM47_INT,OAM_RX_BASE_ADDR,0xfe,31,30},
};
const CHIP_REG bas_period_alm_i2_INT_MASK_REG[]=
{
	{BAS_PERIOD_ALM32_INT_MASK,OAM_RX_BASE_ADDR,0xff,1,0},
	{BAS_PERIOD_ALM33_INT_MASK,OAM_RX_BASE_ADDR,0xff,3,2},
	{BAS_PERIOD_ALM34_INT_MASK,OAM_RX_BASE_ADDR,0xff,5,4},
	{BAS_PERIOD_ALM35_INT_MASK,OAM_RX_BASE_ADDR,0xff,7,6},
	{BAS_PERIOD_ALM36_INT_MASK,OAM_RX_BASE_ADDR,0xff,9,8},
	{BAS_PERIOD_ALM37_INT_MASK,OAM_RX_BASE_ADDR,0xff,11,10},
	{BAS_PERIOD_ALM38_INT_MASK,OAM_RX_BASE_ADDR,0xff,13,12},
	{BAS_PERIOD_ALM39_INT_MASK,OAM_RX_BASE_ADDR,0xff,15,14},
	{BAS_PERIOD_ALM40_INT_MASK,OAM_RX_BASE_ADDR,0xff,17,16},
	{BAS_PERIOD_ALM41_INT_MASK,OAM_RX_BASE_ADDR,0xff,19,18},
	{BAS_PERIOD_ALM42_INT_MASK,OAM_RX_BASE_ADDR,0xff,21,20},
	{BAS_PERIOD_ALM43_INT_MASK,OAM_RX_BASE_ADDR,0xff,23,22},
	{BAS_PERIOD_ALM44_INT_MASK,OAM_RX_BASE_ADDR,0xff,25,24},
	{BAS_PERIOD_ALM45_INT_MASK,OAM_RX_BASE_ADDR,0xff,27,26},
	{BAS_PERIOD_ALM46_INT_MASK,OAM_RX_BASE_ADDR,0xff,29,28},
	{BAS_PERIOD_ALM47_INT_MASK,OAM_RX_BASE_ADDR,0xff,31,30},
};
const CHIP_RAM rx_biperr_ram = 
{
	TABLE_BASE_ADDR,OAM_RX_BASE_ADDR+0xa,24,
};
const CHIP_RAM rx_beierr_ram = 
{
	TABLE_BASE_ADDR,OAM_RX_BASE_ADDR+0xb,24,
};
const CHIP_RAM rx_sdcfg = 
{
	TABLE_BASE_ADDR,OAM_RX_BASE_ADDR+0xc,60,
};
const CHIP_RAM chid_ram = 
{
	TABLE_BASE_ADDR,OAM_RX_BASE_ADDR+0xd,7,
};
const CHIP_RAM rx_sfcfg = 
{
	TABLE_BASE_ADDR,OAM_RX_BASE_ADDR+0xe,60,
};
const CHIP_RAM oam_cnt = 
{
	TABLE_BASE_ADDR,OAM_RX_BASE_ADDR+0x23,64,
};
const CHIP_RAM rx_sdbeicfg = 
{
	TABLE_BASE_ADDR,OAM_RX_BASE_ADDR+0x5a,60,
};
const CHIP_RAM rx_sfbeicfg = 
{
	TABLE_BASE_ADDR,OAM_RX_BASE_ADDR+0x64,60,
};
const CHIP_RAM reixc_cfg = 
{
	TABLE_BASE_ADDR,OAM_RX_BASE_ADDR+0x65,7,
};
const CHIP_RAM base_oam = 
{
	TABLE_BASE_ADDR,OAM_RX_BASE_ADDR+0x71,64,
};
const CHIP_RAM base_oam_cnt = 
{
	TABLE_BASE_ADDR,OAM_RX_BASE_ADDR+0x76,64,
};

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_glb_biperr_bit_cfg_set
*
* DESCRIPTION
*
*     Oam rx glb biperr bit cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 1-bip count by bit, 0-bip count by blk
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_glb_biperr_bit_cfg_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }
   
    rv = regp_bit_write(chip_id,oam_rx_cfg_reg[RX_GLB_BIPERR_BIT_CFG].base_addr,oam_rx_cfg_reg[RX_GLB_BIPERR_BIT_CFG].offset_addr,
        oam_rx_cfg_reg[RX_GLB_BIPERR_BIT_CFG].end_bit,oam_rx_cfg_reg[RX_GLB_BIPERR_BIT_CFG].start_bit,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_glb_biperr_bit_cfg_get
*
* DESCRIPTION
*
*     Oam rx glb biperr bit cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cfg, 1-bip count by bit, 0-bip count by blk
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_glb_biperr_bit_cfg_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,oam_rx_cfg_reg[RX_GLB_BIPERR_BIT_CFG].base_addr,oam_rx_cfg_reg[RX_GLB_BIPERR_BIT_CFG].offset_addr,
        oam_rx_cfg_reg[RX_GLB_BIPERR_BIT_CFG].end_bit,oam_rx_cfg_reg[RX_GLB_BIPERR_BIT_CFG].start_bit,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_glb_beierr_bit_cfg_set
*
* DESCRIPTION
*
*     Oam rx glb beierr bit cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 1-bei count by bit, 0-bei count by blk
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_glb_beierr_bit_cfg_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (RX_GLB_BEIERR_BIT_CFG > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,oam_rx_cfg_reg[RX_GLB_BEIERR_BIT_CFG].base_addr,oam_rx_cfg_reg[RX_GLB_BEIERR_BIT_CFG].offset_addr,
        oam_rx_cfg_reg[RX_GLB_BEIERR_BIT_CFG].end_bit,oam_rx_cfg_reg[RX_GLB_BEIERR_BIT_CFG].start_bit,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_glb_beierr_bit_cfg_get
*
* DESCRIPTION
*
*     Oam rx glb beierr bit cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cfg, 1-bei count by bit, 0-bei count by blk
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_glb_beierr_bit_cfg_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (RX_GLB_BEIERR_BIT_CFG > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,oam_rx_cfg_reg[RX_GLB_BEIERR_BIT_CFG].base_addr,oam_rx_cfg_reg[RX_GLB_BEIERR_BIT_CFG].offset_addr,
        oam_rx_cfg_reg[RX_GLB_BEIERR_BIT_CFG].end_bit,oam_rx_cfg_reg[RX_GLB_BEIERR_BIT_CFG].start_bit,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_crc_invert_set
*
* DESCRIPTION
*
*     Oam rx crc invert cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 1-invert, 0-don't invert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_crc_invert_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (CRC_INVERT > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,oam_rx_cfg_reg[CRC_INVERT],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_crc_invert_get
*
* DESCRIPTION
*
*     Oam rx crc invert cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cfg, 1-invert, 0-don't invert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_crc_invert_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (CRC_INVERT > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_cfg_reg[CRC_INVERT],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_idle_rpl_en_set
*
* DESCRIPTION
*
*     Oam rx idle rpl enable cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_idle_rpl_en_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rx_idle_rpl_en_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,rx_idle_rpl_en_reg[ch_id/32].base_addr,rx_idle_rpl_en_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_idle_rpl_en_get
*
* DESCRIPTION
*
*     Oam rx idle rpl enable cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cfg, 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_idle_rpl_en_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rx_idle_rpl_en_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,rx_idle_rpl_en_reg[ch_id/32].base_addr,rx_idle_rpl_en_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_oam_bip_cla_en_set
*
* DESCRIPTION
*
*     Oam rx bip cla en cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  type:0~63(1-bas 17-cv)
**    parameter: 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_oam_bip_cla_en_set(UINT_8 chip_id,UINT_8 type,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
		(type > 59)||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n type = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   type,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	if(type < 32)
	{
		rv = regp_bit_write(chip_id,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_0].base_addr,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_0].offset_addr,
			type,type,parameter);
	}
	else if(type < 48)
	{
		rv = regp_bit_write(chip_id,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_1].base_addr,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_1].offset_addr,
			type-16,type-16,parameter);
	}
	else
	{
		rv = regp_bit_write(chip_id,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_2].base_addr,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_2].offset_addr,
			type-32,type-32,parameter);
	}

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_oam_bip_cla_en_get
*
* DESCRIPTION
*
*     Oam rx bip cla en cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  type:0~63(1-bas 17-cv)
**   *parameter: pointer to cfg, 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_oam_bip_cla_en_get(UINT_8 chip_id,UINT_8 type,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
		(type > 63))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
		   		   \r\n chip_id = %d, \
                   \r\n type = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   type
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	if(type < 32)
	{
		rv = regp_bit_read(chip_id,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_0].base_addr,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_0].offset_addr,
			type,type,parameter);
	}
	else if(type < 48)
	{
		rv = regp_bit_read(chip_id,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_1].base_addr,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_1].offset_addr,
			type-16,type-16,parameter);
	}
	else
	{
		rv = regp_bit_read(chip_id,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_2].base_addr,oam_type_bip_cal_en_reg[OAM_TYPE_BIP_CAL_EN_2].offset_addr,
			type-32,type-32,parameter);
	}
	
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_cfg_set
*
* DESCRIPTION
*
*     Oam rx bypass cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 1-bypass, 0-normal
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_cfg_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (BYPASS_OAM_RX > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,oam_rx_cfg_reg[BYPASS_OAM_RX],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_cfg_get
*
* DESCRIPTION
*
*     Oam rx bypass cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cfg, 1-bypass, 0-normal
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_cfg_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (BYPASS_OAM_RX > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_cfg_reg[BYPASS_OAM_RX],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_rx_rdi_sel_set
*
* DESCRIPTION
*
*    
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     parameter: set value 0:ch0-19 1:ch20-39 2:ch40-59 3:60-79
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rdi_sel_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (OAM_RX_RDI_BLK > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,oam_rx_cfg_reg[OAM_RX_RDI_BLK],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_rx_rdi_sel_get
*
* DESCRIPTION
*
*    
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     parameter: get value 0:ch0-19 1:ch20-39 2:ch40-59 3:60-79
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rdi_sel_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (OAM_RX_RDI_BLK > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_cfg_reg[OAM_RX_RDI_BLK],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_oam_idfy_37_34_cfg_set
*
* DESCRIPTION
*
*     Oam rx oam idfy 37-34bit cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 37-34bit cfg, default 0xc
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_oam_idfy_37_34_cfg_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0xf))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (OAM_IDFY_37_34_CFG > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,oam_rx_cfg_reg[OAM_IDFY_37_34_CFG],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_oam_idfy_37_34_cfg_get
*
* DESCRIPTION
*
*     Oam rx oam idfy 37-34bit cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to 37-34bit cfg, default 0xc
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_oam_idfy_37_34_cfg_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (OAM_IDFY_37_34_CFG > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_cfg_reg[OAM_IDFY_37_34_CFG],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_pos_cnt_set
*
* DESCRIPTION
*
*     oam_rx_bas_pos_cnt_set
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_pos_cnt_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (BAS_POS_CNT > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,oam_rx_cfg_reg[BAS_POS_CNT],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_pos_cnt_get
*
* DESCRIPTION
*
*     oam_rx_bas_pos_cnt_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: 
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_pos_cnt_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (BAS_POS_CNT > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_cfg_reg[BAS_POS_CNT],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bypass_chnl_set
*
* DESCRIPTION
*
*     Oam rx bypass channel cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: 1-bypass, 0-normal
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bypass_chnl_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bypass_chnl_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,bypass_chnl_reg[ch_id/32].base_addr,bypass_chnl_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bypass_chnl_get
*
* DESCRIPTION
*
*     Oam rx bypass channel cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: 1-bypass, 0-normal
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bypass_chnl_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bypass_chnl_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,bypass_chnl_reg[ch_id/32].base_addr,bypass_chnl_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_period_cfg_set
*
* DESCRIPTION
*
*     Oam rx period cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: 0-16k, 1-64k, 2-256k, 3-512k
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_period_cfg_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/16) > MAX_INDEX(period_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,period_cfg_reg[ch_id/16].base_addr,period_cfg_reg[ch_id/16].offset_addr,
        (ch_id*2+1)%32,(ch_id*2)%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_period_cfg_get
*
* DESCRIPTION
*
*     Oam rx period cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cfg, 0-16k, 1-64k, 2-256k, 3-512k
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_period_cfg_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/16) > MAX_INDEX(period_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,period_cfg_reg[ch_id/16].base_addr,period_cfg_reg[ch_id/16].offset_addr,
        (ch_id*2+1)%32,(ch_id*2)%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_period_sel_set
*
* DESCRIPTION
*
*     Oam rx period sel cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: 0-1, 1-2, 2-3, 3-4 
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_period_sel_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/16) > MAX_INDEX(period_sel_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,period_sel_reg[ch_id/16].base_addr,period_sel_reg[ch_id/16].offset_addr,
        (ch_id*2+1)%32,(ch_id*2)%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_period_sel_get
*
* DESCRIPTION
*
*     Oam rx period sel cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cfg,0-1, 1-2, 2-3, 3-4 
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_period_sel_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/16) > MAX_INDEX(period_sel_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,period_sel_reg[ch_id/16].base_addr,period_sel_reg[ch_id/16].offset_addr,
        (ch_id*2+1)%32,(ch_id*2)%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_oam_cnt_clr_num_set
*
* DESCRIPTION
*
*     Oam rx oam cnt clr num cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: cfg value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_oam_cnt_clr_num_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x7f))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (OAM_CNT_CLR_NUM > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,oam_rx_cfg_reg[OAM_CNT_CLR_NUM],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_oam_cnt_clr_num_get
*
* DESCRIPTION
*
*     Oam rx oam cnt clr num cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cfg value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_oam_cnt_clr_num_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (OAM_CNT_CLR_NUM > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_cfg_reg[OAM_CNT_CLR_NUM],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_period_ab_set
*
* DESCRIPTION
*
*     Oam rx bas_period_a/b cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id:0~3 period_sel 0~3
**    parameter: cfg value 0~3ff
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_period_ab_set(UINT_8 chip_id,UINT_8 field_id, UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
		(field_id > 3) ||
        (parameter > 0x3ff))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n field_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   field_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	if(field_id < 2)
	{
		rv = regp_field_write(chip_id,bas_period_a_REG[field_id],parameter);
	}
    else
    {
		rv = regp_field_write(chip_id,bas_period_b_REG[field_id - 2],parameter);
	}
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_period_ab_get
*
* DESCRIPTION
*
*     Oam rx bas_period_a/b cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id:0~3 period_sel 0~3
**   *parameter: pointer to cfg value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_period_ab_get(UINT_8 chip_id,UINT_8 field_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
		(field_id > 3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d,  \
                   \r\n field_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   field_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	if(field_id < 2)
	{
		rv = regp_field_read(chip_id,bas_period_a_REG[field_id],parameter);
	}
	else
	{
		rv = regp_field_read(chip_id,bas_period_b_REG[field_id - 2],parameter);
	}
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bypass_oam_alm_ch_set
*
* DESCRIPTION
*
*     Oam rx bypass_oam_alm_ch cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter:0~1 0:no bypass 1:bypass
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bypass_oam_alm_ch_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bypass_oam_alm_ch_REG))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,bypass_oam_alm_ch_REG[ch_id/32].base_addr,bypass_oam_alm_ch_REG[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bypass_oam_alm_ch_get
*
* DESCRIPTION
*
*     Oam rx bypass_oam_alm_ch cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cfg, 0~1 0:no bypass 1:bypass
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bypass_oam_alm_ch_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bypass_oam_alm_ch_REG))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,bypass_oam_alm_ch_REG[ch_id/32].base_addr,bypass_oam_alm_ch_REG[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_config_set
*
* DESCRIPTION
*
*     oam_rx_config_set
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id: 0:BAS_RAM_CLR_CH  1:TIMESTAMP_SEL 2:OAM_RX_LPI_PRE_CNT 3:OAM_RX_LPI_POS_CNT
*				4:BASE_LOS_RPL_EN 5:BIP_RECAL_EN 6:BASE_BIP_CRC_EN
**    parameter:set value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_config_set(UINT_8 chip_id,UINT_8 field_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (parameter > 0x7f))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (field_id > MAX_INDEX(oam_rx_config_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id, oam_rx_config_reg[field_id], parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_config_get
*
* DESCRIPTION
*
*     oam_rx_config_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id: 0:BAS_RAM_CLR_CH  1:TIMESTAMP_SEL 2:OAM_RX_LPI_PRE_CNT 3:OAM_RX_LPI_POS_CNT
*				4:BASE_LOS_RPL_EN 5:BIP_RECAL_EN 6:BASE_BIP_CRC_EN
**    parameter:set value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_config_get(UINT_8 chip_id,UINT_8 field_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (field_id > MAX_INDEX(oam_rx_config_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id, oam_rx_config_reg[field_id], parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_lf_manual_insert_set
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter:0~1 0:no replace 1:replace
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-9-12    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_lf_manual_insert_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(lf_manual_insert_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,lf_manual_insert_reg[ch_id/32].base_addr,lf_manual_insert_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_lf_manual_insert_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter:0~1 0:no replace 1:replace
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-9-12    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_lf_manual_insert_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(lf_manual_insert_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,lf_manual_insert_reg[ch_id/32].base_addr,lf_manual_insert_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rf_manual_insert_set
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter:0~1 0:no replace 1:replace
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-9-12    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rf_manual_insert_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rf_manual_insert_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,rf_manual_insert_reg[ch_id/32].base_addr,rf_manual_insert_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rf_manual_insert_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter:0~1 0:no replace 1:replace
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-9-12    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rf_manual_insert_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rf_manual_insert_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,rf_manual_insert_reg[ch_id/32].base_addr,rf_manual_insert_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_lpi_manual_insert_set
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter:0~1 0:no replace 1:replace
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-9-12    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_lpi_manual_insert_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(lpi_manual_insert_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,lpi_manual_insert_reg[ch_id/32].base_addr,lpi_manual_insert_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_lpi_manual_insert_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter:0~1 0:no replace 1:replace
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-9-12    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_lpi_manual_insert_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(lpi_manual_insert_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,lpi_manual_insert_reg[ch_id/32].base_addr,lpi_manual_insert_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bypass_oam_alm_all_set
*
* DESCRIPTION
*
*     Oam rx bypass_oam_alm_all cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter:0~1 0:no bypass 1:bypass
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bypass_oam_alm_all_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (BYPASS_OAM_ALM_ALL > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,oam_rx_cfg_reg[BYPASS_OAM_ALM_ALL],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bypass_oam_alm_all_get
*
* DESCRIPTION
*
*     Oam rx bypass_oam_alm_all cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cfg, 0~1 0:no bypass 1:bypass
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bypass_oam_alm_all_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (BYPASS_OAM_ALM_ALL > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_cfg_reg[BYPASS_OAM_ALM_ALL],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_los_sel_set
*
* DESCRIPTION
*
*     oam_rx_bas_los_sel_set
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter:
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_los_sel_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (OAM_RX_BASE_LOS_SEL > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,oam_rx_cfg_reg[OAM_RX_BASE_LOS_SEL],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_los_sel_get
*
* DESCRIPTION
*
*     oam_rx_bas_los_sel_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: 
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_los_sel_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (OAM_RX_BASE_LOS_SEL > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_cfg_reg[OAM_RX_BASE_LOS_SEL],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_los_sel_set
*
* DESCRIPTION
*
*     oam_rx_base_oam_cnt_clr_num_set
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter:
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_base_oam_cnt_clr_num_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x7f))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (BASE_OAM_CNT_CLR_NUM > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,oam_rx_cfg_reg[BASE_OAM_CNT_CLR_NUM],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_base_oam_cnt_clr_num_get
*
* DESCRIPTION
*
*     oam_rx_base_oam_cnt_clr_num_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: 
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_base_oam_cnt_clr_num_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (BASE_OAM_CNT_CLR_NUM > MAX_INDEX(oam_rx_cfg_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_cfg_reg[BASE_OAM_CNT_CLR_NUM],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_biperr_cnt_clr_pls_set
*
* DESCRIPTION
*
*     Oam rx biperr cnt clr pls.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_biperr_cnt_clr_pls_set(UINT_8 chip_id,UINT_8 ch_id)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rx_biperr_cnt_clr_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
       
    rv = regp_write(chip_id,rx_biperr_cnt_clr_reg[ch_id/32].base_addr,rx_biperr_cnt_clr_reg[ch_id/32].offset_addr,1<<(ch_id%32));
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_beierr_cnt_clr_pls_set
*
* DESCRIPTION
*
*     Oam rx beierr cnt clr pls.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_beierr_cnt_clr_pls_set(UINT_8 chip_id,UINT_8 ch_id)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rx_beierr_cnt_clr_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_write(chip_id,rx_beierr_cnt_clr_reg[ch_id/32].base_addr,rx_beierr_cnt_clr_reg[ch_id/32].offset_addr,1<<(ch_id%32));
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_clr_ram_init_pls_set
*
* DESCRIPTION
*
*     oam_rx_clr_ram_init_pls_set
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id: 0:OAM_CNT_CLR
*				1:OAM_CNT_ALL_CLR
*				2:TS_RAM_INIT
*				3:BASE_OAM_CNT_CLR
*				4:BASE_OAM_CNT_ALL_CLR
*				5:BASE_OAM_RAM_CLR
*				6:FIFO_CNT_CLR
*
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_clr_ram_init_pls_set(UINT_8 chip_id,UINT_8 field_id)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (field_id > MAX_INDEX(oam_clr_ram_init_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_write(chip_id,oam_clr_ram_init_reg[field_id].base_addr,oam_clr_ram_init_reg[field_id].offset_addr,1<<field_id);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_oam_cnt_clr_done_get
*
* DESCRIPTION
*
*     Oam rx oam cnt clr done.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to status
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_oam_cnt_clr_done_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_cnt_clr_done_reg[OAM_CNT_CLR_DONE],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_base_oam_cnt_clr_done_get
*
* DESCRIPTION
*
*     oam_rx_base_oam_cnt_clr_done_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to status
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_base_oam_cnt_clr_done_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (BASE_OAM_CNT_CLR_DONE > MAX_INDEX(oam_cnt_clr_done_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_cnt_clr_done_reg[BASE_OAM_CNT_CLR_DONE],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_fifo_cnt_max_get
*
* DESCRIPTION
*
*     oam_rx_fifo_cnt_max_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to status
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_fifo_cnt_max_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (FIFO_CNT_MAX > MAX_INDEX(oam_cnt_clr_done_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_cnt_clr_done_reg[FIFO_CNT_MAX],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_period_get
*
* DESCRIPTION
*
*     Oam rx bas period.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to status
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_period_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
   
    rv = regp_bit_read(chip_id,base_period_reg[BASE_PERIOD_0].base_addr,base_period_reg[BASE_PERIOD_0].offset_addr+ch_id/16,
        (ch_id%16)*2+1,(ch_id%16)*2,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sdbip_alm_get
*
* DESCRIPTION
*
*     Oam rx sdbip alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbip_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rx_sdbip_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,rx_sdbip_reg[ch_id/32].base_addr,rx_sdbip_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sfbip_alm_get
*
* DESCRIPTION
*
*    oam_rx_sfbip_alm_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sfbip_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rx_sfbip_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,rx_sfbip_reg[ch_id/32].base_addr,rx_sfbip_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sfbei_alm_get
*
* DESCRIPTION
*
*    oam_rx_sfbei_alm_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sfbei_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rx_sfbei_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,rx_sfbei_reg[ch_id/32].base_addr,rx_sfbei_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rdi_alm_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rdi_alm_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_rdi_reg[OAM_RX_RDI],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_demux_client_alm_get
*
* DESCRIPTION
*
*    oam_rx_demux_client_alm_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_demux_client_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(demux_client_alm_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,demux_client_alm_reg[ch_id/32].base_addr,demux_client_alm_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_crc_alm_out_get
*
* DESCRIPTION
*
*     Oam rx crc alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_crc_alm_out_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(crc_alm_out_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,crc_alm_out_reg[ch_id/32].base_addr,crc_alm_out_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_rdi_alm_get
*
* DESCRIPTION
*
*     Oam rx bas_rdi alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_rdi_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bas_rdi_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,bas_rdi_reg[ch_id/32].base_addr,bas_rdi_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_csf_lpi_alm_get
*
* DESCRIPTION
*
*     Oam rx bas_csf_lpi alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_csf_lpi_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bas_csf_lpi_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,bas_csf_lpi_reg[ch_id/32].base_addr,bas_csf_lpi_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_cs_lf_alm_get
*
* DESCRIPTION
*
*     Oam rx bas_cs_lf alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_cs_lf_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bas_cs_lf_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,bas_cs_lf_reg[ch_id/32].base_addr,bas_cs_lf_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_cs_rf_alm_get
*
* DESCRIPTION
*
*     Oam rx bas_cs_rf alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_cs_rf_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bas_cs_rf_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,bas_cs_rf_reg[ch_id/32].base_addr,bas_cs_rf_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_crc_err_alm_get
*
* DESCRIPTION
*
*     Oam rx bas_crc_err alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_crc_err_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bas_crc_err_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,bas_crc_err_reg[ch_id/32].base_addr,bas_crc_err_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_no_receive_alm_get
*
* DESCRIPTION
*
*     Oam rx bas_no_receive alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_no_receive_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bas_no_receive_alm_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,bas_no_receive_alm_reg[ch_id/32].base_addr,bas_no_receive_alm_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rdi_lf_alm_get
*
* DESCRIPTION
*
*     Oam rx rdi_lf alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rdi_lf_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rdi_lf_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,rdi_lf_reg[ch_id/32].base_addr,rdi_lf_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_fifo_full_alm_get
*
* DESCRIPTION
*
*     Oam rx fifo full alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_fifo_full_alm_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (OAM_RX_FULL_1 > MAX_INDEX(oam_rx_rdi_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_rdi_reg[OAM_RX_FULL_1],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sdbei_alm_get
*
* DESCRIPTION
*
*     Oam rx sdbei alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbei_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rx_sdbei_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,rx_sdbei_reg[ch_id/32].base_addr,rx_sdbei_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rf_alm_get
*
* DESCRIPTION
*
*     Oam rx rf alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rf_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rf_alm_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,rf_alm_reg[ch_id/32].base_addr,rf_alm_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_lpi_alm_get
*
* DESCRIPTION
*
*     Oam rx lpi alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_lpi_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(lpi_alm_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,lpi_alm_reg[ch_id/32].base_addr,lpi_alm_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_ecc_alm_get
*
* DESCRIPTION
*
*     Oam rx ecc alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     field_id: 0~1 0:ECC_ERR_CORRECT  1: ECC_ERR_UNCORRECT
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_ecc_alm_get(UINT_8 chip_id,UINT_8 field_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (field_id > (ECC_ERR_UNCORRECT - ECC_ERR_CORRECT)))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n field_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   field_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((field_id + ECC_ERR_CORRECT) > MAX_INDEX(oam_rx_rdi_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,oam_rx_rdi_reg[field_id + ECC_ERR_CORRECT],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_period_alm_get
*
* DESCRIPTION
*
*     Oam rx bas_period alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id:0~CH_NUM-1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_period_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > (CH_NUM - 1)))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,bas_period_alm_REG[ch_id/32].base_addr,bas_period_alm_REG[ch_id/32].offset_addr,
		ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_biperr_ram_get
*
* DESCRIPTION
*
*     Oam rx biperr ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_biperr_ram_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_read_single(chip_id,rx_biperr_ram,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_beierr_ram_get
*
* DESCRIPTION
*
*     Oam rx beierr ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_beierr_ram_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_read_single(chip_id,rx_beierr_ram,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sdcfg_ram_set
*
* DESCRIPTION
*
*     Oam rx sdcfg ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdcfg_ram_set(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_write_single(chip_id,rx_sdcfg,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sdcfg_ram_get
*
* DESCRIPTION
*
*     Oam rx sdcfg ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdcfg_ram_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_read_single(chip_id,rx_sdcfg,index,parameter);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*	  oam_rx_sd_bip8_clr_thresh_set
*
* DESCRIPTION
*
*	  oam rx sdcfg ram.
*
* NOTE
*
*	  RESERVED
*
* PARAMETERS
*
*	  chip_id: chip number used
*	  index: 0~CH_NUM - 1
**	  parameter*: pointer to value
* RETURNS
*
*	  0: success
*	  1: fail
*
* CALLS
*
*	  RESERVED
*
* CALLED BY
*
*	  RESERVED
*
* VERSION
*
*	<author>	 <data>    <CR_ID>		<DESCRIPTION>
*	 dengjie	2018-1-2	 1.0		   initial
*
******************************************************************************/
RET_STATUS oam_rx_sd_bip8_clr_thresh_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
	RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
	
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1) ||
        (parameter > 0xffff))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

	ram_read_single(chip_id,rx_sdcfg,index,value);
	
	value[0] = (value[0] & 0xffff0000) | (parameter);
	
	rv = ram_write_single(chip_id,rx_sdcfg,index,value);

	return rv;
}

/******************************************************************************
*
* FUNCTION
*
*	  oam_rx_sd_bip8_clr_thresh_get
*
* DESCRIPTION
*
*	  oam rx sdcfg ram.
*
* NOTE
*
*	  RESERVED
*
* PARAMETERS
*
*	  chip_id: chip number used
*	  index: 0~CH_NUM - 1
**	  parameter*: pointer to value
* RETURNS
*
*	  0: success
*	  1: fail
*
* CALLS
*
*	  RESERVED
*
* CALLED BY
*
*	  RESERVED
*
* VERSION
*
*	<author>	 <data>    <CR_ID>		<DESCRIPTION>
*	 dengjie	2018-1-2	 1.0		   initial
*
******************************************************************************/
RET_STATUS oam_rx_sd_bip8_clr_thresh_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
	RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
	
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	ram_read_single(chip_id,rx_sdcfg,index,value);
	
	*parameter = value[0] & 0xffff;

	return rv;
}


/******************************************************************************
*
* FUNCTION
*
*	  oam_rx_sd_bip8_thresh_set
*
* DESCRIPTION
*
*	  oam rx sdcfg ram.
*
* NOTE
*
*	  RESERVED
*
* PARAMETERS
*
*	  chip_id: chip number used
*	  index: 0~CH_NUM - 1
**	  parameter*: pointer to value
* RETURNS
*
*	  0: success
*	  1: fail
*
* CALLS
*
*	  RESERVED
*
* CALLED BY
*
*	  RESERVED
*
* VERSION
*
*	<author>	 <data>    <CR_ID>		<DESCRIPTION>
*	 dengjie	2018-1-2	 1.0		   initial
*
******************************************************************************/
RET_STATUS oam_rx_sd_bip8_set_thresh_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
	RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
	
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1) ||
        (parameter > 0x1ffff))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

	ram_read_single(chip_id,rx_sdcfg,index,value);
	
	value[0] = (value[0] & 0x0000ffff) | ((parameter & 0xffff) << 16);
	value[1] = (value[1] & 0xfffffffe) | ((parameter >> 16) & 1);
	
	rv = ram_write_single(chip_id,rx_sdcfg,index,value);

	return rv;
}

/******************************************************************************
*
* FUNCTION
*
*	  oam_rx_sd_bip8_thresh_get
*
* DESCRIPTION
*
*	  oam rx sdcfg ram.
*
* NOTE
*
*	  RESERVED
*
* PARAMETERS
*
*	  chip_id: chip number used
*	  index: 0~CH_NUM - 1
**	  parameter*: pointer to value
* RETURNS
*
*	  0: success
*	  1: fail
*
* CALLS
*
*	  RESERVED
*
* CALLED BY
*
*	  RESERVED
*
* VERSION
*
*	<author>	 <data>    <CR_ID>		<DESCRIPTION>
*	 dengjie	2018-1-2	 1.0		   initial
*
******************************************************************************/
RET_STATUS oam_rx_sd_bip8_set_thresh_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
	RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
	
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	ram_read_single(chip_id,rx_sdcfg,index,value);
	
	*parameter = ((value[0] & 0xffff0000) >> 16) | ((value[1] & 1) << 16);

	return rv;
}


/******************************************************************************
*
* FUNCTION
*
*	  oam_rx_sd_block_num_set
*
* DESCRIPTION
*
*	  oam rx sdcfg ram.
*
* NOTE
*
*	  RESERVED
*
* PARAMETERS
*
*	  chip_id: chip number used
*	  index: 0~CH_NUM - 1
**	  parameter*: pointer to value
* RETURNS
*
*	  0: success
*	  1: fail
*
* CALLS
*
*	  RESERVED
*
* CALLED BY
*
*	  RESERVED
*
* VERSION
*
*	<author>	 <data>    <CR_ID>		<DESCRIPTION>
*	 dengjie	2018-1-2	 1.0		   initial
*
******************************************************************************/
RET_STATUS oam_rx_sd_block_num_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
	RET_STATUS rv = RET_SUCCESS;
	UINT_32 value[2] = {0};
	
	if ((chip_id > MAX_DEV) ||
		(index > CH_NUM - 1) ||
		(parameter > 0x7ffffff))
	{
		if (oam_rx_para_debug)
		{
			printf("[%s] invalid parameter!! \
					\r\n chip_id = %d, \
					\r\n index = %d \r\n",	  
					__FUNCTION__,
					chip_id,
					index
				  );
		}

		return RET_PARAERR;
	}

	ram_read_single(chip_id,rx_sdcfg,index,value);
	
	value[1] = (value[1] & 0xf0000001) | (parameter << 1);
	
	rv = ram_write_single(chip_id,rx_sdcfg,index,value);

	return rv;

}

/******************************************************************************
*
* FUNCTION
*
*	  oam_rx_sd_block_num_get
*
* DESCRIPTION
*
*	  oam rx sdcfg ram.
*
* NOTE
*
*	  RESERVED
*
* PARAMETERS
*
*	  chip_id: chip number used
*	  index: 0~CH_NUM - 1
**	  parameter*: pointer to value
* RETURNS
*
*	  0: success
*	  1: fail
*
* CALLS
*
*	  RESERVED
*
* CALLED BY
*
*	  RESERVED
*
* VERSION
*
*	<author>	 <data>    <CR_ID>		<DESCRIPTION>
*	 dengjie	2018-1-2	 1.0		   initial
*
******************************************************************************/
RET_STATUS oam_rx_sd_block_num_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
	RET_STATUS rv = RET_SUCCESS;
	UINT_32 value[2] = {0};
	
	if ((chip_id > MAX_DEV) ||
		(index > CH_NUM - 1))
	{
		if (oam_rx_para_debug)
		{
			printf("[%s] invalid parameter!! \
					\r\n chip_id = %d, \
					\r\n index = %d \r\n",	  
					__FUNCTION__,
					chip_id,
					index
				  );
		}

		return RET_PARAERR;
	}

	if (NULL == parameter)
	{
		if (oam_rx_para_debug)
		{
			printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
		}
		return RET_PARAERR;
	}

	ram_read_single(chip_id,rx_sdcfg,index,value);
	
	*parameter = (value[1] & 0x0ffffffe) >> 1;

	return rv;

}

/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sd_bei_set_thresh_set
*
* DESCRIPTION
*
*      oam rx sdbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
UINT_8 oam_rx_sd_bei_set_thresh_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1) ||
        (parameter > 0x1ffff))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sdbeicfg,index,value);
    
    value[0] = (value[0] & 0x0000ffff) | ((parameter & 0xffff) << 16);
    value[1] = (value[1] & 0xfffffffe) | ((parameter >> 16) & MASK_1_BIT);
    
    rv = ram_write_single(chip_id,rx_sdbeicfg,index,value);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sd_bei_set_thresh_get
*
* DESCRIPTION
*
*      oam rx sdbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sd_bei_set_thresh_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sdbeicfg,index,value);
    
    *parameter = ((value[0] & 0xffff0000) >> 16) | ((value[1] & 1) << 16);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sd_bei_clr_thresh_set
*
* DESCRIPTION
*
*      oam rx sdbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
UINT_8 oam_rx_sd_bei_clr_thresh_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1) ||
        (parameter > 0xffff))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",      
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfbeicfg,index,value);
    
    value[0] = (value[0] & 0xffff0000) | (parameter);
    
    rv = ram_write_single(chip_id,rx_sdbeicfg,index,value);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sd_bei_clr_thresh_get
*
* DESCRIPTION
*
*      oam rx sdbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sd_bei_clr_thresh_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sdbeicfg,index,value);
    
    *parameter = value[0] & 0xffff;

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sd_bei_block_num_set
*
* DESCRIPTION
*
*      oam rx sdbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
UINT_8 oam_rx_sd_bei_block_num_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1) ||
        (parameter > 0x7ffffff))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",      
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sdbeicfg,index,value);
    
    value[1] = (value[1] & 0xf0000001) | (parameter << 1);
    
    rv = ram_write_single(chip_id,rx_sdbeicfg,index,value);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sd_bei_block_num_get
*
* DESCRIPTION
*
*      oam rx sdbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sd_bei_block_num_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",      
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sdbeicfg,index,value);
    
    *parameter = (value[1] & 0x0ffffffe) >> 1;

    return rv;

}

/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bip8_set_thresh_set
*
* DESCRIPTION
*
*      oam rx sfcfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
UINT_8 oam_rx_sf_bip8_set_thresh_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1) ||
        (parameter > 0x1ffff))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfcfg,index,value);
    
    value[0] = (value[0] & 0x0000ffff) | ((parameter & 0xffff) << 16);
    value[1] = (value[1] & 0xfffffffe) | ((parameter >> 16) & MASK_1_BIT);
    
    rv = ram_write_single(chip_id,rx_sfcfg,index,value);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bip8_set_thresh_get
*
* DESCRIPTION
*
*      oam rx sfcfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sf_bip8_set_thresh_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfcfg,index,value);
    
    *parameter = ((value[0] & 0xffff0000) >> 16) | ((value[1] & 1) << 16);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bip8_clr_thresh_set
*
* DESCRIPTION
*
*      oam rx sfcfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
UINT_8 oam_rx_sf_bip8_clr_thresh_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1) ||
        (parameter > 0xffff))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",      
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfcfg,index,value);
    
    value[0] = (value[0] & 0xffff0000) | (parameter);
    
    rv = ram_write_single(chip_id,rx_sfcfg,index,value);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bip8_clr_thresh_get
*
* DESCRIPTION
*
*      oam rx sfcfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sf_bip8_clr_thresh_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfcfg,index,value);
    
    *parameter = value[0] & 0xffff;

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bip8_block_num_set
*
* DESCRIPTION
*
*      oam rx sfcfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
UINT_8 oam_rx_sf_bip8_block_num_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1) ||
        (parameter > 0x7ffffff))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",      
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfcfg,index,value);
    
    value[1] = (value[1] & 0xf0000001) | (parameter << 1);
    
    rv = ram_write_single(chip_id,rx_sfcfg,index,value);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bip8_block_num_get
*
* DESCRIPTION
*
*      oam rx sfcfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sf_bip8_block_num_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",      
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfcfg,index,value);
    
    *parameter = (value[1] & 0x0ffffffe) >> 1;

    return rv;

}

/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bei_set_thresh_set
*
* DESCRIPTION
*
*      oam rx sfbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
UINT_8 oam_rx_sf_bei_set_thresh_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1) ||
        (parameter > 0x1ffff))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfbeicfg,index,value);
    
    value[0] = (value[0] & 0x0000ffff) | ((parameter & 0xffff) << 16);
    value[1] = (value[1] & 0xfffffffe) | ((parameter >> 16) & MASK_1_BIT);
    
    rv = ram_write_single(chip_id,rx_sfbeicfg,index,value);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bei_set_thresh_get
*
* DESCRIPTION
*
*      oam rx sfbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sf_bei_set_thresh_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfbeicfg,index,value);
    
    *parameter = ((value[0] & 0xffff0000) >> 16) | ((value[1] & 1) << 16);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bei_clr_thresh_set
*
* DESCRIPTION
*
*      oam rx sfbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
UINT_8 oam_rx_sf_bei_clr_thresh_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1) ||
        (parameter > 0xffff))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",      
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfbeicfg,index,value);
    
    value[0] = (value[0] & 0xffff0000) | (parameter);
    
    rv = ram_write_single(chip_id,rx_sfbeicfg,index,value);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bei_clr_thresh_get
*
* DESCRIPTION
*
*      oam rx sfbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sf_bei_clr_thresh_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfbeicfg,index,value);
    
    *parameter = value[0] & 0xffff;

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bei_block_num_set
*
* DESCRIPTION
*
*      oam rx sfbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
UINT_8 oam_rx_sf_bei_block_num_set(UINT_8 chip_id,UINT_8 index,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1) ||
        (parameter > 0x7ffffff))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",      
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfbeicfg,index,value);
    
    value[1] = (value[1] & 0xf0000001) | (parameter << 1);
    
    rv = ram_write_single(chip_id,rx_sfbeicfg,index,value);

    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*      oam_rx_sf_bei_block_num_get
*
* DESCRIPTION
*
*      oam rx sfbeicfg ram.
*
* NOTE
*
*      RESERVED
*
* PARAMETERS
*
*      chip_id: chip number used
*      index: 0~CH_NUM - 1
**      parameter*: pointer to value
* RETURNS
*
*      0: success
*      1: fail
*
* CALLS
*
*      RESERVED
*
* CALLED BY
*
*      RESERVED
*
* VERSION
*
*    <author>     <data>    <CR_ID>        <DESCRIPTION>
*     dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sf_bei_block_num_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    UINT_32 value[2] = {0};
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",      
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    ram_read_single(chip_id,rx_sfbeicfg,index,value);
    
    *parameter = (value[1] & 0x0ffffffe) >> 1;

    return rv;

}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_chid_ram_set
*
* DESCRIPTION
*
*     Oam rx chid ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_chid_ram_set(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_write_single(chip_id,chid_ram,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_chid_ram_get
*
* DESCRIPTION
*
*     Oam rx chid ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_chid_ram_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_read_single(chip_id,chid_ram,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sfcfg_set
*
* DESCRIPTION
*
*     Oam rx rx_sfcfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sfcfg_set(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_write_single(chip_id,rx_sfcfg,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sfcfg_get
*
* DESCRIPTION
*
*     Oam rx chid ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sfcfg_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_read_single(chip_id,rx_sfcfg,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_oam_cnt_ram_get
*
* DESCRIPTION
*
*     Oam rx cnt ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_oam_cnt_ram_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_read_single(chip_id,oam_cnt,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sdbeicfg_ram_set
*
* DESCRIPTION
*
*     Oam rx sdbeicfg ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbeicfg_ram_set(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_write_single(chip_id,rx_sdbeicfg,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sdbeicfg_ram_get
*
* DESCRIPTION
*
*     Oam rx sdbeicfg ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbeicfg_ram_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_read_single(chip_id,rx_sdbeicfg,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sfbeicfg_ram_set
*
* DESCRIPTION
*
*     Oam rx sfbeicfg ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sfbeicfg_ram_set(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_write_single(chip_id,rx_sfbeicfg,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sfbeicfg_ram_get
*
* DESCRIPTION
*
*     Oam rx sfbeicfg ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sfbeicfg_ram_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_read_single(chip_id,rx_sfbeicfg,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_reixc_cfg_ram_set
*
* DESCRIPTION
*
*     Oam rx reixc_cfg ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_reixc_cfg_ram_set(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_write_single(chip_id,reixc_cfg,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_reixc_cfg_ram_get
*
* DESCRIPTION
*
*     Oam rx reixc_cfg ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_reixc_cfg_ram_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_read_single(chip_id,reixc_cfg,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_base_oam_get
*
* DESCRIPTION
*
*     Oam rx base_oam ram.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_base_oam_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_read_single(chip_id,base_oam,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_base_oam_cnt_get
*
* DESCRIPTION
*
*     oam_rx_base_oam_cnt_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     index: 0~CH_NUM - 1
**    parameter*: pointer to value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_base_oam_cnt_get(UINT_8 chip_id,UINT_8 index,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;
    
    if ((chip_id > MAX_DEV) ||
        (index > CH_NUM - 1))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!! \
                    \r\n chip_id = %d, \
                    \r\n index = %d \r\n",    
                    __FUNCTION__,
                    chip_id,
                    index
                  );
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = ram_read_single(chip_id,base_oam_cnt,index,parameter);

    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_alm_en_set
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     alm_type: 0~23
*               0-BASE_LOS_ALM_EN       9-BAS_RDI_ALM_EN
*               1-BAS_CS_LF_ALM_EN      10-CLIENT_FAIL_ALM_EN
*               2-BAS_CS_RF_ALM_EN      11-TX_SDBIP_ALM_EN
*               3-BAS_CSF_LPI_ALM_EN    12-TX_SDBEI_ALM_EN
*               4-SDBIP_ALM_EN          13-TX_BASE_LOS_ALM_EN
*               5-SDBEI_ALM_EN          14-TX_BAS_PERIOD_ALM_EN
*               6-CLIENT_LF_ALM_EN      15-TX_CLIENT_LF_ALM_EN
*               7-CLIENT_RF_ALM_EN      16-TX_CLIENT_RF_ALM_EN
*               8-CLIENT_LPI_ALM_EN     17-TX_CLIENT_LPI_ALM_EN
*				18-RX_LPI_ALM_EN        19-TX_SFBIP_ALM_EN
*				20-TX_SFBEI_ALM_EN      21-SFBIP_ALM_EN
*				22-SFBEI_ALM_EN			23-BAS_PERIOD_ALM_EN
*
*     parameter: 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_alm_en_set(UINT_8 chip_id,UINT_8 alm_type,UINT_32 parameter)
{
    if (chip_id > MAX_DEV || alm_type > MAX_INDEX(oam_rx_alm_en_reg) || parameter > 1)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!!chip_id = %d,alm_type = %d,parameter = %d\r\n",__FUNCTION__,chip_id,alm_type,parameter);
        }

        return RET_PARAERR;
    }

    regp_field_write(chip_id,oam_rx_alm_en_reg[alm_type],parameter);
    
    return RET_SUCCESS;
}


/******************************************************************************
*
* FUNCTION
*
*     oam_rx_alm_en_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     alm_type: 0~23
*               0-BASE_LOS_ALM_EN       9-BAS_RDI_ALM_EN
*               1-BAS_CS_LF_ALM_EN      10-CLIENT_FAIL_ALM_EN
*               2-BAS_CS_RF_ALM_EN      11-TX_SDBIP_ALM_EN
*               3-BAS_CSF_LPI_ALM_EN    12-TX_SDBEI_ALM_EN
*               4-SDBIP_ALM_EN          13-TX_BASE_LOS_ALM_EN
*               5-SDBEI_ALM_EN          14-TX_BAS_PERIOD_ALM_EN
*               6-CLIENT_LF_ALM_EN      15-TX_CLIENT_LF_ALM_EN
*               7-CLIENT_RF_ALM_EN      16-TX_CLIENT_RF_ALM_EN
*               8-CLIENT_LPI_ALM_EN     17-TX_CLIENT_LPI_ALM_EN
*				18-RX_LPI_ALM_EN        19-TX_SFBIP_ALM_EN
*				20-TX_SFBEI_ALM_EN      21-SFBIP_ALM_EN
*				22-SFBEI_ALM_EN			23-BAS_PERIOD_ALM_EN
*
*     *parameter: pointer to enable cfg, 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_alm_en_get(UINT_8 chip_id,UINT_8 alm_type,UINT_32* parameter)
{
    if (chip_id > MAX_DEV || alm_type > MAX_INDEX(oam_rx_alm_en_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter!!chip_id = %d,alm_type = %d\r\n",__FUNCTION__,chip_id,alm_type);
        }

        return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer!!\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    regp_field_read(chip_id,oam_rx_alm_en_reg[alm_type],parameter);
    
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_ts_ram_init_done_get
*
* DESCRIPTION
*
*     Oam rx ts ram init enable
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_ts_ram_init_done_get(UINT_8 chip_id,UINT_32* parameter)
{
	if (chip_id > MAX_DEV)
	{
		if (oam_rx_para_debug)
		{
			printf("[%s] parameter invalid!!chip_id = %d\r\n",__FUNCTION__,chip_id);
		}

		return RET_PARAERR;
	}

	if (NULL == parameter)
	{
		if (oam_rx_para_debug)
		{
			printf("[%s] parameter pointer invalid!!\r\n",__FUNCTION__);
		}

		return RET_PARAERR;
	}
	
	if (OAMRX_TS_RAM_INIT_DONE > MAX_INDEX(oam_cnt_clr_done_reg))
	{
		if (oam_rx_para_debug)
		{
			printf("[%s] out of array range!!\r\n",__FUNCTION__);
		}

		return RET_PARAERR;
	}

	regp_field_read(chip_id,oam_cnt_clr_done_reg[OAMRX_TS_RAM_INIT_DONE],parameter);

	return RET_SUCCESS;
}


/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bypass_xgmii_set
*
* DESCRIPTION
*
*     Oam rx bypass xgmii value set.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bypass_xgmii_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        parameter > 1)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d,  \
                   \r\n parameter = %d\r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bypass_xgmii_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,bypass_xgmii_reg[ch_id/32].base_addr,bypass_xgmii_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bypass_xgmii_get
*
* DESCRIPTION
*
*     Oam rx bypass xgmii value get.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-2     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bypass_xgmii_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(bypass_xgmii_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,bypass_xgmii_reg[ch_id/32].base_addr,bypass_xgmii_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_lpi_rpl_en_set
*
* DESCRIPTION
*
*     oam_rx_lpi_rpl_en_set
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: set value  0:replace  1:no replace
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-4-18     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_lpi_rpl_en_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d,  \
                   \r\n parameter = %d\r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rx_lpi_rpl_en_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,rx_lpi_rpl_en_reg[ch_id/32].base_addr,rx_lpi_rpl_en_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_lpi_rpl_en_get
*
* DESCRIPTION
*
*     oam_rx_lpi_rpl_en_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to get value 0:replace  1:no replace
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-4-18     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_lpi_rpl_en_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(rx_lpi_rpl_en_reg))
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,rx_lpi_rpl_en_reg[ch_id/32].base_addr,rx_lpi_rpl_en_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_crc_en_set
*
* DESCRIPTION
*
*     oam_rx_crc_en_set
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id: 0:CRC_BASE_CNT_EN  1:CRC_OAM_CAL_EN
**    parameter: set value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-4-19     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_crc_en_set(UINT_8 chip_id,UINT_8 field_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }


	if (field_id == 0)
	{
		rv = regp_field_write(chip_id,oam_rx_cfg_reg[CRC_BASE_CNT_EN],parameter);
	}
	else if (field_id == 1)
		{
			rv = regp_field_write(chip_id,oam_rx_cfg_reg[CRC_OAM_CAL_EN],parameter);
		}
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_crc_en_get
*
* DESCRIPTION
*
*     oam_rx_crc_en_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id: 0:CRC_BASE_CNT_EN  1:CRC_OAM_CAL_EN
**   *parameter: pointer to get value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-10    1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_crc_en_get(UINT_8 chip_id,UINT_8 field_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (field_id == 0)
	{
		rv = regp_field_read(chip_id,oam_rx_cfg_reg[CRC_BASE_CNT_EN],parameter);
	}
	else if (field_id == 1)
		{
			rv = regp_field_read(chip_id,oam_rx_cfg_reg[CRC_OAM_CAL_EN],parameter);
		}
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rx_sdbip_int_set
*
* DESCRIPTION
*
*     oam_rx_rx_sdbip_int_set
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbip_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rx_sdbip_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rx_sdbip_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rx_sdbip_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rx_sdbip_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rx_sdbip_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rx_sdbip_int_get
*
* DESCRIPTION
*
*     oam_rx_rx_sdbip_int_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbip_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rx_sdbip_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rx_sdbip_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rx_sdbip_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rx_sdbip_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rx_sdbip_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rx_sdbip_int_mask_set
*
* DESCRIPTION
*
*     oam_rx_rx_sdbip_int_mask_set
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbip_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rx_sdbip_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rx_sdbip_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rx_sdbip_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rx_sdbip_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rx_sdbip_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rx_sdbip_int_mask_get
*
* DESCRIPTION
*
*     oam_rx_rx_sdbip_int_mask_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbip_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rx_sdbip_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rx_sdbip_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rx_sdbip_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rx_sdbip_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rx_sdbip_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_rdi_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_rdi_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_rdi_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_rdi_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_rdi_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_rdi_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_rdi_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_rdi_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_rdi_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_rdi_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_rdi_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_rdi_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_rdi_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_rdi_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_rdi_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_rdi_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_rdi_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_rdi_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_rdi_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_rdi_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_rdi_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_rdi_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_rdi_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_rdi_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_rdi_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_rdi_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_rdi_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_rdi_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_csf_lpi_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_csf_lpi_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_csf_lpi_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_csf_lpi_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_csf_lpi_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_csf_lpi_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_csf_lpi_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_csf_lpi_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_csf_lpi_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_csf_lpi_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_csf_lpi_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_csf_lpi_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_csf_lpi_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_csf_lpi_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_csf_lpi_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_csf_lpi_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_csf_lpi_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_csf_lpi_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_csf_lpi_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_csf_lpi_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_csf_lpi_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_csf_lpi_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_csf_lpi_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_csf_lpi_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_csf_lpi_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_csf_lpi_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_csf_lpi_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_csf_lpi_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_cs_lf_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_cs_lf_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_cs_lf_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_cs_lf_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_cs_lf_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_cs_lf_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_cs_lf_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_cs_lf_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_cs_lf_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_cs_lf_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_cs_lf_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_cs_lf_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_cs_lf_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_cs_lf_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_cs_lf_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_cs_lf_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_cs_lf_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_cs_lf_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_cs_lf_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_cs_lf_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_cs_lf_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_cs_lf_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_cs_lf_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_cs_lf_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_cs_lf_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_cs_lf_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_cs_lf_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_cs_lf_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_cs_rf_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_cs_rf_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_cs_rf_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_cs_rf_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_cs_rf_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_cs_rf_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_cs_rf_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_cs_rf_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_cs_rf_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_cs_rf_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_cs_rf_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_cs_rf_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_cs_rf_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_cs_rf_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_cs_rf_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_cs_rf_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_cs_rf_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_cs_rf_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_cs_rf_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_cs_rf_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_cs_rf_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_cs_rf_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_cs_rf_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_cs_rf_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_cs_rf_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_cs_rf_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_cs_rf_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_cs_rf_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_crc_err_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_crc_err_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_crc_err_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_crc_err_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_crc_err_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_crc_err_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_crc_err_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_crc_err_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_crc_err_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_crc_err_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_crc_err_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_crc_err_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_crc_err_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_crc_err_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_crc_err_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_crc_err_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_crc_err_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_crc_err_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_crc_err_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_crc_err_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_crc_err_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_crc_err_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_crc_err_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_crc_err_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_crc_err_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_crc_err_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_crc_err_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_crc_err_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_no_receive_alm_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_no_receive_alm_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_no_receive_alm_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_no_receive_alm_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_no_receive_alm_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_no_receive_alm_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_no_receive_alm_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_no_receive_alm_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_no_receive_alm_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_no_receive_alm_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_no_receive_alm_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_no_receive_alm_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_no_receive_alm_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_no_receive_alm_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_no_receive_alm_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_no_receive_alm_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_no_receive_alm_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_no_receive_alm_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_no_receive_alm_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_no_receive_alm_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_no_receive_alm_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_bas_no_receive_alm_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_no_receive_alm_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_no_receive_alm_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_no_receive_alm_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_no_receive_alm_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_no_receive_alm_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_no_receive_alm_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rdi_lf_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rdi_lf_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rdi_lf_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rdi_lf_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rdi_lf_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rdi_lf_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rdi_lf_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rdi_lf_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rdi_lf_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rdi_lf_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rdi_lf_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rdi_lf_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rdi_lf_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rdi_lf_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rdi_lf_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rdi_lf_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rdi_lf_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rdi_lf_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rdi_lf_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rdi_lf_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rdi_lf_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rdi_lf_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rdi_lf_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rdi_lf_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rdi_lf_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rdi_lf_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rdi_lf_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rdi_lf_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sdbei_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbei_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rx_sdbei_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rx_sdbei_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rx_sdbei_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rx_sdbei_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rx_sdbei_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sdbei_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbei_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rx_sdbei_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rx_sdbei_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rx_sdbei_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rx_sdbei_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rx_sdbei_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sdbei_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbei_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rx_sdbei_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rx_sdbei_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rx_sdbei_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rx_sdbei_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rx_sdbei_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_sdbei_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_sdbei_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rx_sdbei_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rx_sdbei_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rx_sdbei_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rx_sdbei_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rx_sdbei_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rf_alm_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rf_alm_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rf_alm_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rf_alm_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rf_alm_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rf_alm_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rf_alm_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rf_alm_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rf_alm_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rf_alm_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rf_alm_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rf_alm_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rf_alm_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rf_alm_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rf_alm_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rf_alm_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rf_alm_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rf_alm_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rf_alm_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rf_alm_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rf_alm_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_rf_alm_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_rf_alm_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rf_alm_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rf_alm_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rf_alm_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rf_alm_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rf_alm_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_lpi_alm_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_lpi_alm_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,lpi_alm_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,lpi_alm_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,lpi_alm_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,lpi_alm_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,lpi_alm_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_lpi_alm_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_lpi_alm_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,lpi_alm_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,lpi_alm_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,lpi_alm_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,lpi_alm_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,lpi_alm_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_lpi_alm_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_lpi_alm_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,lpi_alm_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,lpi_alm_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,lpi_alm_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,lpi_alm_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,lpi_alm_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     oam_rx_lpi_alm_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_lpi_alm_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,lpi_alm_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,lpi_alm_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,lpi_alm_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,lpi_alm_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,lpi_alm_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}


/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_rx_bas_period_alm_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_period_alm_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_period_alm_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_period_alm_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_period_alm_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_period_alm_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_period_alm_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_rx_bas_period_alm_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_period_alm_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_period_alm_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_period_alm_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_period_alm_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_period_alm_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_period_alm_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_rx_bas_period_alm_int_mask_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_period_alm_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,bas_period_alm_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,bas_period_alm_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,bas_period_alm_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,bas_period_alm_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,bas_period_alm_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_rx_bas_period_alm_int_mask_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4     1.0           initial
*
******************************************************************************/
RET_STATUS oam_rx_bas_period_alm_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,bas_period_alm_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,bas_period_alm_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,bas_period_alm_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,bas_period_alm_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,bas_period_alm_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

RET_STATUS oam_rx_sfbei_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rx_sfbei_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rx_sfbei_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rx_sfbei_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rx_sfbei_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rx_sfbei_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

RET_STATUS oam_rx_sfbei_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rx_sfbei_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rx_sfbei_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rx_sfbei_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rx_sfbei_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rx_sfbei_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

RET_STATUS oam_rx_sfbei_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rx_sfbei_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rx_sfbei_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rx_sfbei_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rx_sfbei_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rx_sfbei_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

RET_STATUS oam_rx_sfbei_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rx_sfbei_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rx_sfbei_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rx_sfbei_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rx_sfbei_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rx_sfbei_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

RET_STATUS oam_rx_sfbip_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rx_sfbip_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rx_sfbip_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rx_sfbip_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rx_sfbip_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rx_sfbip_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

RET_STATUS oam_rx_sfbip_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rx_sfbip_i0_INT_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rx_sfbip_i1_INT_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rx_sfbip_i2_INT_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rx_sfbip_i3_INT_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rx_sfbip_i4_INT_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

RET_STATUS oam_rx_sfbip_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_write(chip_id,rx_sfbip_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_write(chip_id,rx_sfbip_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_write(chip_id,rx_sfbip_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_write(chip_id,rx_sfbip_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_write(chip_id,rx_sfbip_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

RET_STATUS oam_rx_sfbip_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (oam_rx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (oam_rx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/16)
	{
		case 0:
			regp_field_read(chip_id,rx_sfbip_i0_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 1:
			regp_field_read(chip_id,rx_sfbip_i1_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 2:
			regp_field_read(chip_id,rx_sfbip_i2_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 3:
			regp_field_read(chip_id,rx_sfbip_i3_INT_MASK_REG[ch_id%16],parameter);
			break;
		case 4:
			regp_field_read(chip_id,rx_sfbip_i4_INT_MASK_REG[ch_id%16],parameter);
			break;
		default:
			break;
	}
      
    return RET_SUCCESS;
}

#define OAM_TOTAL_TS    80
#define TOTAL_RATE      400
#define NULL_TUNNEL     0x7f
#define TS_RATE         5


UINT_32 oam_ts_inuse[DEV_NUM] = {0,0};
UINT_32 oam_rate_inuse[DEV_NUM] = {0,0};

UINT_32 oam_ram_bak_value[DEV_NUM][OAM_TOTAL_TS];
UINT_32 oam_ram_value[DEV_NUM][OAM_TOTAL_TS] ;

RET_STATUS oam_rx_ram_init(UINT_8 chip_id)
{
    int i;

    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        oam_ram_value[chip_id][i] = NULL_TUNNEL;
        oam_rx_chid_ram_set(chip_id, i, &(oam_ram_value[chip_id][i]));
    }
	
	oam_ts_inuse[chip_id] = 0;
	oam_rate_inuse[chip_id] = 0;

    return RET_SUCCESS;

}


RET_STATUS oam_rx_ts_add(UINT_8 chip_id, int tunnel_id, int rate)
{
	UINT_32 ts_sum;
	UINT_32 ts_unuse;
    UINT_32 temp_ts;
	UINT_32 num;
    /*UINT_32 num_flag, num_temp;*/
	int i,j,k,temp;
    UINT_32 res = 0, res_again = 0;
    UINT_32 unuse_value[OAM_TOTAL_TS]={0};
    UINT_32 cfg_ts[OAM_TOTAL_TS];
    UINT_32 res_temp[OAM_TOTAL_TS];
    UINT_32 res_temp_again[OAM_TOTAL_TS];
    UINT_32 temp_cfg[OAM_TOTAL_TS];
    int flag;
    UINT_32 value[OAM_TOTAL_TS] = {0};
    
    if((tunnel_id < 0 || tunnel_id >= OAM_TOTAL_TS) || (rate % 5 != 0) || (rate > TOTAL_RATE))
    {
        printf("para error\n");
        return RET_PARAERR;
    }
    
    /*read oam ram and check oam_ram_value same as register value*/
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        /*read oam ram*/
        oam_rx_chid_ram_get(chip_id, i, &(value[i]));

        if(value[i] != oam_ram_value[chip_id][i])
        {
            oam_ram_value[chip_id][i] = value[i];
            /*return RET_FAIL;*/
        }
    }
    
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        if(oam_ram_value[chip_id][i] == tunnel_id)
        {
            printf("the tunnel_id is already used, please delete it first!\n");
            return RET_PARAERR;
        }
    }

	ts_unuse = OAM_TOTAL_TS - oam_ts_inuse[chip_id];
	ts_sum = rate/TS_RATE;
	num = OAM_TOTAL_TS/ts_sum;

    if(ts_sum > ts_unuse)
    {
        printf("The unused rate is not enough\n");
        return RET_PARAERR;
    }

    if(ts_sum > (ts_unuse / 2))
    {
        flag = 1;
        if(num == 1)
        {
            if((OAM_TOTAL_TS % ts_sum) != 0)
            {
                num = 2;
            }
        }
    }
    else
    {
        flag = 0;
        if((OAM_TOTAL_TS % ts_sum) != 0)
        {
            num = num + 1;
        }
    }

    /*save the last chid_ram_value*/
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        oam_ram_bak_value[chip_id][i] = oam_ram_value[chip_id][i];

    }

    /*init the cfg_ts*/
    for(j = 0; j < ts_sum; j++)
    {
        cfg_ts[j] = 0;
    }

    /*record all of the unuse ts first time*/
    temp = 0;
	for(i = 0; i < OAM_TOTAL_TS; i++)
    {
		if(oam_ram_value[chip_id][i] == NULL_TUNNEL)
	    {
            unuse_value[temp] = i;
            temp++;
		}
	}



    /*calculate the ts which can cfg first time*/
    for(j = 0; j < ts_sum; j++)
    {
        cfg_ts[j] = unuse_value[0] + num * j;
    }
	
    if(flag == 0)
    {
        /*for(j = 0; j < ts_sum; j++)*/
        /*{*/
        /*    cfg_ts[j] = unuse_value[0] + num * j;*/
        /*}*/
    }
    else
    {
        /*num = 200 /(200 - rate);*/
        /*num_flag = ts_sum / num;*/
        /*num_temp = ts_sum % num;*/
        
        /*for(i = 0; i < num_flag; i++)*/
        /*{*/
        /*    for(j = 0; j < num; j++)*/
        /*    {*/
        /*        if((i + j) >= ts_sum)*/
        /*        {*/
        /*            break;*/
        /*        }           */
        /*        cfg_ts[i + j] = unuse_value[0] + (num + 1) * i + j;*/
        /*    }*/
        /*}*/
        
    }
    
    /*check the cfg ts */
    for(j = 0; j < ts_sum; j++)
    {
        for(i = 0; i < temp; i++)
        {
            if(cfg_ts[j] == unuse_value[i])
            {
                temp_ts = cfg_ts[j];
                oam_ram_value[chip_id][temp_ts] = tunnel_id;
                break;
            }

        }

        if(i == temp)
        {
        	res_temp[res] = j;
            res++;
        }
    }


    /*record all of the unuse ts second time*/
    temp = 0;
	for(i = 0; i < OAM_TOTAL_TS; i++)
    {
		if(oam_ram_value[chip_id][i] == NULL_TUNNEL)
	    {
            unuse_value[temp] = i;
            temp++;
		}
	}


    /*cfg ts which is failed last time*/
    for(i = 0; i < res; i++)
    {
        temp_cfg[i] = unuse_value[0] + (num * 2) * i;
    }

    /*check the temp_cfg*/
    for(j = 0; j < res; j++)
    {
        for(i = 0; i < temp; i++)
        {
            if(temp_cfg[j] == unuse_value[i])
            {
                k = res_temp[j];
                cfg_ts[k] = temp_cfg[j];
                temp_ts = cfg_ts[k];
                oam_ram_value[chip_id][temp_ts] = tunnel_id;
                break;
            }

        }

        if(i == temp)
        {
        	res_temp_again[res_again] = j;
            res_again++;
        }
    }
    
    
    /*record all of the unuse ts third time*/
    temp = 0;
	for(i = 0; i < OAM_TOTAL_TS; i++)
    {
		if(oam_ram_value[chip_id][i] == NULL_TUNNEL)
	    {
            unuse_value[temp] = i;
            temp++;
		}
	}

    /*cfg ts which is failed last time*/
    for(i = 0; i < res_again; i++)
    {
        j = res_temp_again[i];
        k = res_temp[j];
        cfg_ts[k] = unuse_value[i];

        temp_ts = cfg_ts[k];
        oam_ram_value[chip_id][temp_ts] = tunnel_id;
    }

    for(j = 0; j < ts_sum; j++)
        printf("%d  ",cfg_ts[j]);

    printf("\n");

	oam_rate_inuse[chip_id] = oam_rate_inuse[chip_id] + rate;
	oam_ts_inuse[chip_id] = oam_ts_inuse[chip_id] + ts_sum;

    /*printf("ts  back_up    right_now  \n");*/
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        value[i] = oam_ram_value[chip_id][i];
        /*printf("%2d     %2d       %2d   \n",i,oam_ram_bak_value[i],oam_ram_value[i]);*/
        /*printf("     _______  _______\n");*/
    }

    /*cfg oam ram*/
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        oam_rx_chid_ram_set(chip_id, i, &(value[i]));
    }

    return RET_SUCCESS;
}


RET_STATUS oam_rx_ts_del(UINT_8 chip_id, int tunnel_id)
{
    int i;
	UINT_8 ts = 0;
    UINT_32 value[OAM_TOTAL_TS] = {0};

    /*read oam ram and check oam_ram_value same as register value*/
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        /*read oam ram*/
        oam_rx_chid_ram_get(chip_id, i, &(value[i]));

        if(value[i] != oam_ram_value[chip_id][i])
        {
            oam_ram_value[chip_id][i] = value[i];
            /*return RET_FAIL;*/
        }
    }
    
    /*save the last chid_ram_value*/
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        oam_ram_bak_value[chip_id][i] = oam_ram_value[chip_id][i];

    }

    /*delete the tunnel*/
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        if(oam_ram_value[chip_id][i] == tunnel_id)
        {
            oam_ram_value[chip_id][i] = NULL_TUNNEL;
			ts++;
        }
    }
	
	oam_ts_inuse[chip_id] = oam_ts_inuse[chip_id] - ts;
	oam_rate_inuse[chip_id] = oam_rate_inuse[chip_id] - (ts * TS_RATE);

    /*cfg oam ram */
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        oam_rx_chid_ram_set(chip_id, i, &(oam_ram_value[chip_id][i]));
    }

    return RET_SUCCESS;
}



/*for env*/
RET_STATUS oam_rx_ts_sw_add(UINT_8 chip_id, int tunnel_id, int rate)
{
	UINT_32 ts_sum;
	UINT_32 ts_unuse;
    UINT_32 temp_ts;
	UINT_32 num;
    /*UINT_32 num_flag, num_temp;*/
	int i,j,k,temp;
    UINT_32 res = 0, res_again = 0;
    UINT_32 unuse_value[OAM_TOTAL_TS]={0};
    UINT_32 cfg_ts[OAM_TOTAL_TS];
    UINT_32 res_temp[OAM_TOTAL_TS];
    UINT_32 res_temp_again[OAM_TOTAL_TS];
    UINT_32 temp_cfg[OAM_TOTAL_TS];
    int flag;   
 
    if((tunnel_id < 0 || tunnel_id >= OAM_TOTAL_TS) || (rate % 5 != 0) || (rate > TOTAL_RATE))
    {
        printf("para error\n");
        return RET_PARAERR;
    }
    
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        if(oam_ram_value[chip_id][i] == tunnel_id)
        {
            printf("the tunnel_id is already used, please delete it first!\n");
            return RET_PARAERR;
        }
    }

	ts_unuse = OAM_TOTAL_TS - oam_ts_inuse[chip_id];
	ts_sum = rate/TS_RATE;
	num = OAM_TOTAL_TS/ts_sum;

    if(ts_sum > ts_unuse)
    {
        printf("The unused rate is not enough\n");
        return RET_PARAERR;
    }

    if(ts_sum > (ts_unuse / 2))
    {
        flag = 1;
        if(num == 1)
        {
            if((OAM_TOTAL_TS % ts_sum) != 0)
            {
                num = 2;
            }
        }
    }
    else
    {
        flag = 0;
        if((OAM_TOTAL_TS % ts_sum) != 0)
        {
            num = num + 1;
        }
    }

    /*save the last chid_ram_value*/
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        oam_ram_bak_value[chip_id][i] = oam_ram_value[chip_id][i];

    }

    /*init the cfg_ts*/
    for(j = 0; j < ts_sum; j++)
    {
        cfg_ts[j] = 0;
    }

    /*record all of the unuse ts first time*/
    temp = 0;
	for(i = 0; i < OAM_TOTAL_TS; i++)
    {
		if(oam_ram_value[chip_id][i] == NULL_TUNNEL)
	    {
            unuse_value[temp] = i;
            temp++;
		}
	}



    /*calculate the ts which can cfg first time*/
    for(j = 0; j < ts_sum; j++)
    {
        cfg_ts[j] = unuse_value[0] + num * j;
    }
	
    if(flag == 0)
    {
        /*for(j = 0; j < ts_sum; j++)*/
        /*{*/
        /*    cfg_ts[j] = unuse_value[0] + num * j;*/
        /*}*/
    }
    else
    {
        /*num = 200 /(200 - rate);*/
        /*num_flag = ts_sum / num;*/
        /*num_temp = ts_sum % num;*/
        
        /*for(i = 0; i < num_flag; i++)*/
        /*{*/
        /*    for(j = 0; j < num; j++)*/
        /*    {*/
        /*        if((i + j) >= ts_sum)*/
        /*        {*/
        /*            break;*/
        /*        }           */
        /*        cfg_ts[i + j] = unuse_value[0] + (num + 1) * i + j;*/
        /*    }*/
        /*}*/
        
    }
    
    /*check the cfg ts */
    for(j = 0; j < ts_sum; j++)
    {
        for(i = 0; i < temp; i++)
        {
            if(cfg_ts[j] == unuse_value[i])
            {
                temp_ts = cfg_ts[j];
                oam_ram_value[chip_id][temp_ts] = tunnel_id;
                break;
            }

        }

        if(i == temp)
        {
        	res_temp[res] = j;
            res++;
        }
    }


    /*record all of the unuse ts second time*/
    temp = 0;
	for(i = 0; i < OAM_TOTAL_TS; i++)
    {
		if(oam_ram_value[chip_id][i] == NULL_TUNNEL)
	    {
            unuse_value[temp] = i;
            temp++;
		}
	}


    /*cfg ts which is failed last time*/
    for(i = 0; i < res; i++)
    {
        temp_cfg[i] = unuse_value[0] + (num * 2) * i;
    }

    /*check the temp_cfg*/
    for(j = 0; j < res; j++)
    {
        for(i = 0; i < temp; i++)
        {
            if(temp_cfg[j] == unuse_value[i])
            {
                k = res_temp[j];
                cfg_ts[k] = temp_cfg[j];
                temp_ts = cfg_ts[k];
                oam_ram_value[chip_id][temp_ts] = tunnel_id;
                break;
            }

        }

        if(i == temp)
        {
        	res_temp_again[res_again] = j;
            res_again++;
        }
    }
    
    
    /*record all of the unuse ts third time*/
    temp = 0;
	for(i = 0; i < OAM_TOTAL_TS; i++)
    {
		if(oam_ram_value[chip_id][i] == NULL_TUNNEL)
	    {
            unuse_value[temp] = i;
            temp++;
		}
	}

    /*cfg ts which is failed last time*/
    for(i = 0; i < res_again; i++)
    {
        j = res_temp_again[i];
        k = res_temp[j];
        cfg_ts[k] = unuse_value[i];

        temp_ts = cfg_ts[k];
        oam_ram_value[chip_id][temp_ts] = tunnel_id;
    }

    for(j = 0; j < ts_sum; j++)
        printf("%d  ",cfg_ts[j]);

    printf("\n");

	oam_rate_inuse[chip_id] = oam_rate_inuse[chip_id] + rate;
	oam_ts_inuse[chip_id] = oam_ts_inuse[chip_id] + ts_sum;


    return RET_SUCCESS;
}


void oam_rx_ts_register_add(UINT_8 chip_id)
{
    int i;
    /*cfg oam ram*/
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        oam_rx_chid_ram_set(chip_id, i, &(oam_ram_value[chip_id][i]));
    }

}



/*for debug*/
void oam_ts_debug(UINT_8 chip_id)
{	
	int i;
    UINT_32 value[OAM_TOTAL_TS] = {0};

	printf("OAM_TS_INUSE = %d\n", oam_ts_inuse[chip_id]);
	printf("OAM_RATE_INUSE = %d\n", oam_rate_inuse[chip_id]);	
	printf("		backup	  now	\n");
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        printf("%2d     %2d       %2d   \n",i,oam_ram_bak_value[chip_id][i],oam_ram_value[chip_id][i]);
        printf("     _______  _______\n");
    }

    /*read oam ram and check oam_ram_value same as register value*/
	printf("----- ram value	\n");
    for(i = 0; i < OAM_TOTAL_TS; i++)
    {
        /*read oam ram*/
        oam_rx_chid_ram_get(chip_id, i, &(value[i]));
		
        printf("%2d     %2d\n",i,value[i]);
        printf("     _______\n");
    }

}

