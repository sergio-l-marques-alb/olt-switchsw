

/******************************************************************************
*INCLUDE FILES
******************************************************************************/
#include "reg_operate.h"
#include "hal.h"
#include <stdio.h>
/******************************************************************************
*CONSTANT AND MACRO DEFINE
******************************************************************************/
unsigned long int flexe_oam_tx_para_debug = 0;

const CHIP_REG flexe_oam_joit_bip_cfg_reg[]=
{
	{BAS_BRK_CFG,FLEXE_OAM_TX_BASE_ADDR,0x0,2,2},
	{LPI_INSERT_EN,FLEXE_OAM_TX_BASE_ADDR,0x0,3,3},
	{LF_INSERT_EN,FLEXE_OAM_TX_BASE_ADDR,0x0,4,4},
	{RF_INSERT_EN,FLEXE_OAM_TX_BASE_ADDR,0x0,5,5},
	{BAS_BRK_CH_CFG,FLEXE_OAM_TX_BASE_ADDR,0x0,12,6},
	{TS_1DM_INSERT_EN,FLEXE_OAM_TX_BASE_ADDR,0x0,13,13},
	{TS_2DMM_INSERT_EN,FLEXE_OAM_TX_BASE_ADDR,0x0,14,14},
	{TS_2DMR_INSERT_EN,FLEXE_OAM_TX_BASE_ADDR,0x0,15,15},
	{TS_DM_SEL,FLEXE_OAM_TX_BASE_ADDR,0x0,16,16},
	{FAULT_RPL_EN,FLEXE_OAM_TX_BASE_ADDR,0x0,17,17},
};
const CHIP_REG flexe_bas_idty_cfg_reg[]=
{
	{BAS_IDTY_CFG,FLEXE_OAM_TX_BASE_ADDR,0x1,3,0},
};
const CHIP_REG flexe_bas_period_cfg_reg[]=
{
	{BAS_PERIOD_CFG_0,FLEXE_OAM_TX_BASE_ADDR,0x2,31,0},
	{BAS_PERIOD_CFG_1,FLEXE_OAM_TX_BASE_ADDR,0x3,31,0},
	{BAS_PERIOD_CFG_2,FLEXE_OAM_TX_BASE_ADDR,0x4,31,0},
	{BAS_PERIOD_CFG_3,FLEXE_OAM_TX_BASE_ADDR,0x5,31,0},
	{BAS_PERIOD_CFG_4,FLEXE_OAM_TX_BASE_ADDR,0x6,31,0},
};
const CHIP_REG flexe_seq_type_cfg_reg[]=
{
	{SEQ_TYPE_CFG_0,FLEXE_OAM_TX_BASE_ADDR,0x7,31,0},
	{SEQ_TYPE_CFG_1,FLEXE_OAM_TX_BASE_ADDR,0x8,31,0},
	{SEQ_TYPE_CFG_2,FLEXE_OAM_TX_BASE_ADDR,0x9,15,0},
};
const CHIP_REG flexe_seq_num_cfg_reg[]=
{
	{SEQ_NUM_CFG_0,FLEXE_OAM_TX_BASE_ADDR,0xa,31,0},
	{SEQ_NUM_CFG_1,FLEXE_OAM_TX_BASE_ADDR,0xb,31,0},
	{SEQ_NUM_CFG_2,FLEXE_OAM_TX_BASE_ADDR,0xc,31,0},
	{SEQ_NUM_CFG_3,FLEXE_OAM_TX_BASE_ADDR,0xd,31,0},
	{SEQ_NUM_CFG_4,FLEXE_OAM_TX_BASE_ADDR,0xe,31,0},
	{SEQ_NUM_CFG_5,FLEXE_OAM_TX_BASE_ADDR,0xf,31,0},
	{SEQ_NUM_CFG_6,FLEXE_OAM_TX_BASE_ADDR,0x10,31,0},
	{SEQ_NUM_CFG_7,FLEXE_OAM_TX_BASE_ADDR,0x11,31,0},
	{SEQ_NUM_CFG_8,FLEXE_OAM_TX_BASE_ADDR,0x12,31,0},
	{SEQ_NUM_CFG_9,FLEXE_OAM_TX_BASE_ADDR,0x13,31,0},
};
const CHIP_REG flexe_crc_rev_cfg_reg[]=
{
	{CRC_REV_CFG,FLEXE_OAM_TX_BASE_ADDR,0x14,0,0},
	{OTH_CRC_REV_CFG,FLEXE_OAM_TX_BASE_ADDR,0x14,1,1},
};
const CHIP_REG flexe_tx_idle_rpl_en_reg[]=
{
	{TX_IDLE_RPL_EN_0,FLEXE_OAM_TX_BASE_ADDR,0x15,31,0},
	{TX_IDLE_RPL_EN_1,FLEXE_OAM_TX_BASE_ADDR,0x16,31,0},
	{TX_IDLE_RPL_EN_2,FLEXE_OAM_TX_BASE_ADDR,0x17,15,0},
};
const CHIP_REG flexe_oam_tx_bypass_reg[]=
{
	{OAM_TX_BYPASS,FLEXE_OAM_TX_BASE_ADDR,0x18,0,0},
};
const CHIP_REG flexe_bip_err_mask_reg[]=
{
	{BIP_ERR_MASK,FLEXE_OAM_TX_BASE_ADDR,0x19,7,0},
};
const CHIP_REG flexe_manual_insert_csf_lpi_reg[]=
{
	{MANUAL_INSERT_CSF_LPI_0,FLEXE_OAM_TX_BASE_ADDR,0x1a,31,0},
	{MANUAL_INSERT_CSF_LPI_1,FLEXE_OAM_TX_BASE_ADDR,0x1b,31,0},
	{MANUAL_INSERT_CSF_LPI_2,FLEXE_OAM_TX_BASE_ADDR,0x1c,15,0},
};
const CHIP_REG flexe_manual_insert_csf_lf_reg[]=
{
	{MANUAL_INSERT_CSF_LF_0,FLEXE_OAM_TX_BASE_ADDR,0x1d,31,0},
	{MANUAL_INSERT_CSF_LF_1,FLEXE_OAM_TX_BASE_ADDR,0x1e,31,0},
	{MANUAL_INSERT_CSF_LF_2,FLEXE_OAM_TX_BASE_ADDR,0x1f,15,0},
};
const CHIP_REG flexe_manual_insert_csf_rf_reg[]=
{
	{MANUAL_INSERT_CSF_RF_0,FLEXE_OAM_TX_BASE_ADDR,0x20,31,0},
	{MANUAL_INSERT_CSF_RF_1,FLEXE_OAM_TX_BASE_ADDR,0x21,31,0},
	{MANUAL_INSERT_CSF_RF_2,FLEXE_OAM_TX_BASE_ADDR,0x22,15,0},
};
const CHIP_REG flexe_bip_err_level_reg[]=
{
	{BIP_ERR_LEVEL_0,FLEXE_OAM_TX_BASE_ADDR,0x23,31,0},
	{BIP_ERR_LEVEL_1,FLEXE_OAM_TX_BASE_ADDR,0x24,31,0},
	{BIP_ERR_LEVEL_2,FLEXE_OAM_TX_BASE_ADDR,0x25,15,0},
};
const CHIP_REG flexe_oam_tx_bypass_client_reg[]=
{
	{OAM_TX_BYPASS_CLIENT_0,FLEXE_OAM_TX_BASE_ADDR,0x26,31,0},
	{OAM_TX_BYPASS_CLIENT_1,FLEXE_OAM_TX_BASE_ADDR,0x27,31,0},
	{OAM_TX_BYPASS_CLIENT_2,FLEXE_OAM_TX_BASE_ADDR,0x28,15,0},
};
const CHIP_REG flexe_manual_insert_rdi_reg[]=
{
	{MANUAL_INSERT_RDI_0,FLEXE_OAM_TX_BASE_ADDR,0x29,31,0},
	{MANUAL_INSERT_RDI_1,FLEXE_OAM_TX_BASE_ADDR,0x2a,31,0},
	{MANUAL_INSERT_RDI_2,FLEXE_OAM_TX_BASE_ADDR,0x2b,15,0},
};
const CHIP_REG flexe_bip_err_pulse_reg[]=
{
	{BIP_ERR_PULSE_0,FLEXE_OAM_TX_BASE_ADDR,0x2c,31,0},
	{BIP_ERR_PULSE_1,FLEXE_OAM_TX_BASE_ADDR,0x2d,31,0},
	{BIP_ERR_PULSE_2,FLEXE_OAM_TX_BASE_ADDR,0x2e,15,0},
};
const CHIP_REG flexe_bas_insert_cnt_0t3_reg[]=
{
	{BAS_INSERT_CNT_0,FLEXE_OAM_TX_BASE_ADDR,0x2f,7,0},
	{BAS_INSERT_CNT_1,FLEXE_OAM_TX_BASE_ADDR,0x2f,15,8},
	{BAS_INSERT_CNT_2,FLEXE_OAM_TX_BASE_ADDR,0x2f,23,16},
	{BAS_INSERT_CNT_3,FLEXE_OAM_TX_BASE_ADDR,0x2f,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_4t7_reg[]=
{
	{BAS_INSERT_CNT_4,FLEXE_OAM_TX_BASE_ADDR,0x30,7,0},
	{BAS_INSERT_CNT_5,FLEXE_OAM_TX_BASE_ADDR,0x30,15,8},
	{BAS_INSERT_CNT_6,FLEXE_OAM_TX_BASE_ADDR,0x30,23,16},
	{BAS_INSERT_CNT_7,FLEXE_OAM_TX_BASE_ADDR,0x30,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_8t11_reg[]=
{
	{BAS_INSERT_CNT_8,FLEXE_OAM_TX_BASE_ADDR,0x31,7,0},
	{BAS_INSERT_CNT_9,FLEXE_OAM_TX_BASE_ADDR,0x31,15,8},
	{BAS_INSERT_CNT_10,FLEXE_OAM_TX_BASE_ADDR,0x31,23,16},
	{BAS_INSERT_CNT_11,FLEXE_OAM_TX_BASE_ADDR,0x31,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_12t15_reg[]=
{
	{BAS_INSERT_CNT_12,FLEXE_OAM_TX_BASE_ADDR,0x32,7,0},
	{BAS_INSERT_CNT_13,FLEXE_OAM_TX_BASE_ADDR,0x32,15,8},
	{BAS_INSERT_CNT_14,FLEXE_OAM_TX_BASE_ADDR,0x32,23,16},
	{BAS_INSERT_CNT_15,FLEXE_OAM_TX_BASE_ADDR,0x32,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_16t19_reg[]=
{
	{BAS_INSERT_CNT_16,FLEXE_OAM_TX_BASE_ADDR,0x33,7,0},
	{BAS_INSERT_CNT_17,FLEXE_OAM_TX_BASE_ADDR,0x33,15,8},
	{BAS_INSERT_CNT_18,FLEXE_OAM_TX_BASE_ADDR,0x33,23,16},
	{BAS_INSERT_CNT_19,FLEXE_OAM_TX_BASE_ADDR,0x33,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_20t23_reg[]=
{
	{BAS_INSERT_CNT_20,FLEXE_OAM_TX_BASE_ADDR,0x34,7,0},
	{BAS_INSERT_CNT_21,FLEXE_OAM_TX_BASE_ADDR,0x34,15,8},
	{BAS_INSERT_CNT_22,FLEXE_OAM_TX_BASE_ADDR,0x34,23,16},
	{BAS_INSERT_CNT_23,FLEXE_OAM_TX_BASE_ADDR,0x34,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_24t27_reg[]=
{
	{BAS_INSERT_CNT_24,FLEXE_OAM_TX_BASE_ADDR,0x35,7,0},
	{BAS_INSERT_CNT_25,FLEXE_OAM_TX_BASE_ADDR,0x35,15,8},
	{BAS_INSERT_CNT_26,FLEXE_OAM_TX_BASE_ADDR,0x35,23,16},
	{BAS_INSERT_CNT_27,FLEXE_OAM_TX_BASE_ADDR,0x35,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_28t31_reg[]=
{
	{BAS_INSERT_CNT_28,FLEXE_OAM_TX_BASE_ADDR,0x36,7,0},
	{BAS_INSERT_CNT_29,FLEXE_OAM_TX_BASE_ADDR,0x36,15,8},
	{BAS_INSERT_CNT_30,FLEXE_OAM_TX_BASE_ADDR,0x36,23,16},
	{BAS_INSERT_CNT_31,FLEXE_OAM_TX_BASE_ADDR,0x36,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_32t35_reg[]=
{
	{BAS_INSERT_CNT_32,FLEXE_OAM_TX_BASE_ADDR,0x37,7,0},
	{BAS_INSERT_CNT_33,FLEXE_OAM_TX_BASE_ADDR,0x37,15,8},
	{BAS_INSERT_CNT_34,FLEXE_OAM_TX_BASE_ADDR,0x37,23,16},
	{BAS_INSERT_CNT_35,FLEXE_OAM_TX_BASE_ADDR,0x37,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_36t39_reg[]=
{
	{BAS_INSERT_CNT_36,FLEXE_OAM_TX_BASE_ADDR,0x38,7,0},
	{BAS_INSERT_CNT_37,FLEXE_OAM_TX_BASE_ADDR,0x38,15,8},
	{BAS_INSERT_CNT_38,FLEXE_OAM_TX_BASE_ADDR,0x38,23,16},
	{BAS_INSERT_CNT_39,FLEXE_OAM_TX_BASE_ADDR,0x38,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_40t43_reg[]=
{
	{BAS_INSERT_CNT_40,FLEXE_OAM_TX_BASE_ADDR,0x39,7,0},
	{BAS_INSERT_CNT_41,FLEXE_OAM_TX_BASE_ADDR,0x39,15,8},
	{BAS_INSERT_CNT_42,FLEXE_OAM_TX_BASE_ADDR,0x39,23,16},
	{BAS_INSERT_CNT_43,FLEXE_OAM_TX_BASE_ADDR,0x39,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_44t47_reg[]=
{
	{BAS_INSERT_CNT_44,FLEXE_OAM_TX_BASE_ADDR,0x3a,7,0},
	{BAS_INSERT_CNT_45,FLEXE_OAM_TX_BASE_ADDR,0x3a,15,8},
	{BAS_INSERT_CNT_46,FLEXE_OAM_TX_BASE_ADDR,0x3a,23,16},
	{BAS_INSERT_CNT_47,FLEXE_OAM_TX_BASE_ADDR,0x3a,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_48t51_reg[]=
{
	{BAS_INSERT_CNT_48,FLEXE_OAM_TX_BASE_ADDR,0x3b,7,0},
	{BAS_INSERT_CNT_49,FLEXE_OAM_TX_BASE_ADDR,0x3b,15,8},
	{BAS_INSERT_CNT_50,FLEXE_OAM_TX_BASE_ADDR,0x3b,23,16},
	{BAS_INSERT_CNT_51,FLEXE_OAM_TX_BASE_ADDR,0x3b,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_52t55_reg[]=
{
	{BAS_INSERT_CNT_52,FLEXE_OAM_TX_BASE_ADDR,0x3c,7,0},
	{BAS_INSERT_CNT_53,FLEXE_OAM_TX_BASE_ADDR,0x3c,15,8},
	{BAS_INSERT_CNT_54,FLEXE_OAM_TX_BASE_ADDR,0x3c,23,16},
	{BAS_INSERT_CNT_55,FLEXE_OAM_TX_BASE_ADDR,0x3c,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_56t59_reg[]=
{
	{BAS_INSERT_CNT_56,FLEXE_OAM_TX_BASE_ADDR,0x3d,7,0},
	{BAS_INSERT_CNT_57,FLEXE_OAM_TX_BASE_ADDR,0x3d,15,8},
	{BAS_INSERT_CNT_58,FLEXE_OAM_TX_BASE_ADDR,0x3d,23,16},
	{BAS_INSERT_CNT_59,FLEXE_OAM_TX_BASE_ADDR,0x3d,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_60t63_reg[]=
{
	{BAS_INSERT_CNT_60,FLEXE_OAM_TX_BASE_ADDR,0x3e,7,0},
	{BAS_INSERT_CNT_61,FLEXE_OAM_TX_BASE_ADDR,0x3e,15,8},
	{BAS_INSERT_CNT_62,FLEXE_OAM_TX_BASE_ADDR,0x3e,23,16},
	{BAS_INSERT_CNT_63,FLEXE_OAM_TX_BASE_ADDR,0x3e,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_64t67_reg[]=
{
	{BAS_INSERT_CNT_64,FLEXE_OAM_TX_BASE_ADDR,0x3f,7,0},
	{BAS_INSERT_CNT_65,FLEXE_OAM_TX_BASE_ADDR,0x3f,15,8},
	{BAS_INSERT_CNT_66,FLEXE_OAM_TX_BASE_ADDR,0x3f,23,16},
	{BAS_INSERT_CNT_67,FLEXE_OAM_TX_BASE_ADDR,0x3f,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_68t71_reg[]=
{
	{BAS_INSERT_CNT_68,FLEXE_OAM_TX_BASE_ADDR,0x40,7,0},
	{BAS_INSERT_CNT_69,FLEXE_OAM_TX_BASE_ADDR,0x40,15,8},
	{BAS_INSERT_CNT_70,FLEXE_OAM_TX_BASE_ADDR,0x40,23,16},
	{BAS_INSERT_CNT_71,FLEXE_OAM_TX_BASE_ADDR,0x40,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_72t75_reg[]=
{
	{BAS_INSERT_CNT_72,FLEXE_OAM_TX_BASE_ADDR,0x41,7,0},
	{BAS_INSERT_CNT_73,FLEXE_OAM_TX_BASE_ADDR,0x41,15,8},
	{BAS_INSERT_CNT_74,FLEXE_OAM_TX_BASE_ADDR,0x41,23,16},
	{BAS_INSERT_CNT_75,FLEXE_OAM_TX_BASE_ADDR,0x41,31,24},
};
const CHIP_REG flexe_bas_insert_cnt_76t79_reg[]=
{
	{BAS_INSERT_CNT_76,FLEXE_OAM_TX_BASE_ADDR,0x42,7,0},
	{BAS_INSERT_CNT_77,FLEXE_OAM_TX_BASE_ADDR,0x42,15,8},
	{BAS_INSERT_CNT_78,FLEXE_OAM_TX_BASE_ADDR,0x42,23,16},
	{BAS_INSERT_CNT_79,FLEXE_OAM_TX_BASE_ADDR,0x42,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_0t3_reg[]=
{
	{OTH_INSERT_CNT_0,FLEXE_OAM_TX_BASE_ADDR,0x43,7,0},
	{OTH_INSERT_CNT_1,FLEXE_OAM_TX_BASE_ADDR,0x43,15,8},
	{OTH_INSERT_CNT_2,FLEXE_OAM_TX_BASE_ADDR,0x43,23,16},
	{OTH_INSERT_CNT_3,FLEXE_OAM_TX_BASE_ADDR,0x43,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_4t7_reg[]=
{
	{OTH_INSERT_CNT_4,FLEXE_OAM_TX_BASE_ADDR,0x44,7,0},
	{OTH_INSERT_CNT_5,FLEXE_OAM_TX_BASE_ADDR,0x44,15,8},
	{OTH_INSERT_CNT_6,FLEXE_OAM_TX_BASE_ADDR,0x44,23,16},
	{OTH_INSERT_CNT_7,FLEXE_OAM_TX_BASE_ADDR,0x44,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_8t11_reg[]=
{
	{OTH_INSERT_CNT_8,FLEXE_OAM_TX_BASE_ADDR,0x45,7,0},
	{OTH_INSERT_CNT_9,FLEXE_OAM_TX_BASE_ADDR,0x45,15,8},
	{OTH_INSERT_CNT_10,FLEXE_OAM_TX_BASE_ADDR,0x45,23,16},
	{OTH_INSERT_CNT_11,FLEXE_OAM_TX_BASE_ADDR,0x45,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_12t15_reg[]=
{
	{OTH_INSERT_CNT_12,FLEXE_OAM_TX_BASE_ADDR,0x46,7,0},
	{OTH_INSERT_CNT_13,FLEXE_OAM_TX_BASE_ADDR,0x46,15,8},
	{OTH_INSERT_CNT_14,FLEXE_OAM_TX_BASE_ADDR,0x46,23,16},
	{OTH_INSERT_CNT_15,FLEXE_OAM_TX_BASE_ADDR,0x46,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_16t19_reg[]=
{
	{OTH_INSERT_CNT_16,FLEXE_OAM_TX_BASE_ADDR,0x47,7,0},
	{OTH_INSERT_CNT_17,FLEXE_OAM_TX_BASE_ADDR,0x47,15,8},
	{OTH_INSERT_CNT_18,FLEXE_OAM_TX_BASE_ADDR,0x47,23,16},
	{OTH_INSERT_CNT_19,FLEXE_OAM_TX_BASE_ADDR,0x47,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_20t23_reg[]=
{
	{OTH_INSERT_CNT_20,FLEXE_OAM_TX_BASE_ADDR,0x48,7,0},
	{OTH_INSERT_CNT_21,FLEXE_OAM_TX_BASE_ADDR,0x48,15,8},
	{OTH_INSERT_CNT_22,FLEXE_OAM_TX_BASE_ADDR,0x48,23,16},
	{OTH_INSERT_CNT_23,FLEXE_OAM_TX_BASE_ADDR,0x48,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_24t27_reg[]=
{
	{OTH_INSERT_CNT_24,FLEXE_OAM_TX_BASE_ADDR,0x49,7,0},
	{OTH_INSERT_CNT_25,FLEXE_OAM_TX_BASE_ADDR,0x49,15,8},
	{OTH_INSERT_CNT_26,FLEXE_OAM_TX_BASE_ADDR,0x49,23,16},
	{OTH_INSERT_CNT_27,FLEXE_OAM_TX_BASE_ADDR,0x49,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_28t31_reg[]=
{
	{OTH_INSERT_CNT_28,FLEXE_OAM_TX_BASE_ADDR,0x4a,7,0},
	{OTH_INSERT_CNT_29,FLEXE_OAM_TX_BASE_ADDR,0x4a,15,8},
	{OTH_INSERT_CNT_30,FLEXE_OAM_TX_BASE_ADDR,0x4a,23,16},
	{OTH_INSERT_CNT_31,FLEXE_OAM_TX_BASE_ADDR,0x4a,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_32t35_reg[]=
{
	{OTH_INSERT_CNT_32,FLEXE_OAM_TX_BASE_ADDR,0x4b,7,0},
	{OTH_INSERT_CNT_33,FLEXE_OAM_TX_BASE_ADDR,0x4b,15,8},
	{OTH_INSERT_CNT_34,FLEXE_OAM_TX_BASE_ADDR,0x4b,23,16},
	{OTH_INSERT_CNT_35,FLEXE_OAM_TX_BASE_ADDR,0x4b,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_36t39_reg[]=
{
	{OTH_INSERT_CNT_36,FLEXE_OAM_TX_BASE_ADDR,0x4c,7,0},
	{OTH_INSERT_CNT_37,FLEXE_OAM_TX_BASE_ADDR,0x4c,15,8},
	{OTH_INSERT_CNT_38,FLEXE_OAM_TX_BASE_ADDR,0x4c,23,16},
	{OTH_INSERT_CNT_39,FLEXE_OAM_TX_BASE_ADDR,0x4c,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_40t43_reg[]=
{
	{OTH_INSERT_CNT_40,FLEXE_OAM_TX_BASE_ADDR,0x4d,7,0},
	{OTH_INSERT_CNT_41,FLEXE_OAM_TX_BASE_ADDR,0x4d,15,8},
	{OTH_INSERT_CNT_42,FLEXE_OAM_TX_BASE_ADDR,0x4d,23,16},
	{OTH_INSERT_CNT_43,FLEXE_OAM_TX_BASE_ADDR,0x4d,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_44t47_reg[]=
{
	{OTH_INSERT_CNT_44,FLEXE_OAM_TX_BASE_ADDR,0x4e,7,0},
	{OTH_INSERT_CNT_45,FLEXE_OAM_TX_BASE_ADDR,0x4e,15,8},
	{OTH_INSERT_CNT_46,FLEXE_OAM_TX_BASE_ADDR,0x4e,23,16},
	{OTH_INSERT_CNT_47,FLEXE_OAM_TX_BASE_ADDR,0x4e,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_48t51_reg[]=
{
	{OTH_INSERT_CNT_48,FLEXE_OAM_TX_BASE_ADDR,0x4f,7,0},
	{OTH_INSERT_CNT_49,FLEXE_OAM_TX_BASE_ADDR,0x4f,15,8},
	{OTH_INSERT_CNT_50,FLEXE_OAM_TX_BASE_ADDR,0x4f,23,16},
	{OTH_INSERT_CNT_51,FLEXE_OAM_TX_BASE_ADDR,0x4f,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_52t55_reg[]=
{
	{OTH_INSERT_CNT_52,FLEXE_OAM_TX_BASE_ADDR,0x50,7,0},
	{OTH_INSERT_CNT_53,FLEXE_OAM_TX_BASE_ADDR,0x50,15,8},
	{OTH_INSERT_CNT_54,FLEXE_OAM_TX_BASE_ADDR,0x50,23,16},
	{OTH_INSERT_CNT_55,FLEXE_OAM_TX_BASE_ADDR,0x50,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_56t59_reg[]=
{
	{OTH_INSERT_CNT_56,FLEXE_OAM_TX_BASE_ADDR,0x51,7,0},
	{OTH_INSERT_CNT_57,FLEXE_OAM_TX_BASE_ADDR,0x51,15,8},
	{OTH_INSERT_CNT_58,FLEXE_OAM_TX_BASE_ADDR,0x51,23,16},
	{OTH_INSERT_CNT_59,FLEXE_OAM_TX_BASE_ADDR,0x51,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_60t63_reg[]=
{
	{OTH_INSERT_CNT_60,FLEXE_OAM_TX_BASE_ADDR,0x52,7,0},
	{OTH_INSERT_CNT_61,FLEXE_OAM_TX_BASE_ADDR,0x52,15,8},
	{OTH_INSERT_CNT_62,FLEXE_OAM_TX_BASE_ADDR,0x52,23,16},
	{OTH_INSERT_CNT_63,FLEXE_OAM_TX_BASE_ADDR,0x52,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_64t67_reg[]=
{
	{OTH_INSERT_CNT_64,FLEXE_OAM_TX_BASE_ADDR,0x53,7,0},
	{OTH_INSERT_CNT_65,FLEXE_OAM_TX_BASE_ADDR,0x53,15,8},
	{OTH_INSERT_CNT_66,FLEXE_OAM_TX_BASE_ADDR,0x53,23,16},
	{OTH_INSERT_CNT_67,FLEXE_OAM_TX_BASE_ADDR,0x53,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_68t71_reg[]=
{
	{OTH_INSERT_CNT_68,FLEXE_OAM_TX_BASE_ADDR,0x54,7,0},
	{OTH_INSERT_CNT_69,FLEXE_OAM_TX_BASE_ADDR,0x54,15,8},
	{OTH_INSERT_CNT_70,FLEXE_OAM_TX_BASE_ADDR,0x54,23,16},
	{OTH_INSERT_CNT_71,FLEXE_OAM_TX_BASE_ADDR,0x54,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_72t75_reg[]=
{
	{OTH_INSERT_CNT_72,FLEXE_OAM_TX_BASE_ADDR,0x55,7,0},
	{OTH_INSERT_CNT_73,FLEXE_OAM_TX_BASE_ADDR,0x55,15,8},
	{OTH_INSERT_CNT_74,FLEXE_OAM_TX_BASE_ADDR,0x55,23,16},
	{OTH_INSERT_CNT_75,FLEXE_OAM_TX_BASE_ADDR,0x55,31,24},
};
const CHIP_REG flexe_oth_insert_cnt_76t79_reg[]=
{
	{OTH_INSERT_CNT_76,FLEXE_OAM_TX_BASE_ADDR,0x56,7,0},
	{OTH_INSERT_CNT_77,FLEXE_OAM_TX_BASE_ADDR,0x56,15,8},
	{OTH_INSERT_CNT_78,FLEXE_OAM_TX_BASE_ADDR,0x56,23,16},
	{OTH_INSERT_CNT_79,FLEXE_OAM_TX_BASE_ADDR,0x56,31,24},
};
const CHIP_REG flexe_csf_lpi_reg[]=
{
	{CSF_LPI_0,FLEXE_OAM_TX_BASE_ADDR,0x57,31,0},
	{CSF_LPI_1,FLEXE_OAM_TX_BASE_ADDR,0x58,31,0},
	{CSF_LPI_2,FLEXE_OAM_TX_BASE_ADDR,0x59,15,0},
};
const CHIP_REG flexe_csf_lf_reg[]=
{
	{CSF_LF_0,FLEXE_OAM_TX_BASE_ADDR,0x5a,31,0},
	{CSF_LF_1,FLEXE_OAM_TX_BASE_ADDR,0x5b,31,0},
	{CSF_LF_2,FLEXE_OAM_TX_BASE_ADDR,0x5c,15,0},
};
const CHIP_REG flexe_csf_rf_reg[]=
{
	{CSF_RF_0,FLEXE_OAM_TX_BASE_ADDR,0x5d,31,0},
	{CSF_RF_1,FLEXE_OAM_TX_BASE_ADDR,0x5e,31,0},
	{CSF_RF_2,FLEXE_OAM_TX_BASE_ADDR,0x5f,15,0},
};
const CHIP_REG flexe_fifo_full_rei_reg[]=
{
	{FIFO_FULL_REI_0,FLEXE_OAM_TX_BASE_ADDR,0x60,31,0},
	{FIFO_FULL_REI_1,FLEXE_OAM_TX_BASE_ADDR,0x61,31,0},
	{FIFO_FULL_REI_2,FLEXE_OAM_TX_BASE_ADDR,0x62,15,0},
};
const CHIP_REG flexe_fifo_full_aps_reg[]=
{
	{FIFO_FULL_APS_0,FLEXE_OAM_TX_BASE_ADDR,0x63,31,0},
	{FIFO_FULL_APS_1,FLEXE_OAM_TX_BASE_ADDR,0x64,31,0},
	{FIFO_FULL_APS_2,FLEXE_OAM_TX_BASE_ADDR,0x65,15,0},
};
const CHIP_REG flexe_fifo_full_low_reg[]=
{
	{FIFO_FULL_LOW_0,FLEXE_OAM_TX_BASE_ADDR,0x66,31,0},
	{FIFO_FULL_LOW_1,FLEXE_OAM_TX_BASE_ADDR,0x67,31,0},
	{FIFO_FULL_LOW_2,FLEXE_OAM_TX_BASE_ADDR,0x68,15,0},
};
const CHIP_REG flexe_data_err_pulse_reg[]=
{
	{DATA_ERR_PULSE_0,FLEXE_OAM_TX_BASE_ADDR,0x69,31,0},
	{DATA_ERR_PULSE_1,FLEXE_OAM_TX_BASE_ADDR,0x6a,31,0},
	{DATA_ERR_PULSE_2,FLEXE_OAM_TX_BASE_ADDR,0x6b,15,0},
};
const CHIP_REG flexe_bas_brk_cnt_reg[]=
{
	{BAS_BRK_CNT,FLEXE_OAM_TX_BASE_ADDR,0x6c,2,0},
};
const CHIP_REG flexe_bas_cnt_reg[]=
{
	{BAS_CNT,FLEXE_OAM_TX_BASE_ADDR,0xb0,31,0},
};
const CHIP_REG flexe_aps_cnt_reg[]=
{
	{APS_CNT,FLEXE_OAM_TX_BASE_ADDR,0xb1,31,0},
};
const CHIP_REG flexe_low_cnt_reg[]=
{
	{LOW_CNT,FLEXE_OAM_TX_BASE_ADDR,0xb2,31,0},
};
const CHIP_REG flexe_new_cnt_reg[]=
{
	{NEW_CNT,FLEXE_OAM_TX_BASE_ADDR,0xb3,31,0},
};
const CHIP_REG flexe_timestamp_lock_reg[]=
{
	{TIMESTAMP_LOCK_0,FLEXE_OAM_TX_BASE_ADDR,0xbb,31,0},
	{TIMESTAMP_LOCK_1,FLEXE_OAM_TX_BASE_ADDR,0xbc,31,0},
};
const CHIP_REG flexe_bas_period_cfg01_REG[]=
{
	{BAS_PERIOD_CFG0,FLEXE_OAM_TX_BASE_ADDR,0x6d,8,0},
	{BAS_PERIOD_CFG1,FLEXE_OAM_TX_BASE_ADDR,0x6d,17,9},
};
const CHIP_REG flexe_bas_period_cfg23_REG[]=
{
	{BAS_PERIOD_CFG2,FLEXE_OAM_TX_BASE_ADDR,0x6e,8,0},
	{BAS_PERIOD_CFG3,FLEXE_OAM_TX_BASE_ADDR,0x6e,17,9},
};
const CHIP_REG flexe_bas_en_cfg_asic_REG[]=
{
	{BAS_EN_CFG_ASIC_0,FLEXE_OAM_TX_BASE_ADDR,0x70,31,0},
	{BAS_EN_CFG_ASIC_1,FLEXE_OAM_TX_BASE_ADDR,0x71,31,0},
	{BAS_EN_CFG_ASIC_2,FLEXE_OAM_TX_BASE_ADDR,0x72,15,0},
};
const CHIP_REG flexe_oam_pri_encode_REG[]=
{
	{OAM_PRI_ENCODE,FLEXE_OAM_TX_BASE_ADDR,0x73,1,0},
	{BAS_SOURCE_SEL,FLEXE_OAM_TX_BASE_ADDR,0x73,2,2},
};
const CHIP_REG flexe_tx_ohif_fifo_sel_REG[]=
{
	{TX_OHIF_FIFO_SEL_0,FLEXE_OAM_TX_BASE_ADDR,0x74,31,0},
	{TX_OHIF_FIFO_SEL_1,FLEXE_OAM_TX_BASE_ADDR,0x75,31,0},
	{TX_OHIF_FIFO_SEL_2,FLEXE_OAM_TX_BASE_ADDR,0x76,31,0},
	{TX_OHIF_FIFO_SEL_3,FLEXE_OAM_TX_BASE_ADDR,0x77,31,0},
};
const CHIP_REG flexe_new_cfg_REG[]=
{
	{NEW_PERIOD_CFG,FLEXE_OAM_TX_BASE_ADDR,0xc0,8,0},
	{APS_PERIOD_CFG,FLEXE_OAM_TX_BASE_ADDR,0xc0,20,12},
};
const CHIP_REG flexe_tx_bas_fifo_num_REG[]=
{
	{TX_BAS_FIFO_NUM,FLEXE_OAM_TX_BASE_ADDR,0xc1,5,0},
};
const CHIP_REG flexe_tx_lpi_setclr_cfg_REG[]=
{
	{LPI_PRE_CNT,FLEXE_OAM_TX_BASE_ADDR,0xc2,2,0},
	{LPI_POS_CNT,FLEXE_OAM_TX_BASE_ADDR,0xc2,6,4},
};
const CHIP_REG flexe_tx_insert_66bcode_cfg_REG[]=
{
	{OAM_TX_INSERT_66BCODE_CFG_0,FLEXE_OAM_TX_BASE_ADDR,0xc3,31,0},
	{OAM_TX_INSERT_66BCODE_CFG_1,FLEXE_OAM_TX_BASE_ADDR,0xc4,31,0},
	{OAM_TX_INSERT_66BCODE_CFG_2,FLEXE_OAM_TX_BASE_ADDR,0xc5,15,0},
};
const CHIP_REG flexe_oam_joit_bip_cfg2_reg[]=
{
	{OAM_JOIT_BIP_CFG_0,FLEXE_OAM_TX_BASE_ADDR,0xc6,31,0},
	{OAM_JOIT_BIP_CFG_1,FLEXE_OAM_TX_BASE_ADDR,0xc7,31,0},
};
const CHIP_REG flexe_tx_lpi_bas_ins_en_reg[]=
{
	{TX_LPI_BAS_INS_EN_0,FLEXE_OAM_TX_BASE_ADDR,0xc8,31,0},
	{TX_LPI_BAS_INS_EN_1,FLEXE_OAM_TX_BASE_ADDR,0xc9,31,0},
	{TX_LPI_BAS_INS_EN_2,FLEXE_OAM_TX_BASE_ADDR,0xca,15,0},
};
const CHIP_REG flexe_bas_crc_err_en_reg[]=
{
	{TX_BAS_CRC_ERR_EN_0,FLEXE_OAM_TX_BASE_ADDR,0xcb,31,0},
	{TX_BAS_CRC_ERR_EN_1,FLEXE_OAM_TX_BASE_ADDR,0xcc,31,0},
	{TX_BAS_CRC_ERR_EN_2,FLEXE_OAM_TX_BASE_ADDR,0xcd,15,0},
	{TX_BAS_CRC_ERR_MASK,FLEXE_OAM_TX_BASE_ADDR,0xcd,19,16},
};
const CHIP_REG flexe_oam_cnt_cfg_reg[]=
{
	{OAM_CNT_CH_CFG,FLEXE_OAM_TX_BASE_ADDR,0xb4,6,0},
	{TX_OAM_CNT_CLR,FLEXE_OAM_TX_BASE_ADDR,0xb4,7,7},
};
const CHIP_REG flexe_tx_lpi_idle_rpl_en_reg[]=
{
	{TX_LPI_IDLE_RPL_EN_0,FLEXE_OAM_TX_BASE_ADDR,0xb5,31,0},
	{TX_LPI_IDLE_RPL_EN_1,FLEXE_OAM_TX_BASE_ADDR,0xb6,31,0},
	{TX_LPI_IDLE_RPL_EN_2,FLEXE_OAM_TX_BASE_ADDR,0xb7,15,0},
};
const CHIP_REG flexe_tx_insert_66bcode_en_REG[]=
{
	{TX_INSERT_66BCODE_EN_0,FLEXE_OAM_TX_BASE_ADDR,0xbd,31,0},
	{TX_INSERT_66BCODE_EN_1,FLEXE_OAM_TX_BASE_ADDR,0xbe,31,0},
	{TX_INSERT_66BCODE_EN_2,FLEXE_OAM_TX_BASE_ADDR,0xbf,15,0},
};
const CHIP_REG flexe_fifo_full_bas_REG[]=
{
	{FIFO_FULL_BAS_0,FLEXE_OAM_TX_BASE_ADDR,0x78,31,0},
	{FIFO_FULL_BAS_1,FLEXE_OAM_TX_BASE_ADDR,0x79,31,0},
	{FIFO_FULL_BAS_2,FLEXE_OAM_TX_BASE_ADDR,0x7a,15,0},
};
const CHIP_REG flexe_fifo_full_new_REG[]=
{
	{FIFO_FULL_NEW_0,FLEXE_OAM_TX_BASE_ADDR,0x7b,31,0},
	{FIFO_FULL_NEW_1,FLEXE_OAM_TX_BASE_ADDR,0x7c,31,0},
	{FIFO_FULL_NEW_2,FLEXE_OAM_TX_BASE_ADDR,0x7d,15,0},
};
const CHIP_REG flexe_fifo_empty_bas_reg[]=
{
	{FIFO_EMPTY_BAS_0,FLEXE_OAM_TX_BASE_ADDR,0xb8,31,0},
	{FIFO_EMPTY_BAS_1,FLEXE_OAM_TX_BASE_ADDR,0xb9,31,0},
	{FIFO_EMPTY_BAS_2,FLEXE_OAM_TX_BASE_ADDR,0xba,15,0},
};
const CHIP_REG flexe_csf_lpi_i0_INT_REG[]=
{
	{CSF_LPI_0_INT,FLEXE_OAM_TX_BASE_ADDR,0x80,1,0},
	{CSF_LPI_1_INT,FLEXE_OAM_TX_BASE_ADDR,0x80,3,2},
	{CSF_LPI_2_INT,FLEXE_OAM_TX_BASE_ADDR,0x80,5,4},
	{CSF_LPI_3_INT,FLEXE_OAM_TX_BASE_ADDR,0x80,7,6},
	{CSF_LPI_4_INT,FLEXE_OAM_TX_BASE_ADDR,0x80,9,8},
	{CSF_LPI_5_INT,FLEXE_OAM_TX_BASE_ADDR,0x80,11,10},
	{CSF_LPI_6_INT,FLEXE_OAM_TX_BASE_ADDR,0x80,13,12},
	{CSF_LPI_7_INT,FLEXE_OAM_TX_BASE_ADDR,0x80,15,14},
	{CSF_LPI_8_INT,FLEXE_OAM_TX_BASE_ADDR,0x80,17,16},
	{CSF_LPI_9_INT,FLEXE_OAM_TX_BASE_ADDR,0x80,19,18},
};
const CHIP_REG flexe_csf_lpi_i0_INT_MASK_REG[]=
{
	{CSF_LPI_0_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x81,1,0},
	{CSF_LPI_1_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x81,3,2},
	{CSF_LPI_2_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x81,5,4},
	{CSF_LPI_3_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x81,7,6},
	{CSF_LPI_4_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x81,9,8},
	{CSF_LPI_5_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x81,11,10},
	{CSF_LPI_6_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x81,13,12},
	{CSF_LPI_7_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x81,15,14},
	{CSF_LPI_8_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x81,17,16},
	{CSF_LPI_9_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x81,19,18},
};
const CHIP_REG flexe_csf_lpi_i1_INT_REG[]=
{
	{CSF_LPI_10_INT,FLEXE_OAM_TX_BASE_ADDR,0x82,1,0},
	{CSF_LPI_11_INT,FLEXE_OAM_TX_BASE_ADDR,0x82,3,2},
	{CSF_LPI_12_INT,FLEXE_OAM_TX_BASE_ADDR,0x82,5,4},
	{CSF_LPI_13_INT,FLEXE_OAM_TX_BASE_ADDR,0x82,7,6},
	{CSF_LPI_14_INT,FLEXE_OAM_TX_BASE_ADDR,0x82,9,8},
	{CSF_LPI_15_INT,FLEXE_OAM_TX_BASE_ADDR,0x82,11,10},
	{CSF_LPI_16_INT,FLEXE_OAM_TX_BASE_ADDR,0x82,13,12},
	{CSF_LPI_17_INT,FLEXE_OAM_TX_BASE_ADDR,0x82,15,14},
	{CSF_LPI_18_INT,FLEXE_OAM_TX_BASE_ADDR,0x82,17,16},
	{CSF_LPI_19_INT,FLEXE_OAM_TX_BASE_ADDR,0x82,19,18},
};
const CHIP_REG flexe_csf_lpi_i1_INT_MASK_REG[]=
{
	{CSF_LPI_10_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x83,1,0},
	{CSF_LPI_11_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x83,3,2},
	{CSF_LPI_12_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x83,5,4},
	{CSF_LPI_13_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x83,7,6},
	{CSF_LPI_14_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x83,9,8},
	{CSF_LPI_15_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x83,11,10},
	{CSF_LPI_16_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x83,13,12},
	{CSF_LPI_17_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x83,15,14},
	{CSF_LPI_18_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x83,17,16},
	{CSF_LPI_19_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x83,19,18},
};
const CHIP_REG flexe_csf_lpi_i2_INT_REG[]=
{
	{CSF_LPI_20_INT,FLEXE_OAM_TX_BASE_ADDR,0x84,1,0},
	{CSF_LPI_21_INT,FLEXE_OAM_TX_BASE_ADDR,0x84,3,2},
	{CSF_LPI_22_INT,FLEXE_OAM_TX_BASE_ADDR,0x84,5,4},
	{CSF_LPI_23_INT,FLEXE_OAM_TX_BASE_ADDR,0x84,7,6},
	{CSF_LPI_24_INT,FLEXE_OAM_TX_BASE_ADDR,0x84,9,8},
	{CSF_LPI_25_INT,FLEXE_OAM_TX_BASE_ADDR,0x84,11,10},
	{CSF_LPI_26_INT,FLEXE_OAM_TX_BASE_ADDR,0x84,13,12},
	{CSF_LPI_27_INT,FLEXE_OAM_TX_BASE_ADDR,0x84,15,14},
	{CSF_LPI_28_INT,FLEXE_OAM_TX_BASE_ADDR,0x84,17,16},
	{CSF_LPI_29_INT,FLEXE_OAM_TX_BASE_ADDR,0x84,19,18},
};
const CHIP_REG flexe_csf_lpi_i2_INT_MASK_REG[]=
{
	{CSF_LPI_20_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x85,1,0},
	{CSF_LPI_21_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x85,3,2},
	{CSF_LPI_22_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x85,5,4},
	{CSF_LPI_23_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x85,7,6},
	{CSF_LPI_24_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x85,9,8},
	{CSF_LPI_25_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x85,11,10},
	{CSF_LPI_26_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x85,13,12},
	{CSF_LPI_27_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x85,15,14},
	{CSF_LPI_28_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x85,17,16},
	{CSF_LPI_29_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x85,19,18},
};
const CHIP_REG flexe_csf_lpi_i3_INT_REG[]=
{
	{CSF_LPI_30_INT,FLEXE_OAM_TX_BASE_ADDR,0x86,1,0},
	{CSF_LPI_31_INT,FLEXE_OAM_TX_BASE_ADDR,0x86,3,2},
	{CSF_LPI_32_INT,FLEXE_OAM_TX_BASE_ADDR,0x86,5,4},
	{CSF_LPI_33_INT,FLEXE_OAM_TX_BASE_ADDR,0x86,7,6},
	{CSF_LPI_34_INT,FLEXE_OAM_TX_BASE_ADDR,0x86,9,8},
	{CSF_LPI_35_INT,FLEXE_OAM_TX_BASE_ADDR,0x86,11,10},
	{CSF_LPI_36_INT,FLEXE_OAM_TX_BASE_ADDR,0x86,13,12},
	{CSF_LPI_37_INT,FLEXE_OAM_TX_BASE_ADDR,0x86,15,14},
	{CSF_LPI_38_INT,FLEXE_OAM_TX_BASE_ADDR,0x86,17,16},
	{CSF_LPI_39_INT,FLEXE_OAM_TX_BASE_ADDR,0x86,19,18},
};
const CHIP_REG flexe_csf_lpi_i3_INT_MASK_REG[]=
{
	{CSF_LPI_30_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x87,1,0},
	{CSF_LPI_31_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x87,3,2},
	{CSF_LPI_32_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x87,5,4},
	{CSF_LPI_33_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x87,7,6},
	{CSF_LPI_34_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x87,9,8},
	{CSF_LPI_35_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x87,11,10},
	{CSF_LPI_36_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x87,13,12},
	{CSF_LPI_37_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x87,15,14},
	{CSF_LPI_38_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x87,17,16},
	{CSF_LPI_39_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x87,19,18},
};
const CHIP_REG flexe_csf_lpi_i4_INT_REG[]=
{
	{CSF_LPI_40_INT,FLEXE_OAM_TX_BASE_ADDR,0x88,1,0},
	{CSF_LPI_41_INT,FLEXE_OAM_TX_BASE_ADDR,0x88,3,2},
	{CSF_LPI_42_INT,FLEXE_OAM_TX_BASE_ADDR,0x88,5,4},
	{CSF_LPI_43_INT,FLEXE_OAM_TX_BASE_ADDR,0x88,7,6},
	{CSF_LPI_44_INT,FLEXE_OAM_TX_BASE_ADDR,0x88,9,8},
	{CSF_LPI_45_INT,FLEXE_OAM_TX_BASE_ADDR,0x88,11,10},
	{CSF_LPI_46_INT,FLEXE_OAM_TX_BASE_ADDR,0x88,13,12},
	{CSF_LPI_47_INT,FLEXE_OAM_TX_BASE_ADDR,0x88,15,14},
	{CSF_LPI_48_INT,FLEXE_OAM_TX_BASE_ADDR,0x88,17,16},
	{CSF_LPI_49_INT,FLEXE_OAM_TX_BASE_ADDR,0x88,19,18},
};
const CHIP_REG flexe_csf_lpi_i4_INT_MASK_REG[]=
{
	{CSF_LPI_40_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x89,1,0},
	{CSF_LPI_41_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x89,3,2},
	{CSF_LPI_42_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x89,5,4},
	{CSF_LPI_43_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x89,7,6},
	{CSF_LPI_44_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x89,9,8},
	{CSF_LPI_45_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x89,11,10},
	{CSF_LPI_46_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x89,13,12},
	{CSF_LPI_47_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x89,15,14},
	{CSF_LPI_48_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x89,17,16},
	{CSF_LPI_49_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x89,19,18},
};
const CHIP_REG flexe_csf_lpi_i5_INT_REG[]=
{
	{CSF_LPI_50_INT,FLEXE_OAM_TX_BASE_ADDR,0x8a,1,0},
	{CSF_LPI_51_INT,FLEXE_OAM_TX_BASE_ADDR,0x8a,3,2},
	{CSF_LPI_52_INT,FLEXE_OAM_TX_BASE_ADDR,0x8a,5,4},
	{CSF_LPI_53_INT,FLEXE_OAM_TX_BASE_ADDR,0x8a,7,6},
	{CSF_LPI_54_INT,FLEXE_OAM_TX_BASE_ADDR,0x8a,9,8},
	{CSF_LPI_55_INT,FLEXE_OAM_TX_BASE_ADDR,0x8a,11,10},
	{CSF_LPI_56_INT,FLEXE_OAM_TX_BASE_ADDR,0x8a,13,12},
	{CSF_LPI_57_INT,FLEXE_OAM_TX_BASE_ADDR,0x8a,15,14},
	{CSF_LPI_58_INT,FLEXE_OAM_TX_BASE_ADDR,0x8a,17,16},
	{CSF_LPI_59_INT,FLEXE_OAM_TX_BASE_ADDR,0x8a,19,18},
};
const CHIP_REG flexe_csf_lpi_i5_INT_MASK_REG[]=
{
	{CSF_LPI_50_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8b,1,0},
	{CSF_LPI_51_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8b,3,2},
	{CSF_LPI_52_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8b,5,4},
	{CSF_LPI_53_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8b,7,6},
	{CSF_LPI_54_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8b,9,8},
	{CSF_LPI_55_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8b,11,10},
	{CSF_LPI_56_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8b,13,12},
	{CSF_LPI_57_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8b,15,14},
	{CSF_LPI_58_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8b,17,16},
	{CSF_LPI_59_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8b,19,18},
};
const CHIP_REG flexe_csf_lpi_i6_INT_REG[]=
{
	{CSF_LPI_60_INT,FLEXE_OAM_TX_BASE_ADDR,0x8c,1,0},
	{CSF_LPI_61_INT,FLEXE_OAM_TX_BASE_ADDR,0x8c,3,2},
	{CSF_LPI_62_INT,FLEXE_OAM_TX_BASE_ADDR,0x8c,5,4},
	{CSF_LPI_63_INT,FLEXE_OAM_TX_BASE_ADDR,0x8c,7,6},
	{CSF_LPI_64_INT,FLEXE_OAM_TX_BASE_ADDR,0x8c,9,8},
	{CSF_LPI_65_INT,FLEXE_OAM_TX_BASE_ADDR,0x8c,11,10},
	{CSF_LPI_66_INT,FLEXE_OAM_TX_BASE_ADDR,0x8c,13,12},
	{CSF_LPI_67_INT,FLEXE_OAM_TX_BASE_ADDR,0x8c,15,14},
	{CSF_LPI_68_INT,FLEXE_OAM_TX_BASE_ADDR,0x8c,17,16},
	{CSF_LPI_69_INT,FLEXE_OAM_TX_BASE_ADDR,0x8c,19,18},
};
const CHIP_REG flexe_csf_lpi_i6_INT_MASK_REG[]=
{
	{CSF_LPI_60_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8d,1,0},
	{CSF_LPI_61_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8d,3,2},
	{CSF_LPI_62_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8d,5,4},
	{CSF_LPI_63_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8d,7,6},
	{CSF_LPI_64_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8d,9,8},
	{CSF_LPI_65_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8d,11,10},
	{CSF_LPI_66_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8d,13,12},
	{CSF_LPI_67_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8d,15,14},
	{CSF_LPI_68_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8d,17,16},
	{CSF_LPI_69_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8d,19,18},
};
const CHIP_REG flexe_csf_lpi_i7_INT_REG[]=
{
	{CSF_LPI_70_INT,FLEXE_OAM_TX_BASE_ADDR,0x8e,1,0},
	{CSF_LPI_71_INT,FLEXE_OAM_TX_BASE_ADDR,0x8e,3,2},
	{CSF_LPI_72_INT,FLEXE_OAM_TX_BASE_ADDR,0x8e,5,4},
	{CSF_LPI_73_INT,FLEXE_OAM_TX_BASE_ADDR,0x8e,7,6},
	{CSF_LPI_74_INT,FLEXE_OAM_TX_BASE_ADDR,0x8e,9,8},
	{CSF_LPI_75_INT,FLEXE_OAM_TX_BASE_ADDR,0x8e,11,10},
	{CSF_LPI_76_INT,FLEXE_OAM_TX_BASE_ADDR,0x8e,13,12},
	{CSF_LPI_77_INT,FLEXE_OAM_TX_BASE_ADDR,0x8e,15,14},
	{CSF_LPI_78_INT,FLEXE_OAM_TX_BASE_ADDR,0x8e,17,16},
	{CSF_LPI_79_INT,FLEXE_OAM_TX_BASE_ADDR,0x8e,19,18},
};
const CHIP_REG flexe_csf_lpi_i7_INT_MASK_REG[]=
{
	{CSF_LPI_70_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8f,1,0},
	{CSF_LPI_71_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8f,3,2},
	{CSF_LPI_72_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8f,5,4},
	{CSF_LPI_73_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8f,7,6},
	{CSF_LPI_74_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8f,9,8},
	{CSF_LPI_75_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8f,11,10},
	{CSF_LPI_76_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8f,13,12},
	{CSF_LPI_77_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8f,15,14},
	{CSF_LPI_78_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8f,17,16},
	{CSF_LPI_79_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x8f,19,18},
};
const CHIP_REG flexe_csf_lf_i0_INT_REG[]=
{
	{CSF_LF_0_INT,FLEXE_OAM_TX_BASE_ADDR,0x90,1,0},
	{CSF_LF_1_INT,FLEXE_OAM_TX_BASE_ADDR,0x90,3,2},
	{CSF_LF_2_INT,FLEXE_OAM_TX_BASE_ADDR,0x90,5,4},
	{CSF_LF_3_INT,FLEXE_OAM_TX_BASE_ADDR,0x90,7,6},
	{CSF_LF_4_INT,FLEXE_OAM_TX_BASE_ADDR,0x90,9,8},
	{CSF_LF_5_INT,FLEXE_OAM_TX_BASE_ADDR,0x90,11,10},
	{CSF_LF_6_INT,FLEXE_OAM_TX_BASE_ADDR,0x90,13,12},
	{CSF_LF_7_INT,FLEXE_OAM_TX_BASE_ADDR,0x90,15,14},
	{CSF_LF_8_INT,FLEXE_OAM_TX_BASE_ADDR,0x90,17,16},
	{CSF_LF_9_INT,FLEXE_OAM_TX_BASE_ADDR,0x90,19,18},
};
const CHIP_REG flexe_csf_lf_i0_INT_MASK_REG[]=
{
	{CSF_LF_0_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x91,1,0},
	{CSF_LF_1_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x91,3,2},
	{CSF_LF_2_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x91,5,4},
	{CSF_LF_3_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x91,7,6},
	{CSF_LF_4_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x91,9,8},
	{CSF_LF_5_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x91,11,10},
	{CSF_LF_6_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x91,13,12},
	{CSF_LF_7_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x91,15,14},
	{CSF_LF_8_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x91,17,16},
	{CSF_LF_9_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x91,19,18},
};
const CHIP_REG flexe_csf_lf_i1_INT_REG[]=
{
	{CSF_LF_10_INT,FLEXE_OAM_TX_BASE_ADDR,0x92,1,0},
	{CSF_LF_11_INT,FLEXE_OAM_TX_BASE_ADDR,0x92,3,2},
	{CSF_LF_12_INT,FLEXE_OAM_TX_BASE_ADDR,0x92,5,4},
	{CSF_LF_13_INT,FLEXE_OAM_TX_BASE_ADDR,0x92,7,6},
	{CSF_LF_14_INT,FLEXE_OAM_TX_BASE_ADDR,0x92,9,8},
	{CSF_LF_15_INT,FLEXE_OAM_TX_BASE_ADDR,0x92,11,10},
	{CSF_LF_16_INT,FLEXE_OAM_TX_BASE_ADDR,0x92,13,12},
	{CSF_LF_17_INT,FLEXE_OAM_TX_BASE_ADDR,0x92,15,14},
	{CSF_LF_18_INT,FLEXE_OAM_TX_BASE_ADDR,0x92,17,16},
	{CSF_LF_19_INT,FLEXE_OAM_TX_BASE_ADDR,0x92,19,18},
};
const CHIP_REG flexe_csf_lf_i1_INT_MASK_REG[]=
{
	{CSF_LF_10_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x93,1,0},
	{CSF_LF_11_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x93,3,2},
	{CSF_LF_12_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x93,5,4},
	{CSF_LF_13_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x93,7,6},
	{CSF_LF_14_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x93,9,8},
	{CSF_LF_15_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x93,11,10},
	{CSF_LF_16_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x93,13,12},
	{CSF_LF_17_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x93,15,14},
	{CSF_LF_18_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x93,17,16},
	{CSF_LF_19_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x93,19,18},
};
const CHIP_REG flexe_csf_lf_i2_INT_REG[]=
{
	{CSF_LF_20_INT,FLEXE_OAM_TX_BASE_ADDR,0x94,1,0},
	{CSF_LF_21_INT,FLEXE_OAM_TX_BASE_ADDR,0x94,3,2},
	{CSF_LF_22_INT,FLEXE_OAM_TX_BASE_ADDR,0x94,5,4},
	{CSF_LF_23_INT,FLEXE_OAM_TX_BASE_ADDR,0x94,7,6},
	{CSF_LF_24_INT,FLEXE_OAM_TX_BASE_ADDR,0x94,9,8},
	{CSF_LF_25_INT,FLEXE_OAM_TX_BASE_ADDR,0x94,11,10},
	{CSF_LF_26_INT,FLEXE_OAM_TX_BASE_ADDR,0x94,13,12},
	{CSF_LF_27_INT,FLEXE_OAM_TX_BASE_ADDR,0x94,15,14},
	{CSF_LF_28_INT,FLEXE_OAM_TX_BASE_ADDR,0x94,17,16},
	{CSF_LF_29_INT,FLEXE_OAM_TX_BASE_ADDR,0x94,19,18},
};
const CHIP_REG flexe_csf_lf_i2_INT_MASK_REG[]=
{
	{CSF_LF_20_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x95,1,0},
	{CSF_LF_21_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x95,3,2},
	{CSF_LF_22_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x95,5,4},
	{CSF_LF_23_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x95,7,6},
	{CSF_LF_24_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x95,9,8},
	{CSF_LF_25_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x95,11,10},
	{CSF_LF_26_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x95,13,12},
	{CSF_LF_27_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x95,15,14},
	{CSF_LF_28_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x95,17,16},
	{CSF_LF_29_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x95,19,18},
};
const CHIP_REG flexe_csf_lf_i3_INT_REG[]=
{
	{CSF_LF_30_INT,FLEXE_OAM_TX_BASE_ADDR,0x96,1,0},
	{CSF_LF_31_INT,FLEXE_OAM_TX_BASE_ADDR,0x96,3,2},
	{CSF_LF_32_INT,FLEXE_OAM_TX_BASE_ADDR,0x96,5,4},
	{CSF_LF_33_INT,FLEXE_OAM_TX_BASE_ADDR,0x96,7,6},
	{CSF_LF_34_INT,FLEXE_OAM_TX_BASE_ADDR,0x96,9,8},
	{CSF_LF_35_INT,FLEXE_OAM_TX_BASE_ADDR,0x96,11,10},
	{CSF_LF_36_INT,FLEXE_OAM_TX_BASE_ADDR,0x96,13,12},
	{CSF_LF_37_INT,FLEXE_OAM_TX_BASE_ADDR,0x96,15,14},
	{CSF_LF_38_INT,FLEXE_OAM_TX_BASE_ADDR,0x96,17,16},
	{CSF_LF_39_INT,FLEXE_OAM_TX_BASE_ADDR,0x96,19,18},
};
const CHIP_REG flexe_csf_lf_i3_INT_MASK_REG[]=
{
	{CSF_LF_30_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x97,1,0},
	{CSF_LF_31_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x97,3,2},
	{CSF_LF_32_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x97,5,4},
	{CSF_LF_33_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x97,7,6},
	{CSF_LF_34_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x97,9,8},
	{CSF_LF_35_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x97,11,10},
	{CSF_LF_36_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x97,13,12},
	{CSF_LF_37_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x97,15,14},
	{CSF_LF_38_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x97,17,16},
	{CSF_LF_39_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x97,19,18},
};
const CHIP_REG flexe_csf_lf_i4_INT_REG[]=
{
	{CSF_LF_40_INT,FLEXE_OAM_TX_BASE_ADDR,0x98,1,0},
	{CSF_LF_41_INT,FLEXE_OAM_TX_BASE_ADDR,0x98,3,2},
	{CSF_LF_42_INT,FLEXE_OAM_TX_BASE_ADDR,0x98,5,4},
	{CSF_LF_43_INT,FLEXE_OAM_TX_BASE_ADDR,0x98,7,6},
	{CSF_LF_44_INT,FLEXE_OAM_TX_BASE_ADDR,0x98,9,8},
	{CSF_LF_45_INT,FLEXE_OAM_TX_BASE_ADDR,0x98,11,10},
	{CSF_LF_46_INT,FLEXE_OAM_TX_BASE_ADDR,0x98,13,12},
	{CSF_LF_47_INT,FLEXE_OAM_TX_BASE_ADDR,0x98,15,14},
	{CSF_LF_48_INT,FLEXE_OAM_TX_BASE_ADDR,0x98,17,16},
	{CSF_LF_49_INT,FLEXE_OAM_TX_BASE_ADDR,0x98,19,18},
};
const CHIP_REG flexe_csf_lf_i4_INT_MASK_REG[]=
{
	{CSF_LF_40_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x99,1,0},
	{CSF_LF_41_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x99,3,2},
	{CSF_LF_42_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x99,5,4},
	{CSF_LF_43_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x99,7,6},
	{CSF_LF_44_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x99,9,8},
	{CSF_LF_45_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x99,11,10},
	{CSF_LF_46_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x99,13,12},
	{CSF_LF_47_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x99,15,14},
	{CSF_LF_48_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x99,17,16},
	{CSF_LF_49_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x99,19,18},
};
const CHIP_REG flexe_csf_lf_i5_INT_REG[]=
{
	{CSF_LF_50_INT,FLEXE_OAM_TX_BASE_ADDR,0x9a,1,0},
	{CSF_LF_51_INT,FLEXE_OAM_TX_BASE_ADDR,0x9a,3,2},
	{CSF_LF_52_INT,FLEXE_OAM_TX_BASE_ADDR,0x9a,5,4},
	{CSF_LF_53_INT,FLEXE_OAM_TX_BASE_ADDR,0x9a,7,6},
	{CSF_LF_54_INT,FLEXE_OAM_TX_BASE_ADDR,0x9a,9,8},
	{CSF_LF_55_INT,FLEXE_OAM_TX_BASE_ADDR,0x9a,11,10},
	{CSF_LF_56_INT,FLEXE_OAM_TX_BASE_ADDR,0x9a,13,12},
	{CSF_LF_57_INT,FLEXE_OAM_TX_BASE_ADDR,0x9a,15,14},
	{CSF_LF_58_INT,FLEXE_OAM_TX_BASE_ADDR,0x9a,17,16},
	{CSF_LF_59_INT,FLEXE_OAM_TX_BASE_ADDR,0x9a,19,18},
};
const CHIP_REG flexe_csf_lf_i5_INT_MASK_REG[]=
{
	{CSF_LF_50_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9b,1,0},
	{CSF_LF_51_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9b,3,2},
	{CSF_LF_52_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9b,5,4},
	{CSF_LF_53_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9b,7,6},
	{CSF_LF_54_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9b,9,8},
	{CSF_LF_55_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9b,11,10},
	{CSF_LF_56_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9b,13,12},
	{CSF_LF_57_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9b,15,14},
	{CSF_LF_58_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9b,17,16},
	{CSF_LF_59_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9b,19,18},
};
const CHIP_REG flexe_csf_lf_i6_INT_REG[]=
{
	{CSF_LF_60_INT,FLEXE_OAM_TX_BASE_ADDR,0x9c,1,0},
	{CSF_LF_61_INT,FLEXE_OAM_TX_BASE_ADDR,0x9c,3,2},
	{CSF_LF_62_INT,FLEXE_OAM_TX_BASE_ADDR,0x9c,5,4},
	{CSF_LF_63_INT,FLEXE_OAM_TX_BASE_ADDR,0x9c,7,6},
	{CSF_LF_64_INT,FLEXE_OAM_TX_BASE_ADDR,0x9c,9,8},
	{CSF_LF_65_INT,FLEXE_OAM_TX_BASE_ADDR,0x9c,11,10},
	{CSF_LF_66_INT,FLEXE_OAM_TX_BASE_ADDR,0x9c,13,12},
	{CSF_LF_67_INT,FLEXE_OAM_TX_BASE_ADDR,0x9c,15,14},
	{CSF_LF_68_INT,FLEXE_OAM_TX_BASE_ADDR,0x9c,17,16},
	{CSF_LF_69_INT,FLEXE_OAM_TX_BASE_ADDR,0x9c,19,18},
};
const CHIP_REG flexe_csf_lf_i6_INT_MASK_REG[]=
{
	{CSF_LF_60_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9d,1,0},
	{CSF_LF_61_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9d,3,2},
	{CSF_LF_62_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9d,5,4},
	{CSF_LF_63_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9d,7,6},
	{CSF_LF_64_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9d,9,8},
	{CSF_LF_65_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9d,11,10},
	{CSF_LF_66_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9d,13,12},
	{CSF_LF_67_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9d,15,14},
	{CSF_LF_68_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9d,17,16},
	{CSF_LF_69_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9d,19,18},
};
const CHIP_REG flexe_csf_lf_i7_INT_REG[]=
{
	{CSF_LF_70_INT,FLEXE_OAM_TX_BASE_ADDR,0x9e,1,0},
	{CSF_LF_71_INT,FLEXE_OAM_TX_BASE_ADDR,0x9e,3,2},
	{CSF_LF_72_INT,FLEXE_OAM_TX_BASE_ADDR,0x9e,5,4},
	{CSF_LF_73_INT,FLEXE_OAM_TX_BASE_ADDR,0x9e,7,6},
	{CSF_LF_74_INT,FLEXE_OAM_TX_BASE_ADDR,0x9e,9,8},
	{CSF_LF_75_INT,FLEXE_OAM_TX_BASE_ADDR,0x9e,11,10},
	{CSF_LF_76_INT,FLEXE_OAM_TX_BASE_ADDR,0x9e,13,12},
	{CSF_LF_77_INT,FLEXE_OAM_TX_BASE_ADDR,0x9e,15,14},
	{CSF_LF_78_INT,FLEXE_OAM_TX_BASE_ADDR,0x9e,17,16},
	{CSF_LF_79_INT,FLEXE_OAM_TX_BASE_ADDR,0x9e,19,18},
};
const CHIP_REG flexe_csf_lf_i7_INT_MASK_REG[]=
{
	{CSF_LF_70_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9f,1,0},
	{CSF_LF_71_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9f,3,2},
	{CSF_LF_72_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9f,5,4},
	{CSF_LF_73_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9f,7,6},
	{CSF_LF_74_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9f,9,8},
	{CSF_LF_75_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9f,11,10},
	{CSF_LF_76_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9f,13,12},
	{CSF_LF_77_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9f,15,14},
	{CSF_LF_78_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9f,17,16},
	{CSF_LF_79_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0x9f,19,18},
};
const CHIP_REG flexe_csf_rf_i0_INT_REG[]=
{
	{CSF_RF_0_INT,FLEXE_OAM_TX_BASE_ADDR,0xa0,1,0},
	{CSF_RF_1_INT,FLEXE_OAM_TX_BASE_ADDR,0xa0,3,2},
	{CSF_RF_2_INT,FLEXE_OAM_TX_BASE_ADDR,0xa0,5,4},
	{CSF_RF_3_INT,FLEXE_OAM_TX_BASE_ADDR,0xa0,7,6},
	{CSF_RF_4_INT,FLEXE_OAM_TX_BASE_ADDR,0xa0,9,8},
	{CSF_RF_5_INT,FLEXE_OAM_TX_BASE_ADDR,0xa0,11,10},
	{CSF_RF_6_INT,FLEXE_OAM_TX_BASE_ADDR,0xa0,13,12},
	{CSF_RF_7_INT,FLEXE_OAM_TX_BASE_ADDR,0xa0,15,14},
	{CSF_RF_8_INT,FLEXE_OAM_TX_BASE_ADDR,0xa0,17,16},
	{CSF_RF_9_INT,FLEXE_OAM_TX_BASE_ADDR,0xa0,19,18},
};
const CHIP_REG flexe_csf_rf_i0_INT_MASK_REG[]=
{
	{CSF_RF_0_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa1,1,0},
	{CSF_RF_1_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa1,3,2},
	{CSF_RF_2_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa1,5,4},
	{CSF_RF_3_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa1,7,6},
	{CSF_RF_4_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa1,9,8},
	{CSF_RF_5_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa1,11,10},
	{CSF_RF_6_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa1,13,12},
	{CSF_RF_7_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa1,15,14},
	{CSF_RF_8_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa1,17,16},
	{CSF_RF_9_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa1,19,18},
};
const CHIP_REG flexe_csf_rf_i1_INT_REG[]=
{
	{CSF_RF_10_INT,FLEXE_OAM_TX_BASE_ADDR,0xa2,1,0},
	{CSF_RF_11_INT,FLEXE_OAM_TX_BASE_ADDR,0xa2,3,2},
	{CSF_RF_12_INT,FLEXE_OAM_TX_BASE_ADDR,0xa2,5,4},
	{CSF_RF_13_INT,FLEXE_OAM_TX_BASE_ADDR,0xa2,7,6},
	{CSF_RF_14_INT,FLEXE_OAM_TX_BASE_ADDR,0xa2,9,8},
	{CSF_RF_15_INT,FLEXE_OAM_TX_BASE_ADDR,0xa2,11,10},
	{CSF_RF_16_INT,FLEXE_OAM_TX_BASE_ADDR,0xa2,13,12},
	{CSF_RF_17_INT,FLEXE_OAM_TX_BASE_ADDR,0xa2,15,14},
	{CSF_RF_18_INT,FLEXE_OAM_TX_BASE_ADDR,0xa2,17,16},
	{CSF_RF_19_INT,FLEXE_OAM_TX_BASE_ADDR,0xa2,19,18},
};
const CHIP_REG flexe_csf_rf_i1_INT_MASK_REG[]=
{
	{CSF_RF_10_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa3,1,0},
	{CSF_RF_11_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa3,3,2},
	{CSF_RF_12_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa3,5,4},
	{CSF_RF_13_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa3,7,6},
	{CSF_RF_14_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa3,9,8},
	{CSF_RF_15_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa3,11,10},
	{CSF_RF_16_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa3,13,12},
	{CSF_RF_17_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa3,15,14},
	{CSF_RF_18_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa3,17,16},
	{CSF_RF_19_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa3,19,18},
};
const CHIP_REG flexe_csf_rf_i2_INT_REG[]=
{
	{CSF_RF_20_INT,FLEXE_OAM_TX_BASE_ADDR,0xa4,1,0},
	{CSF_RF_21_INT,FLEXE_OAM_TX_BASE_ADDR,0xa4,3,2},
	{CSF_RF_22_INT,FLEXE_OAM_TX_BASE_ADDR,0xa4,5,4},
	{CSF_RF_23_INT,FLEXE_OAM_TX_BASE_ADDR,0xa4,7,6},
	{CSF_RF_24_INT,FLEXE_OAM_TX_BASE_ADDR,0xa4,9,8},
	{CSF_RF_25_INT,FLEXE_OAM_TX_BASE_ADDR,0xa4,11,10},
	{CSF_RF_26_INT,FLEXE_OAM_TX_BASE_ADDR,0xa4,13,12},
	{CSF_RF_27_INT,FLEXE_OAM_TX_BASE_ADDR,0xa4,15,14},
	{CSF_RF_28_INT,FLEXE_OAM_TX_BASE_ADDR,0xa4,17,16},
	{CSF_RF_29_INT,FLEXE_OAM_TX_BASE_ADDR,0xa4,19,18},
};
const CHIP_REG flexe_csf_rf_i2_INT_MASK_REG[]=
{
	{CSF_RF_20_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa5,1,0},
	{CSF_RF_21_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa5,3,2},
	{CSF_RF_22_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa5,5,4},
	{CSF_RF_23_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa5,7,6},
	{CSF_RF_24_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa5,9,8},
	{CSF_RF_25_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa5,11,10},
	{CSF_RF_26_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa5,13,12},
	{CSF_RF_27_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa5,15,14},
	{CSF_RF_28_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa5,17,16},
	{CSF_RF_29_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa5,19,18},
};
const CHIP_REG flexe_csf_rf_i3_INT_REG[]=
{
	{CSF_RF_30_INT,FLEXE_OAM_TX_BASE_ADDR,0xa6,1,0},
	{CSF_RF_31_INT,FLEXE_OAM_TX_BASE_ADDR,0xa6,3,2},
	{CSF_RF_32_INT,FLEXE_OAM_TX_BASE_ADDR,0xa6,5,4},
	{CSF_RF_33_INT,FLEXE_OAM_TX_BASE_ADDR,0xa6,7,6},
	{CSF_RF_34_INT,FLEXE_OAM_TX_BASE_ADDR,0xa6,9,8},
	{CSF_RF_35_INT,FLEXE_OAM_TX_BASE_ADDR,0xa6,11,10},
	{CSF_RF_36_INT,FLEXE_OAM_TX_BASE_ADDR,0xa6,13,12},
	{CSF_RF_37_INT,FLEXE_OAM_TX_BASE_ADDR,0xa6,15,14},
	{CSF_RF_38_INT,FLEXE_OAM_TX_BASE_ADDR,0xa6,17,16},
	{CSF_RF_39_INT,FLEXE_OAM_TX_BASE_ADDR,0xa6,19,18},
};
const CHIP_REG flexe_csf_rf_i3_INT_MASK_REG[]=
{
	{CSF_RF_30_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa7,1,0},
	{CSF_RF_31_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa7,3,2},
	{CSF_RF_32_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa7,5,4},
	{CSF_RF_33_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa7,7,6},
	{CSF_RF_34_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa7,9,8},
	{CSF_RF_35_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa7,11,10},
	{CSF_RF_36_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa7,13,12},
	{CSF_RF_37_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa7,15,14},
	{CSF_RF_38_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa7,17,16},
	{CSF_RF_39_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa7,19,18},
};
const CHIP_REG flexe_csf_rf_i4_INT_REG[]=
{
	{CSF_RF_40_INT,FLEXE_OAM_TX_BASE_ADDR,0xa8,1,0},
	{CSF_RF_41_INT,FLEXE_OAM_TX_BASE_ADDR,0xa8,3,2},
	{CSF_RF_42_INT,FLEXE_OAM_TX_BASE_ADDR,0xa8,5,4},
	{CSF_RF_43_INT,FLEXE_OAM_TX_BASE_ADDR,0xa8,7,6},
	{CSF_RF_44_INT,FLEXE_OAM_TX_BASE_ADDR,0xa8,9,8},
	{CSF_RF_45_INT,FLEXE_OAM_TX_BASE_ADDR,0xa8,11,10},
	{CSF_RF_46_INT,FLEXE_OAM_TX_BASE_ADDR,0xa8,13,12},
	{CSF_RF_47_INT,FLEXE_OAM_TX_BASE_ADDR,0xa8,15,14},
	{CSF_RF_48_INT,FLEXE_OAM_TX_BASE_ADDR,0xa8,17,16},
	{CSF_RF_49_INT,FLEXE_OAM_TX_BASE_ADDR,0xa8,19,18},
};
const CHIP_REG flexe_csf_rf_i4_INT_MASK_REG[]=
{
	{CSF_RF_40_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa9,1,0},
	{CSF_RF_41_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa9,3,2},
	{CSF_RF_42_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa9,5,4},
	{CSF_RF_43_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa9,7,6},
	{CSF_RF_44_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa9,9,8},
	{CSF_RF_45_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa9,11,10},
	{CSF_RF_46_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa9,13,12},
	{CSF_RF_47_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa9,15,14},
	{CSF_RF_48_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa9,17,16},
	{CSF_RF_49_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xa9,19,18},
};
const CHIP_REG flexe_csf_rf_i5_INT_REG[]=
{
	{CSF_RF_50_INT,FLEXE_OAM_TX_BASE_ADDR,0xaa,1,0},
	{CSF_RF_51_INT,FLEXE_OAM_TX_BASE_ADDR,0xaa,3,2},
	{CSF_RF_52_INT,FLEXE_OAM_TX_BASE_ADDR,0xaa,5,4},
	{CSF_RF_53_INT,FLEXE_OAM_TX_BASE_ADDR,0xaa,7,6},
	{CSF_RF_54_INT,FLEXE_OAM_TX_BASE_ADDR,0xaa,9,8},
	{CSF_RF_55_INT,FLEXE_OAM_TX_BASE_ADDR,0xaa,11,10},
	{CSF_RF_56_INT,FLEXE_OAM_TX_BASE_ADDR,0xaa,13,12},
	{CSF_RF_57_INT,FLEXE_OAM_TX_BASE_ADDR,0xaa,15,14},
	{CSF_RF_58_INT,FLEXE_OAM_TX_BASE_ADDR,0xaa,17,16},
	{CSF_RF_59_INT,FLEXE_OAM_TX_BASE_ADDR,0xaa,19,18},
};
const CHIP_REG flexe_csf_rf_i5_INT_MASK_REG[]=
{
	{CSF_RF_50_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xab,1,0},
	{CSF_RF_51_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xab,3,2},
	{CSF_RF_52_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xab,5,4},
	{CSF_RF_53_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xab,7,6},
	{CSF_RF_54_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xab,9,8},
	{CSF_RF_55_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xab,11,10},
	{CSF_RF_56_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xab,13,12},
	{CSF_RF_57_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xab,15,14},
	{CSF_RF_58_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xab,17,16},
	{CSF_RF_59_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xab,19,18},
};
const CHIP_REG flexe_csf_rf_i6_INT_REG[]=
{
	{CSF_RF_60_INT,FLEXE_OAM_TX_BASE_ADDR,0xac,1,0},
	{CSF_RF_61_INT,FLEXE_OAM_TX_BASE_ADDR,0xac,3,2},
	{CSF_RF_62_INT,FLEXE_OAM_TX_BASE_ADDR,0xac,5,4},
	{CSF_RF_63_INT,FLEXE_OAM_TX_BASE_ADDR,0xac,7,6},
	{CSF_RF_64_INT,FLEXE_OAM_TX_BASE_ADDR,0xac,9,8},
	{CSF_RF_65_INT,FLEXE_OAM_TX_BASE_ADDR,0xac,11,10},
	{CSF_RF_66_INT,FLEXE_OAM_TX_BASE_ADDR,0xac,13,12},
	{CSF_RF_67_INT,FLEXE_OAM_TX_BASE_ADDR,0xac,15,14},
	{CSF_RF_68_INT,FLEXE_OAM_TX_BASE_ADDR,0xac,17,16},
	{CSF_RF_69_INT,FLEXE_OAM_TX_BASE_ADDR,0xac,19,18},
};
const CHIP_REG flexe_csf_rf_i6_INT_MASK_REG[]=
{
	{CSF_RF_60_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xad,1,0},
	{CSF_RF_61_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xad,3,2},
	{CSF_RF_62_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xad,5,4},
	{CSF_RF_63_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xad,7,6},
	{CSF_RF_64_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xad,9,8},
	{CSF_RF_65_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xad,11,10},
	{CSF_RF_66_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xad,13,12},
	{CSF_RF_67_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xad,15,14},
	{CSF_RF_68_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xad,17,16},
	{CSF_RF_69_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xad,19,18},
};
const CHIP_REG flexe_csf_rf_i7_INT_REG[]=
{
	{CSF_RF_70_INT,FLEXE_OAM_TX_BASE_ADDR,0xae,1,0},
	{CSF_RF_71_INT,FLEXE_OAM_TX_BASE_ADDR,0xae,3,2},
	{CSF_RF_72_INT,FLEXE_OAM_TX_BASE_ADDR,0xae,5,4},
	{CSF_RF_73_INT,FLEXE_OAM_TX_BASE_ADDR,0xae,7,6},
	{CSF_RF_74_INT,FLEXE_OAM_TX_BASE_ADDR,0xae,9,8},
	{CSF_RF_75_INT,FLEXE_OAM_TX_BASE_ADDR,0xae,11,10},
	{CSF_RF_76_INT,FLEXE_OAM_TX_BASE_ADDR,0xae,13,12},
	{CSF_RF_77_INT,FLEXE_OAM_TX_BASE_ADDR,0xae,15,14},
	{CSF_RF_78_INT,FLEXE_OAM_TX_BASE_ADDR,0xae,17,16},
	{CSF_RF_79_INT,FLEXE_OAM_TX_BASE_ADDR,0xae,19,18},
};
const CHIP_REG flexe_csf_rf_i7_INT_MASK_REG[]=
{
	{CSF_RF_70_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xaf,1,0},
	{CSF_RF_71_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xaf,3,2},
	{CSF_RF_72_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xaf,5,4},
	{CSF_RF_73_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xaf,7,6},
	{CSF_RF_74_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xaf,9,8},
	{CSF_RF_75_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xaf,11,10},
	{CSF_RF_76_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xaf,13,12},
	{CSF_RF_77_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xaf,15,14},
	{CSF_RF_78_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xaf,17,16},
	{CSF_RF_79_INT_MASK,FLEXE_OAM_TX_BASE_ADDR,0xaf,19,18},
};
const CHIP_RAM flexe_tx_rescfg = 
{
	TABLE_BASE_ADDR,FLEXE_OAM_TX_BASE_ADDR+0x6f,20,
};
/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_oam_joit_bip_cfg_set
*
* DESCRIPTION
*
*     Flexe oam tx oam joit bip cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  type:0~63(bitn oam_type=n)
**    parameter: 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_oam_joit_bip_cfg_set(UINT_8 chip_id,UINT_8 type,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
		(type > 63) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n type = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   type,
                   parameter
                 );
       }

       return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_oam_joit_bip_cfg2_reg[OAM_JOIT_BIP_CFG_0 + type/32].base_addr,flexe_oam_joit_bip_cfg2_reg[OAM_JOIT_BIP_CFG_0 + type/32].offset_addr,
		type%32,type%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_oam_joit_bip_cfg_get
*
* DESCRIPTION
*
*     Flexe oam tx oam joit bip cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  type:0~63(bitn oam_type=n)
**   *parameter: pointer to cfg, 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_oam_joit_bip_cfg_get(UINT_8 chip_id,UINT_8 type,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
		(type > 63))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
		   		   \r\n chip_id = %d, \
                   \r\n type = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   type
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_oam_joit_bip_cfg2_reg[OAM_JOIT_BIP_CFG_0 + type/32].base_addr,flexe_oam_joit_bip_cfg2_reg[OAM_JOIT_BIP_CFG_0 + type/32].offset_addr,
		type%32,type%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_brk_cfg_set
*
* DESCRIPTION
*
*     Flexe oam tx bas brk cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_brk_cfg_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    rv = regp_field_write(chip_id,flexe_oam_joit_bip_cfg_reg[BAS_BRK_CFG],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_brk_cfg_get
*
* DESCRIPTION
*
*     Flexe oam tx bas brk cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_brk_cfg_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    rv = regp_field_read(chip_id,flexe_oam_joit_bip_cfg_reg[BAS_BRK_CFG],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_lpi_insert_en_set
*
* DESCRIPTION
*
*     Flexe oam tx LPI_INSERT_EN.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_lpi_insert_en_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (LPI_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_oam_joit_bip_cfg_reg[LPI_INSERT_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_lpi_insert_en_get
*
* DESCRIPTION
*
*     Flexe oam tx LPI_INSERT_EN.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cfg, 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_lpi_insert_en_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
	
    if (LPI_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_oam_joit_bip_cfg_reg[LPI_INSERT_EN],parameter);
    
    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_lf_insert_en_set
*
* DESCRIPTION
*
*     Flexe oam tx lf_insert_en.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_lf_insert_en_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (LF_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_oam_joit_bip_cfg_reg[LF_INSERT_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_lf_insert_en_get
*
* DESCRIPTION
*
*     Flexe oam tx lf_insert_en.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cfg, 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_lf_insert_en_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
	
    if (LF_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_oam_joit_bip_cfg_reg[LF_INSERT_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_rf_insert_en_set
*
* DESCRIPTION
*
*     Flexe oam tx rf_insert_en.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_rf_insert_en_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (RF_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_oam_joit_bip_cfg_reg[RF_INSERT_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_rf_insert_en_get
*
* DESCRIPTION
*
*     Flexe oam tx rf_insert_en.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cfg, 1-enable, 0-disable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_rf_insert_en_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
	
    if (RF_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_oam_joit_bip_cfg_reg[RF_INSERT_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_brk_ch_cfg_set
*
* DESCRIPTION
*
*     Flexe oam tx bas brk ch cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: ch id 0~79 vaild
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_brk_ch_cfg_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x7f))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (BAS_BRK_CH_CFG > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_oam_joit_bip_cfg_reg[BAS_BRK_CH_CFG],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_brk_ch_cfg_get
*
* DESCRIPTION
*
*     Flexe oam tx bas brk ch cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to ch id
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_brk_ch_cfg_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (BAS_BRK_CH_CFG > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_oam_joit_bip_cfg_reg[BAS_BRK_CH_CFG],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_ts_1dm_insert_en_set
*
* DESCRIPTION
*
*     flexe_Oam tx bas ts_1dm_insert_en cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: ch id 0~79 vaild
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_ts_1dm_insert_en_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (TS_1DM_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_oam_joit_bip_cfg_reg[TS_1DM_INSERT_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_ts_1dm_insert_en_get
*
* DESCRIPTION
*
*     flexe_Oam tx ts_1dm_insert_en cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to ch id
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_ts_1dm_insert_en_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (TS_1DM_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_oam_joit_bip_cfg_reg[TS_1DM_INSERT_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_ts_2dmm_insert_en_set
*
* DESCRIPTION
*
*     flexe_Oam tx bas ts_2dmm_insert_en cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: ch id 0~79 vaild
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_ts_2dmm_insert_en_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (TS_2DMM_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_oam_joit_bip_cfg_reg[TS_2DMM_INSERT_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_ts_2dmm_insert_en_get
*
* DESCRIPTION
*
*     flexe_Oam tx ts_2dmm_insert_en cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to ch id
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_ts_2dmm_insert_en_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (TS_2DMM_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_oam_joit_bip_cfg_reg[TS_2DMM_INSERT_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_ts_2dmr_insert_en_set
*
* DESCRIPTION
*
*     flexe_Oam tx bas ts_2dmr_insert_en cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: ch id 0~79 vaild
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_ts_2dmr_insert_en_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (TS_2DMR_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_oam_joit_bip_cfg_reg[TS_2DMR_INSERT_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_ts_2dmr_insert_en_get
*
* DESCRIPTION
*
*     flexe_Oam tx ts_2dmr_insert_en cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to ch id
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_ts_2dmr_insert_en_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (TS_2DMR_INSERT_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_oam_joit_bip_cfg_reg[TS_2DMR_INSERT_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_ts_dm_sel_set
*
* DESCRIPTION
*
*     flexe_Oam tx bas ts_dm_sel cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: ch id 0~79 vaild
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_ts_dm_sel_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (TS_DM_SEL > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_oam_joit_bip_cfg_reg[TS_DM_SEL],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_ts_dm_sel_get
*
* DESCRIPTION
*
*     flexe_Oam tx ts_dm_sel cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to ch id
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_ts_dm_sel_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (TS_DM_SEL > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_oam_joit_bip_cfg_reg[TS_DM_SEL],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_fault_rpl_en_set
*
* DESCRIPTION
*
*     flexe_oam_tx_fault_rpl_en_set
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_fault_rpl_en_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (FAULT_RPL_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_oam_joit_bip_cfg_reg[FAULT_RPL_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_fault_rpl_en_get
*
* DESCRIPTION
*
*     flexe_oam_tx_fault_rpl_en_get
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to ch id
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_fault_rpl_en_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (FAULT_RPL_EN > MAX_INDEX(flexe_oam_joit_bip_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_oam_joit_bip_cfg_reg[FAULT_RPL_EN],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_idty_cfg_set
*
* DESCRIPTION
*
*     Flexe oam tx bas idty cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: bas identy cfg, default value 0xc
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_idty_cfg_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0xf))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    rv = regp_write(chip_id,flexe_bas_idty_cfg_reg[BAS_IDTY_CFG].base_addr,flexe_bas_idty_cfg_reg[BAS_IDTY_CFG].offset_addr,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_idty_cfg_get
*
* DESCRIPTION
*
*     Flexe oam tx bas idty cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to bas identy cfg, default value 0xc
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_idty_cfg_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    rv = regp_read(chip_id,flexe_bas_idty_cfg_reg[BAS_IDTY_CFG].base_addr,flexe_bas_idty_cfg_reg[BAS_IDTY_CFG].offset_addr,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_period_cfg_set
*
* DESCRIPTION
*
*     Flexe oam tx bas period cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: bas period cfg, 0-16k, 1-64k, 2-256k, 3-512k
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_period_cfg_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 3))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/16) > MAX_INDEX(flexe_bas_period_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_bas_period_cfg_reg[ch_id/16].base_addr,flexe_bas_period_cfg_reg[ch_id/16].offset_addr,
        (ch_id*2+1)%32,(ch_id*2)%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_period_cfg_get
*
* DESCRIPTION
*
*     Flexe oam tx bas period cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to bas period cfg, 0-16k, 1-64k, 2-256k, 3-512k
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_period_cfg_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/16) > MAX_INDEX(flexe_bas_period_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_bas_period_cfg_reg[ch_id/16].base_addr,flexe_bas_period_cfg_reg[ch_id/16].offset_addr,
        (ch_id*2+1)%32,(ch_id*2)%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_seq_type_cfg_set
*
* DESCRIPTION
*
*     Flexe oam tx seq type cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: seq type cfg, 0-cyclic sequence number, 1-fixed sequence numbe
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_seq_type_cfg_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_seq_type_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_seq_type_cfg_reg[ch_id/32].base_addr,flexe_seq_type_cfg_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_seq_type_cfg_get
*
* DESCRIPTION
*
*     Flexe oam tx seq type cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to seq type cfg, 0-cyclic sequence number, 1-fixed sequence numbe
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_seq_type_cfg_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_seq_type_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_seq_type_cfg_reg[ch_id/32].base_addr,flexe_seq_type_cfg_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_seq_num_cfg_set
*
* DESCRIPTION
*
*     Flexe oam tx seq num cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: seq num cfg
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_seq_num_cfg_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 0xf))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/8) > MAX_INDEX(flexe_seq_num_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_seq_num_cfg_reg[ch_id/8].base_addr,flexe_seq_num_cfg_reg[ch_id/8].offset_addr,
        (ch_id*4+3)%32,(ch_id*4)%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_seq_num_cfg_get
*
* DESCRIPTION
*
*     Flexe oam tx seq num cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to seq num cfg
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_seq_num_cfg_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/8) > MAX_INDEX(flexe_seq_num_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_seq_num_cfg_reg[ch_id/8].base_addr,flexe_seq_num_cfg_reg[ch_id/8].offset_addr,
        (ch_id*4+3)%32,(ch_id*4)%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_crc_rev_cfg_set
*
* DESCRIPTION
*
*     Flexe oam tx crc rev cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: crc rev enable cfg, 0-disable, 1-enable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_crc_rev_cfg_set(UINT_8 chip_id,UINT_8 field_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (field_id > MAX_INDEX(flexe_crc_rev_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_crc_rev_cfg_reg[field_id],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_crc_rev_cfg_get
*
* DESCRIPTION
*
*     Flexe oam tx crc rev cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to crc rev enable cfg, 0-disable, 1-enable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_crc_rev_cfg_get(UINT_8 chip_id,UINT_8 field_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (field_id > MAX_INDEX(flexe_crc_rev_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_crc_rev_cfg_reg[field_id],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_idle_rpl_en_set
*
* DESCRIPTION
*
*     Flexe oam tx idle rpl enable cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: idle rpl enable, 0-disable, 1-enable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_idle_rpl_en_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_tx_idle_rpl_en_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_tx_idle_rpl_en_reg[ch_id/32].base_addr,flexe_tx_idle_rpl_en_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_idle_rpl_en_get
*
* DESCRIPTION
*
*     Flexe oam tx idle rpl enable cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to idle rpl enable, 0-disable, 1-enable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_idle_rpl_en_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_tx_idle_rpl_en_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_tx_idle_rpl_en_reg[ch_id/32].base_addr,flexe_tx_idle_rpl_en_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bypass_set
*
* DESCRIPTION
*
*     Flexe oam tx bypass cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: bypass cfg, 0-normal, 1-bypass
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bypass_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    rv = regp_write(chip_id,flexe_oam_tx_bypass_reg[OAM_TX_BYPASS].base_addr,flexe_oam_tx_bypass_reg[OAM_TX_BYPASS].offset_addr,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bypass_get
*
* DESCRIPTION
*
*     Flexe oam tx bypass cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to bypass cfg, 0-normal, 1-bypass
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bypass_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    rv = regp_read(chip_id,flexe_oam_tx_bypass_reg[OAM_TX_BYPASS].base_addr,flexe_oam_tx_bypass_reg[OAM_TX_BYPASS].offset_addr,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bip_err_mask_bit_set
*
* DESCRIPTION
*
*     Flexe oam tx bip err mask cfg by bit.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     bit_sel: 0~7
**    parameter: bip err mask, 0-don't insert bip err, 1-insert bip err
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bip_err_mask_bit_set(UINT_8 chip_id,UINT_8 bit_sel,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (bit_sel > 7) ||
        (parameter > 0x1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n bit_sel = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   bit_sel,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    rv = regp_bit_write(chip_id,flexe_bip_err_mask_reg[BIP_ERR_MASK].base_addr,flexe_bip_err_mask_reg[BIP_ERR_MASK].offset_addr,
        bit_sel,bit_sel,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bip_err_mask_bit_get
*
* DESCRIPTION
*
*     Flexe oam tx bip err mask cfg by bit.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     bit_sel: 0~7
**   *parameter: pointer to bip err mask, 0-don't insert bip err, 1-insert bip err
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bip_err_mask_bit_get(UINT_8 chip_id,UINT_8 bit_sel,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (bit_sel > 7))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n bit_sel = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   bit_sel
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    rv = regp_bit_read(chip_id,flexe_bip_err_mask_reg[BIP_ERR_MASK].base_addr,flexe_bip_err_mask_reg[BIP_ERR_MASK].offset_addr,
        bit_sel,bit_sel,parameter);
    
    return rv;
}


/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bip_err_mask_set
*
* DESCRIPTION
*
*     Flexe oam tx bip err mask cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: bip err mask, 0-don't insert bip err, 1-insert bip err
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bip_err_mask_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0xff))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    rv = regp_field_write(chip_id,flexe_bip_err_mask_reg[BIP_ERR_MASK],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bip_err_mask_get
*
* DESCRIPTION
*
*     Flexe oam tx bip err mask cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to bip err mask, 0-don't insert bip err, 1-insert bip err
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bip_err_mask_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_bip_err_mask_reg[BIP_ERR_MASK],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_manual_insert_csf_lpi_set
*
* DESCRIPTION
*
*     Flexe oam tx manual insert csf lpi cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_manual_insert_csf_lpi_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_manual_insert_csf_lpi_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_manual_insert_csf_lpi_reg[ch_id/32].base_addr,flexe_manual_insert_csf_lpi_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_manual_insert_csf_lpi_get
*
* DESCRIPTION
*
*     Flexe oam tx manual insert csf lpi cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cfg, 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_manual_insert_csf_lpi_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_manual_insert_csf_lpi_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_manual_insert_csf_lpi_reg[ch_id/32].base_addr,flexe_manual_insert_csf_lpi_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_manual_insert_csf_lf_set
*
* DESCRIPTION
*
*     Flexe oam tx manual insert csf lf cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_manual_insert_csf_lf_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_manual_insert_csf_lf_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_manual_insert_csf_lf_reg[ch_id/32].base_addr,flexe_manual_insert_csf_lf_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_manual_insert_csf_lf_get
*
* DESCRIPTION
*
*     Flexe oam tx manual insert csf lf cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cfg, 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_manual_insert_csf_lf_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_manual_insert_csf_lf_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_manual_insert_csf_lf_reg[ch_id/32].base_addr,flexe_manual_insert_csf_lf_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_manual_insert_csf_rf_set
*
* DESCRIPTION
*
*     Flexe oam tx manual insert csf rf cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_manual_insert_csf_rf_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_manual_insert_csf_rf_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_manual_insert_csf_rf_reg[ch_id/32].base_addr,flexe_manual_insert_csf_rf_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_manual_insert_csf_rf_get
*
* DESCRIPTION
*
*     Flexe oam tx manual insert csf rf cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cfg, 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_manual_insert_csf_rf_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_manual_insert_csf_rf_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_manual_insert_csf_rf_reg[ch_id/32].base_addr,flexe_manual_insert_csf_rf_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bip_err_level_set
*
* DESCRIPTION
*
*     Flexe oam tx bip err level cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bip_err_level_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_bip_err_level_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_bip_err_level_reg[ch_id/32].base_addr,flexe_bip_err_level_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bip_err_level_get
*
* DESCRIPTION
*
*     Flexe oam tx bip err level cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cfg, 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bip_err_level_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_bip_err_level_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_bip_err_level_reg[ch_id/32].base_addr,flexe_bip_err_level_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bypass_client_set
*
* DESCRIPTION
*
*     Flexe oam tx bypass client cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: 0-normal, 1-bypass
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bypass_client_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_oam_tx_bypass_client_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_oam_tx_bypass_client_reg[ch_id/32].base_addr,flexe_oam_tx_bypass_client_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bypass_client_get
*
* DESCRIPTION
*
*     Flexe oam tx bypass client cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cfg, 0-normal, 1-bypass
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bypass_client_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_oam_tx_bypass_client_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_oam_tx_bypass_client_reg[ch_id/32].base_addr,flexe_oam_tx_bypass_client_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_manual_insert_rdi_set
*
* DESCRIPTION
*
*     Flexe oam tx manual insert rdi cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_manual_insert_rdi_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_manual_insert_rdi_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_manual_insert_rdi_reg[ch_id/32].base_addr,flexe_manual_insert_rdi_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_manual_insert_rdi_get
*
* DESCRIPTION
*
*     Flexe oam tx manual insert rdi cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cfg, 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_manual_insert_rdi_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_manual_insert_rdi_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_manual_insert_rdi_reg[ch_id/32].base_addr,flexe_manual_insert_rdi_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_period_cfg1_set
*
* DESCRIPTION
*
*     Flexe oam tx bas_period_cfg1 cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     period_id: 0~3 period code in bas
**    parameter: basperiodperiod_id
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_period_cfg1_set(UINT_8 chip_id,UINT_8 period_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (period_id > 3) ||
        (parameter > 0x1ff))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n period_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   period_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	if(period_id < 2)
	{
		rv = regp_field_write(chip_id, flexe_bas_period_cfg01_REG[period_id],parameter);
	}
	else
	{
		rv = regp_field_write(chip_id, flexe_bas_period_cfg23_REG[period_id - 2],parameter);
	}
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_period_cfg1_get
*
* DESCRIPTION
*
*     Flexe oam tx bas_period_cfg1 cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     period_id: 0~3 period code in bas
**    *parameter: basperiodperiod_id
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_period_cfg1_get(UINT_8 chip_id,UINT_8 period_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (period_id > 3))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n period_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   period_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }
	
	if(period_id < 2)
	{
		rv = regp_field_read(chip_id, flexe_bas_period_cfg01_REG[period_id],parameter);
	}
	else
	{
		rv = regp_field_read(chip_id, flexe_bas_period_cfg23_REG[period_id - 2],parameter);
	}
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_en_cfg_asic_set
*
* DESCRIPTION
*
*     flexe_oam tx bas_en_cfg_asic cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id:0~CH_NUM-1
**    parameter: 0~1,0:no bas  1:insert bas
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_en_cfg_asic_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > (CH_NUM - 1)) ||
        (parameter > 0x1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	rv = regp_bit_write(chip_id, flexe_bas_en_cfg_asic_REG[ch_id/32].base_addr,flexe_bas_en_cfg_asic_REG[ch_id/32].offset_addr,
		ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_en_cfg_asic_get
*
* DESCRIPTION
*
*     flexe_oam tx bas_en_cfg_asic cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id:0~CH_NUM-1
**    *parameter: 0:no bas  1:insert bas
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_en_cfg_asic_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > (CH_NUM-1)))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	rv = regp_bit_read(chip_id,flexe_bas_en_cfg_asic_REG[ch_id/32].base_addr,flexe_bas_en_cfg_asic_REG[ch_id/32].offset_addr,
		ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_oam_pri_encode_set
*
* DESCRIPTION
*
*     flexe_oam tx oam_pri_encode cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 0~3,oam 
*				 0:bas apc low new 1:bas aps new low 
*				 2:bas new aps low         3:reserved
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_oam_pri_encode_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x3))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	rv = regp_field_write(chip_id,flexe_oam_pri_encode_REG[OAM_PRI_ENCODE],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_oam_pri_encode_get
*
* DESCRIPTION
*
*     flexe_oam tx oam_pri_encode cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    *parameter: 0~3,oam 
*				 0:bas apc low new 1:bas aps new low 
*				 2:bas new aps low         3:reserved
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_oam_pri_encode_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	rv = regp_field_read(chip_id,flexe_oam_pri_encode_REG[OAM_PRI_ENCODE],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_source_sel_set
*
* DESCRIPTION
*
*     flexe_oam tx bas_source_sel cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 0~1,bas
*				 0:OHIF 1:upi
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_source_sel_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	rv = regp_field_write(chip_id,flexe_oam_pri_encode_REG[BAS_SOURCE_SEL],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_source_sel_get
*
* DESCRIPTION
*
*     flexe_oam tx bas_source_sel cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    *parameter: 0~1,bas
*				 0:OHIF 1:upi
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_source_sel_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	rv = regp_field_read(chip_id,flexe_oam_pri_encode_REG[BAS_SOURCE_SEL],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_new_cfg_set
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id: 0:NEW_PERIOD_CFG  1:APS_PERIOD_CFG
**    parameter: 0~0x1ff
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_new_cfg_set(UINT_8 chip_id,UINT_8 field_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x1ff))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	if (field_id > MAX_INDEX(flexe_new_cfg_REG))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }

	rv = regp_field_write(chip_id,flexe_new_cfg_REG[field_id],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_new_cfg_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id: 0:NEW_PERIOD_CFG  1:APS_PERIOD_CFG
**    *parameter: 0~0x1ff
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_new_cfg_get(UINT_8 chip_id,UINT_8 field_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	if (field_id > MAX_INDEX(flexe_new_cfg_REG))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }

	rv = regp_field_read(chip_id,flexe_new_cfg_REG[field_id],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_fifo_num_set
*
* DESCRIPTION
*
*     flexe_oam tx bas_fifo_num cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 0~0x1ff
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_fifo_num_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x1ff))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	rv = regp_field_write(chip_id,flexe_tx_bas_fifo_num_REG[TX_BAS_FIFO_NUM],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_fifo_num_get
*
* DESCRIPTION
*
*     flexe_oam tx bas_fifo_num cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    *parameter: 0~0x1ff
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_fifo_num_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	rv = regp_field_read(chip_id,flexe_tx_bas_fifo_num_REG[TX_BAS_FIFO_NUM],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_lpi_setclr_cfg_set
*
* DESCRIPTION
*
*     Flexe oam tx lpi_setclr_cfg cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     field_id: 0~1,0:LPI_PRE_CNT 1:LPI_POS_CNT
**    parameter: 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_lpi_setclr_cfg_set(UINT_8 chip_id,UINT_8 field_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (field_id > LPI_POS_CNT) ||
        (parameter > 0x7))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n field_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   field_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (field_id > MAX_INDEX(flexe_tx_lpi_setclr_cfg_REG))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_tx_lpi_setclr_cfg_REG[field_id],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_lpi_setclr_cfg_get
*
* DESCRIPTION
*
*     Flexe oam tx lpi_setclr_cfg cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     field_id: 0~1,0:LPI_PRE_CNT 1:LPI_POS_CNT
**   *parameter: pointer to cfg, 0-don't insert, 1-insert
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_lpi_setclr_cfg_get(UINT_8 chip_id,UINT_8 field_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (field_id > LPI_POS_CNT))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n field_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   field_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (field_id > MAX_INDEX(flexe_tx_lpi_setclr_cfg_REG))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_tx_lpi_setclr_cfg_REG[field_id],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_cnt_cfg_set
*
* DESCRIPTION
*
*    
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id: 0:OAM_CNT_CH_CFG  1:TX_OAM_CNT_CLR
**    parameter: set value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4      1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_cnt_cfg_set(UINT_8 chip_id,UINT_8 field_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

	if (field_id > MAX_INDEX(flexe_oam_cnt_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
	

	rv = regp_field_write(chip_id,flexe_oam_cnt_cfg_reg[field_id],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_cnt_cfg_get
*
* DESCRIPTION
*
*    
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id: 0:OAM_CNT_CH_CFG  1:TX_OAM_CNT_CLR
**    parameter: get value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4      1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_cnt_cfg_get(UINT_8 chip_id,UINT_8 field_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	if (field_id > MAX_INDEX(flexe_oam_cnt_cfg_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
	

	rv = regp_field_read(chip_id,flexe_oam_cnt_cfg_reg[field_id],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_lpi_idle_rpl_en_set
*
* DESCRIPTION
*
*    
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  ch_id: 0 ~ CH_NUM - 1
**    parameter: set value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4      1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_lpi_idle_rpl_en_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_tx_lpi_idle_rpl_en_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_tx_lpi_idle_rpl_en_reg[ch_id/32].base_addr,flexe_tx_lpi_idle_rpl_en_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_lpi_idle_rpl_en_get
*
* DESCRIPTION
*
*    
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  ch_id: 0 ~ CH_NUM - 1
**    parameter: get value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4      1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_lpi_idle_rpl_en_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_tx_lpi_idle_rpl_en_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_tx_lpi_idle_rpl_en_reg[ch_id/32].base_addr,flexe_tx_lpi_idle_rpl_en_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_insert_66bcode_en_set
*
* DESCRIPTION
*
*    
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  ch_id: 0 ~ CH_NUM - 1
**    parameter: set value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4      1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_insert_66bcode_en_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_tx_insert_66bcode_en_REG))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_tx_insert_66bcode_en_REG[ch_id/32].base_addr,flexe_tx_insert_66bcode_en_REG[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_insert_66bcode_en_get
*
* DESCRIPTION
*
*    
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  ch_id: 0 ~ CH_NUM - 1
**    parameter: get value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4      1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_insert_66bcode_en_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_tx_insert_66bcode_en_REG))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_tx_insert_66bcode_en_REG[ch_id/32].base_addr,flexe_tx_insert_66bcode_en_REG[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bip_err_pulse_set
*
* DESCRIPTION
*
*     Flexe oam tx bip err pulse.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bip_err_pulse_set(UINT_8 chip_id,UINT_8 ch_id)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_bip_err_pulse_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_write(chip_id,flexe_bip_err_pulse_reg[ch_id/32].base_addr,flexe_bip_err_pulse_reg[ch_id/32].offset_addr,1<<(ch_id%32));
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_insert_cnt_get
*
* DESCRIPTION
*
*     Flexe oam tx bas insert cnt.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cnt
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_insert_cnt_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id%4) > MAX_INDEX(flexe_bas_insert_cnt_0t3_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_bas_insert_cnt_0t3_reg[ch_id%4].base_addr,flexe_bas_insert_cnt_0t3_reg[ch_id%4].offset_addr+ch_id/4,
        flexe_bas_insert_cnt_0t3_reg[ch_id%4].end_bit,flexe_bas_insert_cnt_0t3_reg[ch_id%4].start_bit,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_oth_insert_cnt_get
*
* DESCRIPTION
*
*     Flexe oam tx oth insert cnt.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to cnt
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_oth_insert_cnt_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id%4) > MAX_INDEX(flexe_oth_insert_cnt_0t3_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_oth_insert_cnt_0t3_reg[ch_id%4].base_addr,flexe_oth_insert_cnt_0t3_reg[ch_id%4].offset_addr+ch_id/4,
        flexe_oth_insert_cnt_0t3_reg[ch_id%4].end_bit,flexe_oth_insert_cnt_0t3_reg[ch_id%4].start_bit,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_lpi_alm_get
*
* DESCRIPTION
*
*     Flexe oam tx csf ipi alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_lpi_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_csf_lpi_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_csf_lpi_reg[ch_id/32].base_addr,flexe_csf_lpi_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_lf_alm_get
*
* DESCRIPTION
*
*     Flexe oam tx csf lf alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_lf_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_csf_lf_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_csf_lf_reg[ch_id/32].base_addr,flexe_csf_lf_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_rf_alm_get
*
* DESCRIPTION
*
*     Flexe oam tx csf rf alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_rf_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_csf_rf_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_csf_rf_reg[ch_id/32].base_addr,flexe_csf_rf_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_fifo_full_rei_alm_get
*
* DESCRIPTION
*
*     Flexe oam tx fifo full rei alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_fifo_full_rei_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_fifo_full_rei_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_fifo_full_rei_reg[ch_id/32].base_addr,flexe_fifo_full_rei_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_fifo_full_aps_alm_get
*
* DESCRIPTION
*
*     Flexe oam tx fifo full aps alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_fifo_full_aps_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_fifo_full_aps_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_fifo_full_aps_reg[ch_id/32].base_addr,flexe_fifo_full_aps_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_fifo_full_low_alm_get
*
* DESCRIPTION
*
*     Flexe oam tx fifo full low alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_fifo_full_low_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_fifo_full_low_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_fifo_full_low_reg[ch_id/32].base_addr,flexe_fifo_full_low_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_fifo_full_bas_alm_get
*
* DESCRIPTION
*
*     flexe_Oam tx fifo full bas alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_fifo_full_bas_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_fifo_full_bas_REG))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_fifo_full_bas_REG[ch_id/32].base_addr,flexe_fifo_full_bas_REG[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_fifo_full_new_alm_get
*
* DESCRIPTION
*
*     flexe_Oam tx fifo full new alm.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_fifo_full_new_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_fifo_full_new_REG))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_fifo_full_new_REG[ch_id/32].base_addr,flexe_fifo_full_new_REG[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_fifo_empty_bas_alm_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to alm
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_fifo_empty_bas_alm_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_fifo_empty_bas_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_fifo_empty_bas_reg[ch_id/32].base_addr,flexe_fifo_empty_bas_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_data_err_pulse_set
*
* DESCRIPTION
*
*     Flexe oam tx date err pulse.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_data_err_pulse_set(UINT_8 chip_id,UINT_8 ch_id)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_data_err_pulse_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_write(chip_id,flexe_data_err_pulse_reg[ch_id/32].base_addr,flexe_data_err_pulse_reg[ch_id/32].offset_addr,(1 << ch_id%32));
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_brk_cnt_get
*
* DESCRIPTION
*
*     Flexe oam tx bas brk cnt.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cnt
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_brk_cnt_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    rv = regp_field_read(chip_id,flexe_bas_brk_cnt_reg[BAS_BRK_CNT],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_cnt_get
*
* DESCRIPTION
*
*   
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cnt
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_cnt_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    rv = regp_field_read(chip_id,flexe_bas_cnt_reg[BAS_CNT],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_aps_cnt_get
*
* DESCRIPTION
*
*   
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cnt
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_aps_cnt_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    rv = regp_field_read(chip_id,flexe_aps_cnt_reg[APS_CNT],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_low_cnt_get
*
* DESCRIPTION
*
*   
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cnt
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_low_cnt_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    rv = regp_field_read(chip_id,flexe_low_cnt_reg[LOW_CNT],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_new_cnt_get
*
* DESCRIPTION
*
*   
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to cnt
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_new_cnt_get(UINT_8 chip_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    rv = regp_field_read(chip_id,flexe_new_cnt_reg[NEW_CNT],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_timestamp_lock_get
*
* DESCRIPTION
*
*   
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  field_id: 0:TIMESTAMP_LOCK_0  1:TIMESTAMP_LOCK_1
**   *parameter: pointer to cnt
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_timestamp_lock_get(UINT_8 chip_id,UINT_8 field_id,UINT_32 *parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (field_id > MAX_INDEX(flexe_timestamp_lock_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_timestamp_lock_reg[field_id],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_rescfg_set
*
* DESCRIPTION
*
*     Flexe oam tx rescfg pulse.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     offset: 0~79
*	  field_id:0~3:0:bas res10_11_d4 1:bas res26_31_d4 2:bas res38_41_d4 3:bas res42_49_d4
*	  *parameter:
*
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_rescfg_set(UINT_8 chip_id,UINT_8 offset,UINT_8 field_id,UINT_32* parameter)
{
	UINT_32 data[1] = {0};
	
	/* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
		(offset > (CH_NUM-1)) ||
		(field_id > 3))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  ,\
                   \r\n offset = %d ,\
                   \r\n field_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   offset,
                   field_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	ram_read_single(chip_id,flexe_tx_rescfg,offset,data);

	switch(field_id)
	{
		case 0:
			data[0] &= (~(MASK_2_BIT << SHIFT_BIT_0));
			data[0] |= (((*parameter) & MASK_2_BIT) << SHIFT_BIT_0);
			break;
		case 1:
			data[0] &= (~(MASK_6_BIT << SHIFT_BIT_2));
			data[0] |= (((*parameter) & MASK_6_BIT) << SHIFT_BIT_2);
			break;
		case 2:
			data[0] &= (~(MASK_4_BIT << SHIFT_BIT_8));
			data[0] |= (((*parameter) & MASK_4_BIT) << SHIFT_BIT_8);
			break;
		case 3:
			data[0] &= (~(MASK_8_BIT << SHIFT_BIT_12));
			data[0] |= (((*parameter) & MASK_8_BIT) << SHIFT_BIT_12);
			break;
		default:
			break;
	}
	
	ram_write_single( chip_id,flexe_tx_rescfg,offset,data);

	return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_rescfg_get
*
* DESCRIPTION
*
*     Flexe oam tx rescfg pulse.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     offset: 0~79
*	  field_id:0~3:0:bas res10_11_d4 1:bas res26_31_d4 2:bas res38_41_d4 3:bas res42_49_d4
*	  *parameter:
*
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_rescfg_get(UINT_8 chip_id,UINT_8 offset,UINT_8 field_id,UINT_32* parameter)
{
	UINT_32 data[1] = {0};
	
	/* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
		(offset > (CH_NUM-1)) ||
		(field_id > 3))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d  ,\
                   \r\n offset = %d ,\
                   \r\n field_id = %d \r\n",   
                   __FUNCTION__,
                   chip_id,
                   offset,
                   field_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	ram_read_single(chip_id,flexe_tx_rescfg,offset,data);

	switch(field_id)
	{
		case 0:
			*parameter = (data[0] >> SHIFT_BIT_0) & MASK_2_BIT;
			break;
		case 1:
			*parameter = (data[0] >> SHIFT_BIT_2) & MASK_6_BIT;
			break;
		case 2:
			*parameter = (data[0] >> SHIFT_BIT_8) & MASK_4_BIT;
			break;
		case 3:
			*parameter = (data[0] >> SHIFT_BIT_12) & MASK_8_BIT;
			break;
		default:
			break;
	}

	return RET_SUCCESS;
}
/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_lpi_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_lpi_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_write(chip_id,flexe_csf_lpi_i0_INT_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_write(chip_id,flexe_csf_lpi_i1_INT_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_write(chip_id,flexe_csf_lpi_i2_INT_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_write(chip_id,flexe_csf_lpi_i3_INT_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_write(chip_id,flexe_csf_lpi_i4_INT_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_write(chip_id,flexe_csf_lpi_i5_INT_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_write(chip_id,flexe_csf_lpi_i6_INT_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_write(chip_id,flexe_csf_lpi_i7_INT_REG[ch_id%10],parameter);
			break;	
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_lpi_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_lpi_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_read(chip_id,flexe_csf_lpi_i0_INT_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_read(chip_id,flexe_csf_lpi_i1_INT_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_read(chip_id,flexe_csf_lpi_i2_INT_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_read(chip_id,flexe_csf_lpi_i3_INT_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_read(chip_id,flexe_csf_lpi_i4_INT_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_read(chip_id,flexe_csf_lpi_i5_INT_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_read(chip_id,flexe_csf_lpi_i6_INT_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_read(chip_id,flexe_csf_lpi_i7_INT_REG[ch_id%10],parameter);
			break;			
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_lpi_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_lpi_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_write(chip_id,flexe_csf_lpi_i0_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_write(chip_id,flexe_csf_lpi_i1_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_write(chip_id,flexe_csf_lpi_i2_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_write(chip_id,flexe_csf_lpi_i3_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_write(chip_id,flexe_csf_lpi_i4_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_write(chip_id,flexe_csf_lpi_i5_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_write(chip_id,flexe_csf_lpi_i6_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_write(chip_id,flexe_csf_lpi_i7_INT_MASK_REG[ch_id%10],parameter);
			break;			
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_lpi_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_lpi_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_read(chip_id,flexe_csf_lpi_i0_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_read(chip_id,flexe_csf_lpi_i1_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_read(chip_id,flexe_csf_lpi_i2_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_read(chip_id,flexe_csf_lpi_i3_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_read(chip_id,flexe_csf_lpi_i4_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_read(chip_id,flexe_csf_lpi_i5_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_read(chip_id,flexe_csf_lpi_i6_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_read(chip_id,flexe_csf_lpi_i7_INT_MASK_REG[ch_id%10],parameter);
			break;			
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_lf_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_lf_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_write(chip_id,flexe_csf_lf_i0_INT_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_write(chip_id,flexe_csf_lf_i1_INT_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_write(chip_id,flexe_csf_lf_i2_INT_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_write(chip_id,flexe_csf_lf_i3_INT_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_write(chip_id,flexe_csf_lf_i4_INT_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_write(chip_id,flexe_csf_lf_i5_INT_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_write(chip_id,flexe_csf_lf_i6_INT_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_write(chip_id,flexe_csf_lf_i7_INT_REG[ch_id%10],parameter);
			break;	
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_lf_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_lf_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_read(chip_id,flexe_csf_lf_i0_INT_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_read(chip_id,flexe_csf_lf_i1_INT_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_read(chip_id,flexe_csf_lf_i2_INT_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_read(chip_id,flexe_csf_lf_i3_INT_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_read(chip_id,flexe_csf_lf_i4_INT_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_read(chip_id,flexe_csf_lf_i5_INT_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_read(chip_id,flexe_csf_lf_i6_INT_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_read(chip_id,flexe_csf_lf_i7_INT_REG[ch_id%10],parameter);
			break;			
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_lf_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_lf_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_write(chip_id,flexe_csf_lf_i0_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_write(chip_id,flexe_csf_lf_i1_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_write(chip_id,flexe_csf_lf_i2_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_write(chip_id,flexe_csf_lf_i3_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_write(chip_id,flexe_csf_lf_i4_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_write(chip_id,flexe_csf_lf_i5_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_write(chip_id,flexe_csf_lf_i6_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_write(chip_id,flexe_csf_lf_i7_INT_MASK_REG[ch_id%10],parameter);
			break;			
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_lf_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_lf_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_read(chip_id,flexe_csf_lf_i0_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_read(chip_id,flexe_csf_lf_i1_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_read(chip_id,flexe_csf_lf_i2_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_read(chip_id,flexe_csf_lf_i3_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_read(chip_id,flexe_csf_lf_i4_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_read(chip_id,flexe_csf_lf_i5_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_read(chip_id,flexe_csf_lf_i6_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_read(chip_id,flexe_csf_lf_i7_INT_MASK_REG[ch_id%10],parameter);
			break;			
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_rf_int_set
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_rf_int_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_write(chip_id,flexe_csf_rf_i0_INT_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_write(chip_id,flexe_csf_rf_i1_INT_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_write(chip_id,flexe_csf_rf_i2_INT_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_write(chip_id,flexe_csf_rf_i3_INT_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_write(chip_id,flexe_csf_rf_i4_INT_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_write(chip_id,flexe_csf_rf_i5_INT_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_write(chip_id,flexe_csf_rf_i6_INT_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_write(chip_id,flexe_csf_rf_i7_INT_REG[ch_id%10],parameter);
			break;	
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_rf_int_get
*
* DESCRIPTION
*
* 
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_rf_int_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_read(chip_id,flexe_csf_rf_i0_INT_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_read(chip_id,flexe_csf_rf_i1_INT_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_read(chip_id,flexe_csf_rf_i2_INT_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_read(chip_id,flexe_csf_rf_i3_INT_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_read(chip_id,flexe_csf_rf_i4_INT_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_read(chip_id,flexe_csf_rf_i5_INT_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_read(chip_id,flexe_csf_rf_i6_INT_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_read(chip_id,flexe_csf_rf_i7_INT_REG[ch_id%10],parameter);
			break;			
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_rf_int_mask_set
*
* DESCRIPTION
*
*
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_rf_int_mask_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1) || (parameter > 0x3))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_write(chip_id,flexe_csf_rf_i0_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_write(chip_id,flexe_csf_rf_i1_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_write(chip_id,flexe_csf_rf_i2_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_write(chip_id,flexe_csf_rf_i3_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_write(chip_id,flexe_csf_rf_i4_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_write(chip_id,flexe_csf_rf_i5_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_write(chip_id,flexe_csf_rf_i6_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_write(chip_id,flexe_csf_rf_i7_INT_MASK_REG[ch_id%10],parameter);
			break;			
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_csf_rf_int_mask_get
*
* DESCRIPTION
*
*     
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
*     *parameter: 0:not allow  1:allow
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-5-31     1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_csf_rf_int_mask_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) || (ch_id > CH_NUM -1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

	if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

	switch (ch_id/10)
	{
		case 0:
			regp_field_read(chip_id,flexe_csf_rf_i0_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 1:
			regp_field_read(chip_id,flexe_csf_rf_i1_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 2:
			regp_field_read(chip_id,flexe_csf_rf_i2_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 3:
			regp_field_read(chip_id,flexe_csf_rf_i3_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 4:
			regp_field_read(chip_id,flexe_csf_rf_i4_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 5:
			regp_field_read(chip_id,flexe_csf_rf_i5_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 6:
			regp_field_read(chip_id,flexe_csf_rf_i6_INT_MASK_REG[ch_id%10],parameter);
			break;
		case 7:
			regp_field_read(chip_id,flexe_csf_rf_i7_INT_MASK_REG[ch_id%10],parameter);
			break;			
		default:
			break;
	}
      
    return RET_SUCCESS;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_insert_66bcode_cfg_set
*
* DESCRIPTION
*
*    
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  ch_id: 0 ~ CH_NUM - 1
**    parameter: set value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4      1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_insert_66bcode_cfg_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_tx_insert_66bcode_cfg_REG))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_tx_insert_66bcode_cfg_REG[ch_id/32].base_addr,flexe_tx_insert_66bcode_cfg_REG[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_insert_66bcode_cfg_get
*
* DESCRIPTION
*
*    
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*	  ch_id: 0 ~ CH_NUM - 1
**    parameter: get value
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dingyi    2018-8-4      1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_insert_66bcode_cfg_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_tx_insert_66bcode_cfg_REG))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_tx_insert_66bcode_cfg_REG[ch_id/32].base_addr,flexe_tx_insert_66bcode_cfg_REG[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_lpi_bas_ins_en_set
*
* DESCRIPTION
*
*     flexe_oam tx lpi_bas_ins_en cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id:0~CH_NUM-1
**    parameter: 0:disable  1:enable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_lpi_bas_ins_en_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > (CH_NUM - 1)) ||
        (parameter > 0x1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }
	
    if ((ch_id/32) > MAX_INDEX(flexe_tx_lpi_bas_ins_en_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }

	rv = regp_bit_write(chip_id, flexe_tx_lpi_bas_ins_en_reg[ch_id/32].base_addr,flexe_tx_lpi_bas_ins_en_reg[ch_id/32].offset_addr,
		ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_lpi_bas_ins_en_get
*
* DESCRIPTION
*
*     flexe_oam tx lpi_bas_ins_en cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id:0~CH_NUM-1
**    *parameter: 0:disable  1:enable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_lpi_bas_ins_en_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > (CH_NUM-1)))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_tx_lpi_bas_ins_en_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }

	rv = regp_bit_read(chip_id,flexe_tx_lpi_bas_ins_en_reg[ch_id/32].base_addr,flexe_tx_lpi_bas_ins_en_reg[ch_id/32].offset_addr,
		ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_crc_err_en_set
*
* DESCRIPTION
*
*     flexe_Oam tx bas_crc_err enable cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**    parameter: bas_crc_err enable, 0-disable, 1-enable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_crc_err_en_set(UINT_8 chip_id,UINT_8 ch_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1) ||
        (parameter > 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_bas_crc_err_en_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_write(chip_id,flexe_bas_crc_err_en_reg[ch_id/32].base_addr,flexe_bas_crc_err_en_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_crc_err_en_get
*
* DESCRIPTION
*
*     flexe_Oam tx bas_crc_err enable cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
*     ch_id: 0~CH_NUM - 1
**   *parameter: pointer to bas_crc_err enable, 0-disable, 1-enable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_crc_err_en_get(UINT_8 chip_id,UINT_8 ch_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (ch_id > CH_NUM - 1))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n ch_id = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   ch_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if ((ch_id/32) > MAX_INDEX(flexe_bas_crc_err_en_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_bit_read(chip_id,flexe_bas_crc_err_en_reg[ch_id/32].base_addr,flexe_bas_crc_err_en_reg[ch_id/32].offset_addr,
        ch_id%32,ch_id%32,parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_crc_err_mask_set
*
* DESCRIPTION
*
*     flexe_Oam tx bas_crc_err mask cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**    parameter: 
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_crc_err_mask_set(UINT_8 chip_id,UINT_32 parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if ((chip_id > MAX_DEV) ||
        (parameter > 0x7))
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d, \
                   \r\n parameter = %d  \r\n",   
                   __FUNCTION__,
                   chip_id,
                   parameter
                 );
       }

       return RET_PARAERR;
    }

    if (TX_BAS_CRC_ERR_MASK > MAX_INDEX(flexe_bas_crc_err_en_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_write(chip_id,flexe_bas_crc_err_en_reg[TX_BAS_CRC_ERR_MASK],parameter);
    
    return rv;
}

/******************************************************************************
*
* FUNCTION
*
*     flexe_oam_tx_bas_crc_err_mask_get
*
* DESCRIPTION
*
*     flexe_Oam tx bas_crc_err mask cfg.
*
* NOTE
*
*     RESERVED
*
* PARAMETERS
*
*     chip_id: chip number used
**   *parameter: pointer to idle rpl enable, 0-disable, 1-enable
* RETURNS
*
*     0: success
*     1: fail
*
* CALLS
*
*     RESERVED
*
* CALLED BY
*
*     RESERVED
*
* VERSION
*
*   <author>     <data>    <CR_ID>      <DESCRIPTION>
*    dengjie    2018-1-15    1.0           initial
*
******************************************************************************/
RET_STATUS flexe_oam_tx_bas_crc_err_mask_get(UINT_8 chip_id,UINT_32* parameter)
{
    RET_STATUS rv = RET_SUCCESS;

    /* check parameter whether valid */
    if (chip_id > MAX_DEV)
    {
       if (flexe_oam_tx_para_debug)
       {
           printf("[%s] invalid parameter!! \
                   \r\n chip_id = %d\r\n",   
                   __FUNCTION__,
                   chip_id
                 );
       }

       return RET_PARAERR;
    }

    if (NULL == parameter)
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] invalid parameter pointer\r\n",__FUNCTION__);
        }
        return RET_PARAERR;
    }

    if (TX_BAS_CRC_ERR_MASK > MAX_INDEX(flexe_bas_crc_err_en_reg))
    {
        if (flexe_oam_tx_para_debug)
        {
            printf("[%s] out of array range\r\n",__FUNCTION__);
        }

        return RET_PARAERR;
    }
    
    rv = regp_field_read(chip_id,flexe_bas_crc_err_en_reg[TX_BAS_CRC_ERR_MASK],parameter);
    
    return rv;
}

