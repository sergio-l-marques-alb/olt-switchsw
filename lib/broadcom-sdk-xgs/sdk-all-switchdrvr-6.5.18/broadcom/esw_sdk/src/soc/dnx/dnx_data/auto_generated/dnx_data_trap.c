/** \file dnx_data_trap.c
 * 
 * MODULE DEVICE DATA - TRAP
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2019 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_RX
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_trap.h>
/*
 * }
 */

/*
 * Extern per device attach function
 */
extern shr_error_e jr2_a0_data_trap_attach(
    int unit);
extern shr_error_e jr2_b0_data_trap_attach(
    int unit);
extern shr_error_e j2c_a0_data_trap_attach(
    int unit);
extern shr_error_e q2a_a0_data_trap_attach(
    int unit);
extern shr_error_e j2p_a0_data_trap_attach(
    int unit);
/*
 * SUBMODULE - INGRESS:
 * {
 */
/*
 * ingress init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_trap_ingress_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "ingress";
    submodule_data->doc = "trap profiles data";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_trap_ingress_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data trap ingress features");

    submodule_data->features[dnx_data_trap_ingress_ndp_trap_en].name = "ndp_trap_en";
    submodule_data->features[dnx_data_trap_ingress_ndp_trap_en].doc = "Are NDP/myNDP traps supported";
    submodule_data->features[dnx_data_trap_ingress_ndp_trap_en].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_trap_ingress_trap_in_lif_profile_mapping].name = "trap_in_lif_profile_mapping";
    submodule_data->features[dnx_data_trap_ingress_trap_in_lif_profile_mapping].doc = "If set, mapping for in_lif_prfile in the case of ingress protocol trap";
    submodule_data->features[dnx_data_trap_ingress_trap_in_lif_profile_mapping].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_trap_ingress_svtag_trap_en].name = "svtag_trap_en";
    submodule_data->features[dnx_data_trap_ingress_svtag_trap_en].doc = "Does MACSec exist in the device, so it can be initialized";
    submodule_data->features[dnx_data_trap_ingress_svtag_trap_en].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_trap_ingress_oam_offset_actions].name = "oam_offset_actions";
    submodule_data->features[dnx_data_trap_ingress_oam_offset_actions].doc = "Does the device support OAM Offset adjustment actions";
    submodule_data->features[dnx_data_trap_ingress_oam_offset_actions].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_trap_ingress_snoop_code_clear_action].name = "snoop_code_clear_action";
    submodule_data->features[dnx_data_trap_ingress_snoop_code_clear_action].doc = "Enables the Snoop Code clear action from Q2A onward";
    submodule_data->features[dnx_data_trap_ingress_snoop_code_clear_action].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_trap_ingress_mirror_code_clear_action].name = "mirror_code_clear_action";
    submodule_data->features[dnx_data_trap_ingress_mirror_code_clear_action].doc = "Enables the Mirror Code clear action from Q2A onward";
    submodule_data->features[dnx_data_trap_ingress_mirror_code_clear_action].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_trap_ingress_stat_sampling_code_clear_action].name = "stat_sampling_code_clear_action";
    submodule_data->features[dnx_data_trap_ingress_stat_sampling_code_clear_action].doc = "Enables the Statistical Sampling Code clear action from Q2A onward";
    submodule_data->features[dnx_data_trap_ingress_stat_sampling_code_clear_action].flags |= DNXC_DATA_F_FEATURE;

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_trap_ingress_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data trap ingress defines");

    submodule_data->defines[dnx_data_trap_ingress_define_protocol_traps_init_mode].name = "protocol_traps_init_mode";
    submodule_data->defines[dnx_data_trap_ingress_define_protocol_traps_init_mode].doc = "initialize protocol traps configuration mode";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_protocol_traps_init_mode].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_trap_ingress_define_protocol_traps_lif_profile_starting_offset].name = "protocol_traps_lif_profile_starting_offset";
    submodule_data->defines[dnx_data_trap_ingress_define_protocol_traps_lif_profile_starting_offset].doc = "The offset at which LIF profile entries start in protocol profiling table";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_protocol_traps_lif_profile_starting_offset].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_predefeind_traps].name = "nof_predefeind_traps";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_predefeind_traps].doc = "Number of predefined traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_predefeind_traps].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_user_defined_traps].name = "nof_user_defined_traps";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_user_defined_traps].doc = "Number of bcmRxTrapUserDefine traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_user_defined_traps].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_1588_traps].name = "nof_1588_traps";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_1588_traps].doc = "Number of bcmRxTrap1588 traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_1588_traps].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_entries_action_table].name = "nof_entries_action_table";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_entries_action_table].doc = "Number of entries in action table of traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_entries_action_table].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_protocol_trap_profiles].name = "nof_protocol_trap_profiles";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_protocol_trap_profiles].doc = "Number of protocol trap profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_protocol_trap_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_recycle_cmds].name = "nof_recycle_cmds";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_recycle_cmds].doc = "Number of forward recycle commands";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_recycle_cmds].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_programmable_traps].name = "nof_programmable_traps";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_programmable_traps].doc = "Number of programmable traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_programmable_traps].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_lif_traps].name = "nof_lif_traps";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_lif_traps].doc = "Number of LIF traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_lif_traps].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_icmp_compressed_types].name = "nof_icmp_compressed_types";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_icmp_compressed_types].doc = "Number of ICMP compressed types";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_icmp_compressed_types].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_stat_objs].name = "nof_stat_objs";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_stat_objs].doc = "Number of ingress statistical objects";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_stat_objs].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_max_nof_stat_objs_to_overwrite].name = "max_nof_stat_objs_to_overwrite";
    submodule_data->defines[dnx_data_trap_ingress_define_max_nof_stat_objs_to_overwrite].doc = "Max number of statistical objects to overwrite";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_max_nof_stat_objs_to_overwrite].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_error_code_profiles].name = "nof_error_code_profiles";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_error_code_profiles].doc = "Number of Error Code profiles for MACSEC traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_error_code_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_sci_profiles].name = "nof_sci_profiles";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_sci_profiles].doc = "Number of SCI profiles for MACSEC traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_sci_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_error_codes].name = "nof_error_codes";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_error_codes].doc = "Number of Error Codes for MACSEC traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_error_codes].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_ingress_define_nof_scis].name = "nof_scis";
    submodule_data->defines[dnx_data_trap_ingress_define_nof_scis].doc = "Number of SCIs for MACSEC traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_ingress_define_nof_scis].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_trap_ingress_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data trap ingress tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * ingress features
 */
int
dnx_data_trap_ingress_feature_get(
    int unit,
    dnx_data_trap_ingress_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, feature);
}

/*
 * ingress defines
 */
uint32
dnx_data_trap_ingress_protocol_traps_init_mode_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_protocol_traps_init_mode);
}

uint32
dnx_data_trap_ingress_protocol_traps_lif_profile_starting_offset_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_protocol_traps_lif_profile_starting_offset);
}

uint32
dnx_data_trap_ingress_nof_predefeind_traps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_predefeind_traps);
}

uint32
dnx_data_trap_ingress_nof_user_defined_traps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_user_defined_traps);
}

uint32
dnx_data_trap_ingress_nof_1588_traps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_1588_traps);
}

uint32
dnx_data_trap_ingress_nof_entries_action_table_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_entries_action_table);
}

uint32
dnx_data_trap_ingress_nof_protocol_trap_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_protocol_trap_profiles);
}

uint32
dnx_data_trap_ingress_nof_recycle_cmds_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_recycle_cmds);
}

uint32
dnx_data_trap_ingress_nof_programmable_traps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_programmable_traps);
}

uint32
dnx_data_trap_ingress_nof_lif_traps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_lif_traps);
}

uint32
dnx_data_trap_ingress_nof_icmp_compressed_types_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_icmp_compressed_types);
}

uint32
dnx_data_trap_ingress_nof_stat_objs_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_stat_objs);
}

uint32
dnx_data_trap_ingress_max_nof_stat_objs_to_overwrite_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_max_nof_stat_objs_to_overwrite);
}

uint32
dnx_data_trap_ingress_nof_error_code_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_error_code_profiles);
}

uint32
dnx_data_trap_ingress_nof_sci_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_sci_profiles);
}

uint32
dnx_data_trap_ingress_nof_error_codes_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_error_codes);
}

uint32
dnx_data_trap_ingress_nof_scis_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_ingress, dnx_data_trap_ingress_define_nof_scis);
}

/*
 * ingress tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - ERPP:
 * {
 */
/*
 * erpp init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_trap_erpp_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "erpp";
    submodule_data->doc = "erpp traps";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_trap_erpp_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data trap erpp features");

    submodule_data->features[dnx_data_trap_erpp_unknown_da_trap_en].name = "unknown_da_trap_en";
    submodule_data->features[dnx_data_trap_erpp_unknown_da_trap_en].doc = "Is UnknownDA trap supported";
    submodule_data->features[dnx_data_trap_erpp_unknown_da_trap_en].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_trap_erpp_glem_not_found_trap].name = "glem_not_found_trap";
    submodule_data->features[dnx_data_trap_erpp_glem_not_found_trap].doc = "Is glem not found trap supported";
    submodule_data->features[dnx_data_trap_erpp_glem_not_found_trap].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_trap_erpp_ip_4_6_l4_traps_enabled].name = "ip_4_6_l4_traps_enabled";
    submodule_data->features[dnx_data_trap_erpp_ip_4_6_l4_traps_enabled].doc = "Are IPv4, IPv6 and L4 ERPP traps enabled.";
    submodule_data->features[dnx_data_trap_erpp_ip_4_6_l4_traps_enabled].flags |= DNXC_DATA_F_FEATURE;

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_trap_erpp_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data trap erpp defines");

    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_app_traps].name = "nof_erpp_app_traps";
    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_app_traps].doc = "Number of ERPP application traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_app_traps].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_forward_profiles].name = "nof_erpp_forward_profiles";
    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_forward_profiles].doc = "Number of ERPP forward profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_forward_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_user_configurable_profiles].name = "nof_erpp_user_configurable_profiles";
    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_user_configurable_profiles].doc = "Number of user configurable profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_user_configurable_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_snif_profiles].name = "nof_erpp_snif_profiles";
    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_snif_profiles].doc = "Number of ERPP snif profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_erpp_define_nof_erpp_snif_profiles].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_trap_erpp_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data trap erpp tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * erpp features
 */
int
dnx_data_trap_erpp_feature_get(
    int unit,
    dnx_data_trap_erpp_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_erpp, feature);
}

/*
 * erpp defines
 */
uint32
dnx_data_trap_erpp_nof_erpp_app_traps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_erpp, dnx_data_trap_erpp_define_nof_erpp_app_traps);
}

uint32
dnx_data_trap_erpp_nof_erpp_forward_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_erpp, dnx_data_trap_erpp_define_nof_erpp_forward_profiles);
}

uint32
dnx_data_trap_erpp_nof_erpp_user_configurable_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_erpp, dnx_data_trap_erpp_define_nof_erpp_user_configurable_profiles);
}

uint32
dnx_data_trap_erpp_nof_erpp_snif_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_erpp, dnx_data_trap_erpp_define_nof_erpp_snif_profiles);
}

/*
 * erpp tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - ETPP:
 * {
 */
/*
 * etpp init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_trap_etpp_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "etpp";
    submodule_data->doc = "etpp traps";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_trap_etpp_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data trap etpp features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_trap_etpp_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data trap etpp defines");

    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_app_traps].name = "nof_etpp_app_traps";
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_app_traps].doc = "Number of ETPP application traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_app_traps].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_user_configurable_profiles].name = "nof_etpp_user_configurable_profiles";
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_user_configurable_profiles].doc = "Number of user configurable profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_user_configurable_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_trap_profiles].name = "nof_etpp_trap_profiles";
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_trap_profiles].doc = "Number of ETPP trap profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_trap_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_oam_traps].name = "nof_etpp_oam_traps";
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_oam_traps].doc = "Number of ETPP OAM traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_oam_traps].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_snif_profiles].name = "nof_etpp_snif_profiles";
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_snif_profiles].doc = "Number of ETPP snif profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_snif_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_etpp_define_nof_mtu_profiles].name = "nof_mtu_profiles";
    submodule_data->defines[dnx_data_trap_etpp_define_nof_mtu_profiles].doc = "Number of MTU profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_etpp_define_nof_mtu_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_lif_traps].name = "nof_etpp_lif_traps";
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_lif_traps].doc = "Number of ETPP LIF traps";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_etpp_define_nof_etpp_lif_traps].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_etpp_define_max_mtu_value].name = "max_mtu_value";
    submodule_data->defines[dnx_data_trap_etpp_define_max_mtu_value].doc = "The maximum MTU value allowed.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_etpp_define_max_mtu_value].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_trap_etpp_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data trap etpp tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * etpp features
 */
int
dnx_data_trap_etpp_feature_get(
    int unit,
    dnx_data_trap_etpp_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_etpp, feature);
}

/*
 * etpp defines
 */
uint32
dnx_data_trap_etpp_nof_etpp_app_traps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_etpp, dnx_data_trap_etpp_define_nof_etpp_app_traps);
}

uint32
dnx_data_trap_etpp_nof_etpp_user_configurable_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_etpp, dnx_data_trap_etpp_define_nof_etpp_user_configurable_profiles);
}

uint32
dnx_data_trap_etpp_nof_etpp_trap_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_etpp, dnx_data_trap_etpp_define_nof_etpp_trap_profiles);
}

uint32
dnx_data_trap_etpp_nof_etpp_oam_traps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_etpp, dnx_data_trap_etpp_define_nof_etpp_oam_traps);
}

uint32
dnx_data_trap_etpp_nof_etpp_snif_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_etpp, dnx_data_trap_etpp_define_nof_etpp_snif_profiles);
}

uint32
dnx_data_trap_etpp_nof_mtu_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_etpp, dnx_data_trap_etpp_define_nof_mtu_profiles);
}

uint32
dnx_data_trap_etpp_nof_etpp_lif_traps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_etpp, dnx_data_trap_etpp_define_nof_etpp_lif_traps);
}

uint32
dnx_data_trap_etpp_max_mtu_value_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_etpp, dnx_data_trap_etpp_define_max_mtu_value);
}

/*
 * etpp tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - STRENGTH:
 * {
 */
/*
 * strength init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_trap_strength_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "strength";
    submodule_data->doc = "trap profiles data";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_trap_strength_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data trap strength features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_trap_strength_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data trap strength defines");

    submodule_data->defines[dnx_data_trap_strength_define_max_strength].name = "max_strength";
    submodule_data->defines[dnx_data_trap_strength_define_max_strength].doc = "Max value of strength (4b)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_strength_define_max_strength].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_strength_define_max_snp_strength].name = "max_snp_strength";
    submodule_data->defines[dnx_data_trap_strength_define_max_snp_strength].doc = "Max value of snoop strength (3b)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_strength_define_max_snp_strength].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_strength_define_max_ingress_to_egress_compressed_strength].name = "max_ingress_to_egress_compressed_strength";
    submodule_data->defines[dnx_data_trap_strength_define_max_ingress_to_egress_compressed_strength].doc = "Max value of ingress compressed strength (3b) mapped to egress strength (4b)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_strength_define_max_ingress_to_egress_compressed_strength].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_trap_strength_define_default_trap_strength].name = "default_trap_strength";
    submodule_data->defines[dnx_data_trap_strength_define_default_trap_strength].doc = "Default trap strength used when drop / trap packets to CPU";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_strength_define_default_trap_strength].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_trap_strength_define_default_snoop_strength].name = "default_snoop_strength";
    submodule_data->defines[dnx_data_trap_strength_define_default_snoop_strength].doc = "Default snoop strength used when drop / trap packets to CPU";
    /* Set data type flag */
    submodule_data->defines[dnx_data_trap_strength_define_default_snoop_strength].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_trap_strength_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data trap strength tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * strength features
 */
int
dnx_data_trap_strength_feature_get(
    int unit,
    dnx_data_trap_strength_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_strength, feature);
}

/*
 * strength defines
 */
uint32
dnx_data_trap_strength_max_strength_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_strength, dnx_data_trap_strength_define_max_strength);
}

uint32
dnx_data_trap_strength_max_snp_strength_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_strength, dnx_data_trap_strength_define_max_snp_strength);
}

uint32
dnx_data_trap_strength_max_ingress_to_egress_compressed_strength_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_strength, dnx_data_trap_strength_define_max_ingress_to_egress_compressed_strength);
}

uint32
dnx_data_trap_strength_default_trap_strength_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_strength, dnx_data_trap_strength_define_default_trap_strength);
}

uint32
dnx_data_trap_strength_default_snoop_strength_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_trap, dnx_data_trap_submodule_strength, dnx_data_trap_strength_define_default_snoop_strength);
}

/*
 * strength tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

shr_error_e
dnx_data_trap_init(
    int unit,
    dnxc_data_module_t *module_data)
{
    SHR_FUNC_INIT_VARS(unit);

    /* Data Struct Init */
    module_data->name = "trap";
    module_data->nof_submodules = _dnx_data_trap_submodule_nof;
    DNXC_DATA_ALLOC(module_data->submodules, dnxc_data_submodule_t, module_data->nof_submodules, "_dnxc_data trap submodules");

    /*
     * Init Submodule data
     */
    SHR_IF_ERR_EXIT(dnx_data_trap_ingress_init(unit, &module_data->submodules[dnx_data_trap_submodule_ingress]));
    SHR_IF_ERR_EXIT(dnx_data_trap_erpp_init(unit, &module_data->submodules[dnx_data_trap_submodule_erpp]));
    SHR_IF_ERR_EXIT(dnx_data_trap_etpp_init(unit, &module_data->submodules[dnx_data_trap_submodule_etpp]));
    SHR_IF_ERR_EXIT(dnx_data_trap_strength_init(unit, &module_data->submodules[dnx_data_trap_submodule_strength]));
    /*
     * Attach device module
     */
    if (dnxc_data_mgmt_is_jr2_a0(unit))
    {
        SHR_IF_ERR_EXIT(jr2_a0_data_trap_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_jr2_b0(unit))
    {
        SHR_IF_ERR_EXIT(jr2_a0_data_trap_attach(unit));
        SHR_IF_ERR_EXIT(jr2_b0_data_trap_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_jr2_b1(unit))
    {
        SHR_IF_ERR_EXIT(jr2_a0_data_trap_attach(unit));
        SHR_IF_ERR_EXIT(jr2_b0_data_trap_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_j2c_a0(unit))
    {
        SHR_IF_ERR_EXIT(jr2_a0_data_trap_attach(unit));
        SHR_IF_ERR_EXIT(j2c_a0_data_trap_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_j2c_a1(unit))
    {
        SHR_IF_ERR_EXIT(jr2_a0_data_trap_attach(unit));
        SHR_IF_ERR_EXIT(j2c_a0_data_trap_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_q2a_a0(unit))
    {
        SHR_IF_ERR_EXIT(jr2_a0_data_trap_attach(unit));
        SHR_IF_ERR_EXIT(q2a_a0_data_trap_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_q2a_b0(unit))
    {
        SHR_IF_ERR_EXIT(jr2_a0_data_trap_attach(unit));
        SHR_IF_ERR_EXIT(q2a_a0_data_trap_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_j2p(unit))
    {
        SHR_IF_ERR_EXIT(jr2_a0_data_trap_attach(unit));
        SHR_IF_ERR_EXIT(j2p_a0_data_trap_attach(unit));
    }

exit:
    SHR_FUNC_EXIT;
}
#undef BSL_LOG_MODULE
/* *INDENT-ON* */
