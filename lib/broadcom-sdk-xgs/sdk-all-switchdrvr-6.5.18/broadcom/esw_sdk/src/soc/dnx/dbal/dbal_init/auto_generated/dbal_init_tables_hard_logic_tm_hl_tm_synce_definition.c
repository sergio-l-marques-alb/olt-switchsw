/** \file dbal_init_tables_hard_logic_tm_hl_tm_synce_definition.c
 * Logical DB enums \n 
 * DO NOT EDIT THIS FILE!\n 
 * This file is auto-generated.\n 
 * Edits to this file will be lost when it is regenerated.\n 
 * \n 
 */
/*
 * $Id: $
 $Copyright: (c) 2019 Broadcom.
 Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 */
#ifdef BSL_LOG_MODULE
#  error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_SOCDNX_DBALDNX

#include <src/soc/dnx/dbal/dbal_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data.h>

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_enable_ctrl_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_SYNCE_ENABLE_CTRL;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_SYNCE_ENABLE_CTRL /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "SYNCE_ENABLE_CTRL" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 2;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_J2P_NOTREV;
    table_entry->table_labels[1] = DBAL_LABEL_SYNCE;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CORE_ID /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_RESET /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_NIF_RESET_REVERSE_LOGIC /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    if (DBAL_IS_J2C_A0 || DBAL_IS_Q2A_A0 || DBAL_IS_Q2A_B0)
    {
        /** set app to phy db general information  */
        /** core mode  */
        cur_table_param->core_mode = DBAL_CORE_MODE_DPC;
        /** reference field  */
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** set (hl direct) accesses for field: RESET  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_RESET + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = ECI_SYNC_E_RSTNr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = NIF_SYNC_E_RSTNf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    else if (DBAL_IS_JR2_A0 || DBAL_IS_JR2_B0)
    {
        /** set app to phy db general information  */
        /** core mode  */
        cur_table_param->core_mode = DBAL_CORE_MODE_DPC;
        /** reference field  */
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** set (hl direct) accesses for field: RESET  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_RESET + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_CORE_ID /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = ECI_SYNC_E_RSTNr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = NIF_CORE_0_SYNC_E_RSTNf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_RESET + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_CORE_ID /* field*/, "1" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = ECI_SYNC_E_RSTNr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = NIF_CORE_1_SYNC_E_RSTNf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_output_clk_mode_ctrl_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_SYNCE_OUTPUT_CLK_MODE_CTRL;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_SYNCE_OUTPUT_CLK_MODE_CTRL /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "SYNCE_OUTPUT_CLK_MODE_CTRL" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 2;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_J2P_NOTREV;
    table_entry->table_labels[1] = DBAL_LABEL_SYNCE;
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CLK0_OUTPUT_ENABLE /* field id*/, TRUE /* Valid*/, 1 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CLK1_OUTPUT_ENABLE /* field id*/, TRUE /* Valid*/, 1 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    if (DBAL_IS_JR2_A0 || DBAL_IS_JR2_B0 || DBAL_IS_J2C_A0)
    {
        /** set app to phy db general information  */
        /** core mode  */
        cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
        /** reference field  */
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** set (hl direct) accesses for field: CLK0_OUTPUT_ENABLE  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLK0_OUTPUT_ENABLE + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CFC_SELECT_OUTPUT_OF_SYNCHRONOUS_ETHERNET_PADSr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_PAD_0_OE_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    }
                }
            }
            /** set (hl direct) accesses for field: CLK1_OUTPUT_ENABLE  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLK1_OUTPUT_ENABLE + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CFC_SELECT_OUTPUT_OF_SYNCHRONOUS_ETHERNET_PADSr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_PAD_1_OE_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    else if (DBAL_IS_Q2A_A0 || DBAL_IS_Q2A_B0)
    {
        /** set app to phy db general information  */
        /** core mode  */
        cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
        /** reference field  */
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** set (hl direct) accesses for field: CLK0_OUTPUT_ENABLE  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLK0_OUTPUT_ENABLE + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = ECI_SELECT_OUTPUT_OF_SYNCHRONOUS_ETHERNET_PADSr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_PAD_0_OE_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    }
                }
            }
            /** set (hl direct) accesses for field: CLK1_OUTPUT_ENABLE  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLK1_OUTPUT_ENABLE + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = ECI_SELECT_OUTPUT_OF_SYNCHRONOUS_ETHERNET_PADSr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_PAD_1_OE_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_counter_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_SYNCE_COUNTER;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_SYNCE_COUNTER /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "SYNCE_COUNTER" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 2;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_J2P_NOTREV;
    table_entry->table_labels[1] = DBAL_LABEL_SYNCE;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CORE_ID /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SYNCE_INDEX /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_SYNCE_INDEX /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_COUNTER /* field id*/, TRUE /* Valid*/, 32 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_DPC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** indicate that the access has packedFields  */
        cur_table_param->hl_access[map_idx].is_packed_fields = TRUE;
        /** update access mapping in hl_access struct for the current packed fields  */
        /** set (hl direct) accesses for packed field  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = NMG_SYNC_ETH_COUNTERr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNC_ETH_COUNTER_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                    access_params->block_index.formula_cb = nif_ethu_tx_lane_ctrl_stop_data_blockindex_1_cb;
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_ref_clk_sel_nif_ctrl_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_SYNCE_REF_CLK_SEL_NIF_CTRL;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_SYNCE_REF_CLK_SEL_NIF_CTRL /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "SYNCE_REF_CLK_SEL_NIF_CTRL" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_PARTIALLY_FUNCTIONAL));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 2;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_J2P_NOTREV;
    table_entry->table_labels[1] = DBAL_LABEL_SYNCE;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field id*/, TRUE /* Valid*/, 4 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_NIF_SYNCE_CLK_BLK_ID /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SYNCE_INDEX /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_SYNCE_INDEX /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CLOCK_LANE_SEL /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_NIF_INTERNAL_LANE /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_VALID_LANE_SEL /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_NIF_INTERNAL_LANE /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_LINK_STATUS_LANE_SEL /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_NIF_INTERNAL_LANE /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CLOCK_CHAIN_SEL /* field id*/, TRUE /* Valid*/, 1 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_VALID_CHAIN_SEL /* field id*/, TRUE /* Valid*/, 1 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_LINK_STATUS_CHAIN_SEL /* field id*/, TRUE /* Valid*/, 1 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_NMG_CHAIN_SEL /* field id*/, dnx_data_synce.general.feature_get(unit, dnx_data_synce_general_synce_nmg_chain_select) /* Valid*/, 1 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    if (DBAL_IS_J2C_A0 || DBAL_IS_Q2A_A0 || DBAL_IS_Q2A_B0)
    {
        /** set app to phy db general information  */
        /** core mode  */
        cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
        /** reference field  */
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** set (hl direct) accesses for field: CLOCK_LANE_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof-1" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CLUP_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_1_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: VALID_LANE_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof-1" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CLUP_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_1_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: LINK_STATUS_LANE_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof-1" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CLUP_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_1_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: CLOCK_CHAIN_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof-1" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CLUP_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_1_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: VALID_CHAIN_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof-1" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CLUP_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_1_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: LINK_STATUS_CHAIN_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "DNX_DATA.nif.eth.cdu_nof-1" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CLUP_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_1_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: NMG_CHAIN_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_NMG_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = NMG_SYNC_ETH_CHAIN_SEL_FOR_CLOCK_VLDr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_SEL_N_FOR_CLOCK_VLDf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        {
                            access_params->block_index.formula_int = 0; 
                        }
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_NMG_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = NMG_SYNC_ETH_CHAIN_SEL_FOR_LINK_STATUSr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_SEL_N_FOR_LINK_STATUSf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        {
                            access_params->block_index.formula_int = 0; 
                        }
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_NMG_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = NMG_SYNC_ETH_CHAIN_SEL_FOR_SYNCE_CLK_WINNERr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_SEL_N_FOR_SYNCE_CLK_WINNERf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        {
                            access_params->block_index.formula_int = 0; 
                        }
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    else if (DBAL_IS_JR2_A0 || DBAL_IS_JR2_B0)
    {
        /** set app to phy db general information  */
        /** core mode  */
        cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
        /** reference field  */
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** set (hl direct) accesses for field: CLOCK_LANE_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_2_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_3_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_4_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: VALID_LANE_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_2_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_3_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_4_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: LINK_STATUS_LANE_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_2_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_3_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_LANE_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "3" /* field size*/, "0" /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_4_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: CLOCK_CHAIN_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_2_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_3_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_CLOCK_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_CLOCK_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_4_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: VALID_CHAIN_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_2_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_3_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_VALID_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_VALID_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_4_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: LINK_STATUS_CHAIN_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_LOWER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_2_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_BIGGER_THAN /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDU_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_3_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_0_cb;
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_LINK_STATUS_CHAIN_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_NIF_SYNCE_CLK_BLK /* field*/, "6" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = CDUM_SYNC_ETH_CFGr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SYNC_ETH_CHAIN_LINK_STATUS_SEL_Nf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                        access_params->block_index.formula_cb = synce_ref_clk_sel_nif_ctrl_clock_lane_sel_blockindex_4_cb;
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_ref_clk_div_nif_ctrl_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_SYNCE_REF_CLK_DIV_NIF_CTRL;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_SYNCE_REF_CLK_DIV_NIF_CTRL /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "SYNCE_REF_CLK_DIV_NIF_CTRL" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 2;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_J2P_NOTREV;
    table_entry->table_labels[1] = DBAL_LABEL_SYNCE;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CORE_ID /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SYNCE_INDEX /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_SYNCE_INDEX /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CLOCK_DIV_MODE /* field id*/, TRUE /* Valid*/, 2 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_DIV_PHASE_ZERO /* field id*/, TRUE /* Valid*/, 4 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_DIV_PHASE_ONE /* field id*/, TRUE /* Valid*/, 4 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_DPC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: CLOCK_DIV_MODE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_CLOCK_DIV_MODE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = NMG_SYNC_ETH_CFGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNC_ETH_CLOCK_DIV_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                    access_params->block_index.formula_cb = nif_ethu_tx_lane_ctrl_stop_data_blockindex_1_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: DIV_PHASE_ZERO  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DIV_PHASE_ZERO + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = NMG_SYNC_ETH_CFGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNC_ETH_DIVIDER_PHASE_ZERO_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                    access_params->block_index.formula_cb = nif_ethu_tx_lane_ctrl_stop_data_blockindex_1_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: DIV_PHASE_ONE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DIV_PHASE_ONE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = NMG_SYNC_ETH_CFGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNC_ETH_DIVIDER_PHASE_ONE_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                    access_params->block_index.formula_cb = nif_ethu_tx_lane_ctrl_stop_data_blockindex_1_cb;
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_core_ctrl_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_SYNCE_CORE_CTRL;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_SYNCE_CORE_CTRL /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "SYNCE_CORE_CTRL" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 2;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_J2P_NOTREV;
    table_entry->table_labels[1] = DBAL_LABEL_SYNCE;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CORE_ID /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SYNCE_INDEX /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_SYNCE_INDEX /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SQUELCH_ENABLE /* field id*/, TRUE /* Valid*/, 1 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_LINK_VALID_SEL /* field id*/, TRUE /* Valid*/, 1 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_GTIMER_MODE /* field id*/, TRUE /* Valid*/, 1 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_DPC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: SQUELCH_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_SQUELCH_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = NMG_SYNC_ETH_CFGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNC_ETH_SQUELCH_EN_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: LINK_VALID_SEL  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LINK_VALID_SEL + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = NMG_SYNC_ETH_CFGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNC_ETH_LINK_VALID_SEL_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: GTIMER_MODE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_GTIMER_MODE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = NMG_SYNC_ETH_CFGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNC_ETH_GTIMER_MODE_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->array_offset.formula_cb = synce_counter_null_arrayoffset_0_cb;
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_auto_sequelch_th_ctrl_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_SYNCE_AUTO_SEQUELCH_TH_CTRL;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_SYNCE_AUTO_SEQUELCH_TH_CTRL /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "SYNCE_AUTO_SEQUELCH_TH_CTRL" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 2;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_J2P_NOTREV;
    table_entry->table_labels[1] = DBAL_LABEL_SYNCE;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CORE_ID /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SQUELCH_EN_THRESHOLD /* field id*/, TRUE /* Valid*/, 16 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SQUELCH_DIS_THRESHOLD /* field id*/, TRUE /* Valid*/, 32 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_DPC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: SQUELCH_EN_THRESHOLD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_SQUELCH_EN_THRESHOLD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = NMG_SYNC_ETH_SQUELCH_EN_TH_REGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNC_ETH_SQUELCH_EN_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->block_index.formula_cb = nif_ethu_tx_lane_ctrl_stop_data_blockindex_1_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: SQUELCH_DIS_THRESHOLD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_SQUELCH_DIS_THRESHOLD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = NMG_SYNC_ETH_SQUELCH_DIS_TH_REGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNC_ETH_SQUELCH_DIS_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->block_index.formula_cb = nif_ethu_tx_lane_ctrl_stop_data_blockindex_1_cb;
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_fabric_synce_ref_clk_fdr_ctrl_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_FABRIC_SYNCE_REF_CLK_FDR_CTRL;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_FABRIC_SYNCE_REF_CLK_FDR_CTRL /* table id*/, dnx_data_fabric.general.feature_get(unit, dnx_data_fabric_general_is_supported) /* is valid*/, &is_valid /* is valid value*/, "FABRIC_SYNCE_REF_CLK_FDR_CTRL" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 2;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_J2P_NOTREV;
    table_entry->table_labels[1] = DBAL_LABEL_SYNCE;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CORE_ID /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_MASTER_CLK_SEL /* field id*/, TRUE /* Valid*/, 6 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SLAVE_CLK_SEL /* field id*/, TRUE /* Valid*/, 6 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    if (DBAL_IS_JR2_A0 || DBAL_IS_JR2_B0 || DBAL_IS_J2C_A0)
    {
        /** set app to phy db general information  */
        /** core mode  */
        cur_table_param->core_mode = DBAL_CORE_MODE_DPC;
        /** reference field  */
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** indicate that the access has packedFields  */
            cur_table_param->hl_access[map_idx].is_packed_fields = TRUE;
            /** update access mapping in hl_access struct for the current packed fields  */
            /** set (hl direct) accesses for packed field  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = FDR_SYNC_E_SELECTr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = MASTER_CLK_SELf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->block_index.formula_cb = nif_ethu_tx_lane_ctrl_stop_data_blockindex_1_cb;
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    else if (DBAL_IS_Q2A_A0 || DBAL_IS_Q2A_B0 || DBAL_IS_J2P_A0)
    {
        /** set app to phy db general information  */
        /** core mode  */
        cur_table_param->core_mode = DBAL_CORE_MODE_DPC;
        /** reference field  */
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** set (hl direct) accesses for field: MASTER_CLK_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_MASTER_CLK_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = FDR_SYNC_E_SELECTr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = MASTER_CLK_SELf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->block_index.formula_cb = nif_ethu_tx_lane_ctrl_stop_data_blockindex_1_cb;
                    }
                }
            }
            /** set (hl direct) accesses for field: SLAVE_CLK_SEL  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    /** set access field id  */
                    access_params->access_field_id = DBAL_FIELD_SLAVE_CLK_SEL + instance_index;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = FDR_SYNC_E_SELECTr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = SLAVE_CLK_SELf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                        access_params->block_index.formula_cb = nif_ethu_tx_lane_ctrl_stop_data_blockindex_1_cb;
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_fabric_synce_ref_clk_fmac_sel_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_FABRIC_SYNCE_REF_CLK_FMAC_SEL;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_FABRIC_SYNCE_REF_CLK_FMAC_SEL /* table id*/, dnx_data_fabric.general.feature_get(unit, dnx_data_fabric_general_is_supported) /* is valid*/, &is_valid /* is valid value*/, "FABRIC_SYNCE_REF_CLK_FMAC_SEL" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 2;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_J2P_NOTREV;
    table_entry->table_labels[1] = DBAL_LABEL_SYNCE;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CORE_ID /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_MASTER_FMAC_INSTANCE /* field id*/, TRUE /* Valid*/, 3 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SLAVE_FMAC_INSTANCE /* field id*/, TRUE /* Valid*/, 3 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_DPC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: MASTER_FMAC_INSTANCE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MASTER_FMAC_INSTANCE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_CORE_ID /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ECI_SELECT_OUTPUT_OF_SYNCHRONOUS_ETHERNET_PADSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNCE_MASTER_FMAC_0_SELf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MASTER_FMAC_INSTANCE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_CORE_ID /* field*/, "1" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ECI_SELECT_OUTPUT_OF_SYNCHRONOUS_ETHERNET_PADSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNCE_MASTER_FMAC_1_SELf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: SLAVE_FMAC_INSTANCE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_SLAVE_FMAC_INSTANCE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_CORE_ID /* field*/, "0" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ECI_SELECT_OUTPUT_OF_SYNCHRONOUS_ETHERNET_PADSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNCE_SLAVE_FMAC_0_SELf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_SLAVE_FMAC_INSTANCE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_CORE_ID /* field*/, "1" /* value*/, (uint32) DBAL_DB_INVALID /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ECI_SELECT_OUTPUT_OF_SYNCHRONOUS_ETHERNET_PADSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNCE_SLAVE_FMAC_1_SELf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_fabric_synce_ref_clk_fsrd_ctrl_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_FABRIC_SYNCE_REF_CLK_FSRD_CTRL;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_FABRIC_SYNCE_REF_CLK_FSRD_CTRL /* table id*/, dnx_data_fabric.general.feature_get(unit, dnx_data_fabric_general_is_supported) /* is valid*/, &is_valid /* is valid value*/, "FABRIC_SYNCE_REF_CLK_FSRD_CTRL" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 2;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_J2P_NOTREV;
    table_entry->table_labels[1] = DBAL_LABEL_SYNCE;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_FABRIC_SYNCE_CLK_BLK /* field id*/, TRUE /* Valid*/, 4 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_FABRIC_SYNCE_CLK_BLK_ID /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_MASTER_CLK_SEL /* field id*/, TRUE /* Valid*/, 4 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SLAVE_CLK_SEL /* field id*/, TRUE /* Valid*/, 4 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_DIV_PHASE_0 /* field id*/, dnx_data_synce.general.feature_get(unit, dnx_data_synce_general_synce_no_sdm_mode) /* Valid*/, 4 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_DIV_PHASE_1 /* field id*/, dnx_data_synce.general.feature_get(unit, dnx_data_synce_general_synce_no_sdm_mode) /* Valid*/, 4 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: MASTER_CLK_SEL  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MASTER_CLK_SEL + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = FSRD_SYNC_E_SELECTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = MASTER_CLK_SELf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->block_index.formula_cb = fabric_synce_ref_clk_fsrd_ctrl_master_clk_sel_blockindex_0_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: SLAVE_CLK_SEL  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_SLAVE_CLK_SEL + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = FSRD_SYNC_E_SELECTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SLAVE_CLK_SELf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->block_index.formula_cb = fabric_synce_ref_clk_fsrd_ctrl_master_clk_sel_blockindex_0_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: DIV_PHASE_0  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DIV_PHASE_0 + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = FSRD_SYNC_E_SELECTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNC_E_CLK_DIV_PHASE_0f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->block_index.formula_cb = fabric_synce_ref_clk_fsrd_ctrl_master_clk_sel_blockindex_0_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: DIV_PHASE_1  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DIV_PHASE_1 + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = FSRD_SYNC_E_SELECTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SYNC_E_CLK_DIV_PHASE_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->block_index.formula_cb = fabric_synce_ref_clk_fsrd_ctrl_master_clk_sel_blockindex_0_cb;
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_init(
int unit,
table_db_struct_t* cur_table_param,
dbal_logical_table_t * table_info)
{
    SHR_FUNC_INIT_VARS(unit);
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_enable_ctrl_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_output_clk_mode_ctrl_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_counter_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_ref_clk_sel_nif_ctrl_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_ref_clk_div_nif_ctrl_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_core_ctrl_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_synce_auto_sequelch_th_ctrl_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_fabric_synce_ref_clk_fdr_ctrl_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_fabric_synce_ref_clk_fmac_sel_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_synce_definition_fabric_synce_ref_clk_fsrd_ctrl_init(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}
