/** \file dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition.c
 * Logical DB enums \n 
 * DO NOT EDIT THIS FILE!\n 
 * This file is auto-generated.\n 
 * Edits to this file will be lost when it is regenerated.\n 
 * \n 
 */
/*
 * $Id: $
 $Copyright: (c) 2019 Broadcom.
 Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 */
#ifdef BSL_LOG_MODULE
#  error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_SOCDNX_DBALDNX

#include <src/soc/dnx/dbal/dbal_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data.h>

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_action_profile_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_TRAP_ACTION_PROFILE;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_TRAP_ACTION_PROFILE /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_TRAP_ACTION_PROFILE" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_TRAP;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_ETPP_TRAP_ID /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_ETPP_TRAP_ID /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_TRAP_ACTION_PROFILE /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_TRAP_ACTION_PROFILE /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_TRAP_FWD_STRENGTH /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_TRAP_FWD_STRENGTH /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_TRAP_SNP_STRENGTH /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_TRAP_SNP_STRENGTH /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: TRAP_ACTION_PROFILE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_ACCEPTABLE_FRAME /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPA_CFG_TRAP_ACTION_PROFILE_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_ACCEPTABLE_FRAME_TRAP_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_GLEM_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPA_CFG_TRAP_ACTION_PROFILE_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_GLEM_TRAP_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_VLAN_MEMBERSHIP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPB_CFG_MEMBERSHIP_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_MEMBERSHIP_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_STP_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPB_CFG_STP_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_STP_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_LATENCY_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_LATENCY_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_LATENCY_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_METERING_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_METERING_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_METERING_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_PROTECTION_DB_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_PROTECTION_DB_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_PROTECTION_DB_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_SPLIT_HORIZON /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_SPLIT_HORIZON_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_SPLIT_HORIZON_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_STACK_TRAP_1 /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_STACK_TRAP_1_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_STACK_TRAP_1_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_STACK_TRAP_2 /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_STACK_TRAP_2_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_STACK_TRAP_2_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: TRAP_FWD_STRENGTH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_ACCEPTABLE_FRAME /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPA_CFG_FORWARDING_ACTION_STRENGTH_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_ACCEPTABLE_FRAME_TRAP_FWD_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_GLEM_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPA_CFG_FORWARDING_ACTION_STRENGTH_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_GLEM_TRAP_FWD_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_VLAN_MEMBERSHIP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPB_CFG_MEMBERSHIP_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_MEMBERSHIP_FWD_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_STP_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPB_CFG_STP_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_STP_FWD_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_LATENCY_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_LATENCY_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_LATENCY_FWD_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_METERING_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_METERING_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_METERING_FWD_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_PROTECTION_DB_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_PROTECTION_DB_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_PROTECTION_DB_FWD_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_SPLIT_HORIZON /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_SPLIT_HORIZON_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_SPLIT_HORIZON_FWD_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_STACK_TRAP_1 /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_STACK_TRAP_1_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_STACK_TRAP_1_FWD_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_STACK_TRAP_2 /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_STACK_TRAP_2_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_STACK_TRAP_2_FWD_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: TRAP_SNP_STRENGTH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_ACCEPTABLE_FRAME /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPA_CFG_SNOOP_ACTION_STRENGTH_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_ACCEPTABLE_FRAME_TRAP_SNOOP_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_GLEM_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPA_CFG_SNOOP_ACTION_STRENGTH_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_GLEM_TRAP_SNOOP_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_VLAN_MEMBERSHIP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPB_CFG_MEMBERSHIP_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_MEMBERSHIP_SNOOP_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_STP_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPB_CFG_STP_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_STP_SNOOP_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_LATENCY_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_LATENCY_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_LATENCY_SNOOP_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_METERING_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_METERING_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_METERING_SNOOP_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_PROTECTION_DB_TRAP /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_PROTECTION_DB_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_PROTECTION_DB_SNOOP_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_SPLIT_HORIZON /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_SPLIT_HORIZON_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_SPLIT_HORIZON_SNOOP_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_STACK_TRAP_1 /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_STACK_TRAP_1_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_STACK_TRAP_1_SNOOP_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], DBAL_CONDITION_EQUAL_TO /* type*/, DBAL_FIELD_ETPP_TRAP_ID /* field*/, NULL /* value*/, (uint32) DBAL_ENUM_FVAL_ETPP_TRAP_ID_STACK_TRAP_2 /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_STACK_TRAP_2_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_STACK_TRAP_2_SNOOP_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_snif_map_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_TRAP_SNIF_MAP;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_TRAP_SNIF_MAP /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_TRAP_SNIF_MAP" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_SNIF;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SNIF_ACTION_PROFILE /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_SNIF_ACTION_PROFILE /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_SNP_ACTION_PROFILE /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_SNP_ACTION_PROFILE /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_TRAP_SNP_STRENGTH /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_TRAP_SNP_STRENGTH /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_MRR_ACTION_PROFILE /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_MRR_ACTION_PROFILE /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: SNP_ACTION_PROFILE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_SNP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPA_CFG_MAP_SNIFF_TO_SNOOP_ACTIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->data_offset.formula_cb = etpp_trap_snif_map_snp_action_profile_dataoffset_0_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: TRAP_SNP_STRENGTH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPA_CFG_MAP_SNIFF_TO_SNOOP_STRENGTHr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->data_offset.formula_cb = etpp_trap_snif_map_snp_action_profile_dataoffset_0_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: MRR_ACTION_PROFILE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MRR_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPA_CFG_MAP_SNIFF_TO_MIRROR_ACTIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->data_offset.formula_cb = etpp_trap_snif_map_snp_action_profile_dataoffset_0_cb;
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_strength_map_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_TRAP_STRENGTH_MAP;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_TRAP_STRENGTH_MAP /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_TRAP_STRENGTH_MAP" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_TRAP;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_TRAP_COMPRESSED_STRENGTH /* field id*/, TRUE /* Valid*/, 3 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_TRAP_FWD_STRENGTH /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_TRAP_FWD_STRENGTH /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: TRAP_FWD_STRENGTH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPA_CFG_MAP_FORWARD_STRENGTH_TO_STRENGTHr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->data_offset.formula_cb = erpp_trap_strength_map_trap_fwd_strength_dataoffset_0_cb;
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_cfg_fhei_type_cpu_trap_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_CFG_FHEI_TYPE_CPU_TRAP;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_CFG_FHEI_TYPE_CPU_TRAP /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_CFG_FHEI_TYPE_CPU_TRAP" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_TRAP;
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_CFG_FHEI_TYPE_CPU_TRAP /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_FHEI_TYPE /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** indicate that the access has packedFields  */
        cur_table_param->hl_access[map_idx].is_packed_fields = TRUE;
        /** update access mapping in hl_access struct for the current packed fields  */
        /** set (hl direct) accesses for packed field  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPB_CFG_FHEI_TYPE_CPU_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_FHEI_TYPE_CPU_TRAPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_cfg_deny_meter_on_trap_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_CFG_DENY_METER_ON_TRAP;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_CFG_DENY_METER_ON_TRAP /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_CFG_DENY_METER_ON_TRAP" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_TRAP;
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_DENY_METER_ON_PROTECTION_TRAP /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_DENY_METER_ON_STACK_TRAP /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_DENY_METER_ON_SPLIT_HORIZON_TRAP /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** indicate that the access has packedFields  */
        cur_table_param->hl_access[map_idx].is_packed_fields = TRUE;
        /** update access mapping in hl_access struct for the current packed fields  */
        /** set (hl direct) accesses for packed field  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_DONT_METERr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_DONT_METER_ON_PROTECTION_TRAPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_cfg_deny_count_on_trap_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_CFG_DENY_COUNT_ON_TRAP;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_CFG_DENY_COUNT_ON_TRAP /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_CFG_DENY_COUNT_ON_TRAP" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_TRAP;
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_DENY_COUNT_ON_PROTECTION_TRAP /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_DENY_COUNT_ON_STACK_TRAP /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_DENY_COUNT_ON_SPLIT_HORIZON_TRAP /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** indicate that the access has packedFields  */
        cur_table_param->hl_access[map_idx].is_packed_fields = TRUE;
        /** update access mapping in hl_access struct for the current packed fields  */
        /** set (hl direct) accesses for packed field  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_DONT_COUNTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_DONT_COUNT_ON_PROTECTION_TRAPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_mtu_map_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_TRAP_MTU_MAP;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_TRAP_MTU_MAP /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_TRAP_MTU_MAP" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_TRAP;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_LAYER_TYPE_COMPRESSED /* field id*/, TRUE /* Valid*/, 3 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_MTU_PROFILE /* field id*/, TRUE /* Valid*/, 3 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_MTU_PROFILE /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_MTU /* field id*/, TRUE /* Valid*/, 14 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_TRAP_ACTION_PROFILE /* field id*/, TRUE /* Valid*/, 3 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_TRAP_ACTION_PROFILE /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_TRAP_FWD_STRENGTH /* field id*/, TRUE /* Valid*/, 4 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_TRAP_FWD_STRENGTH /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_TRAP_SNP_STRENGTH /* field id*/, TRUE /* Valid*/, 3 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_TRAP_SNP_STRENGTH /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: MTU  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MTU + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    /** set field hw Entity id  */
                    fieldHwEntityId = MTUf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_ETPP_MTU_MAP_TABLE /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: TRAP_ACTION_PROFILE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    /** set field hw Entity id  */
                    fieldHwEntityId = MTU_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_ETPP_MTU_MAP_TABLE /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: TRAP_FWD_STRENGTH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_FWD_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    /** set field hw Entity id  */
                    fieldHwEntityId = MTU_FWD_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_ETPP_MTU_MAP_TABLE /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: TRAP_SNP_STRENGTH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRAP_SNP_STRENGTH + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    /** set field hw Entity id  */
                    fieldHwEntityId = MTU_SNOOP_ACTION_STRENGTHf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_ETPP_MTU_MAP_TABLE /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_mtu_layer_type_map_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_TRAP_MTU_LAYER_TYPE_MAP;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_TRAP_MTU_LAYER_TYPE_MAP /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_TRAP_MTU_LAYER_TYPE_MAP" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_TRAP;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_ENC_LAYER_TYPE /* field id*/, TRUE /* Valid*/, 5 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_LAYER_TYPE_COMPRESSED /* field id*/, TRUE /* Valid*/, 3 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: LAYER_TYPE_COMPRESSED  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAYER_TYPE_COMPRESSED + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROTOCOL_TYPE_COMPRESSEDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_ETPP_PROTOCOL_TYPE_COMPRESSED_MAP /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_stack_trap_mirror_action_profile_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_STACK_TRAP_MIRROR_ACTION_PROFILE;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_STACK_TRAP_MIRROR_ACTION_PROFILE /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_STACK_TRAP_MIRROR_ACTION_PROFILE" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_TRAP;
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_MRR_ACTION_PROFILE /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_MRR_ACTION_PROFILE /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** indicate that the access has packedFields  */
        cur_table_param->hl_access[map_idx].is_packed_fields = TRUE;
        /** update access mapping in hl_access struct for the current packed fields  */
        /** set (hl direct) accesses for packed field  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_STACK_MIRROR_ACTION_PROFILEr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_STACK_MIRROR_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_lif_action_profile_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_TRAP_LIF_ACTION_PROFILE;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_TRAP_LIF_ACTION_PROFILE /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_TRAP_LIF_ACTION_PROFILE" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_TRAP;
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_ACTION_PROFILE /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_ACTION_PROFILE /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_STACK_TRAP_1_ENABLE /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_STACK_TRAP_2_ENABLE /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_STACK_MRR_ENABLE /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: STACK_TRAP_1_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_STACK_TRAP_1_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_MAP_STACK_ACTION_PROFILE_IDXr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_MAP_STACK_ACTION_PROFILE_IDX_TRAP_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->data_offset.formula_cb = etpp_trap_lif_action_profile_stack_trap_1_enable_dataoffset_0_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: STACK_TRAP_2_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_STACK_TRAP_2_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_MAP_STACK_ACTION_PROFILE_IDXr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_MAP_STACK_ACTION_PROFILE_IDX_TRAP_2f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->data_offset.formula_cb = etpp_trap_lif_action_profile_stack_trap_1_enable_dataoffset_0_cb;
                }
            }
        }
        /** set (hl direct) accesses for field: STACK_MRR_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_STACK_MRR_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_MAP_STACK_ACTION_PROFILE_IDXr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_MAP_STACK_ACTION_PROFILE_IDX_MIRRORf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    access_params->data_offset.formula_cb = etpp_trap_lif_action_profile_stack_trap_1_enable_dataoffset_0_cb;
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_latency_trap_mirror_action_profile_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_LATENCY_TRAP_MIRROR_ACTION_PROFILE;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_LATENCY_TRAP_MIRROR_ACTION_PROFILE /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_LATENCY_TRAP_MIRROR_ACTION_PROFILE" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_TRAP;
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_MRR_ACTION_PROFILE /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_MRR_ACTION_PROFILE /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_MRR_ACTION_PROFILE_ENABLE /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: MRR_ACTION_PROFILE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MRR_ACTION_PROFILE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_LATENCY_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_LATENCY_MIRROR_ACTION_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: MRR_ACTION_PROFILE_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MRR_ACTION_PROFILE_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPC_CFG_LATENCY_TRAP_PARAMSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CFG_LATENCY_MIRROR_ACTION_PROFILE_VALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_int_signals_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ETPP_INT_SIGNALS;
    int is_valid = FALSE;
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, table_entry, DBAL_TABLE_ETPP_INT_SIGNALS /* table id*/, TRUE /* is valid*/, &is_valid /* is valid value*/, "ETPP_INT_SIGNALS" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    if (!is_valid)
    {
        SHR_EXIT();
    }
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, table_entry, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_TRAP;
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, DBAL_FIELD_PORT_MTU_TRAP /* field id*/, TRUE /* Valid*/, 0 /* Size*/, 0 /* Offset*/, DBAL_DB_INVALID /* MaxValue*/, 0 /* MinValue*/, NULL /* ConstValue*/, 1 /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        cur_table_param->is_standard_1_table = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        cur_table_param->is_compatible_with_all_images = TRUE;
    }
    /** set app to phy db general information  */
    /** core mode  */
    cur_table_param->core_mode = DBAL_CORE_MODE_SBC;
    /** reference field  */
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: PORT_MTU_TRAP  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_PORT_MTU_TRAP + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, NULL /* field size*/, NULL /* field offset*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ETPPB_ETPPB_INT_REGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PORT_MTU_TRAP_INTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_init(
int unit,
table_db_struct_t* cur_table_param,
dbal_logical_table_t * table_info)
{
    SHR_FUNC_INIT_VARS(unit);
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_action_profile_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_snif_map_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_strength_map_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_cfg_fhei_type_cpu_trap_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_cfg_deny_meter_on_trap_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_cfg_deny_count_on_trap_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_mtu_map_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_mtu_layer_type_map_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_stack_trap_mirror_action_profile_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_trap_lif_action_profile_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_latency_trap_mirror_action_profile_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_trap_hl_pp_etpp_trap_definition_etpp_int_signals_init(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}
