<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDK API Guide: Packet Transmit and Receive</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_brcm.css" rel="stylesheet" type="text/css"/>
<link href="tabs_brcm.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SDK API Guide
   &#160;<span id="projectnumber">Version 6.5.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Packet Transmit and Receive </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The BCM packet transmit and receive APIs provide the ability to receive packets captured from the data plane and to send packets to the data plane from the Host CPU. Typical uses for these functions are to implement various networking control protocols or "slow path" session handling.</p>
<p>"Transmit" and "receive" are named from the point of view of the Host CPU, so a "tx" routine sends a packet from the Host CPU to egress some switch port, while "rx" routines handle packets extracted from the data plane. Selection of the frames that get captured to the Host CPU is handled by other modules such as the field processor.</p>
<p>When inband management is enabled, these same APIs handle packets in the inband control plane.</p>
<p>The BCM API presents packets in a standard format. The API defines a structure, bcm_pkt_t, which includes both the actual packet data as well as additional metadata available to the switch device that is not part of the actual frame, such as the ingress port or destination. Packet data is pointed to by a member of the bcm_pkt_t structure, and metadata is presented in other fields of that structure.</p>
<p>The Host CPU can transmit a single frame to one or more ports with a single call. The packet structure thus specifies the destination port(s) with a port bitmap.</p>
<p>The bcm_pkt_t structure contains a flags member that indicates optional behavior. Flags that appear in this field are defined symbols that use the prefix BCM_PKT_F_ or BCM_TX_. See ( <a class="el" href="trtx.html#pkt_flags_table">pkt_flags_table</a> ) for details of the flags field.</p>
<p>This section is divided into the following sub-sections:</p>
<ul>
<li>BCM Packet Structure, bcm_pkt_t ( txrx_pkt )</li>
<li>BCM TX API ( txrx_bcm_tx)</li>
<li>BCM RX API ( txrx_bcm_rx)</li>
<li>BCM RX Pool Reference Implementation ( txrx_bcm_rx_pool)</li>
<li>Abstract Transport Function Types ( txrx_functions)</li>
<li>Packet Tunneling ( txrx_tunnel)</li>
</ul>
<h1><a class="anchor" id="bcm_packet_structure"></a>
BCM Packet Structure</h1>
<p>The BCM packet structure, bcm_pkt_t, represents a data frame and any associated metadata. It provides:</p>
<ul>
<li>A uniform view of packets in transmit and receive operations as well as the BCM API</li>
<li>Support for multiple data buffers per packet (scatter-gather support)</li>
<li>Support for transmitting chains of packets</li>
<li>Zero-copy of packet data through the driver stack</li>
</ul>
<p>The BCM packet structure is divided into two parts:</p>
<ul>
<li>The actual packet data and a description of the frame format</li>
<li>Additional information about the packet not part of the actual packet (such as the port on which the packet was received).</li>
</ul>
<p>This second category is referred to as "metadata". The metadata occupies many more members in the structure. Some of those members are specific to transmit or receive.</p>
<p>The packet data proper is represented by a variable length array of (pointer, length) pairs called "blocks".</p>
<p><a class="anchor" id="pkt_blk_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>bcm_pkt_blk_t Structure Description</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>data </td><td>\sc uint8 * \ec </td><td>Pointer to a block of packet data  </td></tr>
<tr>
<td>len </td><td>int </td><td>The length of this block in bytes  </td></tr>
</table>
<p>The bcm_pkt_t contains a pointer to an array of these blocks, and a length of this array, "blk_count". Usually, one packet will require only one block, though this depends on the application's buffer management policy.</p>
<p>All other members of the bcm_pkt_t structure are metadata. The meaning of each field is described in txrx_pkt . In the receive direction, metadata in the bcm_pkt_t structure is parsed from the device-specific format supplied by the hardware. Some devices support a rich set of metadata, and this parsing can be a significant portion of the cost of handling a packet. So, applications which do not require the full metadata may opt to disable the driver parser and instead supply their own custom parser to extract only fields of interest. In the transmit direction, application code fills in any necessary fields in the bcm_pkt_t structure. The SDK routines will use these fields to correctly format the entire frame as required by the specific switch device. <a class="anchor" id="bcm_pkt_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>bcm_pkt_t Structure Description</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>pkt_data </td><td>bcm_pkt_blk_t * </td><td>Pointer to an array of packet data blocks  </td></tr>
<tr>
<td>blk_count </td><td>uint8 </td><td>Number of elements in the pkt_data array  </td></tr>
<tr>
<td>unit </td><td>uint8 </td><td><p class="starttd">For TX, this is the BCM device number on which the packet is to be transmitted. It may be a remote device number on StrataXGS systems. This will generally be overridden by the parameter specification in a <a class="el" href="tx_8h.html#a9ae99f63ac8ad48b70b986adecac0ef4">bcm_tx_f</a> type call.</p>
<p class="endtd">For RX, this is the BCM device number on which the packet was received. This may be a remote device number indicating that the packet was tunneled from a remote subsystem.   </p>
</td></tr>
<tr>
<td>cos </td><td>uint8 </td><td><p class="starttd">For TX and RX, this is the class of service queue on which the packet traverses the hardware.</p>
<p class="endtd">This may have interactions with the prio_int field if the packet goes across multiple devices in the system.   </p>
</td></tr>
<tr>
<td>prio_int </td><td>uint8 </td><td><p class="starttd">For TX and RX, this is the internal priority associated with the packet. When a packet is received by the hardware from a front-panel port, the ingress logic determines this value based on various settings as well as the packet data. For example, the priority may come directly from the VLAN tag if present; alternatively ingress filtering may set this to a different value.</p>
<p class="endtd">The internal priority is used to determine the hardware CoS queue on which a packet is placed.   </p>
</td></tr>
<tr>
<td>vlan </td><td>bcm_vlan_t </td><td>For RX, this is the 802.1q VLAN ID or Virtual Switching Instance (VSI) or Virtual Private Network (VPN) on which the packet was received on.   </td></tr>
<tr>
<td>vlan_pri </td><td>uint8 </td><td>Outer VLAN tag priority.  </td></tr>
<tr>
<td>vlan_cfi </td><td>uint8 </td><td>Outer VLAN tag cfi bit.  </td></tr>
<tr>
<td>inner_vlan </td><td>bcm_vlan_t </td><td>For double tagged packets inner VLAN ID.  </td></tr>
<tr>
<td>inner_vlan_pri </td><td>uint8 </td><td>Inner VLAN tag priority.  </td></tr>
<tr>
<td>inner_vlan_cfi </td><td>uint8 </td><td>Inner VLAN tag cfi bit.  </td></tr>
<tr>
<td>color </td><td>bcm_color_t </td><td>Packet color.  </td></tr>
<tr>
<td>src_port </td><td>int16 </td><td><p class="starttd">The apparent port on which the packet arrived. For RX, this is the port on the device on which the packet was originally received (paired with src_mod).</p>
<p class="endtd">For TX, this value is normally the CPU source port. However, that may be overridden by setting the flag BCM_TX_SRC_PORT. See <a class="el" href="trtx.html#pkt_flags_table">pkt_flags_table</a> .   </p>
</td></tr>
<tr>
<td>src_trunk </td><td>bcm_trunk_t </td><td>Source trunk group ID if src_port/src_mod is not used.  </td></tr>
<tr>
<td>src_mod </td><td>uint16 </td><td><p class="starttd">The apparent device module ID (fabric mapping ID) on which the packet arrived.</p>
<p class="endtd">For TX, this controls the value placed in the HiGig header if the packet is transmitted across a fabric device. This value is normally the module ID of the device on which the CPU is sending the packet. However, that may be overridden by setting the flag BCM_TX_SRC_MOD. See <a class="el" href="trtx.html#pkt_flags_table">pkt_flags_table</a> .   </p>
</td></tr>
<tr>
<td>dest_port </td><td>uint16 </td><td><p class="starttd">The port to which the packet was mapped. For RX, if the packet was copied to the CPU, this will be the port to which the packet would normally be sent, paired with dest_mod below.</p>
<p class="endtd">For TX, this controls the value placed in the HiGig header if the packet is transmitted on a HiGig port. The immediate port on which the packet will be transmitted is determined by tx_pbmp, described in the following paragraph. If the packet goes across more than one device, then the dest_port will determine the ultimate egress port along with dest_mod.   </p>
</td></tr>
<tr>
<td>dest_mod </td><td>uint16 </td><td><p class="starttd">The device module ID to which the packet is destined. For RX if the packet was copied to the CPU, this will be the module ID of the device to which the packet would normally be sent, paired with dest_port, above.</p>
<p class="endtd">For TX, this controls the value placed in the HiGig header if the packet is transmitted on a HiGig port. The immediate device on which the packet will be transmitted is determined by the unit parameter in bcm_tx. If the packet goes across more than one device, then the dest_mod will determine the ultimate egress device for the packet.   </p>
</td></tr>
<tr>
<td>opcode </td><td>uint8 </td><td>The opcode associated with the packet. See <a class="el" href="trtx.html#pkt_opcode_table">pkt_opcode_table</a> . The opcode can be set on TX and will affect how the packet traverses multiple devices.   </td></tr>
<tr>
<td>dst_gport </td><td>bcm_gport_t </td><td>Packet destination virtual port. Valid if BCM_PKT_STK_F_DST_PORT stack flag is set. Specifies the destination virtual port for a HiGig2 packet on devices which support both HiGig2 and virtual ports.   </td></tr>
<tr>
<td>src_gport </td><td>bcm_gport_t </td><td>Packet source virtual port. Valid if BCM_PKT_STK_F_SRC_PORT stack flag is set. Specifies the source virtual port for a HiGig2 packet on devices which support both HiGig2 and virtual ports.   </td></tr>
<tr>
<td>multicast_group </td><td>bcm_multicast_t </td><td>Destination multicast group. Now uses the same encoding as bcm_multicast_* APIs.  </td></tr>
<tr>
<td>timesync_flags </td><td>uint32 </td><td>timesync packet flags. See <a class="el" href="trtx.html#pkt_timesync_flags_table">pkt_timesync_flags_table</a> .  </td></tr>
<tr>
<td>stk_flags </td><td>uint32 </td><td>Stacking header flags. See <a class="el" href="trtx.html#pkt_stk_flags_table">pkt_stk_flags_table</a> .  </td></tr>
<tr>
<td>stk_forward </td><td>bcm_pkt_stk_forward_t </td><td>Stacking header forwarding opcode for HiGig2 packets. See <a class="el" href="trtx.html#pkt_stk_forward_table">pkt_stk_forward_table</a> .   </td></tr>
<tr>
<td>stk_classification_tag </td><td>uint32 </td><td>Stacking header classification tag for HiGig2 packets. Valid if BCM_PKT_STK_F_CLASSIFICATION_TAG stack flag is set.   </td></tr>
<tr>
<td>stk_pkt_prio </td><td>uint32 </td><td>Stacking header new packet priority for HiGig2 packets. If BCM_PKT_STK_F_DEFERRED_CHANGE_PKT_PRIO stack flag is set, update packet priority to stk_pkt_prio in the egress device.   </td></tr>
<tr>
<td>stk_dscp </td><td>uint32 </td><td>Stacking header new DSCP for HiGig2 packets. If BCM_PKT_STK_F_DEFERRED_CHANGE_DSCP stack flag is set, update dscp value to stk_dscp in the egress device.   </td></tr>
<tr>
<td>stk_load_balancing_number </td><td>uint32 </td><td>Stacking header load balancing number for HiGig2 packets. May be used on egress devices as part of the trunk hash.   </td></tr>
<tr>
<td>stk_encap_id </td><td>bcm_if_t </td><td>Stacking header encapsulation id for operation with remote encapsulation devices via bcmSwitchRemoteEncapsulationMode.  </td></tr>
<tr>
<td>pkt_len </td><td>uint16 </td><td><p class="starttd">For RX, the normal length of the packet in bytes, not including proprietary headers. The packet data may be spread across multiple blocks.</p>
<p class="endtd">For TX, this value is ignored and only the len members of the bcm_pkt_blk_t structures are used.   </p>
</td></tr>
<tr>
<td>tx_pbmp </td><td>bcm_pbmp_t </td><td>For transmit only; the port bitmap on which the packet should be sent on the transmit device.   </td></tr>
<tr>
<td>tx_upbmp </td><td>bcm_pbmp_t </td><td>For transmit only; the port bitmap on which the packet should be sent untagged on the transmit device. This must be a subset of the ports in tx_pbmp.   </td></tr>
<tr>
<td>tx_l3pbmp </td><td>bcm_pbmp_t </td><td>For transmit only; the port bitmap on which the packet should be sent indicating L3 processing (if any) should be carried out. Most L3 processing occurs on ingress and an indication is carried along with the packet to indicate that processing was done. This bitmap allows the CPU to set this bit. Must be a subset of the ports in tx_pbmp.   </td></tr>
<tr>
<td>rx_reason </td><td>uint32 </td><td>For receive only; a bitmap of reason codes for which the packet was forwarded to the CPU. See rx_reason_code_table for a list of reason codes.   </td></tr>
<tr>
<td>rx_reasons </td><td>bcm_rx_reasons_t </td><td>For receive only; a set of packet "reasons " for which the packet was forwarded to the CPU. See rx_reasons_code_table for a list of reason definitions. This takes the place of rx_reason field since rx_reason was limited to 32 reason codes.   </td></tr>
<tr>
<td>rx_path </td><td>uint32 </td><td>For receive only; a bitmap of receiving paths describing how the packet was delivered to the CPU. At present, the possible paths include "SWITCHED", "COPY_TO_CPU", "MIRRORED" or their combination.   </td></tr>
<tr>
<td>rx_unit </td><td>uint8 </td><td>For receive only; the local device on which the packet was received. If the packet was tunneled from a remote subsystem, the original device is indicated by pkt-&gt;unit while the local device is indicated here.   </td></tr>
<tr>
<td>rx_port </td><td>uint8 </td><td>For receive only; the port on rx_unit on which the packet was received. If the packet was tunneled from a remote subsystem, the original device is indicated by pkt-&gt;port while the local port number is indicated here.   </td></tr>
<tr>
<td>rx_cpu_cos </td><td>uint8 </td><td>For receive only; in some systems, the CoS setting for the packet going to the CPU will be different than the packet's normal CoS setting. This override value is indicated here.   </td></tr>
<tr>
<td>rx_untagged </td><td>uint8 </td><td>For receive only; indicates that the packet was received untagged on ingress. <a class="el" href="trtx.html#rx_untagged_flags">rx_untagged_flags</a>   </td></tr>
<tr>
<td>rx_classification_tag </td><td>uint32 </td><td>For receive only; if the packet was redirected by the field processor, this is the cookie supplied to bcmFieldActionAddClassTag.   </td></tr>
<tr>
<td>rx_matched </td><td>uint32 </td><td>For receive only; if the packet was redirected by the field processor, this is the cookie supplied to bcmFieldActionCopyToCpu.   </td></tr>
<tr>
<td>rx_l3_intf </td><td>bcm_if_t </td><td>For receive only; the L3 interface or egress object to which the packet was directed.  </td></tr>
<tr>
<td>rx_outer_tag_action </td><td>bcm_vlan_action_t </td><td>For receive only; the outer tag action determined for the packet.  </td></tr>
<tr>
<td>rx_inner_tag_action </td><td>bcm_vlan_action_t </td><td>For receive only; the inner tag action determined for the packet.  </td></tr>
<tr>
<td>flags </td><td>uint32 </td><td>Flags for the packet. See <a class="el" href="trtx.html#pkt_flags_table">pkt_flags_table</a> .  </td></tr>
<tr>
<td>next </td><td>\sc void * \ec </td><td>Next pointer supporting linked lists of packets.  </td></tr>
<tr>
<td>_higig </td><td>\sc uint8[16] \ec </td><td><p class="starttd">Raw HiGig header. Contains anapplication-supplied HiGig header to override the header the SDK would create from metadata fields.</p>
<p class="endtd">Packets traveling on a HiGig port maintain a 12- or 16-byte HiGig header. Normally, when a packet is sent by the Host CPU to a HiGig port, the values placed in the HiGig header are derived by the SDK from bcm_pkt_t fields. In cases where the application instead wishes to specify its own HiGig header, this field must be populated with the raw data in network byte order, and the BCM_TX_HG_READY flag set.   </p>
</td></tr>
<tr>
<td>_sbx_rh </td><td>\sc uint8[16] \ec </td><td>SBX (XCore) Route Header and Shim. Applicable only to XCore devices.  </td></tr>
<tr>
<td>_sbx_hdr_len </td><td>\sc uint8[16] \ec </td><td>Length of SBX header(s). Applicable only to XCore devices.  </td></tr>
<tr>
<td>flow_id </td><td>int </td><td>Internal flow ID.  </td></tr>
<tr>
<td>filter_enable </td><td>uint32 </td><td>Filters to be enabled.  </td></tr>
<tr>
<td>flags2 </td><td>uint32 </td><td>Flags2 for the packet. See <a class="el" href="trtx.html#pkt_flags2_table">pkt_flags2_table</a> .  </td></tr>
<tr>
<td>oam_replacement_type </td><td>uint8 </td><td>OAM replacement type used in SOBMH header. See <a class="el" href="trtx.html#pkt_flags2_table">pkt_flags2_table</a>  </td></tr>
<tr>
<td>oam_replacement_offset </td><td>uint8 </td><td>OAM replacement offset used in SOBMH header. See <a class="el" href="trtx.html#pkt_flags2_table">pkt_flags2_table</a>  </td></tr>
<tr>
<td>oam_lm_counter_index </td><td>uint16 </td><td>OAM LM counter index used in SOBMH header. See <a class="el" href="trtx.html#pkt_flags2_table">pkt_flags2_table</a>  </td></tr>
<tr>
<td>rx_trap_data </td><td>uint32 </td><td>Additional trap information  </td></tr>
<tr>
<td>_dcb </td><td>\sc void * \ec </td><td>Pointer for dcb. Used when BCM_RX_F_PKT_UNPARSED flag is set. See flags descriptions in <a class="el" href="rx_8h.html#a7b549c50721c4cd172fe927a0b0305c9">bcm_rx_chan_cfg_t</a> .   </td></tr>
<tr>
<td>oam_lm_counter_index_2 </td><td>uint16 </td><td>OAM Second LM counter index used in SOBMH header. See <a class="el" href="trtx.html#pkt_flags2_table">pkt_flags2_table</a>  </td></tr>
<tr>
<td>ma_ptr </td><td>uint16 </td><td>OAM MA Pointer value. For BCM5645x, this corresponds to endpoint group index . See <a class="el" href="trtx.html#pkt_flags2_table">pkt_flags2_table</a>   </td></tr>
<tr>
<td>timestamp_mode </td><td>bcm_pkt_timestamp_mode_t </td><td>OAM DM timestamp mode. See <a class="el" href="trtx.html#pkt_flags2_table">pkt_flags2_table</a> and <a class="el" href="trtx.html#pkt_timestamp_mode_table">pkt_timestamp_mode_table</a>   </td></tr>
<tr>
<td>counter_mode_1 </td><td>bcm_pkt_oam_lm_counter_mode_t </td><td>OAM LM counter-1 mode. See <a class="el" href="trtx.html#pkt_flags2_table">pkt_flags2_table</a> and <a class="el" href="trtx.html#pkt_oam_lm_counter_mode_table">pkt_oam_lm_counter_mode_table</a>   </td></tr>
<tr>
<td>counter_mode_2 </td><td>bcm_pkt_oam_lm_counter_mode_t </td><td>OAM LM counter-2 mode. See <a class="el" href="trtx.html#pkt_flags2_table">pkt_flags2_table</a> and <a class="el" href="trtx.html#pkt_oam_lm_counter_mode_table">pkt_oam_lm_counter_mode_table</a>   </td></tr>
<tr>
<td>timestamp_offset </td><td>uint8 </td><td>Offset to be placed in the timestamp of the packet  </td></tr>
<tr>
<td>rx_decap_tunnel </td><td>bcm_rx_decap_tunnel_t </td><td>For receive only, type of outer tunnel decapped. See bcm_rx_decap_tunnel_type  </td></tr>
<tr>
<td>src_vport </td><td>bcm_gport_t </td><td>Internal hdr.In-LIF-or-In-RIF field  </td></tr>
<tr>
<td>dst_vport </td><td>bcm_gport_t </td><td>FTMH.OUTLIF_MCID field.If dest_port != -1 then outlif, otherwise MCID  </td></tr>
<tr>
<td>fwd_hdr_offset </td><td>uint32 </td><td>the Forwarding-Header-Offset (in bytes) from start of packet, i.e. Internal_hdr.FWD_HEADER_OFFSET  </td></tr>
<tr>
<td>snoop_cmnd </td><td>int </td><td>indicates the two msb bits in Snoop-Command  </td></tr>
<tr>
<td>stk_dst_gport </td><td>bcm_gport_t </td><td>Stacking destination port (FMTH.DSP-Ext).  </td></tr>
<tr>
<td>stk_route_tm_domains </td><td>uint32 </td><td>Bitmap of the traversed TM domains (FMTH.Stacking_Route-History)  </td></tr>
<tr>
<td>oam_hdr_offset </td><td>uint32 </td><td>Distance (in bytes) to OAM header from start of packet  </td></tr>
<tr>
<td>oam_lm_replacement_offset </td><td>uint8 </td><td>Replacement offset for LM counter in Bytes  </td></tr>
<tr>
<td>rx_oam_pkt_type </td><td>bcm_pkt_rx_oam_type_t </td><td>OAM Pkt Type. Refer <a class="el" href="trtx.html#pkt_rx_oam_type_table">pkt_rx_oam_type_table</a>  </td></tr>
<tr>
<td>oam_counter </td><td>\sc bcm_pkt_oam_counter_t[BCM_PKT_OAM_COUNTER_MAX] \ec </td><td>OAM counter array. Refer <a class="el" href="trtx.html#bcm_pkt_oam_counter_t">bcm_pkt_oam_counter_t</a>  </td></tr>
<tr>
<td>oam_counter_size </td><td>uint32 </td><td>Count of Counters in oam_counter array.  </td></tr>
<tr>
<td>_olp_hdr </td><td>\sc uint8[20] \ec </td><td><p class="starttd">Raw pre-built OLP Header (network byte order). Contains an application-supplied OLP header.</p>
<p class="endtd">Normally, when a packet is sent by the Host CPU to a OLP port, the values placed in the OLP header are derived by the SDK from bcm_pkt_t fields. In cases where the application instead wishes to specify its own OLP header, this field must be populated with the raw data in network byte order, and the flag BCM_PKT_F2_OLP_READY set.   </p>
</td></tr>
<tr>
<td>dnx_header_stack </td><td>\sc bcm_pkt_dnx_t[BCM_PKT_NOF_DNX_HEADERS] \ec </td><td>DNX Header stack . Refer <a class="el" href="trtx.html#bcm_pkt_dnx_t">bcm_pkt_dnx_t</a>  </td></tr>
<tr>
<td>dnx_header_count </td><td>uint8 </td><td>Number of DNX headers.  </td></tr>
<tr>
<td>_ext_higig </td><td>\sc uint8[4] \ec </td><td>Raw Extended HiGig header. Contains an application supplied Extended HiGig header.   </td></tr>
<tr>
<td>txprocmh_qos_fields_valid </td><td>uint8 </td><td>QoS values to be picked up from the packet.  </td></tr>
<tr>
<td>txprocmh_congestion_int </td><td>uint8 </td><td>Congestion priority of the packet.  </td></tr>
<tr>
<td>txprocmh_mcast_lb_index_valid </td><td>uint8 </td><td>If set, use the value from txprocmh_mcast_lb_index.  </td></tr>
<tr>
<td>txprocmh_mcast_lb_index </td><td>uint8 </td><td>Software to select load balancing bitmap.  </td></tr>
<tr>
<td>txprocmh_ecmp_group_index </td><td>uint16 </td><td>Single level ECMP group index.  </td></tr>
<tr>
<td>txprocmh_ecmp_member_index </td><td>uint16 </td><td>ECMP member table index used by a single level ECMP group.  </td></tr>
<tr>
<td>txprocmh_destination </td><td>uint16 </td><td>Destination to be used based on txprocmh_destination_type.  </td></tr>
<tr>
<td>txprocmh_destination_type </td><td>uint8 </td><td>Destination Type/opcode of the packet.  </td></tr>
<tr>
<td>egress_to_cpu_hdr_size </td><td>uint16 </td><td>Size of egress to CPU header in CMIC devices. This header is applicable only in the new generation of CMIC called CMIC-X.   </td></tr>
<tr>
<td>match_id </td><td>\sc uint32[2] \ec </td><td>Match ID information.  </td></tr>
<tr>
<td>forwarding_type </td><td>uint32 </td><td>Packet forwarding type.  </td></tr>
<tr>
<td>forwarding_zone_id </td><td>uint32 </td><td>Indicates packet was routed - UC OR MC.  </td></tr>
<tr>
<td>spid </td><td>uint8 </td><td>Service Pool ID  </td></tr>
<tr>
<td>spid_override </td><td>int </td><td>Indicates use of SPID from packet.  </td></tr>
<tr>
<td>replication_or_nhi </td><td>uint32 </td><td>Indicates replication id or nhi from packet.  </td></tr>
</table>
<p>In addition to these documented members, the bcm_pkt_t structure contains undocumented members to support the internal SDK implementation. Undocumented members should not be directly accessed. </p><h2>Packet Opcodes</h2>
<p>The opcode field provides a rough classification indicating packet type, as detailed in the following table.</p>
<p><a class="anchor" id="pkt_opcode_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Packet Opcode Descriptions</caption>
<tr>
<th>Opcode Identifier </th><td>Description  </td></tr>
<tr>
<td>BCM_HG_OPCODE_CPU </td><td>CPU Frame  </td></tr>
<tr>
<td>BCM_HG_OPCODE_UC </td><td>Unicast Frame  </td></tr>
<tr>
<td>BCM_HG_OPCODE_BC </td><td>Broadcast or DLF frame  </td></tr>
<tr>
<td>BCM_HG_OPCODE_MC </td><td>Multicast Frame  </td></tr>
<tr>
<td>BCM_HG_OPCODE_IPMC </td><td>IP Multicast Frame  </td></tr>
</table>
<h2>BCM Packet Flags</h2>
<p>The bcm_pkt_t "flags" and "flags2" fields contain flags that affect transmit and receive operations. Each flag is described in the following table. Flags named with the prefix BCM_TX apply only to transmit; BCM_RX flags apply only to receive.</p>
<p><a class="anchor" id="pkt_flags_table"></a></p>
<p>stacking.sect.cputrans .</p>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>Packet Flags Descriptions</caption>
<tr>
<th>Flag </th><td>Description  </td></tr>
<tr>
<td>BCM_PKT_F_NO_VTAG </td><td><p class="starttd">The packet payload does not contain a VLAN tag. In general, all packets inside of StrataXGS hardware and inside the Broadcom driver have a VLAN tag. If the VLAN tag is stripped on receive, this flag will be set. If the flag is set on transmit, it is an indication that the packet currently does not have a tag in the payload. See ( <a class="el" href="trtx.html#txrx_dev_specific">Device-Specific Variations</a> ) for details.</p>
<p class="endtd">To indicate to the API that a packet should exit the device untagged, the application must set the untagged bitmap in the packet structure (in addition to the destination port bitmap described above). For fabric devices, the untagged bitmap is ignored. For other devices, the bit corresponding to the egress port must be set.   </p>
</td></tr>
<tr>
<td>BCM_PKT_F_ROUTED </td><td>On TX of a HiGig2 packet, indicate to the egress device that the packet is L3 routed. On RX, this flag indicates that the packet was L3 switched.   </td></tr>
<tr>
<td>BCM_TX_CRC_ALLOC </td><td>Allocate four bytes for the CRC when the packet is transmitted.  </td></tr>
<tr>
<td>BCM_TX_CRC_REGEN </td><td>Regenerate the CRC on transmit (in hardware if possible).  </td></tr>
<tr>
<td>BCM_TX_CRC_APPEND </td><td>Just the combination (logical OR) of BCM_TX_CRC_ALLOC and BCM_TX_CRC_REGEN.   </td></tr>
<tr>
<td>BCM_TX_NO_PAD </td><td>Do not add extra bytes to packets less than 64 bytes (68 for VLAN-tagged packets).   </td></tr>
<tr>
<td>BCM_TX_FAST_PATH </td><td>Indicates that all data is set up and no additional processing  </td></tr>
<tr>
<td>BCM_TX_SRC_MOD </td><td>The source module ID to be associated with the packet should be taken from the packet structure, rather than the default value for the transmit device.   </td></tr>
<tr>
<td>BCM_TX_SRC_PORT </td><td>As for BCM_TX_SRC_MOD, but for the source port.  </td></tr>
<tr>
<td>BCM_TX_PFM </td><td>As for BCM_TX_SRC_MOD, but for the Port Filtering Mode.  </td></tr>
<tr>
<td>BCM_TX_PRIO_INT </td><td>As for BCM_TX_SRC_MOD, but for the internal priority value.  </td></tr>
<tr>
<td>BCM_TX_PKT_PROP_ANY </td><td>This is a mask for the above four flags: BCM_TX_SRC_MOD, BCM_TX_SRC_PORT, BCM_TX_PFM and BCM_TX_PRIO_INT.   </td></tr>
<tr>
<td>BCM_TX_ETHER </td><td>Only supported on StrataXGS III switches. Indicates that the packet should be sent through ingress logic on the device. If BCM_TX_HG_READY or any BCM_PKT_PKT_PROP_ANY flags are set, then HiGig ingress processing will be done. Otherwise normal Ethernet ingress processing is done. See txrx for details.   </td></tr>
<tr>
<td>BCM_TX_HG_READY </td><td>Use the _higig packet member for the HiGig header if the packet is destined for a HiGig port. See txrx for details.   </td></tr>
<tr>
<td>BCM_TX_RELIABLE </td><td>Indicates that, if the packet is tunneled by the BCM layer, then a reliable transport should be used if possible.   </td></tr>
<tr>
<td>BCM_TX_BEST_EFFORT </td><td>Indicates that, if the packet is tunneled by the BCM layer, then a best effort transport should be used if possible.   </td></tr>
<tr>
<td>BCM_TX_LOOPBACK </td><td>CPU intended loop backed packets.  </td></tr>
<tr>
<td>BCM_TX_LINKDOWN_TRANSMIT </td><td>Allows packet to be transmitted while the link is down.  </td></tr>
<tr>
<td>BCM_RX_LEARN_DISABLED </td><td>Indicates that the packet's SA is not learned.  </td></tr>
<tr>
<td>BCM_RX_CRC_STRIP </td><td>On receive, remove the CRC from the packet length. If this is set, the packet length \sc pkt-&gt;pkt_len \ec does not include the four bytes of the CRC.   </td></tr>
<tr>
<td>BCM_RX_TUNNELLED </td><td>This flag indicates that the packet was received by a remote CPU and forwarded to this CPU by tunneling. See txrx_tunnel .   </td></tr>
<tr>
<td>BCM_RX_MIRRORED </td><td>This flag indicates that the packet was mirrored to the CPU, that is, not copied or switched. This flag is supported by StrataXGS III devices only.   </td></tr>
<tr>
<td>BCM_RX_TRUNCATED </td><td>This flag indicates that the packet was larger than the RX buffer size and has been truncated. Oversized packets are discarded by default.   </td></tr>
<tr>
<td>BCM_TX_NO_VISIBILITY_RESUME </td><td>This flag indicates that visibility resume is disabled when sending packets on Dune devices. Visibility resume is enabled by default.   </td></tr>
</table>
<p>For transmitting packet length less than 64 bytes, the final packet size is decided based on the combination of related bcm_pkt_t flags including BCM_TX_NO_PAD, BCM_PKT_F_NO_VTAG and BCM_TX_CRC_APPEND. <a class="anchor" id="pkt_tx_flags_example_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Packet length (in bytes) transmitted for payload size (N bytes) less than 64 bytes</caption>
<tr>
<th>bcm_pkt_t "flags" </th><th>Packet lengh (Tagged packet) </th><th>Packet lengh (Untagged packet)  </th></tr>
<tr>
<td>without flags * </td><td>68 </td><td>64  </td></tr>
<tr>
<td>BCM_PKT_F_NO_VTAG * </td><td>68 </td><td>64  </td></tr>
<tr>
<td>BCM_TX_CRC_APPEND * </td><td>68 </td><td>64  </td></tr>
<tr>
<td>BCM_TX_NO_PAD ** </td><td>N </td><td>N-4  </td></tr>
<tr>
<td>BCM_TX_NO_PAD|BCM_PKT_F_NO_VTAG ** </td><td>N+4 </td><td>N  </td></tr>
<tr>
<td>BCM_TX_NO_PAD|BCM_TX_CRC_APPEND ** </td><td>N+4 </td><td>N  </td></tr>
<tr>
<td>BCM_PKT_F_NO_VTAG|BCM_TX_CRC_APPEND * </td><td>68 </td><td>64  </td></tr>
<tr>
<td>BCM_TX_NO_PAD|BCM_PKT_F_NO_VTAG|BCM_TX_CRC_APPEND ** </td><td>N+8 </td><td>N+4  </td></tr>
</table>
<p>Note : * Adding extra bytes to the miminum required length to be transmitted. Packets will not be transmitted unless final packet size satisfies the minimum required length.</p>
<p>Since there are more than 32 flags defined, the flags field is continued in the flags2 field. <a class="anchor" id="pkt_flags2_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Packet flags2 Flags Descriptions</caption>
<tr>
<th>Flag </th><td>Description  </td></tr>
<tr>
<td>BCM_PKT_F2_REPLACEMENT_TYPE </td><td>This flag indicates the transmitted packet needs to be inserted with NTP or IEEE1588 timestamp or Loss Measurement counter value in SOBMH mode   </td></tr>
<tr>
<td>BCM_PKT_F2_REPLACEMENT_OFFSET </td><td>This flag indicates the transmitted packet is specififed with an offset to insert replacement value in SOBMH mode   </td></tr>
<tr>
<td>BCM_PKT_F2_LM_COUNTER_INDEX </td><td>This flag indicates the transmitted packet is specififed with Loss Measurement counter index to be inserted into packet in SOBMH mode   </td></tr>
<tr>
<td>BCM_PKT_F2_TIMESTAMP_MODE </td><td>This flag indicates the transmitted OAM packet needs to be inserted with the timestamp mode value in SOBMH mode.   </td></tr>
<tr>
<td>BCM_PKT_F2_SAMPLE_RDI </td><td>This flag indicates that transmitted OAM packet needs to sample RDI bit in SOBMH mode.   </td></tr>
<tr>
<td>BCM_PKT_F2_MA_PTR </td><td>This flag indicates that transmitted OAM packet needs to insert MA PTR value in SOBMH mode.   </td></tr>
<tr>
<td>BCM_PKT_F2_MEP_TYPE_UPMEP </td><td>This flag indicates that transmitted OAM packet needs to make use of SOBMH UPMEP TX mode. If this flag is not specified, DOWNMEP TX mode is used.   </td></tr>
<tr>
<td>BCM_PKT_F2_LM_COUNTER_INDEX_2 </td><td>This flag indicates the transmitted packet is specififed with Second Loss Measurement counter index to be inserted into packet in SOBMH mode   </td></tr>
<tr>
<td>BCM_PKT_F2_COUNTER_MODE_1 </td><td>This flag indicates the transmitted OAM packet needs to make use of the counter action specified in counter mode 1 in SOBMH mode.   </td></tr>
<tr>
<td>BCM_PKT_F2_COUNTER_MODE_2 </td><td>This flag indicates the transmitted OAM packet needs to make use of the counter action specified in counter mode 2 in SOBMH mode.   </td></tr>
<tr>
<td>BCM_PKT_F2_SNOOPED </td><td>This flag indicates the Packet was snooped.  </td></tr>
<tr>
<td>BCM_PKT_F2_UNKNOWN_DEST </td><td>packet has unknown destination.  </td></tr>
<tr>
<td>BCM_PKT_F2_VISIBILITY_PKT </td><td>This flag indicates that this is internal trace visibility packet  </td></tr>
<tr>
<td>BCM_PKT_F2_RX_PORT </td><td>This flag indicates that <a class="el" href="structbcm__pkt__s.html#a6274c9ec158e36218ca5bee80e9af35a">bcm_pkt_s.rx_port</a> is used as a source port for the masquerade/visibility packet  </td></tr>
<tr>
<td>BCM_PKT_F2_OAM_TX </td><td>This flag indicates that packet is OAM type.  </td></tr>
<tr>
<td>BCM_PKT_F2_OLP_READY </td><td>This flag indicates that OLP header is pre-built in _olp_hdr.  </td></tr>
<tr>
<td>BCM_PKT_F2_LM_REPLACEMENT_OFFSET </td><td>This flag indicates that oam_lm_replacement_offset carries LM Counters replacement offset (in bytes) and oam_replacement_offset carries timestamp replacement offset (in bytes). This flag is used when LM and DM are carried in single packet.   </td></tr>
<tr>
<td>BCM_PKT_F2_MEP_TYPE_SAT_DOWNMEP </td><td>This flag indicates that transmitted SAT packet is of type DOWNMEP and DOWNMEP TX mode is used.  </td></tr>
<tr>
<td>BCM_PKT_F2_MEP_TYPE_SAT_UPMEP </td><td>This flag indicates that transmitted SAT packet is of type UPMEP and UPMEP TX mode is used.  </td></tr>
<tr>
<td>BCM_PKT_F2_MC_QUEUE </td><td>This flag indicates that the host CPU transmit packet to mc queue.  </td></tr>
<tr>
<td>BCM_PKT_F2_CPU_TX_PROC </td><td>This flag indicates that the packet is of type CPU tx proc.  </td></tr>
<tr>
<td>BCM_PKT_F2_CONG_INT </td><td>This flag indicates that the internal congestion value is to be picked up from the packet data structure.   </td></tr>
<tr>
<td>BCM_PKT_F2_EXT_HG_HDR </td><td>This flag indicates that the extended higig header value is to be picked up from the packet data structure.   </td></tr>
<tr>
<td>BCM_PKT_F2_SPID_OVERRIDE </td><td>This flag indicates that the spid needs to be used from the packet instead of the default value.   </td></tr>
</table>
<p>The rx_path field contains the information about the path in which a packet was received. <a class="anchor" id="rx_path"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Rx Paths Descriptions</caption>
<tr>
<th>Flag </th><td>Description  </td></tr>
<tr>
<td>BCM_RX_PATH_SWITCHED </td><td>Packet was switched.  </td></tr>
<tr>
<td>BCM_RX_PATH_COPY_TO_CPU </td><td>Packet was trapped.  </td></tr>
<tr>
<td>BCM_RX_PATH_MIRRORED </td><td>Packet was mirrored.  </td></tr>
</table>
<p>The rx_untagged field contains additional information about the VLAN tag stack format in the frame. <a class="anchor" id="rx_untagged_flags"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>rx_untagged Flags Descriptions</caption>
<tr>
<th>Flag </th><td>Description  </td></tr>
<tr>
<td>BCM_PKT_INNER_UNTAGGED </td><td>Packet was received without inner VLAN tag.  </td></tr>
<tr>
<td>BCM_PKT_OUTER_UNTAGGED </td><td>Packet was received without outer VLAN tag.  </td></tr>
</table>
<p><a class="anchor" id="filter_types"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Filter Types Descriptions</caption>
<tr>
<th>Type </th><td>Description  </td></tr>
<tr>
<td>BCM_PKT_FILTER_LAG </td><td>LAG filter.  </td></tr>
<tr>
<td>BCM_PKT_FILTER_TAGGED </td><td>Tag filter.  </td></tr>
<tr>
<td>BCM_PKT_FILTER_PORT_MASK </td><td>Port mask filter.  </td></tr>
<tr>
<td>BCM_PKT_FILTER_STP </td><td>STP filter.  </td></tr>
<tr>
<td>BCM_PKT_FILTER_EAP </td><td>EAP filter.  </td></tr>
<tr>
<td>BCM_PKT_FILTER_INGRESS_VLAN </td><td>Ingress Vlan filter.  </td></tr>
<tr>
<td>BCM_PKT_FILTER_EGRESS_VLAN </td><td>Egress Vlan filter.  </td></tr>
<tr>
<td>BCM_PKT_FILTER_SA </td><td>Source address filter.  </td></tr>
</table>
<p>The packet timesync flags detail the information encoded in a 1588 timesync packet header. <a class="anchor" id="pkt_timesync_flags_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Packet Timesync Flags Descriptions</caption>
<tr>
<th>Flag </th><td>Description  </td></tr>
<tr>
<td>BCM_TX_TIMESYNC_ONE_STEP </td><td>One step timestamp  </td></tr>
<tr>
<td>BCM_TX_TIMESYNC_ONE_STEP_INGRESS_SIGN </td><td>One step Ingress timestamp sign bit  </td></tr>
<tr>
<td>BCM_TX_TIMESYNC_ONE_STEP_HDR_START_OFFSET </td><td>One step timestamp header offset  </td></tr>
<tr>
<td>BCM_TX_TIMESYNC_ONE_STEP_REGEN_UDP_CHKSUM </td><td>One step timestamp udp checksum  </td></tr>
<tr>
<td>BCM_TX_TIMESYNC_INGRESS_SIGN </td><td>Ingress timestamp sign bit  </td></tr>
<tr>
<td>BCM_TX_TIMESYNC_HDR_START_OFFSET </td><td>Offset of common message header payload of 1588 packet  </td></tr>
<tr>
<td>BCM_TX_TIMESYNC_REGEN_UDP_CHKSUM </td><td>Update udp checksum of 1588 packet  </td></tr>
</table>
<p>The packet stacking flags detail the information encoded in a HiGig2 header if the local egress port is configured for HiGig2 operation. <a class="anchor" id="pkt_stk_flags_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Packet Stacking Flags Descriptions</caption>
<tr>
<th>Flag </th><td>Description  </td></tr>
<tr>
<td>BCM_PKT_STK_F_MIRROR </td><td>For TX, set the mirror indication in the stacking HiGig2 header. For RX, the HiGig2 header reported the packet is a mirror copy.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_DO_NOT_MODIFY </td><td>For TX of HiGig2 packets, notify the egress device to leave the packet unchanged. For RX, the HiGig2 header instructs the egress device not to modify the packet.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_TRUNK_FAILOVER </td><td>For TX of HiGig2 packets, notify the egress device that this packet experienced LAG failover. For RX, the HiGig2 header reports that this packet was redirected due to LAG failover.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_SRC_PORT </td><td>For TX, src_gport specifies the virtual or physical port for use in HiGig2 packets. For RX, src_gport contains the source virtual or physical port.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_DST_PORT </td><td>For TX, dst_gport specifies the virtual or physical port for use in HiGig2 packets. For RX, dst_gport contains the destination virtual or physical port.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_DEFERRED_DROP </td><td>For TX, set the HiGig2 header to instruct the egress device to drop the packet. For RX, the HiGig2 header indicates that the packet should be dropped in the egress device.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_DEFERRED_CHANGE_PKT_PRIO </td><td>For TX of a HiGig2 packet, the stk_pkt_prio member contains the packet priority with which the egress chip should override the arriving packet priority. For RX, the HiGig2 header instructed the egress chip to replace the packet priority with the value in stk_pkt_prio.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_DEFERRED_CHANGE_DSCP </td><td>For TX of a HiGig2 packet, the stk_dscp member contains the DSCP with which the egress chip should override the arriving DSCP. For RX, the HiGig2 header instructed the egress chip to replace the DSCP with the value in stk_dscp.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_CLASSIFICATION_TAG </td><td>For TX of a HiGig2 packet, use the stk_classification_tag value. For RX, the HiGig2 header contained stk_classification_tag.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_VLAN_TRANSLATE_NONE </td><td>For HiGig2 packets, no VLAN translation was performed on this packet.  </td></tr>
<tr>
<td>BCM_PKT_STK_F_VLAN_TRANSLATE_UNCHANGED </td><td>For HiGig2 packets, VLAN translation resulted in no change to this packet.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_VLAN_TRANSLATE_CHANGED </td><td>For HiGig2 packets, VLAN translation changed the packet.  </td></tr>
<tr>
<td>BCM_PKT_STK_F_DO_NOT_LEARN </td><td>For HiGig2 packets, the egress device should not learn the packet source address.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_PRESERVE_DSCP </td><td>For HiGig2 packets, the egress device should not change DSCP  </td></tr>
<tr>
<td>BCM_PKT_STK_F_PRESERVE_PKT_PRIO </td><td>For HiGig2 packets, the egress device should not change the packet priority.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_ENCAP_ID </td><td>For TX of a HiGig2 packet, use the stk_encap_id value. For RX, the HiGig2 header contained stk_encap_id.   </td></tr>
<tr>
<td>BCM_PKT_STK_F_FAILOVER </td><td>For TX of a HiGig2 packet, indicates that the remote device should use the protection path. For RX, the HiGig2 header contained an indication that the egress device should use the protection path.   </td></tr>
</table>
<p>The packet stacking forwarding options describe the egress device operations which may be specified in a HiGig2 header. (The egress device port must be configured as a HiGig port for these options to take effect.) <a class="anchor" id="pkt_stk_forward_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Packet Stacking Forward Descriptions</caption>
<tr>
<th>Name </th><td>Description  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_CPU </td><td>Forward HiGig2 packet to the Host CPU.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_L2_UNICAST </td><td>Forward HiGig2 packet as unicast L2.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_L2_MULTICAST </td><td>Forward HiGig2 packet as multicast L2.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_L2_MULTICAST_UNKNOWN </td><td>Forward HiGig2 packet as unknown multicast L2.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_L3_MULTICAST </td><td>Forward HiGig2 packet as multicast L3.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_L3_MULTICAST_UNKNOWN </td><td>Forward HiGig2 packet as unknown multicast L3.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_L2_UNICAST_UNKNOWN </td><td>Forward HiGig2 packet as unknown unicast L2.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_BROADCAST </td><td>Forward HiGig2 packet as broadcast.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_MPLS </td><td>Stacking header packet forwarding option:MPLS.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_TRILL </td><td>Stacking header packet forwarding option:TRILL.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_FCOE </td><td>Stacking header packet forwarding option:FCoE.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_SNOOP </td><td>Stacking header packet forwarding option:SNOOP.  </td></tr>
<tr>
<td>BCM_PKT_STK_FORWARD_TRAFFIC_MANAGEMENT </td><td>Stacking header packet forwarding option:Traffic Management.  </td></tr>
</table>
<p>The packet timestamp mode options describe the timestamp modes which may be specified in SOBMH header for OAM DM TX packets. <a class="anchor" id="pkt_timestamp_mode_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>OAM Packet time stamp mode Descriptions</caption>
<tr>
<th>Name </th><td>Description  </td></tr>
<tr>
<td>BCM_PKT_TIMESTAMP_MODE_NONE </td><td>No timestamp  </td></tr>
<tr>
<td>BCM_PKT_TIMESTAMP_MODE_NTP </td><td>Timestamp mode is NTP.  </td></tr>
<tr>
<td>BCM_PKT_TIMESTAMP_MODE_PTP </td><td>Timestamp mode is PTP.  </td></tr>
</table>
<p>The packet loss measurement counter mode options describe the LM counter actions which may be specified in SOBMH header for OAM LM TX packets. <a class="anchor" id="pkt_oam_lm_counter_mode_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>OAM Packet time stamp mode Descriptions</caption>
<tr>
<th>Name </th><td>Description  </td></tr>
<tr>
<td>BCM_PKT_OAM_LM_COUNTER_MODE_NONE </td><td>No LM counter operation  </td></tr>
<tr>
<td>BCM_PKT_OAM_LM_COUNTER_MODE_INCREMENT </td><td>Increment LM counter.  </td></tr>
<tr>
<td>BCM_PKT_OAM_LM_COUNTER_MODE_SAMPLE </td><td>Sample LM counter value.  </td></tr>
</table>
<p><a class="anchor" id="pkt_rx_oam_type_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>OAM Packet type Descriptions</caption>
<tr>
<th>Name </th><td>Description  </td></tr>
<tr>
<td>bcmPktRxOamTypeNone </td><td>Not OAM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeBfdOam </td><td>BFD OAM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeEthOamCcm </td><td>Ethernet OAM Down MEP CCM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeEthOamLm </td><td>Ethernet OAM Down MEP LM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeEthOamDm </td><td>Ethernet OAM Down MEP DM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeEthOamOther </td><td>Ethernet OAM Down MEP other opcode packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeBhhOamCcm </td><td>BHH OAM CCM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeBhhOamLm </td><td>BHH OAM LM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeBhhOamDm </td><td>BHH OAM DM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeBhhOamOther </td><td>BHH OAM other opcode packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeRfc6374Dlm </td><td>MPLS LM/DM DLM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeRfc6374Dm </td><td>MPLS LM/DM DM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeRfc6374DlmPlusDm </td><td>MPLS LM/DM DLM + DM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeRfc6374Ilm </td><td>MPLS LM/DM ILM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeRfc6374IlmPlusDm </td><td>MPLS LM/DM ILM + DM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeSat </td><td>Service Activation Test packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeOtherAch </td><td>OAM packets with other ACH types.  </td></tr>
<tr>
<td>bcmPktRxOamTypeEthOamUpMepCcm </td><td>Ethernet OAM Up MEP CCM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeEthOamUpMepLm </td><td>Ethernet OAM Up MEP LM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeEthOamUpMepDm </td><td>Ethernet OAM Up MEP DM CCM packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeEthOamUpMepOther </td><td>Ethernet OAM Up MEP other opcode packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeUpSat </td><td>Up Service Activation Test packet.  </td></tr>
<tr>
<td>bcmPktRxOamTypeCount </td><td>Always last, not a usable value.  </td></tr>
</table>
<p><a class="anchor" id="pkt_oam_counter_object_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>OAM counter object ID type Description</caption>
<tr>
<th>Name </th><td>Description  </td></tr>
<tr>
<td>bcmOamCounterObjectNone </td><td>Invalid counter object.  </td></tr>
<tr>
<td>bcmOamCounterObjectEndpointId </td><td>OAM counter object id.  </td></tr>
<tr>
<td>bcmOamCounterObjectFlexStatId </td><td>OAM counter flex stats ID.  </td></tr>
</table>
<p><a class="anchor" id="bcm_pkt_oam_counter_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>OAM counter Structure Description</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>counter_object </td><td>bcm_pkt_oam_counter_object_t </td><td>OAM counter object type. Refer <a class="el" href="trtx.html#pkt_oam_counter_object_table">pkt_oam_counter_object_table</a>  </td></tr>
<tr>
<td>counter_object_id </td><td>uint32 </td><td>Counter Object Id.  </td></tr>
<tr>
<td>counter_offset </td><td>uint32 </td><td>Offset from start of counter group.  </td></tr>
<tr>
<td>counter_mode </td><td>bcm_pkt_oam_lm_counter_mode_t </td><td>Counter mode during Tx. Refer <a class="el" href="trtx.html#pkt_oam_lm_counter_mode_table">pkt_oam_lm_counter_mode_table</a> .  </td></tr>
<tr>
<td>counter_value_upper </td><td>uint32 </td><td>Upper 32 bit of OAM LM Counter in Rx Packet.  </td></tr>
<tr>
<td>counter_value_lower </td><td>uint32 </td><td>Lower 32 bit of OAM LM Counter in Rx Packet.  </td></tr>
<tr>
<td>oam_lm_byte_count_offset </td><td>uint32 </td><td>Offset to start byte counting.  </td></tr>
</table>
<p><a class="anchor" id="bcm_pkt_dnx_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>DNX packet Structure Description</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>type </td><td>bcm_pkt_dnx_type_t </td><td>DNX Header type. Refer <a class="el" href="trtx.html#bcm_pkt_dnx_type_t">bcm_pkt_dnx_type_t</a>  </td></tr>
<tr>
<td>itmh </td><td>bcm_pkt_dnx_itmh_t </td><td>ITMH Header. Refer <a class="el" href="trtx.html#bcm_pkt_dnx_itmh_t">bcm_pkt_dnx_itmh_t</a>  </td></tr>
<tr>
<td>ftmh </td><td>bcm_pkt_dnx_ftmh_t </td><td>FTMH Header. Refer <a class="el" href="trtx.html#bcm_pkt_dnx_ftmh_t">bcm_pkt_dnx_ftmh_t</a>  </td></tr>
<tr>
<td>otsh </td><td>bcm_pkt_dnx_otsh_t </td><td>OAM-TS Header (OTSH). Refer <a class="el" href="trtx.html#bcm_pkt_dnx_otsh_t">bcm_pkt_dnx_otsh_t</a>  </td></tr>
<tr>
<td>otmh </td><td>bcm_pkt_dnx_otmh_t </td><td>OTMH Header. Refer <a class="el" href="trtx.html#bcm_pkt_dnx_otmh_t">bcm_pkt_dnx_otmh_t</a>  </td></tr>
<tr>
<td>internal </td><td>bcm_pkt_dnx_internal_t </td><td>Internal Header. Refer <a class="el" href="trtx.html#bcm_pkt_dnx_internal_t">bcm_pkt_dnx_internal_t</a>  </td></tr>
</table>
<p><a class="anchor" id="bcm_pkt_dnx_type_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>DNX Packet type Descriptions</caption>
<tr>
<th>Name </th><td>Description  </td></tr>
<tr>
<td>bcmPktDnxTypeItmh </td><td>ITMH Header.  </td></tr>
<tr>
<td>bcmPktDnxTypeFtmh </td><td>FMTH Header.  </td></tr>
<tr>
<td>bcmPktDnxTypeOtsh </td><td>OAM-TS Header (OTSH).  </td></tr>
<tr>
<td>bcmPktDnxTypeOtmh </td><td>OTMH Header.  </td></tr>
<tr>
<td>bcmPktDnxTypeInternals </td><td>Internal Header.  </td></tr>
</table>
<p><a class="anchor" id="bcm_pkt_dnx_itmh_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>DNX ITMH Structure Description</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>inbound_mirror_disable </td><td>uint8 </td><td>If set, disable inbound mirroring ITMH.IN_MIRR_DISABLE)  </td></tr>
<tr>
<td>snoop_cmnd </td><td>uint32 </td><td>snoop command (ITMH.SNOOP_CMD).  </td></tr>
<tr>
<td>prio </td><td>uint32 </td><td>Traffic Class (ITMH.FWD_TRAFFIC_CLASS)  </td></tr>
<tr>
<td>color </td><td>bcm_color_t </td><td>Color (aka Drop precedence, ITMH.FWD_DP)  </td></tr>
<tr>
<td>dest </td><td>bcm_pkt_dnx_itmh_dest_t </td><td>Destination information. Refer <a class="el" href="trtx.html#bcm_pkt_dnx_itmh_dest_t">bcm_pkt_dnx_itmh_dest_t</a>  </td></tr>
</table>
<p><a class="anchor" id="bcm_pkt_dnx_itmh_dest_type_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>ITMH dest type</caption>
<tr>
<th>Name </th><td>Description  </td></tr>
<tr>
<td>bcmPktDnxItmhDestTypeMulticast </td><td>TMH destination type is multicast.  </td></tr>
<tr>
<td>bcmPktDnxItmhDestTypeFlow </td><td>ITMH destination type is flow.  </td></tr>
<tr>
<td>bcmPktDnxItmhDestTypeIngressShapingFlow </td><td>ITMH destination type is ingress shaping flow.  </td></tr>
<tr>
<td>bcmPktDnxItmhDestTypeVport </td><td>ITMH destination type is out lif.  </td></tr>
<tr>
<td>bcmPktDnxItmhDestTypeSystemPort </td><td>ITMH destination type is system port.  </td></tr>
</table>
<p><a class="anchor" id="bcm_pkt_dnx_itmh_dest_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>DNX ITMH Destination information</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>dest_type </td><td>bcm_pkt_dnx_itmh_dest_type_t </td><td>Destination type Refer <a class="el" href="trtx.html#bcm_pkt_dnx_itmh_dest_type_t">bcm_pkt_dnx_itmh_dest_type_t</a>  </td></tr>
<tr>
<td>dest_extension_type </td><td>bcm_pkt_dnx_itmh_dest_type_t </td><td>Destination Extension type. <a class="el" href="trtx.html#bcm_pkt_dnx_itmh_dest_type_t">bcm_pkt_dnx_itmh_dest_type_t</a>  </td></tr>
<tr>
<td>destination </td><td>bcm_gport_t </td><td>Destination Gport.  </td></tr>
<tr>
<td>multicast_id </td><td>bcm_multicast_t </td><td>Destination multicast.  </td></tr>
<tr>
<td>destination_ext </td><td>bcm_gport_t </td><td>Destination-Extension Gport  </td></tr>
</table>
<p><a class="anchor" id="bcm_pkt_dnx_ftmh_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>DNX FTMH Structure Description</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>packet_size </td><td>uint32 </td><td>Packet size in bytes FTMH.Packet-Size  </td></tr>
<tr>
<td>prio </td><td>uint32 </td><td>Traffic class (FTMH.Traffic-Class)  </td></tr>
<tr>
<td>src_sysport </td><td>bcm_gport_t </td><td>Source System port (FTMH.Source-System-Port-Aggr).  </td></tr>
<tr>
<td>dst_port </td><td>bcm_gport_t </td><td>Destination local port (FTMH.PP_DSP).  </td></tr>
<tr>
<td>ftmh_dp </td><td>bcm_color_t </td><td>Drop precedence (FTMH.DP)  </td></tr>
<tr>
<td>action_type </td><td>bcm_pkt_dnx_ftmh_action_type_t </td><td>Action type (FTMH.TM-Action-Type). Refer <a class="el" href="trtx.html#bcm_pkt_dnx_ftmh_action_type_t">bcm_pkt_dnx_ftmh_action_type_t</a>  </td></tr>
<tr>
<td>out_mirror_disable </td><td>uint8 </td><td>Disable Outbound mirroring (FTMH.Out-Mirror-Disable).  </td></tr>
<tr>
<td>is_mc_traffic </td><td>uint8 </td><td>Indicate if the traffic is multicast (FTMH.TM-Action-Is-Multicast)  </td></tr>
<tr>
<td>multicast_id </td><td>bcm_multicast_t </td><td>Multicast ID (FTMH.Multicast-ID). Valid only if is_mc_traffic is set.  </td></tr>
<tr>
<td>out_vport </td><td>bcm_gport_t </td><td>Virtual port (FTMH.Out-LIF). Valid only if is_mc_traffic is unset.  </td></tr>
<tr>
<td>cni </td><td>uint32 </td><td>Congestion indication (FTMH.CNI)  </td></tr>
<tr>
<td>lb_ext </td><td>bcm_pkt_dnx_ftmh_lb_extension_t lb_ext; </td><td>FTMH Load Balancing Key extension.  </td></tr>
<tr>
<td>dest_ext </td><td>bcm_pkt_dnx_ftmh_dest_extension_t </td><td>FTMH Destination System Port Extension  </td></tr>
<tr>
<td>stack_ext </td><td>bcm_pkt_dnx_ftmh_stack_extension_t </td><td>FTMH Stacking extension (Stacking-Route-History-Bitmap)  </td></tr>
<tr>
<td>ase_ext </td><td>bcm_pkt_dnx_ftmh_ase_extension_t </td><td>FTMH Application Specific Extension  </td></tr>
<tr>
<td>flow_id_ext </td><td>bcm_pkt_dnx_ftmh_flow_id_extension_t </td><td>FTMH flow_id Extension  </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/* ftmh lb extension. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__pkt__dnx__ftmh__lb__extension__s.html">bcm_pkt_dnx_ftmh_lb_extension_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__pkt__dnx__ftmh__lb__extension__s.html#afc5dbcc47c15402566b656dca804146f">valid</a>;    <span class="comment">/* Set if the extension is present */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__pkt__dnx__ftmh__lb__extension__s.html#af3f8d6e202a9e227bbeaf3d2b9acca51">lb_key</a>;  <span class="comment">/* Load Balancing Key (FTMH.LB-Key) */</span></div><div class="line">} <a class="code" href="pkt_8h.html#a94ca002477351be30e70f536d0c4b674">bcm_pkt_dnx_ftmh_lb_extension_t</a>;</div><div class="line"></div><div class="line"><span class="comment">/* ftmh dest extension. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__pkt__dnx__ftmh__dest__extension__s.html">bcm_pkt_dnx_ftmh_dest_extension_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__pkt__dnx__ftmh__dest__extension__s.html#afc5dbcc47c15402566b656dca804146f">valid</a>;                <span class="comment">/* Set if the extension is present */</span></div><div class="line">    <a class="code" href="group__types.html#gac5f933aaac05c65b2a78ad8a04316994">bcm_gport_t</a> <a class="code" href="structbcm__pkt__dnx__ftmh__dest__extension__s.html#aa06479fd79604d19a9de2f47bf05819a">dst_sysport</a>;    <span class="comment">/* Destination System Port</span></div><div class="line"><span class="comment">                                   (FTMH.Destination-Sys-Port)) */</span></div><div class="line">} <a class="code" href="pkt_8h.html#a3ff8ad8c5d67dc3980dcb0f06c779dd1">bcm_pkt_dnx_ftmh_dest_extension_t</a>;</div><div class="line"></div><div class="line"><span class="comment">/* ftmh stack extension. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__pkt__dnx__ftmh__stack__extension__s.html">bcm_pkt_dnx_ftmh_stack_extension_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__pkt__dnx__ftmh__stack__extension__s.html#afc5dbcc47c15402566b656dca804146f">valid</a>;                    <span class="comment">/* Set if the extension is present */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__pkt__dnx__ftmh__stack__extension__s.html#a83b2015fc163fa5d62b7c8c8a614dc51">stack_route_history_bmp</a>; <span class="comment">/* Route bitmap to prevent loops in stacking</span></div><div class="line"><span class="comment">                                       system</span></div><div class="line"><span class="comment">                                       (FTMH.Stacking-Route-History-Bitmap) */</span></div><div class="line">} <a class="code" href="pkt_8h.html#a46207b5183a7ae662033b7508372be50">bcm_pkt_dnx_ftmh_stack_extension_t</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="pkt_8h.html#acb145efd438a811e629fa15de86be2cb">bcm_pkt_dnx_ase_type_e</a> {</div><div class="line">    <a class="code" href="pkt_8h.html#acb145efd438a811e629fa15de86be2cba4c3de394d0efdccd403379074131a616">bcmPktDnxAseTypeNone</a> = 0,           <span class="comment">/* Ase type is None */</span></div><div class="line">    <a class="code" href="pkt_8h.html#acb145efd438a811e629fa15de86be2cbaaf4838e9c32f3fa12491db36ce959f6a">bcmPktDnxAseTypeTrajectoryTrace</a> = 1, <span class="comment">/* Ase type is Trajectory trace */</span></div><div class="line">    <a class="code" href="pkt_8h.html#acb145efd438a811e629fa15de86be2cbabe3f1dac2f02685d34d86717212485c1">bcmPktDnxAseTypeErspan</a> = 2,         <span class="comment">/* Ase type is ERSPAN */</span></div><div class="line">    <a class="code" href="pkt_8h.html#acb145efd438a811e629fa15de86be2cba34385e5af8e0b2cbfcd6b0e98da44e47">bcmPktDnxAseTypeSFlow</a> = 3           <span class="comment">/* Ase type is sFlow */</span></div><div class="line">} <a class="code" href="pkt_8h.html#aca0b2ffb8c82fbad2d934ecb62d9c2ec">bcm_pkt_dnx_ase_type_t</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Ase information */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__pkt__dnx__ase__info__s.html">bcm_pkt_dnx_ase_info_s</a> {</div><div class="line">  <a class="code" href="structbcm__pkt__dnx__erspan__info__s.html">bcm_pkt_dnx_erspan_info_t</a> <a class="code" href="structbcm__pkt__dnx__ase__info__s.html#aba54c52243aeaf90223282a0a54044e2">erspan_info</a>; <span class="comment">/* ERSPAN header information */</span></div><div class="line">} <a class="code" href="pkt_8h.html#acec40477a5bfe0af9828787270f5fe99">bcm_pkt_dnx_ase_info_t</a>;</div><div class="line"></div><div class="line"><span class="comment">/* ftmh application specific extension. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__pkt__dnx__ftmh__ase__extension__s.html">bcm_pkt_dnx_ftmh_ase_extension_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__pkt__dnx__ftmh__ase__extension__s.html#afc5dbcc47c15402566b656dca804146f">valid</a>;                        <span class="comment">/* Set if the extension is present */</span></div><div class="line">    <a class="code" href="pkt_8h.html#aca0b2ffb8c82fbad2d934ecb62d9c2ec">bcm_pkt_dnx_ase_type_t</a> <a class="code" href="structbcm__pkt__dnx__ftmh__ase__extension__s.html#aecd8da85bdcb28a858f305b9a7d20c65">ase_type</a>;    <span class="comment">/* Application Specific Extension type */</span></div><div class="line">    <a class="code" href="structbcm__pkt__dnx__ase__info__s.html">bcm_pkt_dnx_ase_info_t</a> <a class="code" href="structbcm__pkt__dnx__ftmh__ase__extension__s.html#ad02b8a3c06459fc36358d9ec8b4b335c">ase_info</a>;    <span class="comment">/* Application Specific Extension</span></div><div class="line"><span class="comment">                                           information */</span></div><div class="line">} <a class="code" href="pkt_8h.html#a247bb573a4494646f45179eb4d4711a1">bcm_pkt_dnx_ftmh_ase_extension_t</a>;</div><div class="line"></div><div class="line"><span class="comment">/* ftmh flow_id extension. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__pkt__dnx__ftmh__flow__id__extension__s.html">bcm_pkt_dnx_ftmh_flow_id_extension_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__pkt__dnx__ftmh__flow__id__extension__s.html#afc5dbcc47c15402566b656dca804146f">valid</a>;        <span class="comment">/* Set if the extension is present */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__pkt__dnx__ftmh__flow__id__extension__s.html#a9f88d9912cc4da6af27cfd640853f16b">flow_id</a>;     <span class="comment">/* Flow-ID */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__pkt__dnx__ftmh__flow__id__extension__s.html#a08437ae5fa9b3014e005d49b7cce4827">flow_profile</a>; <span class="comment">/* Flow-Profile */</span></div><div class="line">} <a class="code" href="pkt_8h.html#a87ccaf1371c6e6282a1d3f4fd4953f8f">bcm_pkt_dnx_ftmh_flow_id_extension_t</a>;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* TSH header */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__pkt__dnx__tsh__s.html">bcm_pkt_dnx_tsh_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__pkt__dnx__tsh__s.html#afc5dbcc47c15402566b656dca804146f">valid</a>;    <span class="comment">/* Set if TSH is present */</span></div><div class="line">} <a class="code" href="pkt_8h.html#aab4aefa039542130144caec64e4ed441">bcm_pkt_dnx_tsh_t</a>;</div></div><!-- fragment --><p> <a class="anchor" id="bcm_pkt_dnx_otsh_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>DNX OTSH Structure Description</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>otsh_type </td><td>bcm_pkt_dnx_otsh_type_t </td><td>OAM-TS(Type)  </td></tr>
<tr>
<td>oam_sub_type </td><td>bcm_pkt_dnx_otsh_oam_subtype_t </td><td>OAM-TS(OAM-Sub-Type). Applies only when otsh_type is oam.  </td></tr>
<tr>
<td>oam_up_mep </td><td>uint32 </td><td>OAM-TS(MEP-Type). Applies only when otsh_type is oam.  </td></tr>
<tr>
<td>tp_cmd </td><td>uint32 </td><td>OAM-TS(TP-Cmd). Applies only when otsh_type is 1588.  </td></tr>
<tr>
<td>ts_encap </td><td>uint8 </td><td>OAM-TS(TS-Encaps). Applies only when otsh_type is 1588.  </td></tr>
<tr>
<td>oam_ts_data </td><td>uint64 </td><td>OAM-TS(OAM-TS-Data)  </td></tr>
<tr>
<td>latency_flow_ID </td><td>uint32 </td><td>Latency flow ID generated by the PMF.  </td></tr>
<tr>
<td>offset </td><td>uint32 </td><td>OAM-TS(offset). Applies only when otsh_type is oam.  </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/* otsh type */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="pkt_8h.html#a516716c79006e85bdf0c177bd5dcbacd">bcm_pkt_dnx_otsh_type_e</a> {</div><div class="line">    <a class="code" href="pkt_8h.html#a516716c79006e85bdf0c177bd5dcbacda8a5f8726fcc84374fcf473e424bf8978">bcmPktDnxOtshTypeOam</a> = 0,       <span class="comment">/* OAM-TS type is OAM */</span></div><div class="line">    bcmPktDnxOtshTypeL588v2 = 1,    <span class="comment">/* OAM-TS type is 1588v2 */</span></div><div class="line">    <a class="code" href="pkt_8h.html#a516716c79006e85bdf0c177bd5dcbacda26d11f8c64047ea9bc65c6d90f62dddd">bcmPktDnxOtshTypeLatency</a> = 2    <span class="comment">/* OAM-TS type is packet latency */</span></div><div class="line">} <a class="code" href="pkt_8h.html#ac4cfbcf351fa224f7de90ec97f5f5962">bcm_pkt_dnx_otsh_type_t</a>;</div><div class="line"></div><div class="line"><span class="comment">/* otsh oam sutype */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="pkt_8h.html#a1a1f8e8b72c464bb0ffb642fed0fc654">bcm_pkt_dnx_otsh_oam_subtype_e</a> {</div><div class="line">    <a class="code" href="pkt_8h.html#a1a1f8e8b72c464bb0ffb642fed0fc654aac6483597f31f376486ac46dc98c7206">bcmPktDnxOtshOamSubtypeNone</a> = 0,    <span class="comment">/* None */</span></div><div class="line">    <a class="code" href="pkt_8h.html#a1a1f8e8b72c464bb0ffb642fed0fc654ab3d26bf932292c9df76b226ddc78bfc1">bcmPktDnxOtshOamSubtypeLm</a> = 1,      <span class="comment">/* Loss Measurement (LM) */</span></div><div class="line">    <a class="code" href="pkt_8h.html#a1a1f8e8b72c464bb0ffb642fed0fc654a190d1ccf2816015fda8e1e0c70dd3329">bcmPktDnxOtshOamSubtypeDm1588</a> = 2,  <span class="comment">/* Delay Measurement (DM) - 1588 ToD */</span></div><div class="line">    <a class="code" href="pkt_8h.html#a1a1f8e8b72c464bb0ffb642fed0fc654a40cd6e60230909afe5b60476bbc47c6c">bcmPktDnxOtshOamSubtypeDmNtp</a> = 3,   <span class="comment">/* Delay Measurement (DM) - NTP ToD */</span></div><div class="line">    <a class="code" href="pkt_8h.html#a1a1f8e8b72c464bb0ffb642fed0fc654a4941fc098ff31a88dce9e98d745e2cb2">bcmPktDnxOtshOamSubtypeOamDefault</a> = 4, <span class="comment">/* Default OAM type */</span></div><div class="line">    <a class="code" href="pkt_8h.html#a1a1f8e8b72c464bb0ffb642fed0fc654a3ca5bc339f199477a0e093893737c31a">bcmPktDnxOtshOamSubtypeLoopback</a> = 5, <span class="comment">/* Loopback */</span></div><div class="line">    <a class="code" href="pkt_8h.html#a1a1f8e8b72c464bb0ffb642fed0fc654ac7e1fe23b9a09efda60cd2f676b19f40">bcmPktDnxOtshOamSubtypeEcn</a> = 7      <span class="comment">/* ECN */</span></div><div class="line">} <a class="code" href="pkt_8h.html#ac50d773bd5c01a432114c6cd80636102">bcm_pkt_dnx_otsh_oam_subtype_t</a>;</div></div><!-- fragment --><p> <a class="anchor" id="bcm_pkt_dnx_ftmh_action_type_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>FTMH action type</caption>
<tr>
<th>Name </th><td>Description  </td></tr>
<tr>
<td>bcmPktDnxFtmhActionTypeForward </td><td>TM action is forward.  </td></tr>
<tr>
<td>bcmPktDnxFtmhActionTypeSnoop </td><td>TM action is snoop  </td></tr>
<tr>
<td>bcmPktDnxFtmhActionTypeInboundMirror </td><td>TM action is inbound mirror.  </td></tr>
<tr>
<td>bcmPktDnxFtmhActionTypeOutboundMirror </td><td>TM action is outbound mirror.  </td></tr>
</table>
<p><a class="anchor" id="bcm_pkt_dnx_otmh_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>DNX OTMH Structure Description</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>action_type </td><td>bcm_pkt_dnx_ftmh_action_type_t </td><td>Action type (OTMH.TM-Action-Type)  </td></tr>
<tr>
<td>ftmh_dp </td><td>bcm_color_t </td><td>Drop precedence (OTMH.DP)  </td></tr>
<tr>
<td>is_mc_traffic </td><td>uint8 </td><td>AIndicate if the traffic is multicast (OTMH.System-Multicast)  </td></tr>
<tr>
<td>prio </td><td>uint32 </td><td>Traffic class (OTMH.Traffic-Class)  </td></tr>
<tr>
<td>dst_port </td><td>bcm_gport_t </td><td>Destination local port (OTMH.Destination-Port)  </td></tr>
<tr>
<td>src_sysport_ext </td><td>bcm_pkt_dnx_otmh_src_sysport_extension_t </td><td>OTMH Source System Port Extension  </td></tr>
<tr>
<td>out_vport_ext </td><td>bcm_pkt_dnx_otmh_vport_extension_t </td><td>OTMH Source System Port Extension  </td></tr>
</table>
<p><a class="anchor" id="bcm_pkt_dnx_internal_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>DNX Internal Structure Description</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>trap_qualifier </td><td>uint32 </td><td>Trap Qualifier  </td></tr>
<tr>
<td>trap_id </td><td>uint32 </td><td>Trap Id  </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/* otmh src sysport extension */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__pkt__dnx__otmh__src__sysport__extension__s.html">bcm_pkt_dnx_otmh_src_sysport_extension_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__pkt__dnx__otmh__src__sysport__extension__s.html#afc5dbcc47c15402566b656dca804146f">valid</a>;                <span class="comment">/* Set if the extension is present */</span></div><div class="line">    <a class="code" href="group__types.html#gac5f933aaac05c65b2a78ad8a04316994">bcm_gport_t</a> <a class="code" href="structbcm__pkt__dnx__otmh__src__sysport__extension__s.html#a4f30fb6c901f52b90f5dfe5f8fd44368">src_sysport</a>;    <span class="comment">/* Source System Port (OTMH.Source-System-Port) */</span></div><div class="line">} <a class="code" href="pkt_8h.html#adb944320e4ddd914e1444e89622cb7b4">bcm_pkt_dnx_otmh_src_sysport_extension_t</a>;</div><div class="line"></div><div class="line"><span class="comment">/* otmh vport extension */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__pkt__dnx__otmh__vport__extension__s.html">bcm_pkt_dnx_otmh_vport_extension_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__pkt__dnx__otmh__vport__extension__s.html#afc5dbcc47c15402566b656dca804146f">valid</a>;            <span class="comment">/* Set if the extension is present */</span></div><div class="line">    <a class="code" href="group__types.html#gac5f933aaac05c65b2a78ad8a04316994">bcm_gport_t</a> <a class="code" href="structbcm__pkt__dnx__otmh__vport__extension__s.html#a2ed45dc2573bee86f08615e287796a67">out_vport</a>;  <span class="comment">/* Virtual port (OTMH.Out-LIF/CUD) */</span></div><div class="line">} <a class="code" href="pkt_8h.html#a469221bbce2af9b408b09496ae783646">bcm_pkt_dnx_otmh_vport_extension_t</a>;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* UDH header */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__pkt__dnx__udh__s.html">bcm_pkt_dnx_udh_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__pkt__dnx__udh__s.html#abf7f47b9039221e81ecb5eac8f3b090d">size</a>;     <span class="comment">/* UDH size: 0/1/2/4 */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__pkt__dnx__udh__s.html#a0be738b5bfc7096ec6dba081a978b471">data</a>;    <span class="comment">/* UDH data */</span></div><div class="line">} <a class="code" href="pkt_8h.html#a70b1fad6196f68121b027207bbf100e8">bcm_pkt_dnx_udh_t</a>;</div></div><!-- fragment --> <h2><a class="anchor" id="txrx_dev_specific"></a>
Device-Specific Variations</h2>
<h2>Pre-StrataXGS III Devices</h2>
<p>On StrataXGS, StrataXGS I, and StrataXGS II switch devices, all packets internally carry a VLAN tag, whether the actual frame is tagged or not. On these devices, VLAN tags are added to untagged packets on ingress and removed on egress (when the egress port is marked untagged for the packet's VLAN).</p>
<p>Similarly, all packets injected by the CPU port on these devices must have a VLAN tag in the packet data. The BCM_PKT_F_NO_VTAG is a signal to the transmit driver that a tag must be added to the packet payload. If this flag is not set, the driver assumes that the VLAN tag already exists in the packet payload as supplied by the application, and will not add the required VLAN tag.</p>
<p>For StrataXGS I and StrataXGS II fabric devices, the VLAN information is stored in the HiGig header and is not transmitted in the packet data. For packets transmitted through BCM TX on these devices, the VLAN tag is removed from the packet data and the VLAN ID copied to the HiGig header. If the BCM_PKT_F_NO_VTAG is set, then the packet payload is not changed and the VLAN ID in the HiGig header is derived from another source (such as the default setting for the CPU port).</p>
<p><a class="anchor" id="XGS2_vlan_tagging"></a> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Pre-StrataXGS III VLAN Action</caption>
<tr>
<th>Pre-StrataXGS III Switch Device </th><th>Pre-StrataXGS III Fabric Device  </th></tr>
<tr>
<th>BCM_PKT_F_NO_VTAG set </th><td>Add VLAN tag to payload </td><td>No action  </td></tr>
<tr>
<th>BCM_PKT_F_NO_VTAG clear </th><td>No action </td><td>Strip VLAN tag from payload and move data to HiGig header  </td></tr>
</table>
<h2>StrataXGS III Devices</h2>
<p>StrataXGS III switch devices treat the CPU port like any other port on the device. The CPU port may appear as either an Ethernet port or as a HiGig port.</p>
<p>Behavior is controlled by the BCM_TX_ETHER flag. If this flag is set, (and no module property flags are set &ndash; see below), packets transmitted by the Host CPU will be processed by the device's ingress pipeline as though the packet were received from a front panel Ethernet port. The packet's transmit and L3 bitmaps are ignored in this case. If the BCM_TX_ETHER flag is not set, the forwarding decisions made by the ingress pipeline are bypassed, and the transmit and L3 bitmaps supplied in the bcm_pkt_t structure determine the egress port of the packet.</p>
<p>The "untagged" bitmap controls whether or not the packet has a VLAN tag when entering the switch. See table <a class="el" href="trtx.html#XGS3_vlan_tagging">XGS3_vlan_tagging</a> .</p>
<p>If any bit in this bitmap is set, then the packet will be sent to the ingress logic without a VLAN tag. In this case, the BCM_PKT_F_NO_VTAG flag determines whether the actual payload is modified (to remove any existing VLAN tag). If BCM_PKT_F_NO_VTAG is set, the packet will not be modified. If it is not set, the VLAN tag will be stripped from the packet data.</p>
<p>If the untagged bitmap is has no bits set, the packet will be sent with a VLAN tag. In this case, the BCM_PKT_F_NO_VTAG flag indicates that a VLAN tag should be inserted in the packet payload, using the bcm_pkt_t metadata. If BCM_PKT_F_NO_VTAG is not set, the SDK assumes that the tag is present in the packet data supplied by the application.</p>
<p><a class="anchor" id="XGS3_vlan_tagging"></a> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>StrataXGS III VLAN Action When BCM_TX_ETHER is Set</caption>
<tr>
<th>Untagged Bitmap Empty </th><th>Untagged Bitmap Non-Empty  </th></tr>
<tr>
<th>BCM_PKT_F_NO_VTAG set </th><td>Add VLAN tag to payload </td><td>No action  </td></tr>
<tr>
<th>BCM_PKT_F_NO_VTAG clear </th><td>No action </td><td>Strip VLAN tag from payload  </td></tr>
</table>
<p>The BCM_TX_ETHER flag is not supported on pre-StrataXGS III devices. Calls to the BCM TX API with this flag set will return BCM_E_UNAVAIL.</p>
<p>As previously mentioned, the CPU may send packets to be processed by an StrataXGS III device as though the CPU were connected to a HiGig port. To select this behavior, the BCM_TX_ETHER flag must be set and one of the following header property flags must be set: BCM_TX_HG_READY, BCM_TX_SRC_MOD, BCM_TX_SRC_PORT, BCM_TX_PRIO_INT or BCM_TX_PFM: That is, if the packet's flags AND'd with \sc (BCM_TX_HG_READY + BCM_TX_PKT_PROP_ANY) \ec is non-zero, and the BCM_TX_ETHER flag is set, then the packet will be sent through the device as a HiGig packet. <a class="anchor" id="XGS3_HG_Ether_transmit"></a> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>StrataXGS III HiGig versus Ethernet Transmit</caption>
<tr>
<th>BCM_TX_ETHER set </th><th>BCM_TX_ETHER clear  </th></tr>
<tr>
<th>BCM_TX_HG_READY or BCM_TX_PKT_PROP_ANY flags non-zero </th><td>Send through HiGig ingress </td><td>Send in legacy (bypass) mode  </td></tr>
<tr>
<th>BCM_TX_HG_READY and BCM_TX_PKT_PROP_ANY flags zero </th><td>Send through Ethernet ingress </td><td>Send in legacy (bypass) mode  </td></tr>
</table>
<p>Macros to access fields in the bcm_pkt_t structure are described in <a class="el" href="trtx.html#txrx_pkt_macro_table">txrx_pkt_macro_table</a> .</p>
<p><a class="anchor" id="txrx_pkt_macro_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Packet Macros</caption>
<tr>
<th>Macro </th><td>Description  </td></tr>
<tr>
<td>BCM_PKT_PORT_SET(pkt, port, untagged, l3) </td><td>Set single transmit port for a packet. The port argument must be a valid port number for the transmit device. The untagged argument is a Boolean that determines if the transmitted frame should include a VLAN tag. The l3 argument is a Boolean that controls the L3 processing indicator in HiGig packets (set to zero if unused).   </td></tr>
<tr>
<td>BCM_PKT_ONE_BUF_SETUP\sc(pkt, buf, len)\ec </td><td>Set up a packet for use with a single buffer. No packet block allocation is required if this is done. The only restriction is that only a single data buffer may be associated with the packet. buf is a pointer to the data buffer. len is the length of that data in bytes.   </td></tr>
<tr>
<td>BCM_PKT_HDR_DMAC_SET(pkt, mac) </td><td>Set destination MAC address for a single-buffer packet. The MAC argument must be a pointer to a 6-byte MAC address.   </td></tr>
<tr>
<td>BCM_PKT_HDR_SMAC_SET(pkt, mac) </td><td>Set source MAC address for a single-buffer packet. The MAC argument must be a pointer to a 6-byte MAC address.   </td></tr>
<tr>
<td>BCM_PKT_HDR_TPID_SET(pkt, tpid) </td><td>Set tag protocol for a single-buffer packet. The tpid argument should be in host-endian order.   </td></tr>
<tr>
<td>BCM_PKT_HDR_VTAG_CONTROL_SET(pkt, vtag) </td><td>Set VLAN control for a single-buffer packet. The vtag argument should be in host-endian order.   </td></tr>
<tr>
<td>BCM_PKT_HDR_UNTAGGED_LEN_SET(pkt, len) </td><td>Set length field (EtherType) for an untagged single-buffer packet. The len argument should be in host-endian order.   </td></tr>
<tr>
<td>BCM_PKT_HDR_TAGGED_LEN_SET(pkt, len) </td><td>Set length field (EtherType) for a VLAN-tagged single-buffer packet. The len argument should be in host-endian order.   </td></tr>
<tr>
<td>BCM_PKT_HDR_SNAP_DSAP_SET(pkt, dsap) </td><td>Set LLC/SNAP DSAP field for a single-buffer packet.  </td></tr>
<tr>
<td>BCM_PKT_HDR_SNAP_SSAP_SET(pkt, ssap) </td><td>Set LLC/SNAP SSAP field for a single-buffer packet.  </td></tr>
<tr>
<td>BCM_PKT_HDR_SNAP_CONTROL_SET(pkt, ctl) </td><td>Set LLC/SNAP Control field for a single-buffer packet.  </td></tr>
<tr>
<td>BCM_PKT_HDR_SNAP_ORG_SET(pkt, b1, b2, b3) </td><td>Set LLC/SNAP Organizational Code field (3 bytes) for a single-buffer packet.   </td></tr>
<tr>
<td>BCM_PKT_HDR_SNAP_ETYPE_SET(pkt, etype) </td><td>Set LLC/SNAP Ethernet Type field for a single-buffer packet. The etype argument should be in host-endian order.   </td></tr>
<tr>
<td>BCM_PKT_TAG_PROTOCOL(pkt) </td><td>Returns the uint16 tag protocol associated with the packet in host endian order.   </td></tr>
<tr>
<td>BCM_PKT_VLAN_CONTROL(pkt) </td><td>Returns the uint16 VLAN control tag associated with the packet in host endian order.   </td></tr>
<tr>
<td>BCM_PKT_HG_HDR(pkt) </td><td>Returns a \sc uint8 * \ec pointer to a buffer holding the HiGig header associated with the packet. On receive, the HiGig header is normally moved from the packet to the buffer returned by this macro.   </td></tr>
<tr>
<td>BCM_PKT_SL_TAG(pkt) </td><td>Returns a \sc uint8 * \ec pointer to a buffer holding the SL tag associated with the packet. On receive, the SL tag is normally moved from the packet to the buffer returned by this macro.   </td></tr>
<tr>
<td>BCM_PKT_VLAN_ID(pkt) </td><td>Returns the VLAN ID associated with the packet as an integer in host endian order.   </td></tr>
<tr>
<td>BCM_PKT_VLAN_PRI(pkt) </td><td>Returns the priority from the VLAN tag associated with the packet as an integer in host endian order.   </td></tr>
<tr>
<td>BCM_PKT_VLAN_CFI(pkt) </td><td>Returns the CFI bit from the VLAN tag associated with the packet as an integer in host endian order.   </td></tr>
</table>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="pkt_8h.html#aedb97b6763b0f60fa69049a698cce5f5" title="Initialize a BCM packet structure.">bcm_pkt_t_init(bcm_pkt_t* pkt)</a>  </td><td>Initialize a BCM packet structure.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a377a208b999601d0ddfd8e7e1748d9fa" title="Allocate a packet structure and packet data.">bcm_pkt_alloc(int unit, int size, uint32 flags, bcm_pkt_t** pkt_buf)</a>  </td><td>Allocate or deallocate a packet structure and packet data.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#aea7321aac41a4f5feef489a7dbb0c5e1" title="Deallocate a packet structure and packet data.">bcm_pkt_free(int unit, bcm_pkt_t* pkt)</a>  </td><td>Allocate or deallocate a packet structure and packet data.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a2c0b7ba88bb74c26200785842918b16d" title="Initialize a BCM packet block structure.">bcm_pkt_blk_t_init(bcm_pkt_blk_t* pkt_blk)</a>  </td><td>Initialize a BCM packet block structure.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#ab9c6094a966015e585599e69680493df" title="Allocate or deallocate an array of packets.">bcm_pkt_blk_alloc(int unit, int count, int size, uint32 flags, bcm_pkt_t*** packet_array)</a>  </td><td>Allocate or deallocate an array of packets   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a2c9c97d2161ad4dfd89c53f638ff1a43" title="Allocate or deallocate an array of packets.">bcm_pkt_blk_free(int unit, bcm_pkt_t** pkt, int count)</a>  </td><td>Allocate or deallocate an array of packets   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a1f162e2cf292ffce6b945e2254dcd957" title="Allocate or deallocate a packet structure using =bcm_rx_alloc.">bcm_pkt_rx_alloc(int unit, int len, bcm_pkt_t** pkt_buf)</a>  </td><td>Allocate or deallocate a packet structure using <a class="el" href="rx_8h.html#bcm_rx_alloc">bcm_rx_alloc</a> .   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a8653e908292c55df24bab12f0ad14915" title="Allocate or deallocate a packet structure using =bcm_rx_alloc.">bcm_pkt_rx_free(int unit, bcm_pkt_t* pkt)</a>  </td><td>Allocate or deallocate a packet structure using <a class="el" href="rx_8h.html#bcm_rx_alloc">bcm_rx_alloc</a> .   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a5130dd08c5a952144efe1eac083172e7" title="Initialize and set up a bcm_pkt_t structure.">bcm_pkt_clear(int unit, bcm_pkt_t* pkt, bcm_pkt_blk_t* blks, int blk_count, uint32 flags, bcm_pkt_t** pkt_buf)</a>  </td><td>Initialize and set up a bcm_pkt_t structure.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a023191728f8fb179d37fdb794459f782" title="Initialize packet flags based on the type of device.">bcm_pkt_flags_init(int unit, bcm_pkt_t* pkt, uint32 init_flags)</a>  </td><td>Initialize packet flags based on the type of device.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a9d5ad1b325208a8bc7d60e8f973a5d5b" title="Set up the length and flags for a bcm_pkt_t structure.">bcm_pkt_flags_len_setup(int unit, bcm_pkt_t* pkt, int alloc_bytes, int payload_len, uint32 flags)</a>  </td><td>Set up the length and flags for a bcm_pkt_t structure.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a073c535aa96278cd2b2760fa4334a54a" title="Copy data into the data blocks of a packet structure.">bcm_pkt_memcpy(bcm_pkt_t* pkt, int dest_byte, uint8* src, int len)</a>  </td><td>Copy data into the data blocks of a packet structure.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#ac475cc72b778cc31e074b0ed14574377" title="Calculate a byte offset in the data buffer for a packet.">bcm_pkt_byte_index(bcm_pkt_t* pkt, int n, int* len, int* blk_idx, uint8** location)</a>  </td><td>Calculate a byte offset in the data buffer for a packet.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a6da3008f6c4a7631be1ec19dfdb6d8ee" title="Set ECMP group field in the pkt structure.">bcm_pkt_ecmp_grp_set(int unit, bcm_pkt_t* pkt, bcm_if_t ecmp_group_id)</a>  </td><td>Set ECMP group in a bcm_pkt_t structure.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a7733c9caf5c04685a8dc93fa9c42b385" title="Set ECMP member field in the pkt structure.">bcm_pkt_ecmp_member_set(int unit, bcm_pkt_t* pkt, bcm_if_t ecmp_group_id, bcm_if_t ecmp_member_id)</a>  </td><td>Set ECMP group in a bcm_pkt_t structure.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a7f87e043145e5e6cab8520da3c562fc7" title="Set nexthop field in the pkt structure.">bcm_pkt_nexthop_set(int unit, bcm_pkt_t* pkt, bcm_if_t nexthop_id)</a>  </td><td>Set next hop in a bcm_pkt_t structure.   </td></tr>
</table>
<h1><a class="anchor" id="bcm_tx_api"></a>
BCM TX API</h1>
<p>The BCM TX API supports injecting single, lists, and arrays of packets into the data plane of the switch device so that the packets egress other switch ports.</p>
<p>The BCM transmit software module runs a single thread for all devices managed by this SDK instance which provides a context for asynchronous transmit callbacks. This thread is started by a call to <a class="el" href="tx_8h.html#bcm_tx_init">bcm_tx_init</a> and will run forever. Applications that do not use asynchronous transmit callbacks need not start this thread.</p>
<p>The bcm_pkt_t structure supplied to bcm_tx routines becomes owned by the BCM TX API when the call is made. The application must not modify or deallocate the structure while the SDK owns it. Once the API returns or the callback is executed, the application resumes ownership of the bcm_pkt_t structure, and may modify or deallocate it.</p>
<p>See <a class="el" href="trtx.html#pkt_flags_table">pkt_flags_table</a> for transmit specific flag definitions in <a class="el" href="trtx.html#bcm_pkt_t">bcm_pkt_t</a> structure.</p>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="tx_8h.html#a4e748c9dab062624d96db6285541d906" title="Initialize the BCM TX software module.">bcm_tx_init(int unit)</a>  </td><td>Initialize the BCM TX software module.   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#acb8095f684616768fd83f3c791868fc2" title="Transmit one or more packets.">bcm_tx(int unit, bcm_pkt_t* tx_pkt, void* cookie)</a>  </td><td>Transmit one or more packets.   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#a2e54d93098d67fbb5b91d104490e583c" title="Transmit one or more packets.">bcm_tx_list(int unit, bcm_pkt_t* pkt, bcm_pkt_cb_f all_done_cb, void* cookie)</a>  </td><td>Transmit one or more packets.   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#a45b38d1c71cd4ca7c192d451ce68f4c8" title="Transmit one or more packets.">bcm_tx_array(int unit, bcm_pkt_t** pkt, int count, bcm_pkt_cb_f all_done_cb, void* cookie)</a>  </td><td>Transmit one or more packets.   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#a276e8446f1a9d7869c25da6a19ac19ed" title="Set up a packet for transmit.">bcm_tx_pkt_setup(int unit, bcm_pkt_t* tx_pkt)</a>  </td><td>Set up a packet for transmit   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#a96cca5d3fa003de0f4bf1a531a8af2f1" title="bcm_tx_dv_dump">bcm_tx_dv_dump(int unit, void* dv_p)</a>  </td><td>Display information about a DMA vector that is setup for transmit.   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#a75186965f3a0a8621be16f2a0f318a3a" title="bcm_tx_show">bcm_tx_show(int unit)</a>  </td><td>Display information about software state of transmitter.   </td></tr>
</table>
<p>ignoreblock</p>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="tx_8h.html#a8f3c4d491f5a8050dd4820d5368687c2" title="Update a packet based on a look up of the Layer 2 Forwarding Database (deprecated,...">bcm_tx_pkt_l2_map(int unit, bcm_pkt_t* pkt, bcm_mac_t dest_mac, int vid)</a>  </td><td>Update a packet based on a look up of the Layer 2 Forwarding Database (deprecated, unimplemented).   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#acb59919d61e537cf2a0de4dab73ac1ac" title="Initialize the rx_trap_config_t structure.">bcm_rx_trap_config_t_init(bcm_rx_trap_config_t* trap_config)</a>  </td><td>Initialize the rx_trap_config_t structure.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#aafb6122656593bad5d73a72883b7957d" title="rx_trap_type_create.">bcm_rx_trap_type_create(int unit, int flags, bcm_rx_trap_t type, int* trap_id)</a>  </td><td>Create trap handle for a given type.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#ae5b8fa6365542cb7a809a00f7c2cd957" title="rx_trap_type_destroy.">bcm_rx_trap_type_destroy(int unit, int trap_id)</a>  </td><td>Destroy trap handle for a given trap id.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a0893e362473841ba6d66f9139beb664e" title="rx_trap_set.">bcm_rx_trap_set(int unit, int trap_id, bcm_rx_trap_config_t* config)</a>  </td><td>Set how to handle packet according to trap type.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a33b8c28f524b23e3845dcaf67b6a23b9" title="rx_trap_type_get.">bcm_rx_trap_type_get(int unit, int flags, bcm_rx_trap_t type, int* trap_id)</a>  </td><td>Get trap id according to type.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#adc70f2743e13db4d568900d41cad7473" title="Get RX trap type from trap ID.">bcm_rx_trap_type_from_id_get(int unit, int flags, int trap_id, bcm_rx_trap_t* trap_type)</a>  </td><td>Get trap type according to trap id.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#ace75a491d8f16316f70e636c9bfcaac1" title="rx_trap_get.">bcm_rx_trap_get(int unit, int trap_id, bcm_rx_trap_config_t* config)</a>  </td><td>Get trap configuration according to trap id.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a80c17899f723531b171b83f444ca5ce8" title="Initialize the rx_snoop_config_t structure.">bcm_rx_snoop_config_t_init(bcm_rx_snoop_config_t* snoop_config)</a>  </td><td>Initialize the rx_snoop_config_t structure.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#aee1edb2d8d6d8d322537eae2c9d80d42" title="rx_snoop_create.">bcm_rx_snoop_create(int unit, int flags, int* snoop_cmnd)</a>  </td><td>Create snoop command.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a80020c1ef97fbe3f3322381b8180b1ba" title="rx_trap_type_destroy.">bcm_rx_snoop_destroy(int unit, int flags, int snoop_cmnd)</a>  </td><td>Destroy create snoop command.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a729f211b063e2694e2f199dde9d7cb02" title="rx_snoop_set.">bcm_rx_snoop_set(int unit, int snoop_cmnd, bcm_rx_snoop_config_t* config)</a>  </td><td>The snoop can be set for given trap-code (e.g. IGMP), or by other action, like FP, or forwarding lookup.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a4475052fd5d629d16c475e6b217331b1" title="rx_snoop_get.">bcm_rx_snoop_get(int unit, int snoop_cmnd, bcm_rx_snoop_config_t* config)</a>  </td><td>Set snoop configuration of the snoop command   </td></tr>
</table>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="rx_8h.html#ac3bcb0b807a0a26513ed7797499bc4fb" title="Initialize the RX software module for the given device.">bcm_rx_init(int unit)</a>  </td><td>Initialize the RX software module for the given device   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a673594ec72f870c3967650c41a72973f" title="Re-initialize the user level configuration for the RX module.">bcm_rx_cfg_init(int unit)</a>  </td><td>Re-initialize the user level configuration for the RX module   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#ac8b013ce3435005fddf690fe9a5635c2" title="Initialize a BCM RX reasons structure.">bcm_rx_reasons_t_init(bcm_rx_reasons_t* reasons)</a>  </td><td>Initialize a BCM RX reasons structure.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a67e177c544c609da41559b1dfd8cfcc3" title="Initialize a BCM RX configuration structure.">bcm_rx_cfg_t_init(bcm_rx_cfg_t* rx_cfg)</a>  </td><td>Initialize a BCM RX configuration structure.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#acb98f5ef14c5d882e4c9efd57d42ca07" title="Get the current configuration for the given device.">bcm_rx_cfg_get(int unit, bcm_rx_cfg_t* cfg)</a>  </td><td>Get the current configuration for the given device   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a71e687188a7d4729a49faf9104e191cc" title="Register CPU bound packets scheduler.">bcm_rx_sched_register(int unit, bcm_rx_sched_cb sched_cb)</a>  </td><td>Register custom CPU packet RX scheduler.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a4f458aba26410267515768dc64e2a7af" title="Unregister CPU bound packets scheduler.">bcm_rx_sched_unregister(int unit)</a>  </td><td>Unregister custom CPU packet RX scheduler.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a14b21bf4e4dc94e5b0cb25fcdd0f4af4" title="Get next unit with CPU rx enabled.">bcm_rx_unit_next_get(int unit, int* next_unit)</a>  </td><td>Get next device with RX enabled.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a544401a56ae03a9e44df9a8e0189b27a" title="Get maximum cos queue number for the device.">bcm_rx_queue_max_get(int unit, bcm_cos_queue_t* cosq)</a>  </td><td>Get highest priority queue number supported by device.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#aba54c6c012b93cf5e424074e9b250cc9" title="Get number of packets awaiting processing in the specific device, queue.">bcm_rx_queue_packet_count_get(int unit, bcm_cos_queue_t cosq, int* packet_count)</a>  </td><td>Get number of packets awaiting processing in RX queue.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a14892e332e34a5fa0796bfd2204506a0" title="Get number of packet takens available for the specific device/queue BCM_RX_SCHED_ALL_PACKETS - queue ...">bcm_rx_queue_rate_limit_status_get(int unit, bcm_cos_queue_t cosq, int* packet_tokens)</a>  </td><td>Get RX queue congestion status.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a931bb1568ff62db30131b654dc67aa4c" title="Start packet reception for the given device.">bcm_rx_start(int unit, bcm_rx_cfg_t* cfg)</a>  </td><td>Start packet reception for the given device.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a2145c1f50f4fb56dc3c5c3a639a564cb" title="Stop the RX software module.">bcm_rx_stop(int unit, bcm_rx_cfg_t* cfg)</a>  </td><td>Stop the RX software module   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a0426751385b1a1d34113b25b80cfab95" title="Boolean indication of whether RX is running on this device.">bcm_rx_active(int unit)</a>  </td><td>Boolean indication of whether RX is running on this device   </td></tr>
<tr>
<td>bcm_rx_register(int unit, constchar* name, bcm_rx_cb_f callback, uint8 priority, void* cookie, uint32 flags)  </td><td>Register or unregister to receive callbacks for received packets   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a0c870fd2df17aa2fca70f586d9a4f33d" title="Register or unregister to receive callbacks for received packets.">bcm_rx_unregister(int unit, bcm_rx_cb_f callback, uint8 priority)</a>  </td><td>Register or unregister to receive callbacks for received packets   </td></tr>
<tr>
<td>bcm_rx_queue_register(int unit, constchar* name, bcm_cos_queue_t cosq, bcm_rx_cb_f callback, uint8 priority, void* cookie, uint32 flags)  </td><td>Register/Unregister a callback function to be called when a packet is received on the specified CPU CoS queue   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#afb7bcacff0ba81836282213256002358" title="Unregister CPU COS callback function.">bcm_rx_queue_unregister(int unit, bcm_cos_queue_t cosq, bcm_rx_cb_f callback, uint8 priority)</a>  </td><td>Register/Unregister a callback function to be called when a packet is received on the specified CPU CoS queue   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#aef1633af5447913104870e62e1e311c2" title="Assign a RX channel to a cosq.">bcm_rx_queue_channel_set(int unit, bcm_cos_queue_t queue_id, bcm_rx_chan_t chan_id)</a>  </td><td>Set/get the RX channel for a given CPU CoS queue.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a343ab09b32dcab47cb738906e9207341" title="Get the RX channel assigned to the given cosq.">bcm_rx_queue_channel_get(int unit, bcm_cos_queue_t queue_id, bcm_rx_chan_t* chan_id)</a>  </td><td>Set/get the RX channel for a given CPU CoS queue.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a30104c3b18b2b12b63bc00c20f016bf1" title="Map packets to a CPU COS queue.">bcm_rx_cosq_mapping_set(int unit, int index, bcm_rx_reasons_t reasons, bcm_rx_reasons_t reasons_mask, uint8 int_prio, uint8 int_prio_mask, uint32 packet_type, uint32 packet_type_mask, bcm_cos_queue_t cosq)</a>  </td><td>Map/Un-map packets to a CPU CoS queue.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#ab8a27f750f80b4d865f9996b2461872f" title="Get packets to CPU COS queue mappings.">bcm_rx_cosq_mapping_get(int unit, int index, bcm_rx_reasons_t* reasons, bcm_rx_reasons_t* reasons_mask, uint8* int_prio, uint8* int_prio_mask, uint32* packet_type, uint32* packet_type_mask, bcm_cos_queue_t* cosq)</a>  </td><td>Map/Un-map packets to a CPU CoS queue.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a9924acdb8e13995d9b887b9b2ef817e2" title="Unmap packets to a CPU COS queue.">bcm_rx_cosq_mapping_delete(int unit, int index)</a>  </td><td>Map/Un-map packets to a CPU CoS queue.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#abd49d86072f1d23ff8c310fe35c3f6a7" title="Get number of packet to CPU COS queue mappings.">bcm_rx_cosq_mapping_size_get(int unit, int* size)</a>  </td><td>Map/Un-map packets to a CPU CoS queue.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a3bf19a227e02cc9eec9b2d9bd95cb35c" title="Initialize a BCM RX cosq mapping structure.">bcm_rx_cosq_mapping_t_init(bcm_rx_cosq_mapping_t* rx_cosq_mapping)</a>  </td><td>Initialize a rx cosq mapping structure.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a16e80e7288c2f96532e622cfb0e8cfdf" title="Map packets to a CPU COS queue.">bcm_rx_cosq_mapping_extended_set(int unit, uint32 options, bcm_rx_cosq_mapping_t* rx_cosq_mapping)</a>  </td><td>Map packets to a CPU CoS queue with truncated packets or not.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#abbaafbddabb40bb2dde57c478d9fc88a" title="Get packets to CPU COS queue mappings.">bcm_rx_cosq_mapping_extended_get(int unit, bcm_rx_cosq_mapping_t* rx_cosq_mapping)</a>  </td><td>Get copy to Rx cosq mapping entry data.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a2b1a843fca0197b216e1559eb98751c5" title="Add a CPU COS map.">bcm_rx_cosq_mapping_extended_add(int unit, uint32 options, bcm_rx_cosq_mapping_t* rx_cosq_mapping)</a>  </td><td>Add a CPU COS map.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#ae5fd13d22412fcff44ff53aa9fe32db3" title="Delete a CPU COS map.">bcm_rx_cosq_mapping_extended_delete(int unit, bcm_rx_cosq_mapping_t* rx_cosq_mapping)</a>  </td><td>Delete a CPU COS map.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#af07a30eb019f6ec73b4cf291cd85e8d5" title="Delete all CPU COS maps.">bcm_rx_cosq_mapping_extended_delete_all(int unit)</a>  </td><td>Delete all CPU COS maps.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a5703b51aa1d770f62b9893da08638547" title="Get all supported reasons for CPU COS queue mapping.">bcm_rx_cosq_mapping_reasons_get(int unit, bcm_rx_reasons_t* reasons)</a>  </td><td>Get all the CPU CoS queue mapping reasons supported on the specified device.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a11e2067931720ecae1812fe942c87b9d" title="Get all supported reasons for rx packets.">bcm_rx_reasons_get(int unit, bcm_rx_reasons_t* reasons)</a>  </td><td>Get all the CPU RX reasons supported on the specified device.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#af881da91362f8ecb849174339966d062" title="Get mode specific configured redirection reasons for rx packets.">bcm_rx_redirect_reasons_get(int unit, bcm_rx_redirect_t mode, bcm_rx_reasons_t* reasons)</a>  </td><td>Set/get all RX reasons for the specified mode that are configured on the specified device.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a775184f55efc40b55b6859783d2321a1" title="Set mode specific redirection reasons for rx packets.">bcm_rx_redirect_reasons_set(int unit, bcm_rx_redirect_t mode, bcm_rx_reasons_t reasons)</a>  </td><td>Set/get all RX reasons for the specified mode that are configured on the specified device.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a44a7313b6363e6dc6f3e9bd4dc7f41c0" title="Allocate or deallocate a packet buffer as configured.">bcm_rx_alloc(int unit, int pkt_size, uint32 flags, void** buf)</a>  </td><td>Allocate or deallocate a packet buffer as configured   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a17698adb9ce1c1ae7daf3ab97cc8c1b7" title="Allocate or deallocate a packet buffer as configured.">bcm_rx_free(int unit, void* pkt_data)</a>  </td><td>Allocate or deallocate a packet buffer as configured   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#af8e177d68479f3fd4d19756d1bafc15e" title="Enqueue a data buffer to be freed later.">bcm_rx_free_enqueue(int unit, void* pkt_data)</a>  </td><td>Enqueue a data buffer to be freed later   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a5b01f8b178a708cb01166abe1342c7c4" title="Set/get the overall packet rate for the given device.">bcm_rx_rate_set(int unit, int pps)</a>  </td><td>Set/get the overall packet rate for the given device   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#afa05a91280334cd2cc3ef5134398e4a7" title="Set/get the overall packet rate for the given device.">bcm_rx_rate_get(int unit, int* pps)</a>  </td><td>Set/get the overall packet rate for the given device   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a05433684d3b2513b6af5c3aad271171f" title="Set/get the overall packet rate for the CPU that given device is attached to.">bcm_rx_cpu_rate_set(int unit, int pps)</a>  </td><td>Set/get the overall packet rate for the CPU that given device is attached to   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#aa5ef29b1b2843f3954c685ec38a4fe59" title="Set/get the overall packet rate for the CPU that given device is attached to.">bcm_rx_cpu_rate_get(int unit, int* pps)</a>  </td><td>Set/get the overall packet rate for the CPU that given device is attached to   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#acaf5e9866423a4df34d21f18c3bfb989" title="Set/get the burst size for the given device.">bcm_rx_burst_set(int unit, int burst)</a>  </td><td>Set/get the burst size for the given device   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a050aeb553411cd5f5938aeefba6446c0" title="Set/get the burst size for the given device.">bcm_rx_burst_get(int unit, int* burst)</a>  </td><td>Set/get the burst size for the given device   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a838c73c3686ef7601afa9e762dda09bc" title="Set/get the RX per-COS rate limiting value.">bcm_rx_cos_rate_set(int unit, int cos, int pps)</a>  </td><td>Set/get the RX per-Cos rate limiting value   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a27c218fe40dea96460f69ac4184874a8" title="Set/get the RX per-COS rate limiting value.">bcm_rx_cos_rate_get(int unit, int cos, int* pps)</a>  </td><td>Set/get the RX per-Cos rate limiting value   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a21759905751150d42535d2f9b7b1c11a" title="Set/get the per-COS burst setting.">bcm_rx_cos_burst_set(int unit, int cos, int burst)</a>  </td><td>Set/get the per-Cos burst setting   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#ade61a551266b98736a5f946a6d15558c" title="Set/get the per-COS burst setting.">bcm_rx_cos_burst_get(int unit, int cos, int* burst)</a>  </td><td>Set/get the per-Cos burst setting   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#aebd455cffd449a4d70bcd7893a2fdc65" title="Set/get the per-COS max queue length.">bcm_rx_cos_max_len_set(int unit, int cos, int max_q_len)</a>  </td><td>Set/get the per-Cos max queue length   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a328b355e4b8de1d02107020a2aff335a" title="Set/get the per-COS max queue length.">bcm_rx_cos_max_len_get(int unit, int cos, int* max_q_len)</a>  </td><td>Set/get the per-Cos max queue length   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#af03512869558b6c022234fb00eaf578b" title="Configure RX operating modes.">bcm_rx_control_set(int unit, bcm_rx_control_t type, int arg)</a>  </td><td>Set/get RX operating modes   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a090fb8d02d6aee37ad102c5b4778f5d8" title="Get RX operating modes.">bcm_rx_control_get(int unit, bcm_rx_control_t type, int* arg)</a>  </td><td>Set/get RX operating modes   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#aa88172e35f853c2c50fa80f0188f1bea" title="Clear all the RX configuration.">bcm_rx_clear(int unit)</a>  </td><td>Clear all the RX configuration   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a46e13421b53fddaf11d1889bd1dc5f1a" title="Associate a policer to the specified set of reason codes.">bcm_rx_reasons_policer_set(int unit, bcm_rx_reasons_t rx_reasons, bcm_policer_t polid)</a>  </td><td>Associate a policer to the specified set of reason codes.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#ad98bbea3c8026a924f1bea0b79c5d6af" title="bcm_rx_channels_running">bcm_rx_channels_running(int unit, uint32* channels)</a>  </td><td>Get bitmap of active receive channels.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a423ebb9e2de21615604fd4beea9692f1" title="bcm_rx_remote_pkt_alloc">bcm_rx_remote_pkt_alloc(int len, bcm_pkt_t** pkt)</a>  </td><td>Allocate packet for local processing of RPC data.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#ad524a273e08e97a7e6de4fb37a15cccf" title="bcm_rx_remote_pkt_free">bcm_rx_remote_pkt_free(bcm_pkt_t* pkt)</a>  </td><td>Free packet allocated with bcm_rx_remote_pkt_alloc.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a97b555fdec44bc0c5dd3f8cc2e1c0d55" title="bcm_rx_remote_pkt_enqueue">bcm_rx_remote_pkt_enqueue(int unit, bcm_pkt_t* pkt)</a>  </td><td>Enqueue a remote packet for normal receive processing.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#af5d8f915575299163659236e18cbc9c7" title="bcm_rx_show">bcm_rx_show(int unit)</a>  </td><td>Display information about software state of receiver.   </td></tr>
</table>
<h1><a class="anchor" id="Copy_to_CPU_Configuration"></a>
Copy to CPU Configuration</h1>
<p>The section describes Copy to CPU configuration. Based on a drop reason in the pipeline, the user has an option to copy such dropped packets to the CPU, this is done by redirecting such packets to the CPU. In addition the user has various options that he can set for such packets, like the cos queue to use, the priority for these redirected packets and such, these are described in detail in the subsequent sections. This feature is supported on BCM5656x and BCM5676x devices.</p>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="rx_8h.html#a483c6a57802669d5ef2732972bed393b" title="Initialize a copy to CPU config structure.">bcm_rx_CopyToCpu_config_t_init(bcm_rx_CopyToCpu_config_t* copyToCpu_config)</a>  </td><td>Initialize a copy to CPU structure.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a00233de8ee2bcfcc551596f7036f923c" title="Add a copy to CPU entry criteria.">bcm_rx_CopyToCpu_config_add(int unit, uint32 options, bcm_rx_CopyToCpu_config_t* copyToCpu_config)</a>  </td><td>Add copy to CPU configuration data.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a66f2f93b0ed46c8eaf8161bcac47b0dd" title="Get a copy to CPU entry.">bcm_rx_CopyToCpu_config_get(int unit, int index, bcm_rx_CopyToCpu_config_t* copyToCpu_config)</a>  </td><td>Get copy to CPU configuration data.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a204c2033c5ad5925348b482ccd859fff" title="Delete a copy to CPU entry.">bcm_rx_CopyToCpu_config_delete(int unit, int index)</a>  </td><td>Delete Copy to CPU configuration data.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#ade41efeb7e5f24401f7f93aac99ece95" title="Get all copy to CPU entries.">bcm_rx_CopyToCpu_config_get_all(int unit, int entries_max, bcm_rx_CopyToCpu_config_t* copyToCpu_config, int* entries_count)</a>  </td><td>Get all Copy to CPU configuration data.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a7a36cbdf26d7c465d27a2dc8716636ca" title="Delete all copy to CPU entries.">bcm_rx_CopyToCpu_config_delete_all(int unit)</a>  </td><td>Delete all Copy to CPU configuration data.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a038337fd67ce65620440369a30ea1eca" title="maps the MTU value from input to LIF/RIF value from input">bcm_rx_mtu_set(int unit, bcm_rx_mtu_config_t* config)</a>  </td><td>Map LIF/RIF to to MTU value for MTU filtering   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a9652343953852f6a5a41e5994515b183" title="return MTU value that was set for LIF/RIF">bcm_rx_mtu_get(int unit, bcm_rx_mtu_config_t* config)</a>  </td><td>Get the MTU value that was mapped to LIF for MTU filtering   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__rx__mtu__config__s.html">bcm_rx_mtu_config_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__rx__mtu__config__s.html#a81a27ce50e78368b0d0de1e8767fd32d">flags</a>;       <span class="comment">/* BCM_RX_MTU_FLAG_XXX */</span></div><div class="line">    <a class="code" href="group__types.html#ga30e6e81bfad0b18e55d3a1c8148fd75d">bcm_if_t</a> <a class="code" href="structbcm__rx__mtu__config__s.html#a56ead26537d07bc392e17b49dcdb686e">intf</a>;      <span class="comment">/* Interface  RIF */</span></div><div class="line">    <a class="code" href="group__types.html#gac5f933aaac05c65b2a78ad8a04316994">bcm_gport_t</a> <a class="code" href="structbcm__rx__mtu__config__s.html#a5bbb92b9248c9ea595e205dd48adefd8">gport</a>;  <span class="comment">/* GPORT LIF */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__rx__mtu__config__s.html#a1423636647f6d9e4fc05b23d819102dd">mtu</a>;         <span class="comment">/* MTU value to set for LIF/RIF */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> compressed_fwd_layer_type;    <span class="comment">/* Compressed forward layer type - Only</span></div><div class="line"><span class="comment">                                           relevant for LIF/RIF */</span></div><div class="line">    <a class="code" href="group__types.html#gac5f933aaac05c65b2a78ad8a04316994">bcm_gport_t</a> trap_gport;             <span class="comment">/* Trap GPORT (Action Profile, FWD and</span></div><div class="line"><span class="comment">                                           SNP Strength */</span></div><div class="line">} <a class="code" href="rx_8h.html#a1c249b46a4e9dcdacec7aff30e756cf5">bcm_rx_mtu_config_t</a>;</div></div><!-- fragment --><a class="anchor" id=""></a>
<table class="doxtable">
<caption>MTU set configuration structure</caption>
<tr>
<td>flags </td><td>int </td><td>Flags for which input is configure LIR or RIF <a class="el" href="trtx.html#BCM_RX_Mtu_falgs_table">BCM_RX_Mtu_falgs_table</a>  </td></tr>
<tr>
<td>intf </td><td>bcm_if_t </td><td>In case RIF is being configured will hold RIF encoded as Interface  </td></tr>
<tr>
<td>gport </td><td>bcm_gport_t </td><td>In case LIF is being configured will hold LIF encoded as GPORT  </td></tr>
<tr>
<td>mtu </td><td>int </td><td>MTU value to set for LIF/RIF  </td></tr>
</table>
<p><a class="anchor" id="BCM_RX_Mtu_falgs_table"></a> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>MTU set flags</caption>
<tr>
<th>Mode </th><th>Meaning  </th></tr>
<tr>
<td>BCM_RX_MTU_LIF </td><td>The input configuration is for LIF  </td></tr>
<tr>
<td>BCM_RX_MTU_RIF </td><td>The input configuration is for RIF  </td></tr>
<tr>
<td>BCM_RX_MTU_PORT </td><td>Set MTU filter for PORT, input is port  </td></tr>
</table>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="rx_8h.html#a07649de6748285e04b15150ceb744f36" title="Maps between SW trap id to HW trap id.">bcm_rx_trap_sw_to_hw_id_map_get(int unit, uint32 flags, int sw_trap_id, int* hw_trap_id)</a>  </td><td>Maps between SW trap id to HW trap id   </td></tr>
</table>
<p><a class="anchor" id="BCM_COPY_TO_CPU_CONFIG_T"></a> </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__rx___copy_to_cpu__config__s.html">bcm_rx_CopyToCpu_config_s</a> {</div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__rx___copy_to_cpu__config__s.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>;                          <span class="comment">/* Flags to pass with configuration data */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__rx___copy_to_cpu__config__s.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>;                          <span class="comment">/* Index of the entry */</span></div><div class="line">    <a class="code" href="structbcm__pkt__drop__reasons__s.html">bcm_pkt_drop_reasons_t</a> <a class="code" href="structbcm__rx___copy_to_cpu__config__s.html#a56e7c8fc286da9fd236d68dff4095189">drop_reason_vector</a>; <span class="comment">/* Array of drop reasons */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__rx___copy_to_cpu__config__s.html#af0114dc9171a9bdc183e54e510bd861d">strength</a>;                       <span class="comment">/* Strength of the entry */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__rx___copy_to_cpu__config__s.html#a4babb092c88218e3c6be18d3b8d75671">buffer_priority</a>;                <span class="comment">/* Buffering priority of the redirected</span></div><div class="line"><span class="comment">                                           packet */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__rx___copy_to_cpu__config__s.html#a77f3051899da1a4f6783aad9b28b576e">cpu_cosq</a>;                       <span class="comment">/* CPU CoS queue to use */</span></div><div class="line">} <a class="code" href="rx_8h.html#a0f4e2a5510572053d2906c4b90eaccda">bcm_rx_CopyToCpu_config_t</a>;</div></div><!-- fragment --><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Copy to CPU configuration structure</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>flags </td><td>int </td><td>Flags for port redirection configuration, defined in <a class="el" href="trtx.html#BCM_RX_Copy_to_Cpu_flags_table">BCM_RX_Copy_to_Cpu_flags_table</a>  </td></tr>
<tr>
<td>index </td><td>int </td><td>Index of the Copy to CPU entry, this value can be passed in by user or allocated automatically.  </td></tr>
<tr>
<td>drop_reason_vector </td><td>int </td><td>Array of drop reasons, which are matched to copy packets to CPU, this is defined here <a class="el" href="trtx.html#BCM_PKT_DROP_REASON_T">BCM_PKT_DROP_REASON_T</a>  </td></tr>
<tr>
<td>strength </td><td>int </td><td>Relative strength of this trigger with respect to other triggers (via field-processor) that could cause a redirection, the higher strength trigger will be selected and the redirection data will be chosen from that entry   </td></tr>
<tr>
<td>buffer_priority </td><td>int </td><td>On packets that are redirected due to this trigger, this value determies the priority to use, defined in <a class="el" href="trtx.html#BCM_RX_Copy_to_Cpu_Buffer_Priority_table">BCM_RX_Copy_to_Cpu_Buffer_Priority_table</a> These flags determine the redirection priority to be assigned to the copy-to-CPU packets, this has significance when there are multiple triggers resulting in packets filling up the redirection buffer. The user can choose to assign different priorities mentioned below and if the thresholds for each of these are exceeeded in the redirection bufferm these packets will be dropped. The setting of the thresholds is done using the bcmSwitchRedirectBufferThresholdPriorityLow/Medium/High switch controls.   </td></tr>
<tr>
<td>cpu_cosq </td><td>bcm_cos_queue_t </td><td>CPU Cos Queue value to send packets to  </td></tr>
</table>
<p><a class="anchor" id="BCM_RX_Copy_to_Cpu_flags_table"></a> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Copy to Cpu flags</caption>
<tr>
<th>Mode </th><th>Meaning  </th></tr>
<tr>
<td>BCM_RX_COPYTOCPU_TRUNCATE </td><td>Packets being copied to CPU are truncated  </td></tr>
</table>
<p><a class="anchor" id="BCM_RX_Cop_to_Cpu_options_table"></a> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Copy to CPU configuration options</caption>
<tr>
<th>Mode </th><th>Meaning  </th></tr>
<tr>
<td>BCM_RX_COPYTOCPU_WITH_ID </td><td>When used, the user specified index is used to create the copy to CPU entry  </td></tr>
<tr>
<td>BCM_RX_COPYTOCPU_REPLACE </td><td>When used, an existing copy to CPU entry is updated, a index value already configured needs to be passed  </td></tr>
</table>
<p><a class="anchor" id="BCM_RX_Copy_to_Cpu_Buffer_Priority_table"></a> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Copy to CPU Buffer Priority table</caption>
<tr>
<th>Mode </th><th>Meaning  </th></tr>
<tr>
<td>BCM_RX_COPYTOCPU_BUFFER_PRIORITY_LOW </td><td>Packets being copied to CPU will be handled with low priority  </td></tr>
<tr>
<td>BCM_RX_COPYTOCPU_BUFFER_PRIORITY_MEDIUM </td><td>Packets being copied to CPU will be handled with medium priority  </td></tr>
<tr>
<td>BCM_RX_COPYTOCPU_ BUFFER_PRIORITY_HIGH </td><td>Packets being copied to CPU will be handled with high priority  </td></tr>
</table>
<p><a class="anchor" id="BCM_PKT_DROP_REASON_Table"></a><a class="anchor" id="bcm_pkt_drop_reason_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Drop Reasons</caption>
<tr>
<th>Field </th><th>Description  </th></tr>
<tr>
<td>bcmPktDropReasonEgressVlanTranslateMiss </td><td>Packet marked for drop due to egress vlan translate miss  </td></tr>
<tr>
<td>bcmPktDropReasonEgressTunnelSnap </td><td>SNAP packet dropped becasuse it is being tunneled  </td></tr>
<tr>
<td>bcmPktDropReasonEgressColorSelect </td><td>If control bcmSwitchColorSelect is not set to BCM_COLOR_OUTER_CFI and the CFI of the packet is derived as 1, then packet is dropped.   </td></tr>
<tr>
<td>bcmPktDropReasonEgressTtlError </td><td>Packet marked for drop due to TTL error  </td></tr>
<tr>
<td>bcmPktDropReasonEgressVlanFilter </td><td>Packet marked for drop due to port not being a member of VLAN. This happens when VLAN filtering is enabled by passing BCM_PORT_VLAN_MEMBER_EGRESS flags to bcm_port_vlan_member_set API   </td></tr>
<tr>
<td>bcmPktDropReasonEgressStgBlock </td><td>Packet marked for drop due to Spanning tree in blocking state  </td></tr>
<tr>
<td>bcmPktDropReasonEgressIPMCSameVlanPrune </td><td>IPMC packet marked for drop due to bcmSwitchDropReasonIpmcSameVlanPruning setting.   </td></tr>
<tr>
<td>bcmPktDropReasonEgressMmuPurge </td><td>Packet marked for drop due to MMU purge  </td></tr>
<tr>
<td>bcmPktDropReasonEgressMmuAge </td><td>Packet marked for drop due to MMU age  </td></tr>
<tr>
<td>bcmPktDropReasonEgressBadTdipDrop </td><td>Packet marked for drop due to bad tunnel destination IP\ incase of 6to4 tunnels and ISATAP tunnels - possible reasons are incorrect prefix for IPv6 DIP, IPv4 DIP/SIP is BC/Zero/loopback/Class-D , IPv4 SIP = DIP   </td></tr>
<tr>
<td>bcmPktDropReasonEgressProtection </td><td>Packets dropped because of protection drop control   </td></tr>
<tr>
<td>bcmPktDropReasonEgressUnknownVlan </td><td>Packet marked for drop due to unknown VLAN. This happens when bcmVlanDropUnknown vlan control is used to set dropping of unknown VLAN packets   </td></tr>
<tr>
<td>bcmPktDropReasonEgressStgDisable </td><td>Packet marked for drop due to Spanning tree in disable state  </td></tr>
<tr>
<td>bcmPktDropReasonEgressHiGig2ReservedPPD </td><td>Packets dropped because of HiGig2 header with reserved ppd going out on non-hg2 ports  </td></tr>
<tr>
<td>bcmPktDropReasonEgressHigigPlusUnknown </td><td>Unknown HiGigPlus packet incoming from hg+ source and dest is non-hg+  </td></tr>
<tr>
<td>bcmPktDropReasonEgressL2MtuExceeded </td><td>Packet dropped because of L2 MTU checks configured on the port (physical/virtual)  </td></tr>
<tr>
<td>bcmPktDropReasonEgressCompositeError </td><td>Packet marked for drop due to parity error from memories or ISM lookup fail  </td></tr>
<tr>
<td>bcmPktDropReasonEgressMulticastPruned </td><td>L3 Multicast packets marked for drop due to BCM_L3_MULTICAST_L3_DROP or BCM_L3_MULTICAST_L2_DROP setting in the multicast APIs   </td></tr>
<tr>
<td>bcmPktDropReasonEgressHigigPlusInvalidModuleId </td><td>Unknown HiGigPlus packet incoming from non-hg+ source and dest is hg+ and the modid is greater than 31   </td></tr>
<tr>
<td>bcmPktDropReasonEgressFieldAction </td><td>Packet dropped due to a egress field action  </td></tr>
<tr>
<td>bcmPktDropReasonEgressSplitHorizon </td><td>Packet marked for drop due to split horizon check. This is done by enabling pruning for DVP network group via bcm_switch_network_group_config_set with BCM_SWITCH_NETWORK_GROUP_EGRESS_PRUNE_ENABLE   </td></tr>
<tr>
<td>bcmPktDropReasonEgressSVPRemoval </td><td>Packet marked for drop due to virtual port pruning - SVP = DVP and VP based pruning is enabled (DISABLE_VP_PRUNING is set to 0 in Source VP table)   </td></tr>
<tr>
<td>bcmPktDropReasonEgressNivSrcKnockout </td><td>Outgoing packet dropped due to NIV pruning check  </td></tr>
<tr>
<td>bcmPktDropReasonEgressNonUCPrune </td><td>Non-unicast packet marked for drop due to drop condition set in egress next hop via bcm_mpls/l2gre/vxlan_port_add API with BCM_MPLS/L2GRE/VXLAN_PORT_DROP flag   </td></tr>
<tr>
<td>bcmPktDropReasonEgressTrillPacket </td><td>Trill packets being sent on non-trill ports  </td></tr>
<tr>
<td>bcmPktDropReasonEgressPacketTooSmall </td><td>Packet dropped since it it too small  </td></tr>
<tr>
<td>bcmPktDropReasonEgressNonTrillPacket </td><td>Non-Trill packets being sent on trill ports  </td></tr>
<tr>
<td>bcmPktDropReasonEgressVpLagPruned </td><td>Packet dropped because of VP lag pruning checks in the egress  </td></tr>
<tr>
<td>bcmPktDropReasonEgressInvalid1588Packet </td><td>Packet dropped since it is a invalid 1588 packet  </td></tr>
<tr>
<td>bcmPktDropReasonEgressInvalidFcoePacket </td><td>Packet dropped since it is a invalid FCOE packet  </td></tr>
<tr>
<td>bcmPktDropReasonEgressInvalidCnmPacket </td><td>Packet dropped since it is a invalid CNM packet  </td></tr>
<tr>
<td>bcmPktDropReasonEgressOriginalPacket </td><td>Packet dropped in egress due to user configuration  </td></tr>
<tr>
<td>bcmPktDropReasonCount </td><td>Last. Not a usable value  </td></tr>
</table>
<p><a class="anchor" id="BCM_PKT_DROP_REASON_T"></a>BCM_PKT_DROP_REASON_Table </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Bitmap of Drop Reasons</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>rbits </td><td>_SHR_BITDCLSIZE(bcmPktDropReasonCount) </td><td>Bitmap of drop reasons, values define in xref=  </td></tr>
</table>
<p><a class="anchor" id="BCM_PKT_DROP_REASON_MACROS"></a><a class="anchor" id="bcm_pkt_drop_reasons_macros"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Macros for Analyzing/Constructing Drop Reasons</caption>
<tr>
<th>Macro </th><th>Macro Description  </th></tr>
<tr>
<td>BCM_PKT_DROP_REASON_GET(_reasons, _reason) </td><td>Macro to check if a reason (bcmPktDropReason*) is included in a set of reasons (bcm_pkt_drop_reason_t)   </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_SET(_reasons, _reason) </td><td>Macro to add a reason (bcmPktDropReason*) to a set of reasons (bcm_pkt_drop_reason_t)   </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_SET_ALL(_reasons) </td><td>Macro to add all drop reasons (bcmPktDropReason*) to a set of reasons (bcm_pkt_drop_reason_t)   </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_CLEAR(_reasons, _reason) </td><td>Macro to clear a reason (bcmPktDropReason*) from a set of reasons (bcm_pkt_drop_reason_t)   </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_CLEAR_ALL(_reasons) </td><td>Macro to clear all reason (bcmPktDropReason*) from a set of reasons (bcm_pkt_drop_reason_t)   </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_IS_NULL(_reasons) </td><td>Macro to check if set of reasons (bcm_pkt_drop_reason_t) is NULL  </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_ITER(_reasons, _reason) </td><td>Macro to iterate over all reasons (bcmPktDropReason*) in a set of reasons (bcm_pkt_drop_reason_t) is NULL   </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_COUNT(_reasons, count) </td><td>Macro to count number of active reasons in a set of reasons (bcm_pkt_drop_reason_t)   </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_EQ(_reasons1, _reasons2) </td><td>Macro to compare two sets of reasons (bcm_pkt_drop_reason_t)  </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_NEQ(_reasons1, _reasons2) </td><td>Macro to negative compare two sets of reasons (bcm_pkt_drop_reason_t)  </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_AND(_reasons1, _reasons2) </td><td>Macro to perform logical AND operation on two sets of reasons (bcm_pkt_drop_reason_t)   </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_OR(_reasons1, _reasons2) </td><td>Macro to perform logical OR operation on two sets of reasons (bcm_pkt_drop_reason_t)   </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_REMOVE(_reasons1, _reasons2) </td><td>Macro to remove set of reasons2 (bcm_pkt_drop_reason_t) from set of reasons1 (bcm_pkt_drop_reason_t)   </td></tr>
<tr>
<td>BCM_PKT_DROP_REASON_NEGATE(_reasons1, _reasons2) </td><td>Macro to negate two sets of reasons (bcm_pkt_drop_reason_t)  </td></tr>
</table>
<p><a class="anchor" id="BCM_RX_PKT_TRACE_REASONS_T"></a>BCM_RX_PKT_TRACE_REASONS_T </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Copy to CPU trace event reasons bitmap structure.</caption>
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>rbits </td><td>_SHR_BITDCLSIZE(bcmPktTraceEventCount) </td><td>Bitmap of drop reasons, values define in xref=  </td></tr>
</table>
<p><a class="anchor" id="BCM_RX_PKT_TRACE_REASON_MACROS"></a><a class="anchor" id="bcm_rx_pkt_trace_reasons_macros"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Macros for Analyzing/Constructing Drop Reasons</caption>
<tr>
<th>Macro </th><th>Macro Description  </th></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_GET(_reasons, _reason) </td><td>Macro to check if a reason (bcmPktTraceEvent*) is included in a set of reasons (bcm_rx_pkt_trace_reasons_t)   </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_SET(_reasons, _reason) </td><td>Macro to add a reason (bcmPktTraceEvent*) to a set of reasons (bcm_rx_pkt_trace_reasons_t)   </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_SET_ALL(_reasons) </td><td>Macro to add all drop reasons (bcmPktTraceEvent*) to a set of reasons (bcm_rx_pkt_trace_reasons_t)   </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_CLEAR(_reasons, _reason) </td><td>Macro to clear a reason (bcmPktTraceEvent*) from a set of reasons (bcm_rx_pkt_trace_reasons_t)   </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_CLEAR_ALL(_reasons) </td><td>Macro to clear all reason (bcmPktTraceEvent*) from a set of reasons (bcm_rx_pkt_trace_reasons_t)   </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_IS_NULL(_reasons) </td><td>Macro to check if set of reasons (bcm_rx_pkt_trace_reasons_t) is NULL  </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_ITER(_reasons, _reason) </td><td>Macro to iterate over all reasons (bcmPktTraceEvent*) in a set of reasons (bcm_rx_pkt_trace_reasons_t) is NULL   </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_COUNT(_reasons, count) </td><td>Macro to count number of active reasons in a set of reasons (bcm_rx_pkt_trace_reasons_t)   </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_EQ(_reasons1, _reasons2) </td><td>Macro to compare two sets of reasons (bcm_rx_pkt_trace_reasons_t)  </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_NEQ(_reasons1, _reasons2) </td><td>Macro to negative compare two sets of reasons (bcm_rx_pkt_trace_reasons_t)  </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_AND(_reasons1, _reasons2) </td><td>Macro to perform logical AND operation on two sets of reasons (bcm_rx_pkt_trace_reasons_t)   </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_OR(_reasons1, _reasons2) </td><td>Macro to perform logical OR operation on two sets of reasons (bcm_rx_pkt_trace_reasons_t)   </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_REMOVE(_reasons1, _reasons2) </td><td>Macro to remove set of reasons2 (bcm_rx_pkt_trace_reasons_t) from set of reasons1 (bcm_rx_pkt_trace_reasons_t)   </td></tr>
<tr>
<td>BCM_RX_PKT_TRACE_REASON_NEGATE(_reasons1, _reasons2) </td><td>Macro to negate two sets of reasons (bcm_rx_pkt_trace_reasons_t)  </td></tr>
</table>
<h1><a class="anchor" id="rx_pool_module"></a>
RX Pool Module</h1>
<p>The BCM RX software module supports a configurable packet buffer allocation mechanism. The SDK distribution includes a reference implementation of this service called the "RX pool". This API is used by the RX module to manage buffers for received packets, and is not normally called directly by application code.</p>
<p>The RX pool module pre-allocates packet buffer memory in a DMA-able region. It then manages this packet buffer pool through specific allocation routines. It provides:</p>
<ul>
<li>Pre-setup configuration of packet size and number of packets</li>
<li>Aligns the beginning of all data buffers to 8-byte boundaries</li>
<li>Supports "any point " buffer references; the argument buf passed to <a class="el" href="rx_8h.html#bcm_rx_pool_free">bcm_rx_pool_free</a> may point to any byte in the buffer.</li>
<li>Supports debugging through buffer tracking and pre- and post-allocation data initialization.</li>
</ul>
<p>The main limitation of the reference RX pool module is that it supports buffers of one fixed size. It is usually initialized with buffers that are the size of the maximum supported frame across all ports in the system, including stacking and front panel ports. The maximum frame size may vary depending on the supported devices or application configuration.</p>
<p>Declarations for the RX pool routines and default constants are in internal header files located in \sc include/bcm_int/esw/rx.h \ec. One exception is bcm_rx_pool_own which is declared in \sc <a class="el" href="rx_8h.html">include/bcm/rx.h</a> \ec . This feature is enabled when BCM_RXP_DEBUG is defined at compile time.</p>
<p>This flag, BCM_RXP_DEBUG, controls all debugging options. When defined, the following debug operations are performed or enabled.</p>
<ul>
<li>Counters are enabled for: Outstanding allocations, total number of allocation operations, total number of free operations, total number of allocation requests which failed due to buffer exhaustion.</li>
<li>Each buffer may have an "owner" object associated to it through the <a class="el" href="rx_8h.html#bcm_rx_pool_own">bcm_rx_pool_own</a> function. That value is set to NULL when a buffer is deallocated, and set to the string "rx_pool_alloc" when allocated.</li>
<li>On free, the buffer data is initialized to 0xEE (for empty).</li>
<li>On allocation, the buffer data is checked to be empty (0xEE) and then set to 0xAA (allocated) before being returned to the application.</li>
<li>The functions <a class="el" href="rx_8h.html#bcm_rx_pool_dump">bcm_rx_pool_dump</a>, <a class="el" href="rx_8h.html#bcm_rx_pool_free_verify">bcm_rx_pool_free_verify</a>, <a class="el" href="rx_8h.html#bcm_rx_pool_own">bcm_rx_pool_own</a> and <a class="el" href="rx_8h.html#bcm_rx_pool_report">bcm_rx_pool_report</a> are compiled in and may be accessed through a runtime shell.</li>
</ul>
<p>The RX pool allocation and free routines conform to the bcm_data_alloc_f and bcm_data_free_f type functions, although they ignore the unit and flags parameters.</p>
<p>The reference RX pool uses sal_dma_alloc and sal_dma_free to acquire and release memory used for RX pool buffers. These functions may be replaced by defining the macros BCM_RX_POOL_MEM_ALLOC and BCM_RX_POOL_MEM_FREE in \sc rx_pool.c \ec. Replacement functions must have the same function signatures as sal_dma_alloc and sal_dma_free.</p>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="rx_8h.html#ae6b1592e614fbf2e23b3f8be7557f4de" title="Set up the RX pool software module.">bcm_rx_pool_setup(int pkt_count, int bytes_per_pkt)</a>  </td><td>Set up the RX pool software module.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a703b807e70f4255437c023037b33dc57" title="Boolean indication of whether the RX pool module is currently set up.">bcm_rx_pool_setup_done(void )</a>  </td><td>Boolean indication of whether the RX pool module is currently set up.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#acbe732dee89d88c7b9f3d12a0e4c4e73" title="Deallocate RX pool structures.">bcm_rx_pool_cleanup(void )</a>  </td><td>Deallocate RX pool structures.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a8a79f9a2c1a108ba91d0d3c054cf26b2" title="Allocate a buffer from RX pool.">bcm_rx_pool_alloc(int unit, int size, uint32 flags, void** pool)</a>  </td><td>Allocate a buffer from RX pool.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a4becc84f51c40d967b0103fbd0e18c92" title="Deallocate a buffer allocated with =bcm_rx_pool_alloc.">bcm_rx_pool_free(int unit, void* buf)</a>  </td><td>Deallocate a buffer allocated with <a class="el" href="rx_8h.html#bcm_rx_pool_alloc">bcm_rx_pool_alloc</a> .   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a1a1fa2566ac227919b73251cf193c14f" title="Indicate ownership of an RX pool buffer.">bcm_rx_pool_own(void* buf, void* owner)</a>  </td><td>Indicate ownership of an RX pool buffer.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a38aa6da832ac280eb1c69d1ffb98b04b" title="Send RX pool debugging information to an output stream.">bcm_rx_pool_report(int min, int max)</a>  </td><td>Send RX pool debugging information to an output stream   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a7889171d70a2379db08638bf3b891e5b" title="Display information on RX pool buffer status.">bcm_rx_pool_dump(int min, int max)</a>  </td><td>Display information on RX pool buffer status   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#ae7684ba6d0ea4c41819c13fe2170be2e" title="Verify the RX pool free buffer list.">bcm_rx_pool_free_verify()</a>  </td><td>Check the integrity of the RX pool free buffer list   </td></tr>
<tr>
<td>bcm_data_alloc_f()  </td><td>Packet data allocation and deallocation function prototypes.   </td></tr>
<tr>
<td>bcm_data_free_f()  </td><td>Packet data allocation and deallocation function prototypes.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a8d5be37a2b6bc072cece366724b36195">bcm_rx_alloc_f()</a>  </td><td>Packet data allocation and deallocation function prototypes.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a2423d3f00ce1858828748313815981a6">bcm_rx_free_f()</a>  </td><td>Packet data allocation and deallocation function prototypes.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a43785a1e093f7604d3a62b5a642bceb5">bcm_pkt_alloc_f()</a>  </td><td>Packet structure allocation and deallocation function prototypes.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a185cf409799918e71b914dc61995d3a3">bcm_pkt_free_f()</a>  </td><td>Packet structure allocation and deallocation function prototypes.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#aebce93fbde3e611e24d35700c6b6941d">bcm_rx_cb_f()</a>  </td><td>BCM RX callback function prototype   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a197ba5dd5dfba9a9ee2d232c4ae54a1f">bcm_rx_reg_f()</a>  </td><td>Packet receive register and unregister function prototypes.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a0853d9526f8c278eac2f0a5d5933bb1d">bcm_rx_unreg_f()</a>  </td><td>Packet receive register and unregister function prototypes.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a0eeb6761ec4add847f58c6387e064474">bcm_rx_sched_cb()</a>  </td><td>Packet receive scheduler function prototype.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#af4944164965c3fe0f52628763f2ec6c9">bcm_pkt_l2_map_f()</a>  </td><td>Packet layer 2 address resolution function prototype.   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#a9ae99f63ac8ad48b70b986adecac0ef4">bcm_tx_f()</a>  </td><td>Function prototypes for transmitting one or more packets.   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#a32413682a4a3495b974aeb5973925144">bcm_tx_list_f()</a>  </td><td>Function prototypes for transmitting one or more packets.   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#a3902e29f9e6755b964065b7cf1f8674f">bcm_tx_array_f()</a>  </td><td>Function prototypes for transmitting one or more packets.   </td></tr>
<tr>
<td><a class="el" href="pkt_8h.html#a4111a17053ae4e710b8450a2e1f8be44">bcm_pkt_cb_f()</a>  </td><td>Asynchronous callback function prototype.   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#a442c94ac1c9925b61b2a3ea563e8e812">bcm_tx_pkt_setup_f()</a>  </td><td>Packet transmit setup function prototype.   </td></tr>
</table>
<h1><a class="anchor" id="packet_tunneling"></a>
Packet Tunneling</h1>
<p>In a system with multiple CPUs, switch, and fabric devices, it would be ideal if any front-panel port could forward packets to any CPU in the system, with full information associated with the packet (such as original ingress port or references to filter rules applied to the packet at various devices). Unfortunately, not all hardware supports to this ideal. Similarly, it would be ideal if any CPU could send arbitrary packets out any front-panel port. Again, intervening hardware could interfere with these operations, for example, if the packet were a protocol packet that was interpreted by a device interconnect port.</p>
<p>In addition, if some out-of-band channel exists between the CPUs, it might be desirable to use that channel to convey some packets between CPUs. This channel would not be able to convey packet metadata without some form of encapsulation.</p>
<p>To support goals like these, the Broadcom Network Switching Software distribution provides a feature called "CPU tunneling" to transfer packets between Host CPUs in such a system. In general, application writers may use the BCM TX and RX APIs and need not be aware that CPU tunneling has taken place. For example, calling <a class="el" href="rx_8h.html#bcm_rx_register">bcm_rx_register</a> for a remote device will result in the RX module on the remote device capturing the packets, updating the meta-data associated with the packet, transferring them to the local CPU, where the local SDK will call receive callbacks as though the packet had directly ingressed the local device.</p>
<p>RX tunnel connections are set up when a <a class="el" href="rx_8h.html#bcm_rx_register">bcm_rx_register</a> (or <a class="el" href="rx_8h.html#bcm_rx_queue_register">bcm_rx_queue_register</a>) call is made with unit indicating a remote device. Whether a packet is tunneled to a remote CPU is not determined inside of the RX module, but in the callbacks. However, an RX tunneling module provides support for this. See txrx_tunnel .</p>
<p>Beginning with SDK-5.2.3, CPU tunneling uses the CPU transport application described in stacking.sect.cputrans . The BCM TX layer provides a CPU tunnel hook that may be set to an external CPU tunnel function provided by this library.</p>
<p><a class="el" href="trtx.html#bcm_cpu_tunnel_mode_t">bcm_cpu_tunnel_mode_t</a> describes the type of tunneling to be used for RX and is defined in <a class="el" href="pkt_8h.html">pkt.h</a>.</p>
<p><a class="anchor" id="bcm_cpu_tunnel_mode_t"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>BCM Tunneling Type Identifiers (bcm_cpu_tunnel_mode_t)</caption>
<tr>
<th>Name </th><th>Description  </th></tr>
<tr>
<td>BCM_CPU_TUNNEL_NONE </td><td>Do not tunnel (was BCM_TUNNEL_NONE)  </td></tr>
<tr>
<td>BCM_CPU_TUNNEL_PACKET_RELIABLE </td><td>Tunnel using reliable transport if available (was BCM_TUNNEL_PACKET_RELIABLE)   </td></tr>
<tr>
<td>BCM_CPU_TUNNEL_PACKET_BEST_EFFORT </td><td>Tunnel using best effort transport if available (was BCM_TUNNEL_PACKET_NO_ACK)   </td></tr>
<tr>
<td>BCM_CPU_TUNNEL_PACKET </td><td>Tunnel using default mode (was BCM_TUNNEL_PACKET)  </td></tr>
</table>
<p>The call bcm_tx_tunnel has been deprecated. The API <a class="el" href="tx_8h.html#bcm_tx">bcm_tx</a> will automatically tunnel if a remote device is specified.</p>
<p>As previously mentioned, the CPU tunnel mechanism has been decoupled from the BCM API. For TX, this is accomplished by the provision of a CPU tunnel hook in the BCM TX layer. See <a class="el" href="tx_8h.html#bcm_tx_cpu_tunnel_set">bcm_tx_cpu_tunnel_set</a> for details.</p>
<p>To indicate the tunneling properties for TX, flags may be passed to the CPU tunnel routine. The definition of these flags is provided in the BCM packet API. <a class="anchor" id="bcm_tunnel_tx_flags"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Flag Definitions.</caption>
<tr>
<th>Name </th><th>Description  </th></tr>
<tr>
<td>BCM_CPU_TUNNEL_F_UNTAGGED </td><td>Forward out front-panel port without a VLAN tag (was BCM_TUNNEL_F_UNTAGGED)   </td></tr>
<tr>
<td>BCM_CPU_TUNNEL_F_L3 </td><td>Set the Layer 3 bitmap for the egress port when sent out the front-panel port (was BCM_TUNNEL_F_L3)   </td></tr>
<tr>
<td>BCM_CPU_TUNNEL_F_PBMP </td><td>Use the port bitmap in the packet when sending on the destination device rather than a single port (was BCM_TUNNEL_F_PBMP)   </td></tr>
<tr>
<td>BCM_CPU_TUNNEL_F_RELIABLE </td><td>Tunnel using a reliable transport between the CPUs if available (was BCM_TUNNEL_F_RELIABLE)   </td></tr>
<tr>
<td>BCM_CPU_TUNNEL_F_BEST_EFFORT </td><td>Tunnel using a best effort transport between the CPUs if available (was BCM_TUNNEL_F_BEST_EFFORT)   </td></tr>
<tr>
<td>BCM_CPU_TUNNEL_F_ALL_UNTAGGED </td><td>Send out all ports untagged; used with BCM_TUNNEL_F_PBMP (was BCM_TUNNEL_F_ALL_UNTAGGED)   </td></tr>
</table>
<p><a class="el" href="trtx.html#old_tunnel_apis">old_tunnel_apis</a> identifies APIs that have been removed from the BCM API as of SDK-5.2.3. The new APIs exist in the application directory: \sc include/appl/cputrans/ct_tun.h. \ec <a class="anchor" id="old_tunnel_apis"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>CPU Tunnel APIs</caption>
<tr>
<th>Old API </th><th>New API </th><th>New Location  </th></tr>
<tr>
<td>bcm_rx_tunnel_filter_f </td><td>ct_rx_tunnel_filter_f </td><td>\sc ct_tun.h \ec  </td></tr>
<tr>
<td>bcm_rx_tunnel_filter_f </td><td>ct_rx_tunnel_filter_f </td><td>\sc ct_tun.h \ec  </td></tr>
<tr>
<td>bcm_rx_tunnel_direct_f </td><td>ct_rx_tunnel_direct_f </td><td>\sc ct_tun.h \ec  </td></tr>
<tr>
<td>bcm_rx_tunnel_filter_set/get </td><td>bcm_rx_tunnel_filter_set/get </td><td>\sc ct_tun.h \ec  </td></tr>
<tr>
<td>bcm_rx_tunnel_client_default </td><td>Replaced by accessors </td><td>\sc ct_tun.h \ec  </td></tr>
<tr>
<td>bcm_rx_tunnel_priority </td><td>Replaced by accessors </td><td>\sc ct_tun.h \ec  </td></tr>
<tr>
<td>bcm_rx_tunnelled_pkt_handler </td><td>ct_rx_tunnelled_pkt_handler </td><td>\sc ct_tun.h \ec  </td></tr>
<tr>
<td>bcm_rx_tunnel_check </td><td>ct_rx_tunnel_check </td><td>\sc ct_tun.h \ec  </td></tr>
<tr>
<td>bcm_tx_tunnel_setup </td><td>ct_tx_tunnel_setup </td><td>\sc ct_tun.h \ec  </td></tr>
<tr>
<td>bcm_tx_tunnel </td><td>bcm_tx_cpu_tunnel </td><td>\sc <a class="el" href="tx_8h.html">bcm/tx.h</a> \ec   </td></tr>
<tr>
<td>bcm_tx_tunnel_forward </td><td>ct_tx_tunnel_forward </td><td>\sc ct_tun.h \ec  </td></tr>
<tr>
<td>bcm_tunnel_mode_t </td><td>bcm_cpu_tunnel_mode_t </td><td>\sc <a class="el" href="pkt_8h.html">bcm/pkt.h</a> \ec  </td></tr>
</table>
<p>The file \sc ct_tun.h \ec is in \sc include/appl/cputrans \ec .</p>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td>ct_rx_tunnel_filter_f()  </td><td>Prototype for function to determine which RX packets to tunnel   </td></tr>
<tr>
<td>ct_rx_tunnel_direct_f()  </td><td>Prototype for function to determine to which CPU packet should be tunneled   </td></tr>
<tr>
<td>ct_rx_tunnel_filter_set()  </td><td>Set/get the tunnel filter function used by ct_rx_tunnel_check   </td></tr>
<tr>
<td>ct_rx_tunnel_filter_get()  </td><td>Set/get the tunnel filter function used by ct_rx_tunnel_check   </td></tr>
<tr>
<td>ct_rx_tunnel_direct_set()  </td><td>Set the tunnel redirection function used by ct_rx_tunnel_check   </td></tr>
<tr>
<td>ct_rx_tunnel_direct_get()  </td><td>Set the tunnel redirection function used by ct_rx_tunnel_check   </td></tr>
<tr>
<td>ct_rx_tunnel_check()  </td><td>Determine whether and where a packet should be tunneled   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#acf4e52c2811fea83020caa0e6030468d">bcm_tx_cpu_tunnel_f()</a>  </td><td>Type definition of a TX CPU tunnel function   </td></tr>
<tr>
<td>ct_tx_tunnel_setup()  </td><td>Set up for TX packet tunneling   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#a284c3af06f90767394516834cb1adb22" title="Encapsulate and forward a packet to a different CPU.">bcm_tx_cpu_tunnel(bcm_pkt_t* pkt, int dest_unit, int remote_port, uint32 flags, bcm_cpu_tunnel_mode_t mode)</a>  </td><td>Encapsulate and forward a packet to a different CPU   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#af31846b2e0f07ffd87d58bd44ed0ebb7" title="Encapsulate and forward a packet to a different CPU.">bcm_tx_cpu_tunnel_set(bcm_tx_cpu_tunnel_f f)</a>  </td><td>Encapsulate and forward a packet to a different CPU   </td></tr>
<tr>
<td><a class="el" href="tx_8h.html#ab30d1ceba09dde3dfdba989a4e037beb" title="Encapsulate and forward a packet to a different CPU.">bcm_tx_cpu_tunnel_get(bcm_tx_cpu_tunnel_f* f)</a>  </td><td>Encapsulate and forward a packet to a different CPU   </td></tr>
<tr>
<td>ct_tx_tunnel_forward()  </td><td>Forward an encapsulated packet out a front panel port   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a4d55c844ac1ceb6556ba6d6cc412727d" title="rx_trap_protocol_set.">bcm_rx_trap_protocol_set(int unit, bcm_rx_trap_protocol_key_t* key_p, bcm_gport_t trap_gport)</a>  </td><td>Set protocol trap action profile: trap strength and action.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#abbd8bfbc7c93217aa94413ba5c4712e1" title="rx_trap_protocol_get.">bcm_rx_trap_protocol_get(int unit, bcm_rx_trap_protocol_key_t* key_p, bcm_gport_t* trap_gport_p)</a>  </td><td>Get configuration of previously created protocol trap.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a2a30326774defdc1b796a0b88b62684b" title="rx_trap_protocol_clear.">bcm_rx_trap_protocol_clear(int unit, bcm_rx_trap_protocol_key_t* key_p)</a>  </td><td>Clear configuration of previously created protocol trap.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a2436843a51e8d24b7325bdf7183665f5" title="rx_trap_protocol_profiles_set.">bcm_rx_trap_protocol_profiles_set(int unit, bcm_gport_t port, bcm_rx_trap_protocol_profiles_t* protocol_profiles_p)</a>  </td><td>This function purpose is to set protocol trap profiles.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#afa7161af9a7d7d60bcff9c2fdd32f64e" title="rx_trap_protocol_profiles_get.">bcm_rx_trap_protocol_profiles_get(int unit, bcm_gport_t port, bcm_rx_trap_protocol_profiles_t* protocol_profiles_p)</a>  </td><td>This function purpose is to get protocol trap profiles configuration.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#af5636fa5f8dab662987aeb67e513d00f" title="Initialize the MTU struct to init values.">bcm_rx_mtu_config_t_init(bcm_rx_mtu_config_t* mtu_config)</a>  </td><td>Initialize the MTU struct to init values.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#ac52671c14a3413d980e2e222d001778f" title="rx_trap_action_profile_set.">bcm_rx_trap_action_profile_set(int unit, uint32 flags, bcm_rx_trap_t trap_type, bcm_gport_t gport)</a>  </td><td>Set the Trap-Action-Profile to of the supplied trap type.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#ac79d238abfc07715af9c3d2fe1332ee2" title="rx_trap_action_profile_get.">bcm_rx_trap_action_profile_get(int unit, bcm_rx_trap_t trap_type, bcm_gport_t* gport)</a>  </td><td>Get the Trap-Action-Profile to of the supplied trap type.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a96df3748797a1fa60b32f419fc5763e5" title="rx_trap_action_profile_clear.">bcm_rx_trap_action_profile_clear(int unit, bcm_rx_trap_t trap_type)</a>  </td><td>Clear the Trap-Action-Profile to of the supplied trap type.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#a1882bc3c50ff48cc07aed33352b2c61a" title="Initialize programmable trap configuration.">bcm_rx_trap_prog_config_t_init(bcm_rx_trap_prog_config_t* prog_config_p)</a>  </td><td>Initializes programmable traps configuration structure.   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/* Rx Program Enable Types */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="rx_8h.html#a166ed658fd774f8d91b77d00f9305708">bcm_rx_trap_prog_enable_e</a> {</div><div class="line">    <a class="code" href="rx_8h.html#a166ed658fd774f8d91b77d00f9305708a8361d6951e8f6d6af9f39d20163d223a">bcmRxTrapProgDisable</a> = 0,</div><div class="line">    <a class="code" href="rx_8h.html#a166ed658fd774f8d91b77d00f9305708ac958f95dc0c5bb907a5adabc52637c3b">bcmRxTrapProgEnableMatch</a> = 1,</div><div class="line">    <a class="code" href="rx_8h.html#a166ed658fd774f8d91b77d00f9305708ac2b5cb0514ebf43f9a21f8988938a8f6">bcmRxTrapProgEnableMismatch</a> = 2</div><div class="line">} <a class="code" href="rx_8h.html#aec73b9dc068049b917182ff808111c83">bcm_rx_trap_prog_enable_t</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Programmable trap structure. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__rx__trap__prog__config__s.html">bcm_rx_trap_prog_config_s</a> {</div><div class="line">    <a class="code" href="rx_8h.html#aec73b9dc068049b917182ff808111c83">bcm_rx_trap_prog_enable_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a89138e1593256da6b596d199ab13bddb">src_mac_enable</a>;</div><div class="line">    <a class="code" href="group__types.html#ga4ccf23ca53e7e7e9a7be38b950aa7943">bcm_mac_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#aa921daa2f03946ed7c419003a5682c7c">src_mac</a>;</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#aaadc82d1ef196814679728a4ac95275e">src_mac_nof_bits</a>;</div><div class="line">    <a class="code" href="rx_8h.html#aec73b9dc068049b917182ff808111c83">bcm_rx_trap_prog_enable_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a1c9de14c415f22d4b2dbc7f2bf71be82">dest_mac_enable</a>;</div><div class="line">    <a class="code" href="group__types.html#ga4ccf23ca53e7e7e9a7be38b950aa7943">bcm_mac_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a488f6cff32476dbb3c737696cef93791">dest_mac</a>;</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#ae064063f0d5c53fea0f696711efe69c5">dest_mac_nof_bits</a>;</div><div class="line">    <a class="code" href="rx_8h.html#aec73b9dc068049b917182ff808111c83">bcm_rx_trap_prog_enable_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a7e3b2129f365853ea231b35bd629a03e">ether_type_enable</a>;</div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a7ca0d84baf6b360b732417e8b107834a">ether_type</a>;</div><div class="line">    <a class="code" href="rx_8h.html#aec73b9dc068049b917182ff808111c83">bcm_rx_trap_prog_enable_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a905e3a99dd1b2a98a795a9d89aedf034">sub_type_enable</a>;</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a63dc106a1e1b3d32190d49bfcede4c07">sub_type</a>;</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a67f11aa177505ab4e5af1552ae2e18f6">sub_type_mask</a>;</div><div class="line">    <a class="code" href="rx_8h.html#aec73b9dc068049b917182ff808111c83">bcm_rx_trap_prog_enable_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a8a547a6fe98d7fff340f9e776711a760">ip_protocol_enable</a>;</div><div class="line">    <a class="code" href="sal_2types_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#abc516bfaffd1558a4ee27a4023e0d160">ip_protocol</a>;</div><div class="line">    <a class="code" href="rx_8h.html#aec73b9dc068049b917182ff808111c83">bcm_rx_trap_prog_enable_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#ac1c1007bd5f466276101e3e254d5595b">l4_ports_enable</a>;</div><div class="line">    <a class="code" href="group__types.html#gad7e36a8d90f5765e8ca58770666c0860">bcm_port_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a7cbfe483f21f219557fe8f7684fb1a9d">src_port</a>;</div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a40d9488619bdf31cfc1704fb32b4da9b">src_port_mask</a>;</div><div class="line">    <a class="code" href="group__types.html#gad7e36a8d90f5765e8ca58770666c0860">bcm_port_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a0a422a028bf37f9e169c493372c38955">dest_port</a>;</div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a87fb5f14881dacc6a6d9c0254b5fa35e">dest_port_mask</a>;</div><div class="line">    <a class="code" href="rx_8h.html#aec73b9dc068049b917182ff808111c83">bcm_rx_trap_prog_enable_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#aa1090d91cff29de6c0eb1541244242b5">tcp_flags_enable</a>;</div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a9dff1890335f48ca41601b02fd4b7b6d">tcp_flags</a>;</div><div class="line">    <a class="code" href="sal_2types_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a6951d7e38152ee42582638b2a73badf0">tcp_flags_mask</a>;</div><div class="line">    <a class="code" href="rx_8h.html#aec73b9dc068049b917182ff808111c83">bcm_rx_trap_prog_enable_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a9338d38a2f35d0079829498091cec598">tcp_seq_is_zero_enable</a>;</div><div class="line">    <a class="code" href="group__types.html#gac5f933aaac05c65b2a78ad8a04316994">bcm_gport_t</a> <a class="code" href="structbcm__rx__trap__prog__config__s.html#a8464a9867529602160ab66721171d0c8">trap_gport</a>;</div><div class="line">} <a class="code" href="rx_8h.html#a7e88f4c683cd21c7f1646bcf7e6f292c">bcm_rx_trap_prog_config_t</a>;</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="rx_8h.html#afe0cfc54852e622abb5af943fcd290f5" title="Set programmable trap configuration.">bcm_rx_trap_prog_set(int unit, uint32 flags, uint8 prog_index, bcm_rx_trap_prog_config_t* prog_config_p)</a>  </td><td>Set programmable trap configuration.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#aa29b3b590ee3f5ff8652b78c550a2205" title="Get programmable trap configuration.">bcm_rx_trap_prog_get(int unit, uint8 prog_index, bcm_rx_trap_prog_config_t* prog_config_p)</a>  </td><td>Get programmable trap configuration.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#aab8248cd8352a04bd876e6e1af76440a" title="Initialize LIF trap configuration.">bcm_rx_trap_lif_config_t_init(bcm_rx_trap_lif_config_t* lif_config_p)</a>  </td><td>Initializes LIF traps configuration structure.   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/* LIF types for trap configuration */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="rx_8h.html#a24e645c58e761482ae6b72384d357a73">bcm_rx_trap_lif_type_e</a> {</div><div class="line">    <a class="code" href="rx_8h.html#a24e645c58e761482ae6b72384d357a73aba150c8a056bfb5944abb1de6988bb1c">bcmRxTrapLifTypeInLif</a> = 0,</div><div class="line">    <a class="code" href="rx_8h.html#a24e645c58e761482ae6b72384d357a73a7934a08a7d55778549be27c8de39fbf0">bcmRxTrapLifTypeInRif</a> = 1,</div><div class="line">    <a class="code" href="rx_8h.html#a24e645c58e761482ae6b72384d357a73a2c2119d018a6c3d89dc2564204667ac5">bcmRxTrapLifTypeOutLif</a> = 2,</div><div class="line">    <a class="code" href="rx_8h.html#a24e645c58e761482ae6b72384d357a73a798a9ce3ebf29027ab87485eb015ce96">bcmRxTrapLifTypeOutRif</a> = 4</div><div class="line">} <a class="code" href="rx_8h.html#ad1cc5c63e2bead0af3f06f4f54b9f25a">bcm_rx_trap_lif_type_t</a>;</div><div class="line"></div><div class="line"><span class="comment">/* LIf traps configuration structure. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__rx__trap__lif__config__s.html">bcm_rx_trap_lif_config_s</a> {</div><div class="line">    <a class="code" href="rx_8h.html#ad1cc5c63e2bead0af3f06f4f54b9f25a">bcm_rx_trap_lif_type_t</a> <a class="code" href="structbcm__rx__trap__lif__config__s.html#a1bf07ff3685a613763ba32e55cfdb8f7">lif_type</a>;</div><div class="line">    <a class="code" href="group__types.html#ga30e6e81bfad0b18e55d3a1c8148fd75d">bcm_if_t</a> <a class="code" href="structbcm__rx__trap__lif__config__s.html#a8ba802386149f2e8166510a2b3828e0a">rif_intf</a>;                  <span class="comment">/* Interface  RIF */</span></div><div class="line">    <a class="code" href="group__types.html#gac5f933aaac05c65b2a78ad8a04316994">bcm_gport_t</a> <a class="code" href="structbcm__rx__trap__lif__config__s.html#a38cb85b70e63e6a8ce6e2277b7bbdd7a">lif_gport</a>;              <span class="comment">/* GPORT LIF */</span></div><div class="line">    <a class="code" href="group__types.html#gac5f933aaac05c65b2a78ad8a04316994">bcm_gport_t</a> <a class="code" href="structbcm__rx__trap__lif__config__s.html#a71755d7a10872afb46c9dbe993c03171">action_gport</a>;           <span class="comment">/* hold theTrap-Action-Profile or</span></div><div class="line"><span class="comment">                                           mirror_cmd(only for egress) to</span></div><div class="line"><span class="comment">                                           configure */</span></div><div class="line">} <a class="code" href="rx_8h.html#a3d34ae214e4c5f84d067171375386477">bcm_rx_trap_lif_config_t</a>;</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="rx_8h.html#ac72dbb8744e62867753a2842e4e251ff" title="Set LIF trap configuration.">bcm_rx_trap_lif_set(int unit, uint32 flags, bcm_rx_trap_lif_config_t* lif_config_p)</a>  </td><td>Set LIF trap configuration.   </td></tr>
<tr>
<td><a class="el" href="rx_8h.html#aafb7c09ca8d67d5c39391b1364db1bb9" title="Get LIF trap configuration.">bcm_rx_trap_lif_get(int unit, bcm_rx_trap_lif_config_t* lif_config_p)</a>  </td><td>Get LIF trap configuration.   </td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="footer-brcm-wrapper">
<table class="footer-brcm">
	<tbody><tr>
		<td class="footer-brcm"><img src="BRCM_Red+Black_noTag_RGB.png" align="left"></td>
		<td class="footer-brcm"><small><b>Proprietary and Confidential &copy; 2019 Broadcom</b></small>
			<div class="footer-brcm">Broadcom Incorporated reserves the right to make changes without further notice to any products or data herein to improve reliability, function, or design.
Information furnished by Broadcom Incorporated is believed to be accurate and reliable. However, Broadcom Incorporated does not assume any liability arising
out of the application or use of this information, nor the application or use of any product or circuit described herein, neither does it convey any license
under its patent rights nor the rights of others.
			</div>
		</td>
	</tr>
</tbody></table>
</div>
</body>
</html>
