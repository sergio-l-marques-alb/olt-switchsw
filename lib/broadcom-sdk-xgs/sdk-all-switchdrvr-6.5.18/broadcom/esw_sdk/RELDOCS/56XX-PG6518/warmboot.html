<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDK API Guide: Warm Boot</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_brcm.css" rel="stylesheet" type="text/css"/>
<link href="tabs_brcm.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SDK API Guide
   &#160;<span id="projectnumber">Version 6.5.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Warm Boot </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Warm Boot Documentation</h2>
<h1><a class="anchor" id="wb_warning"></a>
Notice</h1>
<p>Broadcom extensively tests warmboot scenarios in each release based on Broadcom internal test plan. Each customer needs to plan for their own testing and validation of APIs during warmboot processing as Broadcom does not cover all possible customer environment combinations during testing.</p>
<h1><a class="anchor" id="wb_intro"></a>
Warm Boot Introduction</h1>
<p>Warm Boot is the process of restarting the device driver software while the hardware is running without interruption to the data plane. The primary applications for Warm Boot include application software upgrades and driver upgrades. A controlled restart scenario is considered here. During Warm Boot, the software goes through a special initialization sequence to rebuild its internal state without interfering with switching. In many cases, software state can be recovered by reading the hardware. Unlike the Easy Reload solution, Warm Boot does not require the application to replay the APIs. This implementation of Warm Boot is a considerable improvement over previous solutions aimed at reconstructing the driver's software state. Here are the key improvements over the previous implementation:</p>
<ul>
<li>Various modules have certain amount of state ranging from a few bytes to a few hundred bytes. For this state can be recovered, the application must provde hooks for persistent storage mechanisms to be leveraged by SDK as described in this section.</li>
<li>Replay of any APIs other than callback registration is not a requirement.</li>
<li>If required by the application, the SDK can reconstruct its state to match the original SW state. This will re-generate the original SW handles.</li>
<li>Internal (or if available, external) storage needs to be reserved for this approach.</li>
<li>There are two options in WarmBoot recovery:<ul>
<li>Limited storage recovery: this useful if the application cannot provide an onboard storage or a non-volatile RAM. In this scenario, the SDK can store away the software state for modules that have "small" storage requirements as defined above. The data will be stored in the chip's internal next hop tables. It is recommended to allocate 2 KB of storage, which for a chip like the BCM56334 will translate to approximately 200 next hop entries out of possible 8K entries. Modules like Field, MPLS and OAM have much more state than what can be accommodated in a few hundred next hop entries and require the full recovery method described below. The limited storage recovery is no longer supported from SDK-6.5.8 as the current requirements for scache size cannot be supported by next hop table entries.</li>
<li>Full recovery: this is needed when the application needs to faithfully recover the Field, MPLS and OAM modules. The application needs to provide persistent storage (at least persistent across the boot time). The recommended storage size for BCM56334 is 250KB. For BCM56514, BCM56504 and BCM56224 chip families the recommended size is 100KB.</li>
</ul>
</li>
</ul>
<p>WarmBoot recovery is supported for a subset of Broadcom devices. In all cases, the application needs to specify the persistent storage location and the amount of storage required. The persistent storage can be any external non-volatile memory or one of the internal memories of the chip. If an external non-volatile memory is used, the application needs to supply read/write functions.</p>
<p>The following is the normal initialization sequence from a power on boot, also referred to as the cold boot initialization sequence.</p>
<ul>
<li>Device Probe<ul>
<li>Loop over all devices on the PCI bus</li>
<li>If the (device ID, revision ID) combination is supported, call soc_cm_device_create</li>
<li>End loop</li>
</ul>
</li>
<li>Device Attach<ul>
<li>Initialize OS-specific device access function pointers.</li>
<li>Call soc_cm_device_init to attach the device access vectors to the device handle returned by soc_cm_device_create. soc_cm_device_init calls soc_attach.</li>
</ul>
</li>
<li>The application needs to do the following in order to enable WarmBoot:<ul>
<li>Select the location of the persistent storage by calling: int soc_stable_set(int unit, int stable_type, uint32 flags) The supported stable_types are:<ul>
<li>BCM_SWITCH_STABLE_APPLICATION (use an external non-volatile memory) <pre class="fragment">The flags must be zero.  - If the stable_type is BCM_SWITCH_STABLE_APPLICATION, the application needs
to register read/write functions by issuing the following function call:

int bcm_switch_stable_register(int unit,
                               bcm_switch_read_func_t rf,
                               bcm_switch_write_func_t wf)

bcm_switch_read_func_t and bcm_switch_write_func_t are defined as follows:

typedef int (*bcm_switch_read_func_t)(int unit,
                                      uint32 *buf,
                                      int offset,
                                      int nbytes);

typedef int (*bcm_switch_write_func_t)(int unit,
                                       uint32 *buf,
                                       int offset,
                                       int nbytes);
</pre></li>
</ul>
</li>
<li>Select the size of the storage by calling soc_stable_size_set(int unit, int size)</li>
</ul>
</li>
<li>soc_reset_init</li>
<li>soc_misc_init</li>
<li>soc_mmu_init</li>
<li>bcm_init</li>
<li>Application initialization</li>
</ul>
<p><a class="el" href="group__init.html#bcm_init">bcm_init</a> internally initializes supported modules for a given device.</p>
<p>The following is the sequence of function calls that the application needs to make to use Warm Boot:</p>
<ul>
<li>Device Probe<ul>
<li>Loop over all devices on the PCI bus</li>
<li>If the (device ID, revision ID) combination is supported, call soc_cm_device_create</li>
<li>End loop</li>
</ul>
</li>
<li>Device Attach<ul>
<li>Initialize OS-specific device access function pointers.</li>
<li>Call soc_cm_device_init to attach the device access vectors to the device handle returned by soc_cm_device_create. soc_cm_device_init calls soc_attach.</li>
</ul>
</li>
<li>SOC_WARM_BOOT_START; this disables device writes to the device</li>
<li>Enable Warm Boot:<ul>
<li>Select the location of the persistent storage by calling: int soc_stable_set(int unit, int stable_type, uint32 flags) The supported stable_types are:<ul>
<li>BCM_SWITCH_STABLE_APPLICATION (use an external non-volatile memory) <pre class="fragment">The flags must be zero.  - If the stable_type is BCM_SWITCH_STABLE_APPLICATION, the application needs
to register read/write functions by issuing the following function call:

int bcm_switch_stable_register(int unit,
                               bcm_switch_read_func_t rf,
                               bcm_switch_write_func_t wf)

bcm_switch_read_func_t and bcm_switch_write_func_t are defined as follows:

typedef int (*bcm_switch_read_func_t)(int unit,
                                      uint32 *buf,
                                      int offset,
                                      int nbytes);

typedef int (*bcm_switch_write_func_t)(int unit,
                                       uint32 *buf,
                                       int offset,
                                       int nbytes);
</pre></li>
</ul>
</li>
<li>Select the size of the storage by calling soc_stable_size_set(int unit, int size)</li>
</ul>
</li>
<li>The application must register an event handler callback for enabling notifications about errors in the persistent storage by using the following API: int soc_event_register(int unit, soc_event_cb_t cb, void *userdata) typedef void (*soc_event_cb_t)( int unit, soc_switch_event_t event, uint32 arg1, uint32 arg2, uint32 arg3, void *userdata); More details are provided in the next section.</li>
<li>soc_init</li>
<li>soc_misc_init</li>
<li>soc_mmu_init</li>
<li>bcm_init; Warm boot is complete when this function returns. The application does NOT need to call SOC_WARM_BOOT_DONE. After bcm_init returns, the system is in normal operating mode and the application can call any BCM API.</li>
<li>The application may also optionally call bcm_topo_map_set.</li>
<li>If the device was started in Warm Boot mode, the application only needs to re-registers callbacks:<ul>
<li>bcm_linkscan_register, bcm_linkscan_port_register</li>
<li>bcm_rx_register and other rx configuration if needed</li>
<li>bcm_stk_update_callback_register</li>
</ul>
</li>
</ul>
<p>The main use case in this design is a controlled shutdown for application/driver upgrade. The following sequence must be executed to ensure proper release of memory and thread resources:</p>
<ul>
<li>SOC_WARM_BOOT_START</li>
<li>bcm_detach</li>
<li>SOC_WARM_BOOT_DONE</li>
<li>soc_shutdown</li>
</ul>
<p>Note that the warm boot support (including upgrade and downgrade) assumes config properties to be same in both images of SDK revisions.</p>
<h1><a class="anchor" id="wb_sync"></a>
Synchronizing the SDK Software State with the Persistent Storage</h1>
<p>The following switch control can be used to store the relevant SDK software in the persistent storage:</p>
<p>bcmSwitchControlSync</p>
<p>Calling the above switch control will commit the relevant SDK software state to the persistent storage. Note that the amount of storage is estimated to be around 100KB/250KB.</p>
<p>If the application requires the persistent storage to be updated after every change to the software state, the following switch control can be used:</p>
<p>bcmSwitchControlAutoSync</p>
<p>The above switch control will commit the relevant SDK software state to the persistent storage after every API call that results in a state change that cannot be detected from reading the hardware programming. Examples include the following:</p>
<ul>
<li>APIs that create FP groups, entries, policers and statistics objects.</li>
<li>APIs that change the priorities of entries.</li>
<li>APIs that change the default VLAN.</li>
<li>APIs that change any other entity that has internal SW state.</li>
</ul>
<p>The SDK also handles the following error conditions associated with the persistent storage.</p>
<ul>
<li>Corrupt stored data: If the stored data is found to be corrupt (based on guards and markers), the SDK will notify the application using the following switch event:</li>
</ul>
<p>BCM_SWITCH_EVENT_STABLE_ERROR</p><ul>
<li>arg1 = SOC_STABLE_CORRUPT</li>
<li>arg2 = arg3 = 0</li>
</ul>
<p>Stale stored data: If the stored data is found to be stale due to any reason, the SDK will notify the application using the following switch event:</p>
<p>BCM_SWITCH_EVENT_STABLE_ERROR</p><ul>
<li>arg1 = SOC_STABLE_STALE</li>
<li>arg2 = SOC_STABLE_FIELD or SOC_STABLE_MPLS or SOC_STABLE_MULTICAST (for FP / MPLS /Multicast modules) = 0 (for any other module)</li>
<li>arg3 = 0</li>
</ul>
<p>The return value of bcm_init will be BCM_E_NONE but the application will receive notifications. It can then make appropriate decisions on proceeding further.</p>
<h1><a class="anchor" id="wb_post"></a>
Post Warm Boot Software State</h1>
<h2><a class="anchor" id="wb_field"></a>
Field Processor State</h2>
<p>bcm_init internally recovers state for supported modules (when Warm Boot is asserted ON). An important point to note is that the state recovery for policers and statistics objects is done assuming that the hardware resources were allocated using the bcm_policer_* and bcm_field_stat_* APIs. For the application to be compliant with warm boot, it must use the bcm_policer_* and bcm_field_stat_* APIs while configuring meters and counters. Also, for UDF functionality, the application needs to use the bcm_field_data_* APIs and not the bcm_field_udf_* APIs to be compliant with warm boot.</p>
<p>The recovered software state will match the state prior to the shutdown.</p>
<ul>
<li>All SW-only entities (group IDs, QSETs, entry / policer / statistics object IDs and priorities) are stored in a persistent location.</li>
<li>The recovered SDK state will match the state prior to the shutdown. Provided that all created FP entries are installed in hardware before recovery.</li>
<li>Based on a typical worst case usage scenario for BCM56514 (with IFP, VFP, EFP and 256 entries per slice), the estimated storage requirement is of the order of 100 KB. For BCM56334 and newer XGS chips, there can be up to 512 entries per slice. In addition to the FP, BCM56334 has modules like MPLS and OAM that end up requiring storage space. The storage requirement increases to 250 KB.</li>
</ul>
<p>There are some color-dependent actions that may get aliased during Warm boot recovery. For example, the SDK cannot distinguish whether the application added bcmFieldActionDrop or specifically added bcmFieldActionGpDrop, bcmFieldActionYpDrop and bcmFieldActionRpDrop.</p>
<p>The following switch control can be set to instruct the FP module to save and recover the group IDs, entry IDs, policer IDs and statistics object IDs in 32 bits (long IDs).</p>
<p>bcmSwitchStableSaveLongIds</p>
<p>It is not set by default, so these IDs are stored and recovered as compressed IDs (13 bits max). This switch control should be executed (if needed) before the sync operation (bcmSwitchControlSync).</p>
<h2><a class="anchor" id="wb_level2"></a>
WarmBoot Storage</h2>
<p>A subset of the modules in the SDK requires some form of persistent storage for WarmBoot recovery. The list below shows the impact of WarmBoot recovery for the various modules. Once warm boot is completed, the application may query the SDK using various "traverse" or "get" APIs.</p>
<p>BCM CLI command 'warmboot storage' can be used to make an estimate of the total (as well as the per-module) persistent storage required. For example, the SDK can be used in a simulation environment to estimate the warmboot storage requirements before using it on the actual device. See spreadsheet $SDK/doc/field_scache_storage.xlsx for a more accurate estimation of the storage requirement for the 'field' module.</p>
<ul>
<li>Port<ul>
<li>State can be recovered from the chip.</li>
<li>HCFC is recovered by reading the HW, and only flags field is recovered.</li>
</ul>
</li>
<li>L2<ul>
<li>State can be recovered from the chip. Only direct recovery from HW (no SW state required), is supported for entries configured using <a class="el" href="group__l2.html#ga3e9b6b3dbc1fdd2f88f75fda2395dbd3" title="Add an entry to L2 Station table.">bcm_l2_station_add()</a> API. During warm boot recovery, only valid entries installed in the hardware are recovered. Station ID value for the entries are generated internally and are in increasing order. Entry priorities are constructed based on their relative positions in the TCAM. This cannot detect the case where two entries may have equal priorities. After recovery, application may use <a class="el" href="group__l2.html#ga3e9b6b3dbc1fdd2f88f75fda2395dbd3" title="Add an entry to L2 Station table.">bcm_l2_station_add()</a> API with BCM_L2_STATION_REPLACE flag set to update the entry priority values.</li>
</ul>
</li>
<li>VLAN<ul>
<li>The default VLAN is recovered from WarmBoot storage, as it cannot be reconstructed by reading the HW. Instead of restoring, the application can choose to set the default VLAN using <a class="el" href="group__vlan.html#ga2f52250924d9d49df8f3cb48e10169a4" title="Set the default VLAN ID.">bcm_vlan_default_set()</a> after Warm Boot is completed.</li>
</ul>
</li>
<li>STG<ul>
<li>The default STG cannot be restored by reading from HW, and must be stored in WarmBoot storage. Instead of storing, the application can choose to simply set the default STG using <a class="el" href="group__stg.html#ga46fee6b269d051a4912e377b4f20767d" title="Designate the default STG ID for the chip.">bcm_stg_default_set()</a> after Warm Boot is completed.</li>
<li>Empty STGs cannot be recovered by reading the HW, and thus must be stored in WarmBoot storage. Instead of storing, the application can choose to use <a class="el" href="group__stg.html#ga9cde21d6dd7cdeabae576a4a2affa69c" title="Create a new STG, using a specific STG ID.">bcm_stg_create_id()</a> to create an STG with an ID. The API will return an error if it has already been created.</li>
</ul>
</li>
<li>COSQ<ul>
<li>The number of COSQs configured in the chip cannot be recovered by reading the HW, and thus is stored in WarmBoot storage.</li>
</ul>
</li>
<li>Mirror<ul>
<li>Mirror destination IDs may no longer match the destination information. The application may wish to use the bcm_mirror_destination_traverse API to learn the new mapping between the destination ID and the bcm_mirror_destination_t encapsulation.</li>
</ul>
</li>
<li>Stack<ul>
<li>State can be recovered from the chip.</li>
<li>The enable or disable state of a module and its number of ports are recovered from WarmBoot storage.</li>
</ul>
</li>
<li>Field<ul>
<li>The strategy for the field processor module has been previously described.</li>
</ul>
</li>
<li>Trunk<ul>
<li>Empty trunks cannot be recovered by reading the HW and thus are stored in WarmBoot storage. Instead of storing, the application can also choose to use the bcm_trunk_create_id() to create a trunk with an ID after WarmBoot. The API will return BCM_E_EXISTS if the trunk has already been created.</li>
</ul>
</li>
<li>Linkscan<ul>
<li>The linkscan mode of ports is not recovered. All ports' modes MUST be set after Warm Boot is complete but before <a class="el" href="link_8h.html#bcm_linkscan_enable_set">bcm_linkscan_enable_set</a> is invoked to restart the linkscan process.</li>
<li>Linkscan forced ports which are not in MAC or PHY loopback will no longer be recognized as forced. Application must provide WarmBoot storage in order to allow SDK to recover this automatically. Alternately, the forced port configuration may be repeated after Warm Boot has completed, but before <a class="el" href="link_8h.html#bcm_linkscan_enable_set">bcm_linkscan_enable_set</a> is invoked, just as for the port mode.</li>
</ul>
</li>
<li>Mcast<ul>
<li>State can be recovered from the chip.</li>
</ul>
</li>
<li>L3<ul>
<li>The ingress and egress modes of operation cannot be recovered by reading the HW, and thus is stored in WarmBoot storage. Instead of storing, the application can also call <a class="el" href="group__switch.html#ga716f58b86dda768c10a69f187f5b9056" title="Configure port-specific and device-wide operating modes. Device wide operating modes are configured o...">bcm_switch_control_set()</a> for bcmSwitchL3IngressMode and bcmSwitchL3EgressMode with the value TRUE after warm boot if it intends to use those modes.</li>
<li>L3 Ingress Interface's valid status is stored in persistent storage so that L3 IIF profile reference counts can be built in software. Applications must provide WarmBoot storage to allow SDK to recover l3 iif profile reference counts.</li>
<li>The usage information of IP4 option profiles is stored in persistent storage. If IP4 option profiles are used, the application must provide WarmBoot stage to recover the usage information of IP4 option profiles. There is no API to reconstruct that other than from WarmBoot storage.</li>
</ul>
</li>
<li>IPMC<ul>
<li>State can be recovered from the chip. If L3 interface bitmap to be recovered, the application must provide WarmBoot storage.</li>
</ul>
</li>
<li>OAM<ul>
<li>The current implementation does not store the endpoint IDs. The application can learn about the recovered endpoints by querying their attributes using the bcm_oam_endpoint_get API.</li>
</ul>
</li>
<li>MAC-in-MAC<ul>
<li>Unless WarmBoot storage is provided, the SDK cannot distinguish between MiM, Subport and MPLS ports. The application may optionally call SOC_WARM_BOOT_MIM to instruct the SDK to treat all virtual ports as MiM ports and all VPNs as MiM VPNs. The application needs to call the following API to get the list of configured VPNs: <pre class="fragment">     int bcm_mim_vpn_traverse(int unit,
                              bcm_mim_vpn_traverse_cb cb,
                              void *user_data);

     where the following exists:

     typedef int (*bcm_mim_vpn_traverse_cb)(int unit,
                   bcm_mim_vpn_config_t *info,
                   void *user_data);

     For each VPN, the application can call the following API:

     int bcm_mim_port_get_all(int unit,
                              bcm_mim_vpn_t vpn,
                              int port_max,
                              bcm_mim_port_t *port_array,
                              int *port_count);

     For each MiM virtual port, the application can call:

     int bcm_mim_port_get(int unit,
                          bcm_mim_vpn_t vpn,
                          bcm_mim_port_t *mim_port);
</pre></li>
<li><p class="startli">The application can use the following API to discover MAC addresses with destinations being MiM virtual ports and MiM multicast groups. int bcm_l2_traverse(int unit, bcm_l2_traverse_cb trav_fn, void *user_data);</p>
<p class="startli">where the following exists:</p>
<p class="startli">typedef int (*bcm_l2_traverse_cb)(int unit, bcm_l2_addr_t *info, void *user_data);</p>
</li>
</ul>
</li>
<li>MPLS<ul>
<li>Only Layer 3 MPLS functionality can be recovered by reading the HW, the rest is recovered from WarmBoot storage. If MPLS VPNs are to be recovered, the application must provide WarmBoot storage.</li>
</ul>
</li>
<li>WLAN<ul>
<li>State can be recovered from the chip.</li>
</ul>
</li>
<li>QoS<ul>
<li>Unless WarmBoot storage is provided, the recovered map IDs may not match the ones originally used by the application can call the following API to get all configured map IDs. <pre class="fragment">   int bcm_qos_multi_get(int unit,
                         int size,
                         int *map_id_arr,
                         int *flags,
                         int *count)
</pre></li>
<li>For each map ID, the application can call the following API to retrieve the configured mappings. <pre class="fragment">     int bcm_qos_map_multi_get(int unit,
                               uint32 flags,
                               int map_id,
                               int array_size,
                               bcm_qos_map_t *array,
                               int *array_count);
</pre></li>
</ul>
</li>
<li>Subport<ul>
<li>Unless WarmBoot storage is provided, SDK cannot distinguish between MiM, Subport and MPLS ports. The application may optionally call SOC_WARM_BOOT_SUBPORT to instruct the SDK to treat all virtual ports as Subport ports.</li>
<li>The application can call the bcm_subport_port_traverse API to get all subport virtual ports.</li>
</ul>
</li>
<li>IPFIX<ul>
<li>Flow rate meter IDs and flow rate enabled/disabled states require WarmBoot storage.</li>
</ul>
</li>
<li>Stat<ul>
<li>State can be recovered from the chip. If stat overflow flag states are to be recovered, the application must provide WarmBoot storage.</li>
</ul>
</li>
<li>TX<ul>
<li>State can be recovered from the chip.</li>
</ul>
</li>
<li>RX<ul>
<li>State can be recovered from the chip. If queue level PPS, Burst and System level PPS are to be recovered, the application must provide WarmBoot storage</li>
</ul>
</li>
<li>Time<ul>
<li>State can be recovered from the chip. The application needs to re-register callbacks.</li>
</ul>
</li>
<li>Failover<ul>
<li>State can be recovered from the chip.</li>
</ul>
</li>
<li>L2Gre<ul>
<li>WarmBoot storage is required for recovery. This is similar to all virtual port based features.</li>
</ul>
</li>
<li>Port extender<ul>
<li>The SDK cannot distinguish between Port extender, MiM and NIV ports based on HW programmed values. The application must provide WarmBoot storage for recovery of port extender.</li>
</ul>
</li>
<li>Multicast<ul>
<li>Unless WarmBoot storage is provided, the SDK cannot determine the type of the multicast group if it is not attached to an object. If the application fails to provide WarmBoot storage, the SDK will interpret such groups as IPMC groups.</li>
<li>The application can call the bcm_multicast_group_traverse API with the appropriate flags to learn the multicast groups of the corresponding type that it has created.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="wb_for_tx_and_rx_only"></a>
Early CPU Tx and Rx</h1>
<p>In case of ISSU, where tx and rx APIs cannot be called from the beginning of device shutdown, till the end of warmboot, protocol timers may expire, causing them to misbehave. In order to not starve the protocol timers and to allow applications to send and receive packets early in the initialization sequence and even during warm booting, <a class="el" href="group__init.html#ga57908486412f87e6c080f904e347d150" title="Attach only tx and rx modules to a device as a BCM unit.">bcm_attach_early_txrx()</a> and <a class="el" href="group__init.html#ga1bb715d06eaec47e70bfba7759d9cfad" title="Detach all modules excluding tx and rx from BCM unit.">bcm_detach_late_txrx()</a> APIs can be used.</p>
<p><a class="el" href="group__init.html#ga1bb715d06eaec47e70bfba7759d9cfad">bcm_detach_late_txrx()</a> can be used to delay de-initializing the BCM TX and RX components until all the other BCM components are de-initialized. Then customers TX and RX threads have to be shut down after which API bcm_detach must be called as usual to de-initialize BCM TX and RX components and other control structures for a safe shutdown.</p>
<p><a class="el" href="group__init.html#ga57908486412f87e6c080f904e347d150">bcm_attach_early_txrx()</a> can be used to attach the BCM unit and initialize the BCM TX and RX components. Customers, from their application code, can then start transmitting and receiving packets to/from CPU. Regular <a class="el" href="group__init.html#gaa9516e3bbbd4c154caf0bfd4e2938aff" title="Attach a device as a BCM unit.">bcm_attach()</a> API must still be invoked to allow complete and safe re-initialization so BCM APIs can be used for configuring the system.</p>
<p>However, the CPU packet TX and RX procedures are limited by its nature during the warmboot process. In the absence of the required control data, link status and other integrity checks may be exempted during <a class="el" href="tx_8h.html#acb8095f684616768fd83f3c791868fc2" title="Transmit one or more packets.">bcm_tx()</a> when warm booting. Similarly processing of some packet metadata elements and converting the same to standard BCM types may not happen during packet RX.</p>
<h1><a class="anchor" id="wb_replay"></a>
API Replay</h1>
<p>Warm Boot finishes (the SDK has finished re-constructing the software state) at the end of <a class="el" href="group__init.html#ga5048ba1f59aff4302df0e2643bd939ee" title="Initialize the BCM software layer for a device.">bcm_init()</a>. The application does not need to replay APIs and must not replay APIs while warm boot is in progress. When warm boot finishes, the chip is in normal operating mode and API behavior conforms to the regular documented behavior corresponding to the BCM error codes. After warm boot, the application needs to reconstruct its own state to match the hardware provisioning. Since the SDK state is consistent with the hardware provisioning, the application can query the SDK by means of the various "traverse" and "get" calls to help in reconstructing its own state. The application may also issue other API calls to change certain provisioning. The Easy Reload model is not supported in this solution.</p>
<h1><a class="anchor" id="wb_comp"></a>
Compilation</h1>
<p>The compilation flag BCM_WARM_BOOT_SUPPORT enables support for the feature. This is available in the Make.local file as an option. It is not enabled by default.</p>
<h1><a class="anchor" id="wb_boot"></a>
Booting</h1>
<p>The boot sequence details will depend on the particular hardware involved. For Broadcom-based SDK systems, warm boot is signaled with the boot flag BOOT_F_WARM_BOOT.</p>
<p>On the Linux User mode platform, the environment variable SOC_BOOT_FLAGS can be set before running the BCM executable.</p>
<p>Warm boot is signaled to the SoC layer by calling the macro \sc SOC_WARM_BOOT_START(unit)\ec. This signals the SoC layer to disable register and memory writes to the device. After warm boot is completed, the BCM layer is available. No changes to the probe or attach processing are needed.</p>
<h1><a class="anchor" id="wb_upgrade"></a>
Upgrade Support</h1>
<ul>
<li>Upgrades between consecutive minor revision numbers are supported and validated by Broadcom SQA. Examples:<ul>
<li>SDK-6.4.8 to SDK-6.4.9</li>
<li>SDK-6.5.5 to SDK-6.5.6</li>
</ul>
</li>
<li>Upgrades between non-consecutive minor revisions are supported, but not all combinations are tested by Broadcom SQA. Examples:<ul>
<li>SDK-6.4.7 to SDK-6.4.9 (skipped 6.4.8)</li>
<li>SDK-6.5.3 to SDK-6.5.5 (skipped 6.5.4)</li>
</ul>
</li>
<li>Upgrades between major revision numbers are only supported for consequitive major versions. Examples:<ul>
<li>Supported: SDK-6.4.10 to SDK-6.5.6</li>
<li>Not supported: SDK-6.3.9 to SDK-6.5.5 (skipped SDK-6.4.x)</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="wb_downgrade"></a>
Downgrade Support</h1>
<p>By design, SDK revisions should be able to downgrade to SDK 5.9.0 or later versions. Broadcom SQA has tested limited downgrades between consecutive minor revision numbers (e.g. SDK-6.5.9 to SDK-6.5.8) only on BCM56850, BCM56960, and BCM56860 devices.</p>
<p>The main issues to be considered are different storage formats on a per-module basis, API behavioral differences and new features that may have been added in future revisions but were not present in the older revision. Any given SDK version does not have future knowledge, but it must be able to detect a downgrade event and notify the application. The notification is done using the following switch event:</p>
<p>BCM_SWITCH_EVENT_WARM_BOOT_DOWNGRADE</p><ul>
<li>arg1 = BCM API module identifier. See <a class="el" href="fundamentals.html#BCM_MODULES_table">BCM_MODULES_table</a></li>
<li>arg2 = &lt;recovered_version&gt;</li>
<li>arg3 = &lt;current_version&gt;</li>
</ul>
<p>The version number may be different for each API module. The following table gives the version numbers for each module that needs storage as a function of the SDK release. The version numbers have major and minor numbers that can be accessed using the following macros:</p>
<p>SOC_SCACHE_VERSION_MAJOR(v)</p>
<p>SOC_SCACHE_VERSION_MINOR(v)</p>
<p>The following table shows the version numbers as a function of the module in latest SDK release. The format is (major number, minor number). Warmboot versions of some modules are different across chips.<a class="anchor" id="sdk_modules"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>BCM Module Revision Numbers (SDK Release 6.5.9)</caption>
<tr>
<th>ASF </th><th>BFD </th><th>Bregex </th><th>Extender </th><th>Failover </th><th>FCOE </th><th>Field </th><th>Flexflow  </th></tr>
<tr>
<td>(1,8) </td><td>(1,4) </td><td>(1,0) </td><td>(1,0) </td><td>(1,0) </td><td>(1,1) </td><td>(1,22) </td><td>(1,0)  </td></tr>
<tr>
<th>Flex_ctr </th><th>IPFIX </th><th>IPMC </th><th>L2 </th><th>L2GRE </th><th>L3 </th><th>Latency </th><th>Link  </th></tr>
<tr>
<td>(1,6) </td><td>(1,0) </td><td>(1,5) </td><td>(1,1) </td><td>(1,0) </td><td>(1,14) </td><td>(1,8) </td><td>(1,3)  </td></tr>
<tr>
<th>MIM </th><th>Mirror </th><th>MPLS </th><th>Multicast </th><th>Fabric_IPMC </th><th>NIV </th><th>Policer </th><th>Port  </th></tr>
<tr>
<td>(1,1) </td><td>(1,5) </td><td>(1,11) </td><td>(1,1) </td><td>(1,0) </td><td>(1,3) </td><td>(1,2) </td><td>(1,12)  </td></tr>
<tr>
<th>Proxy </th><th>Range </th><th>Rx </th><th>Stack </th><th>Stat </th><th>STG </th><th>Subport </th><th>Time  </th></tr>
<tr>
<td>(1,0) </td><td>(1,0) </td><td>(1,1) </td><td>(1,8) </td><td>(1,6) </td><td>(1,0) </td><td>(1,1) </td><td>(1,0)  </td></tr>
<tr>
<th>TDM </th><th>TRILL </th><th>Trunk </th><th>TSN </th><th>UDF </th><th>Virtual </th><th>VLAN </th><th>VXLAN  </th></tr>
<tr>
<td>(1,0) </td><td>(1,0) </td><td>(1,7) </td><td>(1,0) </td><td>(1,4) </td><td>(1,13) </td><td>(1,1) </td><td>(1,6)  </td></tr>
<tr>
<th>COSQ </th><th>OAM </th><th>Flex_port  </th></tr>
<tr>
<td>- Firebolt, Trident3, Triumph, Triumph2 (1,0)<ul>
<li>Trident (1,1)</li>
<li>Apache (1,2)</li>
<li>Tomahawk (1,4)</li>
<li>Triumph3 (1,5)</li>
<li>Trident2 (1,7)  </li>
</ul>
</td><td>- Triumph2 (1,1)<ul>
<li>Triumph3 (1,4)  </li>
</ul>
</td><td>- Apache, Tomahawk2, Trident3 (1,0)<ul>
<li>Trident2P (1,1)   </li>
</ul>
</td></tr>
</table>
<p>Version numbers for all future SDK releases will be documented here. Also, any potential remedial actions to deal with the impact of version number updates will be documented here. Future SDK revisions may also store the module data in a backward compatible manner if a downgrade is desired. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="footer-brcm-wrapper">
<table class="footer-brcm">
	<tbody><tr>
		<td class="footer-brcm"><img src="BRCM_Red+Black_noTag_RGB.png" align="left"></td>
		<td class="footer-brcm"><small><b>Proprietary and Confidential &copy; 2019 Broadcom</b></small>
			<div class="footer-brcm">Broadcom Incorporated reserves the right to make changes without further notice to any products or data herein to improve reliability, function, or design.
Information furnished by Broadcom Incorporated is believed to be accurate and reliable. However, Broadcom Incorporated does not assume any liability arising
out of the application or use of this information, nor the application or use of any product or circuit described herein, neither does it convey any license
under its patent rights nor the rights of others.
			</div>
		</td>
	</tr>
</tbody></table>
</div>
</body>
</html>
