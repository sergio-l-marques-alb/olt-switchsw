<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDK API Guide: Trunking (Link Aggregation)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_brcm.css" rel="stylesheet" type="text/css"/>
<link href="tabs_brcm.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SDK API Guide
   &#160;<span id="projectnumber">Version 6.5.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Trunking (Link Aggregation) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Trunking (also known as EtherChannel, Port Bundling and Link Aggregation) is a method by which many Ethernet ports can be bundled together to form a trunk. The trunk is regarded as one logical link, and is useful when a high bandwidth and/ or redundancy between switches are required. All ports in a trunk must be configured with the same speed and the transmission mode for each trunk member port must be set to full-duplex.</p>
<p>Trunking can provide a number of valuable features:</p>
<ul>
<li>Incremental bandwidth based on demand.</li>
<li>Link redundancy. In the case of a trunk port failure, the port with the failure is removed from the trunk group.</li>
<li>High-bandwidth load balancing.</li>
</ul>
<p>The macros shown in <a class="el" href="trunk.html#PSC_macros">PSC_macros</a> are designated for specifying the Port Selection Criteria (PSC), that is, how to spread the traffic across the trunk's member ports:</p>
<p><a class="anchor" id="PSC_macros"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Macros for Specifying Port Selection Criteria (PSC)</caption>
<tr>
<th>Macro </th><th>PSC Description  </th></tr>
<tr>
<td>BCM_TRUNK_PSC_SRCMAC </td><td>Spread based on source MAC address  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_DSTMAC </td><td>Spread based on destination MAC address  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_SRCDSTMAC </td><td>Spread based on source and destination MAC address  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_SRCIP </td><td>Spread based on source IP address  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_DSTIP </td><td>Spread based on destination IP address  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_SRCDSTIP </td><td>Spread based on source and destination IP address  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_PORTINDEX </td><td>Port Index  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_PORTFLOW </td><td>Enhanced hashing  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_DYNAMIC </td><td>Dynamic load balancing normal mode: if inactivity duration elapsed, select optimal member, else select currently assigned member.   </td></tr>
<tr>
<td>BCM_TRUNK_PSC_DYNAMIC_ASSIGNED </td><td>Dynamic load balancing assigned mode: always select currently assigned member.   </td></tr>
<tr>
<td>BCM_TRUNK_PSC_DYNAMIC_OPTIMAL </td><td>Dynamic load balancing optimal mode: always select optimal member.   </td></tr>
<tr>
<td>BCM_TRUNK_PSC_DYNAMIC_RESILIENT </td><td>Resilient hashing mode  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_ROUND_ROBIN </td><td>Round robin selection of members.  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_RANDOMIZED </td><td>Random load balancing selection of members.  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_SMOOTH_DIVISION </td><td>Use Smooth Division table for selection of members.  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_VLANINDEX </td><td>Static port selection based on VLAN ID  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_REDUNDANT </td><td>Full redundancy, all member ports (StrataXGS fabric)  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_IPSA </td><td>Hash key includes IP source address*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_IPDA </td><td>Hash key includes IP dest address*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_L4SS </td><td>Hash key includes TCP/UDP source port*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_L4DS </td><td>Hash key includes TCP/UDP dest port*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_IPMACSA </td><td>Hash key includes MAC source address of IP packets*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_IPMACDA </td><td>Hash key includes MAC dest address of IP packets*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_IPTYPE </td><td>Hash key includes EtherType of IP packets*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_IPVID </td><td>Hash key includes VLAN ID of IP packets*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_MACSA </td><td>Hash key includes MAC source address of non-IP packets*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_MACDA </td><td>Hash key includes MAC dest address of non-IP packets*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_TYPE </td><td>Hash key includes EtherType of non-IP packets*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_VID </td><td>Hash key includes VLAN ID of non-IP packets*  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_EGRESS_VID </td><td>Hash key includes Egress VLAN ID *  </td></tr>
<tr>
<td>BCM_TRUNK_PSC_RANDOM </td><td>Hash key includes a random number *  </td></tr>
</table>
<p>OR-able hash key selection, available only on select SoC devices BCM_TRUNK_PSC_RANDOMIZED provides pseudo-random distribution of traffic across trunk member ports. To avoid any traffic Polarization on load-balanced links of Trunk, customer may specify port-specific Randomizer-value to bias the random-member selection of Trunk. This parameter can be specified on a per-port basis using a bcmPortControlTrunkLoadBalancingRandomizer PortControl(See "Port Configuration" in BCM56XXX Network Switching Platform Programmer's Guide).</p>
<p>BCM_TRUNK_PSC_ROUND_ROBIN provides Round Robin Load balancing distribution of traffic across trunk member ports.</p>
<p>The types essential to trunk management functions are listed below. The bcm_trunk_dgm_t type contains per trunk group dynamic group multipath attributes. The bcm_trunk_info_t type contains per trunk group attributes. The bcm_trunk_member_t type contains per trunk member attributes. The bcm_trunk_chip_info_t type contains per device trunk attributes.</p>
<p><a class="anchor" id="bcm_trunk_dgm_t"></a></p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__trunk__dgm__s.html">bcm_trunk_dgm_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__trunk__dgm__s.html#afce1830df0e3bf5b961af5d0b351c6d3">threshold</a>;   <span class="comment">/* Indicates the primary path is always selected when</span></div><div class="line"><span class="comment">                           primary optimal quality band is above this threshold. */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__trunk__dgm__s.html#a470d3452deebaa0e77c2683c4a3a019a">cost</a>;        <span class="comment">/* Indicates the quality band cost of switching over to</span></div><div class="line"><span class="comment">                           alternate path. */</span></div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__trunk__dgm__s.html#a0d9566bdf30afb9143b2696cd16ab628">bias</a>;        <span class="comment">/* Indicates the quality band bias in favor of alternate</span></div><div class="line"><span class="comment">                           path. */</span></div><div class="line">} <a class="code" href="group__trunk.html#gaaaf2795bbe499abd8203378a7b9350ad">bcm_trunk_dgm_t</a>;</div></div><!-- fragment --><p><a class="anchor" id="bcm_trunk_info_t"></a></p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__trunk__info__s.html">bcm_trunk_info_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__trunk__info__s.html#a81a27ce50e78368b0d0de1e8767fd32d">flags</a>;                       <span class="comment">/* BCM_TRUNK_FLAG_xxx. */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__info__s.html#ac3fbb7296da780b1b464417dc351a31a">psc</a>;                            <span class="comment">/* Port selection criteria. */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__info__s.html#afac2b2b5eb30aa5665282f44a9896f4b">ipmc_psc</a>;                       <span class="comment">/* Port selection criteria for software</span></div><div class="line"><span class="comment">                                           IPMC trunk resolution. */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__info__s.html#a167eba6ee939e6ec52923b6f7d963855">dlf_index</a>;                      <span class="comment">/* DLF/broadcast port for front-panel trunk group. */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__info__s.html#a193096867aa60907280a9b2513bfd05b">mc_index</a>;                       <span class="comment">/* Multicast port for front-panel trunk group. */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__info__s.html#a81443a56dd1e081378aaf64f5b42df6f">ipmc_index</a>;                     <span class="comment">/* IPMC port for front-panel trunk group. */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__info__s.html#ac739bd85dd92d73012c0067db4512b81">dynamic_size</a>;                   <span class="comment">/* Number of flows for dynamic load</span></div><div class="line"><span class="comment">                                           balancing (DLB) or resilient hashing (RH).</span></div><div class="line"><span class="comment">                                           Valid DLB values are 512, 1k, doubling up to 32k.</span></div><div class="line"><span class="comment">                                           Valid RH values are 64, 128, doubling up to 64k. */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__info__s.html#af05b19e7be31474b2f82f4b5ea31c361">dynamic_age</a>;                    <span class="comment">/* Inactivity duration, in microseconds. */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__info__s.html#a7ac8d5f3e6371649bc7abf59508e1f47">dynamic_load_exponent</a>;          <span class="comment">/* The exponent used in the exponentially</span></div><div class="line"><span class="comment">                                           weighted moving average calculation of</span></div><div class="line"><span class="comment">                                           historical member load. */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__info__s.html#a4904c0a0587ee9195c5c5c518a686018">dynamic_expected_load_exponent</a>; <span class="comment">/* The exponent used in the exponentially</span></div><div class="line"><span class="comment">                                           weighted moving average calculation of</span></div><div class="line"><span class="comment">                                           historical expected member load. */</span></div><div class="line">    <a class="code" href="group__types.html#ga44e843a8661c84851ab7e32e229bb8f5">bcm_trunk_t</a> <a class="code" href="structbcm__trunk__info__s.html#a4eaa88caf6b06677a0778534fd56b1c2">master_tid</a>;             <span class="comment">/* Master trunk id. */</span></div><div class="line">    <a class="code" href="structbcm__trunk__dgm__s.html">bcm_trunk_dgm_t</a> <a class="code" href="structbcm__trunk__info__s.html#a9560bbb9f0a432690dd179661b75cde5">dgm</a>;                <span class="comment">/* DGM properties */</span></div><div class="line">} <a class="code" href="group__trunk.html#gac82ceb76c98b3280eb962495880b3b0d">bcm_trunk_info_t</a>;</div></div><!-- fragment --><p><a class="anchor" id="bcm_trunk_member_t"></a></p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__trunk__member__s.html">bcm_trunk_member_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="code" href="structbcm__trunk__member__s.html#a81a27ce50e78368b0d0de1e8767fd32d">flags</a>;                       <span class="comment">/* BCM_TRUNK_MEMBER_xxx */</span></div><div class="line">    <a class="code" href="group__types.html#gac5f933aaac05c65b2a78ad8a04316994">bcm_gport_t</a> <a class="code" href="structbcm__trunk__member__s.html#a5bbb92b9248c9ea595e205dd48adefd8">gport</a>;                  <span class="comment">/* Trunk member GPORT ID */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__member__s.html#ad5491bc091bb9ea98350f291830044fb">dynamic_scaling_factor</a>;         <span class="comment">/* Dynamic load balancing threshold</span></div><div class="line"><span class="comment">                                           scaling factor. Typically 1. */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__member__s.html#a2990c3b477617bff9c3b25868f8522f7">dynamic_load_weight</a>;            <span class="comment">/* Relative weight of historical load</span></div><div class="line"><span class="comment">                                           in determining member quality.</span></div><div class="line"><span class="comment">                                           Specified in percentage. */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__member__s.html#a339f23a4d6b8a157a434c3c44046de10">dynamic_queue_size_weight</a>;      <span class="comment">/* Relative weight of queue size</span></div><div class="line"><span class="comment">                                           in determining member quality.</span></div><div class="line"><span class="comment">                                           Specified in percentage. */</span></div><div class="line">} <a class="code" href="group__trunk.html#ga588d29ee63baadb361a103e8342691b3">bcm_trunk_member_t</a>;</div></div><!-- fragment --><p><a class="anchor" id="bcm_trunk_chip_info_t"></a></p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__trunk__chip__info__s.html">bcm_trunk_chip_info_s</a> {</div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__chip__info__s.html#a2f969605907429a357b260077d8b02f9">trunk_group_count</a>;  <span class="comment">/* Total # (front panel) trunk groups */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__chip__info__s.html#a79bcc8550908360858dcf0d960494aa0">trunk_id_min</a>;           <span class="comment">/* Minimum (front panel) trunk ID number */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__chip__info__s.html#a36fd14c3658da229cc9751d91d4bf495">trunk_id_max</a>;           <span class="comment">/* Maximum (front panel) trunk ID number */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__chip__info__s.html#a71486ed287623ec1011a50580784c8e5">trunk_ports_max</a>;    <span class="comment">/* Max ports per (front panel) trunk group */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__chip__info__s.html#a87d7119d87a478dd03fbf213dbfe3f5e">trunk_fabric_id_min</a>;    <span class="comment">/* Minimum fabric trunk ID number */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__chip__info__s.html#a25e89e4ecba4544cdff15978a946b076">trunk_fabric_id_max</a>;    <span class="comment">/* Maximum fabric trunk ID number */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__chip__info__s.html#a19564fb2b0e1e1d918a9b5dcdfdbfea6">trunk_fabric_ports_max</a>; <span class="comment">/* Max ports per fabric trunk group */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__chip__info__s.html#acae9e26df46426f248b7e42589331e35">vp_id_min</a>;          <span class="comment">/* Minimum virtual port trunk ID number */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__chip__info__s.html#a892d73ab3a85b2f75a79917d76aa522d">vp_id_max</a>;          <span class="comment">/* Maximum virtual port trunk ID number */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__chip__info__s.html#acd56fc284b09da40a51fce66cc5293c7">vp_ports_max</a>;           <span class="comment">/* Max virtual ports per trunk group */</span></div><div class="line">} <a class="code" href="group__trunk.html#ga91e05540e4548e1d269a9448675bb2f6">bcm_trunk_chip_info_t</a>;</div></div><!-- fragment --><p><a class="anchor" id="bcm_trunk_resilient_entry_t"></a></p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__trunk__resilient__entry__s.html">bcm_trunk_resilient_entry_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#aa3ad64cf41ec3a042bd92550cc6ed308">uint64</a> <a class="code" href="structbcm__trunk__resilient__entry__s.html#af075475138f187eb87af1cf0afdae35b">hash_key</a>;          <span class="comment">/* Hash key. */</span></div><div class="line">    <a class="code" href="group__types.html#ga44e843a8661c84851ab7e32e229bb8f5">bcm_trunk_t</a> <a class="code" href="structbcm__trunk__resilient__entry__s.html#ad30c49c0464c762f4b49e961c29905d2">tid</a>; <span class="comment">/* Trunk */</span></div><div class="line">   <a class="code" href="structbcm__trunk__member__s.html">bcm_trunk_member_t</a> *<a class="code" href="structbcm__trunk__resilient__entry__s.html#af9118cc6a036920de2f8412924deeff7">member</a>;  <span class="comment">/* Trunk member */</span></div><div class="line">} <a class="code" href="group__trunk.html#ga0e1b99712273065bb90df93f87fc93b9">bcm_trunk_resilient_entry_t</a>;</div></div><!-- fragment --><p>The dlf_index, mc_index and ipmc_index used in bcm_trunk_info_t should be set to identical value. If this is set to BCM_TRUNK_UNSPEC_INDEX, then the API will select the ports in the front-panel trunk group eligible for forwarding Non-unicast traffic. <a class="el" href="group__switch.html#bcm_switch_control_port_set">bcm_switch_control_port_set</a> (bcmSwitchModuleType) may be used to provide supporting information to permit selection of more than one port in the trunk group eligible for forwarding Non-Unicast traffic. This is useful on StrataXGS III devices to load share Non-Unicast traffic using a set of ports in the trunk group.</p>
<p>The trunk management function prototypes can be found in &lt;<a class="el" href="trunk_8h.html">bcm/trunk.h</a>&gt;.</p>
<p>On some devices, each port in a trunk may be assigned a set of ports to which the traffic should be redirected in case the port's link goes down, a capability termed "failover". This port list may be provided explicitly in <a class="el" href="group__trunk.html#bcm_trunk_failover_set">bcm_trunk_failover_set</a>, or implicitly with the BCM_TRUNK_FLAG_FAILOVER_XXX flags.</p>
<p>If the BCM_TRUNK_FLAG_FAILOVER_XXX flags of the bcm_trunk_info_t structure passed to <a class="el" href="group__trunk.html#bcm_trunk_set">bcm_trunk_set</a> are zeroes, then the failover configuration of the trunk ports will not be updated except for clearing the failover configuration of any ports removed from the trunk. New ports will not be configured, and existing ports will not be updated. This may leave one or more existing ports with failover port lists including ports which have now been removed from the trunk. This behavior allows trunk membership to change without clearing the any custom failover configuration due to <a class="el" href="group__trunk.html#bcm_trunk_failover_set">bcm_trunk_failover_set</a> . If you are not using custom failover configuration, then retain the same flags argument as when the trunk was initially populated.</p>
<p>For non-fabric trunks, when a port configured for failover experiences a link failure, the port will transition to BCM_PORT_LINK_STATUS_FAILED state (see <a class="el" href="group__port.html#BCM_PORT_LINK_STATUS_m">BCM_PORT_LINK_STATUS_m</a> ). The port must be removed from the trunk, then <a class="el" href="group__port.html#bcm_port_link_failed_clear">bcm_port_link_failed_clear</a> called to allow the port state to recover. Only after the link has returned to BCM_PORT_LINK_STATUS_UP can the port be added back to the trunk. This restriction is required to allow the HW failover mechanism to reset.</p>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>BCM Trunk Flags</caption>
<tr>
<th>Name </th><th>Purpose  </th></tr>
<tr>
<td>BCM_TRUNK_FLAG_FAILOVER_NEXT </td><td>Failover port defaults to the next port in the trunk port list  </td></tr>
<tr>
<td>BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL </td><td>Failover port defaults to the next local port in the trunk port list, if any.  </td></tr>
<tr>
<td>BCM_TRUNK_FLAG_FAILOVER_ALL </td><td>Failover ports default to all other ports in this trunk.  </td></tr>
<tr>
<td>BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL </td><td>Failover ports default to all other local ports in this trunk.  </td></tr>
<tr>
<td>BCM_TRUNK_FLAG_FAILOVER </td><td>Enable trunk failover support (deprecated). Equivalent to BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL.  </td></tr>
<tr>
<td>BCM_TRUNK_FLAG_WITH_ID </td><td>Use the trunk ID supplied by the user.  </td></tr>
<tr>
<td>BCM_TRUNK_FLAG_IPMC_CLEAVE </td><td>If set, trunk resolution for IPMC packets is disabled in hardware.  </td></tr>
<tr>
<td>BCM_TRUNK_FLAG_DYNAMIC_LOAD_DECREASE_RESET </td><td>If set, historical member load is reset to the instantaneous member load value if the latter is smaller.  </td></tr>
<tr>
<td>BCM_TRUNK_FLAG_DYNAMIC_EXPECTED_LOAD_DECREASE_RESET </td><td>If set, historical expected member load is reset to the instantaneous member load value if the latter is smaller.  </td></tr>
<tr>
<td>BCM_TRUNK_FLAG_VP </td><td>If set, create a virtual port trunk group.  </td></tr>
<tr>
<td>BCM_TRUNK_FLAG_MEMBER_SORT </td><td>If set, set or add trunk members to hardware in the sorted way.  </td></tr>
<tr>
<td>BCM_TRUNK_FLAG_WEIGHTED </td><td>If set, indicates it is a weighted group and only with BCM_TRUNK_FLAG_VP when creating a VP trunk group. The members count value must be in powers-of-2.  </td></tr>
</table>
<p>In some implementations, it is desirable to use Trunk Member Flags to control the Trunk Collection and Distribution states. This can be used in conjunction with the Marker protocol</p>
<p>Marker PDUs are just normal Slow protocol PDUs that are transmitted and received on physical links (that is, over trunk members, not over trunks). There is no requirement that marker PDUs be prioritized behind or in front of any non-marker traffic on a link.</p>
<p>A typical implementation using the bcm APIs would use bcm_tx and bcm_rx to send and receive marker PDUs on an the ports of interest.</p>
<p>As described in Annex 43A.3 of 802.3-2005, moving conversations to a new port can be accomplished using the collector and distributor disables and the marker PDUs.</p>
<p>Adding a Port</p>
<p>If a trunk member is being added to a trunk, then the member should be added using bcm_trunk_set with the new port added to the end of the existing members in the member_array. Given the hashed implementation of the distributor algorithms, when the new member is enabled for egress, all conversations on the trunk could be moved, so all members of the trunk should have their flags fields set to BCM_TRUNK_MEMBER_EGRESS_DROP.</p>
<p>After waiting a suitable amount of time for any queued packets to be transmitted, send a Marker PDU over the new port. Wait for the Marker Response PDU to be received. If no PDU is received within some timeout, then continue.</p>
<p>Call bcm_trunk_set with all of the members' flags fields set to 0. Conversations continue.</p>
<p>Deleting a port</p>
<p>This scenario is much the same as the above with bcm_trunk_set called with all members' flags fields set to BCM_TRUNK_MEMBER_EGRESS_DROP.</p>
<p>After the Marker Response PDU is received or timer expires, bcm_trunk_set is called with the deleted port no longer in the member list. All other members have their flags fields set to 0.</p>
<p>The implementation used in the underlying hardware (whether Broadcom XGS or Broadcom XCore) causes the traffic distributed to members using EGRESS_DROP to be dropped rather than being held in a queue. Any traffic sent to the trunk while the marker protocol is active (from waiting for the initial traffic to be received until after the Marker Response PDU is received) will be dropped.</p>
<p>On some devices, Trunk Member Flags shown in <a class="el" href="trunk.html#BCM_Trunk_Member_Flags">BCM_Trunk_Member_Flags</a> are supported. <a class="anchor" id="BCM_Trunk_Member_Flags"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>BCM Trunk Member Flags</caption>
<tr>
<th>Name </th><th>Purpose  </th></tr>
<tr>
<td>BCM_TRUNK_MEMBER_INGRESS_DISABLE </td><td>Member will not receive traffic.  </td></tr>
<tr>
<td>BCM_TRUNK_MEMBER_EGRESS_DISABLE </td><td>Member will not be a part of the distributor members to be hashed.  </td></tr>
<tr>
<td>BCM_TRUNK_MEMBER_EGRESS_DROP </td><td>Member is part of the distributor hash but any traffic hashed to this member will be dropped.  </td></tr>
<tr>
<td>BCM_TRUNK_MEMBER_UNICAST_EGRESS_DISABLE </td><td>Member will not be a part of the distributor members to be hashed for unicast packets.  </td></tr>
<tr>
<td>BCM_TRUNK_MEMBER_IPMC_EGRESS_DISABLE </td><td>Member will not be a part of the distributor members to be hashed for IPMC packets.  </td></tr>
<tr>
<td>BCM_TRUNK_MEMBER_L2MC_EGRESS_DISABLE </td><td>Member will not be a part of the distributor members to be hashed for L2MC packets.  </td></tr>
<tr>
<td>BCM_TRUNK_MEMBER_BCAST_EGRESS_DISABLE </td><td>Member will not be a part of the distributor members to be hashed for broadcast packets.  </td></tr>
<tr>
<td>BCM_TRUNK_MEMBER_DLF_EGRESS_DISABLE </td><td>Member will not be a part of the distributor members to be hashed for packets that failed MAC-DA lookup.  </td></tr>
<tr>
<td>BCM_TRUNK_MEMBER_DGM_ALTERNATE </td><td>If set indicating TRUNK member is within alternate path, else within primary path.  </td></tr>
</table>
<p>Some devices support dynamic load balancing. To enable this feature, the psc in bcm_trunk_info_t should be set to one of the BCM_TRUNK_PSC_DYNAMIC_XXX values. The number of flows allocated to a trunk group for dynamic load balancing is specified by dynamic_size. Its valid values are 512, 1024, 2048, doubling up to 32768. The inactivity duration, after which a flow can be reassigned to another member of the trunk group, is specified by dynamic_age. The thresholds used in dynamic load balancing are specified via switch controls bcmSwitchTrunkDynamic* for front-panel trunks and bcmSwitchFabricTrunkDynamic* for fabric trunks. On a per trunk member basis, the thresholds can be scaled via the dynamic_scaling_factor field in bcm_trunk_member_t. <a class="anchor" id="BCM_TRUNK_STACKING_TID"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Stacking Trunk ID (Applicable to: DNX architecture.)</caption>
<tr>
<th>Macro/Define </th><th>Description  </th></tr>
<tr>
<td>BCM_TRUNK_STACKING_TID_BIT </td><td>Bit offset (16) which indicate the Trunk ID is Stacking trunk.  </td></tr>
<tr>
<td>BCM_TRUNK_STACKING_TID_SET(tid, peer_tmd) </td><td>Mark the tid as Stacking trunk according to the Stacking Trunk Peer TM-Domain.  </td></tr>
<tr>
<td>BCM_TRUNK_STACKING_TID_GET(tid) </td><td>Return the tid from Stacking trunk.  </td></tr>
</table>
<ul>
<li>The following defines user-supplied callback functions for the resilient Trunk table traversal.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> int (*<a class="code" href="group__trunk.html#ga10996c2f565b966e04eccfcd851ec600">bcm_trunk_resilient_traverse_cb</a>)(<span class="keywordtype">int</span> unit, <a class="code" href="structbcm__trunk__resilient__entry__s.html">bcm_trunk_resilient_entry_t</a> *<a class="code" href="l3_8dox.html#a53fec9518cfb2f8ebe1ff580a275a7c5">entry</a>, <span class="keywordtype">void</span> *<a class="code" href="l3_8dox.html#afc6e325b3b8c838e0a205aa5c1ec69bd">user_data</a>);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="group__trunk.html#gaded32b57d11c26ef0215c959d15523fd" title="Initialize the trunk module and SoC trunk hardware.">bcm_trunk_init(int unit)</a>  </td><td>Initialize the trunk module and SoC trunk hardware.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gaa9eff7575a9719564138b4c878d2e918" title="Shut down (uninitialize) the trunk module.">bcm_trunk_detach(int unit)</a>  </td><td>Shut down (uninitialize) the trunk module.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gaef9fdf128b434af3f0d4d07e2b5fb36d" title="Create the software data structure for a new trunk, using caller-specified or next available trunk ID...">bcm_trunk_create(int unit, uint32 flags, bcm_trunk_t* tid)</a>  </td><td>Create the software data structure for a new trunk, using caller-specified or next available trunk ID.   </td></tr>
<tr>
<td>bcm_trunk_vplag_create()  </td><td>Create virtual port trunk group with user provided VPLAG Port Id.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga54b97664c4bf7f49d71e4bb43d0fe9ee" title="Set a trunk&#39;s Port Selection Criteria (PSC).">bcm_trunk_psc_set(int unit, bcm_trunk_t tid, int psc)</a>  </td><td>Set a trunk's Port Selection Criteria (PSC).   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga2e50dd77e4b5f0616c8bc50273b5db19" title="Get a trunk&#39;s Port Selection Criteria (PSC).">bcm_trunk_psc_get(int unit, bcm_trunk_t tid, int* psc)</a>  </td><td>Get a trunk's Port Selection Criteria (PSC).   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gac87b8cd5a1196674e399eddfeb4bbe7b" title="Initialize a trunk chip information structure.">bcm_trunk_chip_info_t_init(bcm_trunk_chip_info_t* trunk_chip_info)</a>  </td><td>Initialize a trunk chip information structure.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga2cbcc96911ea6811c13174b8f94fde44" title="Gets the underlying SoC device&#39;s trunk support limits.">bcm_trunk_chip_info_get(int unit, bcm_trunk_chip_info_t* ta_info)</a>  </td><td>Gets the underlying SoC device's trunk support limits.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga2210208186212b95faa9c566b07a3a0a" title="Initializes the bcm_trunk_info_t structure.">bcm_trunk_info_t_init(bcm_trunk_info_t* trunk_info)</a>  </td><td>Initializes the bcm_trunk_info_t structure   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gac569e369044843c12136d40a64e876cb" title="Initializes the bcm_trunk_member_t structure.">bcm_trunk_member_t_init(bcm_trunk_member_t* trunk_member)</a>  </td><td>Initializes the bcm_trunk_member_t structure   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga0f565f5dad975b2fe9368de4d13045de" title="Specify the ports in a trunk group.">bcm_trunk_set(int unit, bcm_trunk_t tid, bcm_trunk_info_t* trunk_info, int member_count, bcm_trunk_member_t* member_array)</a>  </td><td>Specify the ports in a trunk group.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga3273aba03ce16099cb58f99182027ca4" title="Removes a trunk group.">bcm_trunk_destroy(int unit, bcm_trunk_t tid)</a>  </td><td>Removes a trunk group.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gac91144cf95b024122410f08a46387baa" title="Get the current attributes and member ports for the specified trunk group.">bcm_trunk_get(int unit, bcm_trunk_t tid, bcm_trunk_info_t* t_data, int member_max, bcm_trunk_member_t* member_array, int* member_count)</a>  </td><td>Get the current attributes and member ports for the specified trunk group.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga88a4fbd09efc40045f17eeab558f9f2f" title="Get VPLAG port Id for vitual port trunk group.">bcm_trunk_vplag_get(int unit, bcm_trunk_t tid, bcm_gport_t* vplag_port_id)</a>  </td><td>Get VPLAG port Id for vitual port trunk group.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga22795a06c69c58bccd1a6dc5ca69b061" title="Expand a port bitmap to include all associated trunk member ports.">bcm_trunk_bitmap_expand(int unit, bcm_pbmp_t* pbmp_ptr)</a>  </td><td>Expand a port bitmap to include all associated trunk member ports.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gac21a485e17b813d4d5cccf3341063bbb" title="Add the specified trunk group to an existing MAC multicast entry.">bcm_trunk_mcast_join(int unit, bcm_trunk_t tid, bcm_vlan_t vid, bcm_mac_t mac)</a>  </td><td>Add the specified trunk group to an existing MAC multicast entry.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gaf8a17d278b84cabea7a2273b80b00e61" title="Restricts switching only to specified ports from the given trunk.">bcm_trunk_egress_set(int unit, bcm_trunk_t tid, bcm_pbmp_t pbmp)</a>  </td><td>Restricts switching only to specified ports from the given trunk.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gade0d039461f4e9364d14478e1c52c6f7" title="Retrieve the current bitmap of ports for which switching is enabled from the given trunk.">bcm_trunk_egress_get(int unit, bcm_trunk_t tid, bcm_pbmp_t* pbmp)</a>  </td><td>Retrieve the current bitmap of ports for which switching is enabled from the given trunk.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gad53aa02302197d2aa15fed7cc2913adf" title="Configure the override mode of trunk hashing for unicast packets.">bcm_trunk_override_ucast_set(int unit, bcm_port_t port, bcm_trunk_t tid, int modid, int enable)</a>  </td><td>Configure the override mode of trunk hashing for unicast packets.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gabc88eb324b609d0197fbd49a2a21c817" title="Retrieve the current state of trunk hashing override for unicast packets.">bcm_trunk_override_ucast_get(int unit, bcm_port_t port, bcm_trunk_t tid, int modid, int* enable)</a>  </td><td>Retrieve the current state of trunk hashing override for unicast packets.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gae26b38264979ed59eee0484fcbd71f5c" title="Configure the overriding of trunk hashing for multicast packets.">bcm_trunk_override_mcast_set(int unit, bcm_port_t port, bcm_trunk_t tid, int idx, int enable)</a>  </td><td>Configure the overriding of trunk hashing for multicast packets.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga9becdd97bde692278ff80d687ed10868" title="Retrieve the current state of trunk hashing override for multicast packets.">bcm_trunk_override_mcast_get(int unit, bcm_port_t port, bcm_trunk_t tid, int idx, int* enable)</a>  </td><td>Retrieve the current state of trunk hashing override for multicast packets.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga236eddccccbfb0d838b5ef1919b8d5cb" title="Configure the overriding of trunk hashing for IPMC packets.">bcm_trunk_override_ipmc_set(int unit, bcm_port_t port, bcm_trunk_t tid, int idx, int enable)</a>  </td><td>Configure the overriding of trunk hashing for IPMC packets.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga64b60b142a845ca69061b1f08962270a" title="Retrieve the current state of trunk hashing override for IPMC packets.">bcm_trunk_override_ipmc_get(int unit, bcm_port_t port, bcm_trunk_t tid, int idx, int* enable)</a>  </td><td>Retrieve the current state of trunk hashing override for IPMC packets.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gab201233ae3ad5fb61395d46cd6c3acd9" title="Configure the overriding of trunk hashing for broadcast or unknown unicast packets.">bcm_trunk_override_vlan_set(int unit, bcm_port_t port, bcm_trunk_t tid, bcm_vlan_t vid, int enable)</a>  </td><td>Configure the overriding of trunk hashing for broadcast or unknown unicast packets.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gab3a048eb2b9bace476d92857931663fc" title="Retrieve the current state of trunk hashing override for broadcast or unknown unicast packets.">bcm_trunk_override_vlan_get(int unit, bcm_port_t port, bcm_trunk_t tid, bcm_vlan_t vid, int* enable)</a>  </td><td>Retrieve the current state of trunk hashing override for broadcast or unknown unicast packets.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga52b6205c619887c542e937e6b086da59" title="Configure the override mode of trunk hashing for non-unicast packets.">bcm_trunk_override_non_ucast_set(int unit, bcm_trunk_t tid, int enable)</a>  </td><td>Configure the override mode of trunk hashing for non-unicast packets.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga40bd92c903d63ab957e11ddc54b651b6" title="Retrieve the current state of trunk hashing override for non-unicast packets.">bcm_trunk_override_non_ucast_get(int unit, bcm_trunk_t tid, int* enable)</a>  </td><td>Retrieve the current state of trunk hashing override for non-unicast packets.   </td></tr>
<tr>
<td>bcm_trunk_pool_set(int unit, bcm_port_t port, bcm_trunk_t tid, int size, constint weights[BCM_TRUNK_MAX_PORTCNT])  </td><td>Configure the weighted trunk hashing table.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga8510546c420091810f88d48f3fcfd9a5" title="Retrieve the current weighted trunk hashing table.">bcm_trunk_pool_get(int unit, bcm_port_t port, bcm_trunk_t tid, int* size, int weights[BCM_TRUNK_MAX_PORTCNT])</a>  </td><td>Retrieve the current weighted trunk hashing table.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga1897a945532b9d3e191a2f2c282738f3" title="Get the trunk group ID for a given system port, specified by Module ID and Port number.">bcm_trunk_find(int unit, bcm_module_t modid, bcm_gport_t gport, bcm_trunk_t* tid)</a>  </td><td>Get the trunk group ID for a given system port, specified by Module ID and Port number   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga18d88fb48d626b77094c2f1be90c0f09" title="Assign the failover port list for a specific trunk port.">bcm_trunk_failover_set(int unit, bcm_trunk_t tid, bcm_gport_t failport, int psc, uint32 flags, int count, bcm_gport_t* fail_to_array)</a>  </td><td>Assign the failover port list for a specific trunk port.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga41e6698245b925d42f9a9cb663f63c0f" title="Retrieve the failover port list for a specific trunk port.">bcm_trunk_failover_get(int unit, bcm_trunk_t tid, bcm_gport_t failport, int* psc, uint32* flags, int array_size, bcm_gport_t* fail_to_array, int* array_count)</a>  </td><td>Retrieve the failover port list for a specific trunk port.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gaa222c2acf5d6a1e05080f97056b5b7a9" title="Add a member to a trunk group.">bcm_trunk_member_add(int unit, bcm_trunk_t tid, bcm_trunk_member_t* member)</a>  </td><td>Add a member to a trunk group.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gae6d6274e043e0fd9511887b0c29cdf0e" title="Delete a member from a trunk group.">bcm_trunk_member_delete(int unit, bcm_trunk_t tid, bcm_trunk_member_t* member)</a>  </td><td>Delete a member from a trunk group.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gada652a7d373f6bb951a965eb1c53372d" title="Delete all members from a trunk group.">bcm_trunk_member_delete_all(int unit, bcm_trunk_t tid)</a>  </td><td>Delete all members from a trunk group.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga6a88adca53b040d12fcf3bfcb8aff2d0" title="Set trunk member dynamic load balancing (DLB) link status.">bcm_trunk_member_status_set(int unit, bcm_gport_t member, int status)</a>  </td><td>Set trunk member dynamic load balancing (DLB) link status.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga758008cd4aaa2d9aef3007676038c967" title="Get trunk member dynamic load balancing (DLB) link status.">bcm_trunk_member_status_get(int unit, bcm_gport_t member, int* status)</a>  </td><td>Get trunk member dynamic load balancing (DLB) link status.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gace3d0941ed7e4269f863bc28e14460de" title="Set EtherType eligibility for dynamic load balancing or resilient hashing.">bcm_trunk_ethertype_set(int unit, uint32 flags, int ethertype_count, int* ethertype_array)</a>  </td><td>Set EtherType eligibility for dynamic load balancing or resilient hashing.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga6984ffd706653b89aaffb154fe3724a0" title="Traverse through the resilient trunk table and run callback at each valid entry. Possible replacement...">bcm_trunk_resilient_traverse(int unit, uint32 flags, bcm_trunk_resilient_entry_t* match_entry, bcm_trunk_resilient_traverse_cb trav_fn, void* user_data)</a>  </td><td>Traverse through the resilient trunk table and run callback at each valid entry. Possible replacement of the matched entries.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gade5811b5683db9f484a744e0cfafe81b" title="Replace Trunk resilient entries matching given criteria.">bcm_trunk_resilient_replace(int unit, uint32 flags, bcm_trunk_resilient_entry_t* match_entry, int* num_entries, bcm_trunk_resilient_entry_t* replace_entry)</a>  </td><td>Replace Trunk resilient entries matching given criteria.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga55c85faf32c54a0a7dd57ec5f5a00960" title="Get EtherType eligibility for dynamic load balancing or resilient hashing.">bcm_trunk_ethertype_get(int unit, uint32* flags, int ethertype_max, int* ethertype_array, int* ethertype_count)</a>  </td><td>Get EtherType eligibility for dynamic load balancing or resilient hashing.   </td></tr>
</table>
<h1><a class="anchor" id="trunk_agm"></a>
AGM APIs for (Fabric) Trunk group.</h1>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="group__trunk.html#gabc1ccba2e01c7d0ba60fe4cc6ee99cfc" title="Attach already created monitor entry to a trunk or a fabric trunk.">bcm_trunk_agm_attach(int unit, bcm_trunk_t trunk_id, bcm_switch_agm_id_t agm_id)</a>  </td><td>Attach already created monitor entry to a trunk or a fabric trunk.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga30270422f15e62532e56447fae17c71b" title="Detach a monitor entry from a trunk or a fabric trunk.">bcm_trunk_agm_detach(int unit, bcm_trunk_t trunk_id, bcm_switch_agm_id_t agm_id)</a>  </td><td>Detach a monitor entry from a trunk or a fabric trunk   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gac44b58532cd73aadcc14fec57c3e0a77" title="Retrieve a monitor id attached to a (fabric) trunk.">bcm_trunk_agm_attach_get(int unit, bcm_trunk_t trunk_id, bcm_switch_agm_id_t* agm_id)</a>  </td><td>Retrieve a monitor id attached to a (fabric) trunk.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga612316db14c63f510b6ee75cb615975b" title="map a system port aggregate (SPA) to its corresponding system physical port.">bcm_trunk_spa_to_system_phys_port_map_get(int unit, uint32 flags, uint32 system_port_aggregate, bcm_gport_t* gport)</a>  </td><td>map a system port aggregate (SPA) to its corresponding system physical port.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga448bfb44bbf5eef1fdcd57fb0154fdf1" title="Add a GPORT ID for the specified trunk.">bcm_trunk_gport_add(int unit, bcm_trunk_t tid, bcm_gport_t gport)</a>  </td><td>Add a GPORT ID for the specified trunk.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga94f0c255365fbc72c2333cb774d13b41" title="Get all the GPORT ID for the specified trunk.">bcm_trunk_gport_get_all(int unit, bcm_trunk_t tid, int gport_size, bcm_gport_t* gport_array, int* count)</a>  </td><td>Get all the GPORT ID for the specified trunk.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga730a61edc5681396e360782a5c855191" title="Delete the GPORT ID for the specified trunk.">bcm_trunk_gport_delete(int unit, bcm_trunk_t tid, bcm_gport_t gport)</a>  </td><td>Delete the GPORT ID for the specified trunk.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga82d3dc3a55b567705cfa41a6186ba3aa" title="Delete all the GPORT ID for the specified trunk.">bcm_trunk_gport_delete_all(int unit, bcm_trunk_t tid)</a>  </td><td>Delete all the GPORT ID for the specified trunk.   </td></tr>
<tr>
<td>bcm_trunk_id_set()  </td><td>API used to set trunk_ID according to trunk ID info   </td></tr>
<tr>
<td>bcm_trunk_local_attributes_set()  </td><td>API used to set trunk's local attributes   </td></tr>
<tr>
<td>bcm_trunk_local_attributes_get()  </td><td>API used to get trunk's local attributes   </td></tr>
</table>
<h1><a class="anchor" id="trunk_dlb"></a>
FlowStatistic</h1>
<p>DLB Flow Statistics feature has been introduced for BCM56880 devices.</p>
<p>The type bcm_trunk_dlb_stat_t is used to define the counting source (type) of trunk DLB counter engine.</p>
<p><a class="anchor" id="bcm_trunk_dlb_stat_t"></a><a class="anchor" id="trunk_dlb_statistic_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Trunk DLB statistic Types</caption>
<tr>
<th>Name </th><th>Purpose  </th></tr>
<tr>
<td>bcmTrunkDlbStatFailPackets </td><td>Number of packets whose trunk member can't be resolved through the DLB mechanism. Packet forwarding will be based on static trunk resolution when DLB fails.  </td></tr>
<tr>
<td>bcmTrunkDlbStatPortReassignmentCount </td><td>Total aggregate port member reassignments counter.  </td></tr>
<tr>
<td>bcmTrunkDlbStatCount </td><td>Always last; not a usable statistic value  </td></tr>
</table>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga01e2d2616e2dac4081ea09124d1f2540" title="Set the DLB statistic based on the trunk Id.">bcm_trunk_dlb_stat_set(int unit, bcm_trunk_t tid, bcm_trunk_dlb_stat_t type, uint64 value)</a>  </td><td>Set the DLB statistic based on the trunk Id.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga424ffdc92f76724ca35e0fdb02dafd40" title="Get the DLB statistic based on the trunk Id.">bcm_trunk_dlb_stat_get(int unit, bcm_trunk_t tid, bcm_trunk_dlb_stat_t type, uint64* value)</a>  </td><td>Get the DLB statistic based on the trunk Id.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga8eb660d7d4630bde17e1103b71f7d854" title="Get the DLB statistic from the trunk Id with sync mode.">bcm_trunk_dlb_stat_sync_get(int unit, bcm_trunk_t tid, bcm_trunk_dlb_stat_t type, uint64* value)</a>  </td><td>Get the DLB statistic from the trunk Id with sync mode.   </td></tr>
</table>
<h1><a class="anchor" id="flow_monitoring"></a>
Flow Monitoring</h1>
<p>DLB Flow Monitoring feature has been introduced for BCM56880 devices. As part of load balancing process flows are reassigned by hardware based on factors like quality of aggregate members, inactivity duration and new flow additions. The reassignment process results in changes in flowset index assigned to macroflows. This feature allows sampling of packets when such a reassignment occurs. Sampling rate is configurable. The sampled packets can be directed to CPU or mirrored. For CPU destined packets, a new reason code has been introduced. For mirrored packets, a new header called PSAMP Format 2 has been introduced.</p>
<p><a class="anchor" id="bcm_trunk_dlb_mon_cfg_t"></a></p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbcm__trunk__dlb__mon__cfg__s.html">bcm_trunk_dlb_mon_cfg_s</a> {</div><div class="line">    <a class="code" href="sal_2types_8h.html#aa3ad64cf41ec3a042bd92550cc6ed308">uint64</a> <a class="code" href="structbcm__trunk__dlb__mon__cfg__s.html#a0d6763b0eff7d83040124326a35e9867">sample_rate</a>; <span class="comment">/* Rate of sampling DLB monitored packets */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__dlb__mon__cfg__s.html#a9ba0f2f280a2a2e49c17508af48aad91">action</a>;         <span class="comment">/* See BCM_TRUNK_DLB_MON_xxx definitions below */</span></div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="structbcm__trunk__dlb__mon__cfg__s.html#a4f2504e3cd237cbe4ee10255c7855e63">enable</a>;         <span class="comment">/* Enable monitoring of DLB associated with the TRUNK</span></div><div class="line"><span class="comment">                           group. 1 = Enable monitoring for DLB associated with</span></div><div class="line"><span class="comment">                           trunk, 0 = Do not monitor DLB */</span></div><div class="line">} <a class="code" href="group__trunk.html#ga6383aa56b391dac26b00af59344ebc14">bcm_trunk_dlb_mon_cfg_t</a>;</div></div><!-- fragment --><p>The actions to take for sampled packets is specified in the 'action' field through the following encodings.</p>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>Encodings to specify action for sampled packets</caption>
<tr>
<th>Name </th><th>Purpose  </th></tr>
<tr>
<td>BCM_TRUNK_DLB_MON_ACTION_NONE </td><td>Do not perform trace sampled packets.  </td></tr>
<tr>
<td>BCM_TRUNK_DLB_MON_ACTION_TRACE </td><td>Trace DLB monitored packets.  </td></tr>
</table>
<table class="doxtable">
<tr>
<th>API </th><th>Brief  </th></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga87be2fa23956a3b43b5e1ca07050bde5" title="Initializes the bcm_trunk_dlb_mon_cfg_t structure.">bcm_trunk_dlb_mon_cfg_t_init(bcm_trunk_dlb_mon_cfg_t* dlb_mon_cfg)</a>  </td><td>Initializes the bcm_trunk_dlb_mon_cfg_t structure   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#gac07f26264a8a3dd4dbf6060f08b58a21" title="Set DLB monitoring configurations.">bcm_trunk_dlb_mon_config_set(int unit, bcm_trunk_t tid, bcm_trunk_dlb_mon_cfg_t* dlb_mon_cfg)</a>  </td><td>Set DLB monitoring configurations.   </td></tr>
<tr>
<td><a class="el" href="group__trunk.html#ga0cd4cde67728e15fb40a6dfb6e766846" title="Get DLB monitoring configurations.">bcm_trunk_dlb_mon_config_get(int unit, bcm_trunk_t tid, bcm_trunk_dlb_mon_cfg_t* dlb_mon_cfg)</a>  </td><td>Get DLB monitoring configurations.   </td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="footer-brcm-wrapper">
<table class="footer-brcm">
	<tbody><tr>
		<td class="footer-brcm"><img src="BRCM_Red+Black_noTag_RGB.png" align="left"></td>
		<td class="footer-brcm"><small><b>Proprietary and Confidential &copy; 2019 Broadcom</b></small>
			<div class="footer-brcm">Broadcom Incorporated reserves the right to make changes without further notice to any products or data herein to improve reliability, function, or design.
Information furnished by Broadcom Incorporated is believed to be accurate and reliable. However, Broadcom Incorporated does not assume any liability arising
out of the application or use of this information, nor the application or use of any product or circuit described herein, neither does it convey any license
under its patent rights nor the rights of others.
			</div>
		</td>
	</tr>
</tbody></table>
</div>
</body>
</html>
