Index: make/makerules.pkg.vendor
===================================================================
--- make/makerules.pkg.vendor	(revision 7711)
+++ make/makerules.pkg.vendor	(revision 7714)
@@ -27,7 +27,7 @@
 # Location where SDK archives are stored by vendor make system.
 #
 ifeq (1,$(BLD_L7_TARGETOS_LINUX))
-  vend_sdk_arc := $(out_vend_sdk)/unix-user/$(BOARD)-$(L7_CPU)
+  vend_sdk_arc := $(out_vend_sdk)/unix-user/$(L7_CPU)
 
   ifeq (1,$(BLD_L7_TARGETOS_LINUX_26))
     vend_sdk_arc := $(vend_sdk_arc)-2_6
Index: include/soc/mcm/allenum.h
===================================================================
--- include/soc/mcm/allenum.h	(revision 7711)
+++ include/soc/mcm/allenum.h	(revision 7714)
@@ -262,7 +262,29 @@
 # endif
 #endif
 
+/* PTin added: new switch 56689 (Valkyrie2) */
 #ifdef BCM_ESW_SUPPORT
+# if !defined(NO_BCM_56689_A0)
+#  define BCM_56685_A0
+#  define BCM_56689_A0
+# endif
+#endif
+
+#ifdef BCM_ESW_SUPPORT
+# if !defined(NO_BCM_56689_B0)
+#  define BCM_56685_B0
+#  define BCM_56689_B0
+# endif
+#endif
+
+#ifdef BCM_ESW_SUPPORT
+# if !defined(NO_BCM_56643_B0)
+#  define BCM_56643_B0
+# endif
+#endif
+/* PTin end */
+
+#ifdef BCM_ESW_SUPPORT
 # if !defined(NO_BCM_56334_A0)
 #  define BCM_56334_A0
 # endif
Index: include/soc/defs.h
===================================================================
--- include/soc/defs.h	(revision 7711)
+++ include/soc/defs.h	(revision 7714)
@@ -226,8 +226,10 @@
 #define BCM_IPFIX_SUPPORT
 #endif
 
-#if defined(BCM_56685_A0) || defined(BCM_56685_B0)
+/* PTin added: new switch 56689 (Valkyrie2) */
+#if defined(BCM_56685_A0) || defined(BCM_56685_B0) || defined(BCM_56689_A0) || defined(BCM_56689_B0)
 #define BCM_56685
+#define BCM_56689   /* PTin added: new switch 56689 (Valkyrie2) */
 #define BCM_56634
 #define BCM_56624
 #define BCM_56304
@@ -241,6 +243,7 @@
 #define BCM_MPLS_SUPPORT
 #define BCM_IPFIX_SUPPORT
 #endif
+/* PTin end */
 
 #if defined(BCM_56334_A0) || defined(BCM_56334_B0)
 #define BCM_56334
@@ -308,8 +311,10 @@
 #endif
 #endif
 
-#if defined(BCM_56640_A0) || defined(BCM_56640_B0)
+/* PTin modified: new switch 5664x (Triumph3) */
+#if defined(BCM_56640_A0) || defined(BCM_56640_B0) || defined(BCM_56643_A0) || defined(BCM_56643_B0)
 #define BCM_56640
+#define BCM_56643     /* PTin modified: new switch 5664x (Triumph3) */
 #define BCM_56840
 #define BCM_56634
 #define BCM_56624
Index: include/bcm_int/esw/triumph2.h
===================================================================
--- include/bcm_int/esw/triumph2.h	(revision 7711)
+++ include/bcm_int/esw/triumph2.h	(revision 7714)
@@ -74,6 +74,11 @@
                                 bcm_l3_intf_t *l3_intf);
 extern int bcm_tr2_ipmc_egress_intf_delete(int unit, int index, bcm_port_t port,
                                    bcm_l3_intf_t *l3_intf);
+#ifdef LVL7_FIXUP
+extern int bcm_tr2_ipmc_repl_set(int unit, int mc_index, bcm_port_t port,
+                                bcm_vlan_vector_t vlan_vec);
+#endif
+
 extern int bcm_tr2_ipmc_egress_intf_set(int unit, int mc_index,
                                        bcm_port_t port, int if_count,
                                        bcm_if_t *if_array, int check_port);
Index: src/appl/diag/tksdiag.c
===================================================================
--- src/appl/diag/tksdiag.c	(revision 7711)
+++ src/appl/diag/tksdiag.c	(revision 7714)
@@ -64,6 +64,10 @@
 #include <soc/drv.h>    /* For MH Opcode-0 priority workaround */
 #endif
 
+#if (__GNUC__ >= 4) /* PTin added */
+#pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
 void topo_cpu_dump(topo_cpu_t *topo_cpu, char *prefix);
 
 
@@ -705,7 +709,7 @@
  *         5610x A0
  */
 
-STATIC int
+int
 mh_opcode0_priority_select(int unit, 
                            int group_priority,
                            bcm_field_group_t *group,
@@ -826,7 +830,7 @@
  *     Given the above, the device type and rev will NOT be validated.
  */
 
-STATIC int
+int
 mh_opcode0_priority_clear(int unit, 
                           bcm_field_group_t group,
                           bcm_field_entry_t entry,
Index: src/appl/diag/esw/counter.c
===================================================================
--- src/appl/diag/esw/counter.c	(revision 7711)
+++ src/appl/diag/esw/counter.c	(revision 7714)
@@ -93,7 +93,7 @@
         non_dma =
             &SOC_CONTROL(unit)->counter_non_dma[ctr_reg -
                                                 SOC_COUNTER_NON_DMA_START];
-        LOG_INFO(BSL_LS_APPL_COUNTER,
+        LOG_VERBOSE(BSL_LS_APPL_COUNTER,
                  (BSL_META_U(unit,
                              "cval_set: %s ar_idx=%d p=%d idx=%d vh=%d vl=%d\n"),
                   non_dma->cname,
@@ -103,7 +103,7 @@
     } else if (ctr_reg >= NUM_SOC_REG) {
         return;
     } else {
-        LOG_INFO(BSL_LS_APPL_COUNTER,
+        LOG_VERBOSE(BSL_LS_APPL_COUNTER,
                  (BSL_META_U(unit,
                              "cval_set: %s ar_idx=%d p=%d idx=%d vh=%d vl=%d\n"),
                   SOC_REG_NAME(unit, ctr_reg),
@@ -195,7 +195,7 @@
             non_dma =
                 &SOC_CONTROL(unit)->counter_non_dma[ctr_reg -
                                                SOC_COUNTER_NON_DMA_START];
-            LOG_INFO(BSL_LS_APPL_COUNTER,
+            LOG_VERBOSE(BSL_LS_APPL_COUNTER,
                      (BSL_META_U(unit,
                                  "cval_get: %s ar_idx=%d p=%d idx=%d vh=%d vl=%d\n"),
                       non_dma->cname,
@@ -203,7 +203,7 @@
                       COMPILER_64_HI(*val),
                       COMPILER_64_LO(*val)));
         } else {
-            LOG_INFO(BSL_LS_APPL_COUNTER,
+            LOG_VERBOSE(BSL_LS_APPL_COUNTER,
                      (BSL_META_U(unit,
                                  "cval_get: %s ar_idx=%d p=%d idx=%d vh=%d vl=%d\n"),
                       SOC_REG_NAME(unit, ctr_reg),
Index: src/appl/diag/esw/hash.c
===================================================================
--- src/appl/diag/esw/hash.c	(revision 7711)
+++ src/appl/diag/esw/hash.c	(revision 7714)
@@ -41,8 +41,12 @@
 #define   ETHERTYPE_IPV4 0x0800 /* ipv4 ethertype */
 #define   ETHERTYPE_MIN  0x0600 /* minimum ethertype for hashing */
 
+#ifndef IP_PROT_TCP
 #define   IP_PROT_TCP 0x6  /* TCP protocol number */
+#endif
+#ifndef IP_PROT_UDP
 #define   IP_PROT_UDP 0x11 /* TCP protocol number */
+#endif
 
 #if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_ENDURO_SUPPORT) || \
     defined(BCM_GREYHOUND2_SUPPORT)
Index: src/bcm/dispatch.c
===================================================================
--- src/bcm/dispatch.c	(revision 7711)
+++ src/bcm/dispatch.c	(revision 7714)
@@ -13695,7 +13695,7 @@
 	if (!BCM_UNIT_CHECK(unit)) {
 		r_rv = BCM_E_UNIT;
 	} else {
-		BCM_API_XLATE_PORT_PBMP_DECL(t_pbm);
+		BCM_API_XLATE_PORT_PBMP_DECL(t_pbm);	/* PTin TODO: Attention! */
 		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbm,pbm);
 		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbm);
 		dtype = BCM_DTYPE(unit);
Index: src/bcm/common/rx.c
===================================================================
--- src/bcm/common/rx.c	(revision 7711)
+++ src/bcm/common/rx.c	(revision 7714)
@@ -5344,6 +5344,14 @@
                 if (BCM_SUCCESS(rv) && (tid != -1)) {
                     pkt->src_trunk = tid;
                     pkt->flags |= BCM_PKT_F_TRUNK;
+#ifndef LVL7_FIXUP
+   /* Don't destroy information!!
+   ** When frames are received from remote units the src_port is not the same as
+   ** rx_port. We still need to know the physical port on which the frame is
+   ** received even when the frame is for a trunk.
+   */
+                    //pkt->src_port = -1;   /* Already removed at SDK 6.3.4 */
+#endif
                 }
             }
 /* } */
Index: src/bcm/common/link.c
===================================================================
--- src/bcm/common/link.c	(revision 7711)
+++ src/bcm/common/link.c	(revision 7714)
@@ -290,6 +290,7 @@
 {
     int rv, speed;
     uint32 flags;
+    int value;
 #ifdef BCM_DNX_SUPPORT
     if (SOC_IS_DNX(unit)) {
         if (IS_IL_PORT(unit, port) || IS_SFI_PORT(unit, port)) {
@@ -321,6 +322,19 @@
     if (BCM_FAILURE(rv)) {
         return rv;
     }
+    
+#if 1
+     /* PTin added: clear not necessary flags */
+     if (bcm_port_control_get(unit, port, bcmPortControlLinkFaultLocal, &value) != BCM_E_NONE || value ==0)
+     {
+       flags &= ~((uint32) BCM_PORT_FAULT_LOCAL);
+     }
+     if (bcm_port_control_get(unit, port, bcmPortControlLinkFaultRemote, &value) != BCM_E_NONE || value == 0)
+     {
+       flags &= ~((uint32)BCM_PORT_FAULT_REMOTE);
+     }
+#endif
+
     if (flags & BCM_PORT_FAULT_REMOTE) {
         *remote_fault = TRUE;
     }
Index: src/bcm/esw/portctrl.c
===================================================================
--- src/bcm/esw/portctrl.c	(revision 7711)
+++ src/bcm/esw/portctrl.c	(revision 7714)
@@ -82,11 +82,6 @@
 #include <soc/portmod/portmod_legacy_phy.h>
 #include <soc/esw/portctrl_internal.h>
 
-extern uint32_t phymod_dbg_mask;
-extern uint32_t phymod_dbg_addr;
-extern uint32_t phymod_dbg_lane;
-
-
 /*
  * Define:
  *      PORTCTRL_PORT_RESOLVE
@@ -129,6 +124,10 @@
 #define PORTCTRL_SPEED_ABILITY_MAX_COUNT 50
 #endif /* PORTMOD_SUPPORT */
 
+#if (__GNUC__ >= 4) /* PTin added */
+#pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
 /*
  * Macros for use with encapsulation set related functions
  */
Index: src/bcm/esw/flexctr/flex_ctr_common.c
===================================================================
--- src/bcm/esw/flexctr/flex_ctr_common.c	(revision 7711)
+++ src/bcm/esw/flexctr/flex_ctr_common.c	(revision 7714)
@@ -43,6 +43,11 @@
 
 #include <bcm_int/esw/latency_monitor.h>
 
+#if (__GNUC__ >= 4) /* PTin added */
+#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
+#pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
 #ifdef ALPM_ENABLE
 #ifdef BCM_TOMAHAWK_SUPPORT
 extern uint32 *alpm_bkt_node_ptr_arr_get(uint32 idx);
Index: src/bcm/esw/triumph2/vlan.c
===================================================================
--- src/bcm/esw/triumph2/vlan.c	(revision 7711)
+++ src/bcm/esw/triumph2/vlan.c	(revision 7714)
@@ -1033,6 +1033,11 @@
         action.dt_outer_prio = bcmVlanActionReplace;
         action.dt_inner = bcmVlanActionNone;
         action.dt_inner_prio = bcmVlanActionNone;
+    } else if (vlan_vp->flags & BCM_VLAN_PORT_INNER_VLAN_REPLACE) {
+        action.dt_outer = bcmVlanActionReplace;
+        action.dt_outer_prio = bcmVlanActionReplace;
+        action.dt_inner = bcmVlanActionReplace;
+        action.dt_inner_prio = bcmVlanActionNone;
     } else {
         if (soc_feature(unit, soc_feature_vlan_copy_action)) {
             action.dt_outer = bcmVlanActionCopy;
@@ -1645,6 +1650,11 @@
         action.dt_outer_prio = bcmVlanActionReplace;
         action.dt_inner = bcmVlanActionNone;
         action.dt_inner_prio = bcmVlanActionNone;
+    } else if (vlan_vp->flags & BCM_VLAN_PORT_INNER_VLAN_REPLACE) {
+        action.dt_outer = bcmVlanActionReplace;
+        action.dt_outer_prio = bcmVlanActionReplace;
+        action.dt_inner = bcmVlanActionReplace;
+        action.dt_inner_prio = bcmVlanActionNone;
     } else {
         if (soc_feature(unit, soc_feature_vlan_copy_action)) {
             action.dt_outer = bcmVlanActionCopy;
Index: src/bcm/esw/triumph2/wlan.c
===================================================================
--- src/bcm/esw/triumph2/wlan.c	(revision 7711)
+++ src/bcm/esw/triumph2/wlan.c	(revision 7714)
@@ -802,6 +802,10 @@
     uint64 rval64, *rval64s[1];
     uint32 capwap_frag_profile;
 
+#ifdef LVL7_FIXUP
+    (void)bcm_tr2_wlan_port_delete_all(unit); /* jls added */
+#endif
+
     if (!L3_INFO(unit)->l3_initialized) {
         LOG_INFO(BSL_LS_BCM_L3,
                  (BSL_META_U(unit,
@@ -1516,7 +1520,11 @@
         }
     }
     /* Create an interface */
+#ifdef LVL7_FIXUP
+    BCM_IF_ERROR_RETURN(bcm_xgs3_l3_intf_id_create(unit, if_info));
+#else
     BCM_IF_ERROR_RETURN(bcm_xgs3_l3_intf_create(unit, if_info));
+#endif
     _BCM_WLAN_INTF_USED_SET(unit, if_info->l3i_index);
     return BCM_E_NONE;
 }
@@ -1589,6 +1597,12 @@
         bcm_l3_egress_t_init(&nh_info);
 
         nh_flags = _BCM_L3_SHR_MATCH_DISABLE | _BCM_L3_SHR_WRITE_DISABLE;
+#ifdef LVL7_FIXUP
+        if (*nh_index > 0)
+        {
+          nh_flags |= _BCM_L3_SHR_WITH_ID;
+        }
+#endif
         rv = bcm_xgs3_nh_add(unit, nh_flags, &nh_info, nh_index);
         BCM_IF_ERROR_RETURN(rv);
     }
@@ -1648,7 +1662,12 @@
 
     /* Add an L3 interface entry with L2_SWITCH=1 - ref count if exists */
     sal_memset(&if_info, 0, sizeof(_bcm_l3_intf_cfg_t));
+#ifdef LVL7_FIXUP
+    if_info.l3i_flags |= BCM_L3_L2ONLY | BCM_L3_SECONDARY | BCM_L3_WITH_ID;
+    if_info.l3i_index = L3_INFO(unit)->l3_intf_table_size - 2;
+#else
     if_info.l3i_flags |= BCM_L3_L2ONLY | BCM_L3_SECONDARY;
+#endif
     rv = _bcm_tr2_wlan_l3_intf_add(unit, &if_info);
     if (BCM_FAILURE(rv)) {
         goto cleanup;
@@ -1965,7 +1984,11 @@
 int 
 bcm_tr2_wlan_port_add(int unit, bcm_wlan_port_t *wlan_port)
 {
+#ifdef LVL7_FIXUP
+    int drop, mode, is_local = 0, rv = BCM_E_PARAM, nh_index = wlan_port->encap_id;
+#else
     int drop, mode, is_local = 0, rv = BCM_E_PARAM, nh_index = 0;
+#endif
     bcm_port_t local_port;
     bcm_module_t my_modid;
     int vp, num_vp, lport_ptr = -1;
@@ -2108,10 +2131,20 @@
         soc_LPORT_TABm_field32_set(unit, &lport_profile, IPMC_DO_VLANf, 0x1);
         soc_LPORT_TABm_field32_set(unit, &lport_profile, FILTER_ENABLEf, 0x1);
         soc_LPORT_TABm_field32_set(unit, &lport_profile, VFP_ENABLEf, 0x1);
+#ifdef LVL7_FIXUP
+        /* In FASTPATH, all the ports have the same sel_index for slices. Point
+         * the tunnel ports to pick up sel_index of 0. Otherwise IFP matching
+         * does not work on tunnel ports.
+         */
+        soc_LPORT_TABm_field32_set(unit, &lport_profile, 
+                                   FP_PORT_FIELD_SEL_INDEXf, 
+                                   0);
+#else
         /* Allocate a fixed high index for the PORT_FIELD_SEL */
         soc_LPORT_TABm_field32_set(unit, &lport_profile, 
                                    FP_PORT_FIELD_SEL_INDEXf, 
                                    soc_mem_index_max(unit, FP_PORT_FIELD_SELm));
+#endif
         /* The vt_key_types must be set to 0x3 or 0x7 for WLAN */
         soc_LPORT_TABm_field32_set(unit, &lport_profile, VT_KEY_TYPEf,
                                    TR_VLXLT_HASH_KEY_TYPE_VLAN_MAC);
@@ -2291,7 +2324,9 @@
         }
     }
     rv = _bcm_lport_profile_entry_delete(unit, lport_ptr);
+#ifndef LVL7_FIXUP
     BCM_IF_ERROR_RETURN(rv);
+#endif
 
     /* Clear the SVP and DVP table entries */
     sal_memset(&svp, 0, sizeof(wlan_svp_table_entry_t));
@@ -2308,7 +2343,9 @@
 
     /* Clear the next-hop table entries */
     rv = _bcm_tr2_wlan_nh_info_delete(unit, nh_index);
+#ifndef LVL7_FIXUP
     BCM_IF_ERROR_RETURN(rv);
+#endif
 
     /* Update the physical port's SW state */
     BCM_IF_ERROR_RETURN(
@@ -2417,9 +2454,11 @@
             WLAN_LOCK(unit);
             rv = _bcm_tr2_wlan_port_delete(unit, vp);
             WLAN_UNLOCK(unit);
+#ifndef LVL7_FIXUP
             if (rv < 0) {
                 goto done;
             }
+#endif
         }
     }
 done:
Index: src/bcm/esw/triumph2/cosq.c
===================================================================
--- src/bcm/esw/triumph2/cosq.c	(revision 7711)
+++ src/bcm/esw/triumph2/cosq.c	(revision 7714)
@@ -881,6 +881,28 @@
      * c. if MISCCONFIG.METERING_CLK_EN not set before, enable it.
      */
 
+#ifdef LVL7_FIXUP
+    uint64 maskval_64;
+
+    meter_flags = flags;
+
+    /* first clear bit corresponding for que then optionally set it to enable packet mode */
+    BCM_IF_ERROR_RETURN(READ_SHAPING_MODEr(unit, port, &regval_64));
+    maskval_64 = COMPILER_64_INIT(0, 1);
+    COMPILER_64_SHL(maskval_64, cosq);
+    COMPILER_64_NOT(maskval_64);
+    COMPILER_64_AND(regval_64, maskval_64);
+
+    /* set SHAPING_MODE bit if required. */
+    if ((max_quantum !=0) && 
+        (_BCM_XGS_METER_FLAG_PACKET_MODE == (flags&_BCM_XGS_METER_FLAG_PACKET_MODE))) {
+      COMPILER_64_NOT(maskval_64);
+      COMPILER_64_OR(regval_64, maskval_64);
+    }
+
+    BCM_IF_ERROR_RETURN(WRITE_SHAPING_MODEr(unit, port, regval_64));
+#endif    
+
     BCM_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &regval));
     if (soc_reg_field_get(unit, MISCCONFIGr, regval, ITU_MODE_SELf)) {
         meter_flags |= _BCM_XGS_METER_FLAG_NON_LINEAR;
@@ -913,10 +935,19 @@
     bucket_bitsize =
         soc_reg_field_length(unit, MINBUCKETCONFIG_64r, MIN_THDf);
 
+#ifdef LVL7_FIXUP
+    /* Hardcode the burst size to accommodate jumbo frames (9216 bytes). The unit
+       for 'burst_quantum' is kbits. So (9216 * 8 / 1000 = 74)*/
     BCM_IF_ERROR_RETURN
+        (_bcm_xgs_kbits_to_bucket_encoding(min_quantum, kbits_burst_min ? 74 : 0,
+                          meter_flags, refresh_bitsize, bucket_bitsize,
+                          &refresh_rate, &bucketsize, &granularity));
+#else
+    BCM_IF_ERROR_RETURN
         (_bcm_xgs_kbits_to_bucket_encoding(min_quantum, kbits_burst_min,
                           meter_flags, refresh_bitsize, bucket_bitsize,
                           &refresh_rate, &bucketsize, &granularity));
+#endif
 
     COMPILER_64_ZERO(regval_64);
     soc_reg64_field32_set(unit, MINBUCKETCONFIG_64r, &regval_64,
@@ -943,6 +974,15 @@
                           METER_GRANf, granularity);
     soc_reg64_field32_set(unit, MAXBUCKETCONFIG_64r, &regval_64,
                           MAX_REFRESHf, refresh_rate);
+#ifdef LVL7_FIXUP
+    /* We want as small a burst size as possible... 4 KB in this case. */
+    bucketsize = bucketsize ? 1 : 0;
+    if ((0 != max_quantum) && (0 == bucketsize))
+    {
+      /* Max is specified. bucketsize cannot be zero or else shaping is disabled. */
+      bucketsize = 1;
+    }
+#endif
     soc_reg64_field32_set(unit, MAXBUCKETCONFIG_64r, &regval_64, MAX_THDf,
                           bucketsize);
     BCM_IF_ERROR_RETURN(WRITE_MAXBUCKETCONFIG_64r(unit, port, cosq, regval_64));
Index: src/bcm/esw/triumph3/cosq.c
===================================================================
--- src/bcm/esw/triumph3/cosq.c	(revision 7711)
+++ src/bcm/esw/triumph3/cosq.c	(revision 7714)
@@ -5714,6 +5714,7 @@
         mem_size = sizeof(uint32)*SOC_MAX_MEM_WORDS*count;
         i_lls_tree->mtro_entries = sal_alloc(mem_size, "lls_war_buf");
 
+        /* CSP#1137542 correction */
         rv = soc_phyctrl_speed_get(unit, port, &speed);
         if (rv == BCM_E_UNAVAIL) {
             si = &SOC_INFO(unit);
Index: src/bcm/esw/triumph3/oam.c
===================================================================
--- src/bcm/esw/triumph3/oam.c	(revision 7711)
+++ src/bcm/esw/triumph3/oam.c	(revision 7714)
@@ -4691,6 +4691,10 @@
             BCM_FIELD_QSET_ADD(oc->fp_glp_qs, bcmFieldQualifyDstMimGport);
             BCM_FIELD_QSET_ADD(oc->fp_glp_qs, bcmFieldQualifySrcMimGport);
         }
+
+        //PTIn added BRCM Support [CASE#782509] 17th June suggestion to avoid packets reaching the board with translated inner VID to trigger LM OAM counters (just proper outer VID ones)
+        BCM_FIELD_QSET_ADD(oc->fp_glp_qs, bcmFieldQualifyVlanTranslationHit);
+
         /* Create fp group */
         rv = bcm_esw_field_group_create(unit, oc->fp_glp_qs, 
                                 BCM_FIELD_GROUP_PRIO_ANY, &(oc->fp_glp_group));
@@ -4788,7 +4792,21 @@
                                   "EP=%d %s.\n"), hash_data->ep_id, bcm_errmsg(rv)));
             return (rv);
         }
-        
+     
+        /* PTin added: OAM */   
+#if 1
+        //PTIn added BRCM Support [CASE#782509] 17th June suggestion to avoid packets reaching the board with translated inner VID to trigger LM OAM counters (just proper outer VID ones)
+        rv = bcm_esw_field_qualify_VlanTranslationHit(unit, hash_data->fp_entry_rx, 
+                                BCM_FIELD_VXLT_LOOKUP_STATUS_HIT, BCM_FIELD_VXLT_LOOKUP_STATUS_HIT);
+        if (BCM_FAILURE(rv)) {
+            LOG_ERROR(BSL_LS_BCM_OAM,
+                          (BSL_META_U(unit,
+                                      "OAM(unit %d) Error: Qualifying VlanTranslationHit (rx), \
+                                      EP=%d %s.\n"),
+                           unit, hash_data->ep_id, bcm_errmsg(rv)));
+            return (rv);
+        }
+#endif
         rv = _bcm_esw_gport_resolve(unit, hash_data->gport, &modid, 
                                     &local_port, &tgid, &local_id);
         if (BCM_FAILURE(rv)) {
Index: src/bcm/esw/triumph3/extender.c
===================================================================
--- src/bcm/esw/triumph3/extender.c	(revision 7711)
+++ src/bcm/esw/triumph3/extender.c	(revision 7714)
@@ -44,6 +44,9 @@
 #include <soc/saber2.h>
 #endif /* BCM_SABER2_SUPPORT */
 
+#if (__GNUC__ >= 4) /* PTin added */
+#pragma GCC diagnostic ignored "-Wunused-function"
+#endif
 #define  TD_EXTENDER_PORT_HASH_BKT_SIZE          32
 /*
  * Extender EGR_L3_NEXT_HOP View
Index: src/bcm/esw/triumph3/hashing.c
===================================================================
--- src/bcm/esw/triumph3/hashing.c	(revision 7711)
+++ src/bcm/esw/triumph3/hashing.c	(revision 7714)
@@ -41,8 +41,12 @@
 #define   ETHERTYPE_IPV4 0x0800 /* ipv4 ethertype */
 #define   ETHERTYPE_MIN  0x0600 /* minimum ethertype for hashing */
 
+#ifndef IP_PROT_TCP
 #define   IP_PROT_TCP 0x6  /* TCP protocol number */
+#endif
+#ifndef IP_PROT_UDP
 #define   IP_PROT_UDP 0x11 /* TCP protocol number */
+#endif
 
 #define RTAG7_L2_ONLY         0x0
 #define RTAG7_UNKNOWN_HIGIG   0x1
Index: src/bcm/esw/multicast.c
===================================================================
--- src/bcm/esw/multicast.c	(revision 7711)
+++ src/bcm/esw/multicast.c	(revision 7714)
@@ -84,6 +84,10 @@
 #include <bcm_int/esw/triumph3.h>
 #include<bcm_int/esw/saber2.h> 
 
+/* PTin modified: Virtual ports - avoid errors due to CPU port */
+#include "logger.h"
+
+
 #define _BCM_MULTICAST_MTU_TABLE_OFFSET(unit) \
         ((SOC_IS_HURRICANEX(unit) || SOC_IS_GREYHOUND(unit) || \
           SOC_IS_METROLITE(unit) || SOC_IS_GREYHOUND2(unit)) ? \
@@ -3844,9 +3848,17 @@
 #endif /* BCM_TOMAHAWK_SUPPORT || BCM_TRIDENT2PLUS_SUPPORT */
         {
             BCM_PBMP_ITER(ether_higig_pbmp, port_iter) {
+            /* PTin modified: Virtual ports - avoid errors due to CPU port */
+            #if 0
                 BCM_IF_ERROR_RETURN(
                      _bcm_esw_ipmc_egress_intf_set(unit, mc_index, port_iter, 0,
                                                    NULL, is_l3, FALSE));
+            #else
+                if (_bcm_esw_ipmc_egress_intf_set(unit, mc_index, port_iter, 0, NULL, is_l3, FALSE) != BCM_E_NONE)
+                {
+                  PT_LOG_WARN(LOG_CTX_SDK,"Error with _bcm_esw_ipmc_egress_intf_set: unit=%d, mc_index=%d, port=%d", unit, mc_index, port_iter);
+                }
+            #endif
             }
         }
 
Index: src/bcm/esw/stat.c
===================================================================
--- src/bcm/esw/stat.c	(revision 7711)
+++ src/bcm/esw/stat.c	(revision 7714)
@@ -1264,7 +1264,19 @@
                     SOC_IF_ERROR_RETURN(WRITE_IL_RX_CONFIGr(unit, port, rval32));
                 }
             } else {
+#ifdef LVL7_FIXUP
+                /* Set the Stack port Max size to 0x3fff */
+                if (IS_HG_PORT(unit,port))
+                {
+                  COMPILER_64_SET(rval, 0, 0x3fff);
+                }
+                else
+                {
+                  COMPILER_64_SET(rval, 0, _bcm_stat_ovr_threshold[unit][port]);
+                }
+#else
                 COMPILER_64_SET(rval, 0, _bcm_stat_ovr_threshold[unit][port]);
+#endif
                 SOC_IF_ERROR_RETURN(WRITE_MAC_CNTMAXSZr(unit, port, rval));
             }
 
Index: src/bcm/esw/port.c
===================================================================
--- src/bcm/esw/port.c	(revision 7711)
+++ src/bcm/esw/port.c	(revision 7714)
@@ -8325,6 +8325,10 @@
     int pause_tx, pause_rx, q_limit_enable, cos;
     uint32 psl_rval, opc_rval, oqc_rval;
 
+#ifdef LVL7_FIXUP
+    if (SOC_IS_SCORPION(unit)) return BCM_E_NONE;
+#endif
+
     if (!SOC_IS_HBX(unit)) {
         return (BCM_E_UNAVAIL);
     }
@@ -8413,6 +8417,9 @@
              BCM_IF_ERROR_RETURN
                  (_bcm_trx_vlan_port_default_action_get(unit, port, &action));
         }
+        #ifdef LVL7_FIXUP
+        action.it_inner_prio = bcmVlanActionNone;
+        #endif
         action.new_outer_vlan = vid;
         action.priority = PORT(unit, local_port).p_ut_prio;
 #if defined(BCM_TOMAHAWK_SUPPORT)
@@ -18939,6 +18946,345 @@
     return rv;
 }
 
+/* PTin added: linkscan */
+#if 1
+int
+ptin_esw_port_loopback_set(int unit, bcm_port_t port, int loopback, int no_linkchange)
+{
+    int             rv, link = TRUE;
+    int             phy_lane = -1;
+    int             phyn = 0, sys_side = 0;
+    bcm_port_t      local_port = -1;
+#if defined(BCM_TOMAHAWK_SUPPORT)
+    uint32          link_st = 0;
+    soc_timeout_t   to;
+    int             phy_port;
+#endif
+    soc_persist_t   *sop = SOC_PERSIST(unit);
+
+#ifdef BCM_TRIDENT2_SUPPORT
+    int             enable;
+#endif /* BCM_TRIDENT2_SUPPORT */
+#if defined(BCM_KATANA2_SUPPORT)
+    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
+#endif
+
+    /* Make sure port module is initialized. */
+    PORT_INIT(unit);
+
+    if (SOC_USE_PORTCTRL(unit)) {
+        /* Check if port have to force-loopback */
+        if (BCM_ESW_PORT_DRV(unit)!= NULL) {
+            if (BCM_ESW_PORT_DRV(unit)->force_lb_check != NULL) {
+                rv = BCM_ESW_PORT_DRV(unit)->force_lb_check(unit, port,
+                                                            loopback);
+                if (rv != BCM_E_NONE) {
+                    LOG_ERROR(BSL_LS_BCM_PORT,
+                              (BSL_META("Error: Port %d allow PHY internal "
+                                        "loopback only.\n"),
+                               port));
+                    return BCM_E_PARAM;
+                }
+            }
+        }
+
+        return bcmi_esw_portctrl_loopback_set(unit, port, loopback);
+    }
+
+    if(bcm_common_oamp_port_enable_get(unit, port)) {
+        LOG_ERROR(BSL_LS_BCM_PORT,
+                  (BSL_META("Error: Cannot set loopback on OAMP Port %d.\n"),
+                   port));
+        return BCM_E_PARAM;
+    }
+
+#if defined(BCM_KATANA2_SUPPORT)
+#if defined(BCM_SABER2_SUPPORT)
+    if(SOC_IS_SABER2(unit)) {
+        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
+    }
+#endif
+    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
+        (!((port >= 1) && (port <= max_phy_port)))) {
+         return BCM_E_PORT;
+    }
+#endif
+
+    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_phyn_validate(unit, port,
+                                                        &local_port, &phyn,
+                                                        &phy_lane, &sys_side));
+
+    if (local_port == -1) {
+       BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
+    } else {
+       port = local_port;
+    }
+
+#if defined(BCM_TOMAHAWK_SUPPORT)
+    if (SOC_IS_TOMAHAWKX(unit)) {
+        BCM_IF_ERROR_RETURN(bcm_th_phy_lb_check(unit, port, loopback));
+    }
+#endif
+
+#ifdef BCM_RCPU_SUPPORT
+    if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
+        return BCM_E_PORT;
+    }
+#endif /* BCM_RCPU_SUPPORT */
+
+    PORT_LOCK(unit);
+    soc_phyctrl_enable_get(unit, port, &link);
+    PORT_UNLOCK(unit);
+    if (TRUE == link) {
+        if (SOC_PBMP_MEMBER(sop->lc_pbm_override_ports, port)) {
+            if(!SOC_PBMP_MEMBER(sop->lc_pbm_override_link, port)) {
+                link = FALSE;
+            }
+        }
+    }
+
+    rv = BCM_E_NONE;
+    /*
+     * Always force link before changing hardware to avoid
+     * race with the linkscan thread.
+     */
+    if (!(loopback == BCM_PORT_LOOPBACK_NONE)) {
+        rv = _bcm_esw_link_force(unit, 0 /*flags*/, port, TRUE, FALSE);
+
+        if(rv == BCM_E_NONE) {
+            /* Force the update function to be called so the state is
+               updated */
+            if (_soc_linkscan_phy_flags_test(unit, port, PHY_FLAGS_EXTERNAL_PHY)) {
+                rv = bcm_esw_port_update(unit, port, TRUE);
+            }
+        }
+    }
+
+    PORT_LOCK(unit);
+
+    if (BCM_SUCCESS(rv)) {
+        rv = MAC_LOOPBACK_SET(PORT(unit, port).p_mac, unit, port,
+                              (loopback == BCM_PORT_LOOPBACK_MAC));
+    }
+    if (BCM_SUCCESS(rv)) {
+        if (local_port == -1) {
+            if (loopback == BCM_PORT_LOOPBACK_PHY_REMOTE) {
+                rv = soc_phyctrl_control_set(unit, port,
+                                             SOC_PHY_CONTROL_LOOPBACK_REMOTE, 1);
+            } else {
+                if (loopback == BCM_PORT_LOOPBACK_NONE) {
+                    rv = soc_phyctrl_control_set(unit, port,
+                                             SOC_PHY_CONTROL_LOOPBACK_REMOTE, 0);
+                }
+
+                if (rv == SOC_E_NONE || rv == SOC_E_UNAVAIL) {
+                    rv = soc_phyctrl_loopback_set(unit, port,
+                                                  (loopback == BCM_PORT_LOOPBACK_PHY),
+                                                  TRUE);
+                }
+            }
+
+        } else {
+            rv = soc_phyctrl_redirect_loopback_set
+                                          (unit, port, phyn,
+                                           phy_lane, sys_side,
+                                           (loopback == BCM_PORT_LOOPBACK_PHY),
+                                           TRUE);
+        }
+    }
+
+    /* some mac loopback implementations require the phy to also be in loopback */
+    if (soc_feature(unit, soc_feature_phy_lb_needed_in_mac_lb) &&
+        (loopback == BCM_PORT_LOOPBACK_MAC)) {
+        if (local_port == -1) {
+            rv = soc_phyctrl_loopback_set(unit, port, 1, TRUE);
+        } else {
+            rv = soc_phyctrl_redirect_loopback_set(unit, port, phyn,
+                                                   phy_lane, sys_side,
+                                                   1, TRUE);
+        }
+     }
+
+    PORT_UNLOCK(unit);                  /* unlock before link call */
+
+    if ((loopback == BCM_PORT_LOOPBACK_NONE) || !BCM_SUCCESS(rv)) {
+        /* PTin modified */
+        #if 1
+        _bcm_esw_link_force(unit, 0 /*flags*/, port, FALSE, DONT_CARE);
+        #else
+        _ptin_esw_link_force(unit, port, FALSE, DONT_CARE, no_linkchange);
+        #endif
+        PORT_LOCK(unit);
+#ifdef BCM_TRIDENT2_SUPPORT
+        /* When the PHY is TSC, need to unsquelch TX LANE. */
+        if (SOC_IS_TD2_TT2(unit) && !SOC_IS_TOMAHAWKX(unit)){
+            enable = PORT(unit, port).enable;
+            if ((FALSE == enable) && (loopback == BCM_PORT_LOOPBACK_NONE)) {
+                (void)soc_phyctrl_notify(unit, port, phyEventTxSquelch, FALSE);
+                rv = soc_phyctrl_enable_set(unit, port, FALSE);
+                if (SOC_FAILURE(rv)) {
+                    PORT_UNLOCK(unit);
+                    return (rv);
+                }
+                rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, FALSE);
+            }
+        } else
+#endif /* BCM_TRIDENT2_SUPPORT */
+        {
+            if ((FALSE == link) && (loopback == BCM_PORT_LOOPBACK_NONE)) {
+                /* Disable MAC RX to prevent traffic going into this port */
+                MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
+                                SOC_MAC_CONTROL_RX_SET, FALSE);
+                sal_udelay(100); /* Wait for 1 jumbo packet transmission time */
+
+                rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, FALSE);
+            }
+        }
+        PORT_UNLOCK(unit);
+    } else {
+        /* Enable only MAC instead of calling bcm_port_enable_set so
+         * that this API doesn't silently enable the port if the
+         * port is disabled by application.
+         */
+        rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, TRUE);
+
+#ifdef BCM_TRIDENT2_SUPPORT
+        /* When the PHY is TSC, need to enable the PHY to support MAC loopback
+         * on a disabled port. In order to avoid link flap of link partner,
+         * need to squelch TX LANE before enabling PHY.
+         */
+        if (BCM_FAILURE(rv)) {
+            return (rv);
+        }
+        if ((SOC_IS_TD2_TT2(unit) && !SOC_IS_TOMAHAWKX(unit)) && (FALSE == link)
+            && (loopback == BCM_PORT_LOOPBACK_MAC)) {
+            PORT_LOCK(unit);
+            (void)soc_phyctrl_notify(unit, port, phyEventTxSquelch, TRUE);
+            rv = soc_phyctrl_enable_set(unit, port, TRUE);
+            PORT_UNLOCK(unit);
+            if (SOC_FAILURE(rv)) {
+                return (rv);
+            }
+        }
+#endif /* BCM_TRIDENT2_SUPPORT */
+
+        if (BCM_SUCCESS(rv)) {
+            /* Make sure that the link status is updated only after the
+             * MAC is enabled so that link_mask2 is set before the
+             * calling thread synchronizes with linkscan thread in
+             * _bcm_link_force call.
+             * If the link is forced before MAC is enabled, there could
+             * be a race condition in _soc_link_update where linkscan
+             * may use an old view of link_mask2 and override the
+             * EPC_LINK_BMAP after the mac_enable_set updates
+             * link_mask2 and EPC_LINK_BMAP.
+             */
+            if (loopback == BCM_PORT_LOOPBACK_MAC) {
+                rv = _bcm_esw_link_force(unit, 0 /*flags*/, port, TRUE, TRUE);
+            } else {
+                rv = _bcm_esw_link_force(unit, 0 /*flags*/, port, TRUE, link);
+            }
+        }
+        if (BCM_FAILURE(rv)) {
+            return (rv);
+        }
+
+#if defined(BCM_BRADLEY_SUPPORT)
+        /*
+         * Call _bcm_port_mmu_update explicitly because linkscan
+         * will not call bcm_port_update when the link is forced.
+         */
+        if (SOC_IS_HBX(unit) && !SOC_IS_SHADOW(unit)) {
+            rv = _bcm_port_mmu_update(unit, port, 1);
+        }
+
+        /* When a link comes up, hardware will not update the
+         * LINK_STATUS register until software has toggled the
+         * the LAG_FAILOVER_CONFIG.LINK_STATUS_UP field.
+         * Normally, this is done by bcm_port_update. But since
+         * linkscan will not call bcm_port_update when a link is
+         * forced up, the toggling of LAG_FAILOVER_CONFIG.LINK_STATUS_UP
+         * is done here.
+         */
+        if ((SOC_REG_IS_VALID(unit, GXPORT_LAG_FAILOVER_CONFIGr) &&
+             IS_GX_PORT(unit, port)) ||
+            (SOC_REG_IS_VALID(unit, LAG_FAILOVER_CONFIGr)) ||
+            (SOC_REG_IS_VALID(unit, XLPORT_LAG_FAILOVER_CONFIGr) &&
+              (IS_XL_PORT(unit, port) || IS_MXQ_PORT(unit, port))) ||
+            (SOC_REG_IS_VALID(unit, CLPORT_LAG_FAILOVER_CONFIGr) &&
+              IS_CL_PORT(unit, port))) {
+            soc_reg_t reg;
+            uint32 rval;
+
+            if (SOC_IS_SABER2(unit) && SOC_REG_PORT_VALID(unit, XLPORT_LAG_FAILOVER_CONFIGr, port)) {
+                reg = XLPORT_LAG_FAILOVER_CONFIGr;
+            } else if (SOC_REG_IS_VALID(unit, LAG_FAILOVER_CONFIGr)) {
+                reg = LAG_FAILOVER_CONFIGr;
+            } else if (SOC_REG_IS_VALID(unit, GXPORT_LAG_FAILOVER_CONFIGr)) {
+                reg = GXPORT_LAG_FAILOVER_CONFIGr;
+            } else if (SOC_REG_PORT_VALID(unit, CLPORT_LAG_FAILOVER_CONFIGr, port) && 
+                       (SOC_IS_TOMAHAWKX(unit) || IS_CL_PORT(unit, port))) {
+                reg = CLPORT_LAG_FAILOVER_CONFIGr;
+            } else {
+                reg = XLPORT_LAG_FAILOVER_CONFIGr;
+            }
+
+#if defined(BCM_TOMAHAWK_SUPPORT)
+           if (SOC_IS_TOMAHAWK(unit)) {
+               phy_port = SOC_INFO(unit).port_l2p_mapping[port];
+               if((phy_port == TH_MGMT_PORT0_NUM) ||
+                  (phy_port == TH_MGMT_PORT1_NUM)) {
+                   reg = XLPORT_LAG_FAILOVER_CONFIGr;
+               }
+               /* Link status to IPIPE is updated by H/W and driven based on both the
+               * rising edge of XLPORT_LAG_FAILOVER_CONFIG.LINK_STATUS_UP and
+               * actual link up status from Serdes.
+               * In some loopback scenarios it may take longer time to see Serdes link up status.
+               */
+               soc_timeout_init(&to, 10000, 0);
+               do {
+                      if (((phy_port != TH_MGMT_PORT0_NUM) &&
+                           (phy_port != TH_MGMT_PORT1_NUM)) ||
+                           (loopback == BCM_PORT_LOOPBACK_NONE)) {
+                          break;
+                      }
+
+                      switch(phy_port) {
+                          case TH_MGMT_PORT0_NUM:
+                              BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XLPORT_XGXS0_LN0_STATUS0_REGr, port, 0, &rval));
+                              link_st = soc_reg_field_get(unit, XLPORT_XGXS0_LN0_STATUS0_REGr, rval, LINK_STATUSf);
+                              break;
+                          case TH_MGMT_PORT1_NUM:
+                              BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XLPORT_XGXS0_LN2_STATUS0_REGr, port, 0, &rval));
+                              link_st = soc_reg_field_get(unit, XLPORT_XGXS0_LN2_STATUS0_REGr, rval, LINK_STATUSf);
+                              break;
+                      }
+                      if(link_st) {
+                          break;
+                      }
+               } while (!soc_timeout_check(&to));
+           }
+#endif
+           /* Toggle link bit to notify IPIPE on link up */
+           BCM_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
+           soc_reg_field_set(unit, reg, &rval, LINK_STATUS_UPf, 1);
+           BCM_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
+           soc_reg_field_set(unit, reg, &rval, LINK_STATUS_UPf, 0);
+           BCM_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
+        }
+#endif /* BCM_BRADLEY_SUPPORT */
+    }
+
+    LOG_INFO(BSL_LS_BCM_PORT,
+             (BSL_META_U(unit,
+                         "bcm_port_loopback_set: u=%d p=%d lb=%d rv=%d\n"),
+              unit, port, loopback, rv));
+
+    return rv;
+}
+#endif
+
+
 /*
  * Function:
  *      bcm_port_loopback_get
Index: src/bcm/esw/triumph/mpls.c
===================================================================
--- src/bcm/esw/triumph/mpls.c	(revision 7711)
+++ src/bcm/esw/triumph/mpls.c	(revision 7714)
@@ -104,6 +104,10 @@
 #include <soc/esw/cancun_enums.h>
 #endif
 
+#if (__GNUC__ >= 4) /* PTin added */
+#pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
 #ifdef BCM_SPECIAL_LABEL_SUPPORT
 char *label_type_array[5] = { "special_label_type_NONE",
                                   "Special_label_type_GAL",
@@ -116,7 +120,6 @@
 #define ECN_MAP_ID_INVALID 0xffffffff
 #endif
 
-
 _bcm_tr_mpls_bookkeeping_t  _bcm_tr_mpls_bk_info[BCM_MAX_NUM_UNITS] = {{ 0 }};
 STATIC _bcm_mpls_egr_nhopList_t  *_bcm_tr_mpls_nhop_headPtr[BCM_MAX_NUM_UNITS][_BCM_TR_MPLS_HASH_ELEMENTS];
 bcm_tr_mpls_vc_swap_table_hash_t *bcmi_vc_swap_label_hash[SOC_MAX_NUM_DEVICES];
Index: src/bcm/esw/triumph/cosq.c
===================================================================
--- src/bcm/esw/triumph/cosq.c	(revision 7711)
+++ src/bcm/esw/triumph/cosq.c	(revision 7714)
@@ -1089,7 +1089,7 @@
 
 }
 
-STATIC int
+int
 _bcm_tr_cosq_port_packet_bandwidth_set(int unit, bcm_port_t port,
                                        bcm_cos_queue_t cosq,
                                        int pps, int burst)
Index: src/bcm/esw/field_common.c
===================================================================
--- src/bcm/esw/field_common.c	(revision 7711)
+++ src/bcm/esw/field_common.c	(revision 7714)
@@ -40621,6 +40621,9 @@
     while (fs != NULL)
     {
         status->entries_total += fs->entry_count/ratio;
+#ifdef LVL7_FIXUP
+        status->natural_depth = fs->entry_count/ratio;
+#endif
         fs = fs->next;
     }
 
Index: src/bcm/esw/switch.c
===================================================================
--- src/bcm/esw/switch.c	(revision 7711)
+++ src/bcm/esw/switch.c	(revision 7714)
@@ -5433,6 +5433,15 @@
             case bcmSwitchIgmpPktDrop:
                 fields[0] = IGMP_PKT_DROPf;
                 break;
+#ifdef LVL7_FIXUP
+            /* See #77807 for details */
+            case bcmSwitchMldPktToCpu:
+                fields[0] = MLD_PKT_TO_CPUf;
+                break;
+            case bcmSwitchMldPktDrop:
+                fields[0] = MLD_PKT_DROPf;
+                break;
+#endif
             case bcmSwitchV4ResvdMcPktToCpu:
                 fields[0] = IPV4_RESVD_MC_PKT_TO_CPUf;
                 break;
@@ -5635,6 +5644,17 @@
                 field = IGMP_PKT_DROPf;
                 act_value = 1;
                 break;
+#ifdef LVL7_FIXUP
+            /* See #77807 for details */
+            case bcmSwitchMldPktToCpu: 	 
+                field = MLD_PKT_TO_CPUf; 	 
+                act_value = 1; 	 
+                break; 	 
+            case bcmSwitchMldPktDrop: 	 
+                field = MLD_PKT_DROPf; 	 
+                act_value = 1; 	 
+                break;
+#endif
             case bcmSwitchV4ResvdMcPktToCpu:
                 field = IPV4_RESVD_MC_PKT_TO_CPUf;
                 act_value = 1;
Index: src/bcm/esw/vlan.c
===================================================================
--- src/bcm/esw/vlan.c	(revision 7711)
+++ src/bcm/esw/vlan.c	(revision 7714)
@@ -6777,6 +6777,7 @@
     bcm_module_t        modid;
     bcm_trunk_t         tgid = -1;
     int                 id = -1; 
+    int orig_port_class = port_class;
 
     CHECK_INIT(unit);
 #if defined(BCM_TRIDENT2PLUS_SUPPORT) && defined(INCLUDE_L3) 
@@ -6871,6 +6872,9 @@
 
 #ifdef BCM_TRX_SUPPORT
     if (SOC_IS_TRX(unit) && soc_feature(unit, soc_feature_vlan_action)) {
+       if(BCM_GPORT_IS_VLAN_PORT(orig_port_class)) {
+           port_class = orig_port_class;
+       }
         return _bcm_trx_vlan_translate_egress_action_add(unit, port_class, 
                                              outer_vlan, inner_vlan, 
                                              action);
@@ -6904,6 +6908,7 @@
     bcm_module_t        modid;
     bcm_trunk_t         tgid = -1;
     int                 id = -1; 
+    int orig_port_class = port_class;
 
     CHECK_INIT(unit);
 #if defined(BCM_TRIDENT2PLUS_SUPPORT) && defined(INCLUDE_L3)
@@ -6982,6 +6987,9 @@
 
 #ifdef BCM_TRX_SUPPORT
     if (SOC_IS_TRX(unit) && soc_feature(unit, soc_feature_vlan_action)) {
+        if(BCM_GPORT_IS_VLAN_PORT(orig_port_class)) {
+            port_class = orig_port_class;
+        }
         return _bcm_trx_vlan_translate_egress_action_get(unit, port_class, 
                                                         outer_vlan, inner_vlan, 
                                                         action);
@@ -7013,6 +7021,7 @@
     bcm_module_t        modid;
     bcm_trunk_t         tgid = -1;
     int                 id = -1; 
+    int orig_port_class = port_class;
 
     CHECK_INIT(unit); 
 #if defined(BCM_TRIDENT2PLUS_SUPPORT) && defined(INCLUDE_L3) 
@@ -7087,6 +7096,9 @@
 
 #ifdef BCM_TRX_SUPPORT
     if (SOC_IS_TRX(unit) && soc_feature(unit, soc_feature_vlan_action)) {
+        if(BCM_GPORT_IS_VLAN_PORT(orig_port_class)) {
+            port_class = orig_port_class;
+        }
         return _bcm_trx_vlan_translate_egress_action_delete(unit, port_class, 
                                                            outer_vlan, 
                                                            inner_vlan);
Index: src/bcm/esw/trident2/hashing.c
===================================================================
--- src/bcm/esw/trident2/hashing.c	(revision 7711)
+++ src/bcm/esw/trident2/hashing.c	(revision 7714)
@@ -41,8 +41,12 @@
 #define   ETHERTYPE_IPV4 0x0800 /* ipv4 ethertype */
 #define   ETHERTYPE_MIN  0x0600 /* minimum ethertype for hashing */
 
+#ifndef IP_PROT_TCP
 #define   IP_PROT_TCP 0x6  /* TCP protocol number */
+#endif
+#ifndef IP_PROT_UDP
 #define   IP_PROT_UDP 0x11 /* TCP protocol number */
+#endif
 
 #define RTAG7_RH_MODE_ECMP    0
 #define RTAG7_RH_MODE_LAG     1
Index: src/bcm/esw/enduro/vlan.c
===================================================================
--- src/bcm/esw/enduro/vlan.c	(revision 7711)
+++ src/bcm/esw/enduro/vlan.c	(revision 7714)
@@ -808,6 +808,11 @@
         action.dt_outer_prio = bcmVlanActionReplace;
         action.dt_inner = bcmVlanActionNone;
         action.dt_inner_prio = bcmVlanActionNone;
+    } else if (vlan_vp->flags & BCM_VLAN_PORT_INNER_VLAN_REPLACE) {
+        action.dt_outer = bcmVlanActionReplace;
+        action.dt_outer_prio = bcmVlanActionReplace;
+        action.dt_inner = bcmVlanActionReplace;
+        action.dt_inner_prio = bcmVlanActionNone;
     } else {
         /* Strip inner VLAN */
         action.dt_outer = bcmVlanActionReplace;
Index: src/bcm/esw/enduro/hashing.c
===================================================================
--- src/bcm/esw/enduro/hashing.c	(revision 7711)
+++ src/bcm/esw/enduro/hashing.c	(revision 7714)
@@ -41,8 +41,12 @@
 #define   ETHERTYPE_IPV4 0x0800 /* ipv4 ethertype */
 #define   ETHERTYPE_MIN  0x0600 /* minimum ethertype for hashing */
 
+#ifndef IP_PROT_TCP
 #define   IP_PROT_TCP 0x6  /* TCP protocol number */
+#endif
+#ifndef IP_PROT_UDP
 #define   IP_PROT_UDP 0x11 /* TCP protocol number */
+#endif
 
 #define RTAG7_L2_ONLY         0x0
 #define RTAG7_UNKNOWN_HIGIG   0x1
Index: src/bcm/esw/trident/hashing.c
===================================================================
--- src/bcm/esw/trident/hashing.c	(revision 7711)
+++ src/bcm/esw/trident/hashing.c	(revision 7714)
@@ -41,8 +41,18 @@
 #define   ETHERTYPE_IPV4 0x0800 /* ipv4 ethertype */
 #define   ETHERTYPE_MIN  0x0600 /* minimum ethertype for hashing */
 
+/* PTin modified: SDK 6.3.0 */
+#ifdef LVL7_FIXUP
+#ifndef IP_PROT_TCP
 #define   IP_PROT_TCP 0x6  /* TCP protocol number */
+#endif
+#ifndef IP_PROT_UDP
 #define   IP_PROT_UDP 0x11 /* TCP protocol number */
+#endif
+#else
+#define   IP_PROT_TCP 0x6  /* TCP protocol number */
+#define   IP_PROT_UDP 0x11 /* TCP protocol number */
+#endif
 
 #define RTAG7_L2_ONLY         0x0
 #define RTAG7_UNKNOWN_HIGIG   0x1
Index: src/bcm/esw/trident/cosq.c
===================================================================
--- src/bcm/esw/trident/cosq.c	(revision 7711)
+++ src/bcm/esw/trident/cosq.c	(revision 7714)
@@ -4787,7 +4787,15 @@
     * mcast 
     * There are only 5 MC QUEUES [0,4] attached to a port
     */
-    mc_cosq = (cosq > mc_cosq_max) ? mc_cosq_max : cosq;
+/* PTin modified: */
+    //mc_cosq = (cosq > mc_cosq_max) ? mc_cosq_max : cosq;
+    {
+     int numq=8;
+    
+     bcm_td_cosq_config_get(unit,&numq);
+     mc_cosq = cosq * (mc_cosq_max+1) / numq;
+    }	
+/* PTin end */
     BCM_IF_ERROR_RETURN(_bcm_td_cosq_mapping_set(unit, local_port,
         priority,
         BCM_COSQ_GPORT_UCAST_QUEUE_GROUP | BCM_COSQ_GPORT_MCAST_QUEUE_GROUP,
Index: src/bcm/esw/field.c
===================================================================
--- src/bcm/esw/field.c	(revision 7711)
+++ src/bcm/esw/field.c	(revision 7714)
@@ -3145,6 +3145,31 @@
         return (rv);
     }
 
+#ifdef LVL7_FIXUP
+    if (fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE)
+    {
+      fg->group_status.slice_width_physical = 1;
+    }
+    else if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE)
+    {
+      fg->group_status.slice_width_physical = 2;
+    }
+    else 
+    {
+      fg->group_status.slice_width_physical = 4;
+    }
+
+    if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)
+    {
+      fg->group_status.intraslice_mode_enable = 1;
+    }
+    else
+    {
+      fg->group_status.intraslice_mode_enable = 0;
+    }
+#endif
+
+
     *status = fg->group_status;
     FP_UNLOCK(unit);
     return (rv);
Index: src/bcm/esw/link.c
===================================================================
--- src/bcm/esw/link.c	(revision 7711)
+++ src/bcm/esw/link.c	(revision 7714)
@@ -1293,6 +1293,8 @@
     bcm_port_ability_t  port_ability;
     int ln_rmt_fault = 0;
     int ln_lcl_fault = 0;
+    _bcm_port_info_t *port_info;
+    int value;
 
 #ifdef BCM_HELIX5_SUPPORT
     if (SOC_IS_HELIX5(unit)) {
@@ -1399,9 +1401,22 @@
 
         SOC_IF_ERROR_RETURN
             (soc_reg_get(unit, reg, port, 0, &lss));
-        rmt_fault = soc_reg64_field32_get(unit, reg, lss, rmt_fault_field);
-        lcl_fault = soc_reg64_field32_get(unit, reg, lss, lcl_fault_field);
 
+        lcl_fault = rmt_fault = 0;
+        _bcm_port_info_access(unit, port, &port_info);
+        if (MAC_CONTROL_GET(port_info->p_mac, unit, port,
+                            SOC_MAC_CONTROL_FAULT_REMOTE_ENABLE, &value) == BCM_E_NONE
+            && value == 1)
+        {
+            rmt_fault = soc_reg64_field32_get(unit, reg, lss, rmt_fault_field);
+        }
+        if (MAC_CONTROL_GET(port_info->p_mac, unit, port,
+                            SOC_MAC_CONTROL_FAULT_LOCAL_ENABLE, &value) == BCM_E_NONE
+            && value == 1)
+        {
+            lcl_fault = soc_reg64_field32_get(unit, reg, lss, lcl_fault_field);
+        }
+
         if (rmt_fault || lcl_fault) {
             *fault = TRUE;
         }
@@ -1427,6 +1442,14 @@
 
     return BCM_E_NONE;
 }
+
+/* PTin added: linkscan */
+#if 1
+int _ptin_esw_link_fault_get(int unit, int port, int *fault)
+{
+  return _bcm_esw_link_fault_get(unit, port, fault);
+}
+#endif
 #endif /* HERC15, FIREBOLT */  
 
 
@@ -3816,6 +3839,83 @@
     return(BCM_E_NONE);
 }
 
+/* PTin added: linkscan */
+#if 1
+int
+_ptin_esw_link_force(int unit, bcm_port_t port, int force, int link, int no_linkchange)
+{
+    soc_persist_t *sop = SOC_PERSIST(unit);
+    ls_cntl_t *lc = link_control[unit];
+    pbmp_t pbm;
+
+    LC_CHECK_INIT(unit);
+
+    if (!SOC_PORT_VALID(unit, port) || !IS_PORT(unit, port)) {
+        return BCM_E_PORT;
+    }
+
+    LC_LOCK(unit);
+
+    if (force) {
+        SOC_PBMP_PORT_REMOVE(sop->lc_pbm_override_link, port);
+        if (link) {
+            if (lc->lc_warm_boot) {
+                /* Don't update ports when recovering from Warm Boot. */
+                SOC_PBMP_PORT_ADD(sop->lc_pbm_link, port);
+                SOC_PBMP_PORT_REMOVE(sop->lc_pbm_link_change, port);
+            }
+            SOC_PBMP_PORT_ADD(sop->lc_pbm_override_link, port);
+        }
+        SOC_PBMP_PORT_ADD(sop->lc_pbm_override_ports, port);
+    } else {
+        SOC_PBMP_PORT_REMOVE(sop->lc_pbm_override_ports, port);
+        SOC_PBMP_PORT_REMOVE(sop->lc_pbm_override_link, port);
+
+        /* Don't set link change (link down) if port is only on
+           hardware linkscan. This is because a hardware interrupt
+           may never come for a port that is currently up. */
+        if (!(SOC_PBMP_MEMBER(lc->lc_pbm_hw, port) &&
+              !SOC_PBMP_MEMBER(lc->lc_pbm_sw, port))) {
+            /* PTin modified */
+            #if 0
+            SOC_PBMP_PORT_ADD(sop->lc_pbm_link_change, port);
+            #else
+            if (no_linkchange)
+            {
+              //SOC_PBMP_PORT_ADD(sop->lc_pbm_link, port);
+              SOC_PBMP_PORT_REMOVE(sop->lc_pbm_link_change, port);
+            }
+            else
+            {
+              SOC_PBMP_PORT_ADD(sop->lc_pbm_link_change, port);
+            }
+            #endif
+        }
+    }
+
+    /*
+     * Force immediate update to just this port - this allows loopback 
+     * forces to take effect immediately.
+     */
+    SOC_PBMP_CLEAR(pbm);
+    SOC_PBMP_PORT_ADD(pbm, port);
+    /* PTin modified */
+    _bcm_esw_linkscan_update(unit, 0 /*flags*/, pbm);
+
+    LC_UNLOCK(unit);
+
+    /*
+     * Wake up master thread to notice changes - required if using hardware
+     * link scanning.
+     */
+    if (lc->lc_sema != NULL) {
+        sal_sem_give(lc->lc_sema);
+    }
+
+    return(BCM_E_NONE);
+}
+#endif
+
 /*
  * Function:    
  *      _bcm_esw_link_down_tx_set
Index: src/bcm/esw/katana2/hashing.c
===================================================================
--- src/bcm/esw/katana2/hashing.c	(revision 7711)
+++ src/bcm/esw/katana2/hashing.c	(revision 7714)
@@ -42,8 +42,12 @@
 #define   ETHERTYPE_MPLS 0x8847 /* MPLS ethertype */
 #define   ETHERTYPE_MIN  0x0600 /* minimum ethertype for hashing */
 
+#ifndef IP_PROT_TCP
 #define   IP_PROT_TCP 0x6  /* TCP protocol number */
+#endif
+#ifndef IP_PROT_UDP
 #define   IP_PROT_UDP 0x11 /* TCP protocol number */
+#endif
 
 #define RTAG7_L2_ONLY         0x0
 #define RTAG7_UNKNOWN_HIGIG   0x1
Index: src/bcm/esw/katana2/cosq.c
===================================================================
--- src/bcm/esw/katana2/cosq.c	(revision 7711)
+++ src/bcm/esw/katana2/cosq.c	(revision 7714)
@@ -43,6 +43,9 @@
 #include <bcm_int/esw/switch.h>
 #endif /* BCM_WARM_BOOT_SUPPORT */
 
+#pragma GCC diagnostic ignored "-Wunused-function"
+#pragma GCC diagnostic ignored "-Wunused-variable"
+
 #if defined(BCM_KATANA2_SUPPORT)
 #include <soc/katana2.h>
 #include <bcm_int/esw/multicast.h>
@@ -4928,7 +4931,8 @@
     int count_index= 0;
     int rv;
 #ifndef BCM_COSQ_HIGIG_MAP_DISABLE
-    int cpu_hg_index = 0;
+    int cpu_hg_index;
+    cpu_hg_index = 0;
 #endif
     
     if (count < 1 || count > 16) {
Index: src/bcm/esw/firebolt/vlan.c
===================================================================
--- src/bcm/esw/firebolt/vlan.c	(revision 7711)
+++ src/bcm/esw/firebolt/vlan.c	(revision 7714)
@@ -6384,6 +6384,18 @@
                     _BCM_MULTICAST_ID_GET(control->unknown_unicast_group));
             }
         }
+        
+        if (_BCM_MULTICAST_IS_VLAN(control->broadcast_group) || 
+            _BCM_MULTICAST_IS_VLAN(control->unknown_unicast_group) ||
+            _BCM_MULTICAST_IS_VLAN(control->unknown_unicast_group)) {
+            if (SOC_MEM_FIELD_VALID(unit, VLAN_TABm, VIRTUAL_PORT_ENf)) {
+                soc_mem_field32_set(unit, VLAN_TABm, &vt, VIRTUAL_PORT_ENf, 1);
+            }
+        } else {
+            if (SOC_MEM_FIELD_VALID(unit, VLAN_TABm, VIRTUAL_PORT_ENf)) {
+                soc_mem_field32_set(unit, VLAN_TABm, &vt, VIRTUAL_PORT_ENf, 0);
+            }
+        }
    }
 #endif /* (BCM_TRIUMPH2_SUPPORT && INCLUDE_L3 */
 
Index: src/bcm/esw/trx/vlan.c
===================================================================
--- src/bcm/esw/trx/vlan.c	(revision 7711)
+++ src/bcm/esw/trx/vlan.c	(revision 7714)
@@ -1762,6 +1762,22 @@
                    }
                    if (0 != fs_idx) { /* Recover flex stat counter */
                        sal_memset(&event, 0, sizeof(event));
+                       /* PTin modified: Virtual port supported for Helix4 */
+                       if (soc_mem_field_valid(unit, EGR_VLAN_XLATEm, ENTRY_TYPEf)) {
+                           soc_EGR_VLAN_XLATEm_field32_set(unit, &event,
+                                                           ENTRY_TYPEf,
+                           soc_EGR_VLAN_XLATEm_field32_get(unit,
+                                                           &egr_xlate_entry, ENTRY_TYPEf));
+                       }
+                       else if (soc_mem_field_valid(unit, EGR_VLAN_XLATEm, KEY_TYPEf)) {
+                           soc_EGR_VLAN_XLATEm_field32_set(unit, &event,
+                                                           KEY_TYPEf,
+                                                           soc_EGR_VLAN_XLATEm_field32_get(unit, &egr_xlate_entry, KEY_TYPEf));
+                       }
+                       else {
+                           return BCM_E_CONFIG;
+                       }
+                       /* PTin end */
                        /* Construct key-only entry, copy to FS handle */
                         soc_mem_field32_set(unit, egr_mem, &event, ENTRY_TYPEf,
                                  soc_mem_field32_get(unit, egr_mem,
@@ -9755,8 +9771,19 @@
             (0 != soc_mem_field32_get(unit, mem, vtabp, VINTF_CTR_IDXf))) {
             sal_memset(&vent, 0, sizeof(vent));
             /* Construct key-only entry, copy to FS handle */
-            soc_mem_field32_set(unit, mem, &vent, ENTRY_TYPEf,
-                soc_mem_field32_get(unit, mem, vtabp, ENTRY_TYPEf));
+            /* PTin modified: Virtual port supported for Helix4 (updated at SDK-ALL-6.5.15) */
+            if (soc_mem_field_valid(unit, EGR_VLAN_XLATEm, ENTRY_TYPEf)) {
+              soc_mem_field32_set(unit, mem, &vent, ENTRY_TYPEf,
+                  soc_mem_field32_get(unit, mem, vtabp, ENTRY_TYPEf));
+            }
+            else if (soc_mem_field_valid(unit, EGR_VLAN_XLATEm, KEY_TYPEf)) {
+              soc_mem_field32_set(unit, mem, &vent, KEY_TYPEf,
+                  soc_mem_field32_get(unit, mem, vtabp, KEY_TYPEf));
+            }
+            else {
+              return BCM_E_CONFIG;
+            }
+            /* PTin end */
             soc_mem_field_get(unit, mem, (uint32 *) vtabp,
                                KEYf, (uint32 *) key);
             soc_mem_field_set(unit, mem, (uint32 *) &vent,
Index: src/bcm/esw/time.c
===================================================================
--- src/bcm/esw/time.c	(revision 7711)
+++ src/bcm/esw/time.c	(revision 7714)
@@ -110,6 +110,10 @@
 #include <bcm_int/common/esmc.h>
 #endif /* BCM_ESMC_EXTDPLL_SUPPORT */
 
+#if (__GNUC__ >= 4) /* PTin added */
+#pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
 #define BROAD_SYNC_TIME_CAPTURE_TIMEOUT      (10) /* useconds */
 #define BROAD_SYNC_OUTPUT_TOGGLE_TIME_DELAY  (3)  /* seconds */ 
 
Index: src/soc/common/reg.c
===================================================================
--- src/soc/common/reg.c	(revision 7711)
+++ src/soc/common/reg.c	(revision 7714)
@@ -12,6 +12,9 @@
 #include <sal/core/libc.h>
 #include <sal/core/boot.h>
 
+/* PTin added */
+#include "logger.h"
+
 #include <soc/debug.h>
 #include <soc/cm.h>
 #include <soc/drv.h>
@@ -4250,7 +4253,7 @@
     int               gransh; /* index granularity shift */
     soc_block_types_t regblktype;
     soc_block_t       portblktype;
-    int               phy_port;
+    int               phy_port = -1;
     int               instance_mask = 0;
     int               instance = -1;
     
@@ -4274,6 +4277,12 @@
         LOG_CLI((BSL_META_U(unit,
                             "reg %s is invalid\n"), soc_reg_name[reg]));
 #endif
+        /* PTin added */
+        if (!SOC_REG_IS_VALID(unit, reg))
+        {
+          PT_LOG_CRITIC(LOG_CTX_SDK, "assert(SOC_REG_IS_VALID(unit,reg)): unit=%d port=%d reg=%d index=%d SOC_REG_IS_VALID=%d",
+                        unit, port, reg, index, SOC_REG_IS_VALID(unit,reg));
+        }
         assert(SOC_REG_IS_VALID(unit, reg));
     }
 
@@ -4303,7 +4312,13 @@
     if(!instance_mask) {
         if (port >= 0) {
             if (SOC_BLOCK_IN_LIST(regblktype, portblktype)) {
-                assert(SOC_PORT_VALID(unit, port));
+                /* PTin added */
+                if (!SOC_PORT_VALID(unit, port))
+                {
+                  PT_LOG_CRITIC(LOG_CTX_SDK, "assert(SOC_PORT_VALID(unit,port)): unit=%d port=%d reg=%d index=%d SOC_PORT_VALID=%d",
+                                unit, port, reg, index, SOC_PORT_VALID(unit,port));
+                }
+                assert(SOC_PORT_VALID(unit, port)); 
                 if (soc_feature(unit, soc_feature_logical_port_num)) {
                     /*
                      * COVERITY
@@ -4341,6 +4356,9 @@
                     }
                 }
                 if (block < 0) {
+                    /* PTin added */
+                    PT_LOG_CRITIC(LOG_CTX_SDK, "port=%d reg=%d index=%d phy_port=%d block=%d pindex=%d portblktype=%d regblktype=%d SOC_BLOCK_IN_LIST=%d",
+                                  port, reg, index, phy_port, block, pindex, portblktype, regblktype, SOC_BLOCK_IN_LIST(regblktype,portblktype)); 
                     assert(SOC_REG_ADDR_INVALID_PORT); /* invalid port */
                 }
             }
@@ -4424,6 +4442,7 @@
                 break;
             case SOC_BLK_CI:
                 if (port >= 3) {
+                    PT_LOG_CRITIC(LOG_CTX_SDK, "assert(SOC_REG_ADDR_INVALID_PORT): unit=%d port=%d reg=%d index=%d", unit, port, reg, index);
                     assert(SOC_REG_ADDR_INVALID_PORT); /* invalid instance */
                 } else {
                     block = CI_BLOCK(unit, port);
@@ -4597,10 +4616,24 @@
                 break;
             default:
                     block = -1; /* unknown non-port block */
+                /* PTin added */
+                PT_LOG_CRITIC(LOG_CTX_SDK, "{port=%d reg=%d index=%d} {phy_port=%d block=%d pindex=%d} portblktype=%d regblktype=%d SOC_REG_FIRST_BLK_TYPE=%d SOC_BLOCK_IN_LIST=%d",
+                              port, reg, index, phy_port, block, pindex, portblktype, regblktype, SOC_REG_FIRST_BLK_TYPE(regblktype), SOC_BLOCK_IN_LIST(regblktype,portblktype)); 
+                    /* PTin added */
+                    PT_LOG_CRITIC(LOG_CTX_SDK, "port=%d reg=%d index=%d instance_mask=0x%x", port, reg, index, instance_mask);
+                    PT_LOG_CRITIC(LOG_CTX_SDK, "{phy_port=%d block=%d pindex=%d} portblktype=%d regblktype=%d SOC_REG_FIRST_BLK_TYPE=%d SOC_BLOCK_IN_LIST=%d",
+                                  phy_port, block, pindex, portblktype, regblktype, SOC_REG_FIRST_BLK_TYPE(regblktype), SOC_BLOCK_IN_LIST(regblktype,portblktype));
                     break;
             }
         }
 
+    /* PTin added: sometimes this application crash here! */
+    if (block < 0)
+    {
+      PT_LOG_CRITIC(LOG_CTX_SDK, "assert(block>=0): port=%d reg=%d index=%d instance_mask=0x%x", port, reg, index, instance_mask);
+      PT_LOG_CRITIC(LOG_CTX_SDK, "assert(block>=0): {phy_port=%d block=%d pindex=%d} portblktype=%d regblktype=%d SOC_REG_FIRST_BLK_TYPE=%d SOC_BLOCK_IN_LIST=%d",
+                    phy_port, block, pindex, portblktype, regblktype, SOC_REG_FIRST_BLK_TYPE(regblktype), SOC_BLOCK_IN_LIST(regblktype,portblktype));
+    }
     assert(block >= 0); /* block must be valid */
 
     /* determine final block, pindex, and index */
@@ -4660,6 +4693,14 @@
         }
         break;
     case soc_cosreg:
+        /* PTin added */
+        if (index < 0 || index >= NUM_COS(unit))
+        {
+          PT_LOG_CRITIC(LOG_CTX_SDK, "assert(...): unit=%d port=%d reg=%d index=%d NUM_COS=%d SOC_REG_INFO(unit,reg).regtype=%d instance_mask=0x%x",
+                        unit, port, reg, index, NUM_COS(unit), SOC_REG_INFO(unit,reg).regtype, instance_mask);
+          PT_LOG_CRITIC(LOG_CTX_SDK, "assert(...): {phy_port=%d block=%d pindex=%d} portblktype=%d regblktype=%d SOC_REG_FIRST_BLK_TYPE=%d SOC_BLOCK_IN_LIST=%d",
+                        phy_port, block, pindex, portblktype, regblktype, SOC_REG_FIRST_BLK_TYPE(regblktype), SOC_BLOCK_IN_LIST(regblktype,portblktype));
+        }
         assert(index >= 0 && index < NUM_COS(unit));
         pindex = index;
         index = 0;
@@ -4669,6 +4710,11 @@
         pindex = 0;
         break;
     default:
+        /* PTin added */
+        PT_LOG_CRITIC(LOG_CTX_SDK, "assert(0): unit=%d port=%d reg=%d index=%d NUM_COS=%d SOC_REG_INFO.regtype=%d instance_mask=0x%x",
+                      unit, port, reg, index, NUM_COS(unit), SOC_REG_INFO(unit,reg).regtype, instance_mask);
+        PT_LOG_CRITIC(LOG_CTX_SDK, "assert(0): {phy_port=%d block=%d pindex=%d} portblktype=%d regblktype=%d SOC_REG_FIRST_BLK_TYPE=%d SOC_BLOCK_IN_LIST=%d",
+                      phy_port, block, pindex, portblktype, regblktype, SOC_REG_FIRST_BLK_TYPE(regblktype), SOC_BLOCK_IN_LIST(regblktype,portblktype));
         assert(0); /* unknown register type */
         break;
     }
@@ -4690,6 +4736,14 @@
     }
     
     if (SOC_REG_IS_ARRAY(unit, reg)) {
+        /* PTin added */
+        if (index < 0 || index > SOC_REG_NUMELS(unit, reg))
+        {
+          PT_LOG_CRITIC(LOG_CTX_SDK, "assert(...): unit=%d port=%d reg=%d index=%d SOC_REG_NUMELS=%d SOC_REG_INFO.regtype=%d instance_mask=0x%x",
+                        unit, port, reg, index, SOC_REG_NUMELS(unit,reg), SOC_REG_INFO(unit,reg).regtype, instance_mask);
+          PT_LOG_CRITIC(LOG_CTX_SDK, "assert(...): {phy_port=%d block=%d pindex=%d} portblktype=%d regblktype=%d SOC_REG_FIRST_BLK_TYPE=%d SOC_BLOCK_IN_LIST=%d",
+                        phy_port, block, pindex, portblktype, regblktype, SOC_REG_FIRST_BLK_TYPE(regblktype), SOC_BLOCK_IN_LIST(regblktype,portblktype));
+        }
         assert(index >= SOC_REG_INFO(unit, reg).first_array_index && index < SOC_REG_NUMELS(unit, reg) + SOC_REG_INFO(unit, reg).first_array_index);
 #if defined(BCM_SABER2_SUPPORT)
         if (SOC_IS_SABER2(unit) && block == OAMP_BLOCK(unit)) {
@@ -4700,6 +4754,14 @@
         base += (index - SOC_REG_INFO(unit, reg).first_array_index)*SOC_REG_ELEM_SKIP(unit, reg);
         }
     } else if (index && SOC_REG_ARRAY(unit, reg)) {
+        /* PTin added */
+        if (index < 0 || index > SOC_REG_NUMELS(unit, reg))
+        {
+          PT_LOG_CRITIC(LOG_CTX_SDK, "assert(...): unit=%d port=%d reg=%d index=%d SOC_REG_NUMELS=%d SOC_REG_INFO.regtype=%d instance_mask=0x%x",
+                        unit, port, reg, index, SOC_REG_NUMELS(unit,reg), SOC_REG_INFO(unit,reg).regtype, instance_mask);
+          PT_LOG_CRITIC(LOG_CTX_SDK, "assert(...): {phy_port=%d block=%d pindex=%d} portblktype=%d regblktype=%d SOC_REG_FIRST_BLK_TYPE=%d SOC_BLOCK_IN_LIST=%d",
+                        phy_port, block, pindex, portblktype, regblktype, SOC_REG_FIRST_BLK_TYPE(regblktype), SOC_BLOCK_IN_LIST(regblktype,portblktype));
+        }
         assert(index >= 0 && index < SOC_REG_NUMELS(unit, reg));
         if (index && SOC_REG_ARRAY2(unit, reg)) {
             base += ((index*2) << gransh);
Index: src/soc/common/sbusdma.c
===================================================================
--- src/soc/common/sbusdma.c	(revision 7711)
+++ src/soc/common/sbusdma.c	(revision 7714)
@@ -54,6 +54,8 @@
 #define RD_DMA_STAT_CLR                  3
 #endif 
 
+#include <stdio.h>
+
 typedef struct soc_sbusdma_reg_s {
     soc_sbusdma_reg_drv_t drv;
     soc_sbusdma_cmic_ch_t  ch;
Index: src/soc/esw/greyhound2.c
===================================================================
--- src/soc/esw/greyhound2.c	(revision 7711)
+++ src/soc/esw/greyhound2.c	(revision 7714)
@@ -16237,9 +16237,9 @@
     SOC_IF_ERROR_RETURN
         (soc_greyhound2_sbus_tsc_block(unit, phy_port, &blk));
 
-    LOG_INFO(BSL_LS_SOC_MII, (BSL_META_U(unit,
-             "_soc_greyhound2_tscx_reg_read[%d]: %d/%d/%d/%d\n"),
-             unit, phy_addr, phy_port, port, blk));
+    LOG_DEBUG(BSL_LS_SOC_MII, (BSL_META_U(unit,
+              "_soc_greyhound2_tscx_reg_read[%d]: %d/%d/%d/%d\n"),
+              unit, phy_addr, phy_port, port, blk));
     TSC_REG_ADDR_TSCID_SET(phy_reg, phy_addr);
     rv = soc_sbus_tsc_reg_read(unit, port, blk, phy_addr,
                                phy_reg, phy_data);
@@ -16270,9 +16270,9 @@
     SOC_IF_ERROR_RETURN
         (soc_greyhound2_sbus_tsc_block(unit, phy_port, &blk));
 
-    LOG_INFO(BSL_LS_SOC_MII, (BSL_META_U(unit,
-             "_soc_greyhound2_tscx_reg_write[%d]: %d/%d/%d/%d\n"),
-             unit, phy_addr, phy_port, port, blk));
+    LOG_DEBUG(BSL_LS_SOC_MII, (BSL_META_U(unit,
+              "_soc_greyhound2_tscx_reg_write[%d]: %d/%d/%d/%d\n"),
+              unit, phy_addr, phy_port, port, blk));
     TSC_REG_ADDR_TSCID_SET(phy_reg, phy_addr);
     rv = soc_sbus_tsc_reg_write(unit, port, blk, phy_addr,
                                 phy_reg, phy_data);
Index: src/soc/esw/l2xmsg.c
===================================================================
--- src/soc/esw/l2xmsg.c	(revision 7711)
+++ src/soc/esw/l2xmsg.c	(revision 7714)
@@ -1822,6 +1822,14 @@
 
 cleanup_exit:
 
+#ifdef LVL7_FIXUP
+    /* 
+     * Allow the thread to be terminated by soc_l2x_stop, but not due to errors 
+     * Reset the box if it fails for any reason
+     */
+    assert(soc->l2x_interval == 0); /* PTin TODO: unknown reason for a single DMA access error during boot-up */
+#endif
+
     (void)sal_sem_take(soc->l2x_lock, sal_sem_FOREVER);
 
     if (chunk_buf != NULL) {
Index: src/soc/esw/katana2.c
===================================================================
--- src/soc/esw/katana2.c	(revision 7711)
+++ src/soc/esw/katana2.c	(revision 7714)
@@ -62,6 +62,11 @@
 #include <soc/metrolite.h>
 #endif
 
+/* PTin added */
+//#define EXT_MEM_Q_MIN_CELL          8
+//#define EXT_MEM_Q_SHARED_ALPHA_CELL 1
+/* PTin end */
+
 #ifdef BCM_WARM_BOOT_SUPPORT
 
 #define KT2_MAX_TDM_SLOTS_VER_1_1         128
@@ -9589,6 +9594,7 @@
      soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                          &mmu_thdo_qconfig_cell_entry, 
                          Q_SHARED_LIMIT_CELLf, 7);
+
      soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                          &mmu_thdo_qconfig_cell_entry, 
                          Q_LIMIT_DYNAMIC_CELLf, 1);
@@ -11487,12 +11493,15 @@
     if ((_soc_kt2_mmu_params.lossless_mode_d_c == 0) ||
          _soc_kt2_mmu_params.packing_mode_d_c) { 
         if (_soc_kt2_mmu_params.extbuf_used_d_c) {
-            output_port_threshold->min_grntd_res_queue_cells_ext_buff = 
-                  _soc_kt2_mmu_params.mmu_ext_buf_cell_size == 2880 ?
-                  12 : /* LCM of all possible cell usage */
+            /* PTin modified */
+            #ifdef EXT_MEM_Q_MIN_CELL
+            output_port_threshold->min_grntd_res_queue_cells_ext_buff = EXT_MEM_Q_MIN_CELL;
+            #else
+            output_port_threshold->min_grntd_res_queue_cells_ext_buff =
                   ceil_func((output_port_threshold->
                              min_grntd_res_queue_cells_int_buff),
                             (general_info->ratio_of_ext_buff_to_int_buff_size));
+            #endif
         }
     }
 
@@ -13785,6 +13794,9 @@
                  soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                      &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf, 
                      temp_val);
+                 /* PTin added */
+                 /*soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
+                     &mmu_thdo_qconfig_cell_entry, Q_SHARED_ALPHA_CELLf, 1);*/
 
                  if ((buf_queue->pool_scale != -1) && 
                          mmu_config_enabled) {
@@ -13934,6 +13946,11 @@
                  soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                      &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf, 
                      temp_val);
+                 /* PTin added */
+                 #if 0 //def EXT_MEM_Q_SHARED_ALPHA_CELL
+                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
+                    &mmu_thdo_qconfig_cell_entry, Q_SHARED_ALPHA_CELLf, EXT_MEM_Q_SHARED_ALPHA_CELL);
+                 #endif
 
                  /* C415:THDO_QCONFIG_CELL.Q_LIMIT_DYNAMIC_CELL
                          =IF($C$14, 0, 1) */
Index: src/soc/esw/hash.c
===================================================================
--- src/soc/esw/hash.c	(revision 7711)
+++ src/soc/esw/hash.c	(revision 7714)
@@ -1536,6 +1536,41 @@
     return _soc_hash_generic_entry_to_key(unit, entry, key, L2Xm, field_list);
 }
 
+#ifdef LVL7_FIXUP
+static int
+_soc_tr2_l2x_scc_entry_to_key(int unit, uint32 *e, uint8 *key)
+{
+    int ovid, key_type = 1;
+
+    /* Key type 0x1 (SINGLE_CROSS_CONNECT) Key = {OVID} */
+    ovid = soc_L2Xm_field32_get(unit, e, OVIDf);
+
+    /* key[0] has 2 bits of padding of byte alignment */
+    key[0] = ((ovid << 4) & 0xf0) | ((key_type << 2) & 0x0c);
+    key[1] = (ovid >> 4) & 0xff;
+
+    return (64);
+}
+
+static int
+_soc_tr2_l2x_dcc_entry_to_key(int unit, uint32 *e, uint8 *key)
+{
+    int ivid, ovid, key_type = 2;
+
+    /* Key type 0x2 (DOUBLE_CROSS_CONNECT) Key = {OVID, IVOD} */
+    ovid = soc_L2Xm_field32_get(unit, e, OVIDf);
+    ivid = soc_L2Xm_field32_get(unit, e, IVIDf);
+
+    /* key[0] has 2 bits of padding of byte alignment */
+    key[0] = ((key_type << 2)& 0xc) | ((ovid << 4) & 0xf0);
+    key[1] = ((ovid >> 4) & 0xff); 
+    key[2] = (ivid & 0xff);
+    key[3] = ((ivid >> 8) & 0xf);
+
+    return (64);
+}
+#endif
+
 STATIC int
 _soc_tr_l2x_vfi_entry_to_key(int unit, uint32 *entry, uint8 *key)
 {
@@ -1686,9 +1721,27 @@
     case TR_L2_HASH_KEY_TYPE_BRIDGE:
         return _soc_tr_l2x_bridge_entry_to_key(unit, entry, key);
     case TR_L2_HASH_KEY_TYPE_SINGLE_CROSS_CONNECT:
+#ifndef LVL7_FIXUP
         return _soc_tr_l2x_scc_entry_to_key(unit, entry, key);
+#else
+            if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit)/* || SOC_IS_VALKYRIE2(unit)*/) {    /* PTin modified */
+                return _soc_tr2_l2x_scc_entry_to_key(unit, entry, key);
+            }
+            else {
+                return _soc_tr_l2x_scc_entry_to_key(unit, entry, key);
+            }
+#endif
     case TR_L2_HASH_KEY_TYPE_DOUBLE_CROSS_CONNECT:
+#ifndef LVL7_FIXUP
         return _soc_tr_l2x_dcc_entry_to_key(unit, entry, key);
+#else
+            if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit)/* || SOC_IS_VALKYRIE2(unit)*/) {    /* PTin modified */
+                return _soc_tr2_l2x_dcc_entry_to_key(unit, entry, key);
+            }
+            else {
+                return _soc_tr_l2x_dcc_entry_to_key(unit, entry, key);
+            }
+#endif
     case TR_L2_HASH_KEY_TYPE_VFI:
         return _soc_tr_l2x_vfi_entry_to_key(unit, entry, key);
 #ifdef BCM_TRIDENT_SUPPORT
Index: src/soc/esw/drv.c
===================================================================
--- src/soc/esw/drv.c	(revision 7711)
+++ src/soc/esw/drv.c	(revision 7714)
@@ -6,6 +6,9 @@
  * StrataSwitch driver
  */
 
+/* PTin added: PCIe */
+#include "logger.h"
+
 #include <shared/bsl.h>
 
 #include <stddef.h>
@@ -9724,6 +9727,7 @@
             } else
 #endif
             {
+                PT_LOG_INFO(LOG_CTX_SDK, "Going to make PCIe bw adjustment...");
                 SOC_IF_ERROR_RETURN(cmic_pcie_cdr_bw_adj(unit, pcie_phy_addr));
             }
         }
@@ -10247,6 +10251,21 @@
             }
         }
 #endif /* BCM_TRIUMPH_SUPPORT */
+#if defined(BCM_TRIUMPH2_SUPPORT)
+        if (SOC_IS_TRIUMPH2(unit) || SOC_IS_VALKYRIE2(unit)) {
+            if (mem == MMU_WRED_THD_0_CELLm ||
+                mem == MMU_WRED_THD_1_CELLm ||
+                mem == MMU_WRED_THD_0_PACKETm ||
+                mem == MMU_WRED_THD_1_PACKETm ||
+                mem == MMU_WRED_PORT_THD_0_CELLm ||
+                mem == MMU_WRED_PORT_THD_1_CELLm ||
+                mem == MMU_WRED_PORT_THD_0_PACKETm ||
+                mem == MMU_WRED_PORT_THD_1_PACKETm ) {
+                SOC_MEM_INFO(unit, mem).flags |= SOC_MEM_FLAG_CACHABLE;
+                SOC_MEM_INFO(unit, mem).flags |= SOC_MEM_FLAG_SER_CACHE_RESTORE;
+            }
+        }
+#endif /* BCM_TRIUMPH2_SUPPORT */
 #ifdef  BCM_VALKYRIE_SUPPORT
        if (SOC_IS_VALKYRIE(unit)) {
            if (mem == FP_TCAMm || mem == VFP_TCAMm) {
@@ -19220,6 +19239,8 @@
             msi_en = 0;
         }
 
+        PT_LOG_NOTICE(LOG_CTX_SDK, "MSI enable=%d", msi_en);
+
         addr = CMIC_CMCx_PCIE_MISCEL_OFFSET(SOC_PCI_CMC(unit));
         rval = soc_pci_read(unit, addr);
 
Index: src/soc/esw/katana2/cosq.c
===================================================================
--- src/soc/esw/katana2/cosq.c	(revision 7711)
+++ src/soc/esw/katana2/cosq.c	(revision 7714)
@@ -27,6 +27,10 @@
 #endif
 #endif
 
+#if (__GNUC__ >= 4) /* PTin added */
+#pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
 #define _SOC_COE_PORT_TYPE_CASCADED             4
 #define _SOC_COE_PORT_TYPE_CASCADED_LINKPHY     0
 #define _SOC_COE_PORT_TYPE_CASCADED_SUBTAG      1
Index: src/soc/esw/trident.c
===================================================================
--- src/soc/esw/trident.c	(revision 7711)
+++ src/soc/esw/trident.c	(revision 7714)
@@ -8239,7 +8239,7 @@
     divisor = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVISOR, 40);
     dividend = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVIDEND, 1);
     rval = 0;
-    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVISORf, divisor);
+    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVISORf, divisor*2); /* PTin changed: LTX patch */
     soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVIDENDf, dividend);
     /* coverity[result_independent_of_operands] */
     SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUSTr(unit, rval));
Index: src/soc/esw/triumph2.c
===================================================================
--- src/soc/esw/triumph2.c	(revision 7711)
+++ src/soc/esw/triumph2.c	(revision 7714)
@@ -2511,9 +2511,17 @@
                     }
                     break;
                     case _SOC_PARITY_INFO_TYPE_MMUWRED:
+                    /* CSP#1108422: Start */
+                    #if 0
                     SOC_IF_ERROR_RETURN(
                         _soc_triumph2_parity_process_mmuwred(unit, &info[table],
                                                              block_port, msg));
+                    #else
+                    SOC_IF_ERROR_RETURN(
+                        _soc_triumph2_parity_process_mmuwred(unit, &info[table],
+                                                             block_port, msg));
+                    #endif
+                    /* CSP#1108422: End */
                     break;
                     case _SOC_PARITY_INFO_TYPE_MMUMTRO:
                     SOC_IF_ERROR_RETURN(
Index: src/soc/phy/serdescombo65.c
===================================================================
--- src/soc/phy/serdescombo65.c	(revision 7711)
+++ src/soc/phy/serdescombo65.c	(revision 7714)
@@ -1206,7 +1206,11 @@
         sal_memcpy(cfg, &pc->fiber, sizeof (*cfg));
         return SOC_E_NONE;
     default:
+#ifdef LVL7_FIXUP
+        return SOC_E_UNAVAIL;
+#else
         return SOC_E_PARAM;
+#endif
     }
 }
 
Index: src/soc/phy/phy8706.c
===================================================================
--- src/soc/phy/phy8706.c	(revision 7711)
+++ src/soc/phy/phy8706.c	(revision 7714)
@@ -26,6 +26,8 @@
 #include <soc/phy/phyctrl.h>
 #include <soc/phy/drv.h>
 
+///LTX for printf
+#include <stdio.h>
 
 #include "phyident.h"
 #include "phyreg.h"
@@ -511,6 +513,9 @@
 STATIC int
 _8726_rom_load(int unit, int port, phy_ctrl_t *pc)
 {
+	printf("LTX: aborting _8726_rom_load\n");
+    return SOC_E_NONE;
+
     SOC_IF_ERROR_RETURN
         (WRITE_PHY8706_PMA_PMD_REG(unit, pc, 0xca85, 0x0001));
     sal_usleep(1000);
@@ -552,7 +557,8 @@
         pc->write(unit, phy_addr+i,SOC_PHY_CLAUSE45_ADDR(1, 0xc840), 0x000C);
 
         /* Set bit SPI Download (15), SER Boot (14) And SPI Port Enable (0) In C848, SPI_PORT_CTRL */
-        pc->write(unit, phy_addr+i,SOC_PHY_CLAUSE45_ADDR(1, 0xc848), 0xC0F1);
+//        pc->write(unit, phy_addr+i,SOC_PHY_CLAUSE45_ADDR(1, 0xc848), 0xC0F1);
+        pc->write(unit, phy_addr+i,SOC_PHY_CLAUSE45_ADDR(1, 0xc848), 0x80F1);
     }
 
     /* Place Micro in reset */
@@ -853,8 +859,13 @@
     
     PHY_FLAGS_SET(unit, port,  PHY_FLAGS_FIBER | PHY_FLAGS_C45);
 
-    phy_ext_rom_boot = soc_property_port_get(unit, port, 
-                                            spn_PHY_EXT_ROM_BOOT, 1);
+    ///LTX
+//    phy_ext_rom_boot = soc_property_port_get(unit, port,
+//                                            spn_PHY_EXT_ROM_BOOT, 1);
+    phy_ext_rom_boot=1;
+
+
+
     SOC_IF_ERROR_RETURN
         (READ_PHY8706_PMA_PMD_REG(unit, pc, MII_PHY_ID1_REG, &phyid1));
 
@@ -1335,6 +1346,16 @@
         }
     }
 
+    ///LTX
+
+    printf("LTX: Hacking phy_8706_init to enable tx on address 0xc800\n");
+
+    (PHY8706_REG_WRITE(unit, pc,
+                      SOC_PHY_CLAUSE45_ADDR(PHY8706_C45_DEV_PMA_PMD,
+                                            0xC800),
+                      0xFF00));
+
+
     /* Enable Squelch */
     SOC_IF_ERROR_RETURN(_phy_8706_squelch_enable(unit, port, TRUE));
 
@@ -2355,6 +2376,7 @@
 
     if (PHY_IS_BCM5942(pc)) {
         SOC_IF_ERROR_RETURN
+//        (_phy_8706_lb_set(unit, port, enable));
             (_phy_5942_lb_set(unit, port, enable));
     } else {
         SOC_IF_ERROR_RETURN
@@ -3149,9 +3171,12 @@
     if (NULL != int_pc) {
         if (PHY_IS_BCM5942(pc)) {
             SOC_IF_ERROR_RETURN
-                (PHY_INTERFACE_SET(int_pc->pd, unit, port, SOC_PORT_IF_SFI));
+//            (PHY_INTERFACE_SET(int_pc->pd, unit, port, SOC_PORT_IF_XFI));
+                (PHY_INTERFACE_SET(int_pc->pd, unit, port, SOC_PORT_IF_XFI));
+            printf("LTX: internal phy on port %d set to SOC_PORT_IF_XFI\n", port);
             SOC_IF_ERROR_RETURN
                 (PHY_AUTO_NEGOTIATE_SET (int_pc->pd, unit, port, 0));
+            printf("LTX: internal phy on port %d set to AUTONEG OFF\n", port);
         }
         rv = PHY_SPEED_SET(int_pc->pd, unit, port, speed);
     }
@@ -3173,6 +3198,8 @@
 {
     phy_ctrl_t  *pc;
 
+    printf("LTX: Called phy_8706_speed_set for port %d\n", port);
+
     pc = EXT_PHY_SW_STATE(unit, port);
 
     SOC_IF_ERROR_RETURN
Index: src/soc/phy/viper.c
===================================================================
--- src/soc/phy/viper.c	(revision 7711)
+++ src/soc/phy/viper.c	(revision 7714)
@@ -1539,10 +1539,10 @@
         ability->flags     = SOC_PA_ABILITY_NONE;
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META_U(pc->unit,
-                         "phy_viper_ability_local_get:unit=%d p=%d sp=%08x\n"),
-              unit, port, ability->speed_full_duplex));
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+              (BSL_META_U(pc->unit,
+                          "phy_viper_ability_local_get:unit=%d p=%d sp=%08x\n"),
+               unit, port, ability->speed_full_duplex));
     return (SOC_E_NONE);
 }
 
Index: src/soc/phy/wc40_config.c
===================================================================
--- src/soc/phy/wc40_config.c	(revision 7711)
+++ src/soc/phy/wc40_config.c	(revision 7714)
@@ -293,17 +293,17 @@
     pCfg->fw_dfe = SOC_PHY_DFE_AUTO;
 
     if (PHY_INDEPENDENT_LANE_MODE(unit, port)) {
-        pCfg->cl73an     = WC40_CL73_AND_CL73BAM; /*WC40_CL73_WO_CL73BAM; */
+        pCfg->cl73an     = WC40_CL73_AUTONEG_MODE; /*WC40_CL73_AND_CL73BAM;*/     /* PTin modified: WC40 */
     } else {
        if (IS_HG_PORT(unit, port)) {
            pCfg->cl73an     = FALSE;
        } else {
-           pCfg->cl73an     = WC40_CL73_AND_CL73BAM;
+           pCfg->cl73an     = WC40_CL73_AUTONEG_MODE; /*WC40_CL73_AND_CL73BAM;*/  /* PTin modified: WC40 */
        }
     }
    
     /* Default setting for CL37 */ 
-    pCfg->cl37an     = WC40_CL37_AND_CL37BAM; 
+    pCfg->cl37an     = WC40_CL73_AUTONEG_MODE; /*WC40_CL73_AND_CL73BAM;*/         /* PTin modified: WC40 */
 
     if ((PHY_FIBER_MODE(unit, port) && !PHY_EXTERNAL_MODE(unit, port)) ||
         PHY_PASSTHRU_MODE(unit, port) ||
Index: src/soc/phy/wc40.c
===================================================================
--- src/soc/phy/wc40.c	(revision 7711)
+++ src/soc/phy/wc40.c	(revision 7714)
@@ -28,6 +28,8 @@
 #include <soc/scache.h>
 #endif
 
+#define PTIN_PRBS_ALWAYS_CL49 1
+
 #include "phyreg.h"
 #include "phyfege.h"
 #include "phynull.h"
@@ -5578,10 +5582,11 @@
             *speed = 0;
             break;
     }
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META_U(unit,
-                         "_phy_wc40_interlaken_speed_get: u=%d p=%d LANECTRL1r %04x speed= %d\n"),
-              unit, port,data16, *speed));
+    /* PTin modified: logs */
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+                  (BSL_META_U(unit,
+                              "_phy_wc40_interlaken_speed_get: u=%d p=%d LANECTRL1r %04x speed= %d\n"),
+                   unit, port,data16, *speed));
     return SOC_E_NONE;
 }
 
@@ -6804,7 +6809,7 @@
     }
     ability->pause = pause;
 
-    LOG_INFO(BSL_LS_SOC_PHY,
+    LOG_VERBOSE(BSL_LS_SOC_PHY,
              (BSL_META_U(unit,
                          "_phy_wc40_c73_adv_local_get: u=%d p=%d pause=%08x speeds=%04x\n"),
               unit, port, pause, speeds));
@@ -7201,7 +7206,7 @@
         ability->fec = SOC_PA_FEC_NONE;
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
+    LOG_VERBOSE(BSL_LS_SOC_PHY,
              (BSL_META_U(unit,
                          "phy_wc40_ability_advert_get:unit=%d p=%d pause=%08x sp=%08x\n"),
               unit, port, ability->pause, ability->speed_full_duplex));
@@ -7850,10 +7855,11 @@
         ability->flags     = SOC_PA_AUTONEG;
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META_U(unit,
-                         "phy_wc40_ability_local_get:unit=%d p=%d sp=%08x\n"),
-              unit, port, ability->speed_full_duplex));
+    /* PTin modified: logs */
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+                  (BSL_META_U(unit,
+                              "phy_wc40_ability_local_get:unit=%d p=%d sp=%08x\n"),
+                   unit, port, ability->speed_full_duplex));
 
     return (SOC_E_NONE);
 }
@@ -8007,8 +8013,10 @@
 {
     uint16      data16;
     uint16      mask16;
+    #if (!PTIN_PRBS_ALWAYS_CL49)
     int an;
     int an_done;
+    #endif
     soc_port_if_t intf;
     int prbs_lanes = 0;
     int lane;
@@ -8018,6 +8026,8 @@
      * This way the FIR settings negotiated thru CL72 is preserved
      */
 
+    /* PTin modified: PRBS */
+    #if (!PTIN_PRBS_ALWAYS_CL49)
     if (DEV_CTRL_PTR(pc)->prbs.type != WC40_PRBS_TYPE_CL49) {
         SOC_IF_ERROR_RETURN
             (phy_wc40_an_get(unit,port,&an,&an_done));
@@ -8031,6 +8041,12 @@
             }
         }
     }
+    #else
+    /* check interface */
+    SOC_IF_ERROR_RETURN
+        (phy_wc40_interface_get(unit,port,&intf));
+    DEV_CTRL_PTR(pc)->prbs.type = WC40_PRBS_TYPE_CL49;
+    #endif
 
     if (DEV_CTRL_PTR(pc)->prbs.type == WC40_PRBS_TYPE_CL49) {
         SOC_IF_ERROR_RETURN
@@ -8049,6 +8065,11 @@
             DEV_CTRL_PTR(pc)->prbs.type = 0;
         } 
 
+        /* PTin added: PRBS */
+        #if (PTIN_PRBS_ALWAYS_CL49)
+        if (intf==SOC_PORT_IF_KR4 || intf==SOC_PORT_IF_KR)
+        {
+        #endif
         if (intf == SOC_PORT_IF_KR4) {
             SOC_IF_ERROR_RETURN
                 (MODIFY_WC40_SERDESDIGITAL_MISC1r(unit, pc, 0x00, 
@@ -8102,6 +8123,17 @@
         SOC_IF_ERROR_RETURN
             (READ_WC40_AN_IEEE0BLK_AN_IEEECONTROL1r(unit, pc, 0x00, 
                                           &data16));
+
+        /* PTin added: PRBS */
+        #if (PTIN_PRBS_ALWAYS_CL49)
+        }
+        else if (enable)
+        {
+          SOC_IF_ERROR_RETURN
+              (WRITE_WC40_PCS_IEEE2BLK_PCS_TPCONTROLr(unit, pc, 0x00, WC40_PRBS_CL49_POLY31));
+        }
+        #endif
+
         /* not to enable PRBS here. Once PRBS is enabled, the link will go down.
          * Autoneg will be restarted by link partner and Tx settings will be lost.
          * It will be enabled in get function when first time called 
Index: src/soc/phy/wcmod/src/wcmod.c
===================================================================
--- src/soc/phy/wcmod/src/wcmod.c	(revision 7711)
+++ src/soc/phy/wcmod/src/wcmod.c	(revision 7714)
@@ -6428,6 +6435,11 @@
                                                                                 
     pc->fiber.autoneg_enable = an;
                                                                                 
+    LOG_INFO(BSL_LS_SOC_PHY,
+             (BSL_META_U(pc->unit,
+                         "phy_wcmod_xgxs16g1l_an_set: Successfully set u=%d p=%d an=%d\n"),
+              unit, port, an));
+
     return SOC_E_NONE;
 }
 
@@ -7016,10 +7028,11 @@
         ability->flags     = 0 ;    /*SOC_PA_AUTONEG */
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META_U(pc->unit,
-                         "phy_wc_xgxs16g11_ability_local_get:unit=%d p=%d sp=%08x\n"),
-              unit, pc->port, ability->speed_full_duplex));
+    /* PTin modified: logs */
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+                  (BSL_META_U(pc->unit,
+                              "phy_wc_xgxs16g11_ability_local_get:unit=%d p=%d sp=%08x\n"),
+                   unit, pc->port, ability->speed_full_duplex));
 
     return (SOC_E_NONE);
 }
@@ -7645,7 +7658,7 @@
     }
     ability->pause = pause;
 
-    LOG_INFO(BSL_LS_SOC_PHY,
+    LOG_VERBOSE(BSL_LS_SOC_PHY,
              (BSL_META_U(pc->unit,
                          "_phy_wcmod_c73_adv_local_get: u=%d p=%d pause=%08x speeds=%04x\n"),
               unit, port, pause, speeds));
@@ -8063,7 +8076,7 @@
         ability->fec = SOC_PA_FEC_NONE;
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
+    LOG_VERBOSE(BSL_LS_SOC_PHY,
              (BSL_META_U(pc->unit,
                          "phy_wcmod_ability_advert_get:unit=%d p=%d pause=%08x sp=%08x max_spd=%0d\n"),
               unit, port, ability->pause, ability->speed_full_duplex, pc->speed_max));
@@ -8837,10 +8850,11 @@
         ability->flags     = SOC_PA_AUTONEG;
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META_U(pc->unit,
-                         "phy_wcmod_ability_local_get:unit=%d p=%d sp=%08x\n"),
-              unit, port, ability->speed_full_duplex));
+    /* PTin modified: logs */
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+                  (BSL_META_U(pc->unit,
+                              "phy_wcmod_ability_local_get:unit=%d p=%d sp=%08x\n"),
+                   unit, port, ability->speed_full_duplex));
 
     return (SOC_E_NONE);
 }
Index: src/soc/phy/hl65.c
===================================================================
--- src/soc/phy/hl65.c	(revision 7711)
+++ src/soc/phy/hl65.c	(revision 7714)
@@ -2094,13 +2094,13 @@
                 break;
         }
 
-        LOG_INFO(BSL_LS_SOC_PHY,
-                 (BSL_META_U(unit,
-                             "phy_hl65_speed_get: u=%d p=%d GP_STATUS_TOPANSTATUS1 %04x speed= %d\n"),
-                  unit, port,
-                  ((xgxs_stat & GP_STATUS_XGXSSTATUS1_ACTUAL_SPEED_LN0_MASK) >>
-                  GP_STATUS_XGXSSTATUS1_ACTUAL_SPEED_LN0_SHIFT), *speed));
-
+        /* PTin modified: logs */
+        LOG_DEBUG(BSL_LS_SOC_PHY,
+                      (BSL_META_U(unit,
+                                  "phy_hl65_speed_get: u=%d p=%d GP_STATUS_TOPANSTATUS1 %04x speed= %d\n"),
+                       unit, port,
+                       ((xgxs_stat & GP_STATUS_XGXSSTATUS1_ACTUAL_SPEED_LN0_MASK) >>
+                        GP_STATUS_XGXSSTATUS1_ACTUAL_SPEED_LN0_SHIFT), *speed));
     }
     return SOC_E_NONE;
 }
Index: src/soc/phy/phyident.c
===================================================================
--- src/soc/phy/phyident.c	(revision 7711)
+++ src/soc/phy/phyident.c	(revision 7714)
@@ -141,8 +141,13 @@
 #endif /* INCLUDE_PHY_XGXS6 */
 
 #if defined(INCLUDE_PHY_8706)
+#ifdef LVL7_FIXUP
+ int _chk_8706(int unit, soc_port_t port, soc_phy_table_t *my_entry,
+			   uint16 phy_id0, uint16 phy_id1, soc_phy_info_t *pi);
+#else
 static int _chk_8706(int unit, soc_port_t port, soc_phy_table_t *my_entry,
                      uint16 phy_id0, uint16 phy_id1, soc_phy_info_t *pi);
+#endif
 #endif /* INCLUDE_PHY_8706 */
 
 #if defined(INCLUDE_PHY_8072)
@@ -5298,7 +5303,11 @@
 }
 
 #if defined(INCLUDE_PHY_8706)
-static int
+#ifndef LVL7_FIXUP
+static 
+#endif
+int
+//static int
 _chk_8706(int unit, soc_port_t port, soc_phy_table_t *my_entry,
              uint16 phy_id0, uint16 phy_id1, soc_phy_info_t *pi)
 {
@@ -7181,8 +7190,8 @@
     model     = PHY_MODEL(phy_id0, phy_id1);
     rev_map   = 1 << PHY_REV(phy_id0, phy_id1);
 
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META("phy_id0 = %04x phy_id1 %04x oui = %04x model = %04x rev_map = %04x\n"),
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+              (BSL_META("phy_id0 = %04x phy_id1 %04x oui = %04x model = %04x rev_map = %04x\n"),
               phy_id0, phy_id1, oui, model, rev_map));
     for (i = 0; i < COUNTOF(phy_id_map); i++) {
         pm = &phy_id_map[i];
Index: src/soc/phy/wc40_extra.h
===================================================================
--- src/soc/phy/wc40_extra.h	(revision 7711)
+++ src/soc/phy/wc40_extra.h	(revision 7714)
@@ -184,6 +184,7 @@
 #define WC40_CL73_KR2          3
 #define WC40_CL73_WO_CL73BAM   2
 #define WC40_CL73_AND_CL73BAM  1
+#define WC40_CL73_AUTONEG_MODE WC40_CL73_WO_CL73BAM /* PTin added: WC40 */
 
 #define WC40_CL37_WO_CL37BAM   2
 #define WC40_CL37_AND_CL37BAM  1
Index: src/soc/phy/tsce.c
===================================================================
--- src/soc/phy/tsce.c	(revision 7711)
+++ src/soc/phy/tsce.c	(revision 7714)
@@ -2892,10 +2892,10 @@
         ability->flags     = SOC_PA_AUTONEG;
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META_U(pc->unit,
-                         "phy_tsce_ability_local_get:unit=%d p=%d sp=%08x\n"),
-              unit, port, ability->speed_full_duplex));
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+              (BSL_META_U(pc->unit,
+                          "phy_tsce_ability_local_get:unit=%d p=%d sp=%08x\n"),
+               unit, port, ability->speed_full_duplex));
     return (SOC_E_NONE);
 }
 
Index: src/soc/phy/tscf.c
===================================================================
--- src/soc/phy/tscf.c	(revision 7711)
+++ src/soc/phy/tscf.c	(revision 7714)
@@ -3029,10 +3029,10 @@
         ability->flags     = SOC_PA_AUTONEG;
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META_U(pc->unit,
-                         "phy_tscf_ability_local_get:unit=%d p=%d sp=%08x\n"),
-              unit, port, ability->speed_full_duplex));
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+              (BSL_META_U(pc->unit,
+                          "phy_tscf_ability_local_get:unit=%d p=%d sp=%08x\n"),
+               unit, port, ability->speed_full_duplex));
     return (SOC_E_NONE);
 }
 
