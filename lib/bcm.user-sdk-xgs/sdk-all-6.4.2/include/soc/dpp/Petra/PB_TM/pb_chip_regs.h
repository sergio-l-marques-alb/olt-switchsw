/* $Id: soc_pb_chip_regs.h,v 1.8 Broadcom SDK $
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
*/

#ifndef __SOC_PB_CHIP_REGS_INCLUDED__
/* { */
#define __SOC_PB_CHIP_REGS_INCLUDED__

/*************
 * INCLUDES  *
 *************/
/* { */

#include <soc/dpp/SAND/Utils/sand_header.h>
#include <soc/dpp/SAND/Utils/sand_framework.h>

#include <soc/dpp/Petra/petra_chip_defines.h>
#include <soc/dpp/Petra/petra_api_general.h>


/* } */

/*************
 * DEFINES   *
 *************/
/* { */
#define  SOC_PB_BLK_NOF_INSTANCES_ECI                 1
#define  SOC_PB_BLK_NOF_INSTANCES_OLP                 1
#define  SOC_PB_BLK_NOF_INSTANCES_NIF                 2
#define  SOC_PB_BLK_NOF_INSTANCES_MAL                 16
#define  SOC_PB_BLK_NOF_INSTANCES_NBI                 1
#define  SOC_PB_BLK_NOF_INSTANCES_IRE                 1
#define  SOC_PB_BLK_NOF_INSTANCES_IDR                 1
#define  SOC_PB_BLK_NOF_INSTANCES_IRR                 1
#define  SOC_PB_BLK_NOF_INSTANCES_IHP                 1
#define  SOC_PB_BLK_NOF_INSTANCES_IHB                 1
#define  SOC_PB_BLK_NOF_INSTANCES_IQM                 1
#define  SOC_PB_BLK_NOF_INSTANCES_QDR                 1
#define  SOC_PB_BLK_NOF_INSTANCES_IPS                 1
#define  SOC_PB_BLK_NOF_INSTANCES_IPT                 1
#define  SOC_PB_BLK_NOF_INSTANCES_MMU                 1
#define  SOC_PB_BLK_NOF_INSTANCES_DRC                 6
#define  SOC_PB_BLK_NOF_INSTANCES_DPI                 6
#define  SOC_PB_BLK_NOF_INSTANCES_FDR                 1
#define  SOC_PB_BLK_NOF_INSTANCES_FDT                 1
#define  SOC_PB_BLK_NOF_INSTANCES_FCR                 1
#define  SOC_PB_BLK_NOF_INSTANCES_FCT                 1
#define  SOC_PB_BLK_NOF_INSTANCES_MESH_TOPOLOGY       1
#define  SOC_PB_BLK_NOF_INSTANCES_RTP                 1
#define  SOC_PB_BLK_NOF_INSTANCES_FABRIC_MAC          3
#define  SOC_PB_BLK_NOF_INSTANCES_MSW                 1
#define  SOC_PB_BLK_NOF_INSTANCES_EGQ                 1
#define  SOC_PB_BLK_NOF_INSTANCES_EPNI                1
#define  SOC_PB_BLK_NOF_INSTANCES_CFC                 1
#define  SOC_PB_BLK_NOF_INSTANCES_SCH                 1
#define  SOC_PB_BLK_NOF_INSTANCES_SERDES              4
#define  SOC_PB_BLK_NOF_INSTANCES_MCC                 1
#define  SOC_PB_NIF_REGS_AUTO_NEG_CONFIG_REG_ARRAY_SIZE                                                 (3-0+1)
#define  SOC_PB_NIF_REGS_AUTO_NEG_STATUS_REG_ARRAY_SIZE                                                 (3-0+1)
#define  SOC_PB_NBI_REGS_RX_MLF_CONFIG_REG_ARRAY_SIZE                                                   (15-0+1)
#define  SOC_PB_NBI_REGS_RX_MLF_THRESHOLDS_CONFIG_REG_ARRAY_SIZE                                        (15-0+1)
#define  SOC_PB_NBI_REGS_TX_MLF_CONFIG_REG_ARRAY_SIZE                                                   (15-0+1)
#define  SOC_PB_NBI_REGS_RX_ILKN_CONTROL_REG_ARRAY_SIZE                                                 (1-0+1)
#define  SOC_PB_NBI_REGS_TX_ILKN_CONTROL_REG_ARRAY_SIZE                                                 (1-0+1)
#define  SOC_PB_NBI_REGS_TX_ILKN_RATE_LIMITER_CONFIG_REG_ARRAY_SIZE                                     (1-0+1)
#define  SOC_PB_NBI_REGS_ILKN_NUM_LANES_CONFIG_REG_ARRAY_SIZE                                           (1-0+1)
#define  SOC_PB_NBI_REGS_RX_MLF_STATUS_REG_ARRAY_SIZE                                                   (15-0+1)
#define  SOC_PB_NBI_REGS_RX_MLF_MAX_OCCUPANCY_REG_ARRAY_SIZE                                            (15-0+1)
#define  SOC_PB_NBI_REGS_TX_MLF_STATUS_REG_ARRAY_SIZE                                                   (15-0+1)
#define  SOC_PB_NBI_REGS_RX_ILKN_STATUS_REG_ARRAY_SIZE                                                  (1-0+1)
#define  SOC_PB_NBI_REGS_TX_ILKN_STATUS_REG_ARRAY_SIZE                                                  (1-0+1)
#define  SOC_PB_NBI_REGS_NUM_THROWN_BURSTS_COUNTER_RX_PORT_REG_ARRAY_SIZE                               (15-0+1)
#define  SOC_PB_NBI_REGS_BIST_FLOW_FIRST_DESCRIPTOR_REG_ARRAY_SIZE                                      (3-0+1)
#define  SOC_PB_NBI_REGS_BIST_FLOW_SECOND_DESCRIPTOR_REG_ARRAY_SIZE                                     (3-0+1)
#define  SOC_PB_IDR_REGS_MEMORY_INTERRUPT_REG_ARRAY_SIZE                                                (2-1+1)
#define  SOC_PB_IDR_REGS_MEMORY_INTERRUPT_REGISTER_MASK_REG_ARRAY_SIZE                                  (2-1+1)
#define  SOC_PB_IDR_REGS_RECEIVED_PACKETS_CNT_REG_ARRAY_SIZE                                            (3-0+1)
#define  SOC_PB_IDR_REGS_DISCARDED_PACKETS_CNT_REG_ARRAY_SIZE                                           (3-0+1)
#define  SOC_PB_IDR_REGS_RECEIVED_OCTETS_CNT_REG_ARRAY_SIZE                                             (3-0+1)
#define  SOC_PB_IDR_REGS_DISCARDED_OCTETS_CNT_REG_ARRAY_SIZE                                            (3-0+1)
#define  SOC_PB_IRR_REGS_MEMORY_INTERRUPT_REG_ARRAY_SIZE                                                (2-1+1)
#define  SOC_PB_IRR_REGS_MEMORY_INTERRUPT_REGISTER_MASK_REG_ARRAY_SIZE                                  (2-1+1)
#define  SOC_PB_IRR_REGS_RESEQUENCER_STATUS_REG_ARRAY_SIZE                                              (2-0+1)
#define  SOC_PB_IRR_REGS_RESEQUENCER_ERRORS_REG_ARRAY_SIZE                                              (2-0+1)
#define  SOC_PB_FCR_REGS_CONNECTIVITY_MAP_REGISTERS_REG_ARRAY_SIZE                                      (35-0+1)
#define  SOC_PB_ECI_UDR_REG_REG_NOF_REGS                                                                2
#define  SOC_PB_ECI_SCRATCH_PAD_REG_NOF_REGS                                                            2
#define  SOC_PB_ECI_EGRESS_PP_CONFIGURATION_REG_MULT_NOF_REGS                                           2
#define  SOC_PB_OLP_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_NIF_NIF_PTP1588_RESET_REG_MULT_NOF_REGS                                                 2
#define  SOC_PB_NIF_NIF_PTP1588_AUTO_INC_REG_MULT_NOF_REGS                                              2
#define  SOC_PB_NIF_NIF_PTP1588_AUTO_INC_READ_REG_MULT_NOF_REGS                                         2
#define  SOC_PB_NIF_MAC_LANE_FLOW_CONTROL_SOURCE_ADDR_REG_MULT_NOF_REGS                                 2
#define  SOC_PB_NBI_FC_CBFC_MAPPING_REG_NOF_REGS                                                        4
#define  SOC_PB_NBI_FC_BIST_CYCLE_REG_NOF_REGS                                                          2
#define  SOC_PB_NBI_NUM_THROWN_BURSTS_COUNTER_RX_PORT_REG_NOF_REGS                                      4
#define  SOC_PB_NBI_NUM_THROWN_BURSTS_COUNTER_RX_ILKN_PORT_REG_NOF_REGS                                 2
#define  SOC_PB_NBI_FIFO_STATUS_HISTOGRAM_PORT0_BIN_REG_NOF_REGS                                        4
#define  SOC_PB_NBI_FIFO_STATUS_HIST_NOF_PORTS					                                                2
#define  SOC_PB_NBI_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          4
#define  SOC_PB_NBI_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          4
#define  SOC_PB_NBI_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_NBI_FC_LLFC_STOP_TX_FORCE_REG_MULT_NOF_REGS                                             2
#define  SOC_PB_NBI_FC_LLFC_STOP_TX_EN_CFC_REG_MULT_NOF_REGS                                            2
#define  SOC_PB_NBI_FC_TX_GEN_LLFC_FORCE_REG_MULT_NOF_REGS                                              2
#define  SOC_PB_NBI_FC_TX_GEN_LLFC_EN_MLF_REG_MULT_NOF_REGS                                             2
#define  SOC_PB_NBI_FC_TX_GEN_LLFC_EN_CFC_REG_MULT_NOF_REGS                                             2
#define  SOC_PB_NBI_FC_TX_GEN_CBFC_FORCE_REG_MULT_NOF_REGS                                              2
#define  SOC_PB_NBI_FC_TX_GEN_CBFC_EN_MLF_REG_MULT_NOF_REGS                                             2
#define  SOC_PB_NBI_FC_TX_GEN_CBFC_EN_CFC_REG_MULT_NOF_REGS                                             2
#define  SOC_PB_NBI_FC_TX_LLFC_STOP_TX_FROM_CFC_REG_MULT_NOF_REGS                                       2
#define  SOC_PB_NBI_BIST_TX_BURSTS_THRESHOLD_REG_MULT_NOF_REGS                                          2
#define  SOC_PB_NBI_BIST_TX_BURSTS_COUNTER_REG_MULT_NOF_REGS                                            2
#define  SOC_PB_NBI_BIST_RX_OK_BURSTS_COUNTER_REG_MULT_NOF_REGS                                         2
#define  SOC_PB_IRE_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          3
#define  SOC_PB_IRE_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          3
#define  SOC_PB_IRE_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_IRE_SET_FTMH_VERSION_REG_MULT_NOF_REGS                                                  3
#define  SOC_PB_IRE_CPU_PACKET_COUNTER_REG_MULT_NOF_REGS                                                3
#define  SOC_PB_IRE_OLP_PACKET_COUNTER_REG_MULT_NOF_REGS                                                3
#define  SOC_PB_IRE_RCY_PACKET_COUNTER_REG_MULT_NOF_REGS                                                3
#define  SOC_PB_IDR_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          8
#define  SOC_PB_IDR_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          8
#define  SOC_PB_IDR_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_IDR_CONTEXT_OUTBOUND_MIRROR_REG_MULT_NOF_REGS                                           3
#define  SOC_PB_IDR_TIMEOUT_REG_MULT_NOF_REGS                                                           3
#define  SOC_PB_IDR_RECEIVED_PACKETS_CNT_REG_MULT_NOF_REGS                                              2
#define  SOC_PB_IDR_DISCARDED_PACKETS_CNT_REG_MULT_NOF_REGS                                             2
#define  SOC_PB_IDR_RECEIVED_OCTETS_CNT_REG_MULT_NOF_REGS                                               2
#define  SOC_PB_IDR_DISCARDED_OCTETS_CNT_REG_MULT_NOF_REGS                                              2
#define  SOC_PB_IRR_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          4
#define  SOC_PB_IRR_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          4
#define  SOC_PB_IRR_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_IRR_PORT_IS_OUTBOUND_MIRROR_REG_MULT_NOF_REGS                                           3
#define  SOC_PB_IRR_RESEQUENCER_FIFO_INDEX_REG_MULT_NOF_REGS                                            2
#define  SOC_PB_IHP_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          10
#define  SOC_PB_IHP_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          10
#define  SOC_PB_IHP_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_IHB_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          10
#define  SOC_PB_IHB_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          10
#define  SOC_PB_IHB_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_IHB_STATISTICS_KEY_SHIFT_REG_REG_NOF_REGS                                               2
#define  SOC_PB_IHB_DBG_KEY_A_REG_MULT_NOF_REGS                                                         6
#define  SOC_PB_IHB_DBG_KEY_B_REG_MULT_NOF_REGS                                                         6
#define  SOC_PB_IQM_GENERAL_REJECT_CONFIGURATION_BDBS_REG_NOF_REGS                                      4
#define  SOC_PB_IQM_GENERAL_REJECT_CONFIGURATION_BDS_REG_NOF_REGS                                       4
#define  SOC_PB_IQM_GENERAL_REJECT_SET_CONFIGURATION_DBUFFS_REG_NOF_REGS                                4
#define  SOC_PB_IQM_GENERAL_REJECT_CLEAR_CONFIGURATION_DBUFFS_REG_NOF_REGS                              4
#define  SOC_PB_IQM_FREE_UNICAST_DBUFF_THRESHOLD_REG_NOF_REGS                                           3
#define  SOC_PB_IQM_FREE_FULL_MULTICAST_DBUFF_THRESHOLD_REG_NOF_REGS                                    3
#define  SOC_PB_IQM_FREE_BDB_THRESHOLD_REG_NOF_REGS                                                     3
#define  SOC_PB_IQM_GRNT_BYTES_SET_REG_NOF_REGS                                                         2
#define  SOC_PB_IQM_DRAM_DYN_SIZE_TH_CFG_REG_NOF_REGS                                                   4
#define  SOC_PB_IQM_STAT_IF_BIST_PATERN_REG_NOF_REGS                                                    2
#define  SOC_PB_IQM_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          6
#define  SOC_PB_IQM_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          6
#define  SOC_PB_IQM_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_QDR_BIST_PATTERN_REG_NOF_REGS                                                           8
#define  SOC_PB_QDR_BIST_BURST_MASK_REG_NOF_REGS                                                        2
#define  SOC_PB_QDR_QDR_SEEK_DATA_REG_NOF_REGS                                                          2
#define  SOC_PB_QDR_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_IPS_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          2
#define  SOC_PB_IPS_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          2
#define  SOC_PB_IPS_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_IPT_WFQ_WEIGHT_REG_NOF_REGS                                                             2
#define  SOC_PB_IPT_FDT_NUM_LINKS_STATUS_REG_NOF_REGS                                                   2
#define  SOC_PB_IPT_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          16
#define  SOC_PB_IPT_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          16
#define  SOC_PB_IPT_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_IPT_CNM_INGRESS_VLAN_EDIT_CMD_MAP_REG_MULT_NOF_REGS                                     4
#define  SOC_PB_IPT_CNM_PDU_CPID_MSB_REG_MULT_NOF_REGS                                                  2
#define  SOC_PB_IPT_CNM_MAC_SA_REG_MULT_NOF_REGS                                                        2
#define  SOC_PB_MMU_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_DPI_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          2
#define  SOC_PB_DPI_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          2
#define  SOC_PB_FDR_PROGRAMMABLE_DATA_CELL_COUNTER_REG_NOF_REGS                                         2
#define  SOC_PB_FDR_PROGRAMMABLE_DATA_CELL_COUNTER_MASK_REG_NOF_REGS                                    2
#define  SOC_PB_FDR_CPU_DATA_CELL_A_REG_MULT_NOF_REGS                                                   10
#define  SOC_PB_FDR_CPU_DATA_CELL_B_REG_MULT_NOF_REGS                                                   10
#define  SOC_PB_FDR_CPU_DATA_CELL_C_REG_MULT_NOF_REGS                                                   10
#define  SOC_PB_FDR_CPU_DATA_CELL_D_REG_MULT_NOF_REGS                                                   10
#define  SOC_PB_FDR_ERROR_FILTER_REG_MULT_NOF_REGS                                                      4
#define  SOC_PB_FDR_ERROR_FILTER_MASK_REG_MULT_NOF_REGS                                                 4
#define  SOC_PB_FDR_ERROR_FILTER2_REG_MULT_NOF_REGS                                                     4
#define  SOC_PB_FDR_ERROR_FILTER_MASK2_REG_MULT_NOF_REGS                                                4
#define  SOC_PB_FDT_CPUDATA_CELL_REG_MULT_NOF_REGS                                                      10
#define  SOC_PB_FDT_COEXIST_DUPX2_UNICAST_BITMAP_REG_MULT_NOF_REGS                                      4
#define  SOC_PB_FDT_GCI_LINK_MASK_REG_MULT_NOF_REGS                                                     2
#define  SOC_PB_FDT_TDM_LINK_MASK_REG_MULT_NOF_REGS                                                     2
#define  SOC_PB_FCR_CONNECTIVITY_MAP_CHANGE_EVENT_REGISTERS_REG_NOF_REGS                                2
#define  SOC_PB_FCR_PROGRAMMABLE_CONTROL_CELL_COUNTER_REG_NOF_REGS                                      3
#define  SOC_PB_FDT_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          2
#define  SOC_PB_FCR_PROGRAMMABLE_CONTROL_CELL_COUNTER_MASK_REG_NOF_REGS                                 3
#define  SOC_PB_FCR_FAP20B_DESTINATION_ID_BITMAP_REG_MULT_NOF_REGS                                      4
#define  SOC_PB_FCR_CONTROL_CELL_FIFOBUFFER_REG_MULT_NOF_REGS                                           3
#define  SOC_PB_RTP_EXCLUDE_DEST_ID_FOR_MC_LINKS__REG_NOF_REGS                                          4
#define  SOC_PB_RTP_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          3
#define  SOC_PB_RTP_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          3
#define  SOC_PB_RTP_RTP_COEXIST_CONFIGURATION_REG_MULT_NOF_REGS                                         2
#define  SOC_PB_RTP_MULTICAST_LINK_UP_REG_MULT_NOF_REGS                                                 2
#define  SOC_PB_RTP_LINK_ACTIVE_MASK_REG_MULT_NOF_REGS                                                  2
#define  SOC_PB_RTP_ACL_RECEIVED_REG_MULT_NOF_REGS                                                      2
#define  SOC_PB_RTP_LOCALLY_GENERATED_ACL_REG_MULT_NOF_REGS                                             2
#define  SOC_PB_RTP_MC_DISTRIBUTION_MAP_REG_MULT_NOF_REGS                                               2
#define  SOC_PB_RTP_ALLOWED_LINKS_REG_MULT_NOF_REGS                                                     2
#define  SOC_PB_RTP_ALLOWED_LINKS_FOR_REACHABILITY_MESSAGES_REG_MULT_NOF_REGS                           2
#define  SOC_PB_FABRIC_MAC_LEAKY_BUCKET_REG_NOF_REGS                                                    12
#define  SOC_PB_FABRIC_MAC_TRANSMIT_CELL_COUNTERS_REG_NOF_REGS                                          12
#define  SOC_PB_FABRIC_MAC_CRCERROR_COUNTER_REG_NOF_REGS                                                12
#define  SOC_PB_FABRIC_MAC_FEC_TRANSMISSION_ERROR_COUNTER_REG_NOF_REGS                                  12
#define  SOC_PB_EGQ_CNM_CPID_TO_FC_TYPE_REG_NOF_REGS                                                    3
#define  SOC_PB_EGQ_CNM_CPID_TO_FC_TYPE_REG_NOF_FLDS                                                    3
#define  SOC_PB_EGR_SHPR_CONF_NIF_NOF_REGS                                                              16
#define  SOC_PB_EGQ_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          8
#define  SOC_PB_EGQ_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          8
#define  SOC_PB_EGQ_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_EGQ_OFP2TDM_MAP_REG_MULT_NOF_REGS                                                       3
#define  SOC_PB_EGQ_TC_DP_MAP_PROFILE_REG_MULT_NOF_REGS                                                 5
#define  SOC_PB_EGQ_LEARNING_DIS_REG_MULT_NOF_REGS                                                      3
#define  SOC_PB_EGQ_MARVEL_DX_FORWARD_LOW_PR_TABLE_REG_MULT_NOF_REGS                                    4
#define  SOC_PB_EGQ_MARVEL_PORT_MAP_TABLE_OTHER_REG_MULT_NOF_REGS                                       8
#define  SOC_PB_EGQ_MARVEL_PORT_MAP_TABLE_CPU_REG_MULT_NOF_REGS                                         16
#define  SOC_PB_EGQ_PQP2FQP_OFP_STOP_REG_MULT_NOF_REGS                                                  3
#define  SOC_PB_EGQ_PQP_SPR_PER_PORT_DIS_REG_MULT_NOF_REGS                                              3
#define  SOC_PB_EGQ_FQP_SPR_PER_PORT_DIS_REG_MULT_NOF_REGS                                              3
#define  SOC_PB_EGQ_QUEUE_DISABLED_REG_MULT_NOF_REGS                                                    10
#define  SOC_PB_EGQ_CHANNELIZED_PORTS_TOTAL_PACKETS_FLOW_CONTROL_THRESHOLD_REG_MULT_NOF_REGS            9
#define  SOC_PB_EGQ_CHANNELIZED_PORTS_TOTAL_WORDS_FLOW_CONTROL_THRESHOLD_REG_MULT_NOF_REGS              9
#define  SOC_PB_EGQ_OFP_THRESHOLD_TYPE_SELECT_REG_MULT_NOF_REGS                                         5
#define  SOC_PB_EGQ_OFP_AGING_ENABLE_SETTINGS_REG_MULT_NOF_REGS                                         3
#define  SOC_PB_EGQ_OFP_FORCE_AGING_REG_MULT_NOF_REGS                                                   3
#define  SOC_PB_EGQ_EGRESS_PORT_PRIORITY_CONFIGURATION_PQP_REG_MULT_NOF_REGS                            5
#define  SOC_PB_EGQ_EGRESS_PORT_PRIORITY_CONFIGURATION_REG_MULT_NOF_REGS                                5
#define  SOC_PB_EGQ_MAPPING_CONFIGURATION_MAL0_IN_SPAUI_REG_MULT_NOF_REGS                               3
#define  SOC_PB_EGQ_MAPPING_CONFIGURATION_FOR_RECYCLING_PORTS_REG_MULT_NOF_REGS                         3
#define  SOC_PB_EGQ_FC_FROM_CFC_HIGH_ENABLE_REG_MULT_NOF_REGS                                           3
#define  SOC_PB_EGQ_NIF_PORT_IS_SGMII_2_5_REG_MULT_NOF_REGS                                             2
#define  SOC_PB_EGQ_SPAUI_PORT_DELAY_REG_MULT_NOF_REGS                                                  2
#define  SOC_PB_EGQ_SGMII_PORT_DELAY_REG_MULT_NOF_REGS                                                  2
#define  SOC_PB_EGQ_NRDY_TH_SEL_REG_MULT_NOF_REGS                                                       7
#define  SOC_PB_EPNI_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                         8
#define  SOC_PB_EPNI_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                         8
#define  SOC_PB_EPNI_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                  2
#define  SOC_PB_EPNI_MAP_OFP_TO_MIRR_CHANNEL_REG_MULT_NOF_REGS                                          15
#define  SOC_PB_EPNI_OFP2TDM_MAP_REG_MULT_NOF_REGS                                                      3
#define  SOC_PB_EPNI_TDM_EN_CRC_PER_PORT_REG_MULT_NOF_REGS                                              3
#define  SOC_PB_EPNI_MIRROR_ENABLE_REG_MULT_NOF_REGS                                                    16
#define  SOC_PB_CFC_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS                                          2
#define  SOC_PB_CFC_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS                                          2
#define  SOC_PB_CFC_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS                                   2
#define  SOC_PB_CFC_LP_GLB_RSC_TO_NIF_CLSB_MAP_REG_MULT_NOF_REGS                                        4
#define  SOC_PB_CFC_GLB_RSC_TO_RCL_OFP_HP_MAP_REG_MULT_NOF_REGS                                         3
#define  SOC_PB_CFC_GLB_RSC_TO_RCL_OFP_LP_MAP_REG_MULT_NOF_REGS                                         3
#define  SOC_PB_CFC_ILKN_RX_TO_SCH_HR_MASK_REG_MULT_NOF_REGS                                            4
#define  SOC_PB_CFC_OOB_RX_TO_SCH_HR_MASK_REG_MULT_NOF_REGS                                             4
#define  SOC_PB_CFC_NIF_CLSB_TO_SCH_HR_MASK_REG_MULT_NOF_REGS                                           4
#define  SOC_PB_CFC_FRC_SCH_HR_FC_REG_MULT_NOF_REGS                                                     4
#define  SOC_PB_CFC_FRC_SCH_OFP_HR_FC_REG_MULT_NOF_REGS                                                 3
#define  SOC_PB_CFC_FRC_EGQ_OFP_FC_REG_MULT_NOF_REGS                                                    3
#define  SOC_PB_CFC_FRC_NIF_LNK_FC_REG_MULT_NOF_REGS                                                    2
#define  SOC_PB_CFC_FRC_NIF_CLSB_FC_REG_MULT_NOF_REGS                                                   4
#define  SOC_PB_CFC_FRC_NIF_FAST_LLFC_REG_MULT_NOF_REGS                                                 2
#define  SOC_PB_SCH_DVS_CONFIG_REG_NOF_REGS                                                             2
#define  SOC_PB_SCH_FORCE_HIGH_FC__REG_NOF_REGS                                                         3
#define  SOC_PB_SCH_FORCE_LOW_FC__REG_NOF_REGS                                                          3
#define  SOC_PB_SCH_FORCE_AGGR_FC__REG_NOF_REGS                                                         4

/* 0x20(srd1_LN0_cfga) - 0x0(srd0_LN0_cfga)*/
#define SOC_PB_SRD_QRTT_DELTA_OFFSET       0x20

#define SOC_PB_SRD_NOF_PER_LANE_REGS       4
#define SOC_PB_SRD_NOF_PER_QRTT_REGS       4
/* $Id: soc_pb_chip_regs.h,v 1.8 Broadcom SDK $
 * This is the number of serdeses in single MAC group.
 * 3 MAC groups exist.
 */
#define  SOC_PB_NOF_PER_LINK_REGS                   12

#define  SOC_PB_DRAM_NOF_DLL_REGS                   4
#define  SOC_PB_DRAM_NOF_RND_TRP_FLDS               4
#define  SOC_PB_DRAM_NOF_RND_TRP_DIFF_FLDS          4
#define  SOC_PB_DRAM_NOF_TRAIN_SEQ_WORDS_REGS       8
#define  SOC_PB_DRC_NOF_BIST_ENABLES                6
#define  SOC_PB_DRAM_NOF_PATTERN_REGS               8
#define  SOC_PB_DRAM_NOF_SHIFT_REGS                 4

#define  SOC_PB_NOF_STL_GROUP_CONFIG_REGS           6
#define  SOC_PB_NOF_STL_GROUP_CONFIG_FLDS           16
#define  SOC_PB_HRPORT_EN_NOF_REGS                  3
#define  SOC_PB_CH_NIF_CAL_LEN_NOF_FLDS             2
#define  SOC_PB_NOF_CH_NIF_RATE_REGS                16
#define  SOC_PB_NOF_CH_NIF_CAL_REGS                 16
#define  SOC_PB_NOF_1PORT_NIF_RATE_REGS             48
#define  SOC_PB_NOF_DVS_WEIGHT_CONFIG_REGS          4

#define  SOC_PB_NOF_SHAPER_MAX_CREDIT_REGS          4
#define  SOC_PB_NOF_SHAPER_DELAY_REGS               4
#define  SOC_PB_NOF_SHAPER_CAL_REGS                 4

#define  SOC_PB_NOF_RJCT_ADMIT_TMPLTS               8

#define  SOC_PB_REGS_DBUFF_PTR_Q_THRESH_NOF_REGS    8

#define  SOC_PB_NOF_DBUFFS_VALS                     4

#define  SOC_PB_NOF_OFP_TH_TYPE_SEL_FLDS            16

#define  SOC_PB_REGS_NOF_EGR_Q_PRIORITIES           2
#define  SOC_PB_NOF_UNSCHED_QS_THRESH_FOR_DP_REGS   7
#define  SOC_PB_NOF_SCHED_QS_FC_CONS_THR_REGS       2
#define  SOC_PB_NOF_SCHED_QS_RSC_CONS_THR_REGS      6
#define  SOC_PB_NOF_MCI_LVLS_FOR_THRESH_CONF_REGS   2
#define  SOC_PB_NOF_MCI_LVLS_FOR_THRESH_CONF_SKIP   2
#define  SOC_PB_NOF_EGR_PORT_PRIO_CONF_FLDS         16

#define  SOC_PB_NOF_INSTANCES_EGQ_CAL_SETS          2

#define  SOC_PB_REGS_PER_HDR_CR_DSCNT_TYPE_REGS     2

#define  SOC_PB_TRANSMIT_DATA_QUEUE_NOF_REGS        4
#define  SOC_PB_TRANSMIT_DATA_QUEUE_NOF_FLDS        2

#define  SOC_PB_COUNTERS_FAP_PORTS_NOF_FLDS         4

#define  SOC_PB_NOF_MAP_CONF_CHNIF_REGS             16
#define  SOC_PB_NOF_MAP_CONF_CHNIF_NOF_FLDS         16

#define SOC_PB_NOF_DEBUG_HEADER_REGS                (16)

#define SOC_PB_CPU_PACKET_FRAGMENTATION_REGS        8

#define SOC_PB_PMF_NOF_TAG_PROFILES                (8)
#define SOC_PB_PMF_NOF_STAT_SHIFT_FLDS_PER_REG     (4)

#define SOC_PB_EGQ_TC_DP_MAP_PROFILE_REG_MULT_NOF_FLDS (32/2)

#define SOC_PB_NOF_CH_PORTS_TOTAL_FC_THRESH_FLDS 2

/*
 *	NIF related
 */
#define  SOC_PB_REG_NOF_ILKNS                       (2)
/*
 * NIF Paeb Reset 2 - 5.
 */
#define  SOC_PB_REG_NIF_NOF_PAEB_REGS               (4)
#define  SOC_PB_REG_NIF_NOF_PAEB_FLDS               (2)

typedef enum
{
  SOC_PB_REG_NIF_DIRECTION_RX = 0,
  SOC_PB_REG_NIF_DIRECTION_TX = 1,
  SOC_PB_REG_NOF_NIF_DIRECTIONS
}SOC_PB_REG_NIF_DIRECTION;

#define  SOC_PB_REG_NOF_MALS_IN_MALG                (8)
#define  SOC_PB_REG_NOF_MALGS                       (2)
#define  SOC_PB_REG_NOF_MALS                        (SOC_PB_REG_NOF_MALS_IN_MALG*SOC_PB_REG_NOF_MALS_IN_MALG)
#define  SOC_PB_REG_NOF_NIFS                        (64)
#define  SOC_PB_REG_NOF_NIFS_IN_MALG                (SOC_PB_REG_NOF_NIFS/SOC_PB_REG_NOF_MALGS)

#define  SOC_PB_REG_NOF_IRR_RESEQ_PORT_PER_FIFO     (8)
#define  SOC_PB_REG_NOF_RESEQS                      (3)

#define  SOC_PB_EGR_SHPR_PER_NIF_GRP_NOF_REGS       (4)
#define  SOC_PB_EGR_SHPR_PER_NIF_GRP_NOF_FLDS       (4)
#define  SOC_PB_INSTANCES_EGQ_CAL_SETS_OFFSET17     (0x17)
#define  SOC_PB_INSTANCES_EGQ_CAL_SETS_OFFSET18     (0x18)


#define SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS        (2)

#define SOC_PB_REG_BLK_NOF_INSTANCES_OOB              (2)

#define SOC_PB_REG_IQM_GRNT_BYTES_SET_REG_NOF_FLDS    (2)

#define SOC_PB_REG_NOF_FAP_PORT_REGS                  (3)

#define SOC_PB_REG_NOF_MAL_PRIO3_REGS                  (4)
#define SOC_PB_REG_NOF_MAL_PRIO3_FLDS                  (4)


/* } */

/*************
 *  MACROS   *
 *************/
/* { */

/* } */

/*************
 * TYPE DEFS *
 *************/
/* { */

/* Blocks definition { */

/* Block definition: ECI */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Version Register: The device version.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0000 */

     /* ChipType: Chip type                                          */
     /* range: 23:4, access type: RO, default value: 20'hfa100       */
     SOC_PETRA_REG_FIELD chip_type;

     /* DbgVer: Debug Version. The version (bug correction) of       */
     /* the device. Each device may have several versions. (The      */
     /* first version is 1.)                                         */
     /* range: 27:24, access type: RO, default value: 0x1            */
     SOC_PETRA_REG_FIELD dbg_ver;

     /* ChipVer: Device Version. Indicates the version               */
     /* (different functionality) of the device. (The first          */
     /* version's value is 1.)                                       */
     /* range: 31:28, access type: RO, default value: 0x1            */
     SOC_PETRA_REG_FIELD chip_ver;

  } __ATTRIBUTE_PACKED__ version_reg;

  /* Identification Register: The identification of FAP. This       */
  /* is a unique number that identifies the FAP.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0001 */

     /* Pipeid: ID of FAP. This register contains a number that      */
     /* identifies the FAP. It is unique in the system.              */
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pipe_id;

  } __ATTRIBUTE_PACKED__ identification_reg;

  /* Soc_petra-C fix      */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0002 */

    /* range: 0:0, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD oob_fix_en;

  } __ATTRIBUTE_PACKED__ soc_petra_c_fix;

  /* Spare register. Used by SW for managment flags                 */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0003 */
    /* range: 29:29, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD hot_init_done;
    /* range: 30:30, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD pp_enable;
    /* range: 31:31, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD sch_flow_ipf_is_prop_not_inverse;
  } __ATTRIBUTE_PACKED__ spare_flags_reg;

  /* Unicast Dbuff Pointers Start: The following registers          */
  /* describe the partition of the ingress DRAM buffers             */
  /* between Unicast, Mini Multicast, and Full Multicast            */
  /* dbuffs. Any dbuff in the system can be defined as a            */
  /* Unicast dbuff.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0007 */

     /* UcDbPtrStart: Pointer to first DRAM buffer for Unicast       */
     /* type dbuffs.                                                 */
     /* range: 20:0, access type: RW, default value: 21'h12000       */
     SOC_PETRA_REG_FIELD uc_db_ptr_start;

  } __ATTRIBUTE_PACKED__ unicast_dbuff_pointers_start_reg;

  /* Unicast Dbuff Pointers End:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0008 */

     /* UcDbPtrEnd: Pointer to last DRAM buffer for Unicast type     */
     /* dbuffs.                                                      */
     /* range: 20:0, access type: RW, default value: 21'h1fffff      */
     SOC_PETRA_REG_FIELD uc_db_ptr_end;

  } __ATTRIBUTE_PACKED__ unicast_dbuff_pointers_end_reg;

  /* Mini Multicast Dbuff Pointers Start: Up to 64K dbuffs          */
  /* can be defined as Mini Multicast dbuffs. They have an          */
  /* associated two-bit User-Count. These dbuffs are used for       */
  /* snooping and mirroring, or for Multicast where four or         */
  /* less copies are required.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0009 */

     /* MnMulDbPtrStart: Pointer to first DRAM buffer for Mini       */
     /* Multicast type dbuffs.                                       */
     /* range: 20:0, access type: RW, default value: 0x2000          */
     SOC_PETRA_REG_FIELD mn_mul_db_ptr_start;

  } __ATTRIBUTE_PACKED__ mini_multicast_dbuff_pointers_start_reg;

  /* Mini Multicast Dbuff Pointers End:                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000a */

     /* MnMulDbPtrEnd: Pointer to last DRAM buffer for Mini          */
     /* Multicast type dbuffs.                                       */
     /* range: 20:0, access type: RW, default value: 21'h11fff       */
     SOC_PETRA_REG_FIELD mn_mul_db_ptr_end;

  } __ATTRIBUTE_PACKED__ mini_multicast_dbuff_pointers_end_reg;

  /* Full Multicast Dbuff Pointers Start: Up to 8K dbuffs can       */
  /* be defined as Full Multicast dbuffs. They have an              */
  /* associated 12-bit User-Count. These dbuffs are used for        */
  /* Multicast packets.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000b */

     /* FlMulDbPtrStart: Pointer to first DRAM buffer for Full       */
     /* Multicast type dbuffs.                                       */
     /* range: 20:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fl_mul_db_ptr_start;

  } __ATTRIBUTE_PACKED__ full_multicast_dbuff_pointers_start_reg;

  /* Full Multicast Dbuff Pointers End:                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000c */

     /* FlMulDbPtrEnd: Pointer to last DRAM buffer for Full          */
     /* Multicast type dbuffs.                                       */
     /* range: 20:0, access type: RW, default value: 0x1fff          */
     SOC_PETRA_REG_FIELD fl_mul_db_ptr_end;

  } __ATTRIBUTE_PACKED__ full_multicast_dbuff_pointers_end_reg;

  /* Soc_petra Soft Reset: When triggered, the corresponding            */
  /* block will perform a software reset.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000d */

     /* MasReset: Performs soft reset for the MAS block.             */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mas_reset;

     /* MalgaReset: Performs soft reset for the MALGA block.         */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD malga_reset;

     /* MalgbReset: Performs soft reset for the MALGB block.         */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD malgb_reset;

     /* SchReset: Performs soft reset for the SCH block.             */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD sch_reset;

     /* IhpReset: Performs soft reset for the IHP block.             */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ihp_reset;

     /* DprcaReset: Performs soft reset for the DPRCA block.         */
     /* range: 5:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dprc_reset[SOC_PB_BLK_NOF_INSTANCES_DRC];

     /* IrdpReset: Performs soft reset for the IRDP block.           */
     /* range: 11:11, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD irdp_reset;

     /* MmuReset: Performs soft reset for the MMU block.             */
     /* range: 12:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD mmu_reset;

     /* EgqReset: Performs soft reset for the EGQ block.             */
     /* range: 13:13, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD egq_reset;

     /* EpniReset: Performs soft reset for the EPNI block.           */
     /* range: 14:14, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD epni_reset;

     /* FdrcReset: Performs soft reset for the FDRC block.           */
     /* range: 15:15, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fdrc_reset;

     /* PtsReset: Performs soft reset for the PTS block.             */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD pts_reset;

     /* IqmReset: Performs soft reset for the IQM block.             */
     /* range: 17:17, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD iqm_reset;

     /* OlpReset: Performs soft reset for the OLP block.             */
     /* range: 18:18, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD olp_reset;

     /* MdioReset: Performs soft reset for the MDIO block.           */
     /* range: 19:19, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD mdio_reset;

     /* CfcReset: Performs soft reset for the CFC block.             */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cfc_reset;

     /* MccReset: Performs soft reset for the MCC block.             */
     /* range: 21:21, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD mcc_reset;

     /* QdioReset: Performs soft reset for the QDIO block.           */
     /* range: 22:22, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD qdio_reset;

     /* NbiReset: Performs soft reset for the NBI block.             */
     /* range: 23:23, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD nbi_reset;

     /* MbuReset: Performs soft reset for the MBU block.             */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD mbu_reset;

     /* IhbReset: Performs soft reset for the IHB block.             */
     /* range: 25:25, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ihb_reset;

     /* DprcDcaReset: Performs soft reset for the DPRC_DCA           */
     /* block.                                                       */
     /* range: 26:26, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD dprc_dc_reset[SOC_PB_BLK_NOF_INSTANCES_DRC];
  } __ATTRIBUTE_PACKED__ soc_petra_soft_reset_reg;

  /* Soc_petra Soft Init: When triggered, the corresponding block       */
  /* will perform a software init. No need to reconfigure the       */
  /* corresponding block.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000e */

     /* IpsInit: Performs soft init for the IPS block.               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ips_init;

     /* IqmInit: Performs soft init for the IQM block.               */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD iqm_init;

     /* QdrInit: Performs soft init for the QDR block.               */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_init;

     /* IptInit: Performs soft init for the IPT block.               */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ipt_init;

     /* MmuInit: Performs soft init for the MMU block.               */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mmu_init;

     /* DprcaInit - DprcfInit:                                       */
     /* Performs soft init for the DPRCA block.                      */
     /* range: 10:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprc_init[SOC_PB_BLK_NOF_INSTANCES_DRC];

     /* IreInit: Performs soft init for the IRE block.               */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ire_init;

     /* IhpInit: Performs soft init for the IHP block.               */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ihp_init;

     /* IdrInit: Performs soft init for the IDR block.               */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD idr_init;

     /* IrrInit: Performs soft init for the IRR block.               */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD irr_init;

     /* FdtInit: Performs soft init for the FDT block.               */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdt_init;

     /* FdrInit: Performs soft init for the FDR block.               */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_init;

     /* FctInit: Performs soft init for the FCT block.               */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fct_init;

     /* FcrInit: Performs soft init for the FCR block.               */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fcr_init;

     /* RtpInit: Performs soft init for the RTP block.               */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rtp_init;

     /* EgqInit: Performs soft init for the EGQ block.               */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_init;

     /* EpniInit: Performs soft init for the EPNI block.             */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD epni_init;

     /* MacaInit: Performs soft init for the MACA block.             */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD maca_init;

     /* MacbInit: Performs soft init for the MACB block.             */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD macb_init;

     /* MaccInit: Performs soft init for the MACC block.             */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD macc_init;

     /* SchInit: Performs soft init for the SCH block.               */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sch_init;

     /* OlpInit: Performs soft init for the OLP block.               */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD olp_init;

     /* MswInit: Performs soft init for the MSW block.               */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD msw_init;

     /* NbiInit: Performs soft init for the NBI block.               */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nbi_init;

     /* MalgaInit: Performs soft init for the MALGA block.           */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD malga_init;

     /* MalgbInit: Performs soft init for the MALGB block.           */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD malgb_init;

     /* IhbInit: Performs soft init for the IHB block.               */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ihb_init;

  } __ATTRIBUTE_PACKED__ soc_petra_soft_init_reg;

  /* Ingress Shaping Queue Boundaries: Defines a continuous         */
  /* range of queues that are used for Ingress-shaped               */
  /* packets. This assignment is meaningful for the                 */
  /* statistics matrix that the IQM maintains.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000f */

     /* IspQnumLow: First queue ID for ingress shaping queues.       */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD isp_qnum_low;

     /* IspQnumHigh: Last queue ID for ingress shaping queues.       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD isp_qnum_high;

  } __ATTRIBUTE_PACKED__ ingress_shaping_queue_boundaries_reg;

  /* Fabric Multicast Queue Boundaries: Defines a continuous        */
  /* range of queues that are used for Fabric Multicast             */
  /* packets. This assignment is meaningful for the                 */
  /* statistics matrix that the IQM maintains.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0010 */

     /* FmcQnumLow: First queue ID for fabric multicast queues.      */
     /* range: 14:0, access type: RW, default value: 0x7ff           */
     SOC_PETRA_REG_FIELD fmc_qnum_low;

     /* FmcQnumHigh: Last queue ID for fabric multicast queues.      */
     /* range: 30:16, access type: RW, default value: 0x7ff          */
     SOC_PETRA_REG_FIELD fmc_qnum_high;

  } __ATTRIBUTE_PACKED__ fabric_multicast_queue_boundaries_reg;

  /* Drc Bist Enables: This registers enables each one of the       */
  /* DRAM BISTs in the DRAM controller blocks.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0011 */

     /* DrcaBistEn: If set, enables the BIST module in DRCA.         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drca_bist_en;

     /* DrcbBistEn: If set, enables the BIST module in DRCB.         */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drcb_bist_en;

     /* DrccBistEn: If set, enables the BIST module in DRCC.         */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drcc_bist_en;

     /* DrcdBistEn: If set, enables the BIST module in DRCD.         */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drcd_bist_en;

     /* DrceBistEn: If set, enables the BIST module in DRCE.         */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drce_bist_en;

     /* DrcfBistEn: If set, enables the BIST module in DRCF.         */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drcf_bist_en;

     /* DrcfBistEn: If set, enables the BIST module in DRCF.         */
     /* range: i:i, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drcs_bist_en[SOC_PB_DRC_NOF_BIST_ENABLES];

  } __ATTRIBUTE_PACKED__ drc_bist_enables_reg;

  /* General Controls: General configurations                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0012 */

     /* FscEn: If set, cell mode is fixed-size cell. Otherwise,      */
     /* variable-size cell.                                          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fsc_en;

     /* MeshMode: Mesh mode selection. If set, the device works      */
     /* in mesh mode.                                                */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mesh_mode;

     /* SelStatDataOut: Selection between the statistics data        */
     /* and the mirror data bus to be sent out to pads. If set,      */
     /* the statistics data is sent out to pads. Otherwise, the      */
     /* mirror data is sent out to pads.                             */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD sel_stat_data_out;

     /* StatDdrMode: If set, statistics pads are in DDR mode;        */
     /* otherwise, statistics pads are in SDR mode.                  */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_ddr_mode;

     /* StatTagEn: If set, the first 4B of every incoming            */
     /* ingress packet consist of the statistics tag.                */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_tag_en;

     /* QdrParSel: If set, the QDR data is parity protected (4       */
     /* bits parity, 32 bits of data). Otherwise, the QDR data       */
     /* is ECC protected (6 bits for ECC, 30 bits of data).          */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_par_sel;

     /* AddDramCrc: If set, a 16b CRC is appended to the end of      */
     /* the packet (aligned to the last two bytes of a 32B           */
     /* word).                                                       */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD add_dram_crc;

     /* NoFabCrc: If set, the packet will be sent across the         */
     /* fabric without a 16b packet CRC. Otherwise, the packet       */
     /* will be sent with 16b CRC.                                   */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD no_fab_crc;

     /* En_16kMul: If set, the device supports 16K multicast         */
     /* groups.                                                      */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD en_16k_mul;

     /* TdmMode: If set, every cell entering the device must be      */
     /* TDM. Otherwise data traffic.                                 */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_mode;

     /* StatOe: If set, the statistics interface is output;          */
     /* otherwise input.                                             */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_oe;

     /* DbuffSize: The size of a data buffer in the DRAM: 0 -        */
     /* 256 bytes 1 - 512 bytes 2 - 1024 bytes 3 - 2048 bytes        */
     /* range: 17:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dbuff_size;

     /* HdrType: Header type: 2'b00 - Soc_petra Header type 2'b01 -      */
     /* FAP20 Header type 2'b10 - SOC_SAND_FAP10M Header type 2'b11 -         */
     /* Reserved                                                     */
     /* range: 25:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hdr_type;

     /* StatOutPhase: 00 - Statistics data is in phase with the      */
     /* clock. 01 - Statistics data is 90 degrees to the clock.      */
     /* 10 - Statistics data is 180 degrees to the clock. 11 -       */
     /* Statistics data is 270 degrees to the clock.                 */
     /* range: 29:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_out_phase;

     /* Oc768cMode: Indicates the OC-768c operation mode: 0:         */
     /* OC768 mode is OFF. 1: OC768 mode enbaled as 1-PQP port       */
     /* 2: OC768 mode enbaled as 2-PQP port 3: OC768 mode            */
     /* enbaled as 3-PQP port                                        */
     /* range: 31:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oc768c_mode;

  } __ATTRIBUTE_PACKED__ general_controls_reg;

  /* System Headers Configuration 0: Configuration for system       */
  /* headers stack configuration.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0016 */

     /* FTMH-Ext: Determines when an FTMH extension is present       */
     /* in the system headers as follows:                            */
     /* 2'b00 - Never                                                */
     /* 2'b01 - System mutlicast packets only                        */
     /* 2'b1x - Always                                               */
     /* range: 1:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ftmh_ext;

     /* FTMH-LB-Key-Ext-Enable: If set then an FTMH load             */
     /* balancing extension is present in the system headers         */
     /* stack.                                                       */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ftmh_lb_key_ext_enable;

     /* FTMH-LB-Key-Ext-Mode: If set, the FTMH load balancing        */
     /* extension contains an 8-bit load balancing key and an        */
     /* 8-bit stacking route history bitmap. Otherwise the           */
     /* extension contains a 16-bit stacking route history           */
     /* bitmap.                                                      */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ftmh_lb_key_ext_mode;

     /* Add-PPH-EEP-Ext: If set then a PPH EEP extension is          */
     /* present                                                      */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD add_pph_eep_ext;
    
     /* PPH-Soc_petraA-Compatible: If set then PPH is in soc_petra-A         */
     /* compatible mode. In this mode the PPH MFF contains the       */
     /* CUD (which is the ARP pointer in IP applications).           */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pph_petra_a_compatible;
  } __ATTRIBUTE_PACKED__ system_headers_configuration_0_reg;

  /* Endian Mode: The device works by default in big endian         */
  /* mode. In order to work in little endian mode, all bits         */
  /* of this register must be set.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0017 */

     /* LittleEndian: If all bits set, the device works in           */
     /* little endian mode.                                          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD little_endian;

  } __ATTRIBUTE_PACKED__ endian_mode_reg;

  /* Byte Access Order: The byte (8-bit) access order for a         */
  /* 32-bit asynchronous read/write transaction.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0018 */

     /* FourthByteAccess: The fourth byte CPU read/write from/to     */
     /* (address[1:0]). Write the same value also to bits: 9:8,      */
     /* 17:16, 25:24.                                                */
     /* range: 1:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD fourth_byte_access;

     /* ThirdByteAccess: The third byte CPU read/write from/to       */
     /* (address[1:0]). Write the same value also to bits:           */
     /* 11:10, 19:18, 27:26.                                         */
     /* range: 3:2, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD third_byte_access;

     /* SecondByteAccess: The second byte CPU read/write from/to     */
     /* (address[1:0]). Write the same value also to bits:           */
     /* 13:12, 21:20, 29:28.                                         */
     /* range: 5:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD second_byte_access;

     /* FirstByteAccess: The first byte CPU read/write from/to       */
     /* (address[1:0]). Write the same value also to bits:           */
     /* 15:14, 23:22, 31:30.                                         */
     /* range: 7:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD first_byte_access;

  } __ATTRIBUTE_PACKED__ byte_access_order_reg;

  /* Test Register: To verify the CPU interface of the              */
  /* device. By reading the inverted value, it is assured           */
  /* that a read following a write will have to drive the bus       */
  /* in order for the read to be successful.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001a */

     /* TestRegister: This register is for the CPU interface         */
     /* testing. When read, it returns ~TestRegister (i.e., the      */
     /* value is inverted).                                          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD test_register;

  } __ATTRIBUTE_PACKED__ test_reg;

  /* Power Down Configurations: Power-down Configurations.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001b */

     /* MacaPd: If set, MACA is powered down.                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD maca_pd;

     /* MacbPd: If set, MACB is powered down.                        */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD macb_pd;

     /* MaccPd: If set, MACC is powered down.                        */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD macc_pd;

     /* MswPd: If set, MSW is powered down.                          */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD msw_pd;

     /* MalgaPd: If set, MALGA is powered down.                      */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD malga_pd;

     /* MalgbPd: If set, MALGB is powered down.                      */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD malgb_pd;

     /* DprcaPd: If set, DPRCA is powered down.                      */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprca_pd;

     /* DprcbPd: If set, DPRCB is powered down.                      */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcb_pd;

     /* DprccPd: If set, DPRCC is powered down.                      */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcc_pd;

     /* DprcdPd: If set, DPRCD is powered down.                      */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcd_pd;

     /* DprcePd: If set, DPRCE is powered down.                      */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dprce_pd;

     /* DprcfPd: If set, DPRCF is powered down.                      */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dprcf_pd;

     /* QdioPd: If set, QDIO is powered down.                        */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdio_pd;

  } __ATTRIBUTE_PACKED__ power_down_configurations_reg;

  /* Cpu Streaming Interface Configurations: Configuration          */
  /* for the CPU streaming interface.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001c */

     /* CpuifMultiPortMode: If set, the CPU streaming IF is in       */
     /* Multi-Port Mode. Otherwise, the CPU is in Single-Port        */
     /* Mode.                                                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_multi_port_mode;

     /* CpuifEnableTimeoutcnt: If set, the CSI time-out counter      */
     /* is activated and the CSI will send a read reply command      */
     /* back to the CPU after CpuifTimeoutPrd cycles, if no read     */
     /* reply was received from the Soc_petra blocks.                    */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD cpuif_enable_timeoutcnt;

     /* CpuifTimeoutPrd: Number of cycles the CSI waits for a        */
     /* read reply from the Soc_petra blocks before issuing a read       */
     /* reply command.                                               */
     /* range: 22:16, access type: RW, default value: 0x64           */
     SOC_PETRA_REG_FIELD cpuif_timeout_prd;

     /* CpuifQuietMode: If set, the CSI will not send a reply        */
     /* command for write requests. As for read requests, the        */
     /* CSI will send a 32b reply command containing the read        */
     /* data only.                                                   */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpuif_quiet_mode;

     /* CpuifNoDisBadParity: If set, the CSI does not discard        */
     /* data received with a parity error and treats it as valid     */
     /* data. Default is to set this register to assist in the       */
     /* bring-up phase. The application should clear this            */
     /* register after the CPU interface is working.                 */
     /* range: 25:25, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cpuif_no_dis_bad_parity;

     /* CpuifDisPktStreaming: If set, disables transmitting          */
     /* packets over the streaming interface. These packets can      */
     /* be read through the CpuAsynchronousPacketData address.       */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpuif_dis_pkt_streaming;

  } __ATTRIBUTE_PACKED__ cpu_streaming_interface_configurations_reg;

  /* Olp Streaming Interface Configurations: Configuration          */
  /* for the internal Off-Load Processor, which can act like        */
  /* a master and initiate commands to the various blocks via       */
  /* the CSI.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001d */

     /* OlpifEnableTimeoutcnt: If set, the CSI time-out counter      */
     /* is activated and the CSI will send a read reply command      */
     /* back to the OLP after OlpifTimeoutPrd cycles, if no read     */
     /* reply was received from the Soc_petra blocks.                    */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD olpif_enable_timeoutcnt;

     /* OlpifTimeoutPrd: Number of cycles the CSI waits for a        */
     /* read reply from the Soc_petra blocks before issuing a read       */
     /* reply command.                                               */
     /* range: 22:16, access type: RW, default value: 0x64           */
     SOC_PETRA_REG_FIELD olpif_timeout_prd;

     /* OlpifQuietMode: If set, the CSI will not send a reply        */
     /* command for write requests. As for read requests, the        */
     /* CSI will send a 32b reply command containing the read        */
     /* data only.                                                   */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD olpif_quiet_mode;

  } __ATTRIBUTE_PACKED__ olp_streaming_interface_configurations_reg;

  /* Cpu Streaming Interface Interrupts: This register              */
  /* contains the CPU streaming interrupt sources residing in       */
  /* the ECI. Writing a value of 1 to the relevant bit in the        */
  /* interrupt register clears it (event interrupts).               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001e */

     /* CpuifRxPktPrtyErr: Indicates a parity error inside a         */
     /* received packet from the CPU.                                */
     /* range: 0:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_rx_pkt_prty_err;

     /* CpuifRxCmdPrtyErr: Indicates a parity error inside a         */
     /* received command from the CPU.                               */
     /* range: 1:1, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_prty_err;

     /* CpuifRxPktSeqErr: Indicates a bad sequence of commands       */
     /* during the reception of a packet from the CPU.               */
     /* range: 2:2, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_rx_pkt_seq_err;

     /* CpuifRxCmdTypeErr: Indicates an error in a register          */
     /* command because the command type from the CPU                */
     /* (WRITE/READ) was not valid.                                  */
     /* range: 3:3, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_type_err;

     /* CpuifRxCmdSeqErr: Indicates a bad sequence of commands       */
     /* during a received register command from the CPU.             */
     /* range: 4:4, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_seq_err;

     /* CpuifReadRegTimeout: Indicates a timeout has occurred        */
     /* while waiting for a read reply from the ECI. In this         */
     /* case, the device will generate a read reply command with     */
     /* data 0xDEADBEEF.                                             */
     /* range: 5:5, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_read_reg_timeout;

     /* CpuifTxSopErr: Indicates a missing SOP command to the        */
     /* CPU in single-port mode.                                     */
     /* range: 8:8, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_tx_sop_err;

     /* CpuifTxEopErr: Indicates a missing EOP command to the        */
     /* CPU in single-port mode.                                     */
     /* range: 9:9, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_tx_eop_err;

     /* CpuifBadParityData: Contains the 16b data for the last       */
     /* CPU interface transaction on which the parity error          */
     /* occurred.                                                    */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpuif_bad_parity_data;

  } __ATTRIBUTE_PACKED__ cpu_streaming_if_interrupts_reg;

  /* Cpu Streaming Interface Interrupts Mask Register: Each         */
  /* bit in this register corresponds to the interrupt source       */
  /* in the previous Interrupt Register. The interrupt source       */
  /* is masked by writing 0 to the relevant bit in this             */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001f */

     /* CpuifRxPktPrtyErrMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_rx_pkt_prty_err_mask;

     /* CpuifRxCmdPrtyErrMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_prty_err_mask;

     /* CpuifRxPktSeqErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_rx_pkt_seq_err_mask;

     /* CpuifRxCmdTypeErrMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_type_err_mask;

     /* CpuifRxCmdSeqErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_seq_err_mask;

     /* CpuifReadRegTimeoutMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_read_reg_timeout_mask;

     /* CpuifTxSopErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_tx_sop_err_mask;

     /* CpuifTxEopErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_tx_eop_err_mask;

  } __ATTRIBUTE_PACKED__ cpu_streaming_interface_interrupts_mask_reg;

  /* Olp Streaming Interface Interrupts: This register              */
  /* contains the OLP streaming interrupt sources residing in       */
  /* the ECI. Writing a value of 1 to the relevant bit in the        */
  /* interrupt register clears it (event interrupts).               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0020 */

     /* OlpifRxPktSeqErr: Indicates a bad sequence of commands       */
     /* during the reception of a packet from OLP.                   */
     /* range: 2:2, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD olpif_rx_pkt_seq_err;

     /* OlpifRxCmdTypeErr: Indicates an error in a register          */
     /* command because the command type from OLP (WRITE/READ)       */
     /* was not valid.                                               */
     /* range: 3:3, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD olpif_rx_cmd_type_err;

     /* OlpifRxCmdSeqErr: Indicates a bad sequence of commands       */
     /* during a received register command from OLP.                 */
     /* range: 4:4, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD olpif_rx_cmd_seq_err;

     /* OlpifReadRegTimeout: Indicates a timeout has occurred        */
     /* while waiting for a read reply from the ECI. In this         */
     /* case, the device will generate a read reply command with     */
     /* data 0xDEADBEEF.                                             */
     /* range: 5:5, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD olpif_read_reg_timeout;

  } __ATTRIBUTE_PACKED__ olp_streaming_interface_interrupts_reg;

  /* Olp Streaming Interface Interrupts Mask Register: Each         */
  /* bit in this register corresponds to the interrupt source       */
  /* in the previous Interrupt Register. The interrupt source       */
  /* is masked by writing 0 to the relevant bit in this             */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0021 */

     /* OlpifRxPktSeqErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olpif_rx_pkt_seq_err_mask;

     /* OlpifRxCmdTypeErrMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olpif_rx_cmd_type_err_mask;

     /* OlpifRxCmdSeqErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olpif_rx_cmd_seq_err_mask;

     /* OlpifReadRegTimeoutMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olpif_read_reg_timeout_mask;

  } __ATTRIBUTE_PACKED__ olp_streaming_interface_interrupts_mask_reg;

  /* Asynchronous Mode Interrupts: This register contains the       */
  /* asynchronous mode interrupt sources residing in the            */
  /* ECI. Writing a value of 1 to the relevant bit in the            */
  /* interrupt register clears it (event interrupts).               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0022 */

     /* AsynchByteOrderErr: Indicates a disordered byte access       */
     /* in an asynchronous mode transaction.                         */
     /* range: 0:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD asynch_byte_order_err;

     /* AsynchPacketDataValid: This bit is used in CPU               */
     /* asynchronous mode to indicate that packet data to the        */
     /* CPU is valid.                                                */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD asynch_packet_data_valid;

  } __ATTRIBUTE_PACKED__ asynchronous_mode_interrupts_reg;

  /* Asynchronous Mode Interrupts Mask Register: Each bit in        */
  /* this register corresponds to the interrupt source in the       */
  /* previous Interrupt Register. The interrupt source is           */
  /* masked by writing 0 to the relevant bit in this                */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0023 */

     /* AsynchByteOrderErrMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD asynch_byte_order_err_mask;

     /* AsynchPacketDataValidMask: Writing 0 masks the               */
     /* corresponding interrupt source.                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD asynch_packet_data_valid_mask;

  } __ATTRIBUTE_PACKED__ asynchronous_mode_interrupts_mask_reg;

  /* Tdm Configuration: TDM cells configuration.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0026 */

     /* TdmFrgNum: Set the fragment number that defines the TDM      */
     /* cell in the device. If we have FAP20B in the system,         */
     /* this value must remain at the default value.                 */
     /* range: 8:0, access type: RW, default value: 0x180            */
     SOC_PETRA_REG_FIELD tdm_frg_num;

     /* Tdm_2bytesFtmh: Using a 2-byte ftmh in tdm packets           */
     /* (relevant only when the chip is in tdm mode)                 */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_2bytes_ftmh;

     /* TdmPktModeEn: Relevant when the chip is not in tdm mode      */
     /* (eci2fdt_c_tdm_mode = 0), enable 128B cells from             */
     /* relevant sourc_fap_port / to out_fap_port to get tdm         */
     /* fragment number                                              */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_pkt_mode_en;

     /* EgressTdmMode: If set, every cell entering the device        */
     /* egress must be TDM. Otherwise data traffic.                  */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egress_tdm_mode;

  } __ATTRIBUTE_PACKED__ tdm_configuration_reg;

  /* Ddr Pll Config: DDR PLL configuration.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0027 */

     /* DdrPllM: M value for DDR PLL                                 */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_pll_m;

     /* DdrPllN: N value for DDR PLL                                 */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ddr_pll_n;

     /* DdrPllK: K value for DDR PLL                                 */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_pll_k;

     /* DdrPllP: P value for DDR PLL                                 */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_pll_p;

  } __ATTRIBUTE_PACKED__ ddr_pll_config_reg;

  /* Ddr Ab Pll Config: DDR AB PLL configuration.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0028 */

     /* DdrAbPllM: M value for DDR AB PLL                            */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ab_pll_m;

     /* DdrAbPllN: N value for DDR AB PLL                            */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ddr_ab_pll_n;

     /* DdrAbPllK: K value for DDR AB PLL                            */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_ab_pll_k;

     /* DdrAbPllP: P value for DDR AB PLL                            */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_ab_pll_p;

  } __ATTRIBUTE_PACKED__ ddr_ab_pll_config_reg;

  /* Ddr Ef Pll Config: DDR EF PLL configuration.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0029 */

     /* DdrEfPllM: M value for DDR EF PLL                            */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ef_pll_m;

     /* DdrEfPllN: N value for DDR EF PLL                            */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ddr_ef_pll_n;

     /* DdrEfPllK: K value for DDR EF PLL                            */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_ef_pll_k;

     /* DdrEfPllP: P value for DDR EF PLL                            */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_ef_pll_p;

  } __ATTRIBUTE_PACKED__ ddr_ef_pll_config_reg;

  /* Qdr Pll Config: QDR PLL configuration.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002a */

     /* QdrPllM: M value for QDR PLL                                 */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_pll_m;

     /* QdrPllN: N value for QDR PLL                                 */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD qdr_pll_n;

     /* QdrPllK: K value for QDR PLL                                 */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_pll_k;

     /* QdrPllP: P value for QDR PLL                                 */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_pll_p;

  } __ATTRIBUTE_PACKED__ qdr_pll_config_reg;

  /* Ddr Pll Ext Prog: DDR PLL external VCO gain, charge-pump       */
  /* current and loop-filter resistance programming.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002b */

     /* DdrPllVprog: VPROG value for DDR PLL                         */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_pll_vprog;

     /* DdrPllIprog: IPROG value for DDR PLL                         */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_pll_iprog;

     /* DdrPllRprog: RPROG value for DDR PLL                         */
     /* range: 11:8, access type: RW, default value: 0x4             */
     SOC_PETRA_REG_FIELD ddr_pll_rprog;

  } __ATTRIBUTE_PACKED__ ddr_pll_ext_prog_reg;

  /* Ddr Ab Pll Ext Prog: DDR AB PLL external VCO gain,             */
  /* charge-pump current and loop-filter resistance                 */
  /* programming.                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002c */

     /* DdrAbPllVprog: VPROG value for DDR AB PLL                    */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ab_pll_vprog;

     /* DdrAbPllIprog: IPROG value for DDR AB PLL                    */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ab_pll_iprog;

     /* DdrAbPllRprog: RPROG value for DDR AB PLL                    */
     /* range: 11:8, access type: RW, default value: 0x4             */
     SOC_PETRA_REG_FIELD ddr_ab_pll_rprog;

  } __ATTRIBUTE_PACKED__ ddr_ab_pll_ext_prog_reg;

  /* Ddr Ef Pll Ext Prog: DDR EF PLL external VCO gain,             */
  /* charge-pump current and loop-filter resistance                 */
  /* programming.                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002d */

     /* DdrEfPllVprog: VPROG value for DDR EF PLL                    */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ef_pll_vprog;

     /* DdrEfPllIprog: IPROG value for DDR EF PLL                    */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ef_pll_iprog;

     /* DdrEfPllRprog: RPROG value for DDR EF PLL                    */
     /* range: 11:8, access type: RW, default value: 0x4             */
     SOC_PETRA_REG_FIELD ddr_ef_pll_rprog;

  } __ATTRIBUTE_PACKED__ ddr_ef_pll_ext_prog_reg;

  /* Qdr Pll Ext Prog: QDR PLL external VCO gain, charge-pump       */
  /* current and loop-filter resistance programming.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002e */

     /* QdrPllVprog: VPROG value for QDR PLL                         */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_pll_vprog;

     /* QdrPllIprog: IPROG value for QDR PLL                         */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_pll_iprog;

     /* QdrPllRprog: RPROG value for QDR PLL                         */
     /* range: 11:8, access type: RW, default value: 0x4             */
     SOC_PETRA_REG_FIELD qdr_pll_rprog;

  } __ATTRIBUTE_PACKED__ qdr_pll_ext_prog_reg;

  /* Pll Resets: DDR and QDR PLL reset.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002f */

     /* DdrPllRstN: DDR PLL rst_n signal                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_pll_rst_n;

     /* DdrAbPllRstN: DDR AB PLL rst_n signal                        */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ab_pll_rst_n;

     /* DdrEfPllRstN: DDR EF PLL rst_n signal                        */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ef_pll_rst_n;

     /* QdrPllRstN: QDR PLL rst_n signal                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_pll_rst_n;

     /* QdrPllSel: 0 - select QDR PLL. 1 - select core PLL.          */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_pll_sel;

     /* DdrPllPwrdn: DDR PLL power down signal                       */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_pll_pwrdn;

     /* DdrAbPllPwrdn: DDR AB PLL power down signal                  */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ab_pll_pwrdn;

     /* DdrEfPllPwrdn: DDR EF PLL power down signal                  */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ef_pll_pwrdn;

  } __ATTRIBUTE_PACKED__ pll_resets_reg;

  /* Test Mux Config: Clock Test Mux configuration.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0030 */

     /* TestMuxSel: 000 - QDR lock 001 - DDR CD lock 010 - DDR       */
     /* AB lock 011 - DDR EF lock 100 - QDR clock (after             */
     /* divider) 101 - DDR CD clock (after divider) 110 - DDR AB     */
     /* clock (after divider) 111 - DDR EF clock (after divider)     */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD test_mux_sel;

     /* TestMuxDiv: Clock divider for test mux. The clock is         */
     /* divided by (1<<TestMuxDiv).                                  */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD test_mux_div;
  /*
   *	CAUTION: the following register has in practice a different appearance (Alignment with Soc_petra-A).
   */

     /* DdrLock: If asserted, indicates that PLL of DDR is           */
     /* locked.                                                      */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_lock;

     /* QdrLock: If asserted, indicates that PLL of QDR is           */
     /* locked.                                                      */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_lock;

     /* CoreLock: If asserted, indicates that PLL of core is         */
     /* locked.                                                      */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD core_lock;

  } __ATTRIBUTE_PACKED__ test_mux_config_reg;

  /* Msb Mirror Data Bus: The MSB mirror data bus -                 */
  /* mdata[35:18].                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0031 */

     /* MsbMdataBus: mdata[35:18]                                    */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD msb_mdata_bus;

  } __ATTRIBUTE_PACKED__ msb_mirror_data_bus_reg;

  /* Lsb Mirror Data Bus: The LSB mirror data bus -                 */
  /* mdata[17:0].                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0032 */

     /* LsbMdataBus: mdata[17:0]                                     */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lsb_mdata_bus;

  } __ATTRIBUTE_PACKED__ lsb_mirror_data_bus_reg;

  /* Udr Reg0: The UDR LSB bits programmed in efuse.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0033 */

     /* UdrReg0: The UDR LSB bits programmed in efuse.               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD udr_reg0;

  } __ATTRIBUTE_PACKED__ udr_reg_reg[SOC_PB_ECI_UDR_REG_REG_NOF_REGS];

  /* Cpu Asynchronous Packet Data: This register holds the          */
  /* next transmitted packet word towards the CPU. It has the       */
  /* same meaning to data and command as in streaming mode.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0035 */

     /* TDATA: Holds the Packet word data                            */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdata;

     /* TCMD: Holds the Packet word command: 0 - SOP 1 - MOP 3 -     */
     /* EOP with 2 bytes valid 4 - EOP with 1 byte valid             */
     /* range: 18:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tcmd;

     /* TDV: Packet word valid This register is clear on read.       */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdv;

  } __ATTRIBUTE_PACKED__ cpu_asynchronous_packet_data_reg;

  /* Cpuif Transmit Flow Control Events Counter: Counter of         */
  /* flow control events via transmit interface (Soc_petra to           */
  /* CPU).                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0036 */

     /* CpuifTransmitFlowControlEventsCount: Counter value. This     */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpuif_transmit_flow_control_events_count;

     /* CpuifTransmitFlowControlEventsCountOverflow: Counter         */
     /* Overflow indication.                                         */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpuif_transmit_flow_control_events_count_overflow;

  } __ATTRIBUTE_PACKED__ cpuif_transmit_flow_control_events_counter_reg;

  /* Cpuif Recieve Flow Control Events Counter: Counter of          */
  /* flow-control events via receive interface (CPU to              */
  /* Soc_petra).                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0037 */

     /* CpuifRecieveFlowControlEventsCount: Counter value. This      */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpuif_recieve_flow_control_events_count;

     /* CpuifRecieveFlowControlEventsCountOverflow: Counter          */
     /* Overflow indication.                                         */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpuif_recieve_flow_control_events_count_overflow;

  } __ATTRIBUTE_PACKED__ cpuif_recieve_flow_control_events_counter_reg;

  /* Gtimer Configuration: Counters Gtimer configurations           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0038 */

     /* GtimerCycle: Period in cycles in which the counters will     */
     /* be active.                                                   */
     /* range: 29:0, access type: RW, default value: 30'd250000000   */
     SOC_PETRA_REG_FIELD gtimer_cycle;

     /* GtimerEnable: Count using Gtimer                             */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_enable;

     /* GtimerResetOnTrigger: If asserted, the counter is reset      */
     /* when triggered                                               */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_reset_on_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Gtimer Trigger: Gtimer Trigger Register.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0039 */

     /* GtimerTrigger: Trigger indicates to start counting by        */
     /* Gtimer.                                                      */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_trigger_reg;

  /* Malg Configurations: MAL Group Configuration. Controls          */
  /* the IEEE 1588 clock and sync signals.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x003b */

     /* MalgaPtpSyncForce: If set, force the MALGA PTP_SYNC          */
     /* input to 1.                                                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD malga_ptp_sync_force;

     /* MalgbPtpSyncForce: If set, force the MALGB PTP_SYNC          */
     /* input to 1.                                                  */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD malgb_ptp_sync_force;

     /* MalgaPtpClockPd: If set, will power down the MALGA           */
     /* PTP_CLK. As a result, PTP timers will pause and can be       */
     /* read.                                                        */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD malga_ptp_clock_pd;

     /* MalgbPtpClockPd: If set, will power down the MALGB           */
     /* PTP_CLK. As a result, PTP timers will pause and can be       */
     /* read.                                                        */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD malgb_ptp_clock_pd;

     /* MalgaPtpClockPause: If set, the IEEE 1588 MALGA PTP          */
     /* local timers will be paused. The PTP global timers will      */
     /* continue running, so once released, the local timers         */
     /* will resync to the global timers. Set to <1> to be able      */
     /* to read the PTP local timers.                                */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD malga_ptp_clock_pause;

     /* MalgbPtpClockPause: If set, the IEEE 1588 MALGB PTP          */
     /* local timers will be paused. The PTP global timers will      */
     /* continue running, so once released, the local timers         */
     /* will resync to the global timers. Set to <1> to be able      */
     /* to read the PTP local timers.                                */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD malgb_ptp_clock_pause;

  } __ATTRIBUTE_PACKED__ malg_configurations_reg;

  /* Pll Status: PLLs status.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x003c */

     /* DdrLock: If asserted, indicates that PLL of DDR is           */
     /* locked.                                                      */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_lock;

     /* DdrAbLock: If asserted, indicates that PLL of DDR AB is      */
     /* locked.                                                      */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ab_lock;

     /* DdrEfLock: If asserted, indicates that PLL of DDR EF is      */
     /* locked.                                                      */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ef_lock;

     /* QdrLock: If asserted, indicates that PLL of QDR is           */
     /* locked.                                                      */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_lock;

     /* CoreLock: If asserted, indicates that PLL of core is         */
     /* locked.                                                      */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD core_lock;

     /* DdrHsLock: If asserted, indicates that PLL of DDR HS is      */
     /* locked.                                                      */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_hs_lock;

     /* DdrAbHsLock: If asserted, indicates that PLL of DDR AB       */
     /* HS is locked.                                                */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_ab_hs_lock;

     /* DdrEfHsLock: If asserted, indicates that PLL of DDR EF       */
     /* HS is locked.                                                */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_ef_hs_lock;

  } __ATTRIBUTE_PACKED__ pll_status_reg;

  /* Select Output Of Synchronous Ethernet Pads : Select            */
  /* output of the Synchronous Ethernet pads                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x003d */

     /* SyncEthPad0Select: [010] Select clock 0 for PAD0 [011]       */
     /* Select clock 0 in CML mode (P) [1xx] Select valid            */
     /* indication of clock xx. [Other] Reserved                     */
     /* range: 2:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD sync_eth_pad0_select;

     /* SyncEthPad1Select: [010] Select clock 1 for PAD1 [011]       */
     /* Select clock 0 in CML mode (N) [1xx] Select valid            */
     /* indication of clock xx. [Other] Reserved                     */
     /* range: 6:4, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD sync_eth_pad1_select;

     /* SyncEthPad2Select: [010] Select clock 2 for PAD2 [011]       */
     /* Select clock 2 in CML mode (P) [1xx] Select valid            */
     /* indication of clock xx. [Other] Reserved                     */
     /* range: 10:8, access type: RW, default value: 0x2             */
     SOC_PETRA_REG_FIELD sync_eth_pad2_select;

     /* SyncEthPad3Select: [010] Select clock 3 for PAD3 [011]       */
     /* Select clock 2 in CML mode (N) [1xx] Select valid            */
     /* indication of clock xx. [Other] Reserved                     */
     /* range: 14:12, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD sync_eth_pad3_select;

     /* SyncEthPad0Oe n: If set to '0', the Synchronous Ethernet     */
     /* pad0 is output; otherwise input.                             */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD sync_eth_pad0_oe_n;

     /* SyncEthPad1Oe n: If set to '0', the Synchronous Ethernet     */
     /* pad1 is output; otherwise input.                             */
     /* range: 17:17, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD sync_eth_pad1_oe_n;

     /* SyncEthPad2Oe n: If set to '0', the Synchronous Ethernet     */
     /* pad2 is output; otherwise input.                             */
     /* range: 18:18, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD sync_eth_pad2_oe_n;

     /* SyncEthPad3Oe n: If set to '0', the Synchronous Ethernet     */
     /* pad3 is output; otherwise input.                             */
     /* range: 19:19, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD sync_eth_pad3_oe_n;

  } __ATTRIBUTE_PACKED__ select_output_of_synchronous_ethernet_pads_reg;

  /* Mdio Cfg: MDIO Configuration Register.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0080 */

     /* CFG TICK CNT: Number of core clock cycles (250 MHz) in       */
     /* each MDC phase. According to IEEE spec, MDC frequency        */
     /* should not exceed 2.5 MHz. Use value of <50> (or higher)     */
     /* for 2.5 MHz MDC clock (or slower).                           */
     /* range: 11:0, access type: UNDEF, default value: 0x32         */
     SOC_PETRA_REG_FIELD cfg_tick_cnt;

     /* CFG TA LENGTH: Reserved. Number of Turn Around (TA) bits     */
     /* to wait between Tx and Rx of data. Use value of <1>.         */
     /* range: 14:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cfg_ta_length;

     /* CFG MDC FREE RUNNING: If set, MDC clock will be free         */
     /* running. Otherwise, MDC will only toggle when MDIO           */
     /* transaction is in progress.                                  */
     /* range: 15:15, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD cfg_mdc_free_running;

     /* CFG INIT: If set, all MDIO registers and FSM will be         */
     /* reset. Set to <0> for normal operation.                      */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cfg_init;

     /* CFG PD: Power Down mode. If set, MDIO clocks will be         */
     /* disabled. Set to <0> for normal operation.                   */
     /* range: 17:17, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cfg_pd;

     /* CFG_DRIVE_IDLE: If set, drive MDIO signal to 0 while         */
     /* MDIO state machine is in idle mode. Otherwise, drive         */
     /* MDIO signal to High-z.                                       */
     /* range: 18:18, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD cfg_drive_idle;

  } __ATTRIBUTE_PACKED__ mdio_cfg_reg;

  /* Mdio Op: MDIO OP Register. OP is dispatched after it is         */
  /* written to this register. When read, returns the last           */
  /* dispatched OP.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0081 */

     /* OP DATA: Data to write to device. If this is a READ OP,      */
     /* this data will be ignored. If clause 45 format is used,      */
     /* this is the ADDRESS/DATA field.                              */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD op_data;

     /* OP TA: TurnAround bits are needed for READ Ops               */
     /* (contention prevention). In WRITE Ops simply transmit        */
     /* <10>.                                                        */
     /* range: 17:16, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD op_ta;

     /* OP REGAD: Address of a register of the PHY device. If        */
     /* the clause 45 format is used, this is the DEVAD field        */
     /* (Device Address).                                            */
     /* range: 22:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD op_regad;

     /* OP_PHYAD: Address of a PHY device. If clause 45 format       */
     /* is used, this is the PRTAD field (Port Address).             */
     /* range: 27:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD op_phyad;

     /* OP_OP: OP type. Use <10> for read or <01> for write OP.      */
     /* If clause 45 format is used, use also <00> to write to       */
     /* address register and <11> for read with automatic            */
     /* address increment after read.                                */
     /* range: 29:28, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD op_op;

     /* OP ST: Start of frame. Use <01> for IEEE 802.3 clause 22     */
     /* compliance, and <00> for clause 45 compliance.               */
     /* range: 31:30, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD op_st;

  } __ATTRIBUTE_PACKED__ mdio_op_reg;

  /* Mdio Stat: MDIO Status Register. This register returns          */
  /* the results of the last dispatched OP.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0082 */

     /* STAT DATA: For READ Ops, this is the data returned from      */
     /* the PHY device. For WRITE Ops this is the DATA/ADDRESS       */
     /* field of the MdioOp register.                                */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_data;

     /* STAT TA: TA field of the MdioOp register.                    */
     /* range: 17:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_ta;

     /* STAT REGAD: REGAD/DEVAD field of the MdioOp register.        */
     /* range: 22:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_regad;

     /* STAT PHYAD: PHYAD/PRTAD field of the MdioOp register.        */
     /* range: 27:23, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_phyad;

     /* STAT RD EN: MSB of the OP field of the MdioOp register.      */
     /* <1> indicates this was a READ OP, <0> indicates a WRITE      */
     /* OP.                                                          */
     /* range: 29:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rd_en;

     /* STAT TYPE: LSB of the OP ST field. <1> for Clause 22         */
     /* format, and <0> for clause 45 format.                        */
     /* range: 30:30, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_type;

     /* STAT VALID: Indicates execution of last dispatched OP is     */
     /* complete.                                                    */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_valid;

  } __ATTRIBUTE_PACKED__ mdio_stat_reg;

  /* Soc_petra Soft Init1: When triggered, the corresponding            */
  /* block will perform a software init. No need to                 */
  /* reconfigure the corresponding block.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0085 */

     /* MccInit: Performs soft init for the MCC block.               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mcc_init;

     /* CfcInit: Performs soft init for the MCC block.               */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfc_init;

     /* MdioInit: Performs soft init for the MDIO block.             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mdio_init;

  } __ATTRIBUTE_PACKED__ soc_petra_soft_init1_reg;

  /* Power Up Configurations: Power-Up Configurations.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0086 */

     /* CpuifMode: 0 - Asynchronous mode is selected. 1 -            */
     /* Streaming mode is selected.                                  */
     /* range: 0:0, access type: RO, default value: PUC              */
     SOC_PETRA_REG_FIELD cpuif_mode;

     /* CpuifSpeed: 0 - 125 MHz DDR 1 - 125 MHz SDR 2 - 62.5 MHz     */
     /* DDR 3 - 62.5 MHz SDR                                         */
     /* range: 2:1, access type: RO, default value: PUC              */
     SOC_PETRA_REG_FIELD cpuif_speed;

     /* CpuifOutPhase: 00 - Data is in phase with the clock. 01      */
     /* - Data is 90 degrees to the clock. 10 - Data is 180          */
     /* degrees to the clock. 11 - Data is 270 degrees to the        */
     /* clock.                                                       */
     /* range: 4:3, access type: RO, default value: PUC              */
     SOC_PETRA_REG_FIELD cpuif_out_phase;

     /* CpuifInPhase: 0 - Clock phase is inverted. 1 - Clock         */
     /* keeps phase.                                                 */
     /* range: 5:5, access type: RO, default value: PUC              */
     SOC_PETRA_REG_FIELD cpuif_in_phase;

     /* CpuifEnableOdt: Enable ODT on CPU streaming inputs: 0 -      */
     /* Disabled (no ODT). 1 - ODT is enabled                        */
     /* range: 6:6, access type: RO, default value: PUC              */
     SOC_PETRA_REG_FIELD cpuif_enable_odt;

     /* CpuifDrv: Reflects drive strength of CPU streaming I/Os.     */
     /* range: 7:7, access type: RO, default value: PUC              */
     SOC_PETRA_REG_FIELD cpuif_drv;

     /* CorePllRefClockDivider: Core PLL input reference             */
     /* clock-divider.                                               */
     /* range: 9:8, access type: RO, default value: PUC              */
     SOC_PETRA_REG_FIELD core_pll_ref_clock_divider;

     /* Pvalue: Set to '011'                                         */
     /* range: 12:10, access type: RO, default value: PUC            */
     SOC_PETRA_REG_FIELD pvalue;

     /* CorePllVcoFbClockDivider: Core PLL VCO feedback clock        */
     /* divider.                                                     */
     /* range: 16:13, access type: RO, default value: PUC            */
     SOC_PETRA_REG_FIELD core_pll_vco_fb_clock_divider;

     /* NoMemRepairMode: No memory repair mode.                      */
     /* range: 17:17, access type: RO, default value: PUC            */
     SOC_PETRA_REG_FIELD no_mem_repair_mode;

  } __ATTRIBUTE_PACKED__ power_up_configurations_reg;

  /* Interrupt Block Mask Register: Each bit in this register       */
  /* corresponds to the interrupt source in the                     */
  /* InterruptBlockSourceRegister. The interrupt source is          */
  /* masked by writing 0 to the relevant bit in this                */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0100 */

     /* IpsIntMask: Writing 0 masks the IPS interrupt source.        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ips_int_mask;

     /* IqmIntMask: Writing 0 masks the IQM interrupt source.        */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD iqm_int_mask;

     /* QdrIntMask: Writing 0 masks the QDR interrupt source.        */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_int_mask;

     /* IptIntMask: Writing 0 masks the IPT interrupt source.        */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ipt_int_mask;

     /* MmuIntMask: Writing 0 masks the MMU interrupt source.        */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mmu_int_mask;

     /* DprcaIntMask: Writing 0 masks the DPRCA interrupt            */
     /* source.                                                      */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprca_int_mask;

     /* DprcbIntMask: Writing 0 masks the DPRCB interrupt            */
     /* source.                                                      */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcb_int_mask;

     /* DprccIntMask: Writing 0 masks the DPRCC interrupt            */
     /* source.                                                      */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcc_int_mask;

     /* DprcdIntMask: Writing 0 masks the DPRCD interrupt            */
     /* source.                                                      */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcd_int_mask;

     /* DprceIntMask: Writing 0 masks the DPRCE interrupt            */
     /* source.                                                      */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprce_int_mask;

     /* DprcfIntMask: Writing 0 masks the DPRCF interrupt            */
     /* source.                                                      */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dprcf_int_mask;

     /* IreIntMask: Writing 0 masks the IRE interrupt source.        */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ire_int_mask;

     /* IhpIntMask: Writing 0 masks the IHP interrupt source.        */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ihp_int_mask;

     /* IdrIntMask: Writing 0 masks the IDR interrupt source.        */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD idr_int_mask;

     /* IrrIntMask: Writing 0 masks the IRR interrupt source.        */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD irr_int_mask;

     /* FdtIntMask: Writing 0 masks the FDT interrupt source.        */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdt_int_mask;

     /* FdrIntMask: Writing 0 masks the FDR interrupt source.        */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_int_mask;

     /* FctIntMask: Writing 0 masks the FCT interrupt source.        */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fct_int_mask;

     /* FcrIntMask: Writing 0 masks the FCR interrupt source.        */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fcr_int_mask;

     /* RtpIntMask: Writing 0 masks the RTP interrupt source.        */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rtp_int_mask;

     /* EgqIntMask: Writing 0 masks the EGQ interrupt source.        */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_int_mask;

     /* EpniIntMask: Writing 0 masks the EPNI interrupt source.      */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD epni_int_mask;

     /* MacaIntMask: Writing 0 masks the MACA interrupt source.      */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD maca_int_mask;

     /* MacbIntMask: Writing 0 masks the MACB interrupt source.      */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD macb_int_mask;

     /* MaccIntMask: Writing 0 masks the MACC interrupt source.      */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD macc_int_mask;

     /* SchIntMask: Writing 0 masks the SCH interrupt source.        */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sch_int_mask;

     /* OlpIntMask: Writing 0 masks the OLP interrupt source.        */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD olp_int_mask;

     /* CfcIntMask: Writing 0 masks the CFC interrupt source.        */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cfc_int_mask;

     /* MswIntMask: Writing 0 masks the MSW interrupt source.        */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD msw_int_mask;

     /* IhbIntMask: Writing 0 masks the IHB interrupt source.        */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ihb_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_block_mask_reg;

  /* Interrupt Block Mask Register Cont: Each bit in this           */
  /* register corresponds to the interrupt source in the            */
  /* InterruptBlockSourceRegister. The interrupt source is          */
  /* masked by writing 0 to the relevant bit in this                */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0101 */

     /* MalgaIntMask: Writing 0 masks the MALGA interrupt            */
     /* source.                                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD malga_int_mask;

     /* MalgbIntMask: Writing 0 masks the MALGB interrupt            */
     /* source.                                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD malgb_int_mask;

     /* MdioIntMask: Writing 0 masks the MDIO interrupt source.      */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mdio_int_mask;

     /* MbuIntMask: Writing 0 masks the MBU interrupt source.        */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mbu_int_mask;

     /* NbiIntMask: Writing 0 masks the NBI interrupt source.        */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nbi_int_mask;

     /* EciIntMask: Writing 0 masks the ECI interrupt source.        */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD eci_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_block_mask_register_cont_reg;

  /* Interrupt Block Source Register: A bit read HIGH               */
  /* indicates that there is an interrupt from the                  */
  /* corresponding source. This bit will only be cleared            */
  /* after the interrupt source is handled inside the               */
  /* relevant block.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0104 */

     /* IpsIntReg: IPS interrupt was set.                            */
     /* range: 0:0, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD ips_int_reg;

     /* IqmIntReg: IQM interrupt was set.                            */
     /* range: 1:1, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD iqm_int_reg;

     /* QdrIntReg: QDR interrupt was set.                            */
     /* range: 2:2, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD qdr_int_reg;

     /* IptIntReg: IPT interrupt was set.                            */
     /* range: 3:3, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD ipt_int_reg;

     /* MmuIntReg: MMU interrupt was set.                            */
     /* range: 4:4, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD mmu_int_reg;

     /* DprcaIntReg: DPRCA interrupt was set.                        */
     /* range: 5:5, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD dprca_int_reg;

     /* DprcbIntReg: DPRCB interrupt was set.                        */
     /* range: 6:6, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD dprcb_int_reg;

     /* DprccIntReg: DPRCC interrupt was set.                        */
     /* range: 7:7, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD dprcc_int_reg;

     /* DprcdIntReg: DPRCD interrupt was set.                        */
     /* range: 8:8, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD dprcd_int_reg;

     /* DprceIntReg: DPRCE interrupt was set.                        */
     /* range: 9:9, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD dprce_int_reg;

     /* DprcfIntReg: DPRCF interrupt was set.                        */
     /* range: 10:10, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD dprcf_int_reg;

     /* IreIntReg: IRE interrupt was set.                            */
     /* range: 11:11, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD ire_int_reg;

     /* IhpIntReg: IHP interrupt was set.                            */
     /* range: 12:12, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD ihp_int_reg;

     /* IdrIntReg: IDR interrupt was set.                            */
     /* range: 13:13, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD idr_int_reg;

     /* IrrIntReg: IRR interrupt was set.                            */
     /* range: 14:14, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD irr_int_reg;

     /* FdtIntReg: FDT interrupt was set.                            */
     /* range: 15:15, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD fdt_int_reg;

     /* FdrIntReg: FDR interrupt was set.                            */
     /* range: 16:16, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD fdr_int_reg;

     /* FctIntReg: FCT interrupt was set.                            */
     /* range: 17:17, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD fct_int_reg;

     /* FcrIntReg: FCR interrupt was set.                            */
     /* range: 18:18, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD fcr_int_reg;

     /* RtpIntReg: RTP interrupt was set.                            */
     /* range: 19:19, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD rtp_int_reg;

     /* EgqIntReg: EGQ interrupt was set.                            */
     /* range: 20:20, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD egq_int_reg;

     /* EpniIntReg: EPNI interrupt was set.                          */
     /* range: 21:21, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD epni_int_reg;

     /* MacaIntReg: MACA interrupt was set.                          */
     /* range: 22:22, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD maca_int_reg;

     /* MacbIntReg: MACB interrupt was set.                          */
     /* range: 23:23, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD macb_int_reg;

     /* MaccIntReg: MACC interrupt was set.                          */
     /* range: 24:24, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD macc_int_reg;

     /* SchIntReg: SCH interrupt was set.                            */
     /* range: 25:25, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD sch_int_reg;

     /* OlpIntReg: OLP interrupt was set.                            */
     /* range: 26:26, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD olp_int_reg;

     /* CfcIntReg: CFC interrupt was set.                            */
     /* range: 27:27, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD cfc_int_reg;

     /* MswIntReg: MSW interrupt was set.                            */
     /* range: 28:28, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD msw_int_reg;

     /* IhbIntReg: IHB interrupt was set.                            */
     /* range: 29:29, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD ihb_int_reg;

  } __ATTRIBUTE_PACKED__ interrupt_block_source_reg;

  /* Interrupt Block Source Register Cont: A bit read HIGH          */
  /* indicates that there is an interrupt from the                  */
  /* corresponding source. This bit will only be cleared            */
  /* after the interrupt source is handled inside the               */
  /* relevant block.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0105 */

     /* MalgaIntReg: MALGA interrupt was set.                        */
     /* range: 0:0, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD malga_int_reg;

     /* MalgbIntReg: MALGB interrupt was set.                        */
     /* range: 1:1, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD malgb_int_reg;

     /* MdioIntReg: MDIO interrupt was set.                          */
     /* range: 2:2, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD mdio_int_reg;

     /* MbuIntReg: MBU interrupt was set.                            */
     /* range: 3:3, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD mbu_int_reg;

     /* NbiIntReg: NBI interrupt was set.                            */
     /* range: 4:4, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD nbi_int_reg;

     /* EciIntReg: ECI interrupt was set.                            */
     /* range: 5:5, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD eci_int_reg;

  } __ATTRIBUTE_PACKED__ interrupt_block_source_register_cont_reg;

  /* Mask All Interrupts:                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0108 */

     /* AllIntMask: When set LOW, masks all interrupt sources.       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD all_int_mask;

  } __ATTRIBUTE_PACKED__ mask_all_interrupts_reg;

  /* Override Interrupt:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0109 */

     /* OverrideInterrupt: If set, interrupt pin is active           */
     /* regardless interrupt sources.                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD override_interrupt;

  } __ATTRIBUTE_PACKED__ override_interrupt_reg;

  /* Ddr Pll Hs Config: DDR High Speed PLL configuration.           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x01d6 */

     /* DdrPllHsDivf: DIVF value for DDR High Speed PLL              */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_pll_hs_divf;

     /* DdrPllHsDivr: DIVR value for DDR High Speed PLL              */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ddr_pll_hs_divr;

     /* DdrPllHsDivq: DIVQ value for DDR High Speed PLL              */
     /* range: 14:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_pll_hs_divq;

     /* DdrUseHsPll: If set, the high speed PLL will be used.        */
     /* Otherwise the regular PLL will be used.                      */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_use_hs_pll;

  } __ATTRIBUTE_PACKED__ ddr_pll_hs_config_reg;

  /* Ddr Ab Pll Hs Config: DDR AB High Speed PLL                    */
  /* configuration.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x01d7 */

     /* DdrAbPllHsDivf: DIVF value for DDR AB High Speed PLL         */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ab_pll_hs_divf;

     /* DdrAbPllHsDivr: DIVR value for DDR AB High Speed PLL         */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ddr_ab_pll_hs_divr;

     /* DdrAbPllHsDivq: DIVQ value for DDR AB High Speed PLL         */
     /* range: 14:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_ab_pll_hs_divq;

     /* DdrAbUseHsPll: If set, the high speed PLL will be used       */
     /* for DDR AB. Otherwise the regular PLL will be used.          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_ab_use_hs_pll;

  } __ATTRIBUTE_PACKED__ ddr_ab_pll_hs_config_reg;

  /* Ddr Ef Pll Hs Config: DDR EF High Speed PLL                    */
  /* configuration.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x01d8 */

     /* DdrEfPllHsDivf: DIVF value for DDR EF High Speed PLL         */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_ef_pll_hs_divf;

     /* DdrEfPllHsDivr: DIVR value for DDR EF High Speed PLL         */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ddr_ef_pll_hs_divr;

     /* DdrEfPllHsDivq: DIVQ value for DDR EF High Speed PLL         */
     /* range: 14:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_ef_pll_hs_divq;

     /* DdrEfUseHsPll: If set, the high speed PLL will be used       */
     /* for DDR EF. Otherwise the regular PLL will be used.          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_ef_use_hs_pll;

  } __ATTRIBUTE_PACKED__ ddr_ef_pll_hs_config_reg;

  /* Scratch Pad0:                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x01d9 */

     /* ScratchPad0: Software scratch pad0                           */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD scratch_pad0;

  } __ATTRIBUTE_PACKED__ scratch_pad_reg[SOC_PB_ECI_SCRATCH_PAD_REG_NOF_REGS];

  /* Egress Pp Configuration Register: EgressPP                     */
  /* configurations.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x01db */

     /* EgressPpConfiguration: Egress Configurations                 */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD egress_pp_configuration;

  } __ATTRIBUTE_PACKED__ egress_pp_configuration_reg[SOC_PB_ECI_EGRESS_PP_CONFIGURATION_REG_MULT_NOF_REGS];

  /* Mbist Clock Power Down Register: Mbist clock power down.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x01dd */

     /* MbistClockPd: Mbist clock power down.                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mbist_clock_pd;

  } __ATTRIBUTE_PACKED__ mbist_clock_power_down_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_ECI_REGS;
/* Block definition: OLP 	 */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4400 */

     /* EndReadErr: If set, indicates that an end indication         */
     /* error during a read command has occurred on the Command      */
     /* Reception Machine (CRM).                                     */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_read_err;

     /* EndWriteErr: If set, indicates that an end indication        */
     /* error during a write command has occurred on the Command     */
     /* Reception Machine (CRM).                                     */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_write_err;

     /* StartErr: If set, indicates that a start indication          */
     /* error has occurred on the Command Reception Machine          */
     /* (CRM).                                                       */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD start_err;

     /* EndReadExpErr: If set, indicates that an end indication      */
     /* during a read command did not assert compared to the         */
     /* expected value on the Command Reception Machine (CRM).       */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_read_exp_err;

     /* EndWriteExpErr: If set, indicates that an end indication     */
     /* during a write command did not assert compared to the        */
     /* expected value on the Command Reception Machine (CRM).       */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_write_exp_err;

     /* StartExpErr: If set, indicates that a start indication       */
     /* did not assert compared to the expected value on the         */
     /* Command Reception Machine (CRM).                             */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD start_exp_err;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4410 */

     /* EndReadErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_read_err_mask;

     /* EndWriteErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_write_err_mask;

     /* StartErrMask: Writing 0 masks the corresponding              */
     /* interrupt source                                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD start_err_mask;

     /* EndReadExpErrMask: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_read_exp_err_mask;

     /* EndWriteExpErrMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_write_exp_err_mask;

     /* StartExpErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD start_exp_err_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Indirect Command Wr Data: Indirect write data - data           */
  /* that will be written to the addressed object when an           */
  /* indirect write operation is triggered.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4420 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg;

  /* Indirect Command Rd Data: Indirect read data - data is         */
  /* returned by an indirect read operation.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4430 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg;

  /* Indirect Command: Used to send indirect commands and           */
  /* receive their status.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4440 */

     /* IndirectCommandTrigger: Trigger indirect access, as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one for each write command. If set to 0,         */
     /* only one operation is performed. The CPU can read this       */
     /* field to find the number of writes that are left to          */
     /* perform.                                                     */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then the last command failed on             */
     /* timeout.                                                     */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4441 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4442 */

     /* IndirectCommandDataIncrement:                                */
     /* IndirectCommandWrData[31:0] is incremented by this value     */
     /* after every indirect write. Addition is cyclic.              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_OLP_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* Gtimer Configuration:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4500 */

     /* GtimerCycle: The number of clocks the gtimer will count.     */
     /* range: 29:0, access type: RW, default value: 30'd250_000_000 */
     SOC_PETRA_REG_FIELD gtimer_cycle;

     /* GtimerEnable: Whether to use all the counters in gtimer      */
     /* mode or read on clear                                        */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_enable;

     /* GtimerResetOnTrigger: If set, the gtimer will output a       */
     /* reset signal when the count begins.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_reset_on_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Gtimer Trigger:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4501 */

     /* GtimerTrigger: When this register is written to, the         */
     /* gtimer starts counting. When this register is read, it       */
     /* gives the gtimer status (1= still counting, 0=count is       */
     /* over).                                                       */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_trigger_reg;

  /* Incremental Mode Configurations: Packet Generation             */
  /* Engine (PGE) Incremental Mode Configurations.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4523 */

     /* IncVal: Packet Generation Engine (PGE) Incremental           */
     /* Value. A 16b value to add to a specific 16 bits in the       */
     /* Packet.                                                      */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD inc_val;

     /* IncOffset: Packet Generation Engine (PGE) Incremental        */
     /* Offset. Determines a specific 2 bytes to be added to         */
     /* IncVal. (Alignment is in 2-Bytes resolution).                */
     /* range: 28:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD inc_offset;

  } __ATTRIBUTE_PACKED__ incremental_mode_configurations_reg;

  /* Packet Configuration Register: Packet Generation Engine        */
  /* (PGE) Packet Configuration register.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4524 */

     /* PcktLength: The size of the packet generated by the          */
     /* Packet Generation Engine (PGE)                               */
     /* range: 13:0, access type: RW, default value: 0x7f            */
     SOC_PETRA_REG_FIELD pckt_length;

     /* PcktLengthMode: Packet Generation Engine (PGE) Mode for      */
     /* the case when the PcktLength is bigger than 128 bytes: 0     */
     /* - cyclic mode - the PgeMem will be repeatedly                */
     /* concatenated until required size is achieved. 1-             */
     /* incremental mode - the packet is padded by 32b words         */
     /* until size is achieved. Each new 32b word is the sum of      */
     /* previous 32b word and PcktLengthIncVal.                      */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pckt_length_mode;

  } __ATTRIBUTE_PACKED__ packet_configuration_reg;

  /* Packet Counter Configuration: Packet Generation Engine         */
  /* (PGE) Packet Counter.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4525 */

     /* PcktCnt: Number of packets to be generated by the PGE.       */
     /* 0xffffffff - indicates continuous mode 0x0 - stops the       */
     /* PGE on the next packet boundary.                             */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pckt_cnt;

  } __ATTRIBUTE_PACKED__ packet_counter_configuration_reg;

  /* Packet Delay Configuration: Packet Generation Engine           */
  /* (PGE) Packet Delay.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4526 */

     /* PcktDelay: Number of cycles delay between one packet and     */
     /* the next, in addition to 4 cycles delay.                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pckt_delay;

  } __ATTRIBUTE_PACKED__ packet_delay_configuration_reg;

  /* Packet Length Incremental Value: Packet Generation             */
  /* Engine (PGE) Packet Length Incremental value.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4527 */

     /* PcktLengthIncVal: A 32b value to add to the next 32b         */
     /* word when PcktLengthMode is 1 (incremental).                 */
     /* range: 31:0, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD pckt_length_inc_val;

  } __ATTRIBUTE_PACKED__ packet_length_incremental_value_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_OLP_REGS;
/* Block definition: NIF 	 */
typedef struct
{
  uint32   nof_instances; /* 2 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: NIF Main interrupt register.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5000 */

     /* MalInterrupt: MAL Interrupts. (For further information,      */
     /* see InterruptRegister for MAC Lanes 0~7)                     */
     /* range: 7:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD mal_interrupt;

     /* SrdInterrupt: If set, indicates an interrupt was             */
     /* generated by one of the SerDes lanes or the IPU (8051)       */
     /* in the corresponding SRD Group.                              */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD srd_interrupt;

     /* PaebInterrupt: If set, indicates an error interrupt was      */
     /* generated by one of the PAEB synchronizers on the Rx         */
     /* data path. Such errors may be the result of a link           */
     /* partner with too large PPM (in GMII modes) or a              */
     /* synchronization error (in XAUI, RXAUI and QSGMII modes).     */
     /* See RxPaebErrInterrupt register to determine on which        */
     /* PAEB the error occurred.                                     */
     /* range: 9:9, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD paeb_interrupt;

     /* SyncEthInterrupt: If set, indicate status change of the      */
     /* primary or secondary recovered clocks.                       */
     /* range: 10:10, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD sync_eth_interrupt;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Srd Interrupt Register: Secondary interrupt register           */
  /* holding SerDes interrupts.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5001 */

     /* SrdLaneInterrupt: Interrupts from the 16 SerDes lanes.       */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd_lane_interrupt;

     /* SrdIpuInterrupt: If set, indicates that IPU (8051)           */
     /* triggered an interrupt (due to 8051 parity error, IntReq     */
     /* or IntAck).                                                  */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt;

     /* SrdEpbInterrupt: If set, indicates that EPB FSM detected     */
     /* overrun error. This error is caused when an EPB_OP is        */
     /* dispatched when a previous EPB_OP is still executing.        */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt;

  } __ATTRIBUTE_PACKED__ srd_interrupt_reg;

  /* Paeb Interrupt Register: Secondary interrupt register          */
  /* holding PAEB interrupts.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5002 */

     /* RxPaebErrInterrupt: Interrupts from the 26 PAEB              */
     /* synchronizers on the Rx path. Bits 0-3 represent lanes       */
     /* 0-3 of MAL-0, bits 4-5 represent lane 0-1 of MAL-1, ...,     */
     /* bits 22-23 represent lane 0-1 of MAL-7. Bits 24, 25 and      */
     /* 26 represent the PAEBs connecting MAL-5, MAL-6 and MAL-7     */
     /* to their alternative SRD (respectively).                     */
     /* range: 26:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_paeb_err_interrupt;

  } __ATTRIBUTE_PACKED__ paeb_interrupt_reg;

  /* Interrupt Mask Register: Interrupt Mask Register.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5010 */

     /* MalInterruptMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mal_interrupt_mask;

     /* SrdInterruptMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD srd_interrupt_mask;

     /* PaebInterruptMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD paeb_interrupt_mask;

     /* SyncEthInterruptMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sync_eth_interrupt_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Srd Interrupt Mask Register: SerDes Interrupt Mask             */
  /* Register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5011 */

     /* SrdLaneInterruptMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd_lane_interrupt_mask;

     /* SrdIpuInterruptMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt_mask;

     /* SrdEpbInterruptMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt_mask;

  } __ATTRIBUTE_PACKED__ srd_interrupt_mask_reg;

  /* Paeb Interrupt Mask Register: PAEB Interrupt Mask              */
  /* Register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5012 */

     /* RxPaebErrInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 26:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_paeb_err_interrupt_mask;

  } __ATTRIBUTE_PACKED__ paeb_interrupt_mask_reg;

  /* NIF Enabled: Port enabled register                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5060 */

     /* PortEnabled: Indicates the corresponding NIF port is         */
     /* enabled. Value of <1> indicates port is enabled. Value       */
     /* of <0> indicates port is disabled (in reset). This           */
     /* indication does not reflect the status of the ILKN           */
     /* ports.                                                       */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_enabled;

  } __ATTRIBUTE_PACKED__ nif_enabled_reg;

  /* NIF Status: Port link status register                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5061 */

     /* PortLinkStatus: Indicates the link status of the             */
     /* corresponding NIF port. Value of <1> indicates link is       */
     /* up. Value of <0> indicates link is down. This is a           */
     /* latch-low sticky signal (i.e., it is cleared if link         */
     /* fails and remains 0 until read by CPU). This indication      */
     /* does not reflect the status of the ILKN ports. This          */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_link_status;

  } __ATTRIBUTE_PACKED__ nif_status_reg;

  /* NIF Tx Active: Link Tx activity register                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5062 */

     /* PortTxActive: Indicates Tx activity in the corresponding     */
     /* NIF port. Value of <1> indicates there was Tx traffic        */
     /* since the register was last read. This indication does       */
     /* not reflect the status of the ILKN ports. This register      */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_tx_active;

  } __ATTRIBUTE_PACKED__ nif_tx_active_reg;

  /* NIF Rx Active: Link Rx activity register                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5063 */

     /* PortRxActive: Indicates Rx activity in the corresponding     */
     /* NIF port. Value of <1> indicates there was Rx traffic        */
     /* since the register was last read. This indication does       */
     /* not reflect the status of the ILKN ports. This register      */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_rx_active;

  } __ATTRIBUTE_PACKED__ nif_rx_active_reg;

  /* NIF Config: Global NIF configuration and status register       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5064 */

     /* IlknMode: If set, QSRD-0/1/2 will be connected to the        */
     /* ILKN port. QSRD-3 is unaffected. Each bit corresponds to     */
     /* a different QSRD. Set all bits to <1> for normal ILKN        */
     /* modes. If IHP-ELK interfaces is configured on MAL-12         */
     /* then set bit [2] to <0>.                                     */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_mode;

     /* IlknRxAltClockSel: If set, ILKN will select Rx recovered     */
     /* clock from lane 4. Otherwise, recovered clock from lane      */
     /* 0 is used.                                                   */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx_alt_clock_sel;

     /* IlknTxAltClockSel: If set, ILKN will select Tx clock         */
     /* from lane 4. Otherwise, clock from lane 0 is used.           */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_tx_alt_clock_sel;

     /* Serdes_G4_En: If set, the fourth SerDes group (QSRD-3)       */
     /* will be used by the NIF. Otherwise, it is used by the        */
     /* fabric MAC.                                                  */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD serdes_g4_en;

     /* FabricFecMode: If set, the COMBO SRDs will drive raw         */
     /* data to the Fabric-MAC/MSW. This is required when the        */
     /* MAC operates in FEC mode, and is only relevant if            */
     /* Serdes_G4_En is set. Each bit represents a different SRD     */
     /* lane whithin the QSRD.                                       */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fabric_fec_mode;

     /* MAL5 QsgmiiAltSrd: If set, MAL-5 will use alternative        */
     /* SerDes lane from QSRD-0, SRD lane 1. Otherwise, MAL-5        */
     /* will use its normally assigned SerDes (QSRD-2, lane 2).      */
     /* This register may only be set if MAL-5 and MAL-0+1 are       */
     /* all in QSGMII mode or disabled.                              */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mal5_qsgmii_alt_srd;

     /* MAL6 QsgmiiAltSrd: If set, MAL-6 will use alternative        */
     /* SerDes lane from QSRD-1, SRD lane 3. Otherwise, MAL-6        */
     /* will use its normally assigned SerDes (QSRD-3, lane 0).      */
     /* This register may only be set if MAL-6 and MAL-0+1 are       */
     /* all in QSGMII mode or disabled.                              */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mal6_qsgmii_alt_srd;

     /* MAL7 QsgmiiAltSrd: If set, MAL-7 will use alternative        */
     /* SerDes lane from QSRD-0, SRD lane 3. Otherwise, MAL-7        */
     /* will use its normally assigned SerDes (QSRD-3, lane 2).      */
     /* This register may only be set if MAL-7 and MAL-2+3 are       */
     /* all in QSGMII mode or disabled.                              */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mal7_qsgmii_alt_srd;

  } __ATTRIBUTE_PACKED__ nif_config_reg;

  /* NIF Rx Clocks: Select clock for Rx pathEach MAL has an         */
  /* independet clock selection. (XAUI mode is only                 */
  /* applicable for MAL-0,2,4,6).                                   */
  /* NIF Tx Clocks: Select clock for Tx pathTx clock of each        */
  /* pair of MALs (i.e. MAL-0+1, MAL-2+3, MAL4+5, MAL-6+7) is       */
  /* coupled. The proper clock must be selected for the even        */
  /* MALs (i.e. MAL-0,2,4,6) even if it is powered down. If         */
  /* powered down, the MSB of the selector may be set to <0>.       */
  /* Odd MALs (i.e. MAL-1,3,5,7) may have the same clock as         */
  /* their respective even MAL, or they may be powered down.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5065 */

     /* MAL Rx0ClockSelect: Select clock for MAL 0 Rx path:          */
     /* [0000] - Power Down [1000] - XAUI mode (Rx10b) [1001] -      */
     /* GMII mode (Tx10b) [1010] - RXAUI mode (Rx20b) [1011] -       */
     /* QSGMII (Rx40b) [0100] - ILKN (Rx20b) [Other] - Reserved      */
     /* range: 3:0, access type: RW, default value: 0x8              */
     SOC_PETRA_REG_FIELD mal_clock_select[SOC_PB_REG_NOF_MALS_IN_MALG];
  } __ATTRIBUTE_PACKED__ nif_clocks_reg[SOC_PB_REG_NOF_NIF_DIRECTIONS];

  /* NIF Qsgmii Reset: QSGMII uses an internal clock divider        */
  /* to achieve proper clock frequency. This register resets        */
  /* these clock dividers.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5067 */

     /* MalRxQsgmiiPhaseRstn: If set to 0, QSGMII Rx clock           */
     /* divider will be reset. It is required to reset this          */
     /* mechanism (rising edge of this register) after SRD           */
     /* clocks are valid.                                            */
     /* range: 7:0, access type: RW, default value: 0x0              */
     /* MalTxQsgmiiPhaseRstn: If set to 0, QSGMII Tx clock           */
     /* divider will be reset. It is required to reset this          */
     /* mechanism (rising edge of this register) after SRD           */
     /* clocks are valid.                                            */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mal_qsgmii_phase_rstn[SOC_PB_REG_NOF_MALS_IN_MALG][SOC_PB_REG_NOF_NIF_DIRECTIONS];
  } __ATTRIBUTE_PACKED__ nif_qsgmii_reset_reg;

  /* NIF Mal Reset: Soft-reset and Hard-reset for specific          */
  /* MALs.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5068 */

     /* InitMalHardReset: Reserved (set to 0). If set,               */
     /* coresponding MAL will be hard reset (including CPU           */
     /* registers).                                                  */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD init_mal_hard_reset;

     /* InitMalSoftReset: Reserved (set to 0). If set,               */
     /* coresponding MAL will be soft reset (excluding CPU           */
     /* registers).                                                  */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD init_mal_soft_reset;

  } __ATTRIBUTE_PACKED__ nif_mal_reset_reg;

  /* NIF Paeb Reset2 - NIF Paeb Reset5, the relevant feilds         */
  /* Note! ACCESS via fields only, not register                     */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x506a - 0x506d */
    /* Rx0Ln0PaebRdPtrRst - Rx7bLn0PaebRdPtrRst:                    */
    /* Access type: RW, default value: 0x8                          */
    SOC_PETRA_REG_FIELD rx_ln0_paeb_rd_ptr_rst[SOC_PB_REG_NIF_NOF_PAEB_FLDS];
  } __ATTRIBUTE_PACKED__ nif_paeb_reset_reg[SOC_PB_REG_NIF_NOF_PAEB_REGS];

  /* NIF Paeb Reset4 - NIF Paeb Reset5, the relevant registers      */
  /* Alternative  QSGMII configuration only                         */
  /* Note! ACCESS via fields only, not register                     */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x506c - 0x506d */
    /* Rx5bLn0PaebRdPtrRst - Rx7bLn0PaebRdPtrRst:                   */
    /* Access type: RW, default value: 0x8                          */
    SOC_PETRA_REG_FIELD rx_5b_ln0_paeb_rd_ptr_rst;
    SOC_PETRA_REG_FIELD rx_6b_ln0_paeb_rd_ptr_rst;
    SOC_PETRA_REG_FIELD rx_7b_ln0_paeb_rd_ptr_rst;
  } __ATTRIBUTE_PACKED__ nif_paeb_alt_reset_reg;

  /* NIF Ptp1588: Support of IEEE 1588 includes real-clock          */
  /* timers based on PTP_CLK and PTP_SYNC signals. Each time        */
  /* a PTP_SYNC is received, these timers will be reset to          */
  /* the value defined by PtpTslcResetValue register. The            */
  /* timers will be incremented by the value in                     */
  /* PtpDeltaEachPtpClock register, on each rising edge of          */
  /* the PTP_CLK. Note: PTP_SYNC should be stable (setup+hold)       */
  /* on rising edge of PTP_CLK. It is recomended that               */
  /* PTP_SYNC will be generated from falling edge of the            */
  /* PTP_CLK.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5080 */

     /* PtpDeltaEachPtpClock: Set the increment that should be       */
     /* added to the PTP global timers on rising edge of             */
     /* PTP_CLK. Bit [0] represents 2^(-8) of a nano-second. Use     */
     /* 1000ns*256 for 1MHz PTP_CLK, or 100ns*256 for 10MHz          */
     /* PTP_CLK. This configuration depends only on PTP_CLK.         */
     /* range: 19:0, access type: RW, default value: 20'h3e800       */
     SOC_PETRA_REG_FIELD ptp_delta_each_ptp_clock;

     /* PtpClockPd: Reserved (set to 0). If set, PTP_CLK to all      */
     /* the MALs will be will powered down. This will not affect     */
     /* the Auto-Increment function of the PtpTslcResetValue.        */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ptp_clock_pd;

     /* PtpSyncPd: Reserved (set to 0). If set, PTP_SYNC to all      */
     /* the MALs will be powered down. This will not affect the      */
     /* Auto-Increment function of the PtpTslcResetValue.            */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ptp_sync_pd;

     /* PtpTslcResetLoad: If set, the PTP reset value is loaded      */
     /* with the value in PtpTslcResetValue register (i.e., the      */
     /* auto-increment function is bypassed). This reset value       */
     /* will be loaded to PTP global timers on the next PTP_SYNC     */
     /* event. After this register is set to 0, the                  */
     /* PtpTslcResetValue will auto increment beginning from the     */
     /* next PTP_SYNC. To maintain synchronization between           */
     /* devices, this register should be cleared between             */
     /* PTP_SYNC pulses, such that the exact time of the next        */
     /* PTP_SYNC event will be known and reflected by                */
     /* PtpTslcResetValue.                                           */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ptp_tslc_reset_load;

  } __ATTRIBUTE_PACKED__ nif_ptp1588_reg;

  /* NIF Ptp1588 VLAN: IEEE 1588 time-stamping function             */
  /* supports 1588 frames over Ethernet or over UDP with up         */
  /* to 2 VLAN tags. Packets with EtherType equal to the            */
  /* value of this register will be identified as VLAN. Two         */
  /* possible EtherTypes that represent VLAN are supported          */
  /* through PtpVlanEtherType0 and PtpVlanEtherType1.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5081 */

     /* PtpVlanEtherType0: VLAN EtherType.                           */
     /* range: 15:0, access type: RW, default value: 0x8100          */
     SOC_PETRA_REG_FIELD ptp_vlan_ether_type0;

     /* PtpVlanEtherType1: VLAN EtherType.                           */
     /* range: 31:16, access type: RW, default value: 0x8100         */
     SOC_PETRA_REG_FIELD ptp_vlan_ether_type1;

  } __ATTRIBUTE_PACKED__ nif_ptp1588_vlan_reg;

  /* NIF Ptp1588 Reset: IEEE 1588 configuration register for        */
  /* the global PTP_Clk timer.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5082 */

     /* PtpTslcResetValue: Reset value for the local PTP timers.     */
     /* Value of the timer is added to a per-port BIAS register      */
     /* to determine the time for IEEE 1588 stamping. This value     */
     /* should reflect the real time for the next PTP_SYNC           */
     /* pulse. PTP_SYNC pulse is sampled at rising edge of the       */
     /* PTP_CLK. Value of this register may be auto-incremented      */
     /* after each PTP_SYNC event (see PtpTslcResetValueDelta).      */
     /* Bit [0] of the reset register represents 1ns.                */
     /* range: 31:0, access type: RW, default value: 48'h000000000000 */
     SOC_PETRA_REG_FIELD ptp_tslc_reset_value;

  } __ATTRIBUTE_PACKED__ nif_ptp1588_reset_reg[SOC_PB_NIF_NIF_PTP1588_RESET_REG_MULT_NOF_REGS];

  /* NIF Ptp1588 Auto Inc: The PTP_Clk global timer is loaded       */
  /* with the value of register PtpTslcResetValue each time a       */
  /* PTP_SYNC is detected (on rising edge of PTP_CLK). This         */
  /* value may be auto-incremented every time a sync is             */
  /* received.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5084 */

     /* PtpTslcResetValueDelta: Set the increment that should be     */
     /* added to PtpTslcResetValue each time PTP_Sync is             */
     /* detected. Set this register to match the frequency of        */
     /* the PTP_Sync pulses. Bit [0] represents 1ns.                 */
     /* range: 31:0, access type: RW, default value: 48'h000000000000 */
     SOC_PETRA_REG_FIELD ptp_tslc_reset_value_delta;

  } __ATTRIBUTE_PACKED__ nif_ptp1588_auto_inc_reg[SOC_PB_NIF_NIF_PTP1588_AUTO_INC_REG_MULT_NOF_REGS];

  /* NIF Ptp1588 Auto Inc Read: IEEE 1588 configuration             */
  /* register for the global PTP_Clk timer.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5086 */

     /* PtpTslcResetValueAutoInc: Reserved. Indicates the value      */
     /* of the Auto-Incremented PtpTslcResetValue.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ptp_tslc_reset_value_auto_inc;

  } __ATTRIBUTE_PACKED__ nif_ptp1588_auto_inc_read_reg[SOC_PB_NIF_NIF_PTP1588_AUTO_INC_READ_REG_MULT_NOF_REGS];

  /* NIF Sync Eth1: Synchronous EthernetEach MAL Group drives       */
  /* primary and secondary recovered clocks. These go through       */
  /* some more muxing logic near the PADs (see ECI registers        */
  /* for further information).                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5090 */

     /* SyncEthClockSel1: Select one of 16 recovered clocks to       */
     /* drive on primiray recovered clock output of the MALG.        */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD sync_eth_clock_sel1;

     /* SyncEthClockDiv1: Enable clock divider for the selected      */
     /* primary recovered clock: [00] Disable (power down) [01]      */
     /* Undivided [10] Divided by 2 [11] Divided by 4                */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD sync_eth_clock_div1;

     /* SyncEthSquelchEn1: If set, automatic squelch function        */
     /* will be enabled for the primary recovered clock. This        */
     /* function will power down the clock output whenever the       */
     /* Rx PCS Synchronization FSM indicates the link is not         */
     /* synced.                                                      */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD sync_eth_squelch_en1;

     /* SyncEthValidSelect1: If set, will base clock valid           */
     /* indication on link status from AutoNeg function (GMII)       */
     /* or from LFS (XAUI). Otherwise, Rx PCS Lane Sync status       */
     /* (comma lock) is used.                                        */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD sync_eth_valid_select1;

     /* SyncEthGtimerMode1: Reserved (write as 0).                   */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sync_eth_gtimer_mode1;

     /* SyncEthClockSel2: Same as SyncEthClockSel1 for the           */
     /* secondary recovered clock.                                   */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sync_eth_clock_sel2;

     /* SyncEthClockDiv2: Same as SyncEthClockDiv1 for the           */
     /* secondary recovered clock.                                   */
     /* range: 17:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sync_eth_clock_div2;

     /* SyncEthSquelchEn2: Same as SyncEthSquelchEn1 for the         */
     /* secondary recovered clock.                                   */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD sync_eth_squelch_en2;

     /* SyncEthValidSelect2: If set, will base clock valid           */
     /* indication on link status from AutoNeg function.             */
     /* Otherwise, Rx PCS Lane Sync status (comma lock) is used.     */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sync_eth_valid_select2;

     /* SyncEthGtimerMode2: Reserved (write as 0).                   */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sync_eth_gtimer_mode2;

     /* SyncEthXauiMode: If set, the clock validity is               */
     /* determined based on the link status of the respective        */
     /* NIF port, taken from the XAUI LFS function. Otherwise,       */
     /* indication from GMII AutoNeg is used. This should be set     */
     /* for XAUI/RXAUI links where the link status also reflects     */
     /* LF conditions at the PHY. When using this mode, the          */
     /* SyncEthClockSel must select the recovered clock from the     */
     /* first two SRD lanes associated with the MAL (i.e. lane 0     */
     /* or 1). This register is only relevant if                     */
     /* SyncEthValidSelect1/2 is set. Otherwise, NIF port status     */
     /* is ignored, and valid indication is taken from the SRD       */
     /* Rx PCD Lane Sync status (comma lock).                        */
     /* range: 31:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sync_eth_xaui_mode;

  } __ATTRIBUTE_PACKED__ nif_sync_eth1_reg;

  /* NIF Sync Eth2: Synchronous Ethernet Hystersis function         */
  /* is implemented to ensure recovered clock becomes stable        */
  /* before squelch function is disabled.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5091 */

     /* SyncEthSquelchDisTh: If link status is synced for more       */
     /* consecutive recovered clock cycles than the value            */
     /* represented by this register, squelch function will be       */
     /* disabled and output clock will become valid. Use value       */
     /* of <125000> for 1ms interval on 1000Base-X link (at 1.25     */
     /* Gbps). Same value is used for primary and secondary          */
     /* clocks.                                                      */
     /* range: 31:0, access type: RW, default value: 32'd125000      */
     SOC_PETRA_REG_FIELD sync_eth_squelch_dis_th;

  } __ATTRIBUTE_PACKED__ nif_sync_eth2_reg;

  /* NIF Sync Eth3: Synchronous Ethernet Hystersis function         */
  /* (cont)                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5092 */

     /* SyncEthSquelchEnTh: If link status is unsynced for more      */
     /* recovered clock cycles than the value represented by         */
     /* this register, squelch function will be activated and        */
     /* output clock will become invalid (will be powered down).     */
     /* Use value of <125> for 1us reaction time on 1000Base-X       */
     /* link (at 1.25 Gbps). Same value is used for primary and      */
     /* secondary clocks.                                            */
     /* range: 15:0, access type: RW, default value: 0x7d            */
     SOC_PETRA_REG_FIELD sync_eth_squelch_en_th;

  } __ATTRIBUTE_PACKED__ nif_sync_eth3_reg;

  /* srd0 LN0 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5100 */

     /* srd0_LN0_cfga: SerDes Lane 0 Configurations. SerDes          */
     /* registers are further described at the SerDes registers      */
     /* section.                                                     */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln0_cfga_reg;

  /* srd0 LN0 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5101 */

     /* srd0_LN0_stat: SerDes Lane 0 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln0_stat_reg;

  /* srd0 LN0 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5102 */

     /* srd0_LN0_EBIST: SerDes Lane 0 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln0_ebist_reg;

  /* srd0 LN1 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5104 */

     /* srd0_LN1_cfga: SerDes Lane 1 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln1_cfga_reg;

  /* srd0 LN1 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5105 */

     /* srd0_LN1_stat: SerDes Lane 1 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln1_stat_reg;

  /* srd0 LN1 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5106 */

     /* srd0_LN1_EBIST: SerDes Lane 1 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln1_ebist_reg;

  /* srd0 LN2 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5108 */

     /* srd0_LN2_cfga: SerDes Lane 2 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln2_cfga_reg;

  /* srd0 LN2 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5109 */

     /* srd0_LN2_stat: SerDes Lane 2 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln2_stat_reg;

  /* srd0 LN2 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x510a */

     /* srd0_LN2_EBIST: SerDes Lane 2 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln2_ebist_reg;

  /* srd0 LN3 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x510c */

     /* srd0_LN3_cfga: SerDes Lane 3 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln3_cfga_reg;

  /* srd0 LN3 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x510d */

     /* srd0_LN3_stat: SerDes Lane 3 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln3_stat_reg;

  /* srd0 LN3 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x510e */

     /* srd0_LN3_EBIST: SerDes Lane 3 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln3_ebist_reg;

  /* srd0 cmu cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5110 */

     /* srd0_cmu_cfga: SerDes CMU Configurations                     */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd0_cmu_cfga_reg;

  /* srd0 cmu cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5111 */

     /* srd0_cmu_cfgb: SerDes CMU Configurations (Con't)             */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd0_cmu_cfgb_reg;

  /* srd0 cmu stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5112 */

     /* srd0_cmu_stat: SerDes SMU Status                             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd0_cmu_stat_reg;

  /* srd1 LN0 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5120 */

     /* srd1_LN0_cfga: SerDes Lane 0 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln0_cfga_reg;

  /* srd1 LN0 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5121 */

     /* srd1_LN0_stat: SerDes Lane 0 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln0_stat_reg;

  /* srd1 LN0 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5122 */

     /* srd1_LN0_EBIST: SerDes Lane 0 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln0_ebist_reg;

  /* srd1 LN1 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5124 */

     /* srd1_LN1_cfga: SerDes Lane 1 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln1_cfga_reg;

  /* srd1 LN1 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5125 */

     /* srd1_LN1_stat: SerDes Lane 1 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln1_stat_reg;

  /* srd1 LN1 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5126 */

     /* srd1_LN1_EBIST: SerDes Lane 1 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln1_ebist_reg;

  /* srd1 LN2 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5128 */

     /* srd1_LN2_cfga: SerDes Lane 2 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln2_cfga_reg;

  /* srd1 LN2 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5129 */

     /* srd1_LN2_stat: SerDes Lane 2 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln2_stat_reg;

  /* srd1 LN2 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x512a */

     /* srd1_LN2_EBIST: SerDes Lane 2 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln2_ebist_reg;

  /* srd1 LN3 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x512c */

     /* srd1_LN3_cfga: SerDes Lane 3 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln3_cfga_reg;

  /* srd1 LN3 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x512d */

     /* srd1_LN3_stat: SerDes Lane 3 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln3_stat_reg;

  /* srd1 LN3 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x512e */

     /* srd1_LN3_EBIST: SerDes Lane 3 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln3_ebist_reg;

  /* srd1 cmu cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5130 */

     /* srd1_cmu_cfga: SerDes CMU Configurations                     */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd1_cmu_cfga_reg;

  /* srd1 cmu cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5131 */

     /* srd1_cmu_cfgb: SerDes CMU Configurations (Con't)             */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd1_cmu_cfgb_reg;

  /* srd1 cmu stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5132 */

     /* srd1_cmu_stat: SerDes SMU Status                             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd1_cmu_stat_reg;

  /* srd2 LN0 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5140 */

     /* srd2_LN0_cfga: SerDes Lane 0 Configurations. SerDes          */
     /* registers are further described at the SerDes registers      */
     /* section.                                                     */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln0_cfga_reg;

  /* srd2 LN0 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5141 */

     /* srd2_LN0_stat: SerDes Lane 0 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln0_stat_reg;

  /* srd2 LN0 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5142 */

     /* srd2_LN0_EBIST: SerDes Lane 0 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln0_ebist_reg;

  /* srd2 LN1 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5144 */

     /* srd2_LN1_cfga: SerDes Lane 1 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln1_cfga_reg;

  /* srd2 LN1 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5145 */

     /* srd2_LN1_stat: SerDes Lane 1 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln1_stat_reg;

  /* srd2 LN1 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5146 */

     /* srd2_LN1_EBIST: SerDes Lane 1 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln1_ebist_reg;

  /* srd2 LN2 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5148 */

     /* srd2_LN2_cfga: SerDes Lane 2 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln2_cfga_reg;

  /* srd2 LN2 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5149 */

     /* srd2_LN2_stat: SerDes Lane 2 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln2_stat_reg;

  /* srd2 LN2 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x514a */

     /* srd2_LN2_EBIST: SerDes Lane 2 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln2_ebist_reg;

  /* srd2 LN3 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x514c */

     /* srd2_LN3_cfga: SerDes Lane 3 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln3_cfga_reg;

  /* srd2 LN3 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x514d */

     /* srd2_LN3_stat: SerDes Lane 3 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln3_stat_reg;

  /* srd2 LN3 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x514e */

     /* srd2_LN3_EBIST: SerDes Lane 3 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln3_ebist_reg;

  /* srd2 cmu cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5150 */

     /* srd2_cmu_cfga: SerDes CMU Configurations                     */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd2_cmu_cfga_reg;

  /* srd2 cmu cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5151 */

     /* srd2_cmu_cfgb: SerDes CMU Configurations (Con't)             */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd2_cmu_cfgb_reg;

  /* srd2 cmu stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5152 */

     /* srd2_cmu_stat: SerDes SMU Status                             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd2_cmu_stat_reg;

  /* srd3 LN0 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5160 */

     /* srd3_LN0_cfga: SerDes Lane 0 Configurations. SerDes          */
     /* registers are further described at the SerDes registers      */
     /* section.                                                     */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln0_cfga_reg;

  /* srd3 LN0 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5161 */

     /* srd3_LN0_stat: SerDes Lane 0 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln0_stat_reg;

  /* srd3 LN0 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5162 */

     /* srd3_LN0_EBIST: SerDes Lane 0 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln0_ebist_reg;

  /* srd3 LN1 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5164 */

     /* srd3_LN1_cfga: SerDes Lane 1 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln1_cfga_reg;

  /* srd3 LN1 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5165 */

     /* srd3_LN1_stat: SerDes Lane 1 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln1_stat_reg;

  /* srd3 LN1 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5166 */

     /* srd3_LN1_EBIST: SerDes Lane 1 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln1_ebist_reg;

  /* srd3 LN2 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5168 */

     /* srd3_LN2_cfga: SerDes Lane 2 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln2_cfga_reg;

  /* srd3 LN2 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5169 */

     /* srd3_LN2_stat: SerDes Lane 2 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln2_stat_reg;

  /* srd3 LN2 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x516a */

     /* srd3_LN2_EBIST: SerDes Lane 2 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln2_ebist_reg;

  /* srd3 LN3 cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x516c */

     /* srd3_LN3_cfga: SerDes Lane 3 Configurations                  */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln3_cfga_reg;

  /* srd3 LN3 stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x516d */

     /* srd3_LN3_stat: SerDes Lane 3 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln3_stat_reg;

  /* srd3 LN3 EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x516e */

     /* srd3_LN3_EBIST: SerDes Lane 3 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln3_ebist_reg;

  /* srd3 cmu cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5170 */

     /* srd3_cmu_cfga: SerDes CMU Configurations                     */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd3_cmu_cfga_reg;

  /* srd3 cmu cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5171 */

     /* srd3_cmu_cfgb: SerDes CMU Configurations (Con't)             */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd3_cmu_cfgb_reg;

  /* srd3 cmu stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5172 */

     /* srd3_cmu_stat: SerDes SMU Status                             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd3_cmu_stat_reg;

  /* Srd Ipu Cfg:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5178 */

     /* SrdIpuCfg: Configuration Register for IPU (internal          */
     /* 8051), EPB bus, and SCIF access. Shared by all SerDeses      */
     /* in SRD Star.                                                 */
     /* range: 31:0, access type: RW, default value: `SRD_PCFG_DEFAULT */
     SOC_PETRA_REG_FIELD srd_ipu_cfg;

  } __ATTRIBUTE_PACKED__ srd_ipu_cfg_reg;

  /* Srd Epb Op:                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5179 */

     /* SrdEpbOp: EPB OP dispatch register. Writing to this          */
     /* register causes a write or read operation to be              */
     /* dispatched on the EPB bus.                                   */
     /* range: 31:0, access type: RW, default value: `SRD_EPB_OP_DEFAULT */
     SOC_PETRA_REG_FIELD srd_epb_op;

  } __ATTRIBUTE_PACKED__ srd_epb_op_reg;

  /* Srd Epb Rd:                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x517a */

     /* SrdEpbRd: EPB OP data read register. After a read from       */
     /* the EPB bus is finished, the read data and status are        */
     /* available here.                                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd_epb_rd;

  } __ATTRIBUTE_PACKED__ srd_epb_rd_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_NIF_REGS;
/* Block definition: NIF 	MAC LANE  */
typedef struct
{
  uint32   nof_instances; /* 16 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: MAL Interrupt register                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5200 */

     /* LinkStatusChangeInt: If set, indicates change in link        */
     /* status of corresponding port.                                */
     /* range: 3:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_status_change_int;

     /* RxPcsLnSyncStatChangeInt: If set, indicates that Rx PCS      */
     /* synchronization status of corresponding logical lane has     */
     /* changed.                                                     */
     /* range: 7:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_pcs_ln_sync_stat_change_int;

     /* RxPcsLocalFaultInt: If set, indicates that XAUI Rx PCS       */
     /* detected a local fault indication from PHY or that           */
     /* deskew function failed.                                      */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_pcs_local_fault_int;

     /* RxPcsLocalFaultPhyInt: If set, indicates that XAUI Rx        */
     /* PCS detected a local fault indication from PHY.              */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_pcs_local_fault_phy_int;

     /* RxPcsRemoteFaultInt: If set, indicates XAUI Rx PCS           */
     /* detected a remote fault (indicated by link partner).         */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_remote_fault_int;

     /* RxPcsUnknownFaultInt: If set, indicates XAUI Rx PCS          */
     /* detected an unknown fault (||Q|| that is not ||LF|| or       */
     /* ||RF||) indicated by link partner or PHY.                    */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_unknown_fault_int;

     /* StatCounterAfInt: If set, indicates that one of the port     */
     /* statistics counters reached 75% of its maximal value.        */
     /* range: 15:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_counter_af_int;

     /* AN RestartInt: If set, indicates that GMII Ports 0..3 Rx     */
     /* AutoNeg function restarted (AN_RESTART state).               */
     /* range: 19:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_restart_int;

     /* AN CompleteInt: If set, indicates that GMII Ports 0..3       */
     /* Rx AutoNeg function completed (LINK_OK state).               */
     /* range: 23:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_complete_int;

     /* AN ErrorInt: If set, indicates that GMII Ports 0..3 Rx       */
     /* AutoNeg function reports one of these events: (1) Remote     */
     /* Link Status is 0 (SGMII PHY mode) (2) Remote fault           */
     /* indication from link partner (1000 Base-X mode) (3)          */
     /* AutoNeg complete, but capabilities could not be              */
     /* resolved.                                                    */
     /* range: 27:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_error_int;

     /* ErrorInterrupt: If set, indicates one or more of the         */
     /* ErrInterruptRegister bits were set.                          */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_interrupt;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Err Interrupt Register: MAL Error Interrupt register           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5201 */

     /* TxMacErrInt: If set, indicates that MAC Lane encountered     */
     /* a Tx error (i.e. starvation or frame check errors). Lane     */
     /* 0 indication is shared by XAUI.                              */
     /* range: 3:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_mac_err_int;

     /* RxMacErrInt: If set, indicates that MAC Lane encountered     */
     /* an Rx error (i.e. Frame Check Error during packet or         */
     /* between packets). Lane 0 indication is shared by XAUI.       */
     /* range: 7:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mac_err_int;

     /* TxAlnrOvfInt: Reserved.                                      */
     /* range: 11:8, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_alnr_ovf_int;

     /* RxAlnrOvfInt: If set, indicates that Rx Aligner buffers      */
     /* overflowed. Each bit represents buffer of a different        */
     /* port 0 (bit 0 for XAUI).                                     */
     /* range: 15:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_alnr_ovf_int;

     /* TxPtp_1588StampingErrInt: If set, indicates Tx aligner       */
     /* could not properly stamp a 1588 packet.                      */
     /* range: 19:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_ptp_1588_stamping_err_int;

     /* RxPtp_1588StampingErrInt: If set, indicates Rx aligner       */
     /* could not properly stamp a 1588 packet.                      */
     /* range: 23:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ptp_1588_stamping_err_int;

     /* TxTafOverflowErrInt: If set, indicates that TAF had an       */
     /* overflow error.                                              */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_taf_overflow_err_int;

     /* RxRafOverflowErrInt: If set, indicates that RAF had an       */
     /* overflow error.                                              */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_raf_overflow_err_int;

     /* RxPcsDeskewErrInt: If set, indicates a single or a few       */
     /* unaligned ||A|| columns were detected by the XAUI Rx PCS     */
     /* Deskew function, while link was up.                          */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_deskew_err_int;

     /* RxPcsBomErrInt: For XAUI mode, if set, indicates a           */
     /* single or a few unaligned ||A|| columns were detected by     */
     /* the XAUI Rx PCS Deskew function, while link was up. For      */
     /* QSGMII mode, if set, indicates a single or a few             */
     /* unaligned /K28.1/ characters.                                */
     /* range: 27:27, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_bom_err_int;

     /* RxPcsDeskewErrFatalInt: Reserved (debug).                    */
     /* range: 28:28, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_deskew_err_fatal_int;

     /* RxMacBctCrcErrInt: If set, indicates XAUI Rx MAC             */
     /* detected a CRC error on the BCT.                             */
     /* range: 29:29, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mac_bct_crc_err_int;

  } __ATTRIBUTE_PACKED__ err_interrupt_reg;

  /* Interrupt Mask Register: MAL Interrupt Mask Register           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5202 */

     /* LinkStatusChangeIntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_status_change_int_mask;

     /* RxPcsLnSyncStatChangeIntMask: Writing 0 masks the            */
     /* corresponding interrupt source.                              */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_pcs_ln_sync_stat_change_int_mask;

     /* RxPcsLocalFaultIntMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_pcs_local_fault_int_mask;

     /* RxPcsLocalFaultPhyIntMask: Writing 0 masks the               */
     /* corresponding interrupt source.                              */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_pcs_local_fault_phy_int_mask;

     /* RxPcsRemoteFaultIntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_remote_fault_int_mask;

     /* RxPcsUnknownFaultIntMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_unknown_fault_int_mask;

     /* StatCounterAfIntMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_counter_af_int_mask;

     /* AN_RestartIntMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 19:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_restart_int_mask;

     /* AN_CompleteIntMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_complete_int_mask;

     /* AN_ErrorIntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 27:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_error_int_mask;

     /* ErrorInterruptMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_interrupt_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Err Interrupt Mask Register: MAL Error Interrupt Mask          */
  /* Register                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5203 */

     /* TxMacErrIntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_mac_err_int_mask;

     /* RxMacErrIntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mac_err_int_mask;

     /* TxAlnrOvfIntMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_alnr_ovf_int_mask;

     /* RxAlnrOvfIntMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_alnr_ovf_int_mask;

     /* TxPtp_1588StampingErrIntMask: Writing 0 masks the            */
     /* corresponding interrupt source.                              */
     /* range: 19:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_ptp_1588_stamping_err_int_mask;

     /* RxPtp_1588StampingErrIntMask: Writing 0 masks the            */
     /* corresponding interrupt source.                              */
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ptp_1588_stamping_err_int_mask;

     /* TxTafOverflowErrIntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_taf_overflow_err_int_mask;

     /* RxRafOverflowErrIntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_raf_overflow_err_int_mask;

     /* RxPcsDeskewErrIntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_deskew_err_int_mask;

     /* RxPcsBomErrIntMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_bom_err_int_mask;

     /* RxPcsDeskewErrFatalIntMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_deskew_err_fatal_int_mask;

     /* RxMacBctCrcErrIntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mac_bct_crc_err_int_mask;

  } __ATTRIBUTE_PACKED__ err_interrupt_mask_reg;

  /* Link Status Register: MAL Status indications                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5208 */

     /* LinkStatus: Current link status. In XAUI mode, bit 0         */
     /* indicates that all lanes are comma aligned and that lane     */
     /* alignment (deskew) has been achieved. Equivalent to          */
     /* link_fault variable in IEEE 802.3ae Clause 46.3.4.2. In      */
     /* GMII mode (1000 Base-X or SGMII modes), each bit             */
     /* indicates that the XMIT indication for the corresponding     */
     /* lane's AutoNegotiation FSM is XMIT=DATA. In SGMII mode,      */
     /* each bit reflects the link status bit received from the      */
     /* PHY.                                                         */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_status;

     /* LinkStatusSticky: This is a latch-low sticky version of      */
     /* the LinkStatus indication (i.e., it is cleared if link       */
     /* fails and remains 0 until read by CPU). This register is     */
     /* clear on read.                                               */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_status_sticky;

     /* RxPcsLocalFault: Indicates XAUI RxPCS identified a local     */
     /* fault indication from PHY or that deskew function failed     */
     /* (sticky indication). This register is clear on read.         */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_pcs_local_fault;

     /* RxPcsLocalFaultPhy: Indicates XAUI RxPCS identified a        */
     /* local fault indication from PHY (sticky indication).         */
     /* This register is clear on read.                              */
     /* range: 9:9, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_pcs_local_fault_phy;

     /* RxPcsRemoteFault: Indicates XAUI RxPCS identified a          */
     /* remote fault indication from link partner (sticky            */
     /* indication). This register is clear on read.                 */
     /* range: 10:10, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_remote_fault;

     /* RxPcsUnknownFault: Indicates XAUI RxPCS identified an        */
     /* unknown fault indication (||Q|| that is not ||EF|| or        */
     /* ||LF||) from link partner or PHY (sticky indication).        */
     /* This register is clear on read.                              */
     /* range: 11:11, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_unknown_fault;

     /* RxPcsDeskewError: Indicates XAUI RxPCS deskew function       */
     /* is unaligned (sticky indication). This register is clear     */
     /* on read.                                                     */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_deskew_error;

     /* RxPcsBomError: Indicates BOM function detected an            */
     /* alignment error (single or a few errors). Valid for          */
     /* RXAUI and QSGMII modes. This register is clear on read.      */
     /* range: 13:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_bom_error;

     /* RxPcsSyncStat: Indicates all relevant physical lanes         */
     /* achieved synchronization. Relevant only to XAUI and          */
     /* RXAUI modes.                                                 */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_sync_stat;

     /* RxPcsLnSyncStat: Indicates lane synchronization status       */
     /* of the physical lanes associated with the logical lanes.     */
     /* For XAUI and GMII: Each logial lane correspond to            */
     /* physical lanes with same index. For RXAUI: Logial lanes      */
     /* 0+1 and 2+3 correspond to physical lane 0 and 1,             */
     /* respectivelly. For QSGMII: Logial lanes 0-3 are all          */
     /* associated with physical lane 0. The above mapping may       */
     /* change depending on the SWAP function.                       */
     /* range: 23:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_ln_sync_stat;

     /* PortTxActive: Indicates Tx activity in the corresponding     */
     /* NIF port. Value of <1> indicates there was Tx traffic        */
     /* since the register was last read. This register is clear     */
     /* on read.                                                     */
     /* range: 27:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD port_tx_active;

     /* PortRxActive: Indicates Rx activity in the corresponding     */
     /* NIF port. Value of <1> indicates there was Rx traffic        */
     /* since the register was last read. This register is clear     */
     /* on read.                                                     */
     /* range: 31:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD port_rx_active;

  } __ATTRIBUTE_PACKED__ link_status_reg;

  /* Enable Register: MAL Mode Controls and Master Reset            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5209 */

     /* MalEn: Master reset for the MAL logic. If set, the MAL       */
     /* is enabled and XauiRxLaneEn, XauiTxLaneEn, GmiiRxLaneEn      */
     /* or GmiiTxLaneEn may be set. Otherwise, all lanes             */
     /* (XAUI+GMII) are held at reset. This bit should only be       */
     /* set after all NIF and SerDes configurations were set,        */
     /* and SerDes completed its reset sequence (SerDes clocks       */
     /* are stable).                                                 */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mal_en;

     /* XauiRxLaneEn: If set, XAUI Rx lane is enabled.               */
     /* Otherwise, it is held at reset. This register is only        */
     /* relevant if MalEn is set and GmiiMode bit is deasserted.     */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD xaui_rx_lane_en;

     /* XauiTxLaneEn: If set, XAUI Tx lane is enabled.               */
     /* Otherwise, it is held at reset. This register is only        */
     /* relevant if MalEn is set and GmiiMode bit is deasserted.     */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD xaui_tx_lane_en;

     /* GmiiRxLaneEn: If set, corresponding GMII Rx lane is          */
     /* enabled (1000 Base-X, SGMII or QSGMII). Otherwise, it is     */
     /* held at reset. This register is only relevant if MalEn       */
     /* is set and GmiiMode bit is asserted.                         */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD gmii_rx_lane_en;

     /* GmiiTxLaneEn: If set, corresponding GMII Tx lane is          */
     /* enabled (1000 Base-X, SGMII or QSGMII). Otherwise, it is     */
     /* held at reset. This register is only relevant if MalEn       */
     /* is set and GmiiMode bit is asserted.                         */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gmii_tx_lane_en;

     /* XauiSrMode: If set, MAL operates in XAUI Single Rate         */
     /* (SR) mode.                                                   */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD xaui_sr_mode;

     /* XauiDrMode: If set, MAL operates in RXAUI (XAUI-DDR)         */
     /* mode.                                                        */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD xaui_dr_mode;

     /* GmiiMode: If set, MAL operates in 1000Base-X or SGMII        */
     /* mode.                                                        */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gmii_mode;

     /* QsgmiiMode: If set, MAL operates in QSGMII mode.             */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD qsgmii_mode;

     /* GmiiTwoPortsMode: If set, only two GMII MACs will be         */
     /* active (lane 0 and lane 2). This will allocate larger        */
     /* FIFOs to the two active MACs and should be used for fast     */
     /* GMII ports (4GE). In this mode, ports 0 and 2 of the MAL     */
     /* are active, using SerDes lanes 0 and 1 associated with       */
     /* the MAL.                                                     */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gmii_two_ports_mode;

     /* MalLoopbackMode: If set, MAL Rx will loopback data from      */
     /* TxMLF right back to Rx MLF, thus closing a loopb back to     */
     /* the Soc_petra Core (EGQ data is returned to the IRE after        */
     /* passing through the NBI).                                    */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mal_loopback_mode;

     /* MalRepeaterMode: If set, MAL Tx will take data directly      */
     /* from MAL Rx, thus working in repeater mode, where all        */
     /* received data is retransmitted back to link partner. In      */
     /* this case, the data is not transferred to the Soc_petra Core     */
     /* (IRE). Only port 0 may be set to repeater mode (either       */
     /* XAUI, or GMII port-0).                                       */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mal_repeater_mode;

  } __ATTRIBUTE_PACKED__ enable_reg;

  /* Mal Reset1: MAL Reset controls                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x520a */

     /* TxMlfReset: Reserved (set to 0).                             */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_mlf_reset;

     /* TxTafReset: Reserved (set to 0).                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_taf_reset;

     /* TxAlignerReset: Reserved (set to 0).                         */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_aligner_reset;

     /* TxFctReset: Reserved (set to 0).                             */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_fct_reset;

     /* RxBomReset: Reserved (set to 0).                             */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_bom_reset;

  } __ATTRIBUTE_PACKED__ mal_reset1_reg;

  /* Mal Reset2: MAL Reset controls                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x520b */

     /* RxMlfReset: Reserved (set to 0).                             */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mlf_reset;

     /* RxRafReset: Reserved (set to 0).                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_raf_reset;

     /* RxXauiPcsResetDeskew: Reserved (set to 0).                   */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_xaui_pcs_reset_deskew;

     /* RxXauiMacReset: Reserved (set to 0).                         */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_xaui_mac_reset;

     /* RxXauiLfsReset: Reserved (set to 0).                         */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_xaui_lfs_reset;

     /* RxAlignerReset: Reserved (set to 0).                         */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_aligner_reset;

     /* RxGsReset: Reserved (set to 0).                              */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_gs_reset;

     /* RxFcrReset: Reserved (set to 0).                             */
     /* range: 19:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_fcr_reset;

     /* RxGmiiPcsReset: Reserved (set to 0).                         */
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_gmii_pcs_reset;

     /* RxGmiiMacReset: Reserved (set to 0).                         */
     /* range: 27:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_gmii_mac_reset;

     /* RxGmiiAnReset: Reserved (set to 0).                          */
     /* range: 31:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_gmii_an_reset;

  } __ATTRIBUTE_PACKED__ mal_reset2_reg;

  /* Async Fifo Config: Configuration register of                   */
  /* asynchronous FIFO between core-clock FIFO and Tx/Rx MAC.       */
  /* TAF: FIFO in Tx path, RAF: FIFO in Rx path.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x520c */

     /* TxExtraDelayRd: Reserved (set to 1).                         */
     /* range: 1:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tx_extra_delay_rd;

     /* TxExtraDelayWr: Reserved (set to 1).                         */
     /* range: 3:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tx_extra_delay_wr;

     /* RxExtraDelayRd: Reserved (set to 1).                         */
     /* range: 5:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_extra_delay_rd;

     /* RxExtraDelayWr: Reserved (set to 1).                         */
     /* range: 7:6, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_extra_delay_wr;

     /* TAF AF WM: TAF Almost Full Watermark. When TAF has more      */
     /* than TAF_AF_WM valid entries, the read_en is                 */
     /* de-asserted. Set to <10> for XAUI modes, and to <15> for     */
     /* GMII modes.                                                  */
     /* range: 11:8, access type: RW, default value: 0xa             */
     SOC_PETRA_REG_FIELD taf_af_wm;

     /* RAF AE WM: Reserved (set to 8).                              */
     /* range: 15:12, access type: RW, default value: 0x8            */
     SOC_PETRA_REG_FIELD raf_ae_wm;

     /* RAF EnsureOverflowInd: If set, RAF will ensure               */
     /* indication of discarded entries (due to FIFO overflow)       */
     /* is always propagated to Ingress. This is done by             */
     /* flagging the next entry with error, even if it belongs       */
     /* to the next packet. Otherwise, next entry is flagged         */
     /* only if it belongs to the same packet (cleared on next       */
     /* SOB).                                                        */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD raf_ensure_overflow_ind;

     /* RxMaskFifoFull: Reserved (set to 1).                         */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_mask_fifo_full;

     /* TxMaskFifoFull: Reserved (set to 1).                         */
     /* range: 21:21, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tx_mask_fifo_full;

     /* TAF AF Ovrd: Reserved (write as 0).                          */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD taf_af_ovrd;

     /* TxMlfCreditOvrd: If set, TAF will continuosly generate       */
     /* credits to the Tx MLF. The only back pressure in this        */
     /* case will be from the TAF AF indication. Set to <1> for      */
     /* XAUI/RXAUI interfaces. Set to <0> for GMII interfaces.       */
     /* Set to <1> for MAL in XAUI mode and associated with the      */
     /* IPH-ELK interface.                                           */
     /* range: 31:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_mlf_credit_ovrd;

  } __ATTRIBUTE_PACKED__ async_fifo_config_reg;

  /* XAUI Config: Standard MAC XAUI configurations                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x520d */

     /* RxMinPktLength: Rx minimal packet length. Packets            */
     /* shorter than this threshold (including 3B or 4B CRC if       */
     /* present) will be flagged with error indication and           */
     /* dropped in the RxMLF (if less than 32B) or in the            */
     /* Ingress.                                                     */
     /* range: 7:0, access type: RW, default value: 0x40             */
     SOC_PETRA_REG_FIELD rx_min_pkt_length;

     /* TxMinPktLength: Tx minimal packet length. Packets            */
     /* shorter than this threshold (not including the 3B or 4B      */
     /* CRC, if added) will be padded with zeroes. If CRC is         */
     /* added to the packet, it will be calculated on the entire     */
     /* packet (including the trailing zeroes).                      */
     /* range: 15:8, access type: RW, default value: 0x3c            */
     SOC_PETRA_REG_FIELD tx_min_pkt_length;

     /* TxIpgDicThreshold: Deficit Idle Count threshold (average     */
     /* number of IPG characters to insert by Tx MAC). Minimum       */
     /* is 1 (only /T/ character).                                   */
     /* range: 23:16, access type: RW, default value: 0xc            */
     SOC_PETRA_REG_FIELD ipg_dic_threshold;

     /* TxIpgDicEnable: If set, the value in IpgDicThreshold         */
     /* register will be treated as the average number of            */
     /* characters between frames (IPG length), and credits will     */
     /* be transferred between successive IPGs. Otherwise, the       */
     /* value in the IpgDicThreshold register will be the            */
     /* minimum IPG value. Enabling this register will result in     */
     /* IPG of [9:15] (for TxIpgDicThreshold of 12). See also        */
     /* TxIpgMaxCredit_7 register. To configure full IPG             */
     /* compression, disable the DIC, and set the threshold to       */
     /* 1.                                                           */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ipg_dic_enable;

     /* MaskCheckEnd: If set, disables Rx PCS check_end              */
     /* function, defined in IEEE 803.2ae Rx PCS state machine       */
     /* (Clause 48.2.6.1.4). Should be set when working with IPG     */
     /* compression.                                                 */
     /* range: 25:25, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD mask_check_end;

     /* TxIdleRandPolynom: Select one of two polynomials for         */
     /* generation of Idle sequences (IEEE 802.3 Figure 48-5)        */
     /* [0] X^7 + X^6 + 1 [1] X^7 + X^3 + 1                          */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_idle_rand_polynom;

     /* TxTermPktOnErr: Reserved (set to 1).                         */
     /* range: 27:27, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tx_term_pkt_on_err;

     /* TxInsert E OnErr: Reserved (set to 0).                       */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_insert_e_on_err;

     /* LFS Ovrd: Override value for the LFS local-fault and         */
     /* remote-fault indications: [001] Override to no fault         */
     /* (link OK). [010] Override to remote fault. [100]             */
     /* Override to local fault. [111] No override (use value        */
     /* from LFS FSM). [Other] Reserved.                             */
     /* range: 31:29, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD lfs_ovrd;

  } __ATTRIBUTE_PACKED__ xaui_config_reg;

  /* SPAUI Extensions1: SPAUI Extensions to standard XAUI           */
  /* configuration (Rx)                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x520e */

     /* RxCrcCheckEn: If set, Rx MAC will check CRC-32/24 on the     */
     /* received packets. Otherwise, CRC-32/24 check results are     */
     /* ignored.                                                     */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_crc_check_en;

     /* RxCrcTerminateEn: Reserved (write as 1).                     */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_crc_terminate_en;

     /* RxCrc24Mode: If set, Rx MAC will use non-standard 3B         */
     /* CRC-24. Otherwise, standard 4B CRC-32 will be used.          */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_crc24_mode;

     /* RxBctSize: Determines the number of bytes in the BCT (0,     */
     /* 1 or 2 bytes). This information is required when a           */
     /* preamble size of less than one column is used (so MAC        */
     /* will know how many bytes to skip). 1B BCT means only CH      */
     /* field is received. 0B BCT means BCT is not used.             */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_bct_size;

     /* RxPreambleSize: Preamble column size: [2] - complete to      */
     /* two columns. [1] - complete to one column. [0] - less        */
     /* than one column (i.e. only /S/ and/or BCT).                  */
     /* range: 7:6, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD rx_preamble_size;

     /* RxBctChPosition: Index of the byte containing the CH         */
     /* (Channel) field inside the first column of the preamble.     */
     /* Possible values are 0 (if no /S/ in preamble), 1, 2, and     */
     /* 3. If RxBctEnCH is set, the CH will be extracted from        */
     /* this byte of the preamble. Otherwise, CH will be forced      */
     /* to 8'h00.                                                    */
     /* range: 9:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_bct_ch_position;

     /* RxPreambleSOP: If set, Rx MAC will expect /S/ character      */
     /* at the beginning of a packet. Otherwise, this character      */
     /* will be skipped (i.e. when full compression is               */
     /* configured).                                                 */
     /* range: 10:10, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_preamble_sop;

     /* RxAltCrcMode: If set, Rx MAC will use alternative CRC32      */
     /* method and will include the first character of preamble      */
     /* (/S/) in the CRC calculation. This character will be         */
     /* considered as 8'hFB (regardless of the actual character      */
     /* being received).                                             */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_alt_crc_mode;

     /* RxBctEnLlfc: If set, the NIF extracts the Link Level         */
     /* Flow Control (LLFC) bit from the BCT header and passes       */
     /* on to FCR. Otherwise, the NIF ignores this bit and           */
     /* forces the received LLFC to a constant 1'b0 (XON).           */
     /* RxBctLlfc field (RxFlowControlConfig register) instructs     */
     /* the NIF (FCR) how to handle the LLFC indication.             */
     /* RxBctEnLlfc overrides the LLFC value.                        */
     /* range: 12:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_bct_en_llfc;

     /* RxBctEnCH: If set, the NIF extracts the Channel (CH)         */
     /* bits from the BCT header and passes on to ingress (exact     */
     /* location of the CH field inside the first column of the      */
     /* BCT is determined by RxBctChPosition register).              */
     /* Otherwise, the NIF ignores these bits and forces the         */
     /* channel to 8'h00.                                            */
     /* range: 13:13, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_bct_en_ch;

     /* RxBctEnBT: If set, the NIF extracts the Burst Type (BT)      */
     /* bits from the BCT header and passes on to ingress.           */
     /* Otherwise, the NIF ignores these bits and forces the         */
     /* burst type to a constant 3'b011 (Full Packet).               */
     /* range: 14:14, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_bct_en_bt;

     /* RxBctEnCrcCheck: If set, the NIF checks the CRC-4 on the     */
     /* BCT and reports errors on the packet. Otherwise, the NIF     */
     /* does not check CRC-4 on BCT.                                 */
     /* range: 15:15, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_bct_en_crc_check;

     /* RxEnsureFceInd: If set, Rx MAC will ensure Frame Check       */
     /* Errors (FCE) indications are propagated to Ingress. This     */
     /* might cause the next packet to be marked with error even     */
     /* if it is a valid error free packet (in case the packet       */
     /* containing the error was dropped). This mode should be       */
     /* enabled when operating in channelized interleaved mode,      */
     /* where it will prevent the risk of FCE errors causing a       */
     /* BOP to be dropped without any indication to Ingress SAR      */
     /* function.                                                    */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ensure_fce_ind;

     /* TxSopOnOddOnly: If set, allow /S/ characters to be           */
     /* transmitted on odd columns only (relative to the ||A||       */
     /* columns). Otherwise, /S/ characters may be transmitted       */
     /* on even columns (see TxSopOnEvenOnly) or on any column.      */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_sop_on_odd_only;

     /* TxIpgMaxCredit 7: If set, allow up to 7 credits to be        */
     /* accumulated by the DIC mechanism (instead of the             */
     /* standard 3 characters). This may be used when working in     */
     /* TxSopOnEvenOnly mode, so average IPG length may be kept      */
     /* even when SOP is delayed by 1 cycle. Enabling this           */
     /* register together with TxSopOnEvenOnly will result in        */
     /* IPG lengths of [5:19] bytes instead of the standard          */
     /* [9:15] bytes as defined by the IEEE standard.                */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_ipg_max_credit_7;

     /* LFS ResponseToLF: Determines how MAL will respond to LF      */
     /* that is either detected locally (by Rx PCS) or indicated     */
     /* from PHY or link partner: [000] Reserved [001] Continue      */
     /* sending data, send Idles [010] Continue sending data,        */
     /* send RF [011] Continue sending data, send LF [100]           */
     /* Reserved [101] Stop sending data, send Idles [110] Stop      */
     /* sending data, send RF (default) [111] Stop sending data,     */
     /* send LF                                                      */
     /* range: 26:24, access type: RW, default value: 0x6            */
     SOC_PETRA_REG_FIELD lfs_response_to_lf;

     /* LFS ResponseToRF: Determines how MAL will respond to RF      */
     /* that is indicated by link partner: [000] Reserved [001]      */
     /* Continue sending data, send Idles [010] Continue sending     */
     /* data, send RF [011] Continue sending data, send LF [100]     */
     /* Reserved [101] Stop sending data, send Idles (default)       */
     /* [110] Stop sending data, send RF [111] Stop sending          */
     /* data, send LF                                                */
     /* range: 30:28, access type: RW, default value: 0x5            */
     SOC_PETRA_REG_FIELD lfs_response_to_rf;

  } __ATTRIBUTE_PACKED__ spaui_extensions1_reg;

  /* SPAUI Extensions2: SPAUI Extensions to standard XAUI           */
  /* configuration (Tx)                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x520f */

     /* TxSopOnEvenOnly: If set, allow /S/ characters to be          */
     /* transmitted on even columns only (relative to the ||A||      */
     /* columns). Otherwise, /S/ characters may be transmitted       */
     /* on odd columns (see TxSopOnOddOnly) or on any column.        */
     /* This configuration takes precedence over TxSopOnOddOnly      */
     /* (in case both are enabled).                                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_sop_on_even_only;

     /* Tx A OnEvenOnly: If set, allow ||A|| columns to be           */
     /* transmitted on even columns only. Otherwise, ||A||           */
     /* columns may be transmitted on any column.                    */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_a_on_even_only;

     /* TxCrcInsertEn: Reserved (write as 1).                        */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tx_crc_insert_en;

     /* TxCrc24Mode: If set, Tx MAC will use non-standard 3B         */
     /* CRC-24. Otherwise standard 4B CRC-32 will be used.           */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_crc24_mode;

     /* TxBctSize: Determines the number of BCT bytes that Tx        */
     /* MAC will insert into the preamble (0, 1 or 2 bytes). 1B      */
     /* BCT means only CH field is sent.                             */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_bct_size;

     /* TxPreambleSize: Preamble column size: [2] - complete to      */
     /* two columns. [1] - complete to one column. [0] - less        */
     /* than one column (i.e. only /S/ and/or BCT).                  */
     /* range: 7:6, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD tx_preamble_size;

     /* TxBctChPosition: Index of the byte containing the CH         */
     /* (Channel) field inside the first column of the preamble.     */
     /* Possible values are 0 (if no /S/ in preamble), 1, 2, and     */
     /* 3.                                                           */
     /* range: 9:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tx_bct_ch_position;

     /* TxPreambleSOP: If set, Tx MAC will insert /S/ character      */
     /* at the beginning of a packet.                                */
     /* range: 10:10, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tx_preamble_sop;

     /* TxAltCrcMode: If set, Tx MAC will use alternative CRC32      */
     /* method and will include the first character of preamble      */
     /* (/S/) in the CRC calculation. This character will be         */
     /* considered as 8'hFB (regardless of the actual character      */
     /* being transmitted, i.e. TxPreambleSOP=0).                    */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_alt_crc_mode;

     /* TxBctOvrdLlfc: If set, the NIF will override the             */
     /* transmitted LLFC with value defined by                       */
     /* TxBctOvrdLlfcValue register. This does not affect how        */
     /* NIF (FCT) handles flow-control indications from CFC and      */
     /* RxMLF (see TxBctLlfc).                                       */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_llfc;

     /* TxBctOvrdCh: If set, the NIF will override the               */
     /* transmitted CH (Channel) with value defined by               */
     /* TxBctOvrdChValue register.                                   */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_ch;

     /* TxBctOvrdBt: If set, the NIF will override the               */
     /* transmitted BT (Burst Type) with value defined by            */
     /* TxBctOvrdBtValue register.                                   */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_bt;

     /* TxBctOvrdCrc: If set, the NIF will override the              */
     /* transmitted BCT CRC-4 with value defined by                  */
     /* TxBctOvrdCrcValue register.                                  */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_crc;

     /* TxBctOvrdChValue: Value used to override the transmitted     */
     /* CH (Channel).                                                */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_ch_value;

     /* TxBctOvrdBtValue: Value used to override the transmitted     */
     /* BT (Burst Type).                                             */
     /* range: 26:24, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_bt_value;

     /* TxBctOvrdLlfcValue: Value used to override the               */
     /* transmitted LLFC.                                            */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_llfc_value;

     /* TxBctOvrdCrcValue: Value used to override the                */
     /* transmitted BCT CRC-4.                                       */
     /* range: 31:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_crc_value;

  } __ATTRIBUTE_PACKED__ spaui_extensions2_reg;

  /* SPAUI Insert Idle Config: Insert Idles mode is used to         */
  /* force insertion of idle characters (IPG) at given              */
  /* intervals when using IPG compression.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5210 */

     /* TxInsertIdlesCount: How often to insert Idle columns         */
     /* (steps of 256 TxClk cycles). This register is ignored        */
     /* when not working with full IPG compression                   */
     /* range: 23:0, access type: RW, default value: 24'h000000      */
     SOC_PETRA_REG_FIELD tx_insert_idles_count;

     /* TxInsertIdlesMode: Reserved. Write as 0 to disable, or 3     */
     /* to enable.                                                   */
     /* range: 29:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_insert_idles_mode;

  } __ATTRIBUTE_PACKED__ spaui_insert_idle_config_reg;

  /* BOM: RXAUI BOM (Byte Order Mux) Configuration register         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5211 */

     /* Rx BOM En: If set, RXAUI and QSGMII Rx BOM functions         */
     /* (Byte Order Mux) will be enabled. For RXAUI, the             */
     /* function is enabled when the XAUI Rx PCS deskew function     */
     /* indicates a deskew error or when a new alignment is          */
     /* detected (no qualification is required). See RxBomFsmEn      */
     /* register. When enabled, the BOM function will monitor        */
     /* /A/ characters on logical lanes (LL) that were demuxed       */
     /* from the same Physical Lane (PL), and ensure they are        */
     /* mapped to the correct LL of the MAL. For QSGMII, the BOM     */
     /* function will lock to new alignment when enabled by the      */
     /* Rx QSGMII FSM or whenever a new alignment is detected        */
     /* (no qualification is required). See RxBomFsmEn register.     */
     /* If unset, both BOM functions will be forced to select        */
     /* alignment position <0>. This register may always be set      */
     /* to <1>.                                                      */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_bom_en;

     /* Rx BOM FSM En: If set, RXAUI and QSGMII BOM functions        */
     /* will lock to new alignment only when enabled by the XAUI     */
     /* Deskew Functions or by the QSGMII Alignment FSM,             */
     /* respectively. Otherwise, the BOM function will lock to       */
     /* any new alignment whenever it is detected (no enable         */
     /* needed). This register should be enabled by default.         */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_bom_fsm_en;

     /* Rx BOM DeskewErrEn: If set, XAUI Rx PCS Deskew FSM will      */
     /* consider BOM (Byte Order Mux) alignment errors as deskew     */
     /* errors that affect FSM.                                      */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_bom_deskew_err_en;

     /* RxDeskew A OnEvenLanes: If set, XAUI Rx PCS will deskew      */
     /* pairs of logical lanes (LL0 and LL1, LL2 and LL3). This      */
     /* is used if /A/ characters are only allowed on even LLs       */
     /* (LL0, LL2). In such case, /A/ on odd lanes may be mapped     */
     /* to alternative characters. This should be used together      */
     /* with Rx_BOM_A_OnLSB (see also Tx_A_MappingEn).               */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_deskew_a_on_even_lanes;

     /* Rx BOM A OnLSB: If set, Rx BOM will treat /A/ on MSB as      */
     /* BOM swap (deskew) error and will swap PL to LL mapping       */
     /* for this lane. As a result, LL containing /A/ characters     */
     /* will always be aligned to even LLs (LL0, LL2). This          */
     /* should be used together with RxDeskew_A_OnEvenLanes.         */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_bom_a_on_lsb;

     /* Rx BOM A OnMSB: Reserved (write as 0).                       */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_bom_a_on_msb;

     /* Tx K MappingEn: If set, corresponding Tx PCS logical         */
     /* lane will use value from TxMappingValue register instead     */
     /* of the IEEE defined value for comma mapping (/K28.5/ =       */
     /* 8'hBC). This will allow link partner to use alternative      */
     /* BOM method by allowing comma alignment only to logical       */
     /* lanes 0 or 2. Use <0xA> to enable this mode.                 */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_k_mapping_en;

     /* Tx A MappingEn: If set, corresponding Tx PCS logical         */
     /* lane will use value from TxMappingValue register instead     */
     /* of the IEEE defined value for alignment (/A/) character      */
     /* mapping (/K28.3/ = 8'h7C). This will allow link partner      */
     /* to use alternative BOM method by allowing /A/ characters     */
     /* only to logical lanes 0 or 2. Use <0xA> to enable this       */
     /* mode.                                                        */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_a_mapping_en;

     /* TxMappingValue: Alternative value used to map /K/            */
     /* (comma) characters (instead of IEEE /K28.5/) or /A/          */
     /* (alignment) characters (instead of /K28.3/). BIT [8]         */
     /* (MSB) will be used as RxC, bits [7:0] will be used as        */
     /* RxD.                                                         */
     /* range: 24:16, access type: RW, default value: 0x1bc          */
     SOC_PETRA_REG_FIELD tx_mapping_value;

     /* RxSwapLL: If set, order of the SerDes Physical Lanes         */
     /* (PL) will be swapped when mapped into Logical Lanes          */
     /* (LL): For XAUI: PL0->LL3, PL1->LL2, PL2->LL1, PL3->LL0.      */
     /* When in double-rate (DR) mode, should set also               */
     /* BOM_SwapLL_Pair in order to achieve proper lane              */
     /* swapping.                                                    */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_swap_ll;

     /* RxSwapLL Pair: If set, swap the order of each pair of        */
     /* Logical Lanes (LL) that were muxed together on a Double      */
     /* Rate (DR) Physical Lane (PL): For RXAUI: LL0<->LL1,          */
     /* LL2<->LL3. When used together with BOM_SwapLL, will          */
     /* generate the following mapping for RXAUI: PL0->LL3+LL2,      */
     /* PL1->LL1+LL0.                                                */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_swap_ll_pair;

     /* TxSwapLL: Same as RxSwapLL for Tx.                           */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_swap_ll;

     /* TxSwapLL Pair: Same as RxSwapLL_Pair for Tx.                 */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_swap_ll_pair;

  } __ATTRIBUTE_PACKED__ bom_reg;

  /* Statistics: Statistic Module Configurations. Note: All          */
  /* MAL statistics counters inherit the G-Timer from the           */
  /* NBI.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5214 */

     /* StatReset: If set, statistics counters of corresponding      */
     /* port will be held in reset. Note that the statistic          */
     /* counters do not clear on MAL reset and must be reset         */
     /* using this register.                                         */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD stat_reset;

     /* FcRxCountLLFC: Reserved (write as 1).                        */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD fc_rx_count_llfc;

     /* FcRxCountCBFC: Reserved (write as 1).                        */
     /* range: 5:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD fc_rx_count_cbfc;

     /* FcRxCountFCB: Reserved (write as 1).                         */
     /* range: 6:6, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD fc_rx_count_fcb;

     /* FcTxCountLLFC: Reserved (write as 1).                        */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD fc_tx_count_llfc;

     /* FcTxCountCBFC: Reserved (write as 1).                        */
     /* range: 9:9, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD fc_tx_count_cbfc;

     /* FcTxCountFCB: Reserved (write as 1).                         */
     /* range: 10:10, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fc_tx_count_fcb;

     /* FcTxCountPausedCycles: Reserved (write as 0).                */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_count_paused_cycles;

     /* FcTxCountIdles: Reserved (write as 0).                       */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_count_idles;

     /* FcTxCountTxGenLlfc: Reserved (write as 0).                   */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_count_tx_gen_llfc;

     /* FcTxCountTxGenLlfcRise: Reserved (write as 0).               */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_count_tx_gen_llfc_rise;

     /* FcRxCountLpResp: Reserved (write as 0).                      */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx_count_lp_resp;

     /* RxCountBursts: Reserved (write as 0).                        */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_count_bursts;

     /* TxCountBursts: Reserved (write as 0).                        */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_count_bursts;

     /* StatGtimerModeEn: Reserved (write as 0).                     */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_gtimer_mode_en;

     /* Stat_1588AfIntEn: If set, will include the IEEE 1588         */
     /* frame counters (only 16b) in the interrupt indication        */
     /* coming from the statistic collector module (i.e.,            */
     /* indicated when a counter reaches 75% of its maximal          */
     /* value).                                                      */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD stat_1588_af_int_en;

  } __ATTRIBUTE_PACKED__ statistics_reg;

  /* Statistics Read Select: Statistics Read Select. When           */
  /* writing to this register, the value of the selected            */
  /* statistics counter will be copied to StatRdCounter             */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5215 */

     /* StatRdCounterId: Select one of the counters to read: [0]     */
     /* Rx Pause Frames With no errors [1] Rx Pause Frames           */
     /* Errors [2] Rx 1588 Frames (16b) [3] Rx MAC Frame Check       */
     /* Errors (FCE) [8] Tx Pause Frames [10] Tx 1588 Frames         */
     /* (16b) [11] Tx MAC Drops (approx number of dropped bursts     */
     /* due to link failure) [Other] Reserved (will return 0).       */
     /* NOTES: - All counters are 32b saturation counters            */
     /* (except for the 1588 frames counters which are 16b). -       */
     /* In XAUI Mode, Rx and Tx Pause Frames counters of ports       */
     /* 1, 2, and 3 will count number of LLFC, CBFC, and FCB         */
     /* frames (respectively). - In XAUI Mode, Rx MAC Frame          */
     /* Errors counter of port 1 will count BCT CRC Errors. - Tx     */
     /* Pause Frames counters of ports 1 and 3 may be used to        */
     /* count how long link is paused (see                           */
     /* StatTxCountPausedCycles register). - Tx MAC Drops            */
     /* counters may be used to count number of idle characters      */
     /* sent on link (see FcTxCountIdles register).                  */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_rd_counter_id;

     /* StatRdCounterPort: Select one of 4 GMII ports, or port 0     */
     /* for XAUI.                                                    */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_rd_counter_port;

     /* StatRdCounterClr: If set, counter will be cleared after      */
     /* it is read. Otherwise, counter will continue                 */
     /* accumulating events. Set to <1> for normal operation.        */
     /* range: 28:28, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD stat_rd_counter_clr;

  } __ATTRIBUTE_PACKED__ statistics_read_select_reg;

  /* Statistics Read Counter: Contains the data read from the       */
  /* selected statistics counter.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5216 */

     /* StatRdCounter: When a new selection is written to            */
     /* StatRdCounerId and StatRdCounterPort, the value of the       */
     /* selected counter is copied to this register. This is a       */
     /* saturated counter. When any of the counters reach 75% of     */
     /* its maximal value, the statistics interrupt is set for       */
     /* the relevant port.                                           */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_rd_counter;

  } __ATTRIBUTE_PACKED__ statistics_read_counter_reg;

  /* Flow Control Tx: Configuration options for outgoing (Tx)       */
  /* Link-Level Flow Control.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5218 */

     /* FcTxLlfcEn: If set, NIF Tx (FCT) will generate Standard      */
     /* IEEE Pause Frames to indicate LLFC to link partner.          */
     /* Note: In each link, only one type of FC should be            */
     /* enabled (LLFC, CBFC or BCT. LLFC).                            */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD fc_tx_llfc_en;

     /* FcTxCbfcEn: If set, NIF Tx (FCT) will generate Extended      */
     /* Pause Frames (class-based) to indicate CBFC to link          */
     /* partner. Note: In each link, only one type of FC should      */
     /* be enabled (LLFC, CBFC or BCT. LLFC).                         */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_tx_cbfc_en;

     /* FcTxBctLlfcEn: If set, NIF Tx (FCT) will use BCT. LLFC to     */
     /* indicate LLFC conditions to link partner. Note: In each      */
     /* link, only one type of FC should be enabled (LLFC, CBFC      */
     /* or BCT. LLFC).                                                */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_bct_llfc_en;

     /* FcTxFcbEn: If set, NIF Tx (FCT) will generate Flow           */
     /* Control Bursts to indicate BCT. LLFC to link partner          */
     /* (incase there is no outgoing traffic or when link is         */
     /* paused). This should only be set when using BCT. LLFC.        */
     /* Note: In each link, only one type of FC should be            */
     /* enabled (LLFC, CBFC or BCT. LLFC).                            */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_fcb_en;

     /* FcTxShift 2 Byte: If set, Pause Frames (LLFC+CBFC) will      */
     /* be shifted by 2B. This should accommodate for 2B             */
     /* sequence number for Fat-Pipe.                                */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_shift_2_byte;

     /* FcTxDefaultSeqNum: If set, the default 2B sequence           */
     /* number (Fat-Pipe mode) to be inserted at the head of         */
     /* pause frames will be 0xffff. Frames with this sequence       */
     /* number should be bypassed by the receivers resequencer       */
     /* (if configured to do so). Otherwise, value of 0x0000         */
     /* will be used. This register is only relevant if              */
     /* FcTxShift_2B is asserted.                                    */
     /* range: 15:15, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fc_tx_default_seq_num;

     /* FcTxLlfcAsCbfcEn: If set, NIF Tx (FCT) will generate         */
     /* Extended Pause Frames (class-based) with all classes         */
     /* indicating XOFF, in order to indicate LLFC XOFF              */
     /* condition to link partner. This should be enabled when       */
     /* using CBFC.                                                  */
     /* range: 19:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_llfc_as_cbfc_en;

     /* FcTxCbfcPrioritizeDnEn: If set, CBFC classes will affect     */
     /* lower priority classes, where the highest priority is        */
     /* class 7. If a high-priority class is XOFF, all lower         */
     /* priority classes will be forced to XOFF as well.             */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fc_tx_cbfc_prioritize_dn_en;

     /* FcTxCbfcPrioritizeUpEn: If set, CBFC classes will affect     */
     /* lower priority classes, where the highest priority is        */
     /* class 0. If a high-priority class is XOFF, all lower         */
     /* priority classes will be forced to XOFF as well.             */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_cbfc_prioritize_up_en;

     /* FcTxXonOnEdge: If set, NIF Tx will generate XON FC           */
     /* indication when pause condition is no longer required        */
     /* (i.e. when Soc_petra Ingress is no longer congested and          */
     /* there is no need for link partner to continue pausing        */
     /* the link).                                                   */
     /* range: 22:22, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fc_tx_xon_on_edge;

     /* FcTxHysteresisThreshold: Define hysteresis to prevent        */
     /* sending back-to-back pause frames. This will delay           */
     /* sending XON pause frames, and will not affect XOFF pause     */
     /* frames. Measured in 512b time units. Value of 0 disables     */
     /* the hysteresis, allowing generation of pause frames          */
     /* without any additional delay.                                */
     /* range: 31:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fc_tx_hysteresis_threshold;

  } __ATTRIBUTE_PACKED__ flow_control_tx_reg;

  /* Flow Control Tx Cbfc: Configuration options for outgoing       */
  /* (Tx) Class-Based Flow Control.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5219 */

     /* FcTx0CbfcMapTable: For GMII ports, the Soc_petra Core            */
     /* indicates only 2 CBFC classes. These should be mapped        */
     /* into 8 classes indicated in the Extended Pause Frames.       */
     /* Mapping is done using this register: classes indexed         */
     /* from 0 to the value of this register (inclusive) are         */
     /* grouped together. Classes with indexes larger than the       */
     /* value of this register are grouped together. Each GMII       */
     /* port has its own mapping table. This register refers to      */
     /* GMII port 0.                                                 */
     /* range: 2:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD fc_tx0_cbfc_map_table;

     /* FcTx1CbfcMapTable: Tables for mapping CBFC classes of        */
     /* GMII port 1.                                                 */
     /* range: 6:4, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD fc_tx1_cbfc_map_table;

     /* FcTx2CbfcMapTable: Tables for mapping CBFC classes of        */
     /* GMII port 2.                                                 */
     /* range: 10:8, access type: RW, default value: 0x3             */
     SOC_PETRA_REG_FIELD fc_tx2_cbfc_map_table;

     /* FcTx3CbfcMapTable: Tables for mapping CBFC classes of        */
     /* GMII port 3.                                                 */
     /* range: 14:12, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fc_tx3_cbfc_map_table;

  } __ATTRIBUTE_PACKED__ flow_control_tx_cbfc_reg;

  /* Flow Control Tx Refresh Timer: Defines timers for              */
  /* resending XON or XOFF pause frames. When indicating XON        */
  /* or XOFF to link partner, a new indication will be              */
  /* generated when this timers expires (i.e., a new pause          */
  /* frame or BCT. LLFC).                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x521a */

     /* FcTxRefreshTimerXoff: XOFF refresh timer. For                */
     /* effectively pausing the link partner, place here a value     */
     /* that is at least 4 jumbos smaller than                       */
     /* FcTxPauseQuantaXoff. Value of 0 disables the refresh         */
     /* function. Measured in 512b time units.                       */
     /* range: 15:0, access type: RW, default value: 0x8000          */
     SOC_PETRA_REG_FIELD fc_tx_refresh_timer_xoff;

     /* FcTxRefreshTimerXon: XON refresh timer. Specifically,        */
     /* this timer may be used for rate adaptation of traffic        */
     /* coming from link partner. In normal mode (no rate            */
     /* adaptation is needed), it is still recommended to send       */
     /* XON pause frames periodically, so if XON indication was      */
     /* missed by LP (i.e., due to CRC error), the link will not     */
     /* enter deadlock. Value of 0 disables the refresh              */
     /* function. Measured in 512b time units.                       */
     /* range: 31:16, access type: RW, default value: 0xffff         */
     SOC_PETRA_REG_FIELD fc_tx_refresh_timer_xon;

  } __ATTRIBUTE_PACKED__ flow_control_tx_refresh_timer_reg;

  /* Flow Control Tx Quanta: Pause quanta for outgoing pause        */
  /* frames.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x521b */

     /* FcTxPauseQuantaXoff: 16-bit pause quanta used for all        */
     /* outgoing Pause Frames (LLFC or CBFC) that indicate XOFF.     */
     /* Measured in 512b time units.                                 */
     /* range: 15:0, access type: RW, default value: 0xf000          */
     SOC_PETRA_REG_FIELD fc_tx_pause_quanta_xoff;

     /* FcTxPauseQuantaXon: 16-bit pause quanta used for all         */
     /* outgoing Pause Frames (LLFC or CBFC) that indicate XON.      */
     /* Measured in 512b time units. Use non-zero values to          */
     /* enable rate adaptation.                                      */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_pause_quanta_xon;

  } __ATTRIBUTE_PACKED__ flow_control_tx_quanta_reg;

  /* Flow Control Source Addr: NIF MAC Address                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x521c */

     /* FcMalSourceAddress: 48b Source Address (SA) used for all     */
     /* outgoing Pause Frames. Also, this value is used when         */
     /* comparing the Destination Address (DA) of incoming pause     */
     /* frames. The DA should be either the globally assigned        */
     /* multicast address (hardwired constant), or the unicast       */
     /* address of the NIF (defined by this register). Same          */
     /* value is used for all GMII ports.                            */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_mal_source_address;

  } __ATTRIBUTE_PACKED__ flow_control_source_addr_reg[SOC_PB_NIF_MAC_LANE_FLOW_CONTROL_SOURCE_ADDR_REG_MULT_NOF_REGS];

  /* Flow Control Rx: Configuration of incoming (Rx)                */
  /* Flow-Control indications.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x521e */

     /* FcRxLlfcEn: If set, the NIF Rx can receive and process       */
     /* standard LLFC pause frames. Otherwise, LLFC pause frames     */
     /* are ignored.                                                 */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD fc_rx_llfc_en;

     /* FcRxCbfcEn: If set, the NIF Rx can receive and process       */
     /* extended CBFC pause frames. Otherwise, CBFC pause frames     */
     /* are ignored.                                                 */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_rx_cbfc_en;

     /* FcRxBctLlfcEn: If set, NIF Rx (FCR) will extract LLFC        */
     /* conditions from the BCT. LLFC field. Note: While Pause        */
     /* frames (LLFC and CBFC) can co-exist on a link, BCT. LLFC      */
     /* may cause contradictions and should not co-exist             */
     /* together with pause frames on the same link.                 */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx_bct_llfc_en;

     /* FcRxShift 2 Byte: If set, Pause Frames (LLFC+CBFC) will      */
     /* be shifted by 2B. This should accommodate for 2B             */
     /* sequence number for Fat-Pipe.                                */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx_shift_2_byte;

     /* FcRxLlfcAsCbfcEn: If set, NIF Rx (FCR) will interpret        */
     /* Extended Pause Frames (class-based) with all classes         */
     /* XOFF as LLFC XOFF condition. NIF Tx can immediately          */
     /* respond to this condition and pause the link. This           */
     /* should be enabled when using CBFC.                           */
     /* range: 19:16, access type: RW, default value: 0xf            */
     SOC_PETRA_REG_FIELD fc_rx_llfc_as_cbfc_en;

     /* FcRxCbfcPrioritizeDnEn: If set, CBFC classes will affect     */
     /* lower priority classes, where the highest priority is        */
     /* class 7. If a high-priority class is XOFF, all lower         */
     /* priority classes will be forced to XOFF as well. Should      */
     /* not be set if FcRxCbfcPrioritizeUpEn is set.                 */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fc_rx_cbfc_prioritize_dn_en;

     /* FcRxCbfcPrioritizeUpEn: If set, CBFC classes will affect     */
     /* lower priority classes, where the highest priority is        */
     /* class 0. If a high-priority class is XOFF, all lower         */
     /* priority classes will be forced to XOFF as well. Should      */
     /* not be set if FcRxCbfcPrioritizeDnEn is set.                 */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx_cbfc_prioritize_up_en;

     /* FcRxXoffEn: If set, NIF Rx (FCR) will interpret pause        */
     /* quanta of 0xffff as indefinite pause.                        */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx_xoff_en;

     /* FcRxTerminatePause: If set, the NIF Rx path will             */
     /* terminate Pause Frames (standard LLFC or extended CFBC       */
     /* frames). Terminated frames will not be passed to             */
     /* Ingress. This configuration does not affect the              */
     /* processing of Pause Frames by the NIF-FCR.                   */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fc_rx_terminate_pause;

     /* FcRxTerminateMacCtrl: If set, the NIF Rx path will           */
     /* terminate Mac Control Frames (including Pause Frames).       */
     /* Terminated frames will not be passed to Ingress. This        */
     /* configuration does not affect the processing of MAC Ctrl     */
     /* frames (including Pause Frames) by the NIF-FCR.              */
     /* range: 25:25, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fc_rx_terminate_mac_ctrl;

     /* FcRxTerminateFcBurst: If set, the NIF Rx path will           */
     /* terminate SPAUI Flow Control Bursts (BCT. PT=3'b111).         */
     /* Terminated frames will not be passed to Ingress. This        */
     /* configuration does not affect the processing of FC           */
     /* Bursts by the NIF-FCR.                                       */
     /* range: 26:26, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fc_rx_terminate_fc_burst;

     /* FcRxMaskMacCtrl: Reserved (set to 0).                        */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx_mask_mac_ctrl;

     /* FcRxMaskFcBurst: Reserved (set to 0).                        */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx_mask_fc_burst;

  } __ATTRIBUTE_PACKED__ flow_control_rx_reg;

  /* Flow Control Rx2: Configuration options for incoming           */
  /* (Rx) Class-Based Flow Control.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x521f */

     /* FcRx0CbfcMapClass0: Received Extended (CBFC) Pause           */
     /* Frames carry eight classes. For GMII ports these eight       */
     /* classes should be mapped into two classes that are           */
     /* supported by the Soc_petra core. Mapping is done using this      */
     /* register: pause quanta for class 0 of the GMII port is       */
     /* taken from the class with this index in the extended         */
     /* pause frame. This register refers to class 0 of GMII         */
     /* port 0.                                                      */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_rx0_cbfc_map_class0;

     /* FcRx0CbfcMapClass1: This register refers to class 1 of       */
     /* GMII port 0.                                                 */
     /* range: 6:4, access type: RW, default value: 0x7              */
     SOC_PETRA_REG_FIELD fc_rx0_cbfc_map_class1;

     /* FcRx1CbfcMapClass0: This register refers to class 0 of       */
     /* GMII port 1.                                                 */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_rx1_cbfc_map_class0;

     /* FcRx1CbfcMapClass1: This register refers to class 1 of       */
     /* GMII port 1.                                                 */
     /* range: 14:12, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD fc_rx1_cbfc_map_class1;

     /* FcRx2CbfcMapClass0: This register refers to class 0 of       */
     /* GMII port 2.                                                 */
     /* range: 18:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx2_cbfc_map_class0;

     /* FcRx2CbfcMapClass1: This register refers to class 1 of       */
     /* GMII port 2.                                                 */
     /* range: 22:20, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD fc_rx2_cbfc_map_class1;

     /* FcRx3CbfcMapClass0: This register refers to class 0 of       */
     /* GMII port 3.                                                 */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx3_cbfc_map_class0;

     /* FcRx3CbfcMapClass1: This register refers to class 1 of       */
     /* GMII port 3.                                                 */
     /* range: 30:28, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD fc_rx3_cbfc_map_class1;

  } __ATTRIBUTE_PACKED__ flow_control_rx2_reg;

  /* LLFC Pause Quanta: Pause quanta for BCT. LLFC                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5220 */

     /* FcRxBctLlfcPauseQuanta: Default Pause Quanta to be used      */
     /* when receiving BCT. LLFC (XOFF).                              */
     /* range: 15:0, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD fc_rx_bct_llfc_pause_quanta;

  } __ATTRIBUTE_PACKED__ llfc_pause_quanta_reg;

  /* Flow Control Tx Overrides: Override Tx FC indications          */
  /* from CFC.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5221 */

     /* FcTxLlfcStopTxEn: If set, allows NBI LLFC Stop Tx            */
     /* indications to propagate to FCT. Otherwise, LLFC Stop Tx     */
     /* indications are masked. These indications cause the Tx       */
     /* path to stop transmission on the next burst boundary.        */
     /* Each bit corresponds to one of the GMII ports. Bit 0         */
     /* used for XAUI.                                               */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD fc_tx_llfc_stop_tx_en;

     /* FcTxLlfcStopTxForce: If set, forces NBI LLFC Stop Tx         */
     /* indications to 1. Each bit corresponds to one of the         */
     /* GMII ports. Bit 0 used for XAUI.                             */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_tx_llfc_stop_tx_force;

     /* FcTxGenLlfcEn: If set, allows NBI GEN LLFC indications       */
     /* to propagate to FCT. Otherwise, GEN LLFC indications are     */
     /* masked. These indications cause the FCT to transmit an       */
     /* LLFC indication to link partner (either a pause frame or     */
     /* BCT. LLFC). Each bit corresponds to one of the GMII           */
     /* ports. Bit 0 used for XAUI.                                  */
     /* range: 11:8, access type: RW, default value: 0xf             */
     SOC_PETRA_REG_FIELD fc_tx_gen_llfc_en;

     /* FcTxGenLlfcForce: If set, forces NBI GEN LLFC                */
     /* indications to 1. Each bit corresponds to one of the         */
     /* GMII ports. Bit 0 used for XAUI.                             */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_gen_llfc_force;

     /* FcTxGenCbfcEn: If set, allows NBI GEN CBFC indications       */
     /* to propagate to FCT. Otherwise, CFC LLFC indications are     */
     /* masked. These indications cause FCT to transmit a CBFC       */
     /* pause frame to link partner. Each bit represents one of      */
     /* the classes.                                                 */
     /* range: 23:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD fc_tx_gen_cbfc_en;

     /* FcTxGenCbfcForce: If set, forces NBI GEN LLFC                */
     /* indications to 1. Each bit represents one of the             */
     /* classes.                                                     */
     /* range: 31:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_gen_cbfc_force;

  } __ATTRIBUTE_PACKED__ flow_control_tx_overrides_reg;

  /* Flow Control Rx Overrides1: Override Rx FC indications         */
  /* from FCR to FCT.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5222 */

     /* FcRxStartEn: If set, allows FCR Start indication to          */
     /* propagate to FCT. FCT will track how long this               */
     /* indication is held high and will pause the Tx data           */
     /* stream for this duration (on the next packet boundary).      */
     /* Each bit corresponds to one of the GMII ports. Bit 0 is      */
     /* used for XAUI.                                               */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD fc_rx_start_en;

     /* FcRxStartForce: If set, will force the FCR Start             */
     /* indication to 1. Each bit corresponds to one of the GMII     */
     /* ports. Bit 0 is used for XAUI.                               */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_rx_start_force;

     /* FcRxStopEn: If set, allows the FCR Stop indication to        */
     /* propagate to FCR. Once indicated, the FCT will reset the     */
     /* counter that determines for how long the Tx data stream      */
     /* should be passed. This indication is normally the result     */
     /* of receiving a pause frame with XON indication from link     */
     /* partner. Each bit corresponds to one of the GMII ports.      */
     /* Bit 0 is used for XAUI.                                      */
     /* range: 11:8, access type: RW, default value: 0xf             */
     SOC_PETRA_REG_FIELD fc_rx_stop_en;

     /* FcRxStopForce: If set, will force the FCR Stop               */
     /* indication to 1. Each bit corresponds to one of the GMII     */
     /* ports. Bit 0 is used for XAUI.                               */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx_stop_force;

     /* FcRxShortPause: Reserved (set to 0).                         */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx_short_pause;

     /* FcTxShortPause: Reserved (set to 0).                         */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_tx_short_pause;

  } __ATTRIBUTE_PACKED__ flow_control_rx_overrides1_reg;

  /* Flow Control Rx Overrides2: Override Rx FC indications         */
  /* from FCR to CFC.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5223 */

     /* FcRxCbfcEnOut: If set, FCR pause conditions will be          */
     /* indicated to NBI. Otherwise, these indications will be       */
     /* forced to 0 (not-paused). Each bit represents one of the     */
     /* classes.                                                     */
     /* range: 7:0, access type: RW, default value: 0xff             */
     SOC_PETRA_REG_FIELD fc_rx_cbfc_en_out;

     /* FcRxCbfcForceOut: If set, FCR pause conditions indicated     */
     /* to NBI will be forced to 1 (paused). Each bit represents     */
     /* one of the classes.                                          */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_rx_cbfc_force_out;

     /* FcRxLlfcEnOut: If set, FCR pause conditions will be          */
     /* indicated to NBI. Otherwise, these indications will be       */
     /* forced to 0 (not-paused). Only port 0 (XAUI) is              */
     /* indicated (for grouping function).                           */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fc_rx_llfc_en_out;

     /* FcRxLlfcForceOut: If set, FCR LLFC pause conditions          */
     /* indicated to NBI will be forced to 1 (paused). Only port     */
     /* 0 (XAUI) is indicated (for grouping function).               */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rx_llfc_force_out;

  } __ATTRIBUTE_PACKED__ flow_control_rx_overrides2_reg;

  /* Flow Control Status: Flow Control status indication            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5224 */

     /* FcTxLinkIsPaused: If set, indicate link Tx path is           */
     /* currently paused. Each bit corresponds to one of the         */
     /* GMII ports. Bit 0 is used for XAUI.                          */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_tx_link_is_paused;

  } __ATTRIBUTE_PACKED__ flow_control_status_reg;

  /* IEEE 1588: IEEE 1588 configuration registers. The IEEE         */
  /* 1588 is supported through local timers that reside in          */
  /* the MAL Rx/Tx clock domains. These local counters are          */
  /* incremented every MAL Rx/Tx clock, allowing up to 3ns          */
  /* drift to accumulate from one PTP clock to another. The         */
  /* local counters are synced to the global PTP timer on           */
  /* every rising edge of the PTP_Clk. The global PTP timer         */
  /* itself is reset to a preset value on rising edge of the        */
  /* PTP_Clk if the PTP_Sync is set to 1 (PTP_Sync should be        */
  /* generated from falling edge of PTP_Clk).                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5225 */

     /* PtpStampingReset: If set, the 1588 stamping FSM will be      */
     /* kept in soft reset.                                          */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ptp_stamping_reset;

     /* PtpTslcReset: If set, the 1588 PTP local and global          */
     /* timers will be kept in soft reset.                           */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ptp_tslc_reset;

     /* PtpTslcSyncEn: If set, the Rx+Tx PTP global timers will      */
     /* be set to their reset value on the next PTP_SYNC pulse.      */
     /* Otherwise, PTP_SYNC is ignored.                              */
     /* range: 5:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ptp_tslc_sync_en;

     /* PtpTslcForceSync: If set, the Rx+Tx PTP global timers        */
     /* will be set to their reset value (on rising edge of this     */
     /* register). Otherwise, will reset the timers on rising        */
     /* edge of PTP_Sync signal from external pin. Set to 0 for      */
     /* normal functional mode.                                      */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ptp_tslc_force_sync;

     /* PtpPauseLocalTimer: If set, Rx+Tx local PTP timers (MAL      */
     /* Clock) will pause, thus making it possible to read them      */
     /* (by CPU). The global PTP clock timers will not be            */
     /* affected, so once released the local timers will regain      */
     /* synchronization to the PTP timers. Set to 1 when reading     */
     /* the PtpLocalRxTimer and PtpLocalTxTimer registers.           */
     /* Otherwise, set to 0. See also MalgPtpClockPause register     */
     /* (pause all local timers simultaneously).                     */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ptp_pause_local_timer;

     /* PtpGtimerMode: Reserved (write as 0).                        */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ptp_gtimer_mode;

     /* PtpTx_1588_StampingEn: If set, Tx MAC will detect            */
     /* untagged IEEE 1588 packets and modify the correction         */
     /* field.                                                       */
     /* range: 9:9, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ptp_tx_1588_stamping_en;

     /* PtpRx_1588_StampingEn: If set, Rx MAC will detect            */
     /* untagged IEEE 1588 packets and modify the correction         */
     /* field.                                                       */
     /* range: 10:10, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_rx_1588_stamping_en;

     /* PtpTx_1588_Vlan1_StampingEn: If set, Tx MAC will detect      */
     /* IEEE 1588 packets with one VLAN-Tag and modify the           */
     /* correction field.                                            */
     /* range: 11:11, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_tx_1588_vlan1_stamping_en;

     /* PtpRx_1588_Vlan1_StampingEn: If set, Rx MAC will detect      */
     /* IEEE 1588 packets with one VLAN-Tag and modify the           */
     /* correction field.                                            */
     /* range: 12:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_rx_1588_vlan1_stamping_en;

     /* PtpTx_1588_Vlan2_StampingEn: If set, Tx MAC will detect      */
     /* IEEE 1588 packets with two VLAN-Tags and modify the          */
     /* correction field.                                            */
     /* range: 13:13, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_tx_1588_vlan2_stamping_en;

     /* PtpRx_1588_Vlan2_StampingEn: If set, Rx MAC will detect      */
     /* IEEE 1588 packets with two VLAN-Tags and modify the          */
     /* correction field.                                            */
     /* range: 14:14, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_rx_1588_vlan2_stamping_en;

     /* PtpTx_1588_UdpStampingEn: If set, Tx MAC will detect         */
     /* untagged IEEE 1588 packets over UDP and modify the           */
     /* correction field.                                            */
     /* range: 15:15, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_tx_1588_udp_stamping_en;

     /* PtpRx_1588_UdpStampingEn: If set, Rx MAC will detect         */
     /* untagged IEEE 1588 packets over UDP and modify the           */
     /* correction field.                                            */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_rx_1588_udp_stamping_en;

     /* PtpTx_1588_UdpVlan1_StampingEn: If set, Tx MAC will          */
     /* detect IEEE 1588 packets over UDP with one VLAN-Tag and      */
     /* modify the correction field.                                 */
     /* range: 17:17, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_tx_1588_udp_vlan1_stamping_en;

     /* PtpRx_1588_UdpVlan1_StampingEn: If set, Rx MAC will          */
     /* detect IEEE 1588 packets over UDP with one VLAN-Tag and      */
     /* modify the correction field.                                 */
     /* range: 18:18, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_rx_1588_udp_vlan1_stamping_en;

     /* PtpTx_1588_UdpVlan2_StampingEn: If set, Tx MAC will          */
     /* detect IEEE 1588 packets over UDP with two VLAN-Tags and     */
     /* modify the correction field.                                 */
     /* range: 19:19, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_tx_1588_udp_vlan2_stamping_en;

     /* PtpRx_1588_UdpVlan2_StampingEn: If set, Rx MAC will          */
     /* detect IEEE 1588 packets over UDP with two VLAN-Tags and     */
     /* modify the correction field.                                 */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_rx_1588_udp_vlan2_stamping_en;

     /* PtpTx_1588_UdpClrCsEn: If set, Tx MAC will clear the CS      */
     /* field of IEEE 1588 packets over UDP (with 0, 1 or 2 VLAN     */
     /* tags).                                                       */
     /* range: 21:21, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_tx_1588_udp_clr_cs_en;

     /* PtpRx_1588_UdpClrCsEn: If set, Rx MAC will clear the CS      */
     /* field of IEEE 1588 packets over UDP (with 0, 1 or 2 VLAN     */
     /* tags).                                                       */
     /* range: 22:22, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_rx_1588_udp_clr_cs_en;

     /* PtpTxSaturateEn: Reserved (set to 0).                        */
     /* range: 23:23, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_tx_saturate_en;

     /* PtpRxSaturateEn: Reserved (set to 0).                        */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ptp_rx_saturate_en;

     /* Ptp_1588_StampTimerEn: Reserved (debug). Set to 0. If        */
     /* set, Rx and Tx MAC will place the value of the PTP clock     */
     /* (local timer) on the 8B words that follow the CF field       */
     /* of the packet (taking into consideration if the packet       */
     /* is standard Ethernet, UDP or with VLAN tags). The timer      */
     /* value is placed alligned to 8B words.                        */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ptp_1588_stamp_timer_en;

     /* TxWaitFor_2_WordsAtSob: If set, Tx Aligner will              */
     /* accumulate at least two 64b words before propagating         */
     /* them to the Tx MAC. This is required to allow proper         */
     /* time stamping in the tx data path. Set to <1> when           */
     /* PtpTxTslcStampingEn is set.                                  */
     /* range: 26:26, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tx_wait_for_2_words_at_sob;

  } __ATTRIBUTE_PACKED__ ieee_1588_reg;

  /* IEEE 1588 Timer: The PTP timer is composed of a global         */
  /* timer (running at PTP_CLOCK), and a local timer (running       */
  /* on MAL Rx/Tx clock). This register defines the                 */
  /* increments for the local timer.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5226 */

     /* PtpDeltaEachMalClock: Set the increment that should be       */
     /* added to the PTP local timers each MAL Rx/Tx clock. LSB      */
     /* represents 2^(-8) of a nano-second. Use 8ns*256 for GMII     */
     /* ports (1GE), or 3.2ns*256 for XAUI (10GE). This              */
     /* configuration depends only on MAL Rx/Tx clock.               */
     /* range: 15:0, access type: RW, default value: 0x333           */
     SOC_PETRA_REG_FIELD ptp_delta_each_mal_clock;

  } __ATTRIBUTE_PACKED__ ieee_1588_timer_reg;

  /* IEEE 1588 Tx: IEEE 1588 configuration register for the         */
  /* local MAL Tx Clk timer.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5228 */

     /* PtpTxTslcBias: Reset value for the local PTP Tx timer.       */
     /* This value should reflect Tx pipe depth from the Tx MAC      */
     /* 1588 Time Stamping function until the SRD outputs            */
     /* (pads). LSB represents 1ns. Use value of 8ns*25 for GMII     */
     /* ports (1GE), or 3.2ns*25 for XAUI (10GE).                    */
     /* range: 19:0, access type: RW, default value: 0x50            */
     SOC_PETRA_REG_FIELD ptp_tx_tslc_bias;

  } __ATTRIBUTE_PACKED__ ieee_1588_tx_reg;

  /* IEEE 1588 Rx: IEEE 1588 configuration register for the         */
  /* local MAL Rx Clk timer.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5229 */

     /* PtpRxTslcBias: Reset value for the local PTP Rx timer.       */
     /* This value should reflect Rx pipe depth from the SRD         */
     /* inputs (pads) until the Rx MAC 1588 Time Stamping            */
     /* function. LSB represents 1ns. Use value of 8ns*35 for        */
     /* GMII ports (1GE), or 3.2ns*35 for XAUI (10GE).               */
     /* range: 19:0, access type: RW, default value: 0x70            */
     SOC_PETRA_REG_FIELD ptp_rx_tslc_bias;

  } __ATTRIBUTE_PACKED__ ieee_1588_rx_reg;

  /* GMII Config1: GMII Configurations for IEEE 1000Base-X          */
  /* and SGMII modes                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5236 */

     /* GmiiRxCrcCheckEn: If set, enables CRC-32 checks on           */
     /* received packets. Otherwise, the CRC check result is         */
     /* masked and ignored. Regardless of the checking, 4B will      */
     /* be removed from the end of the packet. Same enable is        */
     /* used by all GMII ports.                                      */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD gmii_rx_crc_check_en;

     /* GmiiRxIgnoreCommaPosition: If set, Rx PCS will ignore        */
     /* even/odd comma position and link will not fail due to        */
     /* wrong position. If set, rx_even register will be reset       */
     /* whenever a new comma is detected (IEEE 802.3 figure          */
     /* 36-7). Set to <1> for QSGMII mode. Same enable is used       */
     /* by all SGMII lanes.                                          */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD gmii_rx_ignore_comma_position;

     /* GmiiRxMidPktPpmCompEn: If set, PAEB (Elastic Buffer) is      */
     /* allowed to compensate for PPM mid-packet. This is            */
     /* possible for SGMII 10/100 mode, where each character is      */
     /* duplicated 10 or 100 times. In such cases, each packet       */
     /* is much longer than in standard 1000 Base-X, so              */
     /* accumulated PPM is respectively larger and mid-packet        */
     /* compensation is required. Set to <1> for SGMII               */
     /* 10/100/1000 modes. Otherwise, set to <0>. This               */
     /* configuration is shared for all GMII lanes. Per-lane         */
     /* qualification is done depending on the link speed, as        */
     /* dynamically determined by the AutoNeg. Same enable is        */
     /* shared by all GMII lanes.                                    */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD gmii_rx_mid_pkt_ppm_comp_en;

     /* GmiiRxIgnoreXmitIdle: If set, Rx PCS will ignore             */
     /* XMIT=IDLE, and will allow incoming packets to pass to Rx     */
     /* MAC. Set to <0> for standard behavior. Same enable is        */
     /* used by all SGMII lanes.                                     */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD gmii_rx_ignore_xmit_idle;

     /* GmiiRxMinPktLength: Rx minimal packet length. Packets        */
     /* shorter than this threshold (including 4B CRC) will be       */
     /* flagged with error indication and dropped in the RxMLF       */
     /* (if less than 32B) or in the Ingress. Same threshold is      */
     /* shared by all GMII lanes.                                    */
     /* range: 15:8, access type: RW, default value: 0x40            */
     SOC_PETRA_REG_FIELD gmii_rx_min_pkt_length;

     /* GmiiTxMinPktLength: Tx minimal packet length. Packets        */
     /* shorter than this threshold (not including the 4B CRC)       */
     /* will be padded with zeroes. The CRC-32 will be               */
     /* calculated on the entire packet (including the trailing      */
     /* zeroes). Same threshold is shared by all GMII lanes.         */
     /* range: 23:16, access type: RW, default value: 0x3c           */
     SOC_PETRA_REG_FIELD gmii_tx_min_pkt_length;

     /* GmiiTxIpgLength: Determines the IPG length (number of        */
     /* idle characters between packets). For standard 1GE links     */
     /* use default of <12> and minimum effective value of <5>       */
     /* (determined by standard Tx PCS FSM). 10/100MHz links may     */
     /* use lower values. Same value is shared by all GMII           */
     /* lanes.                                                       */
     /* range: 31:24, access type: RW, default value: 0xc            */
     SOC_PETRA_REG_FIELD gmii_tx_ipg_length;

  } __ATTRIBUTE_PACKED__ gmii_config1_reg;

  /* GMII Config2: GMII Configurations for IEEE 1000Base-X          */
  /* and SGMII modes.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5237 */

     /* AnNumClksIn100us: Number of RxClk cycles in 100 us minus     */
     /* 1. Used by SGMII AutoNeg process to calibrate the link       */
     /* timer. Default for 1GE (RxClk of 125 MHz) is 12,500-1.       */
     /* For 4GE (500 MHz RxClk) use 50,000-1. Same value is used     */
     /* by all GMII AN functions.                                    */
     /* range: 15:0, access type: RW, default value: 16'd12499       */
     SOC_PETRA_REG_FIELD an_num_clks_in100us;

  } __ATTRIBUTE_PACKED__ gmii_config2_reg;

  /* Auto Neg Config[0..3]: GMII AutoNeg Configuration for          */
  /* ports [0..3].                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5238 */

     /* AN Enable: If set, enables AutoNegotiation. (Identical       */
     /* to register 0.12 in standard Management Registers.)          */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD an_enable;

     /* AN Restart: If set, force the AutoNeg FSM into AN_ENABLE     */
     /* state. AN FSM will remain in that state until this           */
     /* register is deasserted. This will cause the AN to            */
     /* restart.                                                     */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD an_restart;

     /* AN SgmiiPhyMode: If set, the link will work as an SGMII      */
     /* MAC which communicates with an external PHY device.          */
     /* Otherwise, the lane will act as a standard IEEE              */
     /* 1000-Base-X 1G Ethernet MAC/PHY and connect directly to      */
     /* the fiber.                                                   */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD an_sgmii_phy_mode;

     /* AN RestartOnRudiInvalid: If set, AutoNeg function will       */
     /* restart on reception of RUDI(INVALID).                       */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD an_restart_on_rudi_invalid;

     /* AN_XMIT_Ovrd: Reserved (write as 111). Override the XMIT     */
     /* signal from AutoNegotiation process to Tx PCS: [001]         */
     /* force XMIT = CONFIGURATION [010] force XMIT = IDLE [100]     */
     /* force XMIT = DATA [111] use XMIT default value from          */
     /* AutoNeg FSM (default) Other values are reserved.             */
     /* range: 6:4, access type: RW, default value: 0x7              */
     SOC_PETRA_REG_FIELD an_xmit_ovrd;

     /* AN_LinkSpeedOvrd: Reserved (write as 111). Override the      */
     /* Link Speed signal from AutoNegotiation process to Rx/Tx      */
     /* MACs: [001] force Link Speed = 10MB [010] force Link         */
     /* Speed = 100MB [100] force Link Speed = 1000MB (1GE)          */
     /* [111] use Link Speed default value from AutoNeg FSM          */
     /* (default) Other values are reserved.                         */
     /* range: 10:8, access type: RW, default value: 0x7             */
     SOC_PETRA_REG_FIELD an_link_speed_ovrd;

     /* AN_LP_PauseOvrd: Reserved (write as 00). Override the        */
     /* Link Partner (LP) Pause capability signal from               */
     /* AutoNegotiation process to Tx MACs: [00] use value from      */
     /* AutoNeg FSM (taken from Rx_CFG_Reg) [01] reserved [10]       */
     /* force LP_Pause to 0 (incapable) [11] force LP_Pause to 1     */
     /* (capable)                                                    */
     /* range: 13:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_lp_pause_ovrd;

     /* AN_TxFsmZeroEn: Reserved (set to 1).                         */
     /* range: 14:14, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD an_tx_fsm_zero_en;

     /* AN TxCfgReg: Auto Neg advertised capabilities register       */
     /* (Tx_CFG_Reg).                                                */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_tx_cfg_reg;

  } __ATTRIBUTE_PACKED__ auto_neg_config_reg[SOC_PB_NIF_REGS_AUTO_NEG_CONFIG_REG_ARRAY_SIZE];

  /* Auto Neg Status[0..3]: GMII AutoNeg Status register for        */
  /* ports [0..3].                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5239 */

     /* AN Complete: If set, indicates that AutoNeg process is       */
     /* complete.                                                    */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD an_complete;

     /* AN LinkStatus: If set, indicates that AutoNegotiation        */
     /* process reached FSM_LINK_OK State. For SGMII, this also      */
     /* indicates that PHY is reporting that the remote (media)      */
     /* link status is 1 (link OK), as reflected by                  */
     /* Rx_CFG_Reg[15].                                              */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD an_link_status;

     /* AN RemoteFault: If set, indicates that received fault        */
     /* indication from link partner. In 1000Base-X mode,            */
     /* indication reflects RF1 and RF2 in Rx_CFG_Reg. In SGMII      */
     /* PHY mode, indication is received from PHY and reflect        */
     /* status of the remote (media) link.                           */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD an_remote_fault;

     /* AN Error: If set, indicates that Auto Neg function           */
     /* completed with error, i.e., capabilities could not be        */
     /* matched. This may be the result of Half-Duplex link          */
     /* partner.                                                     */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD an_error;

     /* AN FSM Restart: If set, indicates AN FSM was in the          */
     /* AN_RESTART state. This register is clear on read.            */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD an_fsm_restart;

     /* AN_FSM_CompleteAck: If set, indicates AN FSM was in the      */
     /* COMPLETE_ACKNOWLEDGE state. This is equivalent for           */
     /* mr_page_rx indicating a page was loaded. This register       */
     /* is clear on read.                                            */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD an_fsm_complete_ack;

     /* AN FSM IdleDetect: If set, indicates AN FSM was in the       */
     /* IDLE_DETECT state. This register is clear on read.           */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD an_fsm_idle_detect;

     /* AN XMIT: Indicate the XMIT signal from AutoNegotiation       */
     /* process to Tx PCS: [001] XMIT = CONFIGURATION [010] XMIT     */
     /* = IDLE [100] XMIT = DATA Any other value is reserved.        */
     /* range: 10:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD an_xmit;

     /* AN FSM State: Reserved.                                      */
     /* range: 14:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_fsm_state;

     /* AN RxCfgReg: Indicates the Link Partners advertised          */
     /* capabilities register as received by the AutoNeg             */
     /* function (rx_cfg_reg).                                       */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_rx_cfg_reg;

     /* Part of AN RxCfgReg: for SGMII */
     /* 1: link-up, 0: link-down */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_rx_cfg_sgmii_link_up;
     
     /* Part of AN RxCfgReg: for SGMII */
     /* 1: link-up, 0: link-down */
     /* range: 28:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD an_rx_cfg_1000b_x_rf_type;

  } __ATTRIBUTE_PACKED__ auto_neg_status_reg[SOC_PB_NIF_REGS_AUTO_NEG_STATUS_REG_ARRAY_SIZE];

} __ATTRIBUTE_PACKED__ SOC_PB_NIF_MAC_LANE_REGS;
/* Block definition: NBI */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a00 */

     /* TxFifoOverflowInt: This interrupt indicates that an          */
     /* overflow has occurred in one of the tx FIFOs.                */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_fifo_overflow_int;

     /* RxFifoOverflowInt: This interrupt indicates that an          */
     /* overflow has occurred in one of the rx FIFOs (including      */
     /* ILKN RX ports). In order to clear the ports in overflow      */
     /* should be read (RxMlfStatus or IlknRxControllerStatus)       */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_fifo_overflow_int;

     /* IlegalIlknInputFromRx0Int: Illegal ILKN input from RX0       */
     /* (core A).                                                    */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilegal_ilkn_input_from_rx0_int;

     /* IlegalIlknInputFromRx1Int: Illegal ILKN input from RX1       */
     /* (core B).                                                    */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilegal_ilkn_input_from_rx1_int;

     /* ErrBitsFromEgqInt: Indicates the error bit from the EGQ      */
     /* is not 0.                                                    */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD err_bits_from_egq_int;

     /* WrongMalgWordInt: Indicates the MALG transmitted a word      */
     /* which is not 8B and not EOB.                                 */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wrong_malg_word_int;

     /* WrongEgqWordInt: Indicates the EGQ transmitted a word        */
     /* which is not 128B and not EOB.                               */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wrong_egq_word_int;

     /* WrongPortFromEgqInt: Indicates the EGQ transmitted data      */
     /* to an invalid port (for example, port 1 in xaui)             */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wrong_port_from_egq_int;

     /* RxPortDiscardedPacketInt: One of the RX NIF ports had        */
     /* thrown a packet due to the "DiscardTooShortErrorPkts"        */
     /* mechanism.                                                   */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_port_discarded_packet_int;

     /* RxNumThrownEopsInt: Indicates some packets were thrown       */
     /* in the NBI RX. In order to know the exact number or to       */
     /* clear this bit the counter RxNumThrownEops should be         */
     /* read.                                                        */
     /* range: 9:9, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_num_thrown_eops_int;

     /* RxNumThrownEops 75pInt: Indicates the counter                */
     /* RxNumThrownEops has reached 75% of its range. In order       */
     /* to clear the counter should be read.                         */
     /* range: 10:10, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_num_thrown_eops_75p_int;

     /* StatInterrupt: Indicates one of the interrupts of the        */
     /* statistics block is asserted.                                */
     /* range: 11:11, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_interrupt;

     /* IlknInterrupt: Indicates one of the interrupts of the        */
     /* Interlaken core is asserted.                                 */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_interrupt;

     /* NbiThrownBurstsCounters0 75pInterrupt: Indicates one of      */
     /* the counter of ports 0-31 has reached 75% of its range.      */
     /* In order to know which port or to clear interrupt            */
     /* register NbiThrownBurstsCounters0_75pInterruptRegister       */
     /* should be read.                                              */
     /* range: 13:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD nbi_thrown_bursts_counters0_75p_interrupt;

     /* NbiThrownBurstsCounters1 75pInterrupt: Indicates one of      */
     /* the counter of ports 32-63 has reached 75% of its range.     */
     /* In order to know which port or to clear interrupt            */
     /* register NbiThrownBurstsCounters1_75pInterruptRegister       */
     /* should be read.                                              */
     /* range: 14:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD nbi_thrown_bursts_counters1_75p_interrupt;

     /* IlknTx0EccErr0Int: Indicates a memory ECC error was          */
     /* detected and fixed on ILKN-0 Tx memories.                    */
     /* range: 17:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx0_ecc_err0_int;

     /* IlknTx0EccErr1Int: Indicates a memory ECC error was          */
     /* detected and could not be fixed on ILKN-0 Tx memories.       */
     /* Such errors may require to reset the ILKN Tx path.           */
     /* range: 20:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx0_ecc_err1_int;

     /* IlknTx1EccErr0Int: Indicates a memory ECC error was          */
     /* detected and fixed on ILKN-1 Tx memories.                    */
     /* range: 22:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx1_ecc_err0_int;

     /* IlknTx1EccErr1Int: Indicates a memory ECC error was          */
     /* detected and could not be fixed on ILKN-1 Tx memories.       */
     /* Such errors may require to reset the ILKN Tx path.           */
     /* range: 24:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx1_ecc_err1_int;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Stat Interrupt Register: This register contains the            */
  /* interrupt sources residing in the Statistics unit.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a01 */

     /* StatReadErrInt: Read error interrupt will be set when:       */
     /* 1. A CPU read request is received during reset sequence      */
     /* 2. A CPU read request is received before previous read       */
     /* was dispatched 3. A CPU read request is received for an      */
     /* invalid counter or invalid port                              */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_read_err_int;

     /* StatRxFrameErrInt: Frame errors detected on NIF2IRE bus      */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_rx_frame_err_int;

     /* StatTxFrameErrInt: Frame errors detected on EGQ2NIF bus      */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_tx_frame_err_int;

     /* StatRxBurstLengthOverflowInt: If set, indicates a packet     */
     /* bigger than 16384B on NIF2IRE interface                      */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_rx_burst_length_overflow_int;

     /* StatTxBurstLengthOverflowInt: If set, indicates a packet     */
     /* bigger than 16384B on EGQ2NIF interface                      */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_tx_burst_length_overflow_int;

     /* StatCnt75pPort0 31: Indicates one of the port counters       */
     /* reached 75% of its max.                                      */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_cnt75p_port0_31;

     /* StatCnt75pPort32 63: Indicates one of the port counters      */
     /* reached 75% of its max.                                      */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_cnt75p_port32_63;

  } __ATTRIBUTE_PACKED__ stat_interrupt_reg;

  /* Stat Cnt75p Port0 31 Interrupt: This register contains         */
  /* interrupts indicating the port counters of ports 0-31          */
  /* reached 75% of their max.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a02 */

     /* StatCnt75pPort0 31Int: Indicates whether the port            */
     /* counters of ports 0-31 reached 75% of its max.               */
     /* range: 31:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_cnt75p_port0_31_int;

  } __ATTRIBUTE_PACKED__ stat_cnt75p_port0_31_interrupt_reg;

  /* Stat Cnt75p Port32 63 Interrupt: This register contains        */
  /* interrupts indicating the port counters of ports 32-63         */
  /* reached 75% of their max.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a03 */

     /* StatCnt75pPort32 63Int: Indicates whether the port           */
     /* counters of ports 32-63 reached 75% of its max.              */
     /* range: 31:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_cnt75p_port32_63_int;

  } __ATTRIBUTE_PACKED__ stat_cnt75p_port32_63_interrupt_reg;

  /* Ilkn Interrupt Register: This register contains                */
  /* interrupts relating to the Interlaken.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a04 */

     /* IlknRxPort0StatusChangeInt: Indicates there has been a       */
     /* change in the alignment of this port.                        */
     /* range: 0:0, access type: RC, default value: 0x0              */
     /* IlknRxPort1StatusChangeInt: Indicates there has been a       */
     /* change in the alignment of this port.                        */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx_port_status_change_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknLinkPartnerStatusChangeLanes0 11Int: Indicates there     */
     /* has been a change in the interface status of the link        */
     /* partner. We receive this indication from bit 33 in the       */
     /* diagword, according to the Interlaken protocol.              */
     /* range: 2:2, access type: RC, default value: 0x0              */
     /* IlknLinkPartnerStatusChangeLanes12 23Int: Indicates          */
     /* there has been a change in the interface status of the       */
     /* link partner. We receive this indication from bit 33 in      */
     /* the diagword, according to the Interlaken protocol.          */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_link_partner_status_change_lanes_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknRxPort0AlignErrInt: Indicates the lane alignment         */
     /* failed after several attempts, or lane alignment was         */
     /* lost.                                                        */
     /* range: 4:4, access type: RC, default value: 0x0              */
     /* IlknRxPort1AlignErrInt: Indicates the lane alignment         */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx_port_align_err_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknCrc32LaneErrIndicationLanes0 11Int: Indicates that       */
     /* the CRC32 in the most recently received Diagnostic Word      */
     /* for the respective lane is not as expected.                  */
     /* range: 6:6, access type: RC, default value: 0x0              */
     /* IlknCrc32LaneErrIndicationLanes12 23Int: Indicates that      */
     /* the CRC32 in the most recently received Diagnostic Word      */
     /* for the respective lane is not as expected.                  */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_crc32_lane_err_indication_lanes_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknLaneSynchErrLanes0 11Int: Indicates one of the           */
     /* following: 64B/67B Word Boundary Lock with Framing bits      */
     /* [65:64] was not achieved OR errors were detected on          */
     /* Framing bits [65:64] after synchronization OR a Meta         */
     /* Frame Synchronization Word was never correctly receive       */
     /* range: 8:8, access type: RC, default value: 0x0              */
     /* IlknLaneSynchErrLanes12 23Int: Indicates one of the          */
     /* following: 64B/67B Word Boundary Lock with Framing bits      */
     /* [65:64] was not achieved OR errors were detected on          */
     /* Framing bits [65:64] after synchronization OR a Meta         */
     /* Frame Synchronization Word was never correctly receive       */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_lane_synch_err_lanes_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknLaneFramingErrLanes0 11Int: Indicates an illegal         */
     /* framing pattern was detected in the respective lane          */
     /* after being Word Boundary Synchronized.                      */
     /* range: 10:10, access type: RC, default value: 0x0            */
     /* IlknLaneFramingErrLanes12 23Int: Indicates an illegal        */
     /* framing pattern was detected in the respective lane          */
     /* after being Word Boundary Synchronized.                      */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_framing_err_lanes_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknLaneBadFramingTypeErrLanes0 11Int: Indicates an          */
     /* illegal framing layer block type was detected.               */
     /* range: 12:12, access type: RC, default value: 0x0            */
     /* IlknLaneBadFramingTypeErrLanes12 23Int: Indicates an         */
     /* illegal framing layer block type was detected.               */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_bad_framing_type_err_lanes_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknLaneMetaFrameSyncWordErrLanes0 11Int: Indicates the      */
     /* Meta Frame Synchronization Word in the respective lane       */
     /* contained an error.                                          */
     /* range: 14:14, access type: RC, default value: 0x0            */
     /* IlknLaneMetaFrameSyncWordErrLanes12 23Int: Indicates the     */
     /* Meta Frame Synchronization Word in the respective lane       */
     /* contained an error.                                          */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_meta_frame_sync_word_err_lanes_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknLaneScramblerStateErrLanes0 11Int: Indicates the         */
     /* Scrambler State Control Word in the respective lane          */
     /* contained an error.                                          */
     /* range: 16:16, access type: RC, default value: 0x0            */
     /* IlknLaneScramblerStateErrLanes12 23Int: Indicates the        */
     /* Scrambler State Control Word in the respective lane          */
     /* contained an error.                                          */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_scrambler_state_err_lanes_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknLaneMetaFrameLengthErrLanes0 11Int: Indicates the        */
     /* length of the Meta Frame being received in the               */
     /* respective lane is different from the expected length.       */
     /* range: 18:18, access type: RC, default value: 0x0            */
     /* IlknLaneMetaFrameLengthErrLanes12 23Int: Indicates the       */
     /* length of the Meta Frame being received in the               */
     /* respective lane is different from the expected length.       */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_meta_frame_length_err_lanes_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknLaneMetaFrameRepeatErrLanes0 11Int: Indicates one or     */
     /* more of the following occurred on the respective lane: -     */
     /* four consecutive Meta Frame Synchronization Words            */
     /* contained errors - three consecutive Scrambler State         */
     /* Control Words contained errors                               */
     /* range: 20:20, access type: RC, default value: 0x0            */
     /* IlknLaneMetaFrameRepeatErrLanes12 23Int: Indicates one       */
     /* or more of the following occurred on the respective          */
     /* lane: - four consecutive Meta Frame Synchronization          */
     /* Words contained errors - three consecutive Scrambler         */
     /* State Control Words contained errors                         */
     /* range: 21:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_meta_frame_repeat_err_lanes_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknRxParityErrInt: Parity error in one of the RX lanes      */
     /* / ports.                                                     */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx_parity_err_int;

     /* IlknTxParityErrInt: Parity error in one of the RX lanes      */
     /* / ports.                                                     */
     /* range: 23:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx_parity_err_int;

     /* IlknRxPort0StatusErrInt: Indicates one of the errors in      */
     /* RxIlknStatus0 has occurred.                                  */
     /* range: 24:24, access type: RC, default value: 0x0            */
     /* IlknRxPort1StatusErrInt: Indicates one of the errors in      */
     /* RxIlknStatus1 has occurred.                                  */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx_port_status_err_int[SOC_PB_REG_NOF_ILKNS];

     /* IlknTxPort0StatusErrInt: Indicates one of the errors in      */
     /* TxIlknStatus0 has occurred.                                  */
     /* range: 26:26, access type: RC, default value: 0x0            */
     /* IlknTxPort1StatusErrInt: Indicates one of the errors in      */
     /* TxIlknStatus1 has occurred.                                  */
     /* range: 27:27, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx_port_status_err_int[SOC_PB_REG_NOF_ILKNS];
  } __ATTRIBUTE_PACKED__ ilkn_interrupt_reg;

  /* Nbi Thrown Bursts Counters0 75p Interrupt Register:            */
  /* Indicates one of the counter of ports 0-31 has reached         */
  /* 75% of its range. In order to clear the relevant counter       */
  /* should be read.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a05 */

     /* NumThrownBurstsCounter 75pRx0Port0Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx0_port0_int;

     /* NumThrownBurstsCounter 75pRx0Port1Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx0_port1_int;

     /* NumThrownBurstsCounter 75pRx0Port2Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx0_port2_int;

     /* NumThrownBurstsCounter 75pRx0Port3Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx0_port3_int;

     /* NumThrownBurstsCounter 75pRx1Port0Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx1_port0_int;

     /* NumThrownBurstsCounter 75pRx1Port1Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx1_port1_int;

     /* NumThrownBurstsCounter 75pRx1Port2Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx1_port2_int;

     /* NumThrownBurstsCounter 75pRx1Port3Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx1_port3_int;

     /* NumThrownBurstsCounter 75pRx2Port0Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx2_port0_int;

     /* NumThrownBurstsCounter 75pRx2Port1Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 9:9, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx2_port1_int;

     /* NumThrownBurstsCounter 75pRx2Port2Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 10:10, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx2_port2_int;

     /* NumThrownBurstsCounter 75pRx2Port3Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 11:11, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx2_port3_int;

     /* NumThrownBurstsCounter 75pRx3Port0Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx3_port0_int;

     /* NumThrownBurstsCounter 75pRx3Port1Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 13:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx3_port1_int;

     /* NumThrownBurstsCounter 75pRx3Port2Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 14:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx3_port2_int;

     /* NumThrownBurstsCounter 75pRx3Port3Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx3_port3_int;

     /* NumThrownBurstsCounter 75pRx4Port0Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx4_port0_int;

     /* NumThrownBurstsCounter 75pRx4Port1Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 17:17, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx4_port1_int;

     /* NumThrownBurstsCounter 75pRx4Port2Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 18:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx4_port2_int;

     /* NumThrownBurstsCounter 75pRx4Port3Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 19:19, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx4_port3_int;

     /* NumThrownBurstsCounter 75pRx5Port0Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx5_port0_int;

     /* NumThrownBurstsCounter 75pRx5Port1Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 21:21, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx5_port1_int;

     /* NumThrownBurstsCounter 75pRx5Port2Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 22:22, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx5_port2_int;

     /* NumThrownBurstsCounter 75pRx5Port3Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 23:23, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx5_port3_int;

     /* NumThrownBurstsCounter 75pRx6Port0Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 24:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx6_port0_int;

     /* NumThrownBurstsCounter 75pRx6Port1Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 25:25, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx6_port1_int;

     /* NumThrownBurstsCounter 75pRx6Port2Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 26:26, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx6_port2_int;

     /* NumThrownBurstsCounter 75pRx6Port3Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 27:27, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx6_port3_int;

     /* NumThrownBurstsCounter 75pRx7Port0Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx7_port0_int;

     /* NumThrownBurstsCounter 75pRx7Port1Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 29:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx7_port1_int;

     /* NumThrownBurstsCounter 75pRx7Port2Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 30:30, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx7_port2_int;

     /* NumThrownBurstsCounter 75pRx7Port3Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx7_port3_int;

  } __ATTRIBUTE_PACKED__ nbi_thrown_bursts_counters0_75p_interrupt_reg;

  /* Nbi Thrown Bursts Counters1 75p Interrupt Register:            */
  /* Indicates one of the counter of ports 32-63 has reached        */
  /* 75% of its range. In order to clear the relevant counter       */
  /* should be read.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a06 */

     /* NumThrownBurstsCounter 75pRx8Port0Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx8_port0_int;

     /* NumThrownBurstsCounter 75pRx8Port1Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx8_port1_int;

     /* NumThrownBurstsCounter 75pRx8Port2Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx8_port2_int;

     /* NumThrownBurstsCounter 75pRx8Port3Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx8_port3_int;

     /* NumThrownBurstsCounter 75pRx9Port0Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx9_port0_int;

     /* NumThrownBurstsCounter 75pRx9Port1Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx9_port1_int;

     /* NumThrownBurstsCounter 75pRx9Port2Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx9_port2_int;

     /* NumThrownBurstsCounter 75pRx9Port3Int: Indicates the         */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx9_port3_int;

     /* NumThrownBurstsCounter 75pRx10Port0Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx10_port0_int;

     /* NumThrownBurstsCounter 75pRx10Port1Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 9:9, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx10_port1_int;

     /* NumThrownBurstsCounter 75pRx10Port2Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 10:10, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx10_port2_int;

     /* NumThrownBurstsCounter 75pRx10Port3Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 11:11, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx10_port3_int;

     /* NumThrownBurstsCounter 75pRx11Port0Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx11_port0_int;

     /* NumThrownBurstsCounter 75pRx11Port1Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 13:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx11_port1_int;

     /* NumThrownBurstsCounter 75pRx11Port2Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 14:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx11_port2_int;

     /* NumThrownBurstsCounter 75pRx11Port3Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx11_port3_int;

     /* NumThrownBurstsCounter 75pRx12Port0Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx12_port0_int;

     /* NumThrownBurstsCounter 75pRx12Port1Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 17:17, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx12_port1_int;

     /* NumThrownBurstsCounter 75pRx12Port2Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 18:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx12_port2_int;

     /* NumThrownBurstsCounter 75pRx12Port3Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 19:19, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx12_port3_int;

     /* NumThrownBurstsCounter 75pRx13Port0Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx13_port0_int;

     /* NumThrownBurstsCounter 75pRx13Port1Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 21:21, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx13_port1_int;

     /* NumThrownBurstsCounter 75pRx13Port2Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 22:22, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx13_port2_int;

     /* NumThrownBurstsCounter 75pRx13Port3Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 23:23, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx13_port3_int;

     /* NumThrownBurstsCounter 75pRx14Port0Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 24:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx14_port0_int;

     /* NumThrownBurstsCounter 75pRx14Port1Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 25:25, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx14_port1_int;

     /* NumThrownBurstsCounter 75pRx14Port2Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 26:26, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx14_port2_int;

     /* NumThrownBurstsCounter 75pRx14Port3Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 27:27, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx14_port3_int;

     /* NumThrownBurstsCounter 75pRx15Port0Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx15_port0_int;

     /* NumThrownBurstsCounter 75pRx15Port1Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 29:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx15_port1_int;

     /* NumThrownBurstsCounter 75pRx15Port2Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 30:30, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx15_port2_int;

     /* NumThrownBurstsCounter 75pRx15Port3Int: Indicates the        */
     /* cosponding NumThrownBurstsCounterRx<>Port<> counter has      */
     /* reached 75% of its range.                                    */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_75p_rx15_port3_int;

  } __ATTRIBUTE_PACKED__ nbi_thrown_bursts_counters1_75p_interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a10 */

     /* TxFifoOverflowIntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tx_fifo_overflow_int_mask;

     /* RxFifoOverflowIntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_fifo_overflow_int_mask;

     /* IlegalIlknInputFromRx0IntMask: Writing 0 masks the           */
     /* corresponding interrupt source.                              */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilegal_ilkn_input_from_rx0_int_mask;

     /* IlegalIlknInputFromRx1IntMask: Writing 0 masks the           */
     /* corresponding interrupt source.                              */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilegal_ilkn_input_from_rx1_int_mask;

     /* ErrBitsFromEgqIntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD err_bits_from_egq_int_mask;

     /* WrongMalgWordIntMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wrong_malg_word_int_mask;

     /* WrongEgqWordIntMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wrong_egq_word_int_mask;

     /* WrongPortFromEgqIntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wrong_port_from_egq_int_mask;

     /* RxPortDiscardedPacketIntMask: Writing 0 masks the            */
     /* corresponding interrupt source.                              */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_port_discarded_packet_int_mask;

     /* RxNumThrownEopsIntMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_num_thrown_eops_int_mask;

     /* RxNumThrownEops_75pIntMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_num_thrown_eops_75p_int_mask;

     /* StatInterruptMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_interrupt_mask;

     /* IlknInterruptMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_interrupt_mask;

     /* NbiThrownBurstsCounters0_75pInterruptMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nbi_thrown_bursts_counters0_75p_interrupt_mask;

     /* NbiThrownBurstsCounters1_75pInterruptMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nbi_thrown_bursts_counters1_75p_interrupt_mask;

     /* IlknTx0EccErr0IntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 17:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx0_ecc_err0_int_mask;

     /* IlknTx0EccErr1IntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 20:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx0_ecc_err1_int_mask;

     /* IlknTx1EccErr0IntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 22:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx1_ecc_err0_int_mask;

     /* IlknTx1EccErr1IntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 24:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx1_ecc_err1_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Stat Interrupt Mask Register: Each bit in this register        */
  /* corresponds to an interrupt source in the                      */
  /* StatInterruptRegister. The interrupt source is masked by       */
  /* writing 0 to the relevant bit in this register.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a11 */

     /* StatReadErrIntMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_read_err_int_mask;

     /* StatRxFrameErrIntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_rx_frame_err_int_mask;

     /* StatTxFrameErrIntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_tx_frame_err_int_mask;

     /* StatRxBurstLengthOverflowIntMask: Writing 0 masks the        */
     /* corresponding interrupt source.                              */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_rx_burst_length_overflow_int_mask;

     /* StatTxBurstLengthOverflowIntMask: Writing 0 masks the        */
     /* corresponding interrupt source.                              */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_tx_burst_length_overflow_int_mask;

     /* StatCnt75pPort0 31Mask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_cnt75p_port0_31_mask;

     /* StatCnt75pPort32 63Mask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_cnt75p_port32_63_mask;

  } __ATTRIBUTE_PACKED__ stat_interrupt_mask_reg;

  /* Stat Cnt75p Port0 31 Int Mask Register: Each bit in this       */
  /* register corresponds to an interrupt source in the             */
  /* StatCnt75pPort0_31Int. The interrupt source is masked by       */
  /* writing 0 to the relevant bit in this register.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a12 */

     /* StatCnt75pPort0 31IntMask: Writing 0 masks the               */
     /* corresponding interrupt source.                              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_cnt75p_port0_31_int_mask;

  } __ATTRIBUTE_PACKED__ stat_cnt75p_port0_31_int_mask_reg;

  /* Stat Cnt75p Port32 63 Int Mask Register: Each bit in           */
  /* this register corresponds to an interrupt source in the        */
  /* StatCnt75pPort32_63Int. The interrupt source is masked         */
  /* by writing 0 to the relevant bit in this register.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a13 */

     /* StatCnt75pPort32 63IntMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_cnt75p_port32_63_int_mask;

  } __ATTRIBUTE_PACKED__ stat_cnt75p_port32_63_int_mask_reg;

  /* Ilkn Interrupt Mask Register: Each bit in this register        */
  /* corresponds to an interrupt source in the IlknInterrupt.       */
  /* The interrupt source is masked by writing 0 to the             */
  /* relevant bit in this register.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a14 */

     /* range: 0:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx_port_status_change_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* range: 2:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_link_partner_status_change_lanes_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* range: 4:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx_port_align_err_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* range: 6:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_crc32_lane_err_indication_lanes_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* range: 8:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_lane_synch_err_lanes_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* range: 10:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_framing_err_lanes_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* range: 12:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_bad_framing_type_err_lanes_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* range: 14:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_meta_frame_sync_word_err_lanes_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* range: 16:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_scrambler_state_err_lanes_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* range: 18:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_meta_frame_length_err_lanes_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* range: 20:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_lane_meta_frame_repeat_err_lanes_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* IlknRxParityErrInt: Parity error in one of the RX lanes      */
     /* / ports.                                                     */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx_parity_err_int_mask;

     /* IlknTxParityErrInt: Parity error in one of the RX lanes      */
     /* / ports.                                                     */
     /* range: 23:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx_parity_err_int_mask;

     /* range: 24:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx_port_status_err_int_mask[SOC_PB_REG_NOF_ILKNS];

     /* range: 26:27, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx_port_status_err_int_mask[SOC_PB_REG_NOF_ILKNS];

  } __ATTRIBUTE_PACKED__ ilkn_interrupt_mask_reg;

  /* Nbi Thrown Bursts Counters0 75p Interrupt Mask Register:       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a15 */

     /* NumThrownBurstsCounter75pRx0Port0IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx0_port0_int_mask;

     /* NumThrownBurstsCounter75pRx0Port1IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx0_port1_int_mask;

     /* NumThrownBurstsCounter75pRx0Port2IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx0_port2_int_mask;

     /* NumThrownBurstsCounter75pRx0Port3IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx0_port3_int_mask;

     /* NumThrownBurstsCounter75pRx1Port0IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx1_port0_int_mask;

     /* NumThrownBurstsCounter75pRx1Port1IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx1_port1_int_mask;

     /* NumThrownBurstsCounter75pRx1Port2IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx1_port2_int_mask;

     /* NumThrownBurstsCounter75pRx1Port3IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx1_port3_int_mask;

     /* NumThrownBurstsCounter75pRx2Port0IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx2_port0_int_mask;

     /* NumThrownBurstsCounter75pRx2Port1IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx2_port1_int_mask;

     /* NumThrownBurstsCounter75pRx2Port2IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx2_port2_int_mask;

     /* NumThrownBurstsCounter75pRx2Port3IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx2_port3_int_mask;

     /* NumThrownBurstsCounter75pRx3Port0IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx3_port0_int_mask;

     /* NumThrownBurstsCounter75pRx3Port1IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx3_port1_int_mask;

     /* NumThrownBurstsCounter75pRx3Port2IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx3_port2_int_mask;

     /* NumThrownBurstsCounter75pRx3Port3IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx3_port3_int_mask;

     /* NumThrownBurstsCounter75pRx4Port0IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx4_port0_int_mask;

     /* NumThrownBurstsCounter75pRx4Port1IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx4_port1_int_mask;

     /* NumThrownBurstsCounter75pRx4Port2IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx4_port2_int_mask;

     /* NumThrownBurstsCounter75pRx4Port3IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx4_port3_int_mask;

     /* NumThrownBurstsCounter75pRx5Port0IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx5_port0_int_mask;

     /* NumThrownBurstsCounter75pRx5Port1IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx5_port1_int_mask;

     /* NumThrownBurstsCounter75pRx5Port2IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx5_port2_int_mask;

     /* NumThrownBurstsCounter75pRx5Port3IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx5_port3_int_mask;

     /* NumThrownBurstsCounter75pRx6Port0IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx6_port0_int_mask;

     /* NumThrownBurstsCounter75pRx6Port1IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx6_port1_int_mask;

     /* NumThrownBurstsCounter75pRx6Port2IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx6_port2_int_mask;

     /* NumThrownBurstsCounter75pRx6Port3IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx6_port3_int_mask;

     /* NumThrownBurstsCounter75pRx7Port0IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx7_port0_int_mask;

     /* NumThrownBurstsCounter75pRx7Port1IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx7_port1_int_mask;

     /* NumThrownBurstsCounter75pRx7Port2IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx7_port2_int_mask;

     /* NumThrownBurstsCounter75pRx7Port3IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx7_port3_int_mask;

  } __ATTRIBUTE_PACKED__ nbi_thrown_bursts_counters0_75p_interrupt_mask_reg;

  /* Nbi Thrown Bursts Counters1 75p Interrupt Mask Register:       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a16 */

     /* NumThrownBurstsCounter75pRx8Port0IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx8_port0_int_mask;

     /* NumThrownBurstsCounter75pRx8Port1IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx8_port1_int_mask;

     /* NumThrownBurstsCounter75pRx8Port2IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx8_port2_int_mask;

     /* NumThrownBurstsCounter75pRx8Port3IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx8_port3_int_mask;

     /* NumThrownBurstsCounter75pRx9Port0IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx9_port0_int_mask;

     /* NumThrownBurstsCounter75pRx9Port1IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx9_port1_int_mask;

     /* NumThrownBurstsCounter75pRx9Port2IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx9_port2_int_mask;

     /* NumThrownBurstsCounter75pRx9Port3IntMask: Writing 0          */
     /* masks the corresponding interrupt source.                    */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx9_port3_int_mask;

     /* NumThrownBurstsCounter75pRx10Port0IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx10_port0_int_mask;

     /* NumThrownBurstsCounter75pRx10Port1IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx10_port1_int_mask;

     /* NumThrownBurstsCounter75pRx10Port2IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx10_port2_int_mask;

     /* NumThrownBurstsCounter75pRx10Port3IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx10_port3_int_mask;

     /* NumThrownBurstsCounter75pRx11Port0IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx11_port0_int_mask;

     /* NumThrownBurstsCounter75pRx11Port1IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx11_port1_int_mask;

     /* NumThrownBurstsCounter75pRx11Port2IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx11_port2_int_mask;

     /* NumThrownBurstsCounter75pRx11Port3IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx11_port3_int_mask;

     /* NumThrownBurstsCounter75pRx12Port0IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx12_port0_int_mask;

     /* NumThrownBurstsCounter75pRx12Port1IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx12_port1_int_mask;

     /* NumThrownBurstsCounter75pRx12Port2IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx12_port2_int_mask;

     /* NumThrownBurstsCounter75pRx12Port3IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx12_port3_int_mask;

     /* NumThrownBurstsCounter75pRx13Port0IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx13_port0_int_mask;

     /* NumThrownBurstsCounter75pRx13Port1IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx13_port1_int_mask;

     /* NumThrownBurstsCounter75pRx13Port2IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx13_port2_int_mask;

     /* NumThrownBurstsCounter75pRx13Port3IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx13_port3_int_mask;

     /* NumThrownBurstsCounter75pRx14Port0IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx14_port0_int_mask;

     /* NumThrownBurstsCounter75pRx14Port1IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx14_port1_int_mask;

     /* NumThrownBurstsCounter75pRx14Port2IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx14_port2_int_mask;

     /* NumThrownBurstsCounter75pRx14Port3IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx14_port3_int_mask;

     /* NumThrownBurstsCounter75pRx15Port0IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx15_port0_int_mask;

     /* NumThrownBurstsCounter75pRx15Port1IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx15_port1_int_mask;

     /* NumThrownBurstsCounter75pRx15Port2IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx15_port2_int_mask;

     /* NumThrownBurstsCounter75pRx15Port3IntMask: Writing 0         */
     /* masks the corresponding interrupt source.                    */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter75p_rx15_port3_int_mask;

  } __ATTRIBUTE_PACKED__ nbi_thrown_bursts_counters1_75p_interrupt_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a20 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_NBI_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a30 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_NBI_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a40 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically set          */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address-             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a41 */

     /* IndirectCommandAddr: Indirect access address- Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0:          */
     /* Write operation. 1: Read operation.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a42 */

     /* IndirectCommandDataIncrement:                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_NBI_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* Gtimer Configuration: NBI Global Timer to enable counter       */
  /* for a controlled interval (may be used for B/W                 */
  /* calculations).                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a58 */

     /* GtimerCycle: The number of clocks the gtimer will count.     */
     /* range: 29:0, access type: RW, default value: 30'd250_000_000 */
     SOC_PETRA_REG_FIELD gtimer_cycle;

     /* GtimerEnable: Whether to use all the counters in gtimer      */
     /* mode or read on clear                                        */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_enable;

     /* GtimerResetOnTrigger: If set, the gtimer will output a       */
     /* reset signal when the count begins.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_reset_on_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Gtimer Trigger:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a59 */

     /* GtimerTrigger: When this register is written to, the         */
     /* gtimer starts counting. When this register is read, it       */
     /* gives the status of the gtimer (1= still counting,           */
     /* 0=count is over).                                            */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_trigger_reg;

  /* Rx Mlf Reset Ports0to31: Rx MLF Reset.                         */
  /* Rx Mlf Reset Ports32to63: Rx MLF Reset.                        */
  /* Tx Mlf Reset Ports0to31: Tx MLF Reset.                         */
  /* Tx Mlf Reset Ports32to63: Tx MLF Reset.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a60 */ /* 0x4a61 (similar for 32-63)*/

     /* RxPorts0To31Srstn: Resets RX NIF ports 0-31 (NIF ports       */
     /* of MALG A). The reset is active low. Bit 0 for port 0;       */
     /* bit 31 for port 31. Note: corresponding ports should be      */
     /* configured before changing this reset.                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ports_srstn[SOC_PB_REG_NOF_NIFS_IN_MALG];

  } __ATTRIBUTE_PACKED__ mlf_reset_ports_reg[SOC_PB_REG_NOF_MALGS][SOC_PB_REG_NOF_NIF_DIRECTIONS];

  /* ILKNReset: ILKN Reset.                                         */
  /* The description for ILKN 0 is relevant also for ILKN 1,        */
  /* with the appropriate field offset                              */
  /* The second index is RX/TX                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a64 */

     /* IlknRx0PortRstn, IlknRx0PortRstn1:                           */
     /* Master reset for ILKN RX Port 0 (same for 1                  */
     /* (24-lanes port). This bit resets the Rx destriper and Rx     */
     /* lanes of port 0. This bit should be set to 1'b1 only         */
     /* after all the ILKN configurations and Serdeses are           */
     /* ready. This signal is active low.                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_port_rstn[SOC_PB_REG_NOF_ILKNS][SOC_PB_REG_NOF_NIF_DIRECTIONS];

     /* IlknRx0LbusRstn: Reserved (set to 1).                        */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ilkn_lbus_rstn[SOC_PB_REG_NOF_ILKNS][SOC_PB_REG_NOF_NIF_DIRECTIONS];

     /* IlknRx0LogicLanesRstn: Reserved (set to 1).                  */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ilkn_logic_lanes_rstn[SOC_PB_REG_NOF_ILKNS][SOC_PB_REG_NOF_NIF_DIRECTIONS];

     /* IlknTx0StriperRstn: Reserved (set to 1).                     */
     /* range: 12:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ilkn_tx_striper_rstn[SOC_PB_REG_NOF_ILKNS];

     /* IlknWrapRstn: Reserved (set to 1).                           */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ilkn_wrap_rstn;

     /* IlknRx0ControllerRstn: Reset signal for Rx ILKN FIFO         */
     /* controller 0 (24-lanes port). This signal is active low.     */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_controller_rstn[SOC_PB_REG_NOF_ILKNS][SOC_PB_REG_NOF_NIF_DIRECTIONS];
  } __ATTRIBUTE_PACKED__ ilknreset_reg;

  /* ILKNRx Lanes Reset: Debug register.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a65 */

     /* IlknRxLogicLaneRstn: Reserved (set to 0xffffff).             */
     /* range: 23:0, access type: RW, default value: 24'hFFFFFF      */
     SOC_PETRA_REG_FIELD ilkn_rx_logic_lane_rstn;

  } __ATTRIBUTE_PACKED__ ilknrx_lanes_reset_reg;

  /* ILKNTx Lanes Reset: Debug register.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a66 */

     /* IlknTxLogicLaneRstn: Reserved (set to 0xffffff).             */
     /* range: 23:0, access type: RW, default value: 24'hFFFFFF      */
     SOC_PETRA_REG_FIELD ilkn_tx_logic_lane_rstn;

  } __ATTRIBUTE_PACKED__ ilkntx_lanes_reset_reg;

  /* Rx Mlf Config[0..15]: Rx MAC Lane FIFO (MLF) [0..15]           */
  /* Configuration Register.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a70 */

     /* RxNumLogicalFifosMode: Indicates into how many logical       */
     /* FIFOs the 128 entries FIFO of 1 MLF are divided. 2'b00 -     */
     /* 4 FIFOs (for sgmii) (first entries are 0, 32, 64 and 96)     */
     /* 2'b01 - 2 FIFOs (for sgmii) (first entries are 0 and 64)     */
     /* 2'b10 - 1 FIFO (for xaui) This register has no meaning       */
     /* if enable Ilkn is set.                                       */
     /* range: 1:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD rx_num_logical_fifos_mode;

     /* RxEnableReq3: If set, the NIF ports in this MLF are          */
     /* allowed to set a request to read 3 segments from the         */
     /* round robin (towards the IRE).                               */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_enable_req3;

     /* RxDiscardTooShortErrPkts: If set, Rx MLF will discard        */
     /* packets that are 64B or less (excluding CRC) and flagged     */
     /* with error indication by the Rx MAC.                         */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_discard_too_short_err_pkts;

     /* RxEnsureDiscardInd: If set, Rx MLF will ensure               */
     /* indication of discarded packets (due to packet being too     */
     /* short) is always propagated to Ingress. This is done by      */
     /* flagging the next packet with error. Otherwise, no           */
     /* indication is propagated to the Ingress due to packets       */
     /* that are dropped because they were too short. This           */
     /* option is only relevant if RxDiscardTooShortPkts is          */
     /* enabled.                                                     */
     /* range: 12:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_ensure_discard_ind;

     /* RxHighReqThreshold: When the FIFO has more than this         */
     /* number of valid entries, it sends a high-priority            */
     /* request to the round robin.                                  */
     /* range: 22:16, access type: RW, default value: 0xc            */
     SOC_PETRA_REG_FIELD rx_high_req_threshold;

     /* RxThresholdAfterOverflow: After the Rx MLF has reached       */
     /* overflow, it waits until this is the status of the           */
     /* FIFOs, and only then writes data again (waits until          */
     /* enough entries are free). In SGMII, the same threshold       */
     /* applies to all FIFOs.                                        */
     /* range: 30:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_threshold_after_overflow;

  } __ATTRIBUTE_PACKED__ rx_mlf_config_reg[SOC_PB_NBI_REGS_RX_MLF_CONFIG_REG_ARRAY_SIZE];

  /* Rx Mlf Thresholds Config[0..15]: Rx MAC Lane FIFO (MLF)        */
  /* [0..15] Flow Control generation thresholds.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a71 */

     /* RxLlfcThresholdSet: Define hysteresis for generation of      */
     /* LLFC. When the Rx MLF has more than this number of valid     */
     /* entries, the MLF sets the indication to send link-level      */
     /* FC to the link partner. Value of this register should be     */
     /* larger than the value of Rx[n]LlfcThresholdClr.              */
     /* Recomended values should be approx 50% of the number of      */
     /* entries in the Rx MLF, depending on the number of            */
     /* logical FIFOs. Recomended values are 64 for XAUI, 32 for     */
     /* SGMII and 16 for QSGMII interfaces. In SGMII and QSGMII,     */
     /* the same threshold applies to all FIFOs.                     */
     /* range: 6:0, access type: RW, default value: 0x40             */
     SOC_PETRA_REG_FIELD rx_llfc_threshold_set;

     /* RxLlfcThresholdClr: When the Rx MLF has less than this       */
     /* number of valid entries, the MLF clears the indication       */
     /* to send link-level FC to the link partner. Recommended       */
     /* value is (Rx[n]LlfcThresholdSet - 4). In SGMII, the same     */
     /* threshold applies to all FIFOs.                              */
     /* range: 14:8, access type: RW, default value: 0x3c            */
     SOC_PETRA_REG_FIELD rx_llfc_threshold_clr;

     /* RxCbfcThresholdSet: Defines hysteresis for generation of     */
     /* CBFC. When the Rx MLF has more than this number of valid     */
     /* entries, the MLF will set the indication to send Class       */
     /* Based flow controls. Recommended value for this register     */
     /* should be lower than Rx[n]LlfcThresholdSet.                  */
     /* range: 22:16, access type: RW, default value: 0x24           */
     SOC_PETRA_REG_FIELD rx_cbfc_threshold_set;

     /* RxCbfcThresholdClr: When the Rx MLF has less than this       */
     /* number of valid entries, the MLF will clear the              */
     /* indication to send Class Based flow controls.                */
     /* Recommended value for this register is                       */
     /* (Rx[n]CbfcThresholdSet -4).                                  */
     /* range: 30:24, access type: RW, default value: 0x20           */
     SOC_PETRA_REG_FIELD rx_cbfc_threshold_clr;

  } __ATTRIBUTE_PACKED__ rx_mlf_thresholds_config_reg[SOC_PB_NBI_REGS_RX_MLF_THRESHOLDS_CONFIG_REG_ARRAY_SIZE];

  /* Tx Mlf Config[0..15]: Configuration and Status Register        */
  /* of Tx MAC Lane FIFO (MLF)                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4a72 */

     /* TxNumLogicalFifosMode: Indicates into how many logical       */
     /* FIFOs the 32-entries FIFO of 1 MLF are divided. 2'b00 -      */
     /* 4 FIFOs (for sgmii) (first entries are 0, 8, 16 and 24)      */
     /* 2'b01 - 2 FIFOs (for sgmii) (first entries are 0 and 32)     */
     /* 2'b10 - 1 FIFO (for xaui) This register has no meaning       */
     /* if enable Ilkn is set.                                       */
     /* range: 1:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD tx_num_logical_fifos_mode;

     /* TxStartTxThreshold: Configures the number of 128B words      */
     /* which MLF must accumulate before starting to transmit a      */
     /* packet. Used to prevent MAC starvation during packet         */
     /* transmission. Value should be at least smaller by 1 than     */
     /* TxAlmostFullThreshold. The same value applies all the        */
     /* FIFOs in the MLF. Note that a value higher than half the     */
     /* FIFO size may cause deadlocks. Recommended values: For       */
     /* XAUI - 5'h4; for GMII - 5'h2                                 */
     /* range: 8:4, access type: RW, default value: 0x4              */
     SOC_PETRA_REG_FIELD tx_start_tx_threshold;

     /* TxThresholdAfterOverflow: Reserved.                          */
     /* range: 28:24, access type: RW, default value: 0x1f           */
     SOC_PETRA_REG_FIELD tx_threshold_after_overflow;

  } __ATTRIBUTE_PACKED__ tx_mlf_config_reg[SOC_PB_NBI_REGS_TX_MLF_CONFIG_REG_ARRAY_SIZE];

  /* Rx Request Low Enable: This register contains the              */
  /* low-priority mask for the RX round robin.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4aa0 */

     /* RxReqLowEn: Low-priority mask for the round robin (the       */
     /* RR before the output to the IRE). If set, the                */
     /* corresponding MLF will participate in the round robin        */
     /* when the MLF requests (low request). Each bit                */
     /* corresponds to a certain MLF. Each MLF has 2                 */
     /* corresponding bits in the mask (one in the low               */
     /* replication and one in the high replication). It is          */
     /* recommended that each MLF have only 1 corresponding bit      */
     /* set in the RxReqLowEn (in the low OR high replication).      */
     /* (Bits 0 and 16 in the mask both correspond to MLF 0;         */
     /* bits 15 and 31 in the mask both correspond to MLF 15.)       */
     /* range: 31:0, access type: RW, default value: 32'h0000FFFF    */
     SOC_PETRA_REG_FIELD rx_req_low_en;

  } __ATTRIBUTE_PACKED__ rx_request_low_enable_reg;

  /* Rx Request High Enable: This register contains the             */
  /* high-priority mask for the RX round robin.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4aa1 */

     /* RxReqHiEn: High-priority mask for the round robin (the       */
     /* RR before the output to the IRE). If set, the                */
     /* corresponding MLF will participate in the round robin        */
     /* when the MLF has high request (the FIFO size exceeds         */
     /* Rx[n]AlmostFullThreshold1). Each bit corresponds to a        */
     /* certain MLF. Each MLF has 2 corresponding bits in the        */
     /* mask (one in the low replication and one in the high         */
     /* replication). It is recommended that each MLF have 0 or      */
     /* 1 corresponding bit set in the RxReqHiEn (in the low OR      */
     /* the high replication). Same bit should not be set in         */
     /* both the ReReqLowEn and ReReqHiEn (otherwise it will not     */
     /* give an additional priority).                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_req_hi_en;

  } __ATTRIBUTE_PACKED__ rx_request_high_enable_reg;

  /* Elk Cfg: This register enables the Soc_petra's internal            */
  /* Packet Processor interface to an External Lookup table         */
  /* (ELK). When set, the corresponding NIF port will bypass        */
  /* the MLF in the NBI and interface directly with the ELK         */
  /* in the IHP.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4aa2 */

     /* ElkEnableMal0: If set, MAL-0 will serve the ELK              */
     /* interface.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD elk_enable_mal0;

     /* ElkEnableMal12: If set, MAL-12 will serve the ELK            */
     /* interface.                                                   */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD elk_enable_mal12;

     /* ElkEnableMal14: If set, MAL-14 will serve the ELK            */
     /* interface.                                                   */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD elk_enable_mal14;

  } __ATTRIBUTE_PACKED__ elk_cfg_reg;

  /* Tx Flush Egress1: Debug register.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4aa3 */

     /* TxFlushEgress1: Reserved (set to 0). If set, override        */
     /* EGQ Rxi-Txi credits for NIF ports 0 - 31.                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_flush_egress1;

  } __ATTRIBUTE_PACKED__ tx_flush_egress1_reg;

  /* Tx Flush Egress2: Debug register.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4aa4 */

     /* TxFlushEgress2: Reserved (set to 0). If set, override        */
     /* EGQ Rxi-Txi credits for NIF ports 32 - 63.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_flush_egress2;

  } __ATTRIBUTE_PACKED__ tx_flush_egress2_reg;

  /* Tx Stop Egress1: Debug register.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4aa5 */

     /* TxStopEgress1: Reserved (set to 0). If set, will stop        */
     /* sending credits to the EGQ for NIF ports 0 - 31,             */
     /* consequently stopping Egress traffic on corresponding        */
     /* port.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_stop_egress1;

  } __ATTRIBUTE_PACKED__ tx_stop_egress1_reg;

  /* Tx Stop Egress2: Debug register.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4aa6 */

     /* TxStopEgress2: Reserved (set to 0). If set, will stop        */
     /* sending credits to the EGQ for NIF ports 32 - 63,            */
     /* consequently stopping Egress traffic on corresponding        */
     /* port.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_stop_egress2;

  } __ATTRIBUTE_PACKED__ tx_stop_egress2_reg;

  /* Enable Interlaken: Configuration Register to enable the        */
  /* ILKN modules                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ab0 */

     /* EnableIlkn0: If set, ILKN 0 (24 lanes) is active. Since      */
     /* ILKN 0 uses the resources of MLFs 0-7, they cannot be        */
     /* used at the same time.                                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_ilkn[SOC_PB_REG_NOF_ILKNS];

     /* ForceEgqSegmentation: If set, the ILKN core will be          */
     /* forced to segment the packets into bursts according the      */
     /* EGQ's segmentation (unless it breaks one of the              */
     /* protocol's rules). Otherwise, the ILKN core will divide      */
     /* the packets into bursts according the ILKN protocol (all     */
     /* bursts will be according BurstMax), except for the EOP       */
     /* burst, where the EGQ's burst boundaries will be forced       */
     /* (to guarantee last burst will be padded with the minimum     */
     /* possible idles).                                             */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD force_egq_segmentation;

     /* IlknRx1ExternalClockSel: This register defines which         */
     /* clock is inserted to MALG-B when working in ILKN mode.       */
     /* If this bit is set, the same clock of MALG-A (lanes          */
     /* 0-11) is taken, otherwise, the clock recovered from          */
     /* lanes 12-24 is taken. Set to <1> when working with ILKN      */
     /* 24 lanes. Otherwise, set to 0.                               */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_1_external_clock_sel[SOC_PB_REG_NOF_NIF_DIRECTIONS];

     /* IlknRx1InternalClockSel: This register defines which         */
     /* clock is inserted to the lane logic of Serdes lanes          */
     /* 12-23 when working in ILKN mode. If this bit is set, the     */
     /* same clock of MALG-A (lanes 0-11) is taken; otherwise,       */
     /* the clock of MALG-B is taken. Set to <1> when working        */
     /* with ILKN 24 lanes. Otherwise, set to 0.                     */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_1_internal_clock_sel[SOC_PB_REG_NOF_NIF_DIRECTIONS];

     /* RxForceLanesResync: Reserved (set to 0).                     */
     /* range: 31:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_force_lanes_resync;

  } __ATTRIBUTE_PACKED__ enable_interlaken_reg;

  /* Ilkn Rx0 Controller Config1: Configuration Register of         */
  /* Rx ILKN controller of the ILKN 24-lanes.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ab1 */

     /* IlknRx0HighReqThreshold: When the FIFO has more than         */
     /* this number of valid entries, it sends a high-priority       */
     /* request to the round robin.                                  */
     /* range: 9:0, access type: RW, default value: 0x200            */
     SOC_PETRA_REG_FIELD ilkn_rx0_high_req_threshold;

     /* IlknRx0LlfcThreshold: When the FIFO has more than this       */
     /* number of valid entries, the MLF will set an indication      */
     /* to send link-level FC to the link partner. In SGMII, the     */
     /* same threshold applies to all FIFOs.                         */
     /* range: 19:10, access type: RW, default value: 0x300          */
     SOC_PETRA_REG_FIELD ilkn_rx0_llfc_threshold;

     /* IlknRx0ThresholdAfterOverflow: After the Rx MLF has          */
     /* reached overflow, it waits until this will be the status     */
     /* of the FIFO, and only then writes data again (wait until     */
     /* enough entries are free). In SGMII, the same threshold       */
     /* applies to all FIFOs.                                        */
     /* range: 29:20, access type: RW, default value: 0x40           */
     SOC_PETRA_REG_FIELD ilkn_rx0_threshold_after_overflow;

     /* IlknRx0EnableReq3: Reserved (set to 0).                      */
     /* range: 30:30, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ilkn_rx0_enable_req3;

  } __ATTRIBUTE_PACKED__ ilkn_rx0_controller_config1_reg;

  /* Ilkn Rx1 Controller Config1: Configuration Register of         */
  /* Rx ILKN controller of the ILKN 12-lanes.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ab2 */

     /* IlknRx1HighReqThreshold: When the FIFO has more than         */
     /* this number of valid entries, it sends a high-priority       */
     /* request to the round robin.                                  */
     /* range: 9:0, access type: RW, default value: 0x200            */
     SOC_PETRA_REG_FIELD ilkn_rx1_high_req_threshold;

     /* IlknRx1LlfcThreshold: When the FIFO has more than this       */
     /* number of valid entries, the MLF sets an indication to       */
     /* send link-level FC to the link partner. In SGMII, the        */
     /* same threshold applies to all FIFOs.                         */
     /* range: 19:10, access type: RW, default value: 0x300          */
     SOC_PETRA_REG_FIELD ilkn_rx1_llfc_threshold;

     /* IlknRx1ThresholdAfterOverflow: After the Rx MLF has          */
     /* reached overflow, it waits until this is the status of       */
     /* the FIFO, and only then writes data again (wait until        */
     /* enough entries are free). In SGMII, the same threshold       */
     /* applies to all FIFOs.                                        */
     /* range: 29:20, access type: RW, default value: 0x40           */
     SOC_PETRA_REG_FIELD ilkn_rx1_threshold_after_overflow;

     /* IlknRx1EnableReq3: Reserved (set to 0).                      */
     /* range: 30:30, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ilkn_rx1_enable_req3;

  } __ATTRIBUTE_PACKED__ ilkn_rx1_controller_config1_reg;

  /* Ilkn Tx0 Controller Config: Configuration Register of Tx       */
  /* ILKN controller of the ILKN 24-lanes.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ab3 */

     /* IlknTx0StartTxThreshold: Configures the number of 128B       */
     /* words which MLF must accumulate before starting to           */
     /* transmit packet. Used to prevent MAC starvation during       */
     /* packet transmission. Value should be at least smaller by     */
     /* 1 than TxAlmostFullThreshold. The same value applies all     */
     /* the FIFOs in the MLF. Note: A value higher than half the     */
     /* FIFO size may cause deadlocks. Recommended value: 8'hF.      */
     /* range: 7:0, access type: RW, default value: 0x4              */
     SOC_PETRA_REG_FIELD ilkn_tx0_start_tx_threshold;

     /* IlknTx0ThresholdAfterOverflow: Reserved.                     */
     /* range: 15:8, access type: RW, default value: 0xf0            */
     SOC_PETRA_REG_FIELD ilkn_tx0_threshold_after_overflow;

     /* IlknTx0NumCreditsToEgq: Reserved (set to 0x100).             */
     /* range: 24:16, access type: RW, default value: 0x100          */
     SOC_PETRA_REG_FIELD ilkn_tx0_num_credits_to_egq;

  } __ATTRIBUTE_PACKED__ ilkn_tx0_controller_config_reg;

  /* Ilkn Tx1 Controller Config: Configuration Register of Tx       */
  /* ILKN controller of the ILKN 12-lanes.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ab4 */

     /* IlknTx1StartTxThreshold: Configures the number of 128B       */
     /* words which MLF must accumulate before starting to           */
     /* transmit a packet. Used to prevent MAC starvation during     */
     /* packet transmission. Value should be at least smaller by     */
     /* 1 than TxAlmostFullThreshold. The same value applies all     */
     /* the FIFOs in the MLF. Note: A value higher than half the     */
     /* FIFO size may cause deadlocks. Recommended value: 8'hF.      */
     /* range: 7:0, access type: RW, default value: 0x4              */
     SOC_PETRA_REG_FIELD ilkn_tx1_start_tx_threshold;

     /* IlknTx1ThresholdAfterOverflow: Reserved.                     */
     /* range: 15:8, access type: RW, default value: 0xf0            */
     SOC_PETRA_REG_FIELD ilkn_tx1_threshold_after_overflow;

     /* IlknTx1NumCreditsToEgq: Reserved (set to 0x100).             */
     /* range: 24:16, access type: RW, default value: 0x100          */
     SOC_PETRA_REG_FIELD ilkn_tx1_num_credits_to_egq;

  } __ATTRIBUTE_PACKED__ ilkn_tx1_controller_config_reg;

  /* Rx[0..1]Ilkn Control: Configuration Register for ILKN RX       */
  /* port [n] (port0=24-lanes, port1=12-lanes)                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ab5 */

     /* RxFullPacketMode: When set, the ILKN port works in           */
     /* full-packet mode; otherwise, it works in interleaved         */
     /* (segmented) mode. Should be changed only when the ILKN       */
     /* port is held at reset.                                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_full_packet_mode;

     /* RxBurstmax: This input specifies the maximum number of       */
     /* Data Words between Burst Control Words and is used in        */
     /* conjunction with Rx[n]StatBurstmaxErr. The following         */
     /* values are defined: 2'h0=64 bytes, 2'h1=128 bytes,           */
     /* 2'h2=192 bytes, 2'h3=256 bytes Should be changed only        */
     /* when the ILKN port is held at reset. Note: to meet           */
     /* Soc_petras burst segmentation rules, BurstMax must be larger     */
     /* than 128B.                                                   */
     /* range: 5:4, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD rx_burstmax;

     /* RxMframeLenMinus1: A Metaframe sync word is expected         */
     /* every (Rx[n]MframeLenMinus1+1) words transfers on every      */
     /* lane. (See section 5.4.3 of Interlaken spec 1.1.) Should     */
     /* be changed only when the ILKN port is held at reset.         */
     /* range: 23:8, access type: RW, default value: 0x7ff           */
     SOC_PETRA_REG_FIELD rx_mframe_len_minus1;

     /* IlknRxStatDiagwordFromOob: If set, the link partner's        */
     /* interface status and lanes status for the relevant           */
     /* Interlaken port will be taken from the OOB indication,       */
     /* instead of the in-band indications. NOTE: When working       */
     /* with ILKN-24 in OOB mode both Rx0 and Rx1 bits should be     */
     /* set.                                                         */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_diagword_from_oob;

  } __ATTRIBUTE_PACKED__ rx_ilkn_control_reg[SOC_PB_NBI_REGS_RX_ILKN_CONTROL_REG_ARRAY_SIZE];

  /* Tx[0..1]Ilkn Control0: Configuration Register for ILKN         */
  /* TX port [n] (port0=24-lanes, port1=12-lanes)                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ab6 */

     /* TxEnableCpuOverride: Reserved (set to 0).                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_enable_cpu_override;

     /* TxEnableCpuValue: Reserved (set to 0).                       */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_enable_cpu_value;

     /* TxDiagwordInterfaceStatOverride: Reserved (set to 0).        */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_diagword_interface_stat_override;

     /* TxDiagwordInterfaceStatValue: Reserved (set to 0).           */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_diagword_interface_stat_value;

     /* TxBurstmax: This input specifies the maximum number of       */
     /* Data Words between Burst Control Words. The following        */
     /* values are defined: 2'h0=64 bytes, 2'h1=128 bytes,           */
     /* 2'h2=192 bytes, 2'h3=256 bytes.                              */
     /* range: 5:4, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD tx_burstmax;

     /* TxDisableSkipword: Reserved (set to 0).                      */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_disable_skipword;

     /* TxRateLimiterEnable: Reserved (set to 0).                    */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_rate_limiter_enable;

     /* TxBurstshort: This input specifies the minimum spacing       */
     /* between Burst Control Words. For ILKN port0: The             */
     /* following values are valid: 001=64 bytes, 011=128 bytes,     */
     /* 101=192 bytes, 111=256 bytes For ILKN port1: The             */
     /* following values are valid: 000=32 bytes, 001=64 bytes,      */
     /* 010=96 bytes, 011=128 bytes 100=160 bytes,101=192 bytes,     */
     /* 110=224 bytes, 111=256 bytes                                 */
     /* range: 10:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD tx_burstshort;

     /* TxNumFreeEntriesForAlmostFull: The ilkn_ready_out is         */
     /* asserted with a value of 1 when the FIFO inside the TX       */
     /* is ready to receive data. This input should be adjusted      */
     /* so that tx_ovfout is never asserted. Valid values are        */
     /* 3-7.                                                         */
     /* range: 13:11, access type: RW, default value: 0x6            */
     SOC_PETRA_REG_FIELD tx_num_free_entries_for_almost_full;

     /* TxMframeLenMinus1: Determines the length of the Meta         */
     /* frame. The actual value of the meta frame will be            */
     /* Tx[n]MframeLenMinus1 + 1. Thus for a Meta Frame of 2048,     */
     /* a value of 2047 should be used. This input is specified      */
     /* in terms of the number of words or cycles minus one.         */
     /* range: 29:14, access type: RW, default value: 0x7ff          */
     SOC_PETRA_REG_FIELD tx_mframe_len_minus1;

  } __ATTRIBUTE_PACKED__ tx_ilkn_control_reg_0[SOC_PB_NBI_REGS_TX_ILKN_CONTROL_REG_ARRAY_SIZE];

  /* Tx[0..1]Ilkn Control1: Configuration Register for ILKN         */
  /* TX port [n] (port0=24-lanes, port1=12-lanes)                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ab7 */

     /* TxFcCalLen: TX FlowControl Calendar Length for ILKN port     */
     /* [n]. This is the number of valid bits in the 256 bits        */
     /* vector from the FC unit in the NBI. The setting are as       */
     /* follows:4'd0-> length of 16, 4'd1->32, 4'd3->64,             */
     /* 4'd7->128, 4'd15->256 This register defines also the         */
     /* length of the calnder required for RX purposes: Cycle        */
     /* length when transferring RX CHFC to the CFC and the          */
     /* valid channels in the RX CHFC to decode llfc from.           */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_fc_cal_len;

     /* TxFlushTxOnLinkStatusFail: If set, the ILKN Tx will          */
     /* flush Tx data when link fails (as reported by the Rx         */
     /* path) or when link partner indicates remote fault            */
     /* (through the diagwords).                                     */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tx_flush_tx_on_link_status_fail;

  } __ATTRIBUTE_PACKED__ tx_ilkn_control1_reg[SOC_PB_NBI_REGS_TX_ILKN_CONTROL_REG_ARRAY_SIZE];

  /* Tx Ilkn[0..1]Rate Limiter Config: Configuration Register       */
  /* for the rate limiter of the ILKN TX port [n]                   */
  /* (port0=24-lanes, port1=12-lanes)                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ab8 */

     /* TxRateLimiterMaxTokens: Reserved (set to 0x1ff).             */
     /* range: 11:0, access type: RW, default value: 0x1ff           */
     SOC_PETRA_REG_FIELD tx_rate_limiter_max_tokens;

     /* TxRateLimiterDelta: Reserved (set to 0x01).                  */
     /* range: 23:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tx_rate_limiter_delta;

     /* TxRateLimiterInterval: Reserved (set to 0x10).               */
     /* range: 31:24, access type: RW, default value: 0x10           */
     SOC_PETRA_REG_FIELD tx_rate_limiter_interval;

  } __ATTRIBUTE_PACKED__ tx_ilkn_rate_limiter_config_reg[SOC_PB_NBI_REGS_TX_ILKN_RATE_LIMITER_CONFIG_REG_ARRAY_SIZE];

  /* Ilkn[0..1]Num Lanes Config: Configuration Register for         */
  /* the ILKN ports. Enables to decommission a certain lane         */
  /* and to limit the port not to use all its available             */
  /* lanes.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ab9 */

     /* RxLastLane: Selects the Last Lane of ILKN RX port[n].        */
     /* This input must have a value between 8 and 23 for ILKN0,     */
     /* and a value of 4 to 11 for ILKN 1. Any other value may       */
     /* result in unreliable operation. This input should be         */
     /* static and should only be changed while the port is held     */
     /* in reset or after force_resync of the ILKN port has been     */
     /* asserted for several clock cycles.                           */
     /* range: 4:0, access type: RW, default value: 0x17             */
     SOC_PETRA_REG_FIELD last_lane[SOC_PB_REG_NOF_NIF_DIRECTIONS];

     /* RxHasBadLane: Enables a Lane Decommissioning in the ILKN     */
     /* RX port[n]. When this bit is a value of 1, a single lane     */
     /* selected by Rx[n]BadLane is decommissioned. This input       */
     /* should be static and changed only while the port is held     */
     /* in reset.                                                    */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD has_bad_lane[SOC_PB_REG_NOF_NIF_DIRECTIONS];

     /* RxBadLane: Selects the Decommissioned Lane of ILKN RX        */
     /* port[n]. Relevant only when Rx[n]HasBadLane is set. This     */
     /* input must be a value between 0 and the value assigned       */
     /* to Rx[n]LastLane. This input should be static and            */
     /* changed only while the port is held in reset.                */
     /* range: 13:9, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bad_lane[SOC_PB_REG_NOF_NIF_DIRECTIONS];

     SOC_PETRA_REG_FIELD tx_bad_lane;

  } __ATTRIBUTE_PACKED__ ilkn_num_lanes_config_reg[SOC_PB_NBI_REGS_ILKN_NUM_LANES_CONFIG_REG_ARRAY_SIZE];

  /* ILKN0 Multiple Use Bits: Optional configurations for the       */
  /* multiple-use bits of ILKN port0.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ac0 */

     /* IlknRx0MultipleUseBitsMaskToLlfc: Masks the received         */
     /* multiple use bits before interpreted as link level flow      */
     /* control. If a certain bit in the rx multiple use bits        */
     /* was received with value of XOFF, and its corresponding       */
     /* bit in the mask is set, this will be interpreted as          */
     /* request for link level flow control (TX will be stoped       */
     /* until XOFF is over). To disable the option of link level     */
     /* flow over the multiple use bits - set this register to       */
     /* 8'h0.                                                        */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx0_multiple_use_bits_mask_to_llfc;

     /* IlknTx0MultipleUseBitsMaskForLlfc: Masks the transmitted     */
     /* multiple use bits before encoding on them link level         */
     /* flow control. If a link level flow control should be         */
     /* transmitted to the LP, it will be encoded on the             */
     /* transmitted multiple use bits on the bits set in the         */
     /* mask. The value of the bits not set in this mask will be     */
     /* taken from the MultipleUseBitsSet.                           */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_tx0_multiple_use_bits_mask_for_llfc;

     /* IlknTx0MultipleUseBitsSet: The value to transmit over        */
     /* the TX multiple use bits of bits not set in the mask (       */
     /* TX0MultipleUseBitsMaskToLlfc) is taken from this field.      */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx0_multiple_use_bits_set;

  } __ATTRIBUTE_PACKED__ ilkn0_multiple_use_bits_reg;

  /* ILKN1 Multiple Use Bits: Optional configurations for the       */
  /* multiple-use bits of ILKN port1.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ac1 */

     /* IlknRx1MultipleUseBitsMaskToLlfc: Masks the received         */
     /* multiple use bits before interpreted as link level flow      */
     /* control. If a certain bit in the rx multiple use bits        */
     /* was received with value of XOFF, and its corresponding       */
     /* bit in the mask is set, this will be interpreted as          */
     /* request for link level flow control (TX will be stoped       */
     /* until XOFF is over). To disable the option of link level     */
     /* flow over the multiple use bits - set this register to       */
     /* 8'h0.                                                        */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx1_multiple_use_bits_mask_to_llfc;

     /* IlknTx1MultipleUseBitsMaskForLlfc: Masks the transmitted     */
     /* multiple use bits before encoding on them link level         */
     /* flow control. If a link level flow control should be         */
     /* transmitted to the LP, it will be encoded on the             */
     /* transmitted multiple use bits on the bits set in the         */
     /* mask. The value of the bits not set in this mask will be     */
     /* taken from the MultipleUseBitsSet.                           */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_tx1_multiple_use_bits_mask_for_llfc;

     /* IlknTx1MultipleUseBitsSet: The value to transmit over        */
     /* the TX multiple use bits of bits not set in the mask (       */
     /* TX1MultipleUseBitsMaskToLlfc) is taken from this field.      */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx1_multiple_use_bits_set;

  } __ATTRIBUTE_PACKED__ ilkn1_multiple_use_bits_reg;

  /* Ilkn Memory Control: Enables memory ECC for ILKN               */
  /* memories.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ac2 */

     /* IlknTxEccDisable: Reserved (set to 0).                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_tx_ecc_disable;

  } __ATTRIBUTE_PACKED__ ilkn_memory_control_reg;

  /* Statistics: Configuration Register for the statistics          */
  /* module                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ad0 */

     /* StatEn: If set, the NIF port statistics counters             */
     /* monitors Rx and Tx interfaces. Otherwise, the counters       */
     /* will not be updated due to Rx/Tx traffic.                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_en;

     /* StatResetStart: NIF port statistics counters will            */
     /* initiate reset sequence on falling edge of this              */
     /* register. The reset sequence will clear all counters for     */
     /* all ports. During the reset sequence, counters are not       */
     /* updated.                                                     */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_reset_start;

     /* StatCntOverflowEnable: Reserved (set to 0).                  */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_cnt_overflow_enable;

     /* StatCountLengWithErr: If set, allows to collect length       */
     /* (octets) statistics from bursts with errors from Rx and      */
     /* Tx interfaces                                                */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stat_count_leng_with_err;

     /* StatCountTypeWithErr: If set, allows to collect type         */
     /* statistics (MCAST/BCAST) from bursts with errors from Rx     */
     /* and Tx interfaces                                            */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_count_type_with_err;

     /* StatCountBinsWithErr: If set, allows to collect length       */
     /* binning statistics from bursts with errors from Rx           */
     /* interface                                                    */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_count_bins_with_err;

     /* StatSobFrameErrMask: Reserved (set to 1).                    */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stat_sob_frame_err_mask;

     /* StatEobFrameErrMask: Reserved (set to 1).                    */
     /* range: 9:9, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stat_eob_frame_err_mask;

     /* StatBobFrameErrMask: Reserved (set to 1).                    */
     /* range: 10:10, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD stat_bob_frame_err_mask;

     /* StatClearOnRead: If set, CPU read will clear the counter     */
     /* range: 12:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD stat_clear_on_read;

     /* StatGtimerMode: If set, the NIF port statistics counters     */
     /* will monitor Rx and Tx interfaces traffic for period         */
     /* configured in StatGtimerCnt register.                        */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_gtimer_mode;

     /* StatUcastCountEnable: If set, enables the unicast            */
     /* packets in OK bursts counters. Otherwise, counts all         */
     /* packets. This register reffers both RX and TX.               */
     /* range: 14:14, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD stat_ucast_count_enable;

     /* IgnoreStatReq: Reserved.                                     */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ignore_stat_req;

     /* StatIlkn0Enable: If set and StatRxEopCountEnable is set,     */
     /* enables to count EOP per channel in Ilkn mode, in            */
     /* binning counters of mal0-mal7 (ports 0-31).                  */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_ilkn_enable[SOC_PB_REG_NOF_ILKNS];

     /* StatRxSopCountEnable: Reserved (set to 0).                   */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_sop_count_enable;

     /* StatRxBopCountEnable: Reserved (set to 0).                   */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_bop_count_enable;

     /* StatRxEopCountEnable: Reserved (set to 0).                   */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_eop_count_enable;

     /* StatPacketCountEn: Reserved (set to 0).                      */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_packet_count_en;

     /* StatTxSopCountEnable: Reserved (set to 0).                   */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tx_sop_count_enable;

     /* StatTxBopCountEnable: Reserved (set to 0).                   */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tx_bop_count_enable;

     /* StatTxEopCountEnable: Reserved (set to 0).                   */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tx_eop_count_enable;

     /* StatBusCyclesCountEn: Reserved (set to 0).                   */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_bus_cycles_count_en;

  } __ATTRIBUTE_PACKED__ statistics_reg;

  /* Statistics Rx Binning: Configuration Register for the          */
  /* statistics module                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ad1 */

     /* StatRxMinBurstLength: Minimal burst length for length        */
     /* binning (excluding 3B or 4B CRC). Bursts shorter than        */
     /* this value will be counted by bin [0] counter. These         */
     /* bursts will not be marked with error. (Max value is 59).     */
     /* range: 7:0, access type: RW, default value: 0x3b             */
     SOC_PETRA_REG_FIELD stat_rx_min_burst_length;

     /* StatRxMaxBurstLength: Minimal burst length for length        */
     /* binning (excluding 3B or 4B CRC). Bursts longer than         */
     /* this value will be counted by bin [9] counter. These         */
     /* bursts will not be marked with error. (Min value is          */
     /* 1515/1519, depends on StatRxBinsCfg)                         */
     /* range: 21:8, access type: RW, default value: 0x3fff          */
     SOC_PETRA_REG_FIELD stat_rx_max_burst_length;

     /* StatRxBinsCfg: Configures the limits for bins 7,8: [0]       */
     /* Sets bin 7 for burst length of 1020...1514 and bin 8 for     */
     /* burst length of 1515...(StatRxMaxBurstLength-1). [1]         */
     /* Sets bin 7 for burst length of 1020...1518 and bin 8 for     */
     /* burst length of 1519...(StatRxMaxBurstLength-1).             */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_bins_cfg;

  } __ATTRIBUTE_PACKED__ statistics_rx_binning_reg;

  /* Statistics Status: Statistic status register.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ad2 */

     /* StatResetIsDone: If set, indicates that the statistics       */
     /* collector is out of reset sequence.                          */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_reset_is_done;

     /* StatReadInProgress: If set, indicates that counter read      */
     /* request is in progress.                                      */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_read_in_progress;

     /* StatIsReady: If set, indicates that the statistics           */
     /* collector is ready (out of reset sequence and enabled).      */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_is_ready;

  } __ATTRIBUTE_PACKED__ statistics_status_reg;

  /* Statistics Read Select: Statistic counters read counter        */
  /* selection. Writing to this register will trigger a CPU         */
  /* read sequence from the selected statistics counter. At         */
  /* the end of this sequence, the read data will be written        */
  /* to StatRdCntLSB and StatRdCntMSB registers, and the            */
  /* StatCntDataValid register will be set. All counters are        */
  /* 48b wide, except octets counter which is 62b wide. All         */
  /* the statistics in the counters exclude CRC.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ad3 */

     /* StatReadCntId: Select counter to read from: Rx Counters:     */
     /* [0] Rx Octets(bytes) in OK bursts (including/excluding       */
     /* bad bursts). [16] Rx BCAST - bursts (including/excluding     */
     /* bad bursts). [17] Rx MCAST - bursts (including/excluding     */
     /* bad bursts). [32] Rx OK bursts. [33] Rx ERR bursts. Rx       */
     /* Bursts Length Bins (including/excluding bad bursts) :        */
     /* [48] 0..<min_birst_length-1>B. [49]                          */
     /* <min_burst_length>..59B. [50] 60B. [51] 61..123B. [52]       */
     /* 124..251B. [53] 252..507B. [54] 508..1019B. [55]             */
     /* 1020..1514/1518B. (configurable) [56]                        */
     /* 1515/1519..<max_burst_length-1>B. (configurable) [57]        */
     /* Bursts larger than <max_burst_length>B. Tx Counters:         */
     /* [64] Tx Octets(bytes) in OK bursts (including/excluding      */
     /* bad bursts). [80] Tx BCAST - bursts (including/excluding     */
     /* bad bursts). [81] Tx MCAST - bursts (including/excluding     */
     /* bad bursts). [96] Tx OK bursts. [97] Tx ERR bursts.          */
     /* StatReadErrInt is set when reading from an invalid           */
     /* address,                                                     */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_read_cnt_id;

     /* StatReadPort: Configure which port to read from.             */
     /* range: 13:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_read_port;

  } __ATTRIBUTE_PACKED__ statistics_read_select_reg;

  /* Statistics Read LSB: Statistic counters read data (LSBs)       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ad4 */

     /* StatReadCntLSB: Data returned from the selected              */
     /* statistics counter (according to StatRdCntSel). Whenever     */
     /* StatRdCntSel register is written to, the selected            */
     /* counter is cleared (if configured), and its contents are     */
     /* moved to the StatisticsRdLSB and StatisticsRdMSB             */
     /* registers. This counter stops at saturation.                 */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_read_cnt_lsb;

  } __ATTRIBUTE_PACKED__ statistics_read_lsb_reg;

  /* Statistics Read MSB: Statistic counters read data (MSBs)       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ad5 */

     /* StatReadCntMSB: Data returned from the selected              */
     /* statistics counter (according to StatRdCntSel). Whenever     */
     /* StatRdCntSel register is written to, the selected            */
     /* counter is cleared (if configured), and its contents are     */
     /* moved to the StatisticsRdLSB and StatisticsRdMSB             */
     /* registers. This counter stops at saturation.                 */
     /* range: 29:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_read_cnt_msb;

     /* StatCntDataOverflow: When set, indicates that the            */
     /* counter read has overflowed. When set and                    */
     /* StatCntDataValid is clear, indicates that the data is        */
     /* erroneous (read from counter that does not exist).           */
     /* range: 30:30, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_cnt_data_overflow;

     /* StatCntDataValid: When set, indicates that the counters      */
     /* data read is valid                                           */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_cnt_data_valid;

  } __ATTRIBUTE_PACKED__ statistics_read_msb_reg;

  /* Statistics Rx Frame Err Cnt: Statistics Frame Error            */
  /* Counter for Rx interface                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ad6 */

     /* StatRxFrameErrCnt: Data returned from the Rx frame error     */
     /* counter. This register is clear on read.                     */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_rx_frame_err_cnt;

     /* StatRxSobFrameErr: If set, indicates that there was SOB      */
     /* (Start Of Burst) frame error (SOB when in burst). This       */
     /* register is clear on read.                                   */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_sob_frame_err;

     /* StatRxBobFrameErr: If set, indicates that there was BOB      */
     /* (Body Of Burst) frame error (BOB when out of burst).         */
     /* This register is clear on read.                              */
     /* range: 17:17, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_bob_frame_err;

     /* StatRxEobFrameErr: If set, indicates that there was EOB      */
     /* (End Of Burst) frame error (EOB when out of burst). This     */
     /* register is clear on read.                                   */
     /* range: 18:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_eob_frame_err;

     /* StatRxLastFrameErrPort: Holds the last port in which         */
     /* frame error was detected.                                    */
     /* range: 25:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_last_frame_err_port;

  } __ATTRIBUTE_PACKED__ statistics_rx_frame_err_cnt_reg;

  /* Statistics Tx Frame Err Cnt: Statistics Frame Error            */
  /* Counter for Tx interface                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ad7 */

     /* StatTxFrameErrCnt: Data returned from the Tx frame error     */
     /* counter. This register is clear on read.                     */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_tx_frame_err_cnt;

     /* StatTxSobFrameErr: If set, indicates that there was SOB      */
     /* (Start Of Burst) frame error (SOB when in burst). This       */
     /* register is clear on read.                                   */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tx_sob_frame_err;

     /* StatTxBobFrameErr: If set, indicates that there was BOB      */
     /* (Body Of Burst) frame error (BOB when out of burst).         */
     /* This register is clear on read.                              */
     /* range: 17:17, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tx_bob_frame_err;

     /* StatTxEobFrameErr: If set, indicates that there was EOB      */
     /* (End Of Burst) frame error (EOB when out of burst). This     */
     /* register is clear on read.                                   */
     /* range: 18:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tx_eob_frame_err;

     /* StatTxLastFrameErrPort: Holds the last port in which         */
     /* frame error was detected.                                    */
     /* range: 25:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tx_last_frame_err_port;

  } __ATTRIBUTE_PACKED__ statistics_tx_frame_err_cnt_reg;

  /* Statistics Rx Bursts Ok Cnt: Statistic counter                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ad8 */

     /* StatRxBurstsOkCnt: Counts total number of bursts (for        */
     /* all ports) that were received without an error. This         */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_rx_bursts_ok_cnt;

     /* StatRxBurstsOkCntOvf: Iindicates counter overflowed.         */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_bursts_ok_cnt_ovf;

  } __ATTRIBUTE_PACKED__ statistics_rx_bursts_ok_cnt_reg;

  /* Statistics Rx Bursts Err Cnt: Statistic counter                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ad9 */

     /* StatRxBurstsErrCnt: Counts total number of bursts (for       */
     /* all ports) that were received with an error. This            */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_rx_bursts_err_cnt;

     /* StatRxBurstsErrCntOvf: Iindicates counter overflowed.        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_bursts_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ statistics_rx_bursts_err_cnt_reg;

  /* Statistics Tx Bursts Cnt: Statistic counter                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ada */

     /* StatTxBurstsCnt: Counts total number of Tx bursts (for       */
     /* all ports) that were received with an error. This            */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_tx_bursts_cnt;

     /* StatTxBurstsCntOvf: Iindicates counter overflowed.           */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tx_bursts_cnt_ovf;

  } __ATTRIBUTE_PACKED__ statistics_tx_bursts_cnt_reg;

  /* Fc Reset: Flow Control Interface processes indications         */
  /* from CFC, MALs and ILKN.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ae0 */

     /* FcReset: If set, the Flow Control Interface will be held     */
     /* in reset.                                                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_reset;

     /* FcMalXauiMode: If set, indicates the corresponding MAL       */
     /* is in XAUI (or SPAUI) mode. This affects how CBFC            */
     /* classes are mapped into 8 classes of the Extended Pause      */
     /* Frames. Otherwise (GMII modes), 2 classes are mapped for     */
     /* each port. One bit per MAL.                                  */
     /* range: 31:16, access type: RW, default value: 0xffff         */
     SOC_PETRA_REG_FIELD fc_mal_xaui_mode[SOC_PB_REG_NOF_MALS];

  } __ATTRIBUTE_PACKED__ fc_reset_reg;

  /* Fc Groups: Bitmap of MALs defining FC groups.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ae1 */

     /* FcLlfcGrp1: Reserved (write as 0). Group 1.                  */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_llfc_grp1;

     /* FcLlfcGrp2: Reserved (write as 0). Group 2.                  */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_llfc_grp2;

  } __ATTRIBUTE_PACKED__ fc_groups_reg;

  /* Fc Cbfc Mapping0: Rx MLF CBFC Mapping.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ae2 */

     /* FcTx0GenCbfcBitmap: When RxMLF passes the                    */
     /* Rx[n]CbfcThreshold the FC interface will indicate to the     */
     /* MAL to generate CBFC extend Pause Frame (TxGenCBFC)          */
     /* using the classes defined by this bitmap. If MAL is in       */
     /* XAUI mode, all 8 bits are used for the xaui port. In         */
     /* GMII modes, each GMII port receives 2 bits (one bit for      */
     /* high priority and one for low priority classes). Further     */
     /* mapping will be done by the port (i.e. port 0 receives       */
     /* bits [1:0], port 1 - [3:2], etc). This field correlates      */
     /* to MAL0.                                                     */
     /* range: 7:0, access type: RW, default value: 0xf0             */
     SOC_PETRA_REG_FIELD fc_tx_gen_cbfc_bitmap;

  } __ATTRIBUTE_PACKED__ fc_cbfc_mapping_reg[SOC_PB_NBI_FC_CBFC_MAPPING_REG_NOF_REGS];
  /* Fc Llfc Stop Tx Force: CPU overrides for LLFC                  */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ae6 */

     /* FcLlfcStopTxForce: Reserved (set to 0).                      */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_llfc_stop_tx_force;

  } __ATTRIBUTE_PACKED__ fc_llfc_stop_tx_force_reg[SOC_PB_NBI_FC_LLFC_STOP_TX_FORCE_REG_MULT_NOF_REGS];

  /* Fc Llfc Stop Tx En Cfc: CPU overrides for LLFC                 */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4ae8 */

     /* FcLlfcStopTxEnCfc: Reserved (set to 1).                      */
     /* range: 31:0, access type: RW, default value: 64'hffffffffffffffff */
     SOC_PETRA_REG_FIELD fc_llfc_stop_tx_en_cfc;

  } __ATTRIBUTE_PACKED__ fc_llfc_stop_tx_en_cfc_reg[SOC_PB_NBI_FC_LLFC_STOP_TX_EN_CFC_REG_MULT_NOF_REGS];

  /* Fc Tx Gen Llfc Force: CPU overrides for LLFC indications       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4aea */

     /* FcTxGenLlfcForce: Reserved (set to 0).                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_tx_gen_llfc_force;

  } __ATTRIBUTE_PACKED__ fc_tx_gen_llfc_force_reg[SOC_PB_NBI_FC_TX_GEN_LLFC_FORCE_REG_MULT_NOF_REGS];

  /* Fc Tx Gen Llfc En MLF: CPU overrides for LLFC                  */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4aec */

     /* FcTxGenLlfcEnMlf: Reserved (set to 1).                       */
     /* range: 31:0, access type: RW, default value: 64'hffffffffffffffff */
     SOC_PETRA_REG_FIELD fc_tx_gen_llfc_en_mlf;

  } __ATTRIBUTE_PACKED__ fc_tx_gen_llfc_en_mlf_reg[SOC_PB_NBI_FC_TX_GEN_LLFC_EN_MLF_REG_MULT_NOF_REGS];

  /* Fc Tx Gen Llfc En CFC: CPU overrides for LLFC                  */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4aee */

     /* FcTxGenLlfcEnCfc: Reserved (set to 1).                       */
     /* range: 31:0, access type: RW, default value: 64'hffffffffffffffff */
     SOC_PETRA_REG_FIELD fc_tx_gen_llfc_en_cfc;

  } __ATTRIBUTE_PACKED__ fc_tx_gen_llfc_en_cfc_reg[SOC_PB_NBI_FC_TX_GEN_LLFC_EN_CFC_REG_MULT_NOF_REGS];

  /* Fc Tx Gen Cbfc Force: CPU overrides for CBFC indications       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4af0 */

     /* FcTxGenCbfcForceMlf: Reserved (set to 0).                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_tx_gen_cbfc_force_mlf;

  } __ATTRIBUTE_PACKED__ fc_tx_gen_cbfc_force_reg[SOC_PB_NBI_FC_TX_GEN_CBFC_FORCE_REG_MULT_NOF_REGS];

  /* Fc Tx Gen Cbfc En MLF: CPU overrides for CBFC                  */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4af2 */

     /* FcTxGenCbfcEnMlf: Reserved (set to 1).                       */
     /* range: 31:0, access type: RW, default value: 64'hffffffffffffffff */
     SOC_PETRA_REG_FIELD fc_tx_gen_cbfc_en_mlf;

  } __ATTRIBUTE_PACKED__ fc_tx_gen_cbfc_en_mlf_reg[SOC_PB_NBI_FC_TX_GEN_CBFC_EN_MLF_REG_MULT_NOF_REGS];

  /* Fc Tx Gen Cbfc En CFC: CPU overrides for CBFC                  */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4af4 */

     /* FcTxGenCbfcEnCfc: Reserved (set to 1).                       */
     /* range: 31:0, access type: RW, default value: 64'hffffffffffffffff */
     SOC_PETRA_REG_FIELD fc_tx_gen_cbfc_en_cfc;

  } __ATTRIBUTE_PACKED__ fc_tx_gen_cbfc_en_cfc_reg[SOC_PB_NBI_FC_TX_GEN_CBFC_EN_CFC_REG_MULT_NOF_REGS];

  /* Fc ILKN: ILKN flow control configurations                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4af6 */

     /* FcIlknMode: If set, ILKN Rx MLF and ILKN Link Status         */
     /* indications will be mapped to trigger generation of LLFC     */
     /* indication to link-partner (TxGenLLFC) through the           */
     /* in-band or out of band FC interfaces. Set to 1 when the      */
     /* corresponding ILKN port is active. Bit 0 corresponds to      */
     /* ILKN port0; bit 1 to ILKN port1.                             */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_ilkn_mode;

     /* FcIlknRxLlfcEn: If set, will enable the ILKN port to         */
     /* pause Tx traffic in reaction to RxLLFC. Otherwise, the       */
     /* ILKN port will let the CFC to process RxLLFC. RxLLFC may     */
     /* be extracted from Rx ChFC channel 0 or channels n*16         */
     /* (see FcIlknRxLlfcOnCh0 and FcIlknRxLlfcEvery_16_Chs          */
     /* registers). Bit 0 corresponds to ILKN port0; bit 1 to        */
     /* ILKN port1.                                                  */
     /* range: 5:4, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD fc_ilkn_rx_llfc_en;

     /* FcTxGenLlfcEnIlkn: If set, will indicates LLFC to the        */
     /* link partner (TxGenLLFC) when ILKN port is not aligned       */
     /* (Rx not ready). Bit 0 corresponds to ILKN port0; bit 1       */
     /* to ILKN port1.                                               */
     /* range: 9:8, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD fc_tx_gen_llfc_en_ilkn;

     /* FcIlknTxGenLlfcOnCh0: If set, will place TxGenLLFC on        */
     /* channel 0 of the in-band ChFC that will be indicated to      */
     /* link partner. Bit 0 corresponds to ILKN port0; bit 1 to      */
     /* ILKN port1.                                                  */
     /* range: 13:12, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fc_ilkn_tx_gen_llfc_on_ch0;

     /* FcIlknTxGenLlfcEvery_16_Chs: If set, will place              */
     /* TxGenLLFC once every 16 channels (0, 16, 32, 48, ... 240)      */
     /* of the in-band ChFC that will be indicated to link           */
     /* partner. Bit 0 corresponds to ILKN port0; bit 1 to ILKN      */
     /* port1.                                                       */
     /* range: 17:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_ilkn_tx_gen_llfc_every_16_chs;

     /* FcIlknTxGenLlfcOnAllChs: If set will place TxGenLLFC on      */
     /* all the channels of the inband channel flow control. Bit     */
     /* 0 corresponds to ILKN port0; bit 1 to ILKN port1.            */
     /* range: 21:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_ilkn_tx_gen_llfc_on_all_chs;

     /* FcIlknRxLlfcOnCh0: If set, will extract RxLLFC from          */
     /* channel 0 of the in-band ChFC indicated by link partner.     */
     /* Bit 0 corresponds to ILKN port0; bit 1 to ILKN port1.        */
     /* range: 25:24, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fc_ilkn_rx_llfc_on_ch0;

     /* FcIlknRxLlfcEvery_16_Chs: If set, will extract RxLLFC        */
     /* once every 16 channels (0, 16, 32, 48, ... 240) from the       */
     /* in-band ChFC indicated by link partner. Bit 0                */
     /* corresponds to ILKN port0; bit 1 to ILKN port1.              */
     /* range: 29:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_ilkn_rx_llfc_every_16_chs;

  } __ATTRIBUTE_PACKED__ fc_ilkn_reg;

  /* Fc Ilkn Tx0 Gen Chfc Force: CPU overrides for ILKN ChFC        */
  /* indications.                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4af7 */

     /* FcIlknTx0GenChfcForce: Reserved (set to 0).                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_ilkn_tx0_gen_chfc_force;

  } __ATTRIBUTE_PACKED__ fc_ilkn_tx0_gen_chfc_force_reg;

  /* Fc Ilkn Tx0 Gen Chfc En CFC: CPU overrides for ILKN ChFC       */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4af8 */

     /* FcIlknTx0GenChfcEnCFC: Reserved (set to 1).                  */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD fc_ilkn_tx0_gen_chfc_en_cfc;

  } __ATTRIBUTE_PACKED__ fc_ilkn_tx0_gen_chfc_en_cfc_reg;

  /* Fc Ilkn Tx1 Gen Chfc Force: CPU overrides for ILKN ChFC        */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4af9 */

     /* FcIlknTx1GenChfcForce: Reserved (set to 0).                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_ilkn_tx1_gen_chfc_force;

  } __ATTRIBUTE_PACKED__ fc_ilkn_tx1_gen_chfc_force_reg;

  /* Fc Ilkn Tx1 Gen Chfc En CFC: CPU overrides for ILKN ChFC       */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4afa */

     /* FcIlknTx1GenChfcEnCFC: Reserved (set to 1).                  */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD fc_ilkn_tx1_gen_chfc_en_cfc;

  } __ATTRIBUTE_PACKED__ fc_ilkn_tx1_gen_chfc_en_cfc_reg;

  /* Fc Ilkn Rx0 Chfc Force: CPU overrides for ILKN ChFC            */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4afb */

     /* FcIlknRx0ChfcForce: Reserved (set to 0).                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_ilkn_rx0_chfc_force;

  } __ATTRIBUTE_PACKED__ fc_ilkn_rx0_chfc_force_reg;

  /* Fc Ilkn Rx0 Chfc En CFC: CPU overrides for ILKN ChFC           */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4afc */

     /* FcIlknRx0ChfcEnCFC: Reserved (set to 1).                     */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD fc_ilkn_rx0_chfc_en_cfc;

  } __ATTRIBUTE_PACKED__ fc_ilkn_rx0_chfc_en_cfc_reg;

  /* Fc Ilkn Rx1 Chfc Force: CPU overrides for ILKN ChFC            */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4afd */

     /* FcIlknRx1ChfcForce: Reserved (set to 0).                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_ilkn_rx1_chfc_force;

  } __ATTRIBUTE_PACKED__ fc_ilkn_rx1_chfc_force_reg;

  /* Fc Ilkn Rx1 Chfc En CFC: CPU overrides for ILKN ChFC           */
  /* indications                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4afe */

     /* FcIlknRx1ChfcEnCFC: Reserved (set to 1).                     */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD fc_ilkn_rx1_chfc_en_cfc;

  } __ATTRIBUTE_PACKED__ fc_ilkn_rx1_chfc_en_cfc_reg;

  /* Fc Rx Gen Llfc From Mlf: LLFC debug indication                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4aff */

     /* FcRxGenLlfcFromMlf: Reserved.                                */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_rx_gen_llfc_from_mlf;

  } __ATTRIBUTE_PACKED__ fc_rx_gen_llfc_from_mlf_reg_0;

  /* Fc Rx Gen Llfc From Mlf: LLFC debug indication                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b00 */

     /* FcRxGenLlfcFromMlf: Reserved.                                */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_rx_gen_llfc_from_mlf;

  } __ATTRIBUTE_PACKED__ fc_rx_gen_llfc_from_mlf_reg_1;

  /* Fc Tx Gen Llfc From CFC: LLFC debug indication                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b01 */

     /* FcTxGenLlfcFromCFC: Reserved.                                */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_tx_gen_llfc_from_cfc;

  } __ATTRIBUTE_PACKED__ fc_tx_gen_llfc_from_cfc_reg_0;

  /* Fc Tx Gen Llfc From CFC: LLFC debug indication                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b02 */

     /* FcTxGenLlfcFromCFC: Reserved.                                */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_tx_gen_llfc_from_cfc;

  } __ATTRIBUTE_PACKED__ fc_tx_gen_llfc_from_cfc_reg_1;

  /* Fc Tx Llfc Stop Tx From Cfc: LLFC debug indication             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b03 */

     /* FcTxLlfcStopTxFromCfc: Reserved.                             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_tx_llfc_stop_tx_from_cfc;

  } __ATTRIBUTE_PACKED__ fc_tx_llfc_stop_tx_from_cfc_reg[SOC_PB_NBI_FC_TX_LLFC_STOP_TX_FROM_CFC_REG_MULT_NOF_REGS];

  /* Fc Rx Cbfc From MAL: CBFC Debug indication                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b05 */

     /* FcRxCbfcFromMAL: Reserved.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_rx_cbfc_from_mal;

  } __ATTRIBUTE_PACKED__ fc_rx_cbfc_from_mal_reg;

  /* Fc Ilkn Rx0 CHFC: ChFC Debug indication                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b06 */

     /* FcIlknRx0CHFC: Reserved.                                     */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_ilkn_rx0_chfc;

  } __ATTRIBUTE_PACKED__ fc_ilkn_rx0_chfc_reg;

  /* Fc Ilkn Rx1 CHFC: ChFC Debug indication                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b07 */

     /* FcIlknRx1CHFC: Reserved.                                     */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_ilkn_rx1_chfc;

  } __ATTRIBUTE_PACKED__ fc_ilkn_rx1_chfc_reg;

  /* Fc Ilkn Tx0 Llfc Stop Tx Cnt: ILKN FC debug counter            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b08 */

     /* IlknTx0LlfcStopTxCnt: Reserved. This register is clear       */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_tx0_llfc_stop_tx_cnt;

     /* IlknTx0LlfcStopTxCntOvf: Reserved.                           */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx0_llfc_stop_tx_cnt_ovf;

  } __ATTRIBUTE_PACKED__ fc_ilkn_tx0_llfc_stop_tx_cnt_reg;

  /* Fc Ilkn Tx0 Gen Llfc Cnt: ILKN FC debug counter                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b09 */

     /* IlknTx0GenLlfcCnt: Reserved. This register is clear on       */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_tx0_gen_llfc_cnt;

     /* IlknTx0GenLlfcCntOvf: Reserved.                              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx0_gen_llfc_cnt_ovf;

  } __ATTRIBUTE_PACKED__ fc_ilkn_tx0_gen_llfc_cnt_reg;

  /* Fc Ilkn Rx0 Llfc From Rx Cnt: ILKN FC debug counter            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b0a */

     /* IlknRx0LlfcFromRxCnt: Reserved. This register is clear       */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx0_llfc_from_rx_cnt;

     /* IlknRx0LlfcFromRxCntOvf: Reserved.                           */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx0_llfc_from_rx_cnt_ovf;

  } __ATTRIBUTE_PACKED__ fc_ilkn_rx0_llfc_from_rx_cnt_reg;

  /* Fc Ilkn Tx1 Llfc Stop Tx Cnt: ILKN FC debug counter            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b0b */

     /* IlknTx1LlfcStopTxCnt: Reserved. This register is clear       */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_tx1_llfc_stop_tx_cnt;

     /* IlknTx1LlfcStopTxCntOvf: Reserved.                           */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx1_llfc_stop_tx_cnt_ovf;

  } __ATTRIBUTE_PACKED__ fc_ilkn_tx1_llfc_stop_tx_cnt_reg;

  /* Fc Ilkn Tx1 Gen Llfc Cnt: ILKN FC debug counter                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b0c */

     /* IlknTx1GenLlfcCnt: Reserved. This register is clear on       */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_tx1_gen_llfc_cnt;

     /* IlknTx1GenLlfcCntOvf: Reserved.                              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx1_gen_llfc_cnt_ovf;

  } __ATTRIBUTE_PACKED__ fc_ilkn_tx1_gen_llfc_cnt_reg;

  /* Fc Ilkn Rx1 Llfc From Rx Cnt: ILKN FC debug counter            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b0d */

     /* IlknRx1LlfcFromRxCnt: Reserved. This register is clear       */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx1_llfc_from_rx_cnt;

     /* IlknRx1LlfcFromRxCntOvf: Reserved.                           */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx1_llfc_from_rx_cnt_ovf;

  } __ATTRIBUTE_PACKED__ fc_ilkn_rx1_llfc_from_rx_cnt_reg;

  /* Fc Bist: FC-BIST mechanism allows to drive some of the         */
  /* FC triggers to the MAL and the ILKN cores, using a             */
  /* programable duty cycle.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b0e */

     /* FcBistEnable: Reserved (set to 0).                           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_bist_enable;

     /* FcBistSelect: Reserved (set to 0).                           */
     /* range: 9:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_bist_select;

  } __ATTRIBUTE_PACKED__ fc_bist_reg;

  /* Fc Bist Cycle1: FC-BIST driver signal will have duty           */
  /* cycle defined by FcBistDuty and FcBistCycle.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b0f */

     /* FcBistCycle: Reserved (set to 0).                            */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_bist_cycle;

  } __ATTRIBUTE_PACKED__ fc_bist_cycle_reg[SOC_PB_NBI_FC_BIST_CYCLE_REG_NOF_REGS];

  /* Fc Rtm: Reserved (debug).                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b11 */

     /* FcRtmEnable: Reserved (set to 0).                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_rtm_enable;

     /* FcRtmModeXoff: Reserved (set to 0).                          */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_rtm_mode_xoff;

     /* FcRtmModeMTBP: Reserved (set to 0).                          */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fc_rtm_mode_mtbp;

     /* FcRtmEventSel: Reserved (set to 0).                          */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_rtm_event_sel;

     /* FcRtmChSel: Reserved (set to 0).                             */
     /* range: 19:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rtm_ch_sel;

     /* FcRtmTrigSel: Reserved (set to 0).                           */
     /* range: 26:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_rtm_trig_sel;

  } __ATTRIBUTE_PACKED__ fc_rtm_reg;

  /* Fc Rtm Threshold: Reserved (debug).                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b12 */

     /* FcRtmEventIdleTh: Reserved (set to 0).                       */
     /* range: 19:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_rtm_event_idle_th;

  } __ATTRIBUTE_PACKED__ fc_rtm_threshold_reg;

  /* Fc Rtm Timer: Reserved (debug).                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b13 */

     /* FcRtmTimer: Reserved. This register is clear on read.        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_rtm_timer;

  } __ATTRIBUTE_PACKED__ fc_rtm_timer_reg;

  /* Rx Mlf Status[0..15]: Status Register of Rx MAC Lane           */
  /* FIFO (MLF) [0..11]                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b20 */

     /* RxMlfStatusPort0: Indicates the corresponding lane MLF       */
     /* fullness level of the FIFO.                                  */
     /* range: 6:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mlf_status_port0;

     /* RxMlfOverflowErrPort0: If set, indicates that                */
     /* corresponding lane MLF experienced overflow and data was     */
     /* lost. This register is clear on read.                        */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mlf_overflow_err_port0;

     /* RxMlfStatusPort1: Indicates the corresponding lane MLF       */
     /* fullness level of the FIFO.                                  */
     /* range: 14:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_mlf_status_port1;

     /* RxMlfOverflowErrPort1: If set, indicates that                */
     /* corresponding lane MLF experienced overflow and data was     */
     /* lost. This register is clear on read.                        */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_overflow_err_port1;

     /* RxMlfStatusPort2: Indicates the corresponding lane MLF       */
     /* fullness level of the FIFO.                                  */
     /* range: 22:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_status_port2;

     /* RxMlfOverflowErrPort2: If set, indicates that                */
     /* corresponding lane MLF experienced overflow and data was     */
     /* lost. This register is clear on read.                        */
     /* range: 23:23, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_overflow_err_port2;

     /* RxMlfStatusPort3: Indicates the corresponding lane MLF       */
     /* fullness level of the FIFO.                                  */
     /* range: 30:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_status_port3;

     /* RxMlfOverflowErrPort3: If set, indicates that                */
     /* corresponding lane MLF experienced overflow and data was     */
     /* lost. This register is clear on read.                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_overflow_err_port3;

  } __ATTRIBUTE_PACKED__ rx_mlf_status_reg[SOC_PB_NBI_REGS_RX_MLF_STATUS_REG_ARRAY_SIZE];

  /* Rx Mlf Max Occupancy[0..15]:                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b21 */

     /* RxMlfMaxOccupancyPort0: Indicates the corresponding lane     */
     /* MLF MAX fullness level of the FIFO. This register is         */
     /* clear on read.                                               */
     /* range: 6:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mlf_max_occupancy_port0;

     /* RxMlfWasEmptyPort0: If set, indicates that corresponding     */
     /* lane MLF was empty. This register is clear on read.          */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mlf_was_empty_port0;

     /* RxMlfMaxOccupancyPort1: Indicates the corresponding lane     */
     /* MLF MAX fullness level of the FIFO. This register is         */
     /* clear on read.                                               */
     /* range: 14:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_mlf_max_occupancy_port1;

     /* RxMlfWasEmptyPort1: If set, indicates that corresponding     */
     /* lane MLF was empty. This register is clear on read.          */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_was_empty_port1;

     /* RxMlfMaxOccupancyPort2: Indicates the corresponding lane     */
     /* MLF MAX fullness level of the FIFO. This register is         */
     /* clear on read.                                               */
     /* range: 22:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_max_occupancy_port2;

     /* RxMlfWasEmptyPort2: If set, indicates that corresponding     */
     /* lane MLF was empty. This register is clear on read.          */
     /* range: 23:23, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_was_empty_port2;

     /* RxMlfMaxOccupancyPort3: Indicates the corresponding lane     */
     /* MLF MAX fullness level of the FIFO. This register is         */
     /* clear on read.                                               */
     /* range: 30:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_max_occupancy_port3;

     /* RxMlfWasEmptyPort3: If set, indicates that corresponding     */
     /* lane MLF was empty. This register is clear on read.          */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_was_empty_port3;

  } __ATTRIBUTE_PACKED__ rx_mlf_max_occupancy_reg[SOC_PB_NBI_REGS_RX_MLF_MAX_OCCUPANCY_REG_ARRAY_SIZE];

  /* Tx Mlf Status[0..15]: Status Register of Tx MAC Lane           */
  /* FIFO (MLF) [0..11]                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b22 */

     /* TxMlfStatusPort0: Indicates the corresponding lane MLF       */
     /* fullness level of the FIFO.                                  */
     /* range: 5:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_mlf_status_port0;

     /* TxMlfOverflowErrPort0: If set, indicates that                */
     /* corresponding lane MLF experienced overflow and data was     */
     /* lost. This register is clear on read.                        */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_mlf_overflow_err_port0;

     /* TxMlfStatusPort1: Indicates the corresponding lane MLF       */
     /* fullness level of the FIFO.                                  */
     /* range: 13:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_mlf_status_port1;

     /* TxMlfOverflowErrPort1: If set, indicates that                */
     /* corresponding lane MLF experienced overflow and data was     */
     /* lost. This register is clear on read.                        */
     /* range: 14:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_mlf_overflow_err_port1;

     /* TxMlfStatusPort2: Indicates the corresponding lane MLF       */
     /* fullness level of the FIFO.                                  */
     /* range: 21:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_mlf_status_port2;

     /* TxMlfOverflowErrPort2: If set, indicates that                */
     /* corresponding lane MLF experienced overflow and data was     */
     /* lost. This register is clear on read.                        */
     /* range: 22:22, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_mlf_overflow_err_port2;

     /* TxMlfStatusPort3: Indicates the corresponding lane MLF       */
     /* fullness level of the FIFO.                                  */
     /* range: 29:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_mlf_status_port3;

     /* TxMlfOverflowErrPort3: If set, indicates that                */
     /* corresponding lane MLF experienced overflow and data was     */
     /* lost. This register is clear on read.                        */
     /* range: 30:30, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_mlf_overflow_err_port3;

  } __ATTRIBUTE_PACKED__ tx_mlf_status_reg[SOC_PB_NBI_REGS_TX_MLF_STATUS_REG_ARRAY_SIZE];

  /* Ilkn Rx Controller Status: Status Register for RX ILKN         */
  /* FIFO controllers                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b50 */

     /* IlknRx0Status: Indicates the corresponding lane MLF          */
     /* fullness level of the FIFO.                                  */
     /* range: 9:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx0_status;

     /* IlknRx0OverflowErr: If set, indicates that corresponding     */
     /* lane MLF experienced overflow and data was lost. This        */
     /* register is clear on read.                                   */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx0_overflow_err;

     /* IlknRx1Status: Indicates the corresponding lane MLF          */
     /* fullness level of the FIFO.                                  */
     /* range: 25:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx1_status;

     /* IlknRx1OverflowErr: If set, indicates that corresponding     */
     /* lane MLF experienced overflow and data was lost. This        */
     /* register is clear on read.                                   */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx1_overflow_err;

  } __ATTRIBUTE_PACKED__ ilkn_rx_controller_status_reg;

  /* Ilkn Rx Controller Max Occupancy: Debug indication for         */
  /* ILKN FIFO                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b51 */

     /* IlknRx0MaxOccupancy: Reserved. This register is clear on     */
     /* read.                                                        */
     /* range: 9:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx0_max_occupancy;

     /* IlknRx0WasEmpty: Reserved. This register is clear on         */
     /* read.                                                        */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx0_was_empty;

     /* IlknRx1MaxOccupancy: Reserved. This register is clear on     */
     /* read.                                                        */
     /* range: 25:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx1_max_occupancy;

     /* IlknRx1WasEmpty: Reserved. This register is clear on         */
     /* read.                                                        */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx1_was_empty;

  } __ATTRIBUTE_PACKED__ ilkn_rx_controller_max_occupancy_reg;

  /* Ilkn Tx Controller Status: Status Register for TX ILKN         */
  /* FIFO controllers                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b52 */

     /* IlknTx0Status: Reserved.                                     */
     /* range: 8:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_tx0_status;

     /* IlknTx0OverflowErr: If set, indicates that corresponding     */
     /* lane MLF experienced overflow and data was lost. This        */
     /* register is clear on read.                                   */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx0_overflow_err;

     /* IlknTx1Status: Reserved.                                     */
     /* range: 24:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx1_status;

     /* IlknTx1OverflowErr: If set, indicates that corresponding     */
     /* lane MLF experienced overflow and data was lost. This        */
     /* register is clear on read.                                   */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx1_overflow_err;

  } __ATTRIBUTE_PACKED__ ilkn_tx_controller_status_reg;

  /* Rx[0..1]Ilkn Status: Status Register for ILKN RX port          */
  /* [n] (port0=24-lanes, port1=12-lanes)                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b53 */

     /* RxStatAligned: Reserved. . This register is clear on         */
     /* read.                                                        */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_stat_aligned;

     /* RxStatAlignedRaw: Indicates all the lanes are aligned        */
     /* and deskewed. This register represents the current port      */
     /* status. .                                                    */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_stat_aligned_raw;

     /* RxPortActive: Indicates Rx activity in ILKN port[n]t.        */
     /* Value of <1> indicates there was Rx traffic since the        */
     /* register was last read. This register is clear on read.      */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_port_active;

     /* RxStatMisaligned: When set, it indicates the Meta Frame      */
     /* Synchronization word was not detected simultaneously         */
     /* across all lanes. This register is clear on read.            */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_stat_misaligned;

     /* RxStatAlignedErr: When set, it indicates one of the          */
     /* following occurred: - lane alignment/de-skew failed          */
     /* after several attempts, or - lane alignment/de-skew was      */
     /* lost, i.e. Rx[n]StatAligned was asserted and then            */
     /* negated due to an error. This register is clear on read.     */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_stat_aligned_err;

     /* RxStatCrc24Err: When set, it indicates a mismatch            */
     /* between the expected and received value of the CRC24 in      */
     /* a Control Word has been detected. This register is clear     */
     /* on read.                                                     */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_stat_crc24_err;

     /* RxStatMissSopErr: When set, it indicates a missing SOP       */
     /* has been detected This register is clear on read.            */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_stat_miss_sop_err;

     /* RxStatMissEopErr: When set, it indicates a missing EOP       */
     /* has been detected This register is clear on read.            */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_stat_miss_eop_err;

     /* RxStatOverflowErr: When it is a value of 1, it indicates     */
     /* that an overflow in the RX FIFO has occurred. This           */
     /* register is clear on read.                                   */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_stat_overflow_err;

     /* RxStatBurstmaxErr: When set, it indicates a burst (i.e.      */
     /* a sequence of Data Words between two Control Words) was      */
     /* detected that was longer than the value of BurstMax          */
     /* specified by Rx[n]Burstmax. This register is clear on        */
     /* read.                                                        */
     /* range: 24:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_stat_burstmax_err;

     /* RxStatBurstErr: When set, one of the following occurred:     */
     /* - a BurstShort violation was detected, or - a burst          */
     /* transfer length error was detected Burst Errors are          */
     /* treated like CRC24 errors, i.e., all open packets are        */
     /* marked as being in error, etc. To prevent these errors,      */
     /* the transmitter must be programmed appropriately. This       */
     /* register is clear on read.                                   */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_stat_burst_err;

     /* RxLpIfcStatus: Indicates the IFC status as reported by       */
     /* link partner through the diagwords of any of the lanes.      */
     /* range: 29:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_lp_ifc_status;

  } __ATTRIBUTE_PACKED__ rx_ilkn_status_reg[SOC_PB_NBI_REGS_RX_ILKN_STATUS_REG_ARRAY_SIZE];

  /* Tx[0..1]Ilkn Status: Status Register for ILKN TX port          */
  /* [n] (port0=24-lanes, port1=12-lanes)                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b54 */

     /* TxOvfout: When setm it indicates that an overflow has        */
     /* occurred or is imminent (should never be asserted) This      */
     /* register is clear on read.                                   */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_ovfout;

     /* TxPortActive: Indicates Tx activity in ILKN port[n]t.        */
     /* Value of <1> indicates there was Tx traffic since the        */
     /* register was last read. This register is clear on read.      */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_port_active;

     /* TxStatUnderflowErr: When set, it indicates serial data       */
     /* rate is faster than the maximum data rate on the Local       */
     /* bus. (The ilkn port had no data to transmit) This            */
     /* register is clear on read.                                   */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_stat_underflow_err;

     /* TxStatBurstErr: When set, it indicates a burst less than     */
     /* BurstShort, not ending with EOP, was written into the        */
     /* TX. This register is clear on read.                          */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_stat_burst_err;

     /* TxStatOverflowErr: Indicates the overflow occurred in        */
     /* the TX FIFO inside the IIPC. This output should never        */
     /* get asserted and indicates a critical failure. This          */
     /* register is clear on read.                                   */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_stat_overflow_err;

  } __ATTRIBUTE_PACKED__ tx_ilkn_status_reg[SOC_PB_NBI_REGS_TX_ILKN_STATUS_REG_ARRAY_SIZE];

  /* Rx Port Ovf Port 0 to31:                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b57 */

     /* RxPortOvfPort0_31: This register reflects the overflow       */
     /* bits of all the RX MLF NIF ports. To clear this              */
     /* indication the relevant RxMlfStatus register should be       */
     /* read. This register doesn't include ILKN ports. Bit 0        */
     /* reflects port0.                                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_port_ovf_port0_31;

  } __ATTRIBUTE_PACKED__ rx_port_ovf_port_0_to31_reg;

  /* Rx Port Ovf Port32 63:                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b58 */

     /* RxPortOvfPort32_63: This register reflects the overflow      */
     /* bits of all the RX MLF NIF ports. To clear this              */
     /* indication the relevant RxMlfStatus register should be       */
     /* read. This register doesn't include ILKN ports. Bit 0        */
     /* reflects port32.                                             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_port_ovf_port32_63;

  } __ATTRIBUTE_PACKED__ rx_port_ovf_port32_63_reg;

  /* Rx FIFO Discard Short Err Packet Port 0 To 31: This            */
  /* register indicates data was thrown due to the discard          */
  /* short error packet in ports 0-31.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b59 */

     /* RxDiscardShortErrPacketPort0 31: This register indicates     */
     /* data was thrown due to the discard short error packet in     */
     /* ports 0-31. Bit0 corresponds to port0. This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_discard_short_err_packet_port0_31;

  } __ATTRIBUTE_PACKED__ rx_fifo_discard_short_err_packet_port_0_to_31_reg;

  /* Rx FIFO Discard Short Err Packet Port 32 To 63: This           */
  /* register indicates data was thrown due to the discard          */
  /* short error packet in ports 0-31.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b5a */

     /* RxDiscardShortErrPacketPort32 63: This register              */
     /* indicates data was thrown due to the discard short error     */
     /* packet in ports 0-31. Bit0 corresponds to port 32. This      */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_discard_short_err_packet_port32_63;

  } __ATTRIBUTE_PACKED__ rx_fifo_discard_short_err_packet_port_32_to_63_reg;

  /* Link Partner Lanes Status : Lane Status Messaging inputs       */
  /* as received from the link partner. Bit 33 in the               */
  /* Diagnostic Word for the respective lane.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b5b */

     /* IlknRxStatDiagwordLanesStat: Lane Status Messaging           */
     /* inputs. According to bit 33 in the Diagnostic Word for       */
     /* the respective lane. It reflects the health of this lane     */
     /* at the link partner.                                         */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_diagword_lanes_stat;

  } __ATTRIBUTE_PACKED__ link_partner_lanes_status_reg;

  /* Link Partner Interface Status : Interface Status               */
  /* Messaging input as received from the link partner. Bit         */
  /* 32 in the Diagnostic Word of each lane.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b5c */

     /* IlknRxStatDiagwordInterfaceStat: Interface Status            */
     /* Messaging input. Sets bit 32 in the Diagnostic Word of       */
     /* each lane. It represents the health of the entire            */
     /* interface at the link partner.1 means healthy.               */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_diagword_interface_stat;

  } __ATTRIBUTE_PACKED__ link_partner_interface_status_reg;

  /* CRC32 Lane Valid Indication: Diagnostic Word CRC32             */
  /* Valid. When bit X is a value of 1, it indicates that the       */
  /* CRC32 in the most recently received Diagnostic Word of         */
  /* the respective lane is as expected .                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b5d */

     /* IlknRxStatCrc32Valid: Diagnostic Word CRC32 Valid. When      */
     /* bit X is a value of 1, it indicates that the CRC32 in        */
     /* the most recently received Diagnostic Word the               */
     /* respective lane is as expected .                             */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_crc32_valid;

  } __ATTRIBUTE_PACKED__ crc32_lane_valid_indication_reg;

  /* CRC32 Lane Err Indication : Diagnostic Word CRC32              */
  /* Invalid/Error. When bit X is a value of 1, it indicates        */
  /* that the CRC32 in the most recently received Diagnostic        */
  /* Word of the respective lane is NOT as expected.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b5e */

     /* IlknRxStatCrc32Err: Diagnostic Word CRC32 Invalid/Error.     */
     /* When bit X is a value of 1, it indicates that the CRC32      */
     /* in the most recently received Diagnostic Word the            */
     /* respective lane is NOT as expected. This register is         */
     /* clear on read.                                               */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_crc32_err;

  } __ATTRIBUTE_PACKED__ crc32_lane_err_indication_reg;

  /* Lane Synchronization Achieved : Word Boundary                  */
  /* Synchronized. When bit X is a value of 1, the respective       */
  /* lane is synched.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b5f */

     /* IlknRxStatLanesSynced: Word Boundary Synchronized was        */
     /* achieved. When bit X is a value of 1, the respective         */
     /* lane is synched.                                             */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_lanes_synced;

  } __ATTRIBUTE_PACKED__ lane_synchronization_achieved_reg;

  /* Lane Synchronization Err : Word Boundary Synchronization       */
  /* Error. When bit X is a value of 1, the respective lane         */
  /* is NOT synched.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b60 */

     /* IlknRxStatLanesSyncedErr: Word Boundary Synchronization      */
     /* Error. When bit X is a value of 1, the respective lane       */
     /* is NOT synched.                                              */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_lanes_synced_err;

  } __ATTRIBUTE_PACKED__ lane_synchronization_err_reg;

  /* Lane Framing Err : Framing Error. When bit X is a value        */
  /* of 1, an illegal framing pattern was detected in the           */
  /* respective lane after being Word Boundary Synchronized         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b61 */

     /* IlknRxStatLanesFramingErr: Framing Error. When bit X is      */
     /* a value of 1, an illegal framing pattern was detected in     */
     /* the respective lane after being Word Boundary                */
     /* Synchronized                                                 */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_lanes_framing_err;

  } __ATTRIBUTE_PACKED__ lane_framing_err_reg;

  /* Lane Bad Framing Layer Err : Bad Framing Layer Block           */
  /* Type Error. When bit X is a value of 1, an illegal             */
  /* framing layer block type was detected in the respective        */
  /* lane.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b62 */

     /* IlknRxStatLanesBadTypeErr: Bad Framing Layer Block Type      */
     /* Error. When bit X is a value of 1, an illegal framing        */
     /* layer block type was detected in the respective lane.        */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_lanes_bad_type_err;

  } __ATTRIBUTE_PACKED__ lane_bad_framing_layer_err_reg;

  /* Lane Meta Frame Sync Word Err : Meta Frame                     */
  /* Synchronization Word Error. When bit X is a value of 1,        */
  /* the Meta Frame Synchronization Word in the respective          */
  /* lane contained an error.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b63 */

     /* IlknRxStatLanesMfErr: Meta Frame Synchronization Word        */
     /* Error. When bit X is a value of 1, the Meta Frame            */
     /* Synchronization Word in the respective lane contained an     */
     /* error.                                                       */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_lanes_mf_err;

  } __ATTRIBUTE_PACKED__ lane_meta_frame_sync_word_err_reg;

  /* Lane Scrambler state Err : Scrambler State Control Word        */
  /* Error. When bit X is a value of 1, the Scrambler State         */
  /* Control Word in the respective lane contained an error.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b64 */

     /* IlknRxStatLanesDescramErr: Scrambler State Control Word      */
     /* Error. When bit X is a value of 1, the Scrambler State       */
     /* Control Word in the respective lane contained an error.      */
     /* This register is clear on read.                              */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_lanes_descram_err;

  } __ATTRIBUTE_PACKED__ lane_scrambler_state_err_reg;

  /* Lane Meta Frame Length Err : Meta Frame Length Error.          */
  /* When bit X is a value of 1, the length of the Meta Frame       */
  /* being received in the respective lane is different from        */
  /* the expected length.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b65 */

     /* IlknRxStatLanesMfLenErr: Meta Frame Length Error. When       */
     /* bit X is a value of 1, the length of the Meta Frame          */
     /* being received in the respective lane is different from      */
     /* the expected length.                                         */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_lanes_mf_len_err;

  } __ATTRIBUTE_PACKED__ lane_meta_frame_length_err_reg;

  /* Lane Meta Frame Repeat Err : Meta Frame Consecutive            */
  /* Error. When bit X is a value of 1, one or more of the          */
  /* following occurred on the respective lane:- four               */
  /* consecutive Meta Frame Synchronization Words contained         */
  /* errors- three consecutive Scrambler State Control Words        */
  /* contained errors                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b66 */

     /* IlknRxStatLanesMfRepeatErr: Meta Frame Consecutive           */
     /* Error. When bit X is a value of 1, one or more of the        */
     /* following occurred on the respective lane: - four            */
     /* consecutive Meta Frame Synchronization Words contained       */
     /* errors - three consecutive Scrambler State Control Words     */
     /* contained errors                                             */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_lanes_mf_repeat_err;

  } __ATTRIBUTE_PACKED__ lane_meta_frame_repeat_err_reg;

  /* Rx Ilkn Status Parity Error: Status Register for ILKN RX       */
  /* port 0 - parity Error                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b67 */

     /* IlknRxStatLanesParityErr: RX Lane Parity Error. This         */
     /* signal indicates that parity error happened in buffer of     */
     /* the corresponding ILKN RX lanes. This register is clear      */
     /* on read.                                                     */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_lanes_parity_err;

     /* IlknRx0StatBuffParityErr: RX Port0 Parity Error. This        */
     /* signal indicates a parity error occurred in the buffer       */
     /* of ILKN port0. This register is clear on read.               */
     /* range: 24:24, access type: RO, default value: 0x0            */
     /* IlknRx1StatBuffParityErr: RX Port1 Parity Error. This        */
     /* signal indicates a parity error occurred in the buffer       */
     /* of ILKN port1. This register is clear on read.               */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx_stat_buff_parity_err[SOC_PB_REG_NOF_ILKNS];

  } __ATTRIBUTE_PACKED__ rx_ilkn_status_parity_error_reg;

  /* Tx0 Ilkn Status Parity Error: Status Register for ILKN         */
  /* TX port 0 - parity Error                                       */
  /* Tx1 Ilkn Status Parity Err: Status Register for ILKN TX        */
  /* port 1 - parity Error                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b68 */

     /* IlknTx0StatLanesParityErr: TX Lane Parity Error. This        */
     /* signal indicates that parity error happened in buffer of     */
     /* the corresponding ILKN TX lanes. This register is clear      */
     /* on read.                                                     */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_tx_stat_lanes_parity_err;

     /* IlknTx0StatBuffParityErr: TX Port0 Parity Error. This        */
     /* signal indicates a parity error occured in the buffer of     */
     /* ILKN port0. This register is clear on read.                  */
     /* range: 24:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx_stat_buff_parity_err;

  } __ATTRIBUTE_PACKED__ tx_ilkn_status_parity_error_reg[SOC_PB_REG_NOF_ILKNS];

 
  /* Ilkn Rx Multiple Use Bits Status: Configuration Register       */
  /* for the ILKN TX ports - enables to decommission a              */
  /* certain lane and to limit the port not to use all its          */
  /* available lanes.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b6a */

     /* IlknRx0MultipleUseBitsValue: The value receives in the       */
     /* multiple-use bits of the Interlaken Control Word             */
     /* bits[31:24] of Ilkn port0.                                   */
     /* range: 7:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx0_multiple_use_bits_value;

     /* IlknRx1MultipleUseBitsValue: The value receives in the       */
     /* multiple-use bits of the Interlaken Control Word             */
     /* bits[31:24] of Ilkn port1.                                   */
     /* range: 15:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx1_multiple_use_bits_value;

  } __ATTRIBUTE_PACKED__ ilkn_rx_multiple_use_bits_status_reg;

  /* Num Thrown Bursts Counter Rx[0..15]Port0: Number of            */
  /* bursts thrown in this NIF port (not written to the FIFO        */
  /* at all). Counted by gtimer or count from last read.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4b70 */

     /* NumThrownBurstsCounterRxPort0: Counter result. This          */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_rx_port0;

     /* NumThrownBurstsCounterRxPort0Ovf: Overflow: In gtimer -      */
     /* indicates the count is over. The overflow can be seen        */
     /* when the counter value is all ones. Not in gtimer -          */
     /* indicates overflow has occurred.                             */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_rx_port0_ovf;

  } __ATTRIBUTE_PACKED__ num_thrown_bursts_counter_rx_port_reg[SOC_PB_NBI_REGS_NUM_THROWN_BURSTS_COUNTER_RX_PORT_REG_ARRAY_SIZE][SOC_PB_NBI_NUM_THROWN_BURSTS_COUNTER_RX_PORT_REG_NOF_REGS];

  /* Num Thrown Bursts Counter Rx Ilkn Port0: Number of             */
  /* bursts thrown in this NIF port (not written to the FIFO        */
  /* at all). Counted by gtimer or count from last read.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bb0 */

     /* NumThrownBurstsCounterRxIlknPort0: Counter result. This      */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_rx_ilkn_port0;

     /* NumThrownBurstsCounterRxIlknPort0Ovf: Overflow: In           */
     /* gtimer - indicates the count is over. The overflow can       */
     /* be seen when the counter value is all ones. Not in           */
     /* gtimer - indicates overflow has occurred.                    */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD num_thrown_bursts_counter_rx_ilkn_port0_ovf;

  } __ATTRIBUTE_PACKED__ num_thrown_bursts_counter_rx_ilkn_port_reg[SOC_PB_NBI_NUM_THROWN_BURSTS_COUNTER_RX_ILKN_PORT_REG_NOF_REGS];

  /* Rx Num Thrown Eops Counter: This counter counts the            */
  /* number of EOPs thrown in all the RX NIF ports. The idea        */
  /* behind this counter is to provide information about            */
  /* thrown packets (not bursts), since the bursts counters         */
  /* (one for each port) does not give information about the        */
  /* number of packets lost, and we might throw a whole             */
  /* packet, which will not be counted in the IRE.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bb2 */

     /* RxNumThrownEops: Counter result. This register is clear      */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_num_thrown_eops;

     /* RxNumThrownEopsOvf: Overflow: In gtimer - indicates the      */
     /* count is over. The overflow can be seen when the counter     */
     /* value is all ones. Not in gtimer - indicates overflow        */
     /* has occurred.                                                */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_num_thrown_eops_ovf;

  } __ATTRIBUTE_PACKED__ rx_num_thrown_eops_counter_reg;

  /* Txi Irdy: Reserved (debug).                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bb3 */

     /* TxiIrdyCnt: Reserved. This register is clear on read.        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD txi_irdy_cnt;

     /* TxiIrdyCntOvf: Reserved.                                     */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD txi_irdy_cnt_ovf;

  } __ATTRIBUTE_PACKED__ txi_irdy_reg;

  /* FIFO Write Pointer MLF Select: Reserved (debug).               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bb4 */

     /* ChosenRxPortForWritePointer: Reserved.                       */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD chosen_rx_port_for_write_pointer;

     /* ChosenTxPortForWritePointer: Reserved.                       */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD chosen_tx_port_for_write_pointer;

  } __ATTRIBUTE_PACKED__ fifo_write_pointer_mlf_select_reg;

  /* FIFO Write Pointer Result: Reserved (debug).                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bb5 */

     /* WritePointerOfChosenRxPort: Reserved.                        */
     /* range: 9:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD write_pointer_of_chosen_rx_port;

     /* WritePointerOfChosenTxPort: Reserved.                        */
     /* range: 19:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD write_pointer_of_chosen_tx_port;

  } __ATTRIBUTE_PACKED__ fifo_write_pointer_result_reg;

  /* FIFO Status Histogram Ports: Reserved (debug).                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bb6 */

     /* FifoStatusHistogramPort0Mlf: Reserved.                       */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fifo_status_histogram_port0_mlf;

     /* FifoStatusHistogramPort1Mlf: Reserved.                       */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fifo_status_histogram_port1_mlf;

  } __ATTRIBUTE_PACKED__ fifo_status_histogram_ports_reg;

  /* FIFO Status Histogram Port0 Th: Reserved.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bb7 */

     /* FifoStatusHistogramPort0Th0: Reserved.                       */
     /* range: 9:0, access type: RW, default value: 0x10             */
     SOC_PETRA_REG_FIELD fifo_status_histogram_port_th0;

     /* FifoStatusHistogramPort0Th1: Reserved.                       */
     /* range: 19:10, access type: RW, default value: 0x20           */
     SOC_PETRA_REG_FIELD fifo_status_histogram_port_th1;

     /* FifoStatusHistogramPort0Th2: Reserved.                       */
     /* range: 29:20, access type: RW, default value: 0x30           */
     SOC_PETRA_REG_FIELD fifo_status_histogram_port_th2;

  } __ATTRIBUTE_PACKED__ fifo_status_histogram_port_th_reg[SOC_PB_NBI_FIFO_STATUS_HIST_NOF_PORTS];

  /* FIFO Status Histogram Port0 Bin0: Reserved.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bb8 */

     /* FifoStatusHistogramPort0Bin0: Reserved. This register is     */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fifo_status_histogram_port_bin;

     /* FifoStatusHistogramPort0Bin0Ovf: Reserved.                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fifo_status_histogram_port_bin_ovf;

  } __ATTRIBUTE_PACKED__ fifo_status_histogram_port_bin_reg[SOC_PB_NBI_FIFO_STATUS_HIST_NOF_PORTS][SOC_PB_NBI_FIFO_STATUS_HISTOGRAM_PORT0_BIN_REG_NOF_REGS];

  /* Rx Round Robin Req: Reserved.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bc1 */

     /* ReqMal0To6: Reserved.                                        */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD req_mal0_to6;

     /* ReqMal8To14: Reserved.                                       */
     /* range: 27:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD req_mal8_to14;

     /* RdMlfIndex: Reserved.                                        */
     /* range: 31:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rd_mlf_index;

  } __ATTRIBUTE_PACKED__ rx_round_robin_req_reg;

  /* Rx Ilkn Crc32 Err Cnt: Count the number of CRC32 error         */
  /* events in all the ILKN lanes.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bc2 */

     /* RxIlknCrc32ErrCnt: Counter result. This register is          */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_ilkn_crc32_err_cnt;

     /* RxIlknCrc32ErrCntOvf: Overflow: In gtimer - indicates        */
     /* the count is over. The overflow can be seen when the         */
     /* counter value is all ones. Not in gtimer - indicates         */
     /* overflow has occurred.                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ilkn_crc32_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ rx_ilkn_crc32_err_cnt_reg;

  /* Rx Ilkn0 Crc24 Err Cnt: Count the number of CRC24 events       */
  /* in ILKN RX port 0.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bc3 */

     /* RxIlkn0Crc24ErrCnt: Counter result. This register is         */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_ilkn0_crc24_err_cnt;

     /* RxIlkn0Crc24ErrCntOvf: Overflow: In gtimer - indicates       */
     /* the count is over. The overflow can be seen when the         */
     /* counter value is all ones. Not in gtimer - indicates         */
     /* overflow has occurred.                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ilkn0_crc24_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ rx_ilkn0_crc24_err_cnt_reg;

  /* Rx Ilkn0 Burst Err Cnt: Count the number of burst error        */
  /* events in ILKN RX port 0. A burst error occurs when a          */
  /* burst arrives which is shorter than burst short or             */
  /* longer than burst max.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bc4 */

     /* RxIlkn0BurstErrCnt: Counter result. This register is         */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_ilkn0_burst_err_cnt;

     /* RxIlkn0BurstErrCntOvf: Overflow: In gtimer - indicates       */
     /* the count is over. The overflow can be seen when the         */
     /* counter value is all ones. Not in gtimer - indicates         */
     /* overflow has occurred.                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ilkn0_burst_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ rx_ilkn0_burst_err_cnt_reg;

  /* Rx Ilkn0 Miss Sop Err Cnt: Count the number of events in       */
  /* which a missing SOP was detected in ILKN RX port 0.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bc5 */

     /* RxIlkn0MissSopErrCnt: Counter result. This register is       */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_ilkn0_miss_sop_err_cnt;

     /* RxIlkn0MissSopErrCntOvf: Overflow: In gtimer - indicates     */
     /* the count is over. The overflow can be seen when the         */
     /* counter value is all ones. Not in gtimer - indicates         */
     /* overflow has occurred.                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ilkn0_miss_sop_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ rx_ilkn0_miss_sop_err_cnt_reg;

  /* Rx Ilkn0 Miss Eop Err Cnt: Count the number of events in       */
  /* which a missing EOP was detected in ILKN RX port 0.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bc6 */

     /* RxIlkn0MissEopErrCnt: Counter result. This register is       */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_ilkn0_miss_eop_err_cnt;

     /* RxIlkn0MissEopErrCntOvf: Overflow: In gtimer - indicates     */
     /* the count is over. The overflow can be seen when the         */
     /* counter value is all ones. Not in gtimer - indicates         */
     /* overflow has occurred.                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ilkn0_miss_eop_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ rx_ilkn0_miss_eop_err_cnt_reg;

  /* Rx Ilkn0 Misaligned Cnt: Count the number of events in         */
  /* which there was a bad alignment error in ILKN RX port 0.       */
  /* Bad Alignment Error means the Meta Frame Synchronization       */
  /* word was not detected simultaneously across all lanes.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bc7 */

     /* RxIlkn0MisalignedCnt: Counter result. This register is       */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_ilkn0_misaligned_cnt;

     /* RxIlkn0MisalignedCntOvf: Overflow: In gtimer - indicates     */
     /* the count is over. The overflow can be seen when the         */
     /* counter value is all ones. Not in gtimer - indicates         */
     /* overflow has occurred.                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ilkn0_misaligned_cnt_ovf;

  } __ATTRIBUTE_PACKED__ rx_ilkn0_misaligned_cnt_reg;

  /* Rx Ilkn1 Crc24 Err Cnt: Count the number of CRC24 events       */
  /* in ILKN RX port 1.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bc8 */

     /* RxIlkn1Crc24ErrCnt: Counter result. This register is         */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_ilkn1_crc24_err_cnt;

     /* RxIlkn1Crc24ErrCntOvf: Overflow: In gtimer - indicates       */
     /* the count is over. The overflow can be seen when the         */
     /* counter value is all ones. Not in gtimer - indicates         */
     /* overflow has occurred.                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ilkn1_crc24_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ rx_ilkn1_crc24_err_cnt_reg;

  /* Rx Ilkn1 Burst Err Cnt: Count the number of burst error        */
  /* events in ILKN RX port 1. A burst error occurs when a          */
  /* burst arrives which is shorter than burst short or             */
  /* longer than burst max.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bc9 */

     /* RxIlkn1BurstErrCnt: Counter result. This register is         */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_ilkn1_burst_err_cnt;

     /* RxIlkn1BurstErrCntOvf: Overflow: In gtimer - indicates       */
     /* the count is over. The overflow can be seen when the         */
     /* counter value is all ones. Not in gtimer - indicates         */
     /* overflow has occurred.                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ilkn1_burst_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ rx_ilkn1_burst_err_cnt_reg;

  /* Rx Ilkn1 Miss Sop Err Cnt: Count the number of events in       */
  /* which a missing SOP was detected in ILKN RX port 1.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bca */

     /* RxIlkn1MissSopErrCnt: Counter result. This register is       */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_ilkn1_miss_sop_err_cnt;

     /* RxIlkn1MissSopErrCntOvf: Overflow: In gtimer - indicates     */
     /* the count is over. The overflow can be seen when the         */
     /* counter value is all ones. Not in gtimer - indicates         */
     /* overflow has occurred.                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ilkn1_miss_sop_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ rx_ilkn1_miss_sop_err_cnt_reg;

  /* Rx Ilkn1 Miss Eop Err Cnt: Count the number of events in       */
  /* which a missing EOP was detected in ILKN RX port 1.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bcb */

     /* RxIlkn1MissEopErrCnt: Counter result. This register is       */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_ilkn1_miss_eop_err_cnt;

     /* RxIlkn1MissEopErrCntOvf: Overflow: In gtimer - indicates     */
     /* the count is over. The overflow can be seen when the         */
     /* counter value is all ones. Not in gtimer - indicates         */
     /* overflow has occurred.                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ilkn1_miss_eop_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ rx_ilkn1_miss_eop_err_cnt_reg;

  /* Rx Ilkn1 Misaligned Cnt: Counts the number of events in        */
  /* which there was a bad alignment error in ILKN RX port 1.       */
  /* Bad Alignment Error means the Meta Frame Synchronization       */
  /* word was not detected simultaneously across all lanes.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bcc */

     /* RxIlkn1MisalignedCnt: Counter result. This register is       */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_ilkn1_misaligned_cnt;

     /* RxIlkn1MisalignedCntOvf: Overflow: In gtimer - indicates     */
     /* the count is over. The overflow can be seen when the         */
     /* counter value is all ones. Not in gtimer - indicates         */
     /* overflow has occurred.                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ilkn1_misaligned_cnt_ovf;

  } __ATTRIBUTE_PACKED__ rx_ilkn1_misaligned_cnt_reg;

  /* Ilkn Invert Polarity Signals: Reserved.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bcd */

     /* IlknInvertStatRxDiagwordIntfstat_Polarity: Reserved.         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_invert_stat_rx_diagword_intfstat_polarity;

     /* IlknInvertStatRxFcStat_Polarity: Reserved.                   */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_invert_stat_rx_fc_stat_polarity;

     /* IlknInvertStatRxFcStatBBB_Polarity: Reserved.                */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_invert_stat_rx_fc_stat_bbb_polarity;

     /* IlknInvertCtlTxDiagwordLanestat_Polarity: Reserved.          */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_invert_ctl_tx_diagword_lanestat_polarity;

     /* IlknInvertCtlTxDiagwordIntfstat_Polarity: Reserved.          */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_invert_ctl_tx_diagword_intfstat_polarity;

     /* IlknInvertCtlTxDiagwordIntfstatBBB_Polarity: Reserved.       */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_invert_ctl_tx_diagword_intfstat_bbb_polarity;

     /* IlknInvertCtlTxFcStat_Polarity: Reserved.                    */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_invert_ctl_tx_fc_stat_polarity;

     /* IlknInvertCtlTxFcStatBBB_Polarity: Reserved.                 */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_invert_ctl_tx_fc_stat_bbb_polarity;

     /* IlknInvertStatRxMubits_Polarity: Reserved.                   */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_invert_stat_rx_mubits_polarity;

     /* IlknInvertStatRxMubitsBBB_Polarity: Reserved.                */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_invert_stat_rx_mubits_bbb_polarity;

     /* IlknInvertCtlTxMubits_Polarity: Reserved.                    */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_invert_ctl_tx_mubits_polarity;

     /* IlknInvertCtlTxMubitsBBB_Polarity: Reserved.                 */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_invert_ctl_tx_mubits_bbb_polarity;

  } __ATTRIBUTE_PACKED__ ilkn_invert_polarity_signals_reg;

  /* BIST general configuration: BIST mechanism is capable of       */
  /* generating and checking traffic to test the NIF.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bd0 */

     /* BistGeneratorEnable: Reserved.                               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_generator_enable;

     /* BistCheckerEnable: Reserved.                                 */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_checker_enable;

     /* BistMode: Reserved.                                          */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_mode;

     /* BistContextsMask: Reserved.                                  */
     /* range: 23:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_contexts_mask;

     /* BistChChosingMethod: Reserved.                               */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_ch_chosing_method;

     /* BistBtChosingMethod: Reserved.                               */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_bt_chosing_method;

  } __ATTRIBUTE_PACKED__ bist_general_configuration_reg;

  /* Bist RX Shaper: BIST Checker configuration.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bd1 */

     /* BistRxShaperCycle: Reserved.                                 */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_shaper_cycle;

     /* BistRxShaperDuty: Reserved.                                  */
     /* range: 23:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_shaper_duty;

     /* BistRxShaperForce: Reserved.                                 */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_shaper_force;

     /* BistRxShaperClear: Reserved.                                 */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_shaper_clear;

  } __ATTRIBUTE_PACKED__ bist_rx_shaper_reg;

  /* Bist TX Bursts Threshold: BIST Generator Configuration.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bd2 */

     /* BistTxBurstTh: Reserved.                                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_burst_th;

  } __ATTRIBUTE_PACKED__ bist_tx_bursts_threshold_reg[SOC_PB_NBI_BIST_TX_BURSTS_THRESHOLD_REG_MULT_NOF_REGS];

  /* BIST TX bursts counter: BIST Generator Status                  */
  /* Indication.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bd4 */

     /* BistTxBurstCnt: Reserved.                                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_burst_cnt;

  } __ATTRIBUTE_PACKED__ bist_tx_bursts_counter_reg[SOC_PB_NBI_BIST_TX_BURSTS_COUNTER_REG_MULT_NOF_REGS];

  /* BIST TX Additional counter: BIST Generator Status              */
  /* Indication.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bd6 */

     /* BistTxCrcErrBurstsCnt: Reserved.                             */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_crc_err_bursts_cnt;

     /* BistTxFlowCnt: Reserved.                                     */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_tx_flow_cnt;

  } __ATTRIBUTE_PACKED__ bist_tx_additional_counter_reg;

  /* BIST Seed: BIST Generator Configuration.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bd7 */

     /* BistSeed: Reserved.                                          */
     /* range: 13:0, access type: RW, default value: 0x155a          */
     SOC_PETRA_REG_FIELD bist_seed;

  } __ATTRIBUTE_PACKED__ bist_seed_reg;

  /* BIST Flow First descriptor[0..3]: BIST Generator Flow          */
  /* register (part 1)                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bd8 */

     /* FlowNumOfBursts: Reserved.                                   */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD flow_num_of_bursts;

     /* FlowDataType: Reserved.                                      */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD flow_data_type;

     /* FlowCreateErr: Reserved. If set, the BIST generator        */
     /* will set the error field                                */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flow_create_err;

     /* FlowClass: Reserved.                                         */
     /* range: 19:16, access type: RW, default value: 0xf            */
     SOC_PETRA_REG_FIELD flow_class;

     /* FlowConstantCh: Reserved.                                    */
     /* range: 27:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flow_constant_ch;

     /* FlowConstantBt: Reserved.                                    */
     /* range: 30:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flow_constant_bt;

  } __ATTRIBUTE_PACKED__ bist_flow_first_descriptor_reg[SOC_PB_NBI_REGS_BIST_FLOW_FIRST_DESCRIPTOR_REG_ARRAY_SIZE];

  /* BIST Flow Second descriptor [0..3] : BIST Generator Flow       */
  /* register (part 2)                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4bd9 */

     /* FlowMinBurstSize: Reserved.                                  */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD flow_min_burst_size;

     /* FlowBurstSizeMask: Reserved.                                 */
     /* range: 29:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flow_burst_size_mask;

  } __ATTRIBUTE_PACKED__ bist_flow_second_descriptor_reg[SOC_PB_NBI_REGS_BIST_FLOW_SECOND_DESCRIPTOR_REG_ARRAY_SIZE];

  /* BIST RX OK bursts counter: BIST Checker Indications.           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4be0 */

     /* BistRxOkBurstsCnt: Reserved.                                 */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_ok_bursts_cnt;

  } __ATTRIBUTE_PACKED__ bist_rx_ok_bursts_counter_reg[SOC_PB_NBI_BIST_RX_OK_BURSTS_COUNTER_REG_MULT_NOF_REGS];

  /* BIST RX counters 1: BIST Checker Indications.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4be2 */

     /* BistRxErrLengthBurstsCnt: Reserved.                          */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_err_length_bursts_cnt;

     /* BistRxErrBurstIndexCnt: Reserved.                            */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_err_burst_index_cnt;

  } __ATTRIBUTE_PACKED__ bist_rx_counters_1_reg;

  /* BIST RX counters 2: BIST Checker Indications.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4be3 */

     /* BistRxErrBctCnt: Reserved.                                   */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_err_bct_cnt;

     /* BistRxErrDataCnt: Reserved.                                  */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_err_data_cnt;

  } __ATTRIBUTE_PACKED__ bist_rx_counters_2_reg;

  /* BIST RX counters 3: BIST Checker Indications.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4be4 */

     /* BistRxErrInCrcErrCnt: Reserved.                              */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_err_in_crc_err_cnt;

     /* BistRxErrSobCnt: Reserved.                                   */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_err_sob_cnt;

  } __ATTRIBUTE_PACKED__ bist_rx_counters_3_reg;

  /* BIST RX flow counter: BIST Checker Indications.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4be5 */

     /* BistRxFlowCnt: Reserved.                                     */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_flow_cnt;

  } __ATTRIBUTE_PACKED__ bist_rx_flow_counter_reg;

  /* BIST Status: BIST Checker Indications.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4be6 */

     /* BistTxDone: Reserved.                                        */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_tx_done;

     /* BistRxDone: Reserved.                                        */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_rx_done;

     /* BistRxErrLength: Reserved.                                   */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_rx_err_length;

     /* BistRxErrIndex: Reserved.                                    */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_err_index;

     /* BistRxErrBct: Reserved.                                      */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_err_bct;

     /* BistRxErrData: Reserved.                                     */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_err_data;

     /* BistRxErrCrc: Reserved.                                      */
     /* range: 24:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_err_crc;

     /* BistRxErrSob: Reserved.                                      */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_err_sob;

  } __ATTRIBUTE_PACKED__ bist_status_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_NBI_REGS;
/* Block definition: IRE 	 */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in the IRE.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2400 */

     /* CpuIfErrDataArrived: If set, then erroneous data has         */
     /* arrived from the CPU (data descriptor error bit was          */
     /* set).                                                        */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_err_data_arrived;

     /* CpuIf 32bytesPackErr: If set, then an error flag was         */
     /* inserted and accompanied the corresponding CPU packet        */
     /* data. This occurs when the CPU 16-bit to 32-byte packing     */
     /* is not yet complete and another SOP is received before       */
     /* the expected EOP.                                            */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_32bytes_pack_err;

     /* CpuIfPacketSizeErr: If set, then an error flag was           */
     /* inserted and accompanied the corresponding CPU packet        */
     /* data. This happens when the CPU packet size is too small     */
     /* (less than 33B).                                             */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_packet_size_err;

     /* CpuIf 64bytesPackErr: If set, then an error flag was         */
     /* inserted and accompanied the corresponding CPU packet        */
     /* data. This occurs when packing 32-byte to 64-byte and a      */
     /* SOP or a data from a different port arrives while the 32     */
     /* most-significant bytes are already occupied.                 */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_64bytes_pack_err;

     /* OlpIfErrDataArrived: If set, then erroneous data has         */
     /* arrived from the OLP (data descriptor error bit was          */
     /* set).                                                        */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_err_data_arrived;

     /* OlpIf 32bytesPackErr: If set, then an error flag was         */
     /* inserted and accompanied the corresponding OLP packet        */
     /* data. This occurs when the OLP 16-bit to 32-byte packing     */
     /* is not yet complete and another SOP is received before       */
     /* the expected EOP.                                            */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_32bytes_pack_err;

     /* OlpIfPacketSizeErr: If set, then an error flag was           */
     /* inserted and accompanied the corresponding OLP packet        */
     /* data. This happens when the OLP packet size is too small     */
     /* (less than 33B).                                             */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_packet_size_err;

     /* OlpIf 64bytesPackErr: If set, then an error flag was         */
     /* inserted and accompanied the corresponding OLP packet        */
     /* data. This occurs when packing 32 to 64 bytes and a SOP      */
     /* or a data from a different port arrives while the 32         */
     /* most-significant bytes are already occupied.                 */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_64bytes_pack_err;

     /* NifPacketSizeErr: If set, then an error flag was             */
     /* inserted and accompanied the corresponding NIFA packet       */
     /* data. This happens when the NIFA packet size is too          */
     /* small (less than 33B).                                       */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD nif_packet_size_err;

     /* RcyErrDataArrived: If set, then erroneous data has           */
     /* arrived from the Recycling interface (data descriptor        */
     /* error bit was set).                                          */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcy_err_data_arrived;

     /* RcyPacketSizeErr: If set, then an error flag was             */
     /* inserted and accompanied the corresponding Recycling         */
     /* packet data. This happens when the Recycling packet size     */
     /* is too small (less than 33B).                                */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_packet_size_err;

     /* Rcy 64bytesPackErr: If set, then an error flag was           */
     /* inserted and accompanied the corresponding Recycling         */
     /* packet data. This occurs when packing 32 to 64 bytes and     */
     /* a SOP or a data from a different port arrives while the      */
     /* 32 most-significant bytes are already occupied.              */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_64bytes_pack_err;

     /* BurstErrFollowSopNotValid: If set, then an error flag        */
     /* was inserted and accompanied the corresponding word          */
     /* (64B) in the Word Store Logic. This occurs when the Word     */
     /* following SOP is not valid. Since words arrive in bursts     */
     /* of two words, they can be less only if an EOP is             */
     /* received.                                                    */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_not_valid;

     /* BurstErrFollowSopDifContext: If set, then an error flag      */
     /* was inserted and accompanied the corresponding word          */
     /* (64B) in the Word Store Logic. This occurs when the Word     */
     /* following a SOP was not of the same context (FAP port).      */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_dif_context;

     /* BurstErrFollowSopIsSop: If set, then an error flag was       */
     /* inserted and accompanied the corresponding word (64B) in     */
     /* the Word Store Logic. This occurs when the Word              */
     /* following a SOP was another SOP.                             */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_is_sop;

     /* BurstErrFollowSopIsErr: If set, then an error flag was       */
     /* inserted and accompanied the corresponding word (64B) in     */
     /* the Word Store Logic. This occurs when the Word              */
     /* following SOP was a ERR.                                     */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_is_err;

     /* FapPortErr: An invalid port/channel id arrived to IRE.       */
     /* The word is discarded. Refer to register InvalidPort for     */
     /* further details                                              */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fap_port_err;

     /* TdmErr: If set, then an error occurred for a TDM packet.     */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_err;

     /* TdmSizeErr: If set, then a TDM packet violated size          */
     /* contraints.                                                  */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_size_err;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2410 */

     /* CpuIfErrDataArrivedMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_err_data_arrived_mask;

     /* CpuIf 32bytesPackErrMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_32bytes_pack_err_mask;

     /* CpuIfPacketSizeErrMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_packet_size_err_mask;

     /* CpuIf 64bytesPackErrMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_64bytes_pack_err_mask;

     /* OlpIfErrDataArrivedMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_err_data_arrived_mask;

     /* OlpIf 32bytesPackErrMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_32bytes_pack_err_mask;

     /* OlpIfPacketSizeErrMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_packet_size_err_mask;

     /* OlpIf 64bytesPackErrMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_64bytes_pack_err_mask;

     /* NifPacketSizeErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nif_packet_size_err_mask;

     /* RcyErrDataArrivedMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcy_err_data_arrived_mask;

     /* RcyPacketSizeErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_packet_size_err_mask;

     /* Rcy 64bytesPackErrMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_64bytes_pack_err_mask;

     /* BurstErrFollowSopNotValidMask: Writing 0 masks the           */
     /* corresponding interrupt source.                              */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_not_valid_mask;

     /* BurstErrFollowSopDifContextMask: Writing 0 masks the         */
     /* corresponding interrupt source.                              */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_dif_context_mask;

     /* BurstErrFollowSopIsSopMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_is_sop_mask;

     /* BurstErrFollowSopIsErrMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_is_err_mask;

     /* FapPortErrMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fap_port_err_mask;

     /* TdmErrMask: Writing 0 masks the corresponding interrupt      */
     /* source.                                                      */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_err_mask;

     /* TdmSizeErrMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_size_err_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;
  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2420 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_IRE_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2430 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_IRE_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2440 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets the     */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one for each write command. If set to 0, one     */
     /* operation is performed. The CPU can read this field to       */
     /* determine the number of writes left.                         */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. The timeout period is in        */
     /* periods of 256 clocks. If set to 0, then the command has     */
     /* no timeout.                                                  */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2441 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2442 */

     /* IndirectCommandDataIncrement:                                */
     /* IndirectCommandWrData[31:0] is incremented by this value     */
     /* after every indirect write. Addition is cyclic.              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_IRE_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* Gtimer Configuration:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2500 */

     /* GtimerCycle: Global timer cycle. Gtimer expires after        */
     /* GtimerCycle. Default value equivalent to 1[sec] @            */
     /* 250[Mhz]                                                     */
     /* range: 29:0, access type: RW, default value: 30'd250_000_000 */
     SOC_PETRA_REG_FIELD gtimer_cycle;

     /* GtimerEnable: If set, then the counters count according      */
     /* to the global timer                                          */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_enable;

     /* GtimerResetOnTrigger: If asserted then all related           */
     /* counters are cleared when GtimerTrigger is asserted          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_reset_on_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Gtimer Trigger:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2501 */

     /* GtimerTrigger: When set, the global counter starts.          */
     /* Trigger is deasserted when counter expires.                  */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_trigger_reg;

  /* Dynamic Configuration: General dynamic configuration           */
  /* registers. The bits in this register may be changed on         */
  /* the fly.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2502 */

     /* EnableDataPath: If set, the IRE allows data words from       */
     /* the interfaces to pass through. This register is reset       */
     /* with the block's soft reset.                                 */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_data_path;

     /* DisEcc: If set, ECC is disabled for all memories             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_ecc;

     /* FtmhVersion: The value to which the FTMH version is set      */
     /* to, if specified by SetFtmhVersion.                          */
     /* range: 3:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ftmh_version;

  } __ATTRIBUTE_PACKED__ dynamic_configuration_reg;

  /* Cpu Fap Port Configuration Register: This is the               */
  /* incoming CPU FAP port in the system.                           */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x2503 */

    /* CpuFapPort: Incoming CPU FAP port.                           */
    /* range: 6:0, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD cpu_fap_port;

  } __ATTRIBUTE_PACKED__ cpu_fap_port_configuration_reg;

  /* Olp Fap Port Configuration Register: This is the               */
  /* incoming OLP FAP port in the system.                           */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x2503 */

    /* OlpFapPort: Incoming OLP FAP port.                           */
    /* range: 6:0, access type: RW, default value: 0x5              */
    SOC_PETRA_REG_FIELD olp_fap_port;

  } __ATTRIBUTE_PACKED__ olp_fap_port_configuration_reg;

  /* FAP Port Configuration: This is the incoming CPU FAP           */
  /* port in the system.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2503 */

     /* RegFapPort: Incoming register interface FAP port             */
     /* range: 22:16, access type: RW, default value: 0x6            */
     SOC_PETRA_REG_FIELD reg_fap_port;

     /* UseAllChannels: For NIF ports 0,16,32 and 48 specifies       */
     /* whether they use all 256 channels. If so, it is verified     */
     /* that NIF ports N+1 through N+15 are not used. If not, it     */
     /* is verified that the channel is less than 64. This           */
     /* register is used for configuring Interlaken ports, where     */
     /* more than 64 channels must be supported.                     */
     /* range: 27:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD use_all_channels;

  } __ATTRIBUTE_PACKED__ fap_port_configuration_reg;

  /* Set Ftmh Version:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2504 */

     /* SetFtmhVersion: For each FAP port specifies whether the      */
     /* FTMH version bits should be set to FtmhVersion               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD set_ftmh_version;

  } __ATTRIBUTE_PACKED__ set_ftmh_version_reg[SOC_PB_IRE_SET_FTMH_VERSION_REG_MULT_NOF_REGS];

  /* Recycling Shaper: Recycling token bucket configuration.        */
  /* The token bucket guarantees a CIR BW to recycling, with        */
  /* a strict priority over the NIF data. The maximum rate is       */
  /* 3.75 Gbps.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2507 */

     /* RcyShaperTimerCycles: Every RcyShaperTimerCycles cycles      */
     /* grants RcyShaperGrantSize bytes to the token bucket. A       */
     /* value of 0 indicates a grant every clock cycle.              */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcy_shaper_timer_cycles;

     /* RcyShaperGrantSize: How many bytes to grant the bucket.      */
     /* A value of zero disables the shaper. When recycling is       */
     /* disabled, all NIF data has strict priority over the          */
     /* recycling data.                                              */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcy_shaper_grant_size;

     /* RcyShaperMaxBurst: Maximum burst in bytes that the           */
     /* shaper is enabled. A value smaller than 128 disables the     */
     /* shaper.                                                      */
     /* range: 29:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_shaper_max_burst;

  } __ATTRIBUTE_PACKED__ recycling_shaper_reg;

  /* Word Fifo Thresholds: A pair of thresholds to regulate         */
  /* the incoming WDF (Word Data FIFO) data, which holds the        */
  /* packet that was selected from one of the incoming              */
  /* interfaces. Note: These thresholds should not be changed       */
  /* without consulting DUNE.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2508 */

     /* ThresholdWdfLow: Low threshold. Must be equal (no            */
     /* hysteresis) or lower than the high threshold. Legal          */
     /* values: 1 up to ThresholdWdfHigh                             */
     /* range: 10:0, access type: RW, default value: 0x3fa           */
     SOC_PETRA_REG_FIELD threshold_wdf_low;

     /* ThresholdWdfHigh: High threshold. Legal values: 1-250        */
     /* range: 26:16, access type: RW, default value: 0x3fa          */
     SOC_PETRA_REG_FIELD threshold_wdf_high;

  } __ATTRIBUTE_PACKED__ word_fifo_thresholds_reg;

  /* Word Fifo Status: Word FIFO status.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2509 */

     /* WdfEmpty: WDF is empty.                                      */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD wdf_empty;

     /* WdfFull: WDF is full. Value is latched when FIFO is full     */
     /* and cleared when register is read. This register is          */
     /* clear on read.                                               */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD wdf_full;

     /* WdfFifoCount: Current number of words in the FIFO.           */
     /* range: 18:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD wdf_fifo_count;

  } __ATTRIBUTE_PACKED__ word_fifo_status_reg;

  /* Ihp Fifo Thresholds: A pair of thresholds to regulate          */
  /* the incoming HPF (IHP FIFO) data, which holds the packet       */
  /* header that was selected from one of the incoming              */
  /* interfaces. Note: These thresholds should not be changed       */
  /* without consulting DUNE.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x250a */

     /* ThresholdHpfLow: Low threshold. Must be equal (no            */
     /* hysteresis) or lower than the high threshold. Legal          */
     /* values: 1 up to ThresholdHpfHigh                             */
     /* range: 5:0, access type: RW, default value: 0x1a             */
     SOC_PETRA_REG_FIELD threshold_hpf_low;

     /* ThresholdHpfHigh: High threshold. Legal values: 1-58         */
     /* range: 13:8, access type: RW, default value: 0x1a            */
     SOC_PETRA_REG_FIELD threshold_hpf_high;

  } __ATTRIBUTE_PACKED__ ihp_fifo_thresholds_reg;

  /* Ihp Fifo Status: IHP FIFO status.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x250b */

     /* HpfEmpty: HPF is empty.                                      */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD hpf_empty;

     /* HpfFull: HPF is full. Value is latched when FIFO is full     */
     /* and cleared when register is read. This register is          */
     /* clear on read.                                               */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD hpf_full;

     /* HpfFifoCount: Current number of words in the FIFO.           */
     /* range: 13:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD hpf_fifo_count;

  } __ATTRIBUTE_PACKED__ ihp_fifo_status_reg;

  /* Packet Edit Fifo Thresholds: A pair of thresholds to           */
  /* regulate the incoming PEF (Packet Edit FIFO) data, which       */
  /* holds the packet edit data that arrived from IHP. Note:        */
  /* These thresholds should not be changed without                 */
  /* consulting DUNE.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x250c */

     /* ThresholdPefLow: Low threshold. Must be equal (no            */
     /* hysteresis) or lower than the high threshold. Legal          */
     /* values: 1 up to ThresholdPefHigh                             */
     /* range: 8:0, access type: RW, default value: 0xc0             */
     SOC_PETRA_REG_FIELD threshold_pef_low;

     /* ThresholdPefHigh: High threshold. Legal values: 1-31         */
     /* range: 24:16, access type: RW, default value: 0xc0           */
     SOC_PETRA_REG_FIELD threshold_pef_high;

  } __ATTRIBUTE_PACKED__ packet_edit_fifo_thresholds_reg;

  /* Packet Edit Fifo Status: PEF FIFO status.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x250d */

     /* PefEmpty: PEF is empty.                                      */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD pef_empty;

     /* PefFull: PEF is full. Value is latched when FIFO is full     */
     /* and cleared when register is read. This register is          */
     /* clear on read.                                               */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD pef_full;

     /* PefFifoCount: Current number of words in the FIFO.           */
     /* range: 14:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD pef_fifo_count;

     /* PefCount: Current number of words in the FIFO plus           */
     /* editing data that is supposed to arrive from the IHP         */
     /* pipe and corresponds to packet headers which are already     */
     /* in pipe. The PEF must be able to sink the editing data.      */
     /* range: 21:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD pef_count;

  } __ATTRIBUTE_PACKED__ packet_edit_fifo_status_reg;

  /* Register Interface Packet Control: Interface for sending       */
  /* a packet from the CPU in Non-streaming (Asynchronous)          */
  /* mode.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x250e */

     /* RegIfPktSendData: The trigger to send 32 bytes of packet     */
     /* data. Should be set when data and control are ready to       */
     /* be sent. Auto clear when data is sent.                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_pkt_send_data;

     /* RegIfPktStart: Indicates that packet data contains Start     */
     /* Of Packet.                                                   */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_pkt_start;

     /* RegIfPktEnd: Indicates that packet data contains End Of      */
     /* Packet.                                                      */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_pkt_end;

     /* RegIfPktErr: Debug mode to force an error on the             */
     /* transmitted packet.                                          */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_pkt_err;

     /* RegIfPktBe: Number of valid bytes in packet data - valid     */
     /* only if EOP exists.                                          */
     /* range: 8:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_pkt_be;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_control_reg;

  /* Register Interface Packet Data: Asynchronous interface         */
  /* CPU packet data. The CPU sends the packet in segments of       */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x250f */

     /* RegIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_0;

  /* Register Interface Packet Data: Asynchronous interface         */
  /* CPU packet data. The CPU sends the packet in segments of       */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2510 */

     /* RegIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_1;

  /* Register Interface Packet Data: Asynchronous interface         */
  /* CPU packet data. The CPU sends the packet in segments of       */
  /* 32B.                                                           */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x2511 */

    /* RegIfPktData: The 32 bytes of packet data.                   */
    /* range: 31:0, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_2;

  /* Register Interface Packet Data: Asynchronous interface         */
  /* CPU packet data. The CPU sends the packet in segments of       */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2512 */

     /* RegIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_3;

  /* Register Interface Packet Data: Asynchronous interface         */
  /* CPU packet data. The CPU sends the packet in segments of       */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2513 */

     /* RegIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_4;

  /* Register Interface Packet Data: Asynchronous interface         */
  /* CPU packet data. The CPU sends the packet in segments of       */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2514 */

     /* RegIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_5;

  /* Register Interface Packet Data: Asynchronous interface         */
  /* CPU packet data. The CPU sends the packet in segments of       */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2515 */

     /* RegIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_6;

  /* Register Interface Packet Data: Asynchronous interface         */
  /* CPU packet data. The CPU sends the packet in segments of       */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2516 */

     /* RegIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_7;

  /* Invalid Port: An invalid port/channel arrived to IRE.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2517 */

     /* Port: Invalid port packet arrived on This register is        */
     /* clear on read.                                               */
     /* range: 6:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD port;

     /* Channel: Invalid channel that packet arrived on This         */
     /* register is clear on read.                                   */
     /* range: 15:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD channel;

     /* Interface: 0 - CPU 1 - NIF 2 - RCY This register is          */
     /* clear on read.                                               */
     /* range: 17:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD interfac;

     /* NifErrorIndication: Indicates reason for erroneous data      */
     /* received on NIF port: 0 - NIF error indication 1 - burst     */
     /* error indication 2 - channel not multiple of 16 3 -          */
     /* channel more than 64 This register is clear on read.         */
     /* range: 27:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD nif_error_indication;

  } __ATTRIBUTE_PACKED__ invalid_port_reg;

  /* TDM Size: TDM packet size limits                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2518 */

     /* TDM MinSize: Minimum size allowed for TDM packets not        */
     /* received from the CPU.                                       */
     /* range: 7:0, access type: RW, default value: 0x7f             */
     SOC_PETRA_REG_FIELD tdm_min_size;

     /* TDM MaxSize: Maximum size allowed for TDM packets not        */
     /* received from the CPU.                                       */
     /* range: 15:8, access type: RW, default value: 0x7f            */
     SOC_PETRA_REG_FIELD tdm_max_size;

  } __ATTRIBUTE_PACKED__ tdm_size_reg;

  /* Cpu Packet Counter:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x251a */

     /* CpuPacketCounter: CPU ingress received packet counter.       */
     /* If bit 64 is set, counter has overflowed. Counter stops      */
     /* at saturation. This register is clear on read.               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_packet_counter;

  } __ATTRIBUTE_PACKED__ cpu_packet_counter_reg[SOC_PB_IRE_CPU_PACKET_COUNTER_REG_MULT_NOF_REGS];

  /* Olp Packet Counter:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x251d */

     /* OlpPacketCounter: OLP ingress received packet counter.       */
     /* If bit 64 is set, counter has overflowed. Counter stops      */
     /* at saturation. This register is clear on read.               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD olp_packet_counter;

  } __ATTRIBUTE_PACKED__ olp_packet_counter_reg[SOC_PB_IRE_OLP_PACKET_COUNTER_REG_MULT_NOF_REGS];

  /* Rcy Packet Counter:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2520 */

     /* RcyPacketCounter: Recycling ingress received packet          */
     /* counter. If bit 64 is set, counter has overflowed.           */
     /* Counter stops at saturation. This register is clear on       */
     /* read.                                                        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcy_packet_counter;

  } __ATTRIBUTE_PACKED__ rcy_packet_counter_reg[SOC_PB_IRE_RCY_PACKET_COUNTER_REG_MULT_NOF_REGS];

} __ATTRIBUTE_PACKED__ SOC_PB_IRE_REGS;
/* Block definition: IDR 	 */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2800 */

     /* ErrorUnicastRecycle: If set, indicates that a unicast DP     */
     /* wasn't recycled                                              */
     /* range: 0:0, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_unicast_recycle;

     /* ErrorMiniMulticastRecycle: If set, indcates that a mini      */
     /* multicast DP wasn't recycled                                 */
     /* range: 1:1, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_mini_multicast_recycle;

     /* ErrorFullMulticastRecycle: If set, indicates that a full     */
     /* multicast DP wasn't recycled                                 */
     /* range: 2:2, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_full_multicast_recycle;

     /* ErrorReassembly: If set, indicates that the reassembly       */
     /* error counter is non-zero                                    */
     /* range: 3:3, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_reassembly;

     /* ErrorTimeout: If set, indicates a timeout error of the       */
     /* reassembly controller                                        */
     /* range: 4:4, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_timeout;

     /* ErrorMemory0: If set, indicates a parity error in one of     */
     /* the memories                                                 */
     /* range: 5:5, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_memory0;

     /* ErrorMemory1: If set, indicates an ECC error of type 1       */
     /* in one of the memories                                       */
     /* range: 6:6, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_memory1;

     /* ErrorMemory2: If set, indicates an ECC error of type 2       */
     /* in one of the memories                                       */
     /* range: 7:7, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_memory2;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Reassembly Interrupt Register: This register contains          */
  /* the interrupt sources residing in this unit.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2801 */

     /* ReassemblyErrorMinimumOriginalSize: If set, indicates        */
     /* there was an ECC error.                                      */
     /* range: 0:0, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_error_minimum_original_size;

     /* ReassemblyErrorMinimumSize: If set, indicates there was      */
     /* an ECC error.                                                */
     /* range: 1:1, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_error_minimum_size;

     /* ReassemblyErrorMaximumOriginalSize: If set, indicates        */
     /* there was an ECC error.                                      */
     /* range: 2:2, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_error_maximum_original_size;

     /* ReassemblyErrorMaximumSize: If set, indicates there was      */
     /* an ECC error.                                                */
     /* range: 3:3, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_error_maximum_size;

     /* ReassemblyErrorMaximumDP: If set, indicates there was an     */
     /* ECC error.                                                   */
     /* range: 4:4, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_error_maximum_dp;

     /* ReassemblyErrorNoPCB: If set, indicates there was an ECC     */
     /* error.                                                       */
     /* range: 5:5, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_error_no_pcb;

     /* ReassemblyErrorNoSopPCB: If set, indicates there was an      */
     /* ECC error.                                                   */
     /* range: 6:6, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_error_no_sop_pcb;

     /* ReassemblyErrorNoDP: If set, indicates there was an ECC      */
     /* error.                                                       */
     /* range: 7:7, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_error_no_dp;

     /* ReassemblyErrorUnexpectedEOP: If set, indicates there        */
     /* was an ECC error.                                            */
     /* range: 8:8, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_error_unexpected_eop;

     /* ReassemblyErrorUnexpectedMOP: If set, indicates there        */
     /* was an ECC error.                                            */
     /* range: 9:9, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_error_unexpected_mop;

     /* ReassemblyErrorUnexpectedSOP: If set, indicates there        */
     /* was an ECC error.                                            */
     /* range: 10:10, access type: INT, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_unexpected_sop;

     /* ReassemblyErrorGeneralMOP: If set, indicates there was       */
     /* an ECC error.                                                */
     /* range: 11:11, access type: INT, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_general_mop;

     /* ReassemblyErrorGeneralIdle: If set, indicates there was      */
     /* an ECC error.                                                */
     /* range: 12:12, access type: INT, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_general_idle;

  } __ATTRIBUTE_PACKED__ reassembly_interrupt_reg;

  /* Memory Interrupt Register0: This register contains the         */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2802 */

     /* Reassembly4BitError: If set, indicates there was a           */
     /* parity error.                                                */
     /* range: 0:0, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly4_bit_error;

     /* EthernetMeterProfilesBitError: If set, indicates there       */
     /* was a parity error.                                          */
     /* range: 1:1, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD ethernet_meter_profiles_bit_error;

     /* EthernetMeterStatusBitError: If set, indicates there was     */
     /* a parity error.                                              */
     /* range: 2:2, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD ethernet_meter_status_bit_error;

     /* ContextStatusBitError: If set, indicates there was a         */
     /* parity error.                                                */
     /* range: 3:3, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD context_status_bit_error;

  } __ATTRIBUTE_PACKED__ memory_interrupt_0_reg;

  /* Memory Interrupt Register[1..2]: This register contains        */
  /* the interrupt sources residing in this unit.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2803 */

     /* ChunkStatusEccError: If set, indicates there was an ECC      */
     /* error.                                                       */
     /* range: 0:0, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD chunk_status_ecc_error;

     /* ChunkFifoEccError: If set, indicates there was an ECC        */
     /* error.                                                       */
     /* range: 1:1, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD chunk_fifo_ecc_error;

     /* DbuffPointerCache01EccError: If set, indicates there was     */
     /* an ECC error.                                                */
     /* range: 2:2, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD dbuff_pointer_cache01_ecc_error;

     /* DbuffPointerCache23EccError: If set, indicates there was     */
     /* an ECC error.                                                */
     /* range: 3:3, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD dbuff_pointer_cache23_ecc_error;

     /* DbuffPointerCache45EccError: If set, indicates there was     */
     /* an ECC error.                                                */
     /* range: 4:4, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD dbuff_pointer_cache45_ecc_error;

     /* FreePcbsEccError: If set, indicates there was an ECC         */
     /* error.                                                       */
     /* range: 5:5, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD free_pcbs_ecc_error;

     /* PcbLinkTableEccError: If set, indicates there was an ECC     */
     /* error.                                                       */
     /* range: 6:6, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcb_link_table_ecc_error;

     /* DpReassemblyEccError: If set, indicates there was an ECC     */
     /* error.                                                       */
     /* range: 7:7, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD dp_reassembly_ecc_error;

     /* CdReassemblyEccError: If set, indicates there was an ECC     */
     /* error.                                                       */
     /* range: 8:8, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD cd_reassembly_ecc_error;

     /* ContextStatusEccError: If set, indicates there was an        */
     /* ECC error.                                                   */
     /* range: 9:9, access type: INT, default value: 0x0             */
     SOC_PETRA_REG_FIELD context_status_ecc_error;

     /* WordIndexEccError: If set, indicates there was an ECC        */
     /* error.                                                       */
     /* range: 10:10, access type: INT, default value: 0x0           */
     SOC_PETRA_REG_FIELD word_index_ecc_error;

     /* CompletePcEccError: If set, indicates there was an ECC       */
     /* error.                                                       */
     /* range: 11:11, access type: INT, default value: 0x0           */
     SOC_PETRA_REG_FIELD complete_pc_ecc_error;

     /* MmuEccError: If set, indicates there was an ECC error.       */
     /* range: 12:12, access type: INT, default value: 0x0           */
     SOC_PETRA_REG_FIELD mmu_ecc_error;

  } __ATTRIBUTE_PACKED__ memory_interrupt_reg[SOC_PB_IDR_REGS_MEMORY_INTERRUPT_REG_ARRAY_SIZE];

  /* Interrupt Register Mask: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2810 */

     /* ErrorUnicastRecycleMask: Writing 0 masks the                 */
     /* corresponding interrupt source                               */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_unicast_recycle_mask;

     /* ErrorMiniMulticastRecycleMask: Writing 0 masks the           */
     /* corresponding interrupt source                               */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_mini_multicast_recycle_mask;

     /* ErrorFullMulticastRecycleMask: Writing 0 masks the           */
     /* corresponding interrupt source                               */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_full_multicast_recycle_mask;

     /* ErrorReassemblyMask: Writing 0 masks the corresponding       */
     /* interrupt source                                             */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_reassembly_mask;

     /* ErrorTimeoutMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 4:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_timeout_mask;

     /* ErrorMemory0Mask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 5:5, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_memory0_mask;

     /* ErrorMemory1Mask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 6:6, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_memory1_mask;

     /* ErrorMemory2Mask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 7:7, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_memory2_mask;

  } __ATTRIBUTE_PACKED__ interrupt_register_mask_reg;

  /* Reassembly Interrupt Register Mask: This register              */
  /* contains the interrupt sources residing in this unit.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2811 */

     /* ReassemblyErrorMinimumOriginalSizeMask: Writing 0 masks      */
     /* the corresponding interrupt source                           */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_minimum_original_size_mask;

     /* ReassemblyErrorMinimumSizeMask: Writing 0 masks the          */
     /* corresponding interrupt source                               */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_minimum_size_mask;

     /* ReassemblyErrorMaximumOriginalSizeMask: Writing 0 masks      */
     /* the corresponding interrupt source                           */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_maximum_original_size_mask;

     /* ReassemblyErrorMaximumSizeMask: Writing 0 masks the          */
     /* corresponding interrupt source                               */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_maximum_size_mask;

     /* ReassemblyErrorMaximumDPMask: Writing 0 masks the            */
     /* corresponding interrupt source                               */
     /* range: 4:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_maximum_dpmask;

     /* ReassemblyErrorNoPCBMask: Writing 0 masks the                */
     /* corresponding interrupt source                               */
     /* range: 5:5, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_no_pcbmask;

     /* ReassemblyErrorNoSopPCBMask: Writing 0 masks the             */
     /* corresponding interrupt source                               */
     /* range: 6:6, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_no_sop_pcbmask;

     /* ReassemblyErrorNoDPMask: Writing 0 masks the                 */
     /* corresponding interrupt source                               */
     /* range: 7:7, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_no_dpmask;

     /* ReassemblyErrorUnexpectedEOPMask: Writing 0 masks the        */
     /* corresponding interrupt source                               */
     /* range: 8:8, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_unexpected_eopmask;

     /* ReassemblyErrorUnexpectedMOPMask: Writing 0 masks the        */
     /* corresponding interrupt source                               */
     /* range: 9:9, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly_error_unexpected_mopmask;

     /* ReassemblyErrorUnexpectedSOPMask: Writing 0 masks the        */
     /* corresponding interrupt source                               */
     /* range: 10:10, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD reassembly_error_unexpected_sopmask;

     /* ReassemblyErrorGeneralMOPMask: Writing 0 masks the           */
     /* corresponding interrupt source                               */
     /* range: 11:11, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD reassembly_error_general_mopmask;

     /* ReassemblyErrorGeneralIdleMask: Writing 0 masks the          */
     /* corresponding interrupt source                               */
     /* range: 12:12, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD reassembly_error_general_idle_mask;

  } __ATTRIBUTE_PACKED__ reassembly_interrupt_register_mask_reg;

  /* Memory Interrupt Register0 Mask: This register contains        */
  /* the interrupt sources residing in this unit.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2812 */

     /* Reassembly4BitErrorMask: Writing 0 masks the                 */
     /* corresponding interrupt source                               */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD reassembly4_bit_error_mask;

     /* EthernetMeterProfilesBitErrorMask: Writing 0 masks the       */
     /* corresponding interrupt source                               */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD ethernet_meter_profiles_bit_error_mask;

     /* EthernetMeterStatusBitErrorMask: Writing 0 masks the         */
     /* corresponding interrupt source                               */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD ethernet_meter_status_bit_error_mask;

     /* ContextStatusBitErrorMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD context_status_bit_error_mask;

  } __ATTRIBUTE_PACKED__ memory_interrupt_register0_mask_reg;

  /* Memory Interrupt Register[1..2]Mask: Each bit in this          */
  /* register corresponds to an interrupt source in the             */
  /* Interrupt Register. The interrupt source is masked by          */
  /* writing 0 to the relevant bit in this register.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2813 */

     /* ChunkStatusEccErrorMask: Writing 0 masks the                 */
     /* corresponding interrupt source                               */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD chunk_status_ecc_error_mask;

     /* ChunkFifoEccErrorMask: Writing 0 masks the corresponding     */
     /* interrupt source                                             */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD chunk_fifo_ecc_error_mask;

     /* DbuffPointerCache01EccErrorMask: Writing 0 masks the         */
     /* corresponding interrupt source                               */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD dbuff_pointer_cache01_ecc_error_mask;

     /* DbuffPointerCache23EccErrorMask: Writing 0 masks the         */
     /* corresponding interrupt source                               */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD dbuff_pointer_cache23_ecc_error_mask;

     /* DbuffPointerCache45EccErrorMask: Writing 0 masks the         */
     /* corresponding interrupt source                               */
     /* range: 4:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD dbuff_pointer_cache45_ecc_error_mask;

     /* FreePcbsEccErrorMask: Writing 0 masks the corresponding      */
     /* interrupt source                                             */
     /* range: 5:5, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD free_pcbs_ecc_error_mask;

     /* PcbLinkTableEccErrorMask: Writing 0 masks the                */
     /* corresponding interrupt source                               */
     /* range: 6:6, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD pcb_link_table_ecc_error_mask;

     /* DpReassemblyEccErrorMask: Writing 0 masks the                */
     /* corresponding interrupt source                               */
     /* range: 7:7, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD dp_reassembly_ecc_error_mask;

     /* CdReassemblyEccErrorMask: Writing 0 masks the                */
     /* corresponding interrupt source                               */
     /* range: 8:8, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD cd_reassembly_ecc_error_mask;

     /* ContextStatusEccErrorMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 9:9, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD context_status_ecc_error_mask;

     /* WordIndexEccErrorMask: Writing 0 masks the corresponding     */
     /* interrupt source                                             */
     /* range: 10:10, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD word_index_ecc_error_mask;

     /* CompletePcEccErrorMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 11:11, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD complete_pc_ecc_error_mask;

     /* MmuEccErrorMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 12:12, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD mmu_ecc_error_mask;

  } __ATTRIBUTE_PACKED__ memory_interrupt_register_mask_reg[SOC_PB_IDR_REGS_MEMORY_INTERRUPT_REGISTER_MASK_REG_ARRAY_SIZE];

  /* Indirect Command Wr Data: Indirect write data - Data           */
  /* that is written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2820 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_IDR_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2830 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_IDR_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands - Used to send             */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2840 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set, to 0, one       */
     /* operation is performed. The CPU can read this field to        */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set, to 0, then the command has no timeout.       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address -            */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2841 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2842 */

     /* IndirectCommandDataIncrement:                                */
     /* IndirectCommandWrData[31:0] is incremented by this value     */
     /* after every indirect write. Addition is cyclic.              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_IDR_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* Soc_petra C fix                               */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x2852 */

    /* range: 0:0, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD meter_mode_0;

    /* range: 1:1, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD meter_mode_1;

    /* range: 2:2, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD gmeter_mode_0;

    /* range: 3:3, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD gmeter_mode_1;

    /* range: 31:16, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD mc_id_use_uc_buffer;

  } __ATTRIBUTE_PACKED__ soc_petra_c_fix;

  /* Gtimer Configuration:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2900 */

     /* GtimerCycle: The number of clocks the gtimer will count.     */
     /* range: 29:0, access type: RW, default value: 30'd250_000_000 */
     SOC_PETRA_REG_FIELD gtimer_cycle;

     /* GtimerEnable: Whether to use all the counters in gtimer      */
     /* mode or read on clear                                        */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_enable;

     /* GtimerResetOnTrigger: If set, the gtimer will output a       */
     /* reset signal when the count begins.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_reset_on_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Gtimer Trigger:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2901 */

     /* GtimerTrigger: When this register is written to, the         */
     /* gtimer starts counting. When this register is read, it       */
     /* gives the gtimer status (1= still counting, 0=count is       */
     /* over).                                                       */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_trigger_reg;

  /* Reset Status Register: Bits in this register specify           */
  /* when initialization has finished.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2902 */

     /* ContextStatusInitDone: If set, then the context status       */
     /* memory has completed initialization                          */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD context_status_init_done;

     /* ChunkStatusInitDone: If set, then the chunk status           */
     /* memory has completed initialization                          */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD chunk_status_init_done;

     /* WordIndexFifoInitDone: If set, then the word index FIFO      */
     /* memory has completed initialization                          */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD word_index_fifo_init_done;

     /* FreePcbFifoInitDone: If set, then the free PCB FIFO          */
     /* memory has completed initialization                          */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD free_pcb_fifo_init_done;

  } __ATTRIBUTE_PACKED__ reset_status_reg;

  /* Static Configuration: General static configuration             */
  /* register. The bits in this register may be changed only        */
  /* during initial configuration.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2903 */

     /* DisEcc: If set ECC is disabled for all memories              */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_ecc;

     /* EnableBufferChange: If set, then a unicast buffer may be     */
     /* used instead of a mini-multicast buffer                      */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_buffer_change;

     /* ReassemblyNoMmcMirrorOnly: If set, then when there are       */
     /* no mini multicast buffers, only the mirror copy of the       */
     /* packet is sent. If there is not a mirror copy or if this     */
     /* bit is not set, only the forwarding copy is sent.            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD reassembly_no_mmc_mirror_only;

     /* FbcInternalReuse: If set, the FBC reuses returned            */
     /* pointers, i.e. if possible, dbuff pointers are not           */
     /* returned to the external memory and are re-used.             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fbc_internal_reuse;

     /* FbcUnicastAutogenEnable: If set, then unicast dbuff          */
     /* pointers are generated; otherwise, only the unicast          */
     /* pointers in external memory are used. After soft reset       */
     /* this signal must be dis-asserted and re-asserted.            */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fbc_unicast_autogen_enable;

     /* FbcMiniMulticastAutogenEnable: If set, then mini             */
     /* multicast dbuff pointers are generated; otherwise, only      */
     /* the mini multicast pointers in external memory are           */
     /* used. After soft reset this signal must be dis-asserted       */
     /* and re-asserted.                                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fbc_mini_multicast_autogen_enable;

     /* FbcFullMulticastAutogenEnable: If set, then full             */
     /* multicast dbuff pointers are generated; otherwise, only      */
     /* the full multicast pointers in external memory are           */
     /* used. After soft reset this signal must be dis-asserted       */
     /* and re-asserted.                                             */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fbc_full_multicast_autogen_enable;

  } __ATTRIBUTE_PACKED__ static_configuration_reg;

  /* Dynamic Configuration: General dynamic configuration           */
  /* registers. The bits in this register may be changed on         */
  /* the fly.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2904 */

     /* DbuffPointerWriteDisable: If set then dbuff pointers are     */
     /* not written to the external MMU                              */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dbuff_pointer_write_disable;

  } __ATTRIBUTE_PACKED__ dynamic_configuration_reg;
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x2904 */

     /* EnableDataPath: If set, the FBC allows data words to         */
     /* pass through. This register is reset with the block's        */
     /* soft reset.                                                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_data_path;

     /* FbcHalt: If set, the FBC stops releasing new buffers to      */
     /* the RCT                                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fbc_halt;

    /* MaxDpThreshold: The maximum number of dbuff pointers per     */
    /* packet minus one (example: 4'b000 is one DP)                 */
    /* range: 9:6, access type: RW, default value: 0x6              */
    SOC_PETRA_REG_FIELD max_dp_threshold;

  } __ATTRIBUTE_PACKED__ dynamic_configuration_reg_cmn;

  /* Bcn Register: Support for BCN (Backwards Congestion            */
  /* Notification)                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2905 */

     /* BcnThreshold: When the number of bytes or packets (as        */
     /* specified by BcnMode) reaches this threshold a packet is     */
     /* snooped as specified by BcnSnoopCmd. If this value is 0      */
     /* then BCN is disabled.                                        */
     /* range: 19:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bcn_threshold;

     /* BcnMode: If reset then BCN mode is packet, otherwise it      */
     /* is bytes.                                                    */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bcn_mode;

     /* BcnSnoopCmd: The BCN snoop command for the selected          */
     /* packets.                                                     */
     /* range: 27:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bcn_snoop_cmd;

  } __ATTRIBUTE_PACKED__ bcn_reg;

  /* Context Outbound Mirror:                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2906 */

     /* ContextOutboundMirror: Specifies for each reassembly         */
     /* context if it is connected to an outbound mirror port        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD context_outbound_mirror;

  } __ATTRIBUTE_PACKED__ context_outbound_mirror_reg[SOC_PB_IDR_CONTEXT_OUTBOUND_MIRROR_REG_MULT_NOF_REGS];

  /* Ingress Multicast Indication:                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2909 */

     /* SnoopIsIngMc: Specifies which snoop commands are ingress     */
     /* multicast.                                                   */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD snoop_is_ing_mc;

     /* MirrorIsIngMc: Specifies which mirror commands are           */
     /* ingress multicast.                                           */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mirror_is_ing_mc;

  } __ATTRIBUTE_PACKED__ ingress_multicast_indication_reg;

  /* Packet Sizes: Specifies the minimumpacket size. Packets        */
  /* violating these limits are dropped.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290a */

     /* MinPacketSize: Minimum packet size. Value must be larger     */
     /* than 32.                                                     */
     /* range: 13:0, access type: RW, default value: 0x20            */
     SOC_PETRA_REG_FIELD min_packet_size;

     /* MinOrgPacketSize: Minimum packet size before editing.        */
     /* Value must be larger than 32.                                */
     /* range: 29:16, access type: RW, default value: 0x20           */
     SOC_PETRA_REG_FIELD min_org_packet_size;

  } __ATTRIBUTE_PACKED__ packet_sizes_reg;

  /* Rct Cpu Request Register: Using this register, the CPU         */
  /* can insert an error word into any context. This register       */
  /* is used for freeing resources used by a timed out              */
  /* context.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290b */

     /* RctCpuRequest: When setting this bit, an RCT CPU request     */
     /* is initiated.                                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rct_cpu_request;

     /* RctCpuRequestFapPort: The FAP port (i.e. reassembly          */
     /* context) of the RCT CPU request.                             */
     /* range: 7:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rct_cpu_request_fap_port;

  } __ATTRIBUTE_PACKED__ rct_cpu_request_reg;

  /* Fbc Full Multicast Autogen Start:                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290c */

     /* FbcFullMulticastAutogenStart: Full multicast pointers        */
     /* are generated starting with this value                       */
     /* range: 20:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fbc_full_multicast_autogen_start;

  } __ATTRIBUTE_PACKED__ fbc_full_multicast_autogen_start_reg;

  /* Fbc Full Multicast Autogen End:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290d */

     /* FbcFullMulticastAutogenEnd: Full multicast pointers are      */
     /* generated up to this value                                   */
     /* range: 20:0, access type: RW, default value: 0x1fff          */
     SOC_PETRA_REG_FIELD fbc_full_multicast_autogen_end;

  } __ATTRIBUTE_PACKED__ fbc_full_multicast_autogen_end_reg;

  /* Fbc Mini Multicast Autogen Start:                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290e */

     /* FbcMiniMulticastAutogenStart: Mini multicast pointers        */
     /* are generated starting with this value                       */
     /* range: 20:0, access type: RW, default value: 0x2000          */
     SOC_PETRA_REG_FIELD fbc_mini_multicast_autogen_start;

  } __ATTRIBUTE_PACKED__ fbc_mini_multicast_autogen_start_reg;

  /* Fbc Mini Multicast Autogen End:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290f */

     /* FbcMiniMulticastAutogenEnd: Mini multicast pointers are      */
     /* generated up to this value                                   */
     /* range: 20:0, access type: RW, default value: 21'h11FFF       */
     SOC_PETRA_REG_FIELD fbc_mini_multicast_autogen_end;

  } __ATTRIBUTE_PACKED__ fbc_mini_multicast_autogen_end_reg;

  /* Fbc Unicast Autogen Start:                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2910 */

     /* FbcUnicastAutogenStart: Unicast pointers are generated       */
     /* starting with this value                                     */
     /* range: 20:0, access type: RW, default value: 21'h12000       */
     SOC_PETRA_REG_FIELD fbc_unicast_autogen_start;

  } __ATTRIBUTE_PACKED__ fbc_unicast_autogen_start_reg;

  /* Fbc Unicast Autogen End:                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2911 */

     /* FbcUnicastAutogenEnd: Unicast pointers are generated up      */
     /* to this value                                                */
     /* range: 20:0, access type: RW, default value: 21'h1FA2E4      */
     SOC_PETRA_REG_FIELD fbc_unicast_autogen_end;

  } __ATTRIBUTE_PACKED__ fbc_unicast_autogen_end_reg;

  /* Fbc Cache Configuration: Configuration for FBC unicast         */
  /* cache.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2912 */

     /* FbcUnicastCacheDivider: Half of the unicast cache            */
     /* divider. This value is valid only when the FBC is in the     */
     /* no-reuse mode. Divider must be smaller than 156.             */
     /* range: 7:0, access type: RW, default value: 0x4f             */
     SOC_PETRA_REG_FIELD fbc_unicast_cache_divider;

     /* FbcMiniMulticastCacheDivider: Half of the mini multicast     */
     /* cache divider. This value is valid only when the FBC is      */
     /* in the no-reuse mode. Divider must be smaller than 156.      */
     /* range: 15:8, access type: RW, default value: 0x4f            */
     SOC_PETRA_REG_FIELD fbc_mini_multicast_cache_divider;

     /* FbcFullMulticastCacheDivider: Half of the full multicast     */
     /* cache divider. This value is valid only when the FBC is      */
     /* in the no-reuse mode. Divider must be smaller than 156.      */
     /* range: 23:16, access type: RW, default value: 0x4f           */
     SOC_PETRA_REG_FIELD fbc_full_multicast_cache_divider;

  } __ATTRIBUTE_PACKED__ fbc_cache_configuration_reg;

  /* Fbc Unicast Thresholds: Configuration for FBC unicast          */
  /* cache thresholds.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2913 */

     /* FbcInternalUnicastNewWriteTh: When number of items in        */
     /* cache is above this threshold, data may be moved from        */
     /* cache to external memory.                                    */
     /* range: 8:0, access type: RW, default value: 0xa0             */
     SOC_PETRA_REG_FIELD fbc_internal_unicast_new_write_th;

     /* FbcInternalUnicastNewReadTh: When number of items in         */
     /* cache is below this threshold, data may be moved from        */
     /* external memory to cache.                                    */
     /* range: 24:16, access type: RW, default value: 0x50           */
     SOC_PETRA_REG_FIELD fbc_internal_unicast_new_read_th;

  } __ATTRIBUTE_PACKED__ fbc_unicast_thresholds_reg;

  /* Fbc Mini Multicast Thresholds: Configuration for FBC           */
  /* mini multicast cache thresholds.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2914 */

     /* FbcInternalMiniMulticastNewWriteTh: When number of items     */
     /* in cache is above this threshold, data may be moved from     */
     /* cache to external memory.                                    */
     /* range: 8:0, access type: RW, default value: 0xa0             */
     SOC_PETRA_REG_FIELD fbc_internal_mini_multicast_new_write_th;

     /* FbcInternalMiniMulticastNewReadTh: When number of items      */
     /* in cache is below this threshold, data may be moved from     */
     /* external memory to cache.                                    */
     /* range: 24:16, access type: RW, default value: 0x50           */
     SOC_PETRA_REG_FIELD fbc_internal_mini_multicast_new_read_th;

  } __ATTRIBUTE_PACKED__ fbc_mini_multicast_thresholds_reg;

  /* Fbc Full Multicast Thresholds: Configuration for FBC           */
  /* full multicast cache thresholds.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2915 */

     /* FbcInternalFullMulticastNewWriteTh: When number of items     */
     /* in cache is below this threshold, data may be moved from     */
     /* external memory to cache.                                    */
     /* range: 8:0, access type: RW, default value: 0xa0             */
     SOC_PETRA_REG_FIELD fbc_internal_full_multicast_new_write_th;

     /* FbcInternalFullMulticastNewReadTh: When number of items      */
     /* in cache is below this threshold, data may be moved from     */
     /* external memory to cache.                                    */
     /* range: 24:16, access type: RW, default value: 0x50           */
     SOC_PETRA_REG_FIELD fbc_internal_full_multicast_new_read_th;

  } __ATTRIBUTE_PACKED__ fbc_full_multicast_thresholds_reg;

  /* Fbc External Full Multicast Limit Low:                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2916 */

     /* FbcExternalFullMulticastLimitLow: Lower limit for full       */
     /* multicast pointers in external memory                        */
     /* range: 21:0, access type: RW, default value: 22'h1FA2E5      */
     SOC_PETRA_REG_FIELD fbc_external_full_multicast_limit_low;

  } __ATTRIBUTE_PACKED__ fbc_external_full_multicast_limit_low_reg;

  /* Fbc External Full Multicast Limit High:                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2917 */

     /* FbcExternalFullMulticastLimitHigh: Upper limit for full      */
     /* multicast pointers in external memory                        */
     /* range: 21:0, access type: RW, default value: 22'h1FA343      */
     SOC_PETRA_REG_FIELD fbc_external_full_multicast_limit_high;

  } __ATTRIBUTE_PACKED__ fbc_external_full_multicast_limit_high_reg;

  /* Fbc External Mini Multicast Limit Low:                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2918 */

     /* FbcExternalMiniMulticastLimitLow: Lower limit for mini       */
     /* multicast pointers in external memory                        */
     /* range: 21:0, access type: RW, default value: 22'h1FA344      */
     SOC_PETRA_REG_FIELD fbc_external_mini_multicast_limit_low;

  } __ATTRIBUTE_PACKED__ fbc_external_mini_multicast_limit_low_reg;

  /* Fbc External Mini Multicast Limit High:                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2919 */

     /* FbcExternalMiniMulticastLimitHigh: Upper limit for mini      */
     /* multicast pointers in external memory                        */
     /* range: 21:0, access type: RW, default value: 22'h1FA62D      */
     SOC_PETRA_REG_FIELD fbc_external_mini_multicast_limit_high;

  } __ATTRIBUTE_PACKED__ fbc_external_mini_multicast_limit_high_reg;

  /* Fbc External Unicast Limit Low:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x291a */

     /* FbcExternalUnicastLimitLow: Lower limit for unicast          */
     /* pointers in external memory.                                 */
     /* range: 21:0, access type: RW, default value: 22'h1FA62E      */
     SOC_PETRA_REG_FIELD fbc_external_unicast_limit_low;

  } __ATTRIBUTE_PACKED__ fbc_external_unicast_limit_low_reg;

  /* Fbc External Unicast Limit High:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x291b */

     /* FbcExternalUnicastLimitHigh: Upper limit for unicast         */
     /* pointers in external memory                                  */
     /* range: 21:0, access type: RW, default value: 22'h1FFFFF      */
     SOC_PETRA_REG_FIELD fbc_external_unicast_limit_high;

  } __ATTRIBUTE_PACKED__ fbc_external_unicast_limit_high_reg;

  /* Reassembly Errors:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2991 */

     /* ReassemblyErrors: Number of reassembly errors This           */
     /* register is clear on read.                                   */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_errors;

     /* ReassemblyErrorMask: Masks the reassembly errors             */
     /* counted. Bits have the following meaning: bit 0 -            */
     /* minimum original size error bit 1 - minimum size error       */
     /* bit 2 - maximum original size error bit 3 - maximum size     */
     /* error bit 4 - maximum DP error bit 5 - no PCB error bit      */
     /* 6 - no PCB for SOP word error bit 7 - no DP error bit 8      */
     /* - unexpected EOP error bit 9 - unexpected MOP error bit      */
     /* 10 - unexpected SOP error bit 11 - general error at          */
     /* middle or end of packet bit 12 - general error when idle     */
     /* range: 28:16, access type: RW, default value: 0x1fff         */
     SOC_PETRA_REG_FIELD reassembly_error_mask;

  } __ATTRIBUTE_PACKED__ reassembly_errors_reg;

  /* Reassembly Errors:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2991 */

     /* ReassemblyErrorsOvf: Overflow bit for ReassemblyErrors       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD reassembly_errors_ovf;

  } __ATTRIBUTE_PACKED__ reassembly_errors_ovf_reg;

  /* Reassembly Errors Hit:                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2992 */

     /* ReassemblyErrorsHit: Specifies which reassembly errors       */
     /* were hit. This register is clear on read.                    */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD reassembly_errors_hit;

  } __ATTRIBUTE_PACKED__ reassembly_errors_hit_reg;

  /* Reassembly Timeout:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2993 */

     /* ReassemblyTimeout: Timeout period for reassembly             */
     /* controller. If there is a non-idle context for more than     */
     /* the specified number of clocks, a timeout interrupt is       */
     /* raised.                                                      */
     /* range: 23:0, access type: RW, default value: 0x200           */
     SOC_PETRA_REG_FIELD reassembly_timeout;

  } __ATTRIBUTE_PACKED__ reassembly_timeout_reg;

  /* Timeout Reg:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2997 */

     /* TimeoutReg: Specifies which contexts (FAP-port) timed        */
     /* out. A timeout occurs when an EOP wasn't received for        */
     /* the specified timeout duration.                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD timeout_reg;

  } __ATTRIBUTE_PACKED__ timeout_reg[SOC_PB_IDR_TIMEOUT_REG_MULT_NOF_REGS];

  /* Counters Fap Ports: Defines the four fap ports for which       */
  /* counters are defined. A value of -1 indicates an invalid       */
  /* fap port.                                                      */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x299f */

    /* FapPort0-FapPort3: FAP ports for which counters are defined. */
    /* range: 6:0, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD fap_port[SOC_PB_COUNTERS_FAP_PORTS_NOF_FLDS];
  } __ATTRIBUTE_PACKED__ counters_fap_ports_reg;

  /* Received Packets0:                                             */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x29a0 */

    /* ReceivedPackets0: Number of received packets for             */
    /* configured fap port 0. When the 32 lsb of this register      */
    /* are read the counter msb value is sampled (to enable         */
    /* reading) but actual counting is restarted for zero. This     */
    /* register is clear on read.                                   */
    /* range: 31:0, access type: RO, default value: 0x0             */
    SOC_PETRA_REG_FIELD received_packets0;

  } __ATTRIBUTE_PACKED__ received_packets0_reg_0;

  /* Received Packets1:                                             */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x29a4 */

    /* ReceivedPackets1: Number of received packets for             */
    /* configured fap port 1. When the 32 lsb of this register      */
    /* are read the counter msb value is sampled (to enable         */
    /* reading) but actual counting is restarted for zero. This     */
    /* register is clear on read.                                   */
    /* range: 31:0, access type: RO, default value: 0x0             */
    SOC_PETRA_REG_FIELD received_packets1;

  } __ATTRIBUTE_PACKED__ received_packets1_reg_0;

  /* Received Packets2:                                             */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x29a8 */

    /* ReceivedPackets2: Number of received packets for             */
    /* configured fap port 2. When the 32 lsb of this register      */
    /* are read the counter msb value is sampled (to enable         */
    /* reading) but actual counting is restarted for zero. This     */
    /* register is clear on read.                                   */
    /* range: 31:0, access type: RO, default value: 0x0             */
    SOC_PETRA_REG_FIELD received_packets2;

  } __ATTRIBUTE_PACKED__ received_packets2_reg_0;

  /* Received Packets3:                                             */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x29ac */

    /* ReceivedPackets3: Number of received packets for             */
    /* configured fap port 3. When the 32 lsb of this register      */
    /* are read the counter msb value is sampled (to enable         */
    /* reading) but actual counting is restarted for zero. This     */
    /* register is clear on read.                                   */
    /* range: 31:0, access type: RO, default value: 0x0             */
    SOC_PETRA_REG_FIELD received_packets3;

  } __ATTRIBUTE_PACKED__ received_packets3_reg_0;

  /* Ire Ready Clks Cnt: Counts number of clocks the ready          */
  /* signal was set on the IDR2IRE interface.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a0 */

     /* IreReadyClks: Number of clocks the ready signal was set      */
     /* (IDR2IRE) This register is clear on read.                    */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ire_ready_clks;

     /* IreReadyClksOvf: If set then number of ready clocks          */
     /* overflowed                                                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ire_ready_clks_ovf;

  } __ATTRIBUTE_PACKED__ ire_ready_clks_cnt_reg;

  /* Mmu Desc Credits Cnt: Counts number of desc credits            */
  /* received in IDR from MMU.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a1 */

     /* MmuDescCredits: Number of desc credits received in IDR       */
     /* from MMU This register is clear on read.                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mmu_desc_credits;

     /* MmuDescCreditsOvf: If set then number of desc credits        */
     /* received overflowed                                          */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mmu_desc_credits_ovf;

  } __ATTRIBUTE_PACKED__ mmu_desc_credits_cnt_reg;

  /* Received Packets[0..3]Cnt:                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a2 */

     /* ReceivedPacketsCnt: Number of received packets for           */
     /* configured fap port                                          */
     /* range: 63:0, access type: CNT, default value: 0x0            */
     SOC_PETRA_REG_FIELD received_packets_cnt;

  } __ATTRIBUTE_PACKED__ received_packets_cnt_reg[SOC_PB_IDR_REGS_RECEIVED_PACKETS_CNT_REG_ARRAY_SIZE][SOC_PB_IDR_RECEIVED_PACKETS_CNT_REG_MULT_NOF_REGS];

  /* Discarded Packets[0..3]Cnt:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a4 */

     /* DiscardedPacketsCnt: Number of discarded packets for         */
     /* configured fap port                                          */
     /* range: 63:0, access type: CNT, default value: 0x0            */
     SOC_PETRA_REG_FIELD discarded_packets_cnt;

  } __ATTRIBUTE_PACKED__ discarded_packets_cnt_reg[SOC_PB_IDR_REGS_DISCARDED_PACKETS_CNT_REG_ARRAY_SIZE][SOC_PB_IDR_DISCARDED_PACKETS_CNT_REG_MULT_NOF_REGS];

  /* Received Octets[0..3]Cnt:                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a6 */

     /* ReceivedOctetsCnt: Number of received octets for             */
     /* configured fap port                                          */
     /* range: 63:0, access type: CNT, default value: 0x0            */
     SOC_PETRA_REG_FIELD received_octets_cnt;

  } __ATTRIBUTE_PACKED__ received_octets_cnt_reg[SOC_PB_IDR_REGS_RECEIVED_OCTETS_CNT_REG_ARRAY_SIZE][SOC_PB_IDR_RECEIVED_OCTETS_CNT_REG_MULT_NOF_REGS];

  /* Discarded Octets[0..3]Cnt:                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a8 */

     /* DiscardedOctetsCnt: Number of received packets for           */
     /* configured fap port                                          */
     /* range: 63:0, access type: CNT, default value: 0x0            */
     SOC_PETRA_REG_FIELD discarded_octets_cnt;

  } __ATTRIBUTE_PACKED__ discarded_octets_cnt_reg[SOC_PB_IDR_REGS_DISCARDED_OCTETS_CNT_REG_ARRAY_SIZE][SOC_PB_IDR_DISCARDED_OCTETS_CNT_REG_MULT_NOF_REGS];

} __ATTRIBUTE_PACKED__ SOC_PB_IDR_REGS;
/* Block definition: IRR 	 */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in the IRR.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a00 */

     /* ErrMaxReplication: Set for an ingress multicast packet       */
     /* which is replicated more than a configurable value.          */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD err_max_replication;

     /* ErrIsMaxReplication: Set for an ingress multicast packet     */
     /* which is replicated more than a configurable value.          */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD err_is_max_replication;

     /* ErrorResequencer0OutOfSeq: If set, indicates that the        */
     /* resequencer of fat pipe 0 encountered an out-of-sequence     */
     /* error.                                                       */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_resequencer0_out_of_seq;

     /* ErrorResequencer1OutOfSeq: If set, indicates that the        */
     /* resequencer of fat pipe 1 encountered an out-of-sequence     */
     /* error.                                                       */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_resequencer1_out_of_seq;

     /* ErrorResequencer2OutOfSeq: If set, indicates that the        */
     /* resequencer of fat pipe 2 encountered an out-of-sequence     */
     /* error.                                                       */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_resequencer2_out_of_seq;

     /* ErrorResequencer0OutOfSync: If set, indicates that the       */
     /* resequencer of fat pipe 0 encountered an                     */
     /* out-of-synchronization error.                                */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_resequencer0_out_of_sync;

     /* ErrorResequencer1OutOfSync: If set, indicates that the       */
     /* resequencer of fat pipe 1 encountered an                     */
     /* out-of-synchronization error.                                */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_resequencer1_out_of_sync;

     /* ErrorResequencer2OutOfSync: If set, indicates that the       */
     /* resequencer of fat pipe 2 encountered an                     */
     /* out-of-synchronization error.                                */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_resequencer2_out_of_sync;

     /* ErrorMemory0: If set, indicates a parity error was found     */
     /* in a memory                                                  */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_memory0;

     /* ErrorMemory1: If set, indicates an ECC error of type 1       */
     /* was found in a memory                                        */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_memory1;

     /* ErrorMemory2: If set, indicates an ECC error of type 2       */
     /* was found in a memory                                        */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_memory2;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Memory Interrupt Register0: This register contains the         */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a01 */

     /* LagMappingBitError: If set, indicates there was an ECC       */
     /* error.                                                       */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD lag_mapping_bit_error;

     /* LagNextMemberBitError: If set, indicates there was an        */
     /* ECC error.                                                   */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD lag_next_member_bit_error;

     /* LagToLagRangeBitError: If set, indicates there was an        */
     /* ECC error.                                                   */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD lag_to_lag_range_bit_error;

     /* McdbBitError: If set, indicates there was an ECC error.      */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mcdb_bit_error;

     /* IrdbBitError: If set, indicates there was an ECC error.      */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD irdb_bit_error;

     /* DestinationTableBitError: If set, indicates there was an     */
     /* ECC error.                                                   */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD destination_table_bit_error;

     /* SmoothDivisionBitError: If set, indicates there was an       */
     /* ECC error.                                                   */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD smooth_division_bit_error;

     /* SnoopMirrorTable0BitError: If set, indicates there was       */
     /* an ECC error.                                                */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD snoop_mirror_table0_bit_error;

     /* SnoopMirrorTable1BitError: If set, indicates there was       */
     /* an ECC error.                                                */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD snoop_mirror_table1_bit_error;

  } __ATTRIBUTE_PACKED__ memory_interrupt_0_reg;

  /* Memory Interrupt Register[1..2]: This register contains        */
  /* the interrupt sources residing in this unit.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a02 */

     /* FreePcbMemoryEccError: If set, indicates there was an        */
     /* ECC error.                                                   */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD free_pcb_memory_ecc_error;

     /* IsFreePcbMemoryEccError: If set, indicates there was an      */
     /* ECC error.                                                   */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD is_free_pcb_memory_ecc_error;

     /* IsPcMemoryEccError: If set, indicates there was an ECC       */
     /* error.                                                       */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD is_pc_memory_ecc_error;

     /* IsPcbLinkTableEccError: If set, indicates there was an       */
     /* ECC error.                                                   */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD is_pcb_link_table_ecc_error;

     /* IsfMemoryEccError: If set, indicates there was an ECC        */
     /* error.                                                       */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD isf_memory_ecc_error;

     /* McrMemoryEccError: If set, indicates there was an ECC        */
     /* error.                                                       */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mcr_memory_ecc_error;

     /* PcMemoryEccError: If set, indicates there was an ECC         */
     /* error.                                                       */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD pc_memory_ecc_error;

     /* PcbLinkTableEccError: If set, indicates there was an ECC     */
     /* error.                                                       */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD pcb_link_table_ecc_error;

     /* RpfMemoryEccError: If set, indicates there was an ECC        */
     /* error.                                                       */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rpf_memory_ecc_error;

     /* RsqFifoEccError: If set, indicates there was an ECC          */
     /* error.                                                       */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rsq_fifo_ecc_error;

  } __ATTRIBUTE_PACKED__ memory_interrupt_reg[SOC_PB_IRR_REGS_MEMORY_INTERRUPT_REG_ARRAY_SIZE];

  /* Interrupt Register Mask: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a10 */

     /* ErrMaxReplicationMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD err_max_replication_mask;

     /* ErrIsMaxReplicationMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD err_is_max_replication_mask;

     /* ErrorResequencer0OutOfSeqMask: Writing 0 masks the           */
     /* corresponding interrupt source.                              */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_resequencer0_out_of_seq_mask;

     /* ErrorResequencer1OutOfSeqMask: Writing 0 masks the           */
     /* corresponding interrupt source.                              */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_resequencer1_out_of_seq_mask;

     /* ErrorResequencer2OutOfSeqMask: Writing 0 masks the           */
     /* corresponding interrupt source.                              */
     /* range: 4:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_resequencer2_out_of_seq_mask;

     /* ErrorResequencer0OutOfSyncMask: Writing 0 masks the          */
     /* corresponding interrupt source.                              */
     /* range: 5:5, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_resequencer0_out_of_sync_mask;

     /* ErrorResequencer1OutOfSyncMask: Writing 0 masks the          */
     /* corresponding interrupt source.                              */
     /* range: 6:6, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_resequencer1_out_of_sync_mask;

     /* ErrorResequencer2OutOfSyncMask: Writing 0 masks the          */
     /* corresponding interrupt source.                              */
     /* range: 7:7, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_resequencer2_out_of_sync_mask;

     /* ErrorMemory0Mask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 8:8, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_memory0_mask;

     /* ErrorMemory1Mask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 9:9, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD error_memory1_mask;

     /* ErrorMemory2Mask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 10:10, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD error_memory2_mask;

  } __ATTRIBUTE_PACKED__ interrupt_register_mask_reg;

  /* Memory Interrupt Register0 Mask: This register contains        */
  /* the interrupt sources residing in this unit.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a11 */

     /* LagMappingBitErrorMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD lag_mapping_bit_error_mask;

     /* LagNextMemberBitErrorMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD lag_next_member_bit_error_mask;

     /* LagToLagRangeBitErrorMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD lag_to_lag_range_bit_error_mask;

     /* McdbBitErrorMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD mcdb_bit_error_mask;

     /* IrdbBitErrorMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 4:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD irdb_bit_error_mask;

     /* DestinationTableBitErrorMask: Writing 0 masks the            */
     /* corresponding interrupt source                               */
     /* range: 5:5, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD destination_table_bit_error_mask;

     /* SmoothDivisionBitErrorMask: Writing 0 masks the              */
     /* corresponding interrupt source                               */
     /* range: 6:6, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD smooth_division_bit_error_mask;

     /* SnoopMirrorTable0BitErrorMask: Writing 0 masks the           */
     /* corresponding interrupt source                               */
     /* range: 7:7, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD snoop_mirror_table0_bit_error_mask;

     /* SnoopMirrorTable1BitErrorMask: Writing 0 masks the           */
     /* corresponding interrupt source                               */
     /* range: 8:8, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD snoop_mirror_table1_bit_error_mask;

  } __ATTRIBUTE_PACKED__ memory_interrupt_register0_mask_reg;

  /* Memory Interrupt Register[1..2]Mask: This register             */
  /* contains the interrupt sources residing in this unit.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a12 */

     /* FreePcbMemoryEccErrorMaskMask: Writing 0 masks the           */
     /* corresponding interrupt source                               */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD free_pcb_memory_ecc_error_mask_mask;

     /* IsFreePcbMemoryEccErrorMaskMask: Writing 0 masks the         */
     /* corresponding interrupt source                               */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD is_free_pcb_memory_ecc_error_mask_mask;

     /* IsPcMemoryEccErrorMaskMask: Writing 0 masks the              */
     /* corresponding interrupt source                               */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD is_pc_memory_ecc_error_mask_mask;

     /* IsPcbLinkTableEccErrorMaskMask: Writing 0 masks the          */
     /* corresponding interrupt source                               */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD is_pcb_link_table_ecc_error_mask_mask;

     /* IsfMemoryEccErrorMaskMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 4:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD isf_memory_ecc_error_mask_mask;

     /* McrMemoryEccErrorMaskMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 5:5, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD mcr_memory_ecc_error_mask_mask;

     /* PcMemoryEccErrorMaskMask: Writing 0 masks the                */
     /* corresponding interrupt source                               */
     /* range: 6:6, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD pc_memory_ecc_error_mask_mask;

     /* PcbLinkTableEccErrorMaskMask: Writing 0 masks the            */
     /* corresponding interrupt source                               */
     /* range: 7:7, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD pcb_link_table_ecc_error_mask_mask;

     /* RpfMemoryEccErrorMaskMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 8:8, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD rpf_memory_ecc_error_mask_mask;

     /* RsqFifoEccErrorMaskMask: Writing 0 masks the                 */
     /* corresponding interrupt source                               */
     /* range: 9:9, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD rsq_fifo_ecc_error_mask_mask;

  } __ATTRIBUTE_PACKED__ memory_interrupt_register_mask_reg[SOC_PB_IRR_REGS_MEMORY_INTERRUPT_REGISTER_MASK_REG_ARRAY_SIZE];

  /* Indirect Command Wr Data:                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a20 */

     /* IndirectCommandWrData: Indirect write data. Data that is     */
     /* be written to the addressed object when an indirect          */
     /* write operation is triggered.                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_IRR_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data:                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a30 */

     /* IndirectCommandRdData: Data returned by an indirect read     */
     /* operation                                                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_IRR_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a40 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* "IndirectCommandCount" number of times. The address is       */
     /* advanced by one with every write command. If set to 0,       */
     /* one operation is performed. The CPU can read this field      */
     /* to find the number of writes left.                           */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a41 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0:-         */
     /* Write operation 1:- Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a42 */

     /* IndirectCommandDataIncrement:                                */
     /* IndirectCommandWrData[31:0] is incremented by this value     */
     /* after every indirect write. Addition is cyclic.              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_IRR_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* Gtimer Configuration:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b00 */

     /* GtimerCycle: The number of clocks the gtimer will count.     */
     /* range: 29:0, access type: RW, default value: 30'd250_000_000 */
     SOC_PETRA_REG_FIELD gtimer_cycle;

     /* GtimerEnable: Whether to use all the counters in gtimer      */
     /* mode or read on clear                                        */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_enable;

     /* GtimerResetOnTrigger: If set, the gtimer will output a       */
     /* reset signal when the count begins.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_reset_on_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Gtimer Trigger:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b01 */

     /* GtimerTrigger: When this register is written to, the         */
     /* gtimer starts counting. When this register is read, it       */
     /* gives the gtimer status (1= still counting, 0=count is       */
     /* over).                                                       */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_trigger_reg;

  /* Static Configuration: General static configuration             */
  /* register. The bits in this register may be changed only        */
  /* during initial configuration.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b02 */

     /* DisEcc: If set, ECC is disabled for all memories (except     */
     /* LagMapping memory)                                           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_ecc;

     /* DisLagEcc: If set, then ECC is disabled for the              */
     /* LagMapping memory.                                           */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dis_lag_ecc;

     /* TcMapDisableIngressShaping: If set then the traffic          */
     /* class is not added to the base queue during the ingress      */
     /* shaping queue resolution                                     */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tc_map_disable_ingress_shaping;

     /* MeterUpdateAllCopies: If set then all ingress multicast      */
     /* copies set the meter update bit (to the IQM). Otherwise      */
     /* only the first copy updates the meter.                       */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD meter_update_all_copies;

     /* CountAllCopies: If reset then all ingress multicast          */
     /* copies of a packet, except the first, have the counter       */
     /* pointers set to zero. Else, all ingress multicast copies     */
     /* have the same counter pointers.                              */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD count_all_copies;

     /* TrafficClassHp: For a Multicast packet with DP 'n', if       */
     /* bit 'n' is set, then the Multicast packet is mapped to       */
     /* the high-priority queue.                                     */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD traffic_class_hp;

  } __ATTRIBUTE_PACKED__ static_configuration_reg;

  /* Flow-Control Thresholds: These flow-control thresholds         */
  /* notify the IPS of the queue fullness for packets               */
  /* received after ingress shaping.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b03 */

     /* DeqFcThresholdL: Low threshold to the IPS, indicating a      */
     /* small number of free IS_PCBs left in the IRR. Note that       */
     /* the actual low threshold is the programmed value             */
     /* multiplied by 2.                                             */
     /* range: 6:0, access type: RW, default value: 0x28             */
     SOC_PETRA_REG_FIELD deq_fc_threshold_l;

     /* DeqFcThresholdH: High threshold to the IPS, indicating a     */
     /* small number of free IS_PCBs left in the IRR. Note that      */
     /* the actual high threshold is the programmed value            */
     /* multiplied by 2.                                             */
     /* range: 14:8, access type: RW, default value: 0x32            */
     SOC_PETRA_REG_FIELD deq_fc_threshold_h;

  } __ATTRIBUTE_PACKED__ flow_control_thresholds_reg;

  /* Dynamic Configuration: General dynamic configuration           */
  /* registers. The bits in this register may be changed on         */
  /* the fly.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b04 */

     /* EnableDataPathIdr: If set, the IRR allows incoming data      */
     /* words from the IDR to pass through. This register is         */
     /* reset with the block's soft reset.                           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_data_path_idr;

     /* EnableDataPathIqm: If set, the IRR allows incoming data      */
     /* words from the IQM to pass through. This register is         */
     /* reset with the block's soft reset.                           */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_data_path_iqm;

     /* UseDestAsMcCud: If set then destination is used as the       */
     /* CUD for fabric or egress multicast packets                   */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD use_dest_as_mc_cud;

     /* UseDestAsIngressMcCud: If set then destination is used       */
     /* as the CUD for ingress multicast packets                     */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD use_dest_as_ingress_mc_cud;

     /* UseDestAsUcCud: If set then destination is used as the       */
     /* CUD for unicast packets                                      */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD use_dest_as_uc_cud;

     /* UseOutlifAsMcidInReport: If set then the outlif is           */
     /* reported as multicast id for ingress multicast copies        */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD use_outlif_as_mcid_in_report;

     /* UcFifoThreshold: When number of free entries in the          */
     /* unicast FIFO is below this threshold packets with snoop      */
     /* or mirror are marked as erroneous.                           */
     /* range: 25:16, access type: RW, default value: 0x5            */
     SOC_PETRA_REG_FIELD uc_fifo_threshold;

  } __ATTRIBUTE_PACKED__ dynamic_configuration_reg;

  /* Arbiter Configuration: These registers control a               */
  /* weighted arbiter that selects between multicast packets        */
  /* and packets after ingress shaping.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b05 */

     /* ArbiterThreshold: The maximum number of credits that can     */
     /* be kept by the arbiter.                                      */
     /* range: 15:0, access type: RW, default value: 0x80            */
     SOC_PETRA_REG_FIELD arbiter_threshold;

     /* ArbiterMulticastWeight: Weight of multicast packets          */
     /* (received from the IDR)                                      */
     /* range: 19:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD arbiter_multicast_weight;

     /* ArbiterIngressShapingWeight: Weight of packets after         */
     /* ingress shaping.                                             */
     /* range: 23:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD arbiter_ingress_shaping_weight;

  } __ATTRIBUTE_PACKED__ arbiter_configuration_reg;

  /* Snoop Size:                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b06 */

     /* SnoopSize: For snoop command 'i'( in the range of 1-15)      */
     /* bits [2i-1, 2i-2] specify the size of the snooped packet     */
     /* that will be generated. Possible values are: 2'b00 -         */
     /* First 64 bytes 2'b01 - First 128 bytes 2'b10 - First 192     */
     /* bytes 2'b11 - Full packet.                                   */
     /* range: 29:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD snoop_size;

  } __ATTRIBUTE_PACKED__ snoop_size_reg;

  /* Port Is Outbound Mirror:                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b07 */

     /* PortIsOutboundMirror: For each incoming port, specifies      */
     /* whether it is connected to a mirrored outgoing port.         */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_is_outbound_mirror;

  } __ATTRIBUTE_PACKED__ port_is_outbound_mirror_reg[SOC_PB_IRR_PORT_IS_OUTBOUND_MIRROR_REG_MULT_NOF_REGS];

  /* Mcr Fifo Config: The unicast, multicast high and               */
  /* multicast low FIFOs share one memory of 768 entries. It        */
  /* is suggested that the size of each FIFO be at least 10.        */
  /* These limits determine their position and size.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b0a */

     /* McrLimitUc: The unicast FIFO is from 0 to McrLimitUc-1.      */
     /* range: 9:0, access type: RW, default value: 0x100            */
     SOC_PETRA_REG_FIELD mcr_limit_uc;

     /* McrLimitMcHp: The multicast high-priority FIFO is from       */
     /* McrLimitUc to McrLimitMcHp-1. The multicast low-pirority     */
     /* FIFO is from McrLimitMcHP to 767.                            */
     /* range: 25:16, access type: RW, default value: 0x200          */
     SOC_PETRA_REG_FIELD mcr_limit_mc_hp;

  } __ATTRIBUTE_PACKED__ mcr_fifo_config_reg;

  /* Error Max Replication Multicast ID:                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b0b */

     /* ErrorMaxReplicationMulticastID: This register Holds the      */
     /* Multicast ID of the first packet that has more than the      */
     /* configured number of ingress multicast replications.         */
     /* Reading this value does not clear the interrupt              */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_max_replication_multicast_id;

  } __ATTRIBUTE_PACKED__ error_max_replication_multicast_id_reg;

  /* Error Ingress Shaping Max Replication Multicast ID:            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b0c */

     /* ErrorIngressShapingMaxReplicationMulticastID: This           */
     /* register Holds the Multicast ID of the first packet,         */
     /* after ingress shaping, that has more than the configured     */
     /* number of ingress multicast replications. Reading this       */
     /* value does not clear the interrupt                           */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_ingress_shaping_max_replication_multicast_id;

  } __ATTRIBUTE_PACKED__ error_ingress_shaping_max_replication_multicast_id_reg;

  /* Max Replications:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b0d */

     /* MaxReplications: This register limits the maximum number     */
     /* of ingress multicast replications for a packet. The          */
     /* maximum number of replications is either                     */
     /* MaxReplicationRegister+1 or MaxReplicationRegister+2,        */
     /* depending on link list structure                             */
     /* range: 12:0, access type: RW, default value: 0x1000          */
     SOC_PETRA_REG_FIELD max_replications;

  } __ATTRIBUTE_PACKED__ max_replications_reg;

  /* Fabric Multicast Base Queue:                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b0e */

     /* FabricMulticastBaseQueue: Base queue for fabric              */
     /* mutlicast or egress multicast queues.                        */
     /* range: 15:0, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD egress_or_fabric_multicast_base_queue_register;

  } __ATTRIBUTE_PACKED__ egress_or_fabric_multicast_base_queue_reg;

  /* Resequencer Configuration: These parameters control the        */
  /* behavior of the resequencer.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b0f */

     /* ResequencerMode: Determines the resequencer mode of          */
     /* operation, which can be one of the following 2'b00 -         */
     /* 3x4: Three resequencers of up to 4 ports each. 2'b01 -       */
     /* 2x6: Two resequencers of up to 6 ports each. 2'b10 -         */
     /* 1x12: One resequencer of up to 12 ports. 2'b11 -             */
     /* Reserved                                                     */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer_mode;

     /* ResequencerBypassEnable: Enables a mode where some           */
     /* packets can bypass the Resequencing process. If the          */
     /* Bypass mode is set, then the sequence number range is        */
     /* only 15b [14:0] instead of 16b, and bit 15, if set,          */
     /* indicates that the packet should bypass the Resequencing     */
     /* process                                                      */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer_bypass_enable;

     /* ResequencerFastEnable: If set, then fast resequencing is     */
     /* enabled. In this mode, a resequencer can make a              */
     /* selection when the next sequencer number is one larger       */
     /* than the previous one selected.                              */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD resequencer_fast_enable;

     /* Resequencer0Flush: When writing one to this register,        */
     /* the matching resequencer flushes. When reading '1' from      */
     /* this register the matching resequencer is in the process     */
     /* of flushing.                                                 */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer0_flush;

     /* Resequencer1Flush: When writing one to this register,        */
     /* the matching resequencer flushes. When reading '1' from      */
     /* this register the matching resequencer is in the process     */
     /* of flushing.                                                 */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer1_flush;

     /* Resequencer2Flush: When writing one to this register,        */
     /* the matching resequencer flushes. When reading '1' from      */
     /* this register the matching resequencer is in the process     */
     /* of flushing.                                                 */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer2_flush;

     /* ResequencerDropOutOfSeq: If set then, out-of-sequence        */
     /* packets are dropped.                                         */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer_drop_out_of_seq;

     /* ResequencerFifoFullMark: Specifies the maximum number of     */
     /* entries in a resequencer FIFO. When the number of            */
     /* entries reaches this limit, the resequencer FIFOs get        */
     /* flushed.                                                     */
     /* range: 27:16, access type: RW, default value: 0x130          */
     SOC_PETRA_REG_FIELD resequencer_fifo_full_mark;

  } __ATTRIBUTE_PACKED__ resequencer_configuration_reg;

  /* Resequencer Ports: Ports mapped to each resequencer are        */
  /* mapped to a shared value                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b10 */

     /* Resequencer0Port: Ports belonging to resequencer 0 are       */
     /* mapped to this port                                          */
     /* range: 6:0, access type: RW, default value: 0x1              */
     /* Resequencer1Port: Ports belonging to resequencer 1 are       */
     /* mapped to this port                                          */
     /* range: 14:8, access type: RW, default value: 0x2             */
     /* Resequencer2Port: Ports belonging to resequencer 2 are       */
     /* mapped to this port                                          */
     /* range: 22:16, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD resequencer_port[SOC_PB_REG_NOF_RESEQS];
  } __ATTRIBUTE_PACKED__ resequencer_ports_reg;

  /* Resequencer Thresholds: These thresholds control the           */
  /* events in which the resequencer can make a decision.           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b11 */

     /* ResequencerFifoTh: When number of entries in FIFO is         */
     /* above this threshold, the resequencer can make a             */
     /* selection based on the 'smallest' sequence number that       */
     /* is present in one of the FIFOs.                              */
     /* range: 11:0, access type: RW, default value: 0x100           */
     SOC_PETRA_REG_FIELD resequencer_fifo_th;

     /* ResequencerNoActivityTh: When a packet is not received       */
     /* for a specified number of clocks, the resequencer makes      */
     /* a selection based on the 'smallest' sequence number that     */
     /* is present in one of the FIFOs.                              */
     /* range: 31:12, access type: RW, default value: 0x1000         */
     SOC_PETRA_REG_FIELD resequencer_no_activity_th;

  } __ATTRIBUTE_PACKED__ resequencer_thresholds_reg;

  /* Resequencer Fifo Index:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b12 */

     /* ResequencerFifoIndex: For each of the first 16 FAP           */
     /* ports, selects one of 12 resequencer FIFOs. Each nibble      */
     /* corresponds to a FAP port. A value of '-1' specifies         */
     /* that resequencing is not needed for this port. For           */
     /* standard operation this should be a one-to-one mapping.      */
     /* range: 31:0, access type: RW, default value: 64'hFFFBA9876543210F */
     SOC_PETRA_REG_FIELD resequencer_fifo_index[SOC_PB_REG_NOF_IRR_RESEQ_PORT_PER_FIFO];

  } __ATTRIBUTE_PACKED__ resequencer_fifo_index_reg[SOC_PB_IRR_RESEQUENCER_FIFO_INDEX_REG_MULT_NOF_REGS];

  /* Resequencer Fifo Valid:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b14 */

     /* ResequencerFifoValid: Specifies for each resequencer         */
     /* FIFO whether it is used or not.                              */
     /* range: 11:0, access type: RW, default value: 0xfff           */
     SOC_PETRA_REG_FIELD resequencer_fifo_valid;

  } __ATTRIBUTE_PACKED__ resequencer_fifo_valid_reg;

  /* Resequencer Error Overflow:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b15 */

     /* Resequencer0ErrorOutOfSeqOvf: If set, then the               */
     /* corresponding counter has overflowed                         */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer0_error_out_of_seq_ovf;

     /* Resequencer0ErrorOutOfSyncOvf: If set, then the              */
     /* corresponding counter has overflowed                         */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer0_error_out_of_sync_ovf;

     /* Resequencer1ErrorOutOfSeqOvf: If set, then the               */
     /* corresponding counter has overflowed                         */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer1_error_out_of_seq_ovf;

     /* Resequencer1ErrorOutOfSyncOvf: If set, then the              */
     /* corresponding counter has overflowed                         */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer1_error_out_of_sync_ovf;

     /* Resequencer2ErrorOutOfSeqOvf: If set, then the               */
     /* corresponding counter has overflowed                         */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer2_error_out_of_seq_ovf;

     /* Resequencer2ErrorOutOfSyncOvf: If set, then the              */
     /* corresponding counter has overflowed                         */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequencer2_error_out_of_sync_ovf;

  } __ATTRIBUTE_PACKED__ resequencer_error_overflow_reg;

  /* Resequencer Status[0..2]:                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b16 */

     /* ResequencerNextSn: Next sequence number expected by the      */
     /* resequencer                                                  */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD resequencer_next_sn;

     /* ResequencerNextSnValid: If set, then the next sequencer      */
     /* number is valid                                              */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD resequencer_next_sn_valid;

  } __ATTRIBUTE_PACKED__ resequencer_status_reg[SOC_PB_IRR_REGS_RESEQUENCER_STATUS_REG_ARRAY_SIZE];

  /* Resequencer Errors[0..2]:                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2b17 */

     /* ResequencerErrorOutOfSeq: Number of out-of-sequence          */
     /* errors. This register is clear on read.                      */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD resequencer_error_out_of_seq;

     /* ResequencerErrorOutOfSync: Number of                         */
     /* out-of-synchronization errors. This register is clear on     */
     /* read.                                                        */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD resequencer_error_out_of_sync;

  } __ATTRIBUTE_PACKED__ resequencer_errors_reg[SOC_PB_IRR_REGS_RESEQUENCER_ERRORS_REG_ARRAY_SIZE];

} __ATTRIBUTE_PACKED__ SOC_PB_IRR_REGS;
/* Block definition: IHP  */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6000 */

     /* IsemInterrupt: If set, one or more of the                    */
     /* IsemInterruptRegister bits is asserted                       */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_interrupt;

     /* MactInterrupt: If set, one or more of the                    */
     /* MactInterruptRegister bits is asserted                       */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_interrupt;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Isem Interrupt Register: This register contains the            */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6001 */

     /* IsemErrorCamTableFull: If set,                               */
     /* IsemErrorCamTableFullCounter is not equal to 0               */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_error_cam_table_full;

     /* IsemErrorTableCoherency: If set,                             */
     /* IsemErrorTableCoherencyCounter is not equal to 0             */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_error_table_coherency;

     /* IsemErrorDeleteUnknownKey: If set,                           */
     /* IsemErrorDeleteUnknownKeyCounter is not equal to 0           */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_error_delete_unknown_key;

     /* IsemErrorReachedMaxEntryLimit: If set,                       */
     /* IsemErrorReachedMaxEntryLimitCounter is not equal to 0       */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_error_reached_max_entry_limit;

     /* IsemWarningInsertedExisting: If set,                         */
     /* IsemWarningInsertedExistingCounter is not equal to 0         */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_warning_inserted_existing;

     /* IsemManagementUnitFailureValid: Asserts when,                */
     /* IsemManagementUnitFailure register contains valid data       */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_management_unit_failure_valid;

     /* IsemManagementCompleted: Asserts when reply fifo is not      */
     /* empty                                                        */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_management_completed;

  } __ATTRIBUTE_PACKED__ isem_interrupt_reg;

  /* Mact Interrupt Register: This register contains the            */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6002 */

     /* MactErrorCamTableFull: If set,                               */
     /* MactErrorCamTableFullCounter is not equal to 0               */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_cam_table_full;

     /* MactErrorTableCoherency: If set,                             */
     /* MactErrorTableCoherencyCounter is not equal to 0             */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_table_coherency;

     /* MactErrorDeleteUnknownKey: If set,                           */
     /* MactErrorDeleteUnknownKeyCounter is not equal to 0           */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_delete_unknown_key;

     /* MactErrorReachedMaxEntryLimit: If set,                       */
     /* MactErrorReachedMaxEntryLimitCounter is not equal to 0       */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_reached_max_entry_limit;

     /* MactWarningInsertedExisting: If set,                         */
     /* MactWarningInsertedExistingCounter is not equal to 0         */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_warning_inserted_existing;

     /* MactErrorLearnRequestOverStatic: If set,                     */
     /* MactErrorLearnRequestOverStaticCounter is not equal to 0     */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_learn_request_over_static;

     /* MactWarningLearnOverExisting: If set,                        */
     /* MactWarningLearnOverExistingCounter is not equal to 0        */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_warning_learn_over_existing;

     /* MactErrorChangeFailNonExist: If set,                         */
     /* MactErrorChangeFailNonExistCounter is not equal to 0         */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_change_fail_non_exist;

     /* MactErrorChangeRequestOverStatic: If set,                    */
     /* MactErrorChangeRequestOverStaticCounter is not equal to      */
     /* 0                                                            */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_change_request_over_static;

     /* MactWarningChangeNonExistFromOther: If set,                  */
     /* MactWarningChangeNonExistFromOtherCounter is not equal       */
     /* to 0                                                         */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_warning_change_non_exist_from_other;

     /* MactWarningChangeNonExistFromSelf: If set,                   */
     /* MactWarningChangeNonExistFromSelfCounter is not equal to     */
     /* 0                                                            */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_warning_change_non_exist_from_self;

     /* MactManagementUnitFailureValid: If asserted,                 */
     /* MactManagementUnitFailure register contains valid data       */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_management_unit_failure_valid;

     /* MactMngmntReqFidExceedLimit: If asserted,                    */
     /* MACT-Last-FID-exceed-limit-FID contain valid data.           */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_mngmnt_req_fid_exceed_limit;

     /* MactMngmntReqFidExceedLimitStaticAllowed: If asserted,       */
     /* MACT-Last-FID-exceed-limit-Static-FID contain valid data     */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_mngmnt_req_fid_exceed_limit_static_allowed;

     /* MactMngmntReqSystemVsiNotFound: If asserted,                 */
     /* MACT-System-VSI-not-found contains valid data                */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_mngmnt_req_system_vsi_not_found;

     /* MactEventReady: If asserted, an event is ready for           */
     /* reading                                                      */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_event_ready;

     /* MactEventFifoEventDrop: If set, one of the Event-FIFO        */
     /* drop counters is not equal to 0                              */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_event_fifo_event_drop;

     /* MactEventFifoHighThresholdReached: If set, Event FIFO        */
     /* reached high threshold                                       */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_event_fifo_high_threshold_reached;

     /* MactReplyReady: Asserted when reply FIFO is not empty        */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_reply_ready;

     /* MactReplyFifoReplyDrop: If set, Reply-FIFO drop counters     */
     /* is not equal to 0                                            */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_reply_fifo_reply_drop;

     /* MactLookupBurstFifoDrop: If set, Lookup-Burst-FIFO drop      */
     /* counter is not equal to 0                                    */
     /* range: 20:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_lookup_burst_fifo_drop;

     /* MactAgeReachedEndIndex: If asserted, the aging machine       */
     /* has reached EndIndex                                         */
     /* range: 21:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_age_reached_end_index;

     /* MactFluReachedEndIndex: If asserted, the flush machine       */
     /* has reached EndIndex                                         */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_flu_reached_end_index;

     /* MactAmsgDrop: If asserted, the AMSG FIFO dropped an          */
     /* entry                                                        */
     /* range: 23:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_amsg_drop;

     /* MactFmsgDrop: If asserted, the FMSG FIFO dropped an          */
     /* entry                                                        */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_fmsg_drop;

     /* MactLookupRequestContention: If asserted, Link-Layer         */
     /* Lookup and Source/Destination Lookup were requested          */
     /* simultaneously, only the Source/Destination Lookup will      */
     /* be answered, this suggests a mis-configuration               */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_lookup_request_contention;

     /* MactSrcOrLlLookupOnWrongCycle: If asserted, Link-Layer       */
     /* Lookup Or Source Lookup were requested on the wrong          */
     /* cycle, these request will not be answered, this suggests     */
     /* a mis-configuration.                                         */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_src_or_ll_lookup_on_wrong_cycle;

  } __ATTRIBUTE_PACKED__ mact_interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6010 */

     /* IsemInterruptMask: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_interrupt_mask;

     /* MactInterruptMask: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_interrupt_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Isem Interrupt Mask Register: Each bit in this register        */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6011 */

     /* IsemErrorCamTableFullMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_error_cam_table_full_mask;

     /* IsemErrorTableCoherencyMask: Writing 0 masks the             */
     /* corresponding interrupt source                               */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_error_table_coherency_mask;

     /* IsemErrorDeleteUnknownKeyMask: Writing 0 masks the           */
     /* corresponding interrupt source                               */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_error_delete_unknown_key_mask;

     /* IsemErrorReachedMaxEntryLimitMask: Writing 0 masks the       */
     /* corresponding interrupt source                               */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_error_reached_max_entry_limit_mask;

     /* IsemWarningInsertedExistingMask: Writing 0 masks the         */
     /* corresponding interrupt source                               */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_warning_inserted_existing_mask;

     /* IsemManagementUnitFailureValidMask: Writing 0 masks the      */
     /* corresponding interrupt source                               */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_management_unit_failure_valid_mask;

     /* IsemManagementCompletedMask: Writing 0 masks the             */
     /* corresponding interrupt source                               */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD isem_management_completed_mask;

  } __ATTRIBUTE_PACKED__ isem_interrupt_mask_reg;

  /* Mact Interrupt Mask Register: Each bit in this register        */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6012 */

     /* MactErrorCamTableFullMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_cam_table_full_mask;

     /* MactErrorTableCoherencyMask: Writing 0 masks the             */
     /* corresponding interrupt source                               */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_table_coherency_mask;

     /* MactErrorDeleteUnknownKeyMask: Writing 0 masks the           */
     /* corresponding interrupt source                               */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_delete_unknown_key_mask;

     /* MactErrorReachedMaxEntryLimitMask: Writing 0 masks the       */
     /* corresponding interrupt source                               */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_reached_max_entry_limit_mask;

     /* MactWarningInsertedExistingMask: Writing 0 masks the         */
     /* corresponding interrupt source                               */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_warning_inserted_existing_mask;

     /* MactErrorLearnRequestOverStaticMask: Writing 0 masks the     */
     /* corresponding interrupt source                               */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_learn_request_over_static_mask;

     /* MactWarningLearnOverExistingMask: Writing 0 masks the        */
     /* corresponding interrupt source                               */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_warning_learn_over_existing_mask;

     /* MactErrorChangeFailNonExistMask: Writing 0 masks the         */
     /* corresponding interrupt source                               */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_change_fail_non_exist_mask;

     /* MactErrorChangeRequestOverStaticMask: Writing 0 masks        */
     /* the corresponding interrupt source                           */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_error_change_request_over_static_mask;

     /* MactWarningChangeNonExistFromOtherMask: Writing 0 masks      */
     /* the corresponding interrupt source                           */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mact_warning_change_non_exist_from_other_mask;

     /* MactWarningChangeNonExistFromSelfMask: Writing 0 masks       */
     /* the corresponding interrupt source                           */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_warning_change_non_exist_from_self_mask;

     /* MactManagementUnitFailureValidMask: Writing 0 masks the      */
     /* corresponding interrupt source                               */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_management_unit_failure_valid_mask;

     /* MactMngmntReqFidExceedLimitMask: Writing 0 masks the         */
     /* corresponding interrupt source                               */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_mngmnt_req_fid_exceed_limit_mask;

     /* MactMngmntReqFidExceedLimitStaticAllowedMask: Writing 0      */
     /* masks the corresponding interrupt source                     */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_mngmnt_req_fid_exceed_limit_static_allowed_mask;

     /* MactMngmntReqSystemVsiNotFoundMask: Writing 0 masks the      */
     /* corresponding interrupt source                               */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_mngmnt_req_system_vsi_not_found_mask;

     /* MactEventReadyMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_event_ready_mask;

     /* MactEventFifoEventDropMask: Writing 0 masks the              */
     /* corresponding interrupt source                               */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_event_fifo_event_drop_mask;

     /* MactEventFifoHighThresholdReachedMask: Writing 0 masks       */
     /* the corresponding interrupt source                           */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_event_fifo_high_threshold_reached_mask;

     /* MactReplyReadyMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_reply_ready_mask;

     /* MactReplyFifoReplyDropMask: Writing 0 masks the              */
     /* corresponding interrupt source                               */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_reply_fifo_reply_drop_mask;

     /* MactLookupBurstFifoDropMask: Writing 0 masks the             */
     /* corresponding interrupt source                               */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_lookup_burst_fifo_drop_mask;

     /* MactAgeReachedEndIndexMask: Writing 0 masks the              */
     /* corresponding interrupt source                               */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_age_reached_end_index_mask;

     /* MactFluReachedEndIndexMask: Writing 0 masks the              */
     /* corresponding interrupt source                               */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_flu_reached_end_index_mask;

     /* MactAmsgDropMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_amsg_drop_mask;

     /* MactFmsgDropMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_fmsg_drop_mask;

     /* MactLookupRequestContentionMask: Writing 0 masks the         */
     /* corresponding interrupt source                               */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_lookup_request_contention_mask;

     /* MactSrcOrLlLookupOnWrongCycleMask: Writing 0 masks the       */
     /* corresponding interrupt source                               */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mact_src_or_ll_lookup_on_wrong_cycle_mask;

  } __ATTRIBUTE_PACKED__ mact_interrupt_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6020 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_IHP_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6030 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_IHP_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6040 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically set          */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to        */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6041 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6042 */

     /* IndirectCommandDataIncrement:                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_IHP_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* Gtimer Configuration:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6054 */

     /* GtimerCycle: Period in cycles in which the counters will     */
     /* be active.                                                   */
     /* range: 29:0, access type: RW, default value: 250000000       */
     SOC_PETRA_REG_FIELD gtimer_cycle;

     /* GtimerEnable: Count using Gtimer                             */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_enable;

     /* GtimerResetOnTrigger: If asserted, the counter is reset      */
     /* when triggered                                               */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_reset_on_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Gtimer Trigger:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6055 */

     /* GtimerTrigger: Trigger indicates to start counting by        */
     /* Gtimer.                                                      */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_trigger_reg;

  /* Debug                                                      */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x6056 */

    SOC_PETRA_REG_FIELD dbg_addr;
    SOC_PETRA_REG_FIELD enable;

  } __ATTRIBUTE_PACKED__ ihp_debug_reg;

  /* Debug                                                      */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x6057 */

    SOC_PETRA_REG_FIELD val;

  } __ATTRIBUTE_PACKED__ ihp_debug_res_reg;

  /* Ihp Enablers: Global enablers for the IHP                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6080 */

     /* EnableDataPath: If set, IHP data path is enable.             */
     /* Otherwise IHP data path is disabled and packets are not      */
     /* accepted.                                                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_data_path;

     /* AcceptOnePacket: If set, IHP will accept a single packet     */
     /* from IRE, and de-assert sync. Otherwise, all packets are     */
     /* accepted. To accept another packet, user should              */
     /* de-assert and assert back this bit. Note: This is a          */
     /* debug feature, and should be used accordingly.               */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD accept_one_packet;

  } __ATTRIBUTE_PACKED__ ihp_enablers_reg;

  /* Last Received Header Reg: Holds the last received              */
  /* header, it's size, tm_port, and the calculated values in       */
  /* port termination. This regsiter is cleared when                */
  /* LastRcvdPort register is read.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6090 */

     /* LastRcvdHdr: Holds the last received header.                 */
     /* range: 31:0, access type: RO, default value: 0x0             */
    SOC_PETRA_REG_FIELD debug_header;

  } __ATTRIBUTE_PACKED__ debug_header_reg[SOC_PB_NOF_DEBUG_HEADER_REGS];

  /* Last Received Port: Holds the last received header, it's       */
  /* size, tm_port, and the calculated values in port               */
  /* termination. This regsiter is cleared when LastRcvdPort        */
  /* register is read.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x60b1 */

     /* LastRcvdTmPort: Holds the last received TM port value.       */
     /* range: 6:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD last_rcvd_tm_port;

     /* LastRcvdPacketSize: Holds the packet size of the last        */
     /* received packet.                                             */
     /* range: 14:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD last_rcvd_packet_size;

     /* LastRcvdValid: If set, Last received registers are           */
     /* valid. This register is clear on read.                       */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD last_rcvd_valid;

  } __ATTRIBUTE_PACKED__ debug_port_type_reg;

  /* Rcvd Packet Counter: Counts the received packets from          */
  /* the IRE.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x60b2 */

     /* RcvdPacketCounter: Counts the received packets from the      */
     /* IRE. This register is clear on read.                         */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcvd_packet_counter;

     /* RcvdPacketCounterOverflow:                                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcvd_packet_counter_overflow;

  } __ATTRIBUTE_PACKED__ rcvd_packet_counter_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_IHP_REGS;
/* Block definition: IHB  */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6400 */

     /* InvalidDestinationValid: If set, InvalidDestination          */
     /* Register contains a valid data, this interrupt is            */
     /* cleared upon reading the InvalidDestination Register         */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD invalid_destination_valid;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x6410 */

    /* InvalidDestinationValidMask: Writing 0 masks the             */
    /* corresponding interrupt source                               */
    /* range: 15:15, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD invalid_destination_valid_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6420 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_IHB_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6430 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_IHB_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6440 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* determine the number of writes left.                         */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6441 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6442 */

     /* IndirectCommandDataIncrement:                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_IHB_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* Gtimer Configuration:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6454 */

     /* GtimerCycle: Period in cycles for which the counters         */
     /* will be active                                               */
     /* range: 29:0, access type: RW, default value: 250000000       */
     SOC_PETRA_REG_FIELD gtimer_cycle;

     /* GtimerEnable: Count using Gtimer                             */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_enable;

     /* GtimerResetOnTrigger: If asserted, the counter is reset      */
     /* when triggered                                               */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_reset_on_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Gtimer Trigger:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6455 */

     /* GtimerTrigger: Trigger indicates to start counting by        */
     /* Gtimer.                                                      */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_trigger_reg;

  /* Debug                                                      */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x6456 */

    SOC_PETRA_REG_FIELD dbg_addr;
    SOC_PETRA_REG_FIELD enable;

  } __ATTRIBUTE_PACKED__ ihb_debug_reg;

  /* Debug                                                      */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x6457 */

    SOC_PETRA_REG_FIELD val;

  } __ATTRIBUTE_PACKED__ ihb_debug_res_reg;

  /* Lag Lb Key Cfg: LB-Key Configuration                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6560 */

     /* LagLbKeySeed: Initial value for the LB key generation        */
     /* range: 7:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD lag_lb_key_seed;

     /* LagLbHashIndex: Selects one of four options for the LB       */
     /* key generation: 3'd0 - Use polynomial 0x14D 3'd1 - Use       */
     /* polynomial 0x1C3 3'd2 - Use polynomial 0x1CF 3'b3 - Use      */
     /* LSB of LB-Key-Packet-Data 4'b4 - Use counter incremented     */
     /* every packet 4'b5 - User counter incremented every two       */
     /* clocks                                                       */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD lag_lb_hash_index;

     /* LagLbKeyUseInPort: If set then In-PP-Port is used in the     */
     /* CRC-LB-Vector                                                */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD lag_lb_key_use_in_port;

     /* LagLbKeyShift: The LAG load balancing key is barrel          */
     /* shifted by this value.                                       */
     /* range: 14:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD lag_lb_key_shift;

     /* LbMplsControlWord: If set then a control word is             */
     /* searched for after an MPLS label with a BOS indication       */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD lb_mpls_control_word;

  } __ATTRIBUTE_PACKED__ lag_lb_key_cfg_reg;

  /* Tm Domain:                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6591 */

     /* TmDomain: The TM Domain of this Device                       */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tm_domain;

  } __ATTRIBUTE_PACKED__ tm_domain_reg;

  /* Vsq Tc Threshold:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6592 */

     /* VsqTcThreshold: Used for CBFC2 - Packets with TC higher      */
     /* than this value will have their Statistics VSQ Pointer       */
     /* LSB asserted                                                 */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsq_tc_threshold;

  } __ATTRIBUTE_PACKED__ vsq_tc_threshold_reg;

  /* Invalid Destination: Contains the last Invalid                 */
  /* destination that was passed to ingress                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6594 */

     /* InvalidDestinationDestination: Invalid destination in        */
     /* 16bit Encoding This register is clear on read.               */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD invalid_destination_destination;

     /* InvalidDestinationSource: 1'b0 from Pipe, 1'b1 from Trap     */
     /* This register is clear on read.                              */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD invalid_destination_source;

  } __ATTRIBUTE_PACKED__ invalid_destination_reg;

  /* PMFGeneral Configuration0: Holds PMF Enablers                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6500 */

     /* DestinationActionEnable: If set, then Destination action     */
     /* may update the packet's destination; otherwise, it           */
     /* remains unchanged.                                           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD destination_action_enable;

     /* DP_ActionEnable: If set, then DP action may update the       */
     /* packet's DP; otherwise, it remains unchanged.                */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dp_action_enable;

     /* DP_MeterCmdActionEnable: If set, then DP Meter Command       */
     /* action may update the packet's DP-Meter-CMD; otherwise,      */
     /* it remains unvalid.                                          */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dp_meter_cmd_action_enable;

     /* TC ActionEnable: If set, then TC action may update the       */
     /* packet's TC; otherwise, it remains unchanged.                */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tc_action_enable;

     /* ForwardActionEnable: If set, then PMF-Forward action is      */
     /* enabled; otherwise, this action will not affect the          */
     /* packet forward-code.                                         */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD forward_action_enable;

     /* SnoopActionEnable: If set, then PMF-snoop action may         */
     /* affect the packet-snoop; otherwise, incoming snoop won't     */
     /* be changed.                                                  */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD snoop_action_enable;

     /* MirrorActionEnable: If set, then PMF-mirror action may       */
     /* affect the packet mirroring; otherwise, the incoming         */
     /* mirror won't be changed.                                     */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mirror_action_enable;

     /* OutboundMirrorDisableActionEnable: If set, then              */
     /* outbound-mirror-disable-action may affect the packet;        */
     /* otherwise, outbound-mirror-disable will be zeroed.           */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD outbound_mirror_disable_action_enable;

     /* ExcludeSourceActionEnable: If set, then                      */
     /* exclude-source--action may affect the packet; otherwise,     */
     /* exclude-source will be zeroed.                               */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD exclude_source_action_enable;

     /* IngressShapingActionEnable: If set, then                     */
     /* ingress-shape-action may affect the packet; otherwise,       */
     /* ingress-shape remains invalid.                               */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ingress_shaping_action_enable;

     /* MeterActionEnable: If set, then meter action may update      */
     /* the meter pointer (for bank A and B); otherwise, both        */
     /* pointers will be zeroed.                                     */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD meter_action_enable;

     /* CounterActionEnable: If set, then counter action may         */
     /* update the counter pointer (for bank A and B);               */
     /* otherwise, both pointers will be zeroed.                     */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD counter_action_enable;

     /* StatisticsActionEnable: If set, then statistics-action       */
     /* may update statistics-tag-packet-data; otherwise, it         */
     /* remains unchanged.                                           */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD statistics_action_enable;

     /* OutlifActionEnable: If set, then statistics-action may       */
     /* update statistics-tag-packet-data; otherwise, it remains     */
     /* unchanged.                                                   */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD outlif_action_enable;

     /* SecondPassDataUpdateActionEnable: If set, then this          */
     /* action in the first pass may update the key for the          */
     /* second pass; otherwise, the keys remain unchanged.           */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD second_pass_data_update_action_enable;

     /* SecondPassProfileUpdateActionEnable: If set, then this       */
     /* action in the first pass may update profile-select for       */
     /* the second pass; otherwise, the profile remains              */
     /* unchanged.                                                   */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD second_pass_profile_update_action_enable;

     /* DisableFirstPassFEM0: Disable Field-Extraction-Macro-0       */
     /* in the first pass                                            */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_first_pass_fem0;

     /* DisableFirstPassFEM1: Disable Field-Extraction-Macro-1       */
     /* in the first pass                                            */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_first_pass_fem1;

     /* DisableFirstPassFEM2: Disable Field-Extraction-Macro-2       */
     /* in the first pass                                            */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_first_pass_fem2;

     /* DisableFirstPassFEM3: Disable Field-Extraction-Macro-3       */
     /* in the first pass                                            */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_first_pass_fem3;

     /* DisableFirstPassFEM4: Disable Field-Extraction-Macro-4       */
     /* in the first pass                                            */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_first_pass_fem4;

     /* DisableFirstPassFEM5: Disable Field-Extraction-Macro-5       */
     /* in the first pass                                            */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_first_pass_fem5;

     /* DisableFirstPassFEM6: Disable Field-Extraction-Macro-6       */
     /* in the first pass                                            */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_first_pass_fem6;

     /* DisableFirstPassFEM7: Disable Field-Extraction-Macro-7       */
     /* in the first pass                                            */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_first_pass_fem7;

     /* DisableSecondPassFEM0: Disable Field-Extraction-Macro-0      */
     /* in the second pass                                           */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_second_pass_fem0;

     /* DisableSecondPassFEM1: Disable Field-Extraction-Macro-1      */
     /* in the second pass                                           */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_second_pass_fem1;

     /* DisableSecondPassFEM2: Disable Field-Extraction-Macro-2      */
     /* in the second pass                                           */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_second_pass_fem2;

     /* DisableSecondPassFEM3: Disable Field-Extraction-Macro-3      */
     /* in the second pass                                           */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_second_pass_fem3;

     /* DisableSecondPassFEM4: Disable Field-Extraction-Macro-4      */
     /* in the second pass                                           */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_second_pass_fem4;

     /* DisableSecondPassFEM5: Disable Field-Extraction-Macro-5      */
     /* in the second pass                                           */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_second_pass_fem5;

     /* DisableSecondPassFEM6: Disable Field-Extraction-Macro-6      */
     /* in the second pass                                           */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_second_pass_fem6;

     /* DisableSecondPassFEM7: Disable Field-Extraction-Macro-7      */
     /* in the second pass                                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD disable_second_pass_fem7;

  } __ATTRIBUTE_PACKED__ pmfgeneral_configuration0_reg;

  /* Statistics Key Select:                                         */
  /* Selected-Program. TagSelectionProfileIndex selects one of       */
  /* the following eight StatisticsKeySelect, and according         */
  /* to the value, Statistics-Tag-Packet-Data is set.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x650f */

     /* StatisticsKeySelect0: 3'd0 : Key-A[29:0] 3'd1 :              */
     /* Key-A[61:32] 3'd2 : Key-B[29:0] 3'd3 : Key-B[61:32] 3'd4     */
     /* : TCAM-PD1-Data[29:0] 3'd5 : TCAM-PD2-Data[29:0] 3'd6 :      */
     /* TCAM-Sel3-Data[29:0] 3'd7 : \{10'b0,Direct-Table-Data\}      */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD statistics_key_select[SOC_PB_PMF_NOF_TAG_PROFILES];

  } __ATTRIBUTE_PACKED__ statistics_key_select_reg;

  /* LAG LB Key Select:                                             */
  /* Selected-Program. TagSelectionProfileIndex selects one of       */
  /* the following eight LAG_LB_KeySelect, and according to         */
  /* the value, LAG-LB-Key-Packet-Data is set.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6510 */

     /* LAG LB KeySelect0: 3'd0 : Key-A[19:0] 3'd1 :                 */
     /* Key-A[51:32] 3'd2 : Key-B[19:0] 3'd3 : Key-B[51:32] 3'd4     */
     /* : TACM-PD1-Data[19:0] 3'd5 : TACM-PD2-Data[19:0] 3'd6 :      */
     /* TCAM-Sel3-Data[19:0] 3'd7 : Direct-Table-Data[19:0]          */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD lag_lb_key_select[SOC_PB_PMF_NOF_TAG_PROFILES];

  } __ATTRIBUTE_PACKED__ lag_lb_key_select_reg;

  /* Stacking Route History Select:                                 */
  /* Selected-Program. TagSelectionProfileIndex selects one of       */
  /* the following eight StackingRouteHistorySelect, and            */
  /* according to the value, stacking-route-history-bitmap is       */
  /* set.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6512 */

     /* StackingRouteHistorySelect0: 3'd0 : Key-A[15:0] 3'd1 :       */
     /* Key-A[47:32] 3'd2 : Key-B[15:0] 3'd3 : Key-B[47:32] 3'd4     */
     /* : TACM-PD1-Data[15:0] 3'd5 : TACM-PD2-Data[15:0] 3'd6 :      */
     /* TCAM-Sel3-Data[15:0] 3'd7 : Direct-Table-Data[15:0]          */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stacking_route_history_select[SOC_PB_PMF_NOF_TAG_PROFILES];

  } __ATTRIBUTE_PACKED__ stacking_route_history_select_reg;

  /* Statistics Key Shift Reg0:                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6513 */

     /* StatisticsKeyShift0:                                         */
     /* range: 4:0, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD statistics_key_shift[SOC_PB_PMF_NOF_STAT_SHIFT_FLDS_PER_REG];

  } __ATTRIBUTE_PACKED__ statistics_key_shift_reg_reg[SOC_PB_IHB_STATISTICS_KEY_SHIFT_REG_REG_NOF_REGS];

  /* Dbg PMF Force action1:                                          */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x6515 */

    SOC_PETRA_REG_FIELD force_action;
    SOC_PETRA_REG_FIELD force_action_type;

  } __ATTRIBUTE_PACKED__ dbg_pmf_force_action1_reg;

  /* Dbg PMF Force action2:                                          */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x6516 */

    SOC_PETRA_REG_FIELD force_action_value;

  } __ATTRIBUTE_PACKED__ dbg_pmf_force_action2_reg;

  /* Dbg Selected Program:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6517 */

     /* DbgSelectedProgram: 32 sticky bits, bit[x] is set of         */
     /* program x is selected. The register is cleared on read.      */
     /* This register is clear on read.                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD dbg_selected_program;

  } __ATTRIBUTE_PACKED__ dbg_selected_program_reg;

  /* Dbg Key A:                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6518 */

     /* DbgKeyA: Holds configurable Key-A for the last packet        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD dbg_key_a;

  } __ATTRIBUTE_PACKED__ dbg_key_a_reg[SOC_PB_IHB_DBG_KEY_A_REG_MULT_NOF_REGS];

  /* Dbg Key B:                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x651e */

     /* DbgKeyB: Holds configurable Key-B for the last packet        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD dbg_key_b;

  } __ATTRIBUTE_PACKED__ dbg_key_b_reg[SOC_PB_IHB_DBG_KEY_B_REG_MULT_NOF_REGS];

  /* Dbg FEM: Set wether FEM debug features holds data from         */
  /* the first or second pass. Notice, When using DbgFreezeFEM       */
  /* or DbgFreezeFEM_AtPMF_Program then all of the following        */
  /* bits must have the same value.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6537 */

     /* Dbg_1stPassFEM0: If set, then DbgFEM0Key and Dbg_FEM0        */
     /* will hold the data from the first pass; otherwise, the       */
     /* registers will hold the data from the second pass.           */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dbg_1st_pass_fem0;

     /* Dbg_1stPassFEM1: If set, then DbgFEM1Key and Dbg_FEM1        */
     /* will hold the data from the first pass; otherwise, the       */
     /* registers will hold the data from the second pass.           */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dbg_1st_pass_fem1;

     /* Dbg_1stPassFEM2: If set, then DbgFEM2Key and Dbg_FEM2        */
     /* will hold the data from the first pass; otherwise, the       */
     /* registers will hold the data from the second pass.           */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dbg_1st_pass_fem2;

     /* Dbg_1stPassFEM3: If set, then DbgFEM3Key and Dbg_FEM3        */
     /* will hold the data from the first pass; otherwise, the       */
     /* registers will hold the data from the second pass.           */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dbg_1st_pass_fem3;

     /* Dbg_1stPassFEM4: If set, then DbgFEM4Key and Dbg_FEM4        */
     /* will hold the data from the first pass; otherwise, the       */
     /* registers will hold the data from the second pass.           */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dbg_1st_pass_fem4;

     /* Dbg_1stPassFEM5: If set, then DbgFEM5Key and Dbg_FEM5        */
     /* will hold the data from the first pass; otherwise, the       */
     /* registers will hold the data from the second pass.           */
     /* range: 5:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dbg_1st_pass_fem5;

     /* Dbg_1stPassFEM6: If set, then DbgFEM6Key and Dbg_FEM6        */
     /* will hold the data from the first pass; otherwise, the       */
     /* registers will hold the data from the second pass.           */
     /* range: 6:6, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dbg_1st_pass_fem6;

     /* Dbg_1stPassFEM7: If set, then DbgFEM7Key and Dbg_FEM7        */
     /* will hold the data from the first pass; otherwise, the       */
     /* registers will hold the data from the second pass.           */
     /* range: 7:7, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dbg_1st_pass_fem7;

  } __ATTRIBUTE_PACKED__ dbg_fem_reg;

  /* Dbg Freeze FEM: This will function correctly only if           */
  /* Dbg_1stPassFEMX has the same value for all FEMs                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6538 */

     /* DbgFreezeFEM: If set, then all DbgFEM registers will         */
     /* freeze and hold a relevant data for certain packet;          */
     /* otherwise, DbgFEM register will keep the relevant data       */
     /* for the last packet.                                         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dbg_freeze_fem;

     /* DbgFreezeFEM_AtPMF_Program: If set, then all DbgFEM          */
     /* registers will freeze when packet with PMF program ==        */
     /* DbgFreezeFEM_AtPMF_Program; otherwise,                       */
     /* DbgFreezePMF_Program will not affect.                        */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dbg_freeze_fem_at_pmf_program;

     /* DbgFreezePMF_Program: If DbgFreezeFEM_AtPMF_Program set,     */
     /* then the DbgFEM registers will hold the data according       */
     /* to DbgFreezePMF_Program.                                     */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dbg_freeze_pmf_program;

  } __ATTRIBUTE_PACKED__ dbg_freeze_fem_reg;

  /* Dbg FEM Status:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x6539 */

     /* DbgFEM_Freezed: An Indication that DbgFEM registers are      */
     /* freezed for certain packet.                                  */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD dbg_fem_freezed;

  } __ATTRIBUTE_PACKED__ dbg_fem_status_reg;

  /* Tcam Power: Tcam power control                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x65e5 */

     /* TcamPowerDown: Reset power for all tcams                     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tcam_power_down;

     /* TcamDisable: Disable each tcam bank                          */
     /* range: 4:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tcam_disable;

  } __ATTRIBUTE_PACKED__ tcam_power_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_IHB_REGS;
/* Block definition: IQM  */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0400 */

     /* FreeBdbOvf: Free-BDB counter has overflowed                  */
     /* range: 0:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD free_bdb_ovf;

     /* FreeBdbUnf: Free-BDB counter has under-flowed                */
     /* range: 1:1, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD free_bdb_unf;

     /* FullUscntOvf: Full User count overflowed. Received over      */
     /* 4K multiplications for the same DB.                          */
     /* range: 3:3, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD full_uscnt_ovf;

     /* MiniUscntOvf: Mini User count overflowed. Received over      */
     /* 4 multiplications for the same DB.                           */
     /* range: 4:4, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD mini_uscnt_ovf;

     /* QdrSftErr: ECC/Parity error detected in read-data            */
     /* returned from the QDR (BDB data). Note: This type of         */
     /* error could cause IQM internal data-base mismatch.           */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_sft_err;

     /* PktEnqRsrcErr: Resource error reported on the packet         */
     /* enqueue command. Packet was rejected because the IDR ran     */
     /* out of buffers during packet re-assembly. Asserted when      */
     /* RjctRsrcErrPktCnt increments.                                */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_rsrc_err;

     /* PktEnqSnErr: Sequence error reported on the packet           */
     /* enqueue command. The packet was rejected. IRR had wrong      */
     /* sequence number (oc-768c re-sequencing). Asserted when       */
     /* RjctSnErrPktCnt increments.                                  */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_sn_err;

     /* PktEnqMcErr: Multicast error reported on the packet          */
     /* enqueue command. The packet was rejected because the IRR     */
     /* did not have place in the multicast FIFO while receiving     */
     /* multicast packet. Asserted when RjctMcErrPktCnt              */
     /* increments.                                                  */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_mc_err;

     /* PktEnqQnvalidErr: Q not valid in the packet enqueue          */
     /* command. A packet was rejected. Asserted when                */
     /* RjctQnvalidErrPktCnt increments.                             */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_qnvalid_err;

     /* StRptOvf: A statistics report has been discarded. This       */
     /* could happen due to a rather slow rate statistics            */
     /* interface or a high rate Statistics-Sync configuration       */
     /* (StRptSyncPrd)                                               */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD st_rpt_ovf;

     /* QrollOver: One of the packet queues Q-size rolled over       */
     /* (overflowed or under-flowed). The IQM must go through        */
     /* initialization (soft reset).                                 */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD qroll_over;

     /* VsqRollOver: One of the virtual queues Q-size (bytes or      */
     /* BDs) rolled over (overflowed or under-flowed). The STE       */
     /* might have wrong decisions for packet accept/reject.         */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_roll_over;

     /* DramDynSizeRollOver: Inidicates a roll over (overflow or     */
     /* under-flowed) of the DRAM dynamic size counter. In case      */
     /* roll-over occurred the IQM might have wrong packet           */
     /* discard decisions.                                           */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dram_dyn_size_roll_over;

     /* CnmPktRjct: A CNM packet has been dropped due to             */
     /* oversubscription on IQM->IPT interface.                      */
     /* range: 20:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnm_pkt_rjct;

     /* DoubleCdErr: A packet enqueue command arrived with both      */
     /* IPT-CD and ISP-CD. In case this event happ[ens the IQM's     */
     /* Enq state machine will be defected, IQM init is              */
     /* required. Note: this might happen due to wrong               */
     /* configuration of the IRR.                                    */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD double_cd_err;

     /* MtrpaPacketSizeErr: If set, then Meter-A received a          */
     /* packet bigger than max-packet size. In this case the         */
     /* bucket level will be reset.                                  */
     /* range: 23:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpa_packet_size_err;

     /* MtrpbPacketSizeErr: If set, then Meter-B received a          */
     /* packet bigger than max-packet size. In this case the         */
     /* bucket level will be reset.                                  */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_packet_size_err;

     /* CrpsIntr: If set, then one (or more) of the bits in          */
     /* CrpsInterruptRegister has been set.                          */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_intr;

     /* EccIntrErr: If set, then one (or more) of the bits in        */
     /* EccIntrruptRegister has been set.                            */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ecc_intr_err;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Ecc Interrupt Register: This register contains the             */
  /* interrupt sources residing in this unit. OneBErrFixed: a        */
  /* single bit ECC (soft) error was detected and                   */
  /* fixed. TwoBERR : a 2 bits ECC (soft) error was detected.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0401 */

     /* PqdmdTwoBErr: An ECC soft error detected in dynamic PQD      */
     /* (Q descriptor) memory.                                       */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD pqdmd_two_berr;

     /* TaildscrTwoBErr: An ECC soft error detected in               */
     /* Tail-pointer (part of Q descriptor) memory.                  */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD taildscr_two_berr;

     /* BdbllTwoBErr: An ECC soft error detected in BDB link         */
     /* list memory.                                                 */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdbll_two_berr;

     /* FluscntTwoBErr: An ECC soft error detected in                */
     /* full-multicast user count memory.                            */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fluscnt_two_berr;

     /* MnuscntTwoBErr: An ECC soft error detected in                */
     /* mini-multicast user count memory.                            */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mnuscnt_two_berr;

     /* TxpdmTwoBErr: An ECC soft error detected in Tx-PD FIFOs      */
     /* memory.                                                      */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD txpdm_two_berr;

     /* TxdscrmTwoBErr: An ECC soft error detected in                */
     /* Tx-Descriptor FIFOs memory.                                  */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD txdscrm_two_berr;

     /* DbffmTwoBErr: An ECC soft error detected in Dbuff FIFO       */
     /* memory.                                                      */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD dbffm_two_berr;

     /* DelffmTwoBErr: An ECC soft error detected in                 */
     /* Deleted-buffers FIFO memory.                                 */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD delffm_two_berr;

     /* VsqbQszTwoBErr: An ECC soft error detected in VSQb Q         */
     /* size memory.                                                 */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsqb_qsz_two_berr;

     /* VsqcQszTwoBErr: An ECC soft error detected in VSQc Q         */
     /* size memory.                                                 */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqc_qsz_two_berr;

     /* VsqdQszTwoBErr: An ECC soft error detected in VSQd Q         */
     /* size memory.                                                 */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqd_qsz_two_berr;

     /* CpdmdTwoBErr: An ECC soft error detected in CPDMD            */
     /* memory.                                                      */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpdmd_two_berr;

     /* PqdmdOneBErrFixed: An ECC soft error detected in dynamic     */
     /* PQD (Q descriptor) memory.                                   */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pqdmd_one_berr_fixed;

     /* TaildscrOneBErrFixed: An ECC soft error detected in          */
     /* Tail-pointer (part of Q descriptor) memory.                  */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD taildscr_one_berr_fixed;

     /* BdbllOneBErrFixed: An ECC soft error detected in BDB         */
     /* link list memory.                                            */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD bdbll_one_berr_fixed;

     /* FluscntOneBErrFixed: An ECC soft error detected in           */
     /* full-multicast user count memory.                            */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fluscnt_one_berr_fixed;

     /* MnuscntOneBErrFixed: An ECC soft error detected in           */
     /* mini-multicast user count memory.                            */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mnuscnt_one_berr_fixed;

     /* TxpdmOneBErrFixed: An ECC soft error detected in Tx-PD       */
     /* FIFOs memory.                                                */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD txpdm_one_berr_fixed;

     /* TxdscrmOneBErrFixed: An ECC soft error detected in           */
     /* Tx-Descriptor FIFOs memory.                                  */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD txdscrm_one_berr_fixed;

     /* DbffmOneBErrFixed: An ECC soft error detected in Dbuff       */
     /* FIFO memory.                                                 */
     /* range: 20:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dbffm_one_berr_fixed;

     /* DelffmOneBErrFixed: An ECC soft error detected in            */
     /* Deleted-buffers FIFO memory.                                 */
     /* range: 21:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD delffm_one_berr_fixed;

     /* VsqbQszOneBErrFixed: An ECC soft error detected in VSQb      */
     /* Q size memory.                                               */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqb_qsz_one_berr_fixed;

     /* VsqcQszOneBErrFixed: An ECC soft error detected in VSQc      */
     /* Q size memory.                                               */
     /* range: 23:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqc_qsz_one_berr_fixed;

     /* VsqdQszOneBErrFixed: An ECC soft error detected in VSQd      */
     /* Q size memory.                                               */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqd_qsz_one_berr_fixed;

     /* CpdmdOneBErrFixed: An ECC soft error detected in CPDMD       */
     /* memory.                                                      */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpdmd_one_berr_fixed;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_reg;

  /* Crps Interrupt Register: This register contains the            */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0402 */

     /* CrpsCntOvf: Indicates a counter has overflown.              */
     /* range: 0:0, access type: RC, default value: 0x0              */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_cnt_ovf[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsInvldAdAcc: Indicates a counter command (received       */
     /* from the ingress/egress) tried to access an invalid          */
     /* address.                                                     */
     /* range: 1:1, access type: RC, default value: 0x0              */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_invld_ad_acc[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsInvldPtrAcc: Indicates the CPU read request tried       */
     /* to access via an invalid pointer.                            */
     /* range: 2:2, access type: RC, default value: 0x0              */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_invld_ptr_acc[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsPreReadFifoFull: Indicates the pre fetch fifo is        */
     /* full. Crps counters should be read. Valid only when          */
     /* working in PREFETCH read mode. Note: the register must       */
     /* be cleared by write.                                         */
     /* range: 3:3, access type: RC, default value: 0x0              */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_pre_read_fifo_full[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsPreReadFifoNotEmpty: Indicates the prefetch fifo is     */
     /* not empty Note: the register must be cleared by write.       */
     /* range: 4:4, access type: RC, default value: 0x0              */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_pre_read_fifo_not_empty[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsDirectRdWhenWaiting: User performed direct read         */
     /* access while former action has not finished.                 */
     /* range: 5:5, access type: RC, default value: 0x0              */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_direct_rd_when_waiting[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsStaticRdWhenWaiting: User read static read register     */
     /* while former action did not reset the last counters set.     */
     /* Note: in this case the user will read CrpsDataValid at      */
     /* 0.                                                           */
     /* range: 6:6, access type: RC, default value: 0x0              */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_static_rd_when_waiting[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  } __ATTRIBUTE_PACKED__ crps_interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0410 */

     /* FreeBdbOvfMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD free_bdb_ovf_mask;

     /* FreeBdbUnfMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD free_bdb_unf_mask;

     /* FullUscntOvfMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD full_uscnt_ovf_mask;

     /* MiniUscntOvfMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mini_uscnt_ovf_mask;

     /* QdrSftErrMask: Writing 0 masks the corresponding             */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_sft_err_mask;

     /* IspDupErrMask: Writing 0 masks the corresponding             */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD isp_dup_err_mask;

     /* PktEnqRsrcErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_rsrc_err_mask;

     /* PktEnqSnErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_sn_err_mask;

     /* PktEnqMcErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_mc_err_mask;

     /* FreeBdbProtErrMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD free_bdb_prot_err_mask;

     /* PktEnqQnvalidErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_qnvalid_err_mask;

     /* StRptOvfMask: Writing 0 masks the corresponding              */
     /* interrupt source.                                            */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD st_rpt_ovf_mask;

     /* QrollOverMask: Writing 0 masks the corresponding             */
     /* interrupt source.                                            */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD qroll_over_mask;

     /* VsqRollOverMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_roll_over_mask;

     /* DramDynSizeRollOverMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dram_dyn_size_roll_over_mask;

     /* CnmPktRjctMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnm_pkt_rjct_mask;

     /* DeqStopQdrErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_stop_qdr_err_mask;

     /* DoubleCdErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD double_cd_err_mask;

     /* MtrpaPacketSizeErrMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpa_packet_size_err_mask;

     /* MtrpbPacketSizeErrMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_packet_size_err_mask;

     /* CrpsIntrMask: Writing 0 masks the corresponding              */
     /* interrupt source.                                            */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_intr_mask;

     /* EccIntrErrMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ecc_intr_err_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Ecc Interrupt Register Mask: Each bit in this register         */
  /* corresponds to an interrupt source in the Ecc Interrupt        */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0411 */

     /* PqdmdTwoBErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pqdmd_two_berr_mask;

     /* TaildscrTwoBErrMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD taildscr_two_berr_mask;

     /* BdbllTwoBErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdbll_two_berr_mask;

     /* FluscntTwoBErrMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fluscnt_two_berr_mask;

     /* MnuscntTwoBErrMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mnuscnt_two_berr_mask;

     /* TxpdmTwoBErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD txpdm_two_berr_mask;

     /* TxdscrmTwoBErrMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD txdscrm_two_berr_mask;

     /* DbffmTwoBErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dbffm_two_berr_mask;

     /* DelffmTwoBErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD delffm_two_berr_mask;

     /* VsqbQszTwoBErrMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsqb_qsz_two_berr_mask;

     /* VsqcQszTwoBErrMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqc_qsz_two_berr_mask;

     /* VsqdQszTwoBErrMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqd_qsz_two_berr_mask;

     /* CpdmdTwoBErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpdmd_two_berr_mask;

     /* PqdmdOneBErrFixedMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pqdmd_one_berr_fixed_mask;

     /* TaildscrOneBErrFixedMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD taildscr_one_berr_fixed_mask;

     /* BdbllOneBErrFixedMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bdbll_one_berr_fixed_mask;

     /* FluscntOneBErrFixedMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fluscnt_one_berr_fixed_mask;

     /* MnuscntOneBErrFixedMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mnuscnt_one_berr_fixed_mask;

     /* TxpdmOneBErrFixedMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD txpdm_one_berr_fixed_mask;

     /* TxdscrmOneBErrFixedMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD txdscrm_one_berr_fixed_mask;

     /* DbffmOneBErrFixedMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dbffm_one_berr_fixed_mask;

     /* DelffmOneBErrFixedMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD delffm_one_berr_fixed_mask;

     /* VsqbQszOneBErrFixedMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqb_qsz_one_berr_fixed_mask;

     /* VsqcQszOneBErrFixedMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqc_qsz_one_berr_fixed_mask;

     /* VsqdQszOneBErrFixedMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqd_qsz_one_berr_fixed_mask;

     /* CpdmdOneBErrFixedMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpdmd_one_berr_fixed_mask;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_register_mask_reg;

  /* Crps Interrupt Register Mask: This register contains the       */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0412 */

     /* CrpsCntOvfMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_cnt_ovf_mask[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsInvldAdAccMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_invld_ad_acc_mask[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsInvldPtrAccMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_invld_ptr_acc_mask[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsPreReadFifoFullMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 3:3, access type: RW, default value: 0x0              */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_pre_read_fifo_full_mask[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsPreReadFifoNotEmptyMask: Writing 0 masks the            */
     /* corresponding interrupt source.                              */
     /* range: 4:4, access type: RW, default value: 0x0              */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_pre_read_fifo_not_empty_mask[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsDirectRdWhenWaitingMask: Writing 0 masks the            */
     /* corresponding interrupt source.                              */
     /* range: 5:5, access type: RW, default value: 0x0              */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_direct_rd_when_waiting_mask[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsStaticRdWhenWaitingMask: Writing 0 masks the            */
     /* corresponding interrupt source.                              */
     /* range: 6:6, access type: RW, default value: 0x0              */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_static_rd_when_waiting_mask[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];
 
  } __ATTRIBUTE_PACKED__ crps_interrupt_register_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0420 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_IQM_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0430 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_IQM_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0440 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets the     */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access                      */
  /* address. Defines which indirect object is accessed.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0441 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform. 0:          */
     /* Write operation 1: Read operation                            */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0442 */

     /* IndirectCommandDataIncrement:                                */
     /* IndirectCommandWrData[31:0] is incremented by this value     */
     /* after every indirect write. Addition is cyclic.              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_IQM_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* Soc_petra-C Crps fix                                           */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0452 */

    /* range: 0:0, access type: RW, default value: 0x0              */
    /* range: 1:1, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD crps_scan_fix_en[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

    /* range: 2:2, access type: RW, default value: 0x0              */
    /* range: 3:3, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD crps_mapping_fix_en[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

    /* range: 4:4, access type: RW, default value: 0x0              */
    /* range: 5:5, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD crps_ovt_clr_fix_en[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  } __ATTRIBUTE_PACKED__ soc_petra_c_crps_fix_reg;

  /* ECC Configuration register: This register is used for          */
  /* configuring IQM ECC.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0460 */

     /* DisEcc: If set, disables the ECC mechanism in the block.     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_ecc;

  } __ATTRIBUTE_PACKED__ ecc_configuration_reg;

  /* Iqm Init: IQM initialization internal indications.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0480 */

     /* IqcInit: While IqcInit==1, the IQC performs its 64K          */
     /* cycles' s initialization. The IQC initialization is          */
     /* triggered when IQM-Init from ECI is set. All IQC logic       */
     /* is reset, except for the configuration registers and         */
     /* static tables. Tables initialized: - BDB Link List -         */
     /* Full-Multicast User count - Mini-Multicast User count -      */
     /* PQD Dynamic (Size, Average Size, Tail, Head).                */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD iqc_init;

     /* SteInit: If set, the STE performs its 256 cycles             */
     /* initialization. The STE init is triggered when IQM-Init      */
     /* from ECI is set. All STE logic is reset, except for the      */
     /* configuration registers and static tables. Tables            */
     /* initialized: - VSQD Size (a,b,c,d) - VSQD Average            */
     /* (a,b,c,d)                                                    */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ste_init;

     /* MrpsInitA: If set, then MRPSA enters soft reset , when       */
     /* unset the meter performs init sequence of 2K cycles.         */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mrps_init_a;

     /* MrpsInitB: If set, then MRPSB enters soft reset, when        */
     /* unset the meter performs init sequence of 2K cycles.         */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mrps_init_b;

     /* CrpsInit: When set, CrPs enters soft reset mode. When      */
     /* unset the Crps performs a 8k initialization phase, in        */
     /* which all counters are set to 0.                             */
     /* range: 5:5, access type: RW, default value: 0x1              */
     /* range: 6:6, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD crps_init[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     
  } __ATTRIBUTE_PACKED__ iqm_init_reg;

  /* Iqm Enablers: IQM Enable bits                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0481 */

     /* FrcIptCD: If set, the IQM keeps FwdAction and                */
     /* Etm-De+EcnChange from ENQ command in the QDR, and sends      */
     /* them to the IPT, once the packet is Dequeued. If OutLif      */
     /* is valid (OutLif !=0), this bit is ignored.                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_ipt_cd;

     /* FwdActSel: Defines the source of the FwdAction sent to       */
     /* the IPT. If set, FwdAction is taken from the Q               */
     /* descriptor Q-signature field. Otherwise, FwdAction is        */
     /* taken from the Enq command (IRR) if IPT-CD is valid          */
     /* (OutLif !=0, or EnIptCd).                                    */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fwd_act_sel;

     /* DscrdAllPkt: If set, the IQM discards all incoming           */
     /* packets.                                                     */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dscrd_all_pkt;

     /* EcnEnable: If set, then the IQM will not discard packet      */
     /* signed as ECN-capable, in case of WRED discard               */
     /* (including main Q, VSQs or system-red). In this case the     */
     /* IQM will change the DROP-P presented to the IPT (EnIptCd     */
     /* must be set also)                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ecn_enable;

     /* CnmEnable: If set, then the IQM will enable the CNM          */
     /* logic. According to a Congestion point (CP-Queue)            */
     /* congestion level , either generates or do not generate a     */
     /* special CNM packet.                                          */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnm_enable;

     /* EnIptCd4Snoop: If set, then the IQM keeps IPT-CD with        */
     /* FWD-Action for Snoop packets regardless of OutLif valid.     */
     /* This is needed to identify the packet as Snoop at the        */
     /* DEQ, as snoop packets do not have the CRC field in the       */
     /* DRAM.                                                        */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD en_ipt_cd4_snoop;

     /* MeterEn: If set, then meter-processing action is             */
     /* enabled, and the IQM-DP and EtmDe are effected by the 2      */
     /* meters action, else the incoming DP is used.                 */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD meter_en;

     /* IgnoreDp: If bit [n] is set, then the IQM will ignore        */
     /* the relevant Drop-p in discard decisions(wred) in case       */
     /* the relevant Q is in the guaranteed space assigned for       */
     /* it. Note: This can be reffered as guaranteed-space           */
     /* enable per drop-p. The referenced DP is the DP after         */
     /* IRR-DP to IQM-DP mapping.                                    */
     /* range: 11:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD ignore_dp;

     /* DscrdDp: Defines the Drop-p value above which all            */
     /* packets will always be discarded. This setting will          */
     /* override all other discard tests. Default: None. Note:       */
     /* Setting this value bigger than 3 , disables the discard.     */
     /* range: 14:12, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD dscrd_dp;

     /* CrpsCmdEn: If set, then Crps action is enabled, else       */
     /* Crps will not receive any counting commands, CPU reads      */
     /* commands will be enabled.                                    */
     /* range: 18:18, access type: RW, default value: 0x0            */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_cmd_en[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* VsqBdSizeMode: If set, then the IQM(STE) calculates the      */
     /* packet's BD size while considering also the BDs occupied     */
     /* by ISP/IPT-CD ot ST-VSQ pointer, otherwise only BDs          */
     /* containing Dbuffs pointer are accounted. Note: when          */
     /* disabled, the VSQ's BD size present the number of Dbuffs     */
     /* occupied by the relevant Qs pointing to the VSQ.             */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD vsq_bd_size_mode;

  } __ATTRIBUTE_PACKED__ iqm_enablers_reg;

  /* Packet Queues Categories1: Defines Packet Queues               */
  /* Categories. IQM Queues are divided to four categories.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0482 */

     /* TopPktQCat0: Top-most Q that defined in category 0           */
     /* (0->TopPktQCat0)                                             */
     /* range: 14:0, access type: RW, default value: 0x1fff          */
     SOC_PETRA_REG_FIELD top_pkt_qcat0;

     /* TopPktQCat1: Top-most Q that defined in category 1           */
     /* (TopPktQCat0+1 -> TopPktQCat1)                               */
     /* range: 30:16, access type: RW, default value: 0x3fff         */
     SOC_PETRA_REG_FIELD top_pkt_qcat1;

  } __ATTRIBUTE_PACKED__ packet_queues_categories1_reg;

  /* Packet Queues Categories2: Packet Queues Categories.           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0483 */

     /* TopPktQCat2: Top-most Q that defined in category 2           */
     /* (TopPktQCat1+1 -> TopPktQCat2)                               */
     /* range: 14:0, access type: RW, default value: 0x5fff          */
     SOC_PETRA_REG_FIELD top_pkt_qcat2;

  } __ATTRIBUTE_PACKED__ packet_queues_categories2_reg;

  /* General Flow Control Configuration Bdb High Priority:          */
  /* Free BDB Flow-control Set and Clear thresholds                 */
  /* High-priority indication. BDB range is 64K. Values are           */
  /* presented as floating numbers : Value= Th[7:0] <<              */
  /* Th[11:8]                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0484 */

     /* FcSetFrBdbThHp: Threshold of free BDBs to set general        */
     /* flow-control. (Flow control is set when free-bdb <           */
     /* FcSetFrBdbth). It is used for high-priority flow             */
     /* control.                                                     */
     /* range: 7:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_bdb_th_hp_mnt;
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_bdb_th_hp_exp;

     /* FcClrFrBdbThHp: Threshold of free BDBs to clear the          */
     /* general flow-control. (Flow control is Cleared when          */
     /* free-bdb > FcClrFrBdbth). It is used for high-priority       */
     /* flow control.                                                */
     /* range: 19:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_bdb_th_hp_mnt;
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_bdb_th_hp_exp;

  } __ATTRIBUTE_PACKED__ general_flow_control_configuration_bdb_high_priority_reg;

  /* General Flow Control Configuration Bdb Low Priority:           */
  /* Free BDB Fc Sets/Clears thresholds Low-priority                */
  /* indication. BDB range is 64K. Values are presented in            */
  /* floating numbers : Value= Th[7:0] << Th[11:8]                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0485 */

     /* FcSetFrBdbThLp: Threshold of free BDBs to set general        */
     /* flow-control. (Flow control is set when free-bdb <           */
     /* FcSetFrBdbth). It is used for low-priority flow control.     */
     /* range: 7:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_bdb_th_lp_mnt;
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_bdb_th_lp_exp;

     /* FcClrFrBdbThLp: Threshold of free BDBs to clear the          */
     /* general flow-control. (Flow control is Cleared when          */
     /* free-bdb > FcClrFrBdbth). It is used for low-priority        */
     /* flow control.                                                */
     /* range: 19:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_bdb_th_lp_mnt;
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_bdb_th_lp_exp;

  } __ATTRIBUTE_PACKED__ general_flow_control_configuration_bdb_low_priority_reg;

  /* General Reject Configuration BDBs0 : Free BDB Set and          */
  /* Clear thresholds for drop-p 0. Values are presented as          */
  /* floating numbers :Value: Th[7:0] << Th[11:8]                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0486 */

     /* RjctSetFrBdbTh0: Threshold of free-BDBs to set the           */
     /* reject state (Set when free-bdb <= RjctSetFrBdbTh0). 0x0     */
     /* - Disables the reject assertion.                             */
     /* range: 7:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_set_fr_bdb_th_mnt;
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_set_fr_bdb_th_exp;

     /* RjctClrFrBdbTh0: Threshold of free-BDBs to clear the         */
     /* reject state (Cleared when free-bdb > RjctSetFrBdbTh0).      */
     /* range: 19:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_bdb_th_mnt;
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_bdb_th_exp;

  } __ATTRIBUTE_PACKED__ general_reject_configuration_bdbs_reg[SOC_PB_IQM_GENERAL_REJECT_CONFIGURATION_BDBS_REG_NOF_REGS];

  /* General Reject Configuration BDs0 : Occupied BD (QDR           */
  /* entries) Set and Clear thresholds for drop-p 0. BDs range       */
  /* is according to QDR size. Values are presented as               */
  /* floating numbers :Value: Th[11:0] << Th[15:12]                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x048a */

     /* RjctSetOcBdTh0: Threshold of occupied-BDs to set the         */
     /* reject state (Set when occupied-bd => RjctSetOcBdTh0).       */
     /* 0xFFFF - Disables the reject assertion.                      */
     /* range: 11:0, access type: RW, default value: 0xfff           */
     SOC_PETRA_REG_FIELD rjct_set_oc_bd_th_mnt;
     /* range: 15:12 */
     SOC_PETRA_REG_FIELD rjct_set_oc_bd_th_exp;

     /* RjctClrOcBdTh0: Threshold of occupied-BDs to clear the       */
     /* reject state (Cleared when occupied-bd <                     */
     /* RjctSetFrBdbTh0).                                            */
     /* range: 27:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_oc_bd_th_mnt;
     /* range: 31:28 */
     SOC_PETRA_REG_FIELD rjct_clr_oc_bd_th_exp;

  } __ATTRIBUTE_PACKED__ general_reject_configuration_bds_reg[SOC_PB_IQM_GENERAL_REJECT_CONFIGURATION_BDS_REG_NOF_REGS];

  /* General Set Flow Control Configuration DBs High                */
  /* Priority: Free-Dbuff flow-control set thresholdsUnicast        */
  /* DBs range is according to global configuration (but not        */
  /* more than 2M).                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x048e */

     /* FcSetFrDbUcThHp: Threshold of free-Unicast-Dbuffs to set     */
     /* the flow-control state. Value: Th[6:0] << Th[10:7] - 0x0     */
     /* - Disables the reject assertion.                             */
     /* range: 6:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_db_uc_th_hp_mnt;
     /* range: 10:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_db_uc_th_hp_exp;

     /* FcSetFrDbFlmcThHp: Threshold of                              */
     /* free-Full-Multicast-Dbuffs to set the flow-control           */
     /* state. Th[6:0] << Th[10:7] 0x0 - Disables the flow           */
     /* control assertion. Full-multicast range is configurable      */
     /* (but not more than 32K).                                     */
     /* range: 18:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_set_fr_db_flmc_th_hp_mnt;
     /* range: 21:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_set_fr_db_flmc_th_hp_exp;

  } __ATTRIBUTE_PACKED__ general_set_flow_control_configuration_bds_high_priority_reg;

  /* General Clear Flow Control Configuration DBs High              */
  /* Priority: Free-Dbuff flow-control Clear thresholds.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x048f */

     /* FcClrFrDbUcThHp: Threshold of free-Unicast-Dbuffs to         */
     /* clear theflow-control state. Value: Th[6:0] << Th[10:7]      */
     /* 0x0 - Disables the flow-control assertion.                   */
     /* range: 6:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_uc_th_hp_mnt;
     /* range: 10:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_uc_th_hp_exp;

     /* FcClrFrDbFlmcThHp: Threshold of                              */
     /* free-Full-Multicast-Dbuffs to clear the flow-control         */
     /* state. Th[6:0] << Th[10:7] -0x0 - Disables the               */
     /* flow-control assertion.                                      */
     /* range: 18:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_flmc_th_hp_mnt;
     /* range: 21:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_flmc_th_hp_exp;

  } __ATTRIBUTE_PACKED__ general_clear_flow_control_configuration_dbs_high_priority_reg;

  /* General Set Flow Control Configuration DBs Low Priority:       */
  /* Free-Dbuff flow-control set thresholds.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0490 */

     /* FcSetFrDbUcThLp: Threshold of free-Unicast-Dbuffs to set     */
     /* the flow-control state. Value: Th[6:0] << Th[10:7] -0x0      */
     /* - Disables the flow-control assertion.                       */
     /* range: 6:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_db_uc_th_lp_mnt;
     /* range: 10:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_db_uc_th_lp_exp;

     /* FcSetFrDbFlmcThLp: Threshold of                              */
     /* free-Full-Multicast-Dbuffs to set the flow-control           */
     /* state. Th[6:0] << Th[10:7] - 0x0 - Disables the              */
     /* flow-control assertion. Full-multicast range is              */
     /* configurable (but not more than 32K).                        */
     /* range: 18:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_set_fr_db_flmc_th_lp_mnt;
     /* range: 21:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_set_fr_db_flmc_th_lp_exp;

  } __ATTRIBUTE_PACKED__ general_set_flow_control_configuration_dbs_low_priority_reg;

  /* General Clear Flow Control Configuration DBs Low               */
  /* Priority: Free-Dbuff flow-control Clear thresholds.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0491 */

     /* FcClrFrDbUcThLp: Threshold of free-Unicast-Dbuffs to         */
     /* clear the flow control state. Value: Th[6:0] << Th[10:7]     */
     /* - 0x0 - Disables the flow-control assertion.                 */
     /* range: 6:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_uc_th_lp_mnt;
     /* range: 10:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_uc_th_lp_exp;

     /* FcClrFrDbFlmcThLp: Threshold of                              */
     /* free-Full-Multicast-Dbuffs to clear the flow-control         */
     /* state. Th[6:0] << Th[10:7] - 0x0 - Disables the              */
     /* flow-control assertion.                                      */
     /* range: 18:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_flmc_th_lp_mnt;
     /* range: 21:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_flmc_th_lp_exp;

  } __ATTRIBUTE_PACKED__ general_clear_flow_control_configuration_dbs_low_priority_reg;

  /* General Reject Set Configuration DBuffs0 : Reject              */
  /* free-Dbuffs Set thresholds for Drop-p 0                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0492 */

     /* RjctSetFrDbUcTh0: Threshold of free-Unicast-Dbuffs to        */
     /* set the reject state. Value: Th[6:0] << Th[10:7] - 0x0 -     */
     /* Disables the reject assertion.                               */
     /* range: 6:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_uc_th_mnt;
     /* range: 10:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_uc_th_exp;

     /* RjctSetFrDbMnmcTh0: Threshold of                             */
     /* free-Mini-Multicast-Dbuffs to set the reject state.          */
     /* Mini-multicast DBs range is configurable but not more        */
     /* than 64K. Value: Th[5:0] << Th[9:6] - 0x0 - Disables the     */
     /* reject assertion.                                            */
     /* range: 16:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_mnmc_th_mnt;
     /* range: 20:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_mnmc_th_exp;

     /* RjctSetFrDbFlmcTh0: Threshold of                             */
     /* free-Full-Multicast-Dbuffs to set the reject state.          */
     /* Value: Th[6:0] << Th[10:7] - 0x0 - Disables the reject       */
     /* assertion. Full-Mc maximal number : 32K buffers.             */
     /* range: 28:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_flmc_th_mnt;
     /* range: 31:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_flmc_th_exp;

  } __ATTRIBUTE_PACKED__ general_reject_set_configuration_dbuffs_reg[SOC_PB_IQM_GENERAL_REJECT_SET_CONFIGURATION_DBUFFS_REG_NOF_REGS];

  /* General Reject Clear Configuration DBuffs0 : Reject            */
  /* free-Dbuffs Clear thresholds for Drop-p 0                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0496 */

     /* RjctClrFrDbUcTh0: Threshold of free-Unicast-Dbuffs to        */
     /* clear the reject state. Value: Th[6:0] << Th[10:7] -0x0      */
     /* - Disables the reject assertion.                             */
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_uc_th_mnt;
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_uc_th_exp;

     /* RjctClrFrDbMnmcTh0: Threshold of                             */
     /* free-Mini-Multicast-Dbuffs to clear the reject state.        */
     /* Value: Th[5:0] << Th[9:6] -0x0 - Disables the reject         */
     /* assertion.                                                   */
     /* range: 20:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_mnmc_th_mnt;
     /* range: 20:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_mnmc_th_exp;

     /* RjctClrFrDbFlmcTh0: Threshold of                             */
     /* free-Full-Multicast-Dbuffs to clear the reject state.        */
     /* Th[6:0] << Th[10:7] - 0x0 - Disables the reject              */
     /* assertion.                                                   */
     /* range: 31:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_flmc_th_mnt;
     /* range: 31:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_flmc_th_exp;

  } __ATTRIBUTE_PACKED__ general_reject_clear_configuration_dbuffs_reg[SOC_PB_IQM_GENERAL_REJECT_CLEAR_CONFIGURATION_DBUFFS_REG_NOF_REGS];

  /* Statistics Tag Configuration: The statistics-tag is a          */
  /* 30/32-bit information inserted by the user as part of          */
  /* the packet. The register defines the IQM functionalities        */
  /* regarding the statistics-tag.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049a */

     /* StatTagVsqWidth: Defines the VSQ pointer width. Note:        */
     /* The maximal width is 8, or 256 ST-VSQs.                      */
     /* range: 3:0, access type: RW, default value: 0x7              */
     SOC_PETRA_REG_FIELD stat_tag_vsq_width;

     /* StatTagVsqEn: If set, then the VSQ defines a separate        */
     /* VSQ number in the STE. Otherwise, the ST-VSQ group is        */
     /* not updated. Note: Should be set only in case a valid        */
     /* VSQ pointer is generated by the IHP or received from         */
     /* link partner.                                                */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_tag_vsq_en;

     /* StatTagCrpsCmdLsb: Defines the LSB of the field in the       */
     /* statistics-tag that carries the counter processor            */
     /* counting command. Note : CrpsaSrcType                        */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_tag_crps_cmd_lsb;

  } __ATTRIBUTE_PACKED__ statistics_tag_configuration_reg;

  /* Statistics Report Configurations: Statistics reports           */
  /* definitions. Define the format of the statistics report        */
  /* presented on the statistics interface.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049b */

     /* StRptMode: Define the statistics report mode. 0 :            */
     /* FAP20-compatible mode is presented: Ingress Enq and          */
     /* Ingress Deq reports. D266 1: Billing mode with OutLif:        */
     /* Ingress Enq and Egress (EGQ) Enq reports. 2: Billing         */
     /* mode with Outgoing Q number 3: Billing mode with             */
     /* VSI/VLAN 4: Billing mode with Inlif/outLif                   */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD st_rpt_bill;

     /* StRptPcktSize: If set, selects packet-size format for        */
     /* the statistics report, Otherwise, selects Qsize format.      */
     /* Valid only for FAP20-compatible mode.                        */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD st_rpt_pckt_size;

     /* StRptMcidSptMc: If set, presents Multicast ID for            */
     /* spatial-multicast packets (instead of Qnum). Otherwise,      */
     /* spatial-multicast packets are reported with the Qnumber.     */
     /* Valid only for FAP20- compatible mode working in packet-     */
     /* size mode.                                                   */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD st_rpt_mcid_spt_mc;

     /* StRptMcidIngRep: If set, presents Multicast ID for           */
     /* Ingress-Replication multicast packets (instead of            */
     /* Qnum). Otherwise, Ingress-Replication multicast packets       */
     /* are reported with the Qnumber. Valid only for FAP20-         */
     /* compatible mode working in packet- size mode.                */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD st_rpt_mcid_ing_rep;

     /* StRptCntSnp: If set, snoop/mirror packets are also           */
     /* counted in the Copy-Count. Valid only for                    */
     /* FAP20-compatible mode. (Not valid for this version)          */
     /* range: 6:6, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD st_rpt_cnt_snp;

     /* StRptDdrMode: If set then Staistics-if works in DDR          */
     /* mode, otherwise, the interface works in SDR mode. Note:      */
     /* This register must be set to the same value as the           */
     /* GeneralConfiguration's StatDdrMode.                          */
     /* range: 7:7, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD st_rpt_ddr_mode;

     /* StRptSyncPrd: Statistics interface sync period. Defines      */
     /* the maximal period between consecutive sync patterns         */
     /* transmitted on the statistics interface (The pattern is      */
     /* defined as 3MSBs equal to 3'b111 for MSB part, and           */
     /* 3'b110 for LSB part). The period is defined as:              */
     /* (2^StRptSyncPrd) cycles (of 250Mhz). Note: This is the       */
     /* maximal period, apart of that the STE will send sync         */
     /* patterns whenever it has no report to send. Value 0 -        */
     /* disables sync patterns transmission. Valid range: 1->        */
     /* 29.                                                          */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD st_rpt_sync_prd;

     /* StRptMcidOnce: Report multicast packets once per packet.     */
     /* If set, then a single MC-ID format report will be            */
     /* generated for the whole set of copies. Note: Relevant        */
     /* only for ingress replication multicasts.                     */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD st_rpt_mcid_once;

     /* StRptCnmEn: If set, then CNM information is added to the     */
     /* reports.                                                     */
     /* range: 17:17, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD st_rpt_cnm_en;

     /* StRptEccEn: If set, then each report is protected with       */
     /* an 8 bits ECC (with parity) code, which are appended to      */
     /* the MSB of the report (at bits 79:72). Note: The ECC         */
     /* code is calculated over the whole report, including the      */
     /* parity bits, if they exist.                                  */
     /* range: 18:18, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD st_rpt_ecc_en;

     /* StRptParEn: If set, then each outgoing report includes a     */
     /* 2 parity- bits field calculated over the whole report,       */
     /* except for the ECC bits.                                     */
     /* range: 19:19, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD st_rpt_par_en;

     /* StRptShowOrgPcktSize: If set, then the original packet       */
     /* size (before header editing) is presented. Note:             */
     /* relevant only when working with Fap20 compatible with        */
     /* packet size mode.                                            */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD st_rpt_show_org_pckt_size;

  } __ATTRIBUTE_PACKED__ statistics_report_configurations_reg;

  /* Bdb Configuration: BDB configurations                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049c */

     /* BdbSize: Defines the number of BDs (QDR buffer               */
     /* descriptor) inside a single BDB. 0: 8 BDs 1: 16 BDs 2:       */
     /* 32 BDs 3: 64 BDs                                             */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdb_size;

     /* RecycleFrBdb: Use local freed BDB from DEQ pipe as           */
     /* free-BDBs to the ENQ pipe (bypass the free-BDB link          */
     /* list) Note: This should be enabled to ensure best            */
     /* performance.                                                 */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD recycle_fr_bdb;

  } __ATTRIBUTE_PACKED__ bdb_configuration_reg;

  /* Internal Thesholds                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049d */

     /* range: 6:0, access type: RW, default value: 0x20           */
     SOC_PETRA_REG_FIELD thr_0;
     /* range: 11:7, access type: RW, default value: 0xc           */
     SOC_PETRA_REG_FIELD thr_1;
  } __ATTRIBUTE_PACKED__ intern_thresh_reg;

  /* Reject Admission: Rejects admission template sets              */
  /* selected by AddmitLogic[1:0] from Q param table. Defines        */
  /* the test accounted for the packet reject decision. Bit          */
  /* Assignment:RjctTmplt[0] - Category-VSQ testRjctTmplt[1]        */
  /* - Category&Connection-class VSQ testRjctTmplt[2] -             */
  /* Category2/3 & Class test VSQ testRjctTmplt[3] -                */
  /* Statistic TAG VSQ testPacket is accepted if:GlbTest &          */
  /* IngQ & ( (TmplA[0] | Cat) & (TmplA[1] | CTC) & (TmplA[2]       */
  /* | CCC) & (TmplA[3] |ST ) Or (TmplB[0] | Cat) & (TmplB[1]       */
  /* | CTC) & (TmplB[2] | CCC) & (TmplB[3] |ST ))                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049e */

     /* RjctTmpltaSet0: Masking bits for VSQ accept                  */
     /* tests. EVEN index- Template A                                */
     /*        ODD index - Template B                                */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rjct_tmplt_set[SOC_PB_NOF_RJCT_ADMIT_TMPLTS];

  } __ATTRIBUTE_PACKED__ reject_admission_reg;

  /* Free Unicast Dbuff Threshold0: System RED                      */
  /* configuration. Free Unicast Dbuff Threshold Define value        */
  /* - 0. Value is used to generate general-source-Q-size (4         */
  /* bit) for the IPS                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049f */

     /* FrUnDbTh0: If free-dbuff > Th0 -> Qsize=Val0                 */
     /* range: 20:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_un_db_th;

  } __ATTRIBUTE_PACKED__ free_unicast_dbuff_threshold_reg[SOC_PB_IQM_FREE_UNICAST_DBUFF_THRESHOLD_REG_NOF_REGS];

  /* Free Unicast Dbuff Range Values: System RED                    */
  /* configurationDefine respective source-Q-size value for         */
  /* each range of the Free-Unicast-Dbuff counter                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x04a2 */

     /* FrUnDbRngVal0-3: Source-Q-size value assigned to Range-3       */
     /* range: 15:12, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fr_un_db_rng_val[SOC_PB_NOF_DBUFFS_VALS];

  } __ATTRIBUTE_PACKED__ free_unicast_dbuff_range_values_reg;

  /* Free Full Multicast Dbuff Threshold0: System RED               */
  /* configurationFree Full-Multicast Dbuff Thresholds. Values       */
  /* used to generate general-source-Q-size (4 bit) for the         */
  /* IPS.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x04a3 */

     /* FrFlMulDbTh0: If free-dbuff > Th0 -> Qsize=Val0              */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_fl_mul_db_th;

  } __ATTRIBUTE_PACKED__ free_full_multicast_dbuff_threshold_reg[SOC_PB_IQM_FREE_FULL_MULTICAST_DBUFF_THRESHOLD_REG_NOF_REGS];

  /* Free Full Multicast Dbuff Range Values: System RED             */
  /* configuration. Define respective source-Q-size value for        */
  /* each range of the Free-Full-Multicast-Dbuff counter            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x04a6 */

     /* FrFlMlDbRngVal3: Source-Q-size value assigned to Range0-3     */
     /* range: 15:12, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fr_fl_ml_db_rng_val[SOC_PB_NOF_DBUFFS_VALS];

  } __ATTRIBUTE_PACKED__ free_full_multicast_dbuff_range_values_reg;

  /* Free Bdb Threshold0: System RED configuration. Free BDB         */
  /* Threshold. Values used to generate general-source-Q-size        */
  /* (4 bit) for the IPS . Top-Most threshold: if free-BDB >         */
  /* Th0 -> Qsize=Val0                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x04a7 */

     /* FrBdbTh0: If free-BDB > Th0 -> Qsize=Val0                    */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_bdb_th;

  } __ATTRIBUTE_PACKED__ free_bdb_threshold_reg[SOC_PB_IQM_FREE_BDB_THRESHOLD_REG_NOF_REGS];

  /* Free Bdb Range Values: System RED configuration. Define         */
  /* respective source-Q-size value for each range of the           */
  /* Free-BDBs counter.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x04aa */

     /* FrBdbRngVal3: Source-Q-size value assigned to Range0-3        */
     /* range: 15:12, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fr_bdb_rng_val[SOC_PB_NOF_DBUFFS_VALS];

  } __ATTRIBUTE_PACKED__ free_bdb_range_values_reg;

  /* Programmable Counter Queue Select: Defines the Q               */
  /* selection of the programmable counters                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0500 */

     /* PrgCntQ: Matching Filter Q number                            */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD prg_cnt_q;

     /* PrgCntMsk: Matching Filter mask Filter matches if : (        */
     /* Qnum | PrgCntMsk) == (PrgCntQ | PrgCntMsk)                   */
     /* range: 31:17, access type: RW, default value: 0x7fff         */
     SOC_PETRA_REG_FIELD prg_cnt_msk;

  } __ATTRIBUTE_PACKED__ programmable_counter_queue_select_reg;

  /* Vsq Programmable Counter Select: Defines the VSQ               */
  /* selection of the programmable                                  */
  /* counters/MaxOccupancy. Counter relates to operation done        */
  /* on the VSQs that are matching the filter and the               */
  /* VsqPrgGrpSel value. Note: The filter cannot select              */
  /* monitored VSQs from different groups.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0501 */

     /* VsqPrgCntQ: Matching Filter VSQ Q number The VSQ number      */
     /* is the selected group range.                                 */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsq_prg_cnt_q;

     /* VsqPrgCntMsk: Matching Filter mask Filter matches if : (     */
     /* VSQnum | VsqPrgCntMsk) == (VsqPrgCntQ | VsqPrgCntMsk)        */
     /* range: 19:12, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD vsq_prg_cnt_msk;

     /* VsqPrgGrpSel: Defines the VSQ group that the counters        */
     /* should relate to. 0: Check group a (VSQs 0->3, Q             */
     /* category) 1: Check group b (VSQs 4->35, Q category &         */
     /* TrClss) 2: Check group c (VSQs 36->99, Q category &          */
     /* (CnClss2/3)) 3: Check group d (VSQs 100 -> 355, ST-TAG)      */
     /* range: 21:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_prg_grp_sel;

  } __ATTRIBUTE_PACKED__ vsq_programmable_counter_select_reg;

  /* Global Time Counter: Gtimer configuration                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0502 */

     /* GtPrd: Global timer period. Gtimer expires after             */
     /* TimePrd. Default value equivalent to 1[sec] @ 250[MHZ]       */
     /* range: 30:0, access type: RW, default value: 31'hEE6B280     */
     SOC_PETRA_REG_FIELD gt_prd;

     /* GtRstCntrs: If asserted then all related counters are        */
     /* cleared when GtStrtTrg is asserted.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gt_rst_cntrs;

  } __ATTRIBUTE_PACKED__ global_time_counter_reg;

  /* Global Time Counter Trigger: Gtimer trigger.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0503 */

     /* GlbCntTrg: When set, the global-counter counter starts.      */
     /* Trigger is deasserted when counter expires.                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_cnt_trg;

  } __ATTRIBUTE_PACKED__ global_time_counter_trigger_reg;

  /* Global Time Counter Configuration: Defines which               */
  /* counters count according to the global-timer.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0504 */

     /* IqcCntByGt: If set, then the IQC's counters count            */
     /* according to the GlobalTimer.                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD iqc_cnt_by_gt;

     /* IqcPrgCntByGt: If set, then the IQC's programmable           */
     /* counters count according to the GlobalTimer.                 */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD iqc_prg_cnt_by_gt;

     /* SteCntByGt: If set, then the STE counters count              */
     /* according to the GlobalTimer.                                */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ste_cnt_by_gt;

     /* MrpsCntByGt: If set, then the 2 Meter-Processors             */
     /* counters count according to the GlobalTimer.                 */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mrps_cnt_by_gt;

     /* CrpsCntByGt: If set, then the 2 Counter-Processors           */
     /* counters count according to the GlobalTimer.                 */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_cnt_by_gt;

  } __ATTRIBUTE_PACKED__ global_time_counter_configuration_reg;

  /* Grnt Bytes Set0: Guaranteed bytes per Q 0,1                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0505 */

     /* GrntBytes0: Defines the guaranteed size in [16 bytes]        */
     /* per Q. Selected when Q-rate-class[1:0] == 0 Guaranteed       */
     /* Size = Val[5:0]<<Val[10:6] in [16 bytes] Range: 0 ->         */
     /* 2^24                                                         */
     /* range: 5:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD grnt_bytes_mnt[SOC_PB_REG_IQM_GRNT_BYTES_SET_REG_NOF_FLDS];

     /* range: 10:6, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD grnt_bytes_exp[SOC_PB_REG_IQM_GRNT_BYTES_SET_REG_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ grnt_bytes_set_reg[SOC_PB_IQM_GRNT_BYTES_SET_REG_NOF_REGS];

  /* Dram Dyn Size Th Cfg0: Dram dynamic space reject               */
  /* thresholds for DP0. Should be set according to total            */
  /* available DRAM space.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0507 */

     /* DramDynSizeRjctSetTh0: Define the value of                   */
     /* total-dram-dynamic-size above which packets with Drop-p      */
     /* 0 are rejected. Value = Th[11:0]<<Th[15:12] (128 bytes       */
     /* units)                                                       */
     /* range: 11:0, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD dram_dyn_size_rjct_set_th_mnt;

     /* range: 15:12, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD dram_dyn_size_rjct_set_th_exp;

     /* DramDynSizeRjctClrTh0: Define the value of                   */
     /* total-dram-dynamic-size above which packets with Drop-p      */
     /* 0 are rejected.                                              */
     /* range: 27:16, access type: RW, default value: 0xffff         */
     SOC_PETRA_REG_FIELD dram_dyn_size_rjct_clr_th_mnt;

     /* range: 31:28, access type: RW, default value: 0xffff         */
     SOC_PETRA_REG_FIELD dram_dyn_size_rjct_clr_th_exp;

  } __ATTRIBUTE_PACKED__ dram_dyn_size_th_cfg_reg[SOC_PB_IQM_DRAM_DYN_SIZE_TH_CFG_REG_NOF_REGS];

  /* Cp Queues Range: Defines the range of CNM eligible             */
  /* queuesNote: If CpQnumHigh<CpQnumLow, no Q will be CP           */
  /* related.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x050b */

     /* CpQnumLow: The first queue in the range of the CP            */
     /* (congestion point) Queues.                                   */
     /* range: 14:0, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD cp_qnum_low;

     /* CpQnumHigh: The last queue in the range of the CP            */
     /* (congestion point) Queues. Note: The maximal range is 8K     */
     /* , from which every other Q is relevant for CP (odd or        */
     /* even).                                                       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cp_qnum_high;

  } __ATTRIBUTE_PACKED__ cp_queues_range_reg;

  /* Cp Configuration: CNM (CP, congestion point)                   */
  /* configurations                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x050c */

     /* CpQnumOddSel: If set then odd Queues from the CP Queues      */
     /* range are slected as CP Queues, else the even Queues are     */
     /* selected. The CP number is Qnumber/2. CP Queues amount       */
     /* is CP-Queues-range/2 (maximum of 4K) Note: Relevant only     */
     /* when Cp8QsSetMode is off.                                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cp_qnum_odd_sel;

     /* CnmSmpModeEn: If set, then the IQM works in sampling         */
     /* mode. In this mode the IQM manage an 8K set of CP            */
     /* points, and only calculates the Qenqued vlaue for each       */
     /* CP point. (Not Cpfeedback is calculated). Otherwise, the     */
     /* IQM works in Soc_petra-PP mode, and the IPT generates the        */
     /* CNM packet. Note: In this mode the CPDMD/CPDMS change        */
     /* their fields meaning. Also, in this mode the                 */
     /* CpEightQsSetMode must be enabled.                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnm_smp_mode_en;

     /* CpEightQsSetMode: If set, then eavery 8 consecutive 8 Qs     */
     /* above QnumLow are defined as CP queues, else, the 4 Qs       */
     /* mode is used, according to QnumOddSel.                       */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cp_eight_qs_set_mode;

     /* EnCnmMcDa: If set then IQM will generate CNM for packets     */
     /* with MAC-DA which is Multicast/Broadcast, else, those        */
     /* packets are ignored in CNM logic.                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD en_cnm_mc_da;

     /* EnCnmIngRep: If set then IQM will generate CNM for           */
     /* ingress replication multicast packets, else, those           */
     /* packets are ignored in CNM logic.                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD en_cnm_ing_rep;

     /* EnCnmSnp: If set then IQM will generate CNM for snopped      */
     /* copies of packets, else, those packets are ignored in        */
     /* CNM logic (they will no affect the PC data-base, and         */
     /* will not cause CNM generation).                              */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD en_cnm_snp;

     /* EnCnmMirr: If set then IQM will generate CNM for             */
     /* mirrored copies of packets, else, those packets are          */
     /* ignored in CNM logic (they will no affect the PC             */
     /* data-base, and will not cause CNM generation).               */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD en_cnm_mirr;

     /* CpEnqEarlyUp: If set then CNM will updated the CpEnq         */
     /* value before CNM sample evaluation, else, the current        */
     /* Cpenq (before packet size addition) is evaluated             */
     /* (compared to SampleBaseTh).                                  */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cp_enq_early_up;

     /* RstCpEnqOnSmp: If set then CNM will reset the CpEnq          */
     /* value when CNM sample action is valid, else, the CpEnq       */
     /* value will be the residue between the OldCpenq and           */
     /* SameTh value.                                                */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rst_cp_enq_on_smp;

     /* CpSmpResShift: The register enables control on the           */
     /* resolution of CpQDelta and CpQOffset that are presented      */
     /* to the IPT in case of CNM-sample mode. Valid options: 0      */
     /* - 128 bytes 1 - 64 bytes 2 - 32 bytes 3 - 16 bytes           */
     /* range: 10:9, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD cp_smp_res_shift;

     /* CnmShpIntrvl: Defines the interval, in packets or            */
     /* clocks, after which the IQM adds a single credit to the      */
     /* CNM shaper. When CnmShpPktEvnt is on, and interval =         */
     /* 0x7ff, then cnm rate is limited to 61.06[Kpps]. Value of     */
     /* 0, means that every packet/half-clock increments the         */
     /* shaper credit.                                               */
     /* range: 22:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnm_shp_intrvl;

     /* CnmShpMaxBurst: Defines the maximal burst for CNM            */
     /* packets generation, as limited by the CNM shaper. Note:      */
     /* a value of 0, disables CNM generation.                       */
     /* range: 27:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cnm_shp_max_burst;

     /* CnmShpPktEvnt: If set, then the CNM shaper will count        */
     /* events of packets, otherwise it will count events in         */
     /* half core clock period.                                      */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnm_shp_pkt_evnt;

     /* CnmShpEn: If set, then CNM generation shaper is enabled,     */
     /* otherwise the IQM will generate CNM packets with no          */
     /* shaping.                                                     */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnm_shp_en;

  } __ATTRIBUTE_PACKED__ cp_configuration_reg;

  /* Force Cmn: CNM (CP, congestion point) debug                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x050d */

     /* ForceCnm: If set, the IQM will generate a CNM message,       */
     /* for the next arriving packet, regardless of the CNM          */
     /* logic result. (Should be used for debug only)                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_cnm;

  } __ATTRIBUTE_PACKED__ force_cmn_reg;

  /* Etm De To Dpmap: EtmDe to DP Mapping.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x050e */

     /* EtmDe2IqmDpMap0: Maps EtmDe (Discard eligible) defined       */
     /* in ISP first path, to Drop-p to be used by the IQM on        */
     /* the second path (IQM-DP). Selected when EtmDe == 0.          */
     /* Note: Valid only for second path of ISP packet.              */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD etm_de2_iqm_dp_map0;

     /* EtmDe2IqmDpMap1: Maps EtmDe (Discard eligible) defined       */
     /* in ISP first path, to Drop-p to be used by the IQM           */
     /* (IQM-DP). Selected when EtmDe == 1. Note: Valid only for     */
     /* second path of ISP packet.                                   */
     /* range: 3:2, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD etm_de2_iqm_dp_map1;

  } __ATTRIBUTE_PACKED__ etm_de_to_dpmap_reg;

  /* Irr Dp To Enq Dp Map: IRR-DP to Enq-DP mappingMapping          */
  /* table from incoming IRR's drop-p[1:0] into Enq                 */
  /* drop-p[1:0]. The table is used to map the incoming DP to        */
  /* the packet clour scheme expected by the                        */
  /* meter-processor. If no meter action is performed, then          */
  /* this will be the DP to be used in discard decisions of         */
  /* the IQM (IQM-DP).                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x050f */

     /* Irr2EnqDpMap0: ENQ-DP value for IRR-DP 0.                    */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD irr2_enq_dp_map0;

     /* Irr2EnqDpMap1: ENQ-DP value for IRR-DP 1.                    */
     /* range: 3:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD irr2_enq_dp_map1;

     /* Irr2EnqDpMap2: ENQ-DP value for IRR-DP 2.                    */
     /* range: 5:4, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD irr2_enq_dp_map2;

     /* Irr2EnqDpMap3: ENQ-DP value for IRR-DP 3.                    */
     /* range: 7:6, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD irr2_enq_dp_map3;

  } __ATTRIBUTE_PACKED__ irr_dp_to_enq_dp_map_reg;

  /* Mrps Config1: Meter processors Configuration                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0510 */

     /* MtrpaHighRateEna: If set then Meter-processor-A's            */
     /* High-Rate leaky buckets are enabled (upto 64 high-rate       */
     /* LBs) , defined by the meter-processors profiles.             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mtrpa_high_rate_ena;

     /* MtrpbHighRateEna: If set then Meter-processor-B's            */
     /* High-Rate leaky buckets are enabled (upto 64 high-rate       */
     /* LBs), defined by the meter-processors profiles               */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mtrpb_high_rate_ena;

     /* MtrpaRefreshEna: If set then Meter-processor-A activates     */
     /* the leaky-buckets refresh. The refresh is responsible to     */
     /* update the buckets with the time stamp and credit, when      */
     /* no metering commands arrive.                                 */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mtrpa_refresh_ena;

     /* MtrpbRefreshEna: If set then Meter-processor-B activates     */
     /* the leaky-buckets refresh. The refresh is responsible to     */
     /* update the buckets with the time stamp and credit, when      */
     /* no metering commands arrive.                                 */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mtrpb_refresh_ena;

     /* MtrpaMaxPacketSize: Meter-processor-A's MaxPacket Size       */
     /* parameter, needed in case fairness mode is enabled (per      */
     /* profile). In unites of bytes.                                */
     /* range: 17:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpa_max_packet_size;

     /* MtrpbMaxPacketSize: Meter-processor-B's MaxPacket Size       */
     /* parameter, needed in case fairness mode is enabled (per      */
     /* profile). In unites of bytes.                                */
     /* range: 31:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_max_packet_size;

  } __ATTRIBUTE_PACKED__ mrps_config1_reg;

  /* Mrpsa Config2: Meter processor A Normal Index                  */
  /* Configuration                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0511 */

     /* MtrpaRefreshStartIndex: This field sets the first Normal     */
     /* bucket index in the refresh mechanism range. Note:           */
     /* Normal Indexes below this value will not be refreshed        */
     /* and as a result are not functional.                          */
     /* range: 12:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpa_refresh_start_index;

     /* MtrpaRefreshEndIndex: This field sets the last               */
     /* Normal-Index in the refresh mechanism range. Note:           */
     /* Normal Indexes above this value will not be refreshed        */
     /* and as a result are not functional.                          */
     /* range: 25:13, access type: RW, default value: 0x1fff         */
     SOC_PETRA_REG_FIELD mtrpa_refresh_end_index;

  } __ATTRIBUTE_PACKED__ mrpsa_config2_reg;

  /* Mrpsb Config2: Meter processor B Normal Index                  */
  /* Configuration                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0512 */

     /* MtrpbRefreshStartIndex: This field sets the first Normal     */
     /* bucket index in the refresh mechanism range. Note:           */
     /* Normal Indexes below this value will not be refreshed        */
     /* and as a result are not functional.                          */
     /* range: 12:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpb_refresh_start_index;

     /* MtrpbRefreshEndIndex: This field sets the last               */
     /* Normal-Index in the refresh mechanism range. Note:           */
     /* Normal Indexes above this value will not be refreshed        */
     /* and as a result are not functional.                          */
     /* range: 25:13, access type: RW, default value: 0x1fff         */
     SOC_PETRA_REG_FIELD mtrpb_refresh_end_index;

  } __ATTRIBUTE_PACKED__ mrpsb_config2_reg;

  /* Mrps Config2: Meter processors refresh configuration           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0513 */

     /* MtrpaBubbleRate: This register defines the rate of           */
     /* bubbles the MRPS will generate in order to manage the        */
     /* refresh mechanism of the Normal Leaky-Buckets. Every         */
     /* configured 32 core clocks, if no bubble was inserted         */
     /* from the IQM, the MRPS will generate one bubble. A value     */
     /* of 0 disables the bubble generation.                         */
     /* range: 7:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD mtrpa_bubble_rate;

     /* MtrpbBubbleRate: This register defines the rate of           */
     /* bubbles the MRPS will generate in order to manage the        */
     /* refresh mechanism of the Normal Leaky-Buckets. Every         */
     /* configured 32 core clocks, if no bubble was inserted         */
     /* from the IQM, the MRPS will generate one bubble. A value     */
     /* of 0 disables the bubble generation.                         */
     /* range: 15:8, access type: RW, default value: 0xf             */
     SOC_PETRA_REG_FIELD mtrpb_bubble_rate;

     /* MtrpaTimerEn: If disabled all leaky buckets will not be      */
     /* update.                                                      */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpa_timer_en;

     /* MtrpbTimerEn: If disabled all leaky buckets will not be      */
     /* update.                                                      */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_timer_en;

     /* MtrpaMeterOnQnvalid: If set then the Meter will process      */
     /* also packets arrived with Q not valid. This is possible      */
     /* in case of packet filtered by PP (packet processing)         */
     /* filter. Note: in this case the Q number presented to the     */
     /* IQM will be -1.                                              */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpa_meter_on_qnvalid;

     /* MtrpbMeterOnQnvalid: Same as above but for Meter-B.          */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_meter_on_qnvalid;

     /* MtrpaMeterOnErrors: If set, then the Meter will process      */
     /* also packets arrived with one of these 3 error               */
     /* indications asserted: Sequence error : IRR's resequnecer     */
     /* error (FAT-Pipe). Multicast error: IRR's Multicast Queue     */
     /* overflow. Resource error: IDR ran out of free dram           */
     /* buffer.                                                      */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpa_meter_on_errors;

     /* MtrpbMeterOnErrors: Same as above but for Meter-B.           */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_meter_on_errors;

     /* MtrpaMeterOnDpRjct: If set, then the Meter will process      */
     /* also packets arrived with Drop-p above DscrdDp level         */
     /* (usually RED), otherwise, packet will be rejected and        */
     /* not acounted in the meter.                                   */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpa_meter_on_dp_rjct;

     /* MtrpbMeterOnDpRjct: Same as above but for Meter-B.           */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_meter_on_dp_rjct;

     /* MtrpaRndModeEn: If set then the meter will add ar            */
     /* andomized value to the packet size before comparing to       */
     /* credit balance. Note: the credit balance calculation         */
     /* will be done with original packet size.                      */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpa_rnd_mode_en;

     /* MtrpbRndModeEn: Same for MeterB.                             */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_rnd_mode_en;

     /* MtrpaRndRange: Specifies the range of random values          */
     /* added to the packet size, when RndMode is set. 0 - upto      */
     /* 8K 1 - upto 4K 2 - upto 2K 3 - upto 1K                       */
     /* range: 29:28, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD mtrpa_rnd_range;

     /* MtrpbRndRange: Sane for MeterB.                              */
     /* range: 31:30, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD mtrpb_rnd_range;

  } __ATTRIBUTE_PACKED__ mrps_config3_reg;

  /* Cntprocessor Config1: Counter processor Configuration          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0514 */

     /* CrpsCntWorkMode: Crps counting mode: If set to 0 ,then     */
     /* each 2 consecutive counters are a set of : Enq, Discard.     */
     /* If set to 1, then each 4 consecutive counters are            */
     /* defined as a set: 1. Enqueued green 2. Enqueuesd yellow      */
     /* 3. Discard green 4. Discard yellow + Red If set to 2 ,       */
     /* then each 5 consecutive counters are defined as a set:       */
     /* 1. Enqueued green 2. Enqueued yellow 3. Discard green 4.     */
     /* Discard yellow 5. Discard red                                */
     /* range: 1:0, access type: RW, default value: 0x0              */
     /* range: 3:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_cnt_work_mode[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];
     
     /* CrpsCacheReadEn: Enable the CACHE read mode: 0: Static       */
     /* mode, in this mode the Crps will always present the          */
     /* optimal counter pointer value for reading (the Maximal       */
     /* if exist, otherwise one counter above the threshold,         */
     /* otherwise some other non-zero coutner). When the CPU         */
     /* reads the CrpsCntAddr the whole data set is locked, so       */
     /* the CPU can read coherent data set. When the CPU reads       */
     /* CrpsOctsCnt the data set is released, and the CRPS will      */
     /* update it untill next reading (reading sequence must         */
     /* start at CrpsddrCnt and end with CrpsOctsCnt). Note:        */
     /* If all counters are at 0, or that the Crps did not           */
     /* managed to read a valid counter then CrpsDataValid bit       */
     /* will be 0. 1: Pre-fetch FIFO mode (Cache Read): in this      */
     /* mode the Crps will always present the optimal counter        */
     /* pointer value for reading in an internal FIFO (16            */
     /* entries deep), that holds the optimal counter pointer        */
     /* values. The Crps performs memory reads into this FIFO.       */
     /* The first entry is always presented for reading. The         */
     /* data is latched in the CrpsCntAddr, CrpsPktsCnt and          */
     /* CrpsOctsCnt. After CrpsOctsCnt is read, the Crps will      */
     /* present the next FIFO entry.                                 */
     /* range: 4:4, access type: RW, default value: 0x0              */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_cache_read_en[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsPrefetchTmrCfg: Determines the number of 1msec          */
     /* multiples between read operations to the pre-fetch FIFO.     */
     /* Period length is 1 msec in 250Mhz. Valid only when           */
     /* working in prefetch read mode. 0 means 1 msec.               */
     /* range: 12:8, access type: RW, default value: 0x0             */
     /* range: 17:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_prefetch_tmr_cfg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsBubbleEn: If set, then Crps will request a bubble      */
     /* from the IQM when a CPU command, or prefetch command         */
     /* should enter the Crps pipe. Otherwise, CPU read commands     */
     /* will be postponed untill the first gap in Enqueue            */
     /* commands. Note: bubble is needed only if high rate of        */
     /* packet Enque exists.                                         */
     /* range: 20:20, access type: RW, default value: 0x1            */
     /* range: 21:21, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD crps_bubble_en[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsCntOnQnvalid: If set then CrPs will count also         */
     /* packets arrived with Q not valid. This is possible in        */
     /* case of packet filtered by PP (packet processing)            */
     /* filter. Note: in this case the Q number presented to the     */
     /* IQM will be -1, which will not always reside in the CrPs     */
     /* counting range.                                              */
     /* range: 22:22, access type: RW, default value: 0x1            */
     /* range: 23:23, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD crps_cnt_on_qnvalid[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];


     /* CrpsCntOnErrors: If set, then CrPs will count also         */
     /* packets arrived with one of these 3 error indications        */
     /* asserted: Sequence error : IRR's resequnecer error           */
     /* (FAT-Pipe). Multicast error: IRR's Multicast Queue           */
     /* overflow. Resource error: IDR ran out of free dram           */
     /* buffer.                                                      */
     /* range: 24:24, access type: RW, default value: 0x1            */
     /* range: 25:25, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD crps_cnt_on_errors[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  } __ATTRIBUTE_PACKED__ cntprocessor_config1_reg;

  /* Cnt Processor Config2: Counter processors A counters           */
  /* thresholdsThese thresholds are used for the                    */
  /* over-the-thresholds counters fetching mode.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0515-0x0516 */

     /* CrpsPktCntThresh: CrPs threshold, defines packets           */
     /* counters threshold, above which the CrPs will read the       */
     /* counter in LRT mode (reading counters above thresholds).     */
     /* Note: Threshold = Th[9:0]<<Th[13:10] (maximal value          */
     /* 2^25)                                                        */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD crps_pkt_cnt_thresh;

     /* CrpsOctCntThresh: Same but of Octets counters. Note:        */
     /* Threshold = Th[9:0]<<Th[14:10] (maximal allowed value        */
     /* 2^32)                                                        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_oct_cnt_thresh;

  } __ATTRIBUTE_PACKED__ cnt_processor_config_reg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];


  /* Cnt Processor Config4: Counter processors init and             */
  /* source select                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0517 */

     /* CrpsSrcType: Defines the source counting information        */
     /* for CrPs. 0 -IHP counting command (in this case             */
     /* command==0 is invalid). 1- Per IQM Q count 2- Per            */
     /* statistics-tag field 3- Per st-vsq (statistics-vsq)          */
     /* pointer 4- Per CNM-ID (will count only if CNM packet is      */
     /* generated). 5->7 reserved.                                   */
     /* range: 2:0, access type: RW, default value: 0x0              */
     /* range: 6:4, access type: RW, default value: 0x5              */
     SOC_PETRA_REG_FIELD crps_src_type[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsQueueShift: Defines the right shift amount (number      */
     /* of bits) of the Q number for Crps.                          */
     /* range: 11:8, access type: RW, default value: 0x0             */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_queue_shift[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  } __ATTRIBUTE_PACKED__ cnt_processor_config4_reg;

  /* Cnt Processor Shift Cfg1: Counter processors A Queue          */
  /* count configurationDefines the counter index in case of        */
  /* count per Queue number. Counter index = (Qnum - BaseQ)          */
  /* >>ShiftValThe valid range of Qs is defined between BaseQ       */
  /* and TopQ. Note: Relevant only when SrcType is per-Q count       */
  /* (1).                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0518-0x0519 */

     /* CrpsBaseQ: CrPs base Queue. Defines the base Q from        */
     /* which counting per Queue is performed                        */
     /* range: 14:0, access type: RW, default value: 0x0             */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_base_q;

     /* CrpsTopQ: CrPs top Queue. Defines the highest Q in the     */
     /* range for counting per Queue action.                         */
     
     SOC_PETRA_REG_FIELD crps_top_q;

  } __ATTRIBUTE_PACKED__ cnt_processor_shift_cfg1_reg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  
  /* Cnt Processor ARead: Counter processorA read                   */
  /* commandNote: this register is relevant only when Crps         */
  /* works in dynamic mode.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x051a-0x051b */

     /* CrpsRdReq: When set, Crps performs counters read           */
     /* according to ReadType. When data is valid, the CrpsRdReq     */
     /* is unset by the IQM.                                         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_rd_req;

     /* CrpsRdReqType: Read request type: 0 - LRT-LR0 , if          */
     /* LR0(maximal-visited) > Th, then read LR0, otherwise, if      */
     /* LRT (over threshold) exists read current LRT, else read      */
     /* LR0. 1 - LR0, read only maximal-visited. 2 - LRT, read       */
     /* only counters above threshold. 3 - Direct read, read         */
     /* counter according to ReqAddr.                                */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_rd_req_type;

     /* CrpsRdReqAddr: Direct read address, defines the             */
     /* counter's address to be read, out of the 8K possible         */
     /* counter. Relevant only when ReqType is 'Direct' (type        */
     /* 3).                                                          */
     /* range: 20:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD crps_rd_req_addr;

  } __ATTRIBUTE_PACKED__ cnt_processor_read_reg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  /* Cnt Processor ARd Result0: Counter processor  read            */
  /* Result. When DataValid is asserted, the register and the        */
  /* next two present a coherent set of Packets counter,            */
  /* Octets counter, and the relevant address of the counter        */
  /* (in the CrPs data base). The counter entry read index, is       */
  /* defined by the CrpsReqType. When working in static mode,        */
  /* this register should be read first to latch the               */
  /* Address, PktsCnt and OctsCnt values. Note: relevant for         */
  /* static or cache read modes only.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x051c-0x051f */

     /* CrpsDataValid: Read data valid. When presents '1', the      */
     /* requested read data is ready. The bit is cleared upon        */
     /* reading CrpsOctCnt.                                         */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_data_valid;

     /* CrpsCntAddr: Address of the returned PktCnt and OctCnt.     */
     /* This register is clear on read.                              */
     /* range: 20:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crps_cnt_addr;

  } __ATTRIBUTE_PACKED__ cnt_proccesso_rd_result0_reg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  /* Cnt Proccesso ARd Result1: Counter processor A read            */
  /* Result 1                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x051d-0x0520 */

     /* CrpsPktsCnt: Packet counter value.                          */
     /* range: 24:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crps_pkts_cnt;

  } __ATTRIBUTE_PACKED__ cnt_proccesso_rd_result1_reg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  /* Cnt Proccesso ARd Result2: Counter processor  read            */
  /* Result 2                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x051e-0x0521 */

     /* CrpsOctsCnt: Octets (bytes) counter value. Note:            */
     /* Reading this offset, clears the CrpsDataValid. This          */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crps_octs_cnt;

  } __ATTRIBUTE_PACKED__ cnt_proccesso_rd_result2_reg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];


  /* Cnt Proccesso ADirect Rd Result0: Counter processor A          */
  /* direct-read mode read ResultWhen DataValid is asserted,        */
  /* the register and the next two present a coherent set of        */
  /* Packets counter, Octets counter, and the relevant              */
  /* address of the counter (in the CrPs data base). The             */
  /* counter entry read index, is defined by the                    */
  /* CrpsReqAddr. Note: relevant for direct mode access only.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0522-0x0525 */

     /* CrpsDirectDataValid: Read data valid. When presents         */
     /* '1', the requested read data is ready. The bit is            */
     /* cleared upon reading CrpsOctCnt.                            */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD crps_direct_data_valid;

     /* CrpsDirectCntAddr: Address of the returned PktCnt and       */
     /* OctCnt.                                                      */
     /* range: 20:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crps_direct_cnt_addr;

  } __ATTRIBUTE_PACKED__ cnt_proccesso_direct_rd_result0_reg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  /* Cnt Proccesso ADirect Rd Result1: Counter processor A          */
  /* direct-read mode read Result 1                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0523-0x0526 */

     /* CrpsDirectPktsCnt: Packet counter value.                    */
     /* range: 24:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crps_direct_pkts_cnt;

  } __ATTRIBUTE_PACKED__ cnt_proccesso_direct_rd_result1_reg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  /* Cnt Proccesso ADirect Rd Result2: Counter processor A          */
  /* direct-read mode read Result 2                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0524-0x0527 */

     /* CrpsDirectOctsCnt: Octets (bytes) counter value. Note:      */
     /* Reading this offset, clears the CrpsDataValid. This          */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crps_direct_octs_cnt;

  } __ATTRIBUTE_PACKED__ cnt_proccesso_direct_rd_result2_reg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];


  /* Stat If Bist1: Statisitcs interface BIST configDefine          */
  /* the BIST operation. Note: While in BIST mode the IQM does       */
  /* not calculate the 8 ECC bits, as these are part of the         */
  /* BIST data.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0528 */

     /* BistEn: If set then Statistics-if wil enter BIST mode,       */
     /* in this mode the IQM will present test data on the           */
     /* stat-if. Regular statistics reports will be discarded.       */
     /* As long as BistEn is set the stat-if is in BIST mode,        */
     /* when de-asserted the interface will return to                */
     /* operational mode.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_en;

     /* BistMode: Defines the BIST working mode: 0 - Bist            */
     /* pattern mode, data pettenr is defined by BIST-pattern        */
     /* settings. 1- Shift mode: in this mode the BIST-pattern       */
     /* word0 is used while shifted throuhg the MSB (enables         */
     /* walking one test). 2- PRBS mode: in this mode PRBS data      */
     /* is used. otherwise: BIST pattern mode is used.               */
     /* range: 3:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_mode;

     /* BistBurstActions: Defines the number of BIST actions         */
     /* performed in a single burst. The IQM will insert a           */
     /* BistGap idle clocks between each burst.                      */
     /* range: 9:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_burst_actions;

     /* BistGap: The number of idle clocks on the stat-if            */
     /* between each BIST burst. In units of 2. Setting this         */
     /* register to 0 results in continuess BIST regardless of       */
     /* BistActions setting. Note: In PRBS mode this value must      */
     /* be 0 to enable the checker operation.                        */
     /* range: 16:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_gap;

  } __ATTRIBUTE_PACKED__ stat_if_bist_reg;

  /* Stat If Bist Patern0: Statisitcs interface BIST Word 0         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0529 */

     /* BistPtrn0: Defines the first 20 bits of the BIST             */
     /* pattern. The IQM, in BIST-pattern mode, will present         */
     /* BistPtrn0/1 periodicly (changing data every clock) on        */
     /* the statistics interface.                                    */
     /* range: 19:0, access type: RW, default value: 20'haaaaa       */
     SOC_PETRA_REG_FIELD bist_ptrn0;

  } __ATTRIBUTE_PACKED__ stat_if_bist_patern_reg[SOC_PB_IQM_STAT_IF_BIST_PATERN_REG_NOF_REGS];

  /* Global Reject State: Global Reject States status. Per           */
  /* each Drop-precedence.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0550 */

     /* GlbRjctBdb: Reject State VS free-BDBs Drop-p 3,2,1,0         */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_rjct_bdb;

     /* GlbRjctOcBd: Reject State VS consumed BDs (QDR entries)      */
     /* Drop-p 3,2,1,0                                               */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_rjct_oc_bd;

     /* GlbRjctFrdbFlmc: Reject State VS free Unicast Dbuffs         */
     /* Drop-p 3,2,1,0                                               */
     /* range: 11:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD glb_rjct_frdb_flmc;

     /* GlbRjctFrdbMnmc: Reject State VS free Unicast Dbuffs         */
     /* Drop-p 3,2,1,0                                               */
     /* range: 15:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD glb_rjct_frdb_mnmc;

     /* GlbRjctFrdbUc: Reject State VS free Unicast Dbuffs           */
     /* Drop-p 3,2,1,0                                               */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD glb_rjct_frdb_uc;

     /* GlbRjctDramDynSpace: Reject State VS Dram dynamic space      */
     /* (part of guaranteed space logic) Drop-p 3,2,1,0              */
     /* range: 23:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD glb_rjct_dram_dyn_space;

  } __ATTRIBUTE_PACKED__ global_reject_state_reg;

  /* Global Flow Control State: Global Flow-Control                 */
  /* indications.                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0551 */

     /* GlbFcBdb: Global Flow-Control VS free-BDBs.                  */
     /* range: 1:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_fc_bdb;

     /* GlbFcFrdbUc: Global Flow-Control VS free Unicast Dbuffs.     */
     /* range: 3:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_fc_frdb_uc;

     /* GlbFcFrdbFlmc: Global Flow-Control VS free Full              */
     /* multicast Dbuffs.                                            */
     /* range: 5:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_fc_frdb_flmc;

  } __ATTRIBUTE_PACKED__ global_flow_control_state_reg;

  /* Global Resource Counters:                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0552 */

     /* FreeBdbCount: Number of free BDBs (buffer descriptors        */
     /* buffers). The IQM uses this counter to generate/decide       */
     /* on packet Reject and generate Flow-Control signal.           */
     /* range: 16:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD free_bdb_count;

  } __ATTRIBUTE_PACKED__ global_resource_counters_reg;

  /* Global Resource Counters BD:                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0553 */

     /* OcBdCount: Number of occupied BDs (Buffer-Descriptor or      */
     /* QDR entries). The IQM uses this counter to                   */
     /* generate/decide on packet Reject.                            */
     /* range: 22:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD oc_bd_count;

  } __ATTRIBUTE_PACKED__ global_resource_counters_bd_reg;

  /* Free Unicast Dbuffs Counter:                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0554 */

     /* FrDbCountUc: Counts the number of free Unicast Type          */
     /* Dbuffs. The counter is managed by the IQM according to       */
     /* indication of Buffer capture/release from the IDR. The       */
     /* IQM uses this counter to generate/decide on packet           */
     /* Reject and generate Flow-Control signal.                     */
     /* range: 21:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_count_uc;

  } __ATTRIBUTE_PACKED__ free_unicast_dbuffs_counter_reg;

  /* Free Full Multicast Dbuffs Counter:                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0555 */

     /* FrDbCountFlmc: Counts the number of free Full-Multicast      */
     /* Type Dbuffs. The counter is managed by the IQM according     */
     /* to indication of Buffer capture/release from the IDR.        */
     /* The IQM uses this counter to generate/decide on packet       */
     /* Reject and generate Flow-Control signal. The                 */
     /* free-Full-Multicast buffers number is limit to 32K.          */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_count_flmc;

  } __ATTRIBUTE_PACKED__ free_full_multicast_dbuffs_counter_reg;

  /* Free Mini Multicast Dbuffs Counter:                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0556 */

     /* FrDbCountMnmc: Counts the number of free Mini-Multicast      */
     /* Type Dbuffs. The counter is managed by the IQM according     */
     /* to indication of Buffer capture/release from the IDR.        */
     /* The IQM uses this counter to generate/decide on packet       */
     /* Reject and generate Flow-Control signal.                     */
     /* range: 16:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_count_mnmc;

  } __ATTRIBUTE_PACKED__ free_mini_multicast_dbuffs_counter_reg;

  /* Global Resource Minimum Occupancy:                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0557 */

     /* FreeBdbMinOc: Free BDBs (buffer descriptors buffers)         */
     /* minimum occupancy indication. A low watermark that           */
     /* points to minimal level of free-BDBs. Cleared (set to        */
     /* 64K) when read. This register is clear on read.              */
     /* range: 16:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD free_bdb_min_oc;

  } __ATTRIBUTE_PACKED__ global_resource_minimum_occupancy_reg;

  /* Free Unicast Dbuffs Minimum Occupancy:                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0558 */

     /* FrDbMinOc: Free Unicast Type Dbuffs minimal occupancy        */
     /* level. Cleared (set to Number of Uni-Dbuffs) when read.      */
     /* This register is clear on read.                              */
     /* range: 21:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_min_oc;

  } __ATTRIBUTE_PACKED__ free_unicast_dbuffs_minimum_occupancy_reg;

  /* Free Full Multicast Dbuffs Minimum Occupancy:                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0559 */

     /* FrDbFlmcMinOc: Free Full-Multicast Type Dbuffs minimal       */
     /* occupancy level. Cleared (set to Number of                   */
     /* Full-Mul-Dbuffs) when read. This register is clear on        */
     /* read.                                                        */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_flmc_min_oc;

  } __ATTRIBUTE_PACKED__ free_full_multicast_dbuffs_minimum_occupancy_reg;

  /* Free Mini Multicast Dbuffs Minimum Occupancy:                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x055a */

     /* FrDbMnmcMinOc: Free Mini-Multicast Type Dbuffs minimal       */
     /* occupancy level. Cleared (set to Number of                   */
     /* Min-Mul-Dbuffs) when read. This register is clear on         */
     /* read.                                                        */
     /* range: 16:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_mnmc_min_oc;

  } __ATTRIBUTE_PACKED__ free_mini_multicast_dbuffs_minimum_occupancy_reg;

  /* Enqueue Packet Counter:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x055b */

     /* EnqPktCnt: Counts enqueued packets (does not include         */
     /* discarded packets) This register is clear on read.           */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD enq_pkt_cnt;

     /* EnqPktCntOvf: EnqPktCnt Overflow bit. When using CntByGt     */
     /* (count by gtime), the bit means "finished".                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD enq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ enqueue_packet_counter_reg;

  /* Dequeue Packet Counter:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x055c */

     /* DeqPktCnt: Counts dequeued packets (do not include           */
     /* deleted packets) This register is clear on read.             */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD deq_pkt_cnt;

     /* DeqPktCntOvf: DeqPktCnt Overflow bit. When using CntByGt     */
     /* (count by gtime), the bit means "finished".                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ dequeue_packet_counter_reg;

  /* Total Discarded Packet Counter:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x055d */

     /* TotDscrdPktCnt: Counts all the packets discarded at the      */
     /* ENQ pipe. Tail Discarded. This register is clear on          */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tot_dscrd_pkt_cnt;

     /* TotDscrdPktCntOvf: TotDscrdPktCnt Overflow bit. When         */
     /* using CntByGt (count by gtime), the bit means                */
     /* "finished".                                                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tot_dscrd_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ total_discarded_packet_counter_reg;

  /* Deleted Packet Counter:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x055e */

     /* DeqDeletePktCnt: Counts packets discarded in the DEQ         */
     /* process (IPS signaled discard for the packet). Head          */
     /* Discarded. This register is clear on read.                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD deq_delete_pkt_cnt;

     /* DeqDeletePktCntOvf: DeqDeleteCnt Overflow bit. When          */
     /* using CntByGt (count by gtime), the bit means                */
     /* "finished".                                                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_delete_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ deleted_packet_counter_reg;

  /* Isp Packet Counter:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x055f */

     /* IspPktCnt: Counts ISP packets passed on IQM2IRR              */
     /* interface. Note: These packets are counted also as DEQ       */
     /* packets (DeqPktCnt) This register is clear on read.          */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD isp_pkt_cnt;

     /* IspPktCntOvf: IspPktCnt Overflow bit. When using CntByGt     */
     /* (count by gtime), the bit means "finished".                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD isp_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ isp_packet_counter_reg;

  /* Queue Enqueue Packet Counter: Counts according to a            */
  /* programmable Counter                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0560 */

     /* QEnqPktCnt: Counts matched enqueued packets (does not        */
     /* include discarded packets). The counter counts according     */
     /* to Queue filtering settings (PrgCntQ,PrgCntMsk). This        */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qenq_pkt_cnt;

     /* QEnqPktCntOvf: QEnqPktCnt Overflow bit.                      */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qenq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ queue_enqueue_packet_counter_reg;

  /* Queue Dequeue Packet Counter: Counts according to              */
  /* programmable Counter                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0561 */

     /* QDeqPktCnt: Counts matched dequeued packets (does not        */
     /* include deleted packets). The counter counts according       */
     /* to Queue filtering settings (PrgCntQ,PrgCntMsk). This        */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qdeq_pkt_cnt;

     /* QDeqPktCntOvf: QDeqPktCnt Overflow bit.                      */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdeq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ queue_dequeue_packet_counter_reg;

  /* Queue Total Discarded Packet Counter: Counts according         */
  /* to programmable Counter                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0562 */

     /* QTotDscrdPktCnt: Counts matched packets discarded at ENQ     */
     /* pipe. Tail Discarded. The counter counts according to        */
     /* Queue filtering settings (PrgCntQ,PrgCntMsk). This           */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qtot_dscrd_pkt_cnt;

     /* QTotDscrdPktCntOvf: QTotDscrdPktCnt Overflow bit.            */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qtot_dscrd_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ queue_total_discarded_packet_counter_reg;

  /* Queue Deleted Packet Counter: Counts according to              */
  /* programmable Counter                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0563 */

     /* QDeqDeletePktCnt: Counts matched packets discarded in        */
     /* the DEQ process (IPS signaled discard for the packet).       */
     /* Head Discarded. The counter counts according to Queue        */
     /* filtering settings (PrgCntQ,PrgCntMsk). This register is     */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qdeq_delete_pkt_cnt;

     /* QDeqDeletePktCntOvf: QDeqDeleteCnt Overflow bit.             */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdeq_delete_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ queue_deleted_packet_counter_reg;

  /* Free Resource Rejected Packet Counter1: Counters for           */
  /* packet rejected due to lack of global resources.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0564 */

     /* RjctDbPktCnt: Counts packets reject in the ENQ process       */
     /* due to lack of free-Dbuffs                                   */
     /* (Unicast/Mini/Full-multicast). This register is clear on     */
     /* read.                                                        */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_db_pkt_cnt;

     /* RjctDbPktCntOvf: RjctDbPktCnt Overflow bit                   */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_db_pkt_cnt_ovf;

     /* RjctBdbPktCnt: Counts packets reject in the ENQ process      */
     /* due to lack of free-BDBs (free-bdb counter value reduced     */
     /* bellow reject thresholds). This register is clear on         */
     /* read.                                                        */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_bdb_pkt_cnt;

     /* RjctBdbPktCntOvf: RjctBdbPktCnt Overflow bit                 */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_bdb_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ free_resource_rejected_packet_counter1_reg;

  /* Free Resource Rejected Packet Counter2:                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0565 */

     /* RjctBdbProtctPktCnt: Counts packets rejected in the ENQ      */
     /* process due to panic mode protection of free-bdb             */
     /* resource. Note: This type of discard is not related to       */
     /* threholds and drop-p. This register is clear on read.        */
     /* range: 7:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rjct_bdb_protct_pkt_cnt;

     /* RjctBdbProtctPktCntOvf: RjctBdbProtctPktCnt Overflow bit     */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rjct_bdb_protct_pkt_cnt_ovf;

     /* RjctOcBdPktCnt: Counts packets rejected in the ENQ           */
     /* process due to lack of free-BDs (QDR entrees). Note:         */
     /* Packet is discarded if OcBdCounter (occupied BDs) is         */
     /* over threshold. This register is clear on read.              */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_oc_bd_pkt_cnt;

     /* RjctOcBdPktCntOvf: RjctOcBdPktCnt Overflow bit               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_oc_bd_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ free_resource_rejected_packet_counter2_reg;

  /* Irr Error Rejected Packet Counters : These counters            */
  /* count packets that are rejected due to errors reported         */
  /* by the IRR.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0566 */

     /* RjctSnErrPktCnt: Counts packets rejected in the ENQ          */
     /* process due to sequence number error in the IRR (oc-768c     */
     /* re-sequencing). This register is clear on read.              */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_sn_err_pkt_cnt;

     /* RjctSnErrPktCntOvf: RjctSeqNumErrPktCnt Overflow bit.        */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_sn_err_pkt_cnt_ovf;

     /* RjctMcErrPktCnt: Counts packets rejected in the ENQ          */
     /* process due to multicast error in the IRR (IRR did not       */
     /* have place in the MC FIFO). This register is clear on        */
     /* read.                                                        */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_mc_err_pkt_cnt;

     /* RjctMcErrPktCntOvf: RjctBdbPktCnt Overflow bit               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_mc_err_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ irr_error_rejected_packet_counters_reg;

  /* Idr Error Reject Packet Counters : These counters count        */
  /* packets that are rejected due to errors reported by the        */
  /* IDR.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0567 */

     /* RjctRsrcErrPktCnt: Counts packets rejected in the ENQ        */
     /* process resource error signal in the PD: the IDR run out     */
     /* of Dbuffs while re-assembling the packet. Note: In this      */
     /* case, the IQM rejects the packet, but does not release       */
     /* Dbuffs. This register is clear on read.                      */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_rsrc_err_pkt_cnt;

     /* RjctRsrcErrPktCntOvf: RjctRsrcErrPktCnt Overflow bit         */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_rsrc_err_pkt_cnt_ovf;

     /* RjctQnvalidErrPktCnt: Counts packets rejected in the ENQ     */
     /* process due to Q not valid in the ENQ command. This          */
     /* register is clear on read.                                   */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_qnvalid_err_pkt_cnt;

     /* RjctQnvalidErrPktCntOvf: RjctQnvalidErrPktCnt Overflow       */
     /* bit.                                                         */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_qnvalid_err_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ idr_error_reject_packet_counters_reg;

  /* Maximum Occupancy Queue Size0: Maximum Packet Queue            */
  /* occupancy                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0568 */

     /* MxOcQsz: Presents the maximum occupancy level of the         */
     /* Packet Qs. Value is in units of 16-bytes. Cleared when       */
     /* read. This register is clear on read.                        */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mx_oc_qsz;

     /* MxOcRfrsh: Maximum occupancy value refresh indication.       */
     /* Set whenever the maximum occupancy value/Qnum has been       */
     /* updated/changed. Auto-Clear.                                 */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mx_oc_rfrsh;

  } __ATTRIBUTE_PACKED__ maximum_occupancy_queue_size0_reg;

  /* Maximum Occupancy Queue Size1:                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0569 */

     /* MxOcQnum: Holds the Q number to which the maximum            */
     /* occupancy value relates. Updated when MxOcQsz is             */
     /* updated.                                                     */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mx_oc_qnum;

  } __ATTRIBUTE_PACKED__ maximum_occupancy_queue_size1_reg;

  /* Queue Maximum Occupancy Queue Size0: Queue filter              */
  /* Maximum Packet Queue occupancy                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x056a */

     /* QMxOcQsz: Presents the maximum occupancy level (Qsize)       */
     /* measured on the matching filter Q or Qs (PrgCntQ and         */
     /* PrgCntMsk). The Value is in units of 16-bytes. This          */
     /* register is clear on read. This register is clear on         */
     /* read.                                                        */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qmx_oc_qsz;

     /* QMxOcRfrsh: Maximum occupancy value refresh                  */
     /* indication. Set whenever the maximum occupancy value/Qnum     */
     /* has been updated/changed. Auto-Clear.                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qmx_oc_rfrsh;

  } __ATTRIBUTE_PACKED__ queue_maximum_occupancy_queue_size0_reg;

  /* Vsq Maximum Occupancy0: Maximum VSQ occupancy                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x056b */

     /* VsqMxOcQsz: Presents the maximum occupancy level of the      */
     /* VSQs that match the programmable counter                     */
     /* settings. Maximum occupancy is updated when either size       */
     /* in bytes or BDs exceeds the current maximum size. Value       */
     /* is in units of 16-bytes. This register is clear on read.     */
     /* This register is clear on read.                              */
     /* range: 27:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsq_mx_oc_qsz;

     /* VsqMxOcRfrsh: Maximum occupancy value refresh                */
     /* indication. Set whenever the maximum occupancy value/Qnum     */
     /* has been updated/changed. Auto-Clear.                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_mx_oc_rfrsh;

  } __ATTRIBUTE_PACKED__ vsq_maximum_occupancy0_reg;

  /* Vsq Maximum Occupancy1:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x056c */

     /* VsqMxOcQnum: Holds the VSQ Q number to which the maximum     */
     /* occupancy value relates. The VSQ number is the global        */
     /* number (0->355). Updated when VsqMxOcQsz is updated.         */
     /* range: 8:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsq_mx_oc_qnum;

     /* VsqMxOcBdsz: Presents the maximum occupancy level of the     */
     /* VSQ in BDs. Cleared when VsqMxOcQsz is read.                 */
     /* range: 30:9, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsq_mx_oc_bdsz;

  } __ATTRIBUTE_PACKED__ vsq_maximum_occupancy1_reg;

  /* Vsq Enqueue Packet Counter: VSQs programmable Counter          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x056d */

     /* VsqEnqPktCnt: Counts matched VSQs enqueued packets (does     */
     /* not include discarded packets). The counter counts           */
     /* according to Queue filtering settings                        */
     /* (VsqPrgCntQ,VsqPrgCntMsk). (Each event on a VSQ number       */
     /* matched by the filter is considered). This register is       */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsq_enq_pkt_cnt;

     /* VsqEnqPktCntOvf: VsqEnqPktCnt Overflow bit.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_enq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ vsq_enqueue_packet_counter_reg;

  /* Vsq Dequeue Packet Counter: VSQs programmable Counter          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x056e */

     /* VsqDeqPktCnt: Counts matched VSQs dequeued packets (does     */
     /* not include discarded packets). The counter counts           */
     /* according to Queue filtering settings                        */
     /* (VsqPrgCntQ,VsqPrgCntMsk). This register is clear on         */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsq_deq_pkt_cnt;

     /* VsqDeqPktCntOvf: VsqDeqPktCnt Overflow bit                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_deq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ vsq_dequeue_packet_counter_reg;

  /* Qdc Tag Ctrl Dbg Sel: Select CACHE line for debug              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x056f */

     /* TagCtlDbgSel: Defines the TAG control line , in the IQM      */
     /* cache, to be monitored. Both by mirror bus, and by           */
     /* QdcTagDbg status register                                    */
     /* range: 4:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tag_ctl_dbg_sel;

  } __ATTRIBUTE_PACKED__ qdc_tag_ctrl_dbg_sel_reg;

  /* Qdc Tag Ctrl Dbg: Present the selected TAG line controls       */
  /* from the QDC                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0570 */

     /* TagDbgFree: Line is free                                     */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tag_dbg_free;

     /* TagDbgLineV: Line valid                                      */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tag_dbg_line_v;

     /* TagDbgDirty: Line Dirty                                      */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tag_dbg_dirty;

     /* TagDbgUserCnt: User count                                    */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tag_dbg_user_cnt;

     /* TagDbgRdPnd: Read pending                                    */
     /* range: 11:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tag_dbg_rd_pnd;

     /* TagDbgQnum: Q number related to this line                    */
     /* range: 26:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tag_dbg_qnum;

  } __ATTRIBUTE_PACKED__ qdc_tag_ctrl_dbg_reg;

  /* Enqueue Byte Counter:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0571 */

     /* EnqByteCnt: Counts total enqued packet's bytes (does not     */
     /* include discarded packets) This register is clear on         */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD enq_byte_cnt;

     /* EnqByteCntOvf: EnqByteCnt Overflow bit. When using           */
     /* CntByGt (count by gtime), the bit means "finished".          */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD enq_byte_cnt_ovf;

  } __ATTRIBUTE_PACKED__ enqueue_byte_counter_reg;

  /* Dequeue Byte Counter:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0572 */

     /* DeqByteCnt: Counts total dequed packet's bytes This          */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD deq_byte_cnt;

     /* DeqByteCntOvf: DeqByteCnt Overflow bit. When using           */
     /* CntByGt (count by gtime), the bit means "finished".          */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_byte_cnt_ovf;

  } __ATTRIBUTE_PACKED__ dequeue_byte_counter_reg;

  /* Tot Dscrd Byte Counter:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0573 */

     /* TotDscrdByteCnt: Counts total discarded packet's bytes       */
     /* This register is clear on read.                              */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tot_dscrd_byte_cnt;

     /* TotDscrdByteCntOvf: TotDscrdByteCnt Overflow bit. When       */
     /* using CntByGt (count by gtime), the bit means                */
     /* "finished".                                                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tot_dscrd_byte_cnt_ovf;

  } __ATTRIBUTE_PACKED__ tot_dscrd_byte_counter_reg;

  /* Qdr Read Cnt: The counter counts reading command from          */
  /* the QDR                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0574 */

     /* QdrReadRplyCnt: Counts the total number of read command      */
     /* returned from the QDR (speculative and real reads). This     */
     /* register is clear on read.                                   */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qdr_read_rply_cnt;

     /* QdrReadRplyCntOvf: QdrReadRplyCnt Overflow bit               */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_read_rply_cnt_ovf;

     /* QdrValReadRplyCnt: Counts the total number of valid read     */
     /* command returned from the QDR ( the non-valid commands       */
     /* are the speculative reads). This register is clear on        */
     /* read.                                                        */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_val_read_rply_cnt;

     /* QdrValReadRplyCntOvf: QdrValReadRplyCnt Overflow bit         */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_val_read_rply_cnt_ovf;

  } __ATTRIBUTE_PACKED__ qdr_read_cnt_reg;

  /* Cnm Pckt Cnt: The counter counts generated CNM packets         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0575 */

     /* CnmPktCnt: Counts number of generated CNM packets . This     */
     /* register is clear on read.                                   */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cnm_pkt_cnt;

     /* CnmPktCntOvf: CnmPktCnt Overflow bit                         */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnm_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ cnm_pckt_cnt_reg;

  /* Rjct Cnm Pckt Cnt: Rejected CNM packets status.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0576 */

     /* RjctCnmPktCnt: Counts number of rejected CNM packets         */
     /* (CNM FIFO towards IPT was full). This register is clear      */
     /* on read.                                                     */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_cnm_pkt_cnt;

     /* RjctCnmPktCntOvf: RjctCnmPktCnt Overflow bit                 */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_cnm_pkt_cnt_ovf;

     /* RjctCnmCpid: CP-ID of the last rejected CNM packet.          */
     /* Note: Not valid if RjctCnmPktCnt is 0.                       */
     /* range: 27:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_cnm_cpid;

  } __ATTRIBUTE_PACKED__ rjct_cnm_pckt_cnt_reg;

  /* Dram Dyn Reject Packet Counters : DRAM dynamic space           */
  /* packet reject.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0577 */

     /* RjctDramDynPktCnt: Counts packets rejected due to DRAM       */
     /* dynamic space protection. The IQM rejects packets when       */
     /* the dynamic space is over a configurable threshold. This     */
     /* is needed to keep a static area for the Q's guaranteed       */
     /* bytes. This register is clear on read.                       */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_dram_dyn_pkt_cnt;

     /* RjctDramDynPktCntOvf: RjctDramDynPktCnOverflow bit           */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_dram_dyn_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ dram_dyn_reject_packet_counters_reg;

  /* Dram Dyn Size Cnt: DRAM dynamic space resource.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0578 */

     /* DramDynSize: Presents the DRAM dynamic space in 16 bytes     */
     /* units. The dynamic space is calculated according to          */
     /* number of bytes in each Q that exceeds the Q's               */
     /* guaranteed space threshold GrntBytes0->3). The counter       */
     /* is used for reject decisions (according to thresholds:       */
     /* DramDynSizeRjctSet/Clr), in order to keep a guaranteed       */
     /* static space of the DRAM free.                               */
     /* range: 28:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD dram_dyn_size;

  } __ATTRIBUTE_PACKED__ dram_dyn_size_cnt_reg;

  /* Global Resource Counters2: Occupied BDBs                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0579 */

     /* OcBdbCount: Number of occupied BDBs (buffer descriptors      */
     /* buffers).                                                    */
     /* range: 16:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD oc_bdb_count;

  } __ATTRIBUTE_PACKED__ global_resource_counters2_reg;

  /* Reject Status Bmp: Packet reject status score-board. The        */
  /* score board defines all possible packet reject                 */
  /* reasons. Bit asserted, indicates that one (or more)             */
  /* packets wehre rejected during ENQ process due the              */
  /* specific reason.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x057a */

     /* FrBdbRjct:                                                   */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_bdb_rjct;

     /* FrDbUcRjct: Free Unicast Dbuffs number bellow threshold.     */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_db_uc_rjct;

     /* FrDbFlmcRjct: Free Full-MC Dbuffs number bellow              */
     /* threshold.                                                   */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_db_flmc_rjct;

     /* FrDbMnmcRjct: Free Mini-MC Dbuffs number bellow              */
     /* threshold.                                                   */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_db_mnmc_rjct;

     /* OcBdRjct: Reject on occupied BDs (QDR entrees).              */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD oc_bd_rjct;

     /* DramDynSizeRjct: Dram dynamic size protection (guranteed     */
     /* space mechanism).                                            */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD dram_dyn_size_rjct;

     /* DroppLvlRjct: Packet rejected on DP above reject value.      */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD dropp_lvl_rjct;

     /* RsrcErrRjct: Resource error reported , IDR run out of        */
     /* Dbuffs.                                                      */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rsrc_err_rjct;

     /* SeqErrRjct: Sequence error detected (FAT pipe                */
     /* resequencer failed)                                          */
     /* range: 9:9, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD seq_err_rjct;

     /* McErrRjct: Multicast error detected.                         */
     /* range: 10:10, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mc_err_rjct;

     /* QnotValidRjct: Q number is not valid.                        */
     /* range: 11:11, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qnot_valid_rjct;

     /* IspDupErrRjct: Packet rejected due to ISP packet             */
     /* pointing to ISP Q on 2cnd path.                              */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD isp_dup_err_rjct;

     /* PktQMaxSizeRjct: Main Q (packet Q) reached MaxSize.          */
     /* range: 13:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_qmax_size_rjct;

     /* PktQWredRjct: Main Q (packet Q) WRED discard.                */
     /* range: 14:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_qwred_rjct;

     /* VsqaMaxSizeRjct: VSQ-a reached MaxSize (bytes).              */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqa_max_size_rjct;

     /* VsqbMaxSizeRjct: VSQ-b reached MaxSize (bytes).              */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqb_max_size_rjct;

     /* VsqcMaxSizeRjct: VSQ-c reached MaxSize (bytes).              */
     /* range: 17:17, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqc_max_size_rjct;

     /* VsqdMaxSizeRjct: VSQ-d reached MaxSize (bytes).              */
     /* range: 18:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqd_max_size_rjct;

     /* VsqaMaxBdSizeRjct: VSQ-a reached MaxSize (BDs).              */
     /* range: 19:19, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqa_max_bd_size_rjct;

     /* VsqbMaxBdSizeRjct: VSQ-b reached MaxSize (BDs)..             */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqb_max_bd_size_rjct;

     /* VsqcMaxBdSizeRjct: VSQ-c reached MaxSize (BDs)..             */
     /* range: 21:21, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqc_max_bd_size_rjct;

     /* VsqdMaxBdSizeRjct: VSQ-d reached MaxSize (BDs)..             */
     /* range: 22:22, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqd_max_bd_size_rjct;

     /* VsqaWredRjct: VSQ-a WRED diascard.                           */
     /* range: 23:23, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqa_wred_rjct;

     /* VsqbWredRjct: VSQ-b WRED diascard.                           */
     /* range: 24:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqb_wred_rjct;

     /* VsqcWredRjct: VSQ-c WRED diascard.                           */
     /* range: 25:25, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqc_wred_rjct;

     /* VsqdWredRjct: VSQ-d WRED diascard.                           */
     /* range: 26:26, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqd_wred_rjct;

     /* SredRjct: Sytem RED reject.                                  */
     /* range: 27:27, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD sred_rjct;

  } __ATTRIBUTE_PACKED__ reject_status_bmp_reg;

  /* Lst Qdr Read Data: QDR read data                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x057b */

     /* LstQdrReadData: Presents the last received QDR               */
     /* read-data, in case of soft error (ECC or Parity), the        */
     /* value is freezed untill read. This register is clear on      */
     /* read.                                                        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lst_qdr_read_data;

  } __ATTRIBUTE_PACKED__ lst_qdr_read_data_reg;

  /* Crps Cnt Ovrf Sts: Counter processors overflowed counter       */
  /* status                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x057c */

     /* CrpsCounterOvfAddr: Indicates the counter pair that         */
     /* overflowed last address Note: Valid when CntOvf              */
     /* interrupt is set. Value is locked untill interrupt is        */
     /* cleared. This register is clear on read.                     */
     /* range: 12:0, access type: RO, default value: 0x0             */
     /* range: 28:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_counter_ovf_addr[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsIsOvfCntPkts: If set, the overflown counter in the      */
     /* pair was the packets counter. Note: Valid when CntOvf        */
     /* interrupt is set. Value is locked untill interrupt is        */
     /* cleared.                                                     */
     /* range: 13:13, access type: RO, default value: 0x0            */
     /* range: 29:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_is_ovf_cnt_pkts[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

     /* CrpsIsOvfCntOcts: If set, the overflown counter in the      */
     /* pair was the octets counter. Note: Valid when CntOvf         */
     /* interrupt is set. Value is locked untill interrupt is        */
     /* cleared.                                                     */
     /* range: 14:14, access type: RO, default value: 0x0            */
     /* range: 30:30, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_is_ovf_cnt_octs[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  } __ATTRIBUTE_PACKED__ crps_cnt_ovrf_sts_reg;

  /* Crps Counter Sts: Coutner processor A - command status        */
  /* counters                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x057d-0x057e  */

     /* CrpsCmdCnt: The counter holds the counting-commands         */
     /* received ( by the design). Note: counter is cleared on       */
     /* read. This register is clear on read.                        */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crps_cmd_cnt;

     /* CrpsCmdCntOvf: Indicated CmdCnt counter overflow.           */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_cmd_cnt_ovf;

     /* CrpsCpuReqCnt: The counter holds the CPU read requests      */
     /* received. Note: counter is cleared on read. This             */
     /* register is clear on read.                                   */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_cpu_req_cnt;

     /* CrpsCpuReqCntOvf: Indicated CpuReqCnt counter overflow.     */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_cpu_req_cnt_ovf;

  } __ATTRIBUTE_PACKED__ crps_counter_sts_reg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

  /* Crps Counter Sts1: Coutner processor  - counters             */
  /* status counters                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x057f - 0x0580 */

     /* CrpsOvthCntrsCnt: The counter presents the number of        */
     /* counters that are over the threshold. Note: maximal          */
     /* value is 8192.                                               */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crps_ovth_cntrs_cnt;

     /* CrpsctCntrsCnt: The coutner presents the number of         */
     /* active (non-emtpy) pairs of counters. Note: maximal          */
     /* value is 8192.                                               */
     /* range: 28:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crps_act_cntrs_cnt;

  } __ATTRIBUTE_PACKED__ crps_counter_sts1_reg[SOC_PB_CHIP_REGS_NOF_CNT_PROCESSOR_IDS];

 
  /* Mtrpa Stats Cfg: Meter processor A - Statistics counter        */
  /* configuration                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0581 */

     /* MtrpaStatsGranularity: If set the MRPS counts its            */
     /* statistics in bytes granularity, otherwise in nibble         */
     /* granularity.                                                 */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mtrpa_stats_granularity;

     /* MtrpaStatsIsHigh: If set the Stat-Index point a              */
     /* High-Rate index, otherwise Nomal-Rate index.                 */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mtrpa_stats_is_high;

     /* MtrpaStatsCfgIndex: High-Rate / Normal-Rate configured       */
     /* index.                                                       */
     /* range: 14:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpa_stats_cfg_index;

     /* MtrpaStatsCfgIndexMask: High-Rate / Normal-Rate              */
     /* configured index mask.                                       */
     /* range: 27:15, access type: RW, default value: 0x1fff         */
     SOC_PETRA_REG_FIELD mtrpa_stats_cfg_index_mask;

  } __ATTRIBUTE_PACKED__ mtrpa_stats_cfg_reg;

  /* Mtrpa Cbl Cnt: Meter processor A - Leaky buckets               */
  /* statistics CBL counter                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0582 */

     /* MtrpaCblCnt: Number of bytes assigned by the committed       */
     /* leaky bucket of the configured index. This register is       */
     /* clear on read. This register is clear on read.               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpa_cbl_cnt;

     /* MtrpaCblCntOvf: MtrpaCblCnt overflow. This register is       */
     /* clear on read. When using CntByGt (count by gtime), the      */
     /* bit means "finished".                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpa_cbl_cnt_ovf;

  } __ATTRIBUTE_PACKED__ mtrpa_cbl_cnt_reg;

  /* Mtrpa Ebl Cnt: Meter processor A - Leaky buckets               */
  /* statistics EBL counter                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0583 */

     /* MtrpaEblCnt: Number of bytes assigned by the excessed        */
     /* leaky bucket of the configured index. This register is       */
     /* clear on read. This register is clear on read.               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpa_ebl_cnt;

     /* MtrpaEblCntOvf: MtrpaEblCnt overflow. This register is       */
     /* clear on read. When using CntByGt (count by gtime), the      */
     /* bit means "finished".                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpa_ebl_cnt_ovf;

  } __ATTRIBUTE_PACKED__ mtrpa_ebl_cnt_reg;

  /* Mtrpa Bubble Cnt: Meter processor A - Bubbles counter          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0584 */

     /* MtrpaBubbleCnt: Counts the number of bubules (IQM enque      */
     /* gap requests) that the Meter has generated. This             */
     /* register is clear on read. This register is clear on         */
     /* read.                                                        */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpa_bubble_cnt;

     /* MtrpaBubbleCntOvf: MtrpaBubbleCnt overflow. When using       */
     /* CntByGt (count by gtime), the bit means "finished". This     */
     /* register is clear on read.                                   */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpa_bubble_cnt_ovf;

  } __ATTRIBUTE_PACKED__ mtrpa_bubble_cnt_reg;

  /* Mtrpb Stats Cfg: Meter processor B - Statistics counter        */
  /* configuration                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0585 */

     /* MtrpbStatsGranularity: If set the MRPS counts its            */
     /* statistics in bytes granularity, otherwise in nibble         */
     /* granularity.                                                 */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mtrpb_stats_granularity;

     /* MtrpbStatsIsHigh: If set the Stat-Index point a              */
     /* High-Rate index, otherwise Nomal-Rate index.                 */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mtrpb_stats_is_high;

     /* MtrpbStatsCfgIndex: High-Rate / Normal-Rate configured       */
     /* index.                                                       */
     /* range: 14:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpb_stats_cfg_index;

     /* MtrpbStatsCfgIndexMask: High-Rate / Normal-Rate              */
     /* configured index mask.                                       */
     /* range: 27:15, access type: RW, default value: 0x1fff         */
     SOC_PETRA_REG_FIELD mtrpb_stats_cfg_index_mask;

  } __ATTRIBUTE_PACKED__ mtrpb_stats_cfg_reg;

  /* Mtrpb Cbl Cnt: Meter processor B - Leaky buckets               */
  /* statistics CBL counter                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0586 */

     /* MtrpbCblCnt: Number of bytes assigned by the committed       */
     /* leaky bucket of the configured index. This register is       */
     /* clear on read. This register is clear on read.               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpb_cbl_cnt;

     /* MtrpbCblCntOvf: MtrpbCblCnt overflow. This register is       */
     /* clear on read. When using CntByGt (count by gtime), the      */
     /* bit means "finished".                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_cbl_cnt_ovf;

  } __ATTRIBUTE_PACKED__ mtrpb_cbl_cnt_reg;

  /* Mtrpb Ebl Cnt: Meter processor B - Leaky buckets               */
  /* statistics EBL counter                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0587 */

     /* MtrpbEblCnt: Number of bytes assigned by the excessed        */
     /* leaky bucket of the configured index. This register is       */
     /* clear on read. This register is clear on read.               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpb_ebl_cnt;

     /* MtrpbEblCntOvf: MtrpbEblCnt overflow. This register is       */
     /* clear on read. When using CntByGt (count by gtime), the      */
     /* bit means "finished".                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_ebl_cnt_ovf;

  } __ATTRIBUTE_PACKED__ mtrpb_ebl_cnt_reg;

  /* Mtrpb Bubble Cnt: Meter processor B - Bubbles counter          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0588 */

     /* MtrpbBubbleCnt: Counts the number of bubules (IQM enque      */
     /* gap requests) that the Meter has generated. This             */
     /* register is clear on read. This register is clear on         */
     /* read.                                                        */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpb_bubble_cnt;

     /* MtrpbBubbleCntOvf: MtrpaBubbleCnt overflow. When using       */
     /* CntByGt (count by gtime), the bit means "finished".          */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_bubble_cnt_ovf;

  } __ATTRIBUTE_PACKED__ mtrpb_bubble_cnt_reg;

  /* Mrpsa Last Idx: Last meter command index processed             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0589 */

     /* MtrpaCmdLastIndex: Holds the last meter command index        */
     /* processed by the MRPS. Note: Index is updated only when      */
     /* other index is processed by the MRPS. This register is       */
     /* clear on read.                                               */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpa_cmd_last_index;

     /* MtrpaCmdLastIndexUpdated: Meter command index was            */
     /* updated. Note: clear when read                               */
     /* range: 13:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpa_cmd_last_index_updated;

  } __ATTRIBUTE_PACKED__ mrpsa_last_idx_reg;

  /* Mrpsb Last Idx: Last meter command index processed             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x058a */

     /* MtrpbCmdLastIndex: Holds the last meter command index        */
     /* processed by the MRPS. Note: Index is updated only when      */
     /* other index is processed by the MRPS. This register is       */
     /* clear on read.                                               */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtrpb_cmd_last_index;

     /* MtrpbCmdLastIndexUpdated: Meter command index was            */
     /* updated. Note: clear when read                               */
     /* range: 13:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtrpb_cmd_last_index_updated;

  } __ATTRIBUTE_PACKED__ mrpsb_last_idx_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_IQM_REGS;
/* Block definition: QDR */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in the QDR.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0600 */

     /* QdrEccInt: If set, indicates that ecc error occurred in      */
     /* the QDR                                                      */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_ecc_int;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0610 */

     /* QdrEccIntMask: Writing 0 masks QDR ECC Interrupt             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_ecc_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0620 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg;

  /* Indirect Command Rd Data: Data from indirect read              */
  /* command                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0630 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg;

  /* Indirect Command: Send indirect commands to QDR and            */
  /* receives status.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0640 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically set          */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Address for indirect command         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0641 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0642 */

     /* IndirectCommandDataIncrement:                                */
     /* IndirectCommandWrData[31:0] is incremented by this value     */
     /* after every indirect write. Addition is cyclic.              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_QDR_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* Qdr Ecc Error Counter: QDR ECC error counter. This             */
  /* register counts the number of errors detected by the ECC       */
  /* mechanism.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0660 */

     /* QdrEccErrCnt: Qdr ecc error counter of all read replies      */
     /* (BD, Indirect) This register is clear on read.               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qdr_ecc_err_cnt;

     /* QdrEccErrCntOvf: Qdr ecc error counter overflow              */
     /* indication                                                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_ecc_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ qdr_ecc_error_counter_reg;

  /* Reply Threshold: Reply threshold for QDR Mux FIFOs. The        */
  /* QDR includes several FIFOs for the read replies. This          */
  /* registers sets the full FIFO threshold indication              */
  /* towards the IQM.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0661 */

     /* ReplyTh: Qdr Mux Reply FIFO almost-full threshold. FIFO      */
     /* direction is QDRM to IQM.                                    */
     /* range: 5:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD reply_th;

  } __ATTRIBUTE_PACKED__ reply_threshold_reg;

  /* Dll Update Period: Dll Update Period. The DLL requires         */
  /* to be updated periodically. This registers sets the            */
  /* duration of the update period, in core clocks, which           */
  /* should be no less than the equivalent to 8 QDR clocks.         */
  /* Setting high values in this register will harm the             */
  /* bandwidth.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0662 */

     /* DllUpdatePrd: Dll update period, measured in core            */
     /* clocks. Should be equivalent to no less than 8 QDR           */
     /* clocks.                                                      */
     /* range: 7:0, access type: RW, default value: 0x14             */
     SOC_PETRA_REG_FIELD dll_update_prd;

  } __ATTRIBUTE_PACKED__ dll_update_period_reg;

  /* Qdr Protect Disable: Disable protection on QDR. This           */
  /* register disables both ECC and parity protection on the        */
  /* QDR.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0663 */

     /* QdrProtectDis: If set, disables both ECC and parity          */
     /* protection on QDR                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_protect_dis;

  } __ATTRIBUTE_PACKED__ qdr_protect_disable_reg;

  /* Qdr Ecc Bit Correction Counter: QDR ECC bit corrections        */
  /* counter. This register counts the number of bits the QDR       */
  /* was able to correct due to ECC errors. The QDR can             */
  /* correct only 1 bit errors per data burst.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0664 */

     /* QdrEccBitCorrCnt: Qdr ecc bit corrections counter of all     */
     /* read replies (BD, Indirect) This register is clear on        */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qdr_ecc_bit_corr_cnt;

     /* QdrEccBitCorrCntOvf: Qdr ecc bit corrections counter         */
     /* overflow indication                                          */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_ecc_bit_corr_cnt_ovf;

  } __ATTRIBUTE_PACKED__ qdr_ecc_bit_correction_counter_reg;

  /* Qdr Bist Enable: Enables the QDR BIST (Built In Self           */
  /* Test) mechanism. This register should be enabled only          */
  /* after all QDR BIST registers are configured. This is a         */
  /* level signal, therefore the BIST infinite tests will run       */
  /* as long as it is enabled. All traffic and indirect             */
  /* access must stop before BIST is enabled.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0667 */

     /* QdrBistEn: If set, enables QDR bist. Otherwise, bist is      */
     /* disabled.                                                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_bist_en;

  } __ATTRIBUTE_PACKED__ qdr_bist_enable_reg;

  /* Bist Write Number Configuration Register: Number of            */
  /* write commands to be executed in a BIST test.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0668 */

     /* BistWriteNum: Number of write commands to execute in one     */
     /* full bist test.                                              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_write_num;

  } __ATTRIBUTE_PACKED__ bist_write_number_configuration_reg;

  /* Bist Read Number Configuration Register: Number of read        */
  /* commands to be executed in a BIST test.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0669 */

     /* BistReadNum: Number of read commands to execute in one       */
     /* full bist test.                                              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_read_num;

  } __ATTRIBUTE_PACKED__ bist_read_number_configuration_reg;

  /* Bist Infinite Test: Execute an infinite QDR BIST test.         */
  /* The test will execute an infinite number of read and/or        */
  /* write commands as long as QDR BIST is enabled.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x066a */

     /* BistWriteInfinite: Execute an infinite number of write       */
     /* commands in the bist test. Test is stopped only by           */
     /* negating QdrBistEn.                                          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_write_infinite;

     /* BistReadInfinite: Execute an infinite number of read         */
     /* commands in the bist test. Test is stopped only by           */
     /* negating QdrBistEn.                                          */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_read_infinite;

  } __ATTRIBUTE_PACKED__ bist_infinite_test_reg;

  /* Bist Read Delay: Number of write commands to execute           */
  /* before executing read commands. Some write commands must       */
  /* be executed prior to read commands to ensure the return        */
  /* of valid data.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x066b */

     /* BistReadDelay: Number of write commands to execute           */
     /* before stating to execute read commands. Required to         */
     /* assure knowledge of returned data.                           */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_read_delay;

  } __ATTRIBUTE_PACKED__ bist_read_delay_reg;

  /* Bist Thresholds: Reply threshold for QDR BIST FIFOs. The       */
  /* QDR BIST block includes several FIFOs for write and read       */
  /* commands. This register sets the full FIFO threshold           */
  /* indication to the internal machines.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x066c */

     /* BistWrTh: Qdr Mux Bist write FIFO threshold                  */
     /* range: 3:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD bist_wr_th;

     /* BistRdTh: Qdr Mux Bist read FIFO threshold                   */
     /* range: 11:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD bist_rd_th;

  } __ATTRIBUTE_PACKED__ bist_thresholds_reg;

  /* Bist Gap: This register sets the gap between commands in       */
  /* a BIST test. It is intended to control the transactions        */
  /* bandwidth on the bus, with the default value being 100%        */
  /* bandwidth. Any gap larger than zero will reduce the            */
  /* transactions bandwidth.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x066e */

     /* BistGap: The number of commands that should be issued        */
     /* before an idle is inserted for one clock. The gap allows     */
     /* reducing commands bandwidth. Actual                          */
     /* bandwidth=BistGap/(BistGap+1) and may range from 50% to      */
     /* 100% of maximal bandwidth. BistGap=0 mean 100%               */
     /* bandwidth. The gap is identical for both read and write      */
     /* commands.                                                    */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_gap;

  } __ATTRIBUTE_PACKED__ bist_gap_reg;

  /* Bist Pattern0: The test pattern that will be used in the       */
  /* BIST test. For a simple BIST test, only 18 bits (same as       */
  /* data bus width) will be used. The used bits are bits           */
  /* 17:0. For a BIST test in bit mode, all 32 bits are             */
  /* used. This register defines Bist test Pattern, Word 0           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x066f */

     /* BistPattern0: Bist test Pattern, Word 0. First 18b are       */
     /* used for simple bist test; all 32b are used for BitMode      */
     /* test.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern0;

  } __ATTRIBUTE_PACKED__ bist_pattern_regs[SOC_PB_QDR_BIST_PATTERN_REG_NOF_REGS];

  /* Bist Start Address: BIST test start address. This              */
  /* register configures the start address for the bist test        */
  /* write commands.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0677 */

     /* BistStartAddress: Bist test write commands start address     */
     /* in the QDR memory                                            */
     /* range: 21:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_start_address;

  } __ATTRIBUTE_PACKED__ bist_start_address_reg;

  /* Bist End Address: BIST test end address. This register         */
  /* configures the end address for the bist test read &            */
  /* write commands.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0678 */

     /* BistEndAddress: Bist test write and read commands end        */
     /* address in the QDR memory. If end address is reached,        */
     /* address is reset to the initial write or read address        */
     /* (accordingly).                                               */
     /* range: 21:0, access type: RW, default value: 22'h3ffff       */
     SOC_PETRA_REG_FIELD bist_end_address;

  } __ATTRIBUTE_PACKED__ bist_end_address_reg;

  /* Bist Offset Address: This register sets the offset of          */
  /* BIST read commands start address from the write commands       */
  /* start address.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0679 */

     /* BistOffsetAddress: Bist test read commands offset            */
     /* address. The initial read address is set to the              */
     /* StartAddress+OffsetAddress. In AddressShift mode,            */
     /* initial read address is set to                               */
     /* StartAddress<<OffsetAddress. If OffsetAddress>ReadDelay,     */
     /* then the used offset is set to read delay, to assure         */
     /* knowledge of returning data.                                 */
     /* range: 21:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_offset_address;

  } __ATTRIBUTE_PACKED__ bist_offset_address_reg;

  /* Bist Test Mode: BIST test mode register. Used to select        */
  /* the operation mode of the BIST test. Can be used to            */
  /* configure both data and address advancing mode, as well        */
  /* as a dedicated address test. When no bit is asserted, a         */
  /* simple BIST test mode is in use, reading and writing two       */
  /* 18b BistPattern words on every transaction.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x067a */

     /* BistPatternBitMode: If set, every write command one bit      */
     /* data from the BistPattern is duplicated on the entire        */
     /* data bus. For one burst of 2 commands, 2 consecutive         */
     /* bits are used. All 32b of every BistPattern word are         */
     /* used in this mode. BistPatternBitMode is ignored if          */
     /* BistAddressTest is set.                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_pattern_bit_mode;

     /* BistDataRandomMode: If set, every write command is           */
     /* random data, generated by x^31+x^28+1 polynomial. For        */
     /* one burst of two commands, 2 consecutive 26b data writes     */
     /* are done. In this mode, the BistOffsetAddress is always      */
     /* taken to be 0. BistDataRandomMode is ignored if              */
     /* BistAddressTest or BistPatternBitMode are set.               */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_data_random_mode;

     /* BistDataShiftMode: If set, every write command the data      */
     /* is shifted in cyclic manner one bit left. For one burst      */
     /* of 2 commands, 2 consecutive shifts are done. Only           */
     /* BistPattern0 word is used in this mode. Intended for         */
     /* walking one / walking zero tests. BistDataShiftMode is       */
     /* ignored if BistAddressTest or BistPatternBitMode are         */
     /* set.                                                         */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_data_shift_mode;

     /* BistAddressShiftMode: If set, every write command the        */
     /* address is shifted in cyclic manner one bit left.            */
     /* Address is reset if it exceeds EndAddress. Intended for      */
     /* walking one / walking zero tests. BistAddressShiftMode       */
     /* is ignored if AddressTest is set.                            */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_address_shift_mode;

     /* BistAddressTest: Address test mode. Overrides all other      */
     /* bist modes. Writes walking ones and zeros on the address     */
     /* bus and finds if any address bit is defective.               */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_address_test;

  } __ATTRIBUTE_PACKED__ bist_test_mode_reg;

  /* Bist Address Bits Number: This register is used to             */
  /* configure the number of address bits in the used QDR           */
  /* memory. It allows user flexibility, as not always the          */
  /* maximal QDR size will be assembled on board.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x067b */

     /* BistAddrBitNum: Number of Address bits in the assembled      */
     /* QDR. This bit is relevant for address test only.             */
     /* range: 4:0, access type: RW, default value: 0x16             */
     SOC_PETRA_REG_FIELD bist_addr_bit_num;

  } __ATTRIBUTE_PACKED__ bist_address_bits_number_reg;

  /* Bist Data Shift Mod Offset: For BIST test in data shift        */
  /* mode, when read start address is in offset from write          */
  /* start address, this register should include the number         */
  /* of bits shifted between write and read address. This           */
  /* value equals (BistOffsetAddress*2) modulus                     */
  /* QDR_bus_width. BistOffsetAddress*2 is used, as each 2          */
  /* burst QDR is used. Example: If BistOffsetAddress=30,            */
  /* BistDataShiftModOffset=(30*2)%18=6                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x067c */

     /* BistDataShiftModOffset: The number of bits that should       */
     /* be shifted in data shift test mode. This value equals        */
     /* (BistOffsetAddress*2) modulus 18                             */
     /* range: 4:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_data_shift_mod_offset;

  } __ATTRIBUTE_PACKED__ bist_data_shift_mod_offset_reg;

  /* Bist Burst Mask0: Configure the bits in a burst (2             */
  /* commands) that should be masked for errors in the BIST         */
  /* test. This register configures masked bits in the data         */
  /* burst, word 0.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x067d */

     /* BistBurstMask0: Writing 0 masks error bits in the data       */
     /* burst, word 0.                                               */
     /* range: 17:0, access type: RW, default value: 18'h3FFFF       */
     SOC_PETRA_REG_FIELD bist_burst_mask0;

  } __ATTRIBUTE_PACKED__ bist_burst_mask_reg[SOC_PB_QDR_BIST_BURST_MASK_REG_NOF_REGS];

  /* Bist Bit Mask: Configures the bits on the data bus that        */
  /* should be masked for errors in the BIST test.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x067f */

     /* BistBitMask: Writing 0 masks error bits in the data bus.     */
     /* range: 17:0, access type: RW, default value: 18'h3FFFF       */
     SOC_PETRA_REG_FIELD bist_bit_mask;

  } __ATTRIBUTE_PACKED__ bist_bit_mask_reg;

  /* Bist Error Burst Counter: BIST burst error counter. This       */
  /* register counts the number of erroneous burst (2               */
  /* commands) replies detected.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0680 */

     /* BistErrBurstCounter: Bist burst error counter. Counts        */
     /* the number of errors that appeared on one burst (2           */
     /* commands) reply. This register is clear on read.             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_err_burst_counter;

  } __ATTRIBUTE_PACKED__ bist_error_burst_counter_reg;

  /* Bist Error Bit Counter: BIST bit error counter. This           */
  /* register counts the number of erroneous data (18 bit)          */
  /* replies detected.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0681 */

     /* BistErrBitCounter: Bist bit error counter. Counts the        */
     /* number of errors that appeared on one 18-bit reply. This     */
     /* may increase by 1 for every reply, regardless of the         */
     /* number of different bit errors on the reply. This            */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_err_bit_counter;

  } __ATTRIBUTE_PACKED__ bist_error_bit_counter_reg;

  /* Bist Error Occurred: BIST error occurred indication bit.       */
  /* An asserted bit indicates that at least one error              */
  /* occurrs on this specific data bit. Every bit corresponds       */
  /* to a bit on the external QDR data bus.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0682 */

     /* BistErrOccurred: Bist error occurred indication per bit.     */
     /* A bit is asserted if an error has occurred on it any         */
     /* time during the test. Each bit is equivalent to a bit on     */
     /* the external QDR data bus. This register is clear on         */
     /* read.                                                        */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_err_occurred;

  } __ATTRIBUTE_PACKED__ bist_error_occurred_reg;

  /* Bist Global Error Counter: BIST global error counter.          */
  /* This register counts the number of erroneous replies           */
  /* during a test, regardless of masking.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0683 */

     /* BistGlobalErrCounter: Bist global error counter. Counts      */
     /* the total number of erroneous replies, regardless bit        */
     /* masking. This register is clear on read.                     */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_global_err_counter;

  } __ATTRIBUTE_PACKED__ bist_global_error_counter_reg;

  /* Bist Error Address: This register saves the address of         */
  /* the last erroneous burst reply.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0684 */

     /* BistErrAddress: The address of the last erroneous burst      */
     /* reply.                                                       */
     /* range: 21:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_err_address;

  } __ATTRIBUTE_PACKED__ bist_error_address_reg;

  /* Bist Error Data1: This register saves the reply data           */
  /* from the first burst of the last erroneous reply.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0685 */

     /* BistErrData1: The data of the last erroneous burst           */
     /* reply, first burst word.                                     */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_err_data1;

  } __ATTRIBUTE_PACKED__ bist_error_data1_reg;

  /* Bist Error Data2: This register saves the reply data           */
  /* from the second burst of the last erroneous reply.             */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0686 */

    /* BistErrData2: The data of the last erroneous burst           */
    /* reply, second burst word.                                    */
    /* range: 17:0, access type: RO, default value: 0x0             */
    SOC_PETRA_REG_FIELD bist_err_data2;

  } __ATTRIBUTE_PACKED__ bist_error_data2_reg;

  /* Bist Finished: BIST test finished indication. This bit         */
  /* is asserted only for non-infinite BIST tests.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0687 */

     /* BistFinished: Bist test finished indication. Cleared         */
     /* when BistEn is reset.                                        */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_finished;

  } __ATTRIBUTE_PACKED__ bist_finished_reg;

  /* Qdr Dll Off Control: This register controls the QDR DLL        */
  /* on/off state. It is directly mirrored to the DLL off           */
  /* signal.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0688 */

     /* DllOffn: Writing 0 turns off QDR DLL                         */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dll_offn;

  } __ATTRIBUTE_PACKED__ qdr_dll_control_reg;

  /* Qdr Controller Reset Register: This register controls          */
  /* the QDR controller block reset.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0689 */

     /* QdrcRstN: Writing 0 puts the QDRC block into reset.          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdrc_rst_n;

  } __ATTRIBUTE_PACKED__ qdr_controller_reset_reg;

 /* Qdr Dummy Data0: QDR Controller dummy data. This data is       */
  /* used both for training sequence and for sending on the         */
  /* write interface when no data is available. This register        */
  /* contains the first datum.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068a */

     /* DummyData0: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. First datum.            */
     /* range: 17:0, access type: RW, default value: 18'h2AAAA       */
     SOC_PETRA_REG_FIELD dummy_data0;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data0_reg;

  /* Qdr Dummy Data1: QDR Controller dummy data, second datum       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068b */

     /* DummyData1: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Second datum.           */
     /* range: 17:0, access type: RW, default value: 18'h15555       */
     SOC_PETRA_REG_FIELD dummy_data1;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data1_reg;

  /* Qdr Dummy Data2: QDR Controller dummy data, third datum        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068c */

     /* DummyData2: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Third datum.            */
     /* range: 17:0, access type: RW, default value: 18'h2AAAA       */
     SOC_PETRA_REG_FIELD dummy_data2;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data2_reg;

  /* Qdr Dummy Data3: QDR Controller dummy data, forth datum        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068d */

     /* DummyData3: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Forth datum.            */
     /* range: 17:0, access type: RW, default value: 18'h15555       */
     SOC_PETRA_REG_FIELD dummy_data3;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data3_reg;

  /* Qdr Dummy Data4: QDR Controller dummy data, fifth datum        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068e */

     /* DummyData4: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Fifth datum.            */
     /* range: 17:0, access type: RW, default value: 18'h2AAAA       */
     SOC_PETRA_REG_FIELD dummy_data4;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data4_reg;

  /* Qdr Dummy Data5: QDR Controller dummy data, sixth datum        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068f */

     /* DummyData5: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Sixth datum.            */
     /* range: 17:0, access type: RW, default value: 18'h15555       */
     SOC_PETRA_REG_FIELD dummy_data5;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data5_reg;

  /* Qdr Dummy Data6: QDR Controller dummy data, seventh            */
  /* datum                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0690 */

     /* DummyData6: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Seventh datum.          */
     /* range: 17:0, access type: RW, default value: 18'h2AAAA       */
     SOC_PETRA_REG_FIELD dummy_data6;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data6_reg;

  /* Qdr Dummy Data7: QDR Controller dummy data, eighth datum       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0691 */

     /* DummyData7: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Eighth datum.           */
     /* range: 17:0, access type: RW, default value: 18'h15555       */
     SOC_PETRA_REG_FIELD dummy_data7;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data7_reg;

  /* Qdr Seek Data1: QDR Controller seek data. This data is         */
  /* used both for training sequence as the locking                 */
  /* pattern. This register contains the first datum.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0692 */

     /* SeekData1: QDR Controller seek data. This data is used       */
     /* for training sequence, as the locking pattern. First         */
     /* datum.                                                       */
     /* range: 17:0, access type: RW, default value: 18'h3FFFF       */
     SOC_PETRA_REG_FIELD seek_data1;

  } __ATTRIBUTE_PACKED__ qdr_seek_data_reg[SOC_PB_QDR_QDR_SEEK_DATA_REG_NOF_REGS];

  /* Qdr Calibration Configuration Register: QDR Calibration        */
  /* Configuration. This register contains several parameters       */
  /* used for the QDR controller calibration.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0694 */

     /* PreRead: Number of dummy data reads to execute before        */
     /* reading SeekData                                             */
     /* range: 3:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD pre_read;

     /* PostRead: Number of dummy data reads to execute after        */
     /* reading SeekData                                             */
     /* range: 7:4, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD post_read;

     /* UseDummyData: Use DummyData set by the register.             */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD use_dummy_data;

     /* MaxSeekCnt: Maximal number of clocks to wait between         */
     /* read command issue and data reply.                           */
     /* range: 15:12, access type: RW, default value: 0xf            */
     SOC_PETRA_REG_FIELD max_seek_cnt;

     /* MaxIteration: Maximal iterations to look for SeekData        */
     /* during the training sequence. Each iteration waits           */
     /* MaxSeekCnt clocks.                                           */
     /* range: 19:16, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD max_iteration;

  } __ATTRIBUTE_PACKED__ qdr_calibration_configuration_reg;

  /* Qdr Calibration Trigger: This register contains the            */
  /* trigger for the QDR calibration sequence.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0695 */

     /* SeekTrigger: If set, triggers the QDR calibration            */
     /* sequence.                                                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD seek_trigger;

  } __ATTRIBUTE_PACKED__ qdr_calibration_trigger_reg;

  /* Qdr Calibration Bypass: QDR Calibration bypass. Allows         */
  /* to manually set the QDR controller parameters, if the          */
  /* QDR calibration fails.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0696 */

     /* SetDelay: A constant delay to use between read command       */
     /* issue and read command reply                                 */
     /* range: 3:0, access type: RW, default value: 0x5              */
     SOC_PETRA_REG_FIELD set_delay;

     /* BypassCalib: Bypass QDR controller calibration sequence      */
     /* and use SetDelay                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bypass_calib;

  } __ATTRIBUTE_PACKED__ qdr_calibration_bypass_reg;

  /* Qdr Reply Lock: QDR controller has lock indication,            */
  /* marking the completion of QDR controller calibration.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0697 */

     /* ReplyLock: If set, indicates that QDR controller has         */
     /* locked on read command reply.                                */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD reply_lock;

  } __ATTRIBUTE_PACKED__ qdr_reply_lock_reg;

  /* Qdr Reply Delay: This register contains information            */
  /* about the delay, in QDR clocks, between the time a read        */
  /* command is sent and a read reply returns.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0698 */

     /* ReplyDelay: QDR delay between Read command issue by QDRC     */
     /* and returning reply.                                         */
     /* range: 3:0, access type: RO, default value: 0x7              */
     SOC_PETRA_REG_FIELD reply_delay;

  } __ATTRIBUTE_PACKED__ qdr_reply_delay_reg;

  /* Qdr Phy Reset: Qdr Phy Reset and calibration restart           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x069a */

     /* QdioReset: Reset QDR Phy module, active low                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdio_reset;

     /* DdlInitReset: Restart Qdr Phy DDL calibration Sequence       */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddl_init_reset;

  } __ATTRIBUTE_PACKED__ qdr_phy_reset_reg;

  /* Qdr Init Status: This register includes indications of         */
  /* the status of the QDR phy initialization sequence.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x069b */

     /* Ready: Phy ready indication                                  */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ready;

     /* DdlInitDone: DDL initialization done indication              */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddl_init_done;

     SOC_PETRA_REG_FIELD dll_mstr_s;

  } __ATTRIBUTE_PACKED__ qdr_init_status_reg;

  struct
  {
    SOC_PETRA_REG_ADDR addr; /* 0x069c */
    SOC_PETRA_REG_FIELD qc_sel_vec_lsb;
  } __ATTRIBUTE_PACKED__ qdr_qc_sel_vec_lsb_reg;

  /* Qdr Training Fail:                                             */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x069d */
    SOC_PETRA_REG_FIELD qc_sel_vec_msb;

    /* Fail: If set, indicates that QDR reply failed              */
    /* range: 11:11, access type: RO, default value: 0x0           */
    SOC_PETRA_REG_FIELD fail;
  } __ATTRIBUTE_PACKED__ qdr_training_fail_reg;

  /* Output Clock Control: This register controls the C clock       */
  /* operation mode and delay relative to K clock                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a0 */

     /* CcnDelSel: These bits control the C to K clock delay         */
     /* select. It allows creating a phase between write             */
     /* commands and read replies to improve the electrical          */
     /* performance of the device.                                   */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ccn_del_sel;

     /* Qdr3Mode: Select the QDR operation mode. 1'b0 is for         */
     /* QDR2 mode, 1'b1 is for QDR3 mode. In Qdr3 Mode the C         */
     /* clock is used as reset to the QDR.                           */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr3_mode;

     /* Qdr3Rst: Writing 1 puts QDR3 device into reset. Applys       */
     /* only when Qdr3Mode is set to 1'b1.                           */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD qdr3_rst;

  } __ATTRIBUTE_PACKED__ output_clock_control_reg;

  /* Dll Updtate Counter: The QDR DLL requires a periodic DLL       */
  /* update interval. This register sets the QDR DLL Update         */
  /* timeout counter. Note that a low value in this counter         */
  /* can harm the device bandwidth performance.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a1 */

     /* DllUpdtCnt: Number of Qdr clock cycles between each DLL      */
     /* update                                                       */
     /* range: 31:0, access type: RW, default value: 32'h200000      */
     SOC_PETRA_REG_FIELD dll_updt_cnt;

  } __ATTRIBUTE_PACKED__ dll_updtate_counter_reg;

  /* Periodic Training Counter: The QDR DLL requires a              */
  /* periodic training sequence, mainly to compensate for           */
  /* temperature-caused changes. This register sets the QDR         */
  /* training timeout counter. Note that a low value in this        */
  /* counter can harm the device bandwidth performance.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a2 */

     /* PrdTrnCnt: Number of Dll update cycles between each          */
     /* Periodic training. If DllUpdtEn is disabled, will still      */
     /* use the DllUpdCnt. The number of QDR clock cycles            */
     /* between each training sequence is DllUpdCnt*PrdTrnCnt        */
     /* range: 31:0, access type: RW, default value: 0xe000          */
     SOC_PETRA_REG_FIELD prd_trn_cnt;

  } __ATTRIBUTE_PACKED__ periodic_training_counter_reg;

  /* Periodic Enable: This register enables DLL update and          */
  /* QDR phy training sequences. If either one is not               */
  /* enabled, the internal machines will maintain their             */
  /* previous values. Note that a training sequence can be          */
  /* internally triggered by the device regardless the              */
  /* setting of this register, if a fatal phy state is              */
  /* detected.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a3 */

     /* DllUpdtEn: Enables periodic DLL update.                      */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dll_updt_en;

     /* PrdTrnEn: Enables periodic phy training                      */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD prd_trn_en;

  } __ATTRIBUTE_PACKED__ periodic_enable_reg;

  /* Qdr Cq Edge Select: Select CQ sampling edge. Different         */
  /* QDR vendor datasheets point to different edge as the           */
  /* first sampling edge for returning data - either CQ             */
  /* rising edge or CQn rising edge. This register allows           */
  /* selecting with which edge to work.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a4 */

     /* CqEdgeSel: Selects the CQ edge with the first burst of       */
     /* data. If set - CQ, otherwise - CQn.                          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cq_edge_sel;

  } __ATTRIBUTE_PACKED__ qdr_cq_edge_select_reg;

  /* Dll Control: This register controls various parameters         */
  /* of the QDR's phy DLL.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a5 */

     /* DllDiv2En: Divide master word by 2, if reset, divided by     */
     /* 4 by default                                                 */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dll_div2_en;

     /* DllUpdateSingle: Assert this signal to allow a single        */
     /* update to the DLL (Does not have to be in override mode)     */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dll_update_single;

     SOC_PETRA_REG_FIELD dll_slave_override_en;

     /* DllReady: Dll ready indication                               */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD dll_ready;

  } __ATTRIBUTE_PACKED__ dll_control_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_QDR_REGS;
/* Block definition: IPS */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0200 */

     /* DqcqDepthOvf: If set, then total depth configured to         */
     /* DQCQs is over 2432. This interrupt is cleared only after     */
     /* DQCQ depth is fixed.                                         */
     /* range: 0:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD dqcq_depth_ovf;

     /* EmptyDqcqWrite: If set, logic tried to write to a DQCQ       */
     /* with depth 0. This interrupt is cleared when EmptyDqcqId     */
     /* is read.                                                     */
     /* range: 1:1, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD empty_dqcq_write;

     /* QueueEnteredDel: A queue entered the delete state. This      */
     /* interrupt is cleared after DelQueueNumber register is        */
     /* read.                                                        */
     /* range: 2:2, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD queue_entered_del;

     /* CreditLost: The IPS might lose credit if one of the          */
     /* following situations occur: 1) When queue DQCQ is full,      */
     /* and a credit is received that triggers a write to full       */
     /* DQCQ. The credit is dropped. 2) When a credit is to be       */
     /* returned to the SCH, but the FMS is not ready, the           */
     /* credit is lost. Interrupt is cleared after                   */
     /* LostCreditQueueNum is read.                                  */
     /* range: 3:3, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD credit_lost;

     /* CreditOverflow: A queue's credit balance overflowed.         */
     /* Credit received cause the credit balance to exceed           */
     /* (32K-1) credit bytes. If this happens, the credit            */
     /* balance wil become stuck at (32K-1). Interrupt is            */
     /* cleared after CreditOverflowQueueNum is read.                */
     /* range: 4:4, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD credit_overflow;

     /* DeqCommandTimeout: A DEQ command was sent to the IQM but     */
     /* a DEQ report was not received in DeqCmdTimeout clocks.       */
     /* Interrupt is cleared after DeqCmdTimeoutQueueNum is read     */
     /* range: 5:5, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD deq_command_timeout;

     /* DqcqOverflow: If set, the DQCQ encountered a write to a      */
     /* full DQCQ. Cleared when OverflowDqcqId is read.              */
     /* range: 6:6, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD dqcq_overflow;

     /* PushQueueActive: If set, device has an active push           */
     /* queue. Cleared when ActivePushQueueId is read. User          */
     /* should mask this register if push queues are used in the     */
     /* system.                                                      */
     /* range: 7:7, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD push_queue_active;

     /* QdescEccErr: ECC error detected in qdesc table               */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdesc_ecc_err;

     /* QdescEccOneErrFixed:                                         */
     /* range: 27:27, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdesc_ecc_one_err_fixed;

     /* DqcqmemEccErr: ECC error detected in dqcqmem table           */
     /* range: 28:28, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcqmem_ecc_err;

     /* DqcqmemEccOneErrFixed:                                       */
     /* range: 29:29, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcqmem_ecc_one_err_fixed;

     /* FsmrqmemEccErr: ECC error detected in fsmrqmem table         */
     /* range: 30:30, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrqmem_ecc_err;

     /* FsmrqmemEccOneErrFixed:                                      */
     /* range: 31:31, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrqmem_ecc_one_err_fixed;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0210 */

     /* DqcqDepthOvfMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dqcq_depth_ovf_mask;

     /* EmptyDqcqWriteMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD empty_dqcq_write_mask;

     /* QueueEnteredDelMask: Writing 0 masks the corresponding       */
     /* interrupt source                                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD queue_entered_del_mask;

     /* CreditLostMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD credit_lost_mask;

     /* CreditOverflowMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD credit_overflow_mask;

     /* DeqCommandTimeoutMask: Writing 0 masks the corresponding     */
     /* interrupt source                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD deq_command_timeout_mask;

     /* DqcqOverflowMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dqcq_overflow_mask;

     /* PushQueueActiveMask: Writing 0 masks the corresponding       */
     /* interrupt source                                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD push_queue_active_mask;

     /* QdescEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdesc_ecc_err_mask;

     /* QdescEccOneErrFixedMask: Writing 0 masks the                 */
     /* corresponding interrupt source                               */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdesc_ecc_one_err_fixed_mask;

     /* DqcqmemEccErrMask: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcqmem_ecc_err_mask;

     /* DqcqmemEccOneErrFixedMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcqmem_ecc_one_err_fixed_mask;

     /* FsmrqmemEccErrMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrqmem_ecc_err_mask;

     /* FsmrqmemEccOneErrFixedMask: Writing 0 masks the              */
     /* corresponding interrupt source                               */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrqmem_ecc_one_err_fixed_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0220 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_IPS_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0230 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_IPS_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0240 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically set          */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address-             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0241 */

     /* IndirectCommandAddr: Indirect access address- Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0:          */
     /* Write operation. 1: Read operation.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0242 */

     /* IndirectCommandDataIncrement:                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_IPS_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* ECC Configuration register: This register is used for          */
  /* configuring IPS ECC                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0260 */

     /* DisEcc: If set, disables the ECC mechanism in the block.     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_ecc;

  } __ATTRIBUTE_PACKED__ ecc_configuration_reg;

  /* Ips General Configurations: General configurations and         */
  /* enables of the IPS                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0300 */

     /* DiscardAllIQMMsg: If set, the IPS discards all IQM           */
     /* reports (ENQ and DEQ).                                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD discard_all_iqmmsg;

     /* DiscardAllCrdt: If set, the IPS discards all incoming        */
     /* credits from FCR. Note: Auto credits can still be            */
     /* processed                                                    */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD discard_all_crdt;

     /* DisableStatusMsgGen: If set, the IPS will not generate       */
     /* status messages towards the SCH.                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD disable_status_msg_gen;

     /* DisableCreditSurplus: If set, the IPS will not return        */
     /* unused credits to the originating port scheduler. Note:      */
     /* Only full unused credits are returned.                       */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD disable_credit_surplus;

     /* DisSingleDelDeqCmd: If set, the IPS can send more than       */
     /* one delete DEQ command to the IQM. Otherwise, the IPS        */
     /* can send only one delete DEQ command to the IQM until a      */
     /* DEQ report is received.                                      */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_single_del_deq_cmd;

     /* FmcCreditsFromSch: If set, the IPS sends the FMC credits     */
     /* generated by it to be distributed by SCH. Otherwise, the     */
     /* IPS FMC credit generator distributes the credits to the      */
     /* relevant queues. If more than one queue is assigned to a     */
     /* FMC class, this bit should be asserted.                      */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fmc_credits_from_sch;

     /* DisOffSendAfterDeq: If set, the IPS will not send OFF        */
     /* message after a DEQ report when the credit balance is        */
     /* positive (next credit will). Otherwise, the IPS may send     */
     /* OFF messages after DEQ report processing if credit           */
     /* balance is still positive.                                   */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_off_send_after_deq;

     /* SendFsmOnCredit: If set, the IPS will send a flow            */
     /* status-message for every credit received. Otherwise,         */
     /* flow status messages will be sent upon CRS change.           */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD send_fsm_on_credit;

     /* SendNoChgOnCredit: This is bit is valid only when            */
     /* SendFsmOnCredit is set. If set, the IPS will send a          */
     /* NO-CHANGE flow-status message for every credit (unless a     */
     /* real flow status is needed). Otherwise, flow status          */
     /* messages with queue's current CRS will be sent. This is      */
     /* useful for systems using System RED feature.                 */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD send_no_chg_on_credit;

     /* SendFsmForBiggerMaxQueueSize: If set, the IPS will send      */
     /* a flow-status message when the maximum queue size            */
     /* received on an incoming credit is smaller than the           */
     /* actual that queue size should be reported for this           */
     /* queue.                                                       */
     /* range: 9:9, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD send_fsm_for_bigger_max_queue_size;

     /* SendFsmForMulCrossDown: If set, the IPS will send a          */
     /* flow-status message when the queue size crosses FsmThMul     */
     /* down as well as on the up direction. Otherwise, messages     */
     /* will only be sent when queue size crosses FsmThMul up.       */
     /* This is useful for systems using System RED feature.         */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD send_fsm_for_mul_cross_down;

     /* UpdateMaxQszFromLocal: If set, and the 4b queue size         */
     /* from the IQM is bigger the 4b queue size received from       */
     /* the SCH, the IPS will update the IQM value to the            */
     /* maximum queue size table; otherwise the SCH value will       */
     /* always be used.                                              */
     /* range: 11:11, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD update_max_qsz_from_local;

     /* DisAutoCreditSendMsg: If set, the IPS will not send          */
     /* flow-status message to the SCH after an auto credit          */
     /* processing.                                                  */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dis_auto_credit_send_msg;

     /* EnIntLpDqcqFc: If set, the internal low prioirty DQCQ        */
     /* flow control is enabled. When a HP priority queue size       */
     /* crosses IntLpDqcqFcSetTh, a flow control bit is asserted     */
     /* preventing DEQ commands for low-priority queues from         */
     /* being sent, until IntLpDqcqFcResetTh is crossed down by      */
     /* the asserting queue.                                         */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD en_int_lp_dqcq_fc;

     /* DisDeqCmds: If set, the IPS will not send DEQ commands.      */
     /* Note: This should be used for debug purposes only!           */
     /* range: 14:14, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD dis_deq_cmds;

     /* DiscardCredits: If set, the IPS will reject credits          */
     /* coming from FCR according to queue number filter             */
     /* configuration.                                               */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD discard_credits;

     /* GtimerEnable: Whether to use all the counters in gtimer      */
     /* mode or read on clear                                        */
     /* range: 27:27, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD gtimer_enable;

     /* IpsInitTrigger: When IpsInit==1, the IPS performs its        */
     /* 32K cycles initialization. The IPS init is triggered by      */
     /* a signal from ECI (IPS INIT). All IPS logic is reset,        */
     /* except for the configuration registers and static            */
     /* tables. Tables initialized: - Queue descriptor table -       */
     /* Queue size table - Fsmrq Control table memory - System       */
     /* RED maximum queue size table                                 */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ips_init_trigger;

  } __ATTRIBUTE_PACKED__ ips_general_configurations_reg;

  /* Ips Credit Config: General configurations and enables of       */
  /* the IPS                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0301 */

     /* CreditValue: Credit Value in 1B resolution.                  */
     /* range: 12:0, access type: RW, default value: 0x200           */
     SOC_PETRA_REG_FIELD credit_value;

     /* UseRandomCrBal: Must be set to 0.                            */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD use_random_cr_bal;

  } __ATTRIBUTE_PACKED__ ips_credit_config_reg;

  /* Auto Credit Mechanism Queue Boundaries: This registers         */
  /* contains the needed configurations for the auto credit         */
  /* mechanism.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0304 */

     /* AutoCrFrstQue: The number of the first queue (in a           */
     /* continuous cyclic segment of queues) to generate an auto     */
     /* credit                                                       */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD auto_cr_frst_que;

     /* AutoCrLastQue: The number of the last queue (in a            */
     /* continuous cyclic segment of queues) to generate an auto     */
     /* credit                                                       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD auto_cr_last_que;

  } __ATTRIBUTE_PACKED__ auto_credit_mechanism_queue_boundaries_reg;

  /* Auto Credit Mechanism Rate Configuration:                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0305 */

     /* AutoCrRate: Determine the rate (in FAP core clocks) of       */
     /* generating auto credits to 1<<(AutoCrRate+3). A value of     */
     /* 0 disables the Auto generation.                              */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD auto_cr_rate;

  } __ATTRIBUTE_PACKED__ auto_credit_mechanism_rate_configuration_reg;

  /* High Priority Dqcq Depth Config1: Sets the FIFO depth          */
  /* for the DQCQs. Note: Total for all DQCQs should not             */
  /* exceed 2432. In Mesh mode, we have 3 HPs and 8 LPs,            */
  /* while in Fabric mode we have 4 HPs and 3 LPs. Value of 0        */
  /* means DQCQ not in use, otherwise minimum value shuld be        */
  /* 32.                                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0306 */

     /* DelDepth: FIFO depth for Delete DQCQ                         */
     /* range: 11:0, access type: RW, default value: 0x80            */
     SOC_PETRA_REG_FIELD del_depth;

     /* IsDepth: FIFO depth for Ingress shape DQCQ                   */
     /* range: 27:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD is_depth;

  } __ATTRIBUTE_PACKED__ high_priority_dqcq_depth_config1_reg;

  /* High Priority Dqcq Depth Config2: Sets the FIFO depth          */
  /* for the DQCQs. Note: Total for all DQCQs should not             */
  /* exceed 2432. In Mesh mode, we have 3 HPs and 8 LPs,            */
  /* while in Fabric mode we have 4 HPs and 3 LPs. Value of 0        */
  /* means DQCQ not in use, otherwise minimum value shuld be        */
  /* 32.                                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0307 */

     /* LowDelayDepth: FIFO depth for low delay DQCQ                 */
     /* range: 11:0, access type: RW, default value: 0x80            */
     SOC_PETRA_REG_FIELD low_delay_depth;

  } __ATTRIBUTE_PACKED__ high_priority_dqcq_depth_config2_reg;

  /* Low Priority Dqcq Depth Config1: Sets the FIFO depth for       */
  /* the DQCQs. Note: Total for all DQCQs should not exceed          */
  /* 2432. In Mesh mode, we have 3 HPs and 8 LPs, while in          */
  /* Fabric mode we have 4 HPs and 3 LPs. Value of 0 means           */
  /* DQCQ not in use, otherwise minimum value shuld be 32.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0308 */

     /* Dest0Depth: FIFO depth for DQCQ of destination 0 in mesh     */
     /* mode. In Clos fabric mode, this is Local route DQCQ          */
     /* range: 11:0, access type: RW, default value: 0x100           */
     SOC_PETRA_REG_FIELD dest0_depth;

     /* Dest1Depth: FIFO depth for DQCQ of destination 1 in mesh     */
     /* mode. In Clos fabric mode, this is guaranteed fabric         */
     /* multicast DQCQ.                                              */
     /* range: 27:16, access type: RW, default value: 0x100          */
     SOC_PETRA_REG_FIELD dest1_depth;

  } __ATTRIBUTE_PACKED__ low_priority_dqcq_depth_config1_reg;

  /* Low Priority Dqcq Depth Config2: Sets the FIFO depth for       */
  /* the DQCQs. Note: Total for all DQCQs should not exceed          */
  /* 2432. In Mesh mode, we have 3 HPs and 8 LPs, while in          */
  /* Fabric mode we have 4 HPs and 3 LPs. Value of 0 means           */
  /* DQCQ not in use, otherwise minimum value shuld be 32.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0309 */

     /* Dest2Depth: FIFO depth for DQCQ of destination 2 in mesh     */
     /* mode. In Clos fabric mode, this is best effort fabric        */
     /* multicast DQCQ.                                              */
     /* range: 11:0, access type: RW, default value: 0x100           */
     SOC_PETRA_REG_FIELD dest2_depth;

     /* Dest3Depth: FIFO depth for DQCQ of destination 3 in mesh     */
     /* mode. In Clos fabric mode, this is fabric (other             */
     /* destinations) DQCQ.                                          */
     /* range: 27:16, access type: RW, default value: 0x100          */
     SOC_PETRA_REG_FIELD dest3_depth;

  } __ATTRIBUTE_PACKED__ low_priority_dqcq_depth_config2_reg;

  /* Low Priority Dqcq Depth Config3: Sets the FIFO depth for       */
  /* the DQCQs. Note: Total for all DQCQs should not exceed          */
  /* 2432. In Mesh mode, we have 3 HPs and 8 LPs, while in          */
  /* Fabric mode we have 4 HPs and 3 LPs. Value of 0 means           */
  /* DQCQ not in use, otherwise minimum value shuld be 32.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030a */

     /* Dest4Depth: FIFO depth for DQCQ of destination 4 in mesh     */
     /* mode.                                                        */
     /* range: 11:0, access type: RW, default value: 0x100           */
     SOC_PETRA_REG_FIELD dest4_depth;

     /* Dest5Depth: FIFO depth for DQCQ of destination 5 in mesh     */
     /* mode.                                                        */
     /* range: 27:16, access type: RW, default value: 0x100          */
     SOC_PETRA_REG_FIELD dest5_depth;

  } __ATTRIBUTE_PACKED__ low_priority_dqcq_depth_config3_reg;

  /* Low Priority Dqcq Depth Config4: Sets the FIFO depth for       */
  /* the DQCQs. Note: Total for all DQCQs should not exceed          */
  /* 2432. In Mesh mode, we have 3 HPs and 8 LPs, while in          */
  /* Fabric mode we have 4 HPs and 3 LPs. Value of 0 means           */
  /* DQCQ not in use, otherwise minimum value shuld be 32.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030b */

     /* Dest6Depth: FIFO depth for DQCQ of destination 6 in mesh     */
     /* mode.                                                        */
     /* range: 11:0, access type: RW, default value: 0x100           */
     SOC_PETRA_REG_FIELD dest6_depth;

     /* Dest7Depth: FIFO depth for DQCQ of destination 7 in mesh     */
     /* mode.                                                        */
     /* range: 27:16, access type: RW, default value: `IPS_DEPTH7    */
     SOC_PETRA_REG_FIELD dest7_depth;

  } __ATTRIBUTE_PACKED__ low_priority_dqcq_depth_config4_reg;

  /* Fmc Credit Flow Control Threshold: When a Fabric MC DQCQ       */
  /* is over a configured threshold, a credit flow-control          */
  /* indication is sent to relevant credit generator. The           */
  /* flow control is released when the DQCQ is below the            */
  /* reset threshold.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030c */

     /* FmcCrdtFcSet: When DQCQ crosses this threshold from          */
     /* above, credit flow control is set.                           */
     /* range: 11:0, access type: RW, default value: 0x80            */
     SOC_PETRA_REG_FIELD fmc_crdt_fc_set;

     /* FmcCrdtFcReset: When DQCQ crosses this threshold from        */
     /* below, credit flow control is reset.                         */
     /* range: 27:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD fmc_crdt_fc_reset;

  } __ATTRIBUTE_PACKED__ fmc_credit_flow_control_threshold_reg;

  /* Ipt Flow-Control Configuration: IPT flow control usage         */
  /* in IPS configurations.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030d */

     /* IptHpFcMask: The IPT sends the IPS flow control per          */
     /* context, per high and low priority. The IPS has only one     */
     /* high priority DQCQ, so all the flow-control bits are         */
     /* ORed, and masked by this register. A de-asserted bit         */
     /* masks the relevant flow control. Note: In Clos fabric        */
     /* mode, only the lower two bits are used. One bit per high     */
     /* priority context in the IPT.                                 */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ipt_hp_fc_mask;

     /* GfmcFcMap: Used to control which IPT flow control            */
     /* indications wil stop the GFMC credit generator.              */
     /* range: 11:8, access type: RW, default value: 0x8             */
     SOC_PETRA_REG_FIELD gfmc_fc_map;

     /* Bfmc2FcMap: Used to control which IPT flow control           */
     /* indications wil stop the BFMC2 credit generator.             */
     /* range: 15:12, access type: RW, default value: 0xc            */
     SOC_PETRA_REG_FIELD bfmc2_fc_map;

     /* Bfmc1FcMap: Used to control which IPT flow control           */
     /* indications wil stop the BFMC1 credit generator.             */
     /* range: 19:16, access type: RW, default value: 0xa            */
     SOC_PETRA_REG_FIELD bfmc1_fc_map;

     /* Bfmc0FcMap: Used to control which IPT flow control           */
     /* indications wil stop the BFMC0 credit generator.             */
     /* range: 23:20, access type: RW, default value: 0x9            */
     SOC_PETRA_REG_FIELD bfmc0_fc_map;

     /* IptHpFcStopLp: If set, the IPT flow control from the         */
     /* high priority contexts will stop the low priority DQCQ       */
     /* as well.                                                     */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ipt_hp_fc_stop_lp;

  } __ATTRIBUTE_PACKED__ ipt_flow_control_configuration_reg;

  /* Fmc Scheduler Configs: Controls the overall rate               */
  /* generated for the FMC (Fabric MultiCast) queues                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030e */

     /* FmcMaxCrRate: The FMC credit generator generates credit      */
     /* every ((FmcMaxCrRate+102) /8) clocks. Value of 0             */
     /* disables the generator.                                      */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fmc_max_cr_rate;

     /* FmcMaxBurst: The maximum number of credits the generator     */
     /* can hold.                                                    */
     /* range: 31:26, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fmc_max_burst;

  } __ATTRIBUTE_PACKED__ fmc_scheduler_configs_reg;

  /* Gfmc Shaper Configs: Controls the credit shaper for GFMC       */
  /* (Guaranteed FMC). When IPS distributes the credits, queue       */
  /* 0 is the GFMC queue (class 0).                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030f */

     /* GfmcMaxCrRate: The maximum gap between two GMFC credits      */
     /* is ((GfmcMaxCrRate+102) /8) clocks. Value of 0 disables      */
     /* the shaper (credits may still be sent to GFMC according      */
     /* to strict priority over BFMC).                               */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD gfmc_max_cr_rate;

     /* GfmcMaxBurst: The maximum number of credits the              */
     /* generator can hold when GFMC credits are not needed.         */
     /* range: 31:26, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD gfmc_max_burst;

  } __ATTRIBUTE_PACKED__ gfmc_shaper_configs_reg;

  /* Bfmc Shaper Configs: Controls the credit shaper for BFMC       */
  /* (Best-effort FMC). When IPS distributes the credits,            */
  /* queue 1-3 are BFMC queues (class 1 is associated with          */
  /* queue 1, etc.)                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0310 */

     /* BfmcMaxCrRate: The maximum gap between two BMFC credits      */
     /* is (BfmcMaxCrRate+102) 1/8th clocks. Value of 0 disables     */
     /* the shaper (credits may still be sent to BFMC).              */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bfmc_max_cr_rate;

     /* BfmcMaxBurst: The maximum number of credits the              */
     /* generator can hold when BFMC credits are not needed.         */
     /* range: 31:26, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD bfmc_max_burst;

  } __ATTRIBUTE_PACKED__ bfmc_shaper_configs_reg;

  /* Bfmc Class Configs: Controls the distribution of credits       */
  /* between BFMC classes. Weight configurations:* Lower value       */
  /* means better priority, 1 is the highest priority.* A           */
  /* class rate is distributed according                            */
  /* to:(1/Wx)/((1/W1)+(1/W2)+(1/W3))* Value of 0 to any of         */
  /* the weight disables the relevant class from receiving          */
  /* credits.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0311 */

     /* BFMC class 2 weight for WFQ                                  */
     /* BFMC class 3 weight for WFQ                                  */
     /* BFMC class 4 weight for WFQ                                  */
     /* range: 4:0, access type: RW, default value: 0x0              */
     /* range: 12:8, access type: RW, default value: 0x0             */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bfmc_class_w[SOC_PETRA_NOF_MULTICAST_CLASSES - 1];

     /* BfmcWfqEn: If set, credits for BFMC are distributed          */
     /* according to WFQ; otherwise, according to SP by class.       */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bfmc_wfq_en;

  } __ATTRIBUTE_PACKED__ bfmc_class_configs_reg;

  /* Ingress Shape Scheduler Config: Controls the rate for          */
  /* Ingress shape credits. Note: Ingress Shape credit are           */
  /* distributed by the SCH.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0312 */

     /* IssMaxCrRate: The IS credit generator generates credit       */
     /* every ((IssMaxCrRate+102) /8) clocks. Value of 0             */
     /* disables the generator.                                      */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD iss_max_cr_rate;

  } __ATTRIBUTE_PACKED__ ingress_shape_scheduler_config_reg;

  /* Credit Watchdog Queue Boundaries: Queue boundaries to be       */
  /* scanned by a credit watchdog. The watchdog scans between       */
  /* the bottom queue and top queue in cyclic manner, at a          */
  /* minimum rate.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0313 */

     /* CrWdBottomQ: Bottom queue for credit watchdog                */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cr_wd_bottom_q;

     /* CrWdTopQ: Top queue for credit watchdog                      */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cr_wd_top_q;

  } __ATTRIBUTE_PACKED__ credit_watchdog_queue_boundaries_reg;

  /* Credit Watchdog Configuration: This registers holds            */
  /* credit watchdog configurations, rate and message               */
  /* generation control. The credit watchdog has a given             */
  /* minimum scan rate between the top and bottom queues. The       */
  /* scan time can be longer if the watchdog access is              */
  /* restrained by other events. If many queues need to be          */
  /* serviced by the credit watchdog, then it is restrained         */
  /* by its own flow status generation limit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0314 */

     /* CrWdMaxFlowMsgGenRate: Defines the period in clocks in       */
     /* which a token bucket is incremented. '0' disables the        */
     /* shaper mechanism, meaning the credit watchdog may send       */
     /* as many messages as it can.                                  */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cr_wd_max_flow_msg_gen_rate;

     /* CrWdMaxFlowMsgGenBurstSize: The maximum size of the          */
     /* token bucket.                                                */
     /* range: 15:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD cr_wd_max_flow_msg_gen_burst_size;

     /* CrWdMinScanCyclePeriod: The minimum number of clocks         */
     /* that must elapse between full scans, in clocks, is           */
     /* CrWDMinScanCyclePeriod * 256. Value of 0 disables the        */
     /* watchdog.                                                    */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cr_wd_min_scan_cycle_period;

     /* CrWdGenOffMsgs: If set, credit watchdog will generate        */
     /* OFF messages for queues; otherwise, the credit watchdog      */
     /* will only generate ON (SLOW and NORM) messages.              */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cr_wd_gen_off_msgs;

  } __ATTRIBUTE_PACKED__ credit_watchdog_configuration_reg;

  /* Fsm On Message Shaper: This register controls the rate         */
  /* limit shaper for ON messages (SLOW and NORM) from the          */
  /* FSRMQ.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0315 */

     /* FsmMaxRate: The number of clocks passed between two          */
     /* consecutive ON messages. Value of '0' disables the rate      */
     /* limiting shaper.                                             */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsm_max_rate;

     /* FsmMaxBurst: The maximum number of consecutive messages      */
     /* (burst) allowed.                                             */
     /* range: 20:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fsm_max_burst;

     /* ShaperLowPri: If set, the shaper works on low priority       */
     /* FSMRQ alone; otherwise, the shaper limits both high and      */
     /* low priority.                                                */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD shaper_low_pri;

  } __ATTRIBUTE_PACKED__ fsm_on_message_shaper_reg;

  /* Fms Parameters: Set of parameters to control the flow          */
  /* message shaper behaviour                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0316 */

     /* bypassShaper: If set, no messages will be delayed in the     */
     /* FMS.                                                         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bypass_shaper;

     /* DisableSlowDelay: If set, the FMS will not delay NORM        */
     /* after SLOW messages.                                         */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD disable_slow_delay;

     /* LocalRouteBypass: If set, local route messages will          */
     /* bypass the FMS.                                              */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD local_route_bypass;

     /* MinDly: The minimum allowable amount of FMS time clock       */
     /* units (64 core clocks, ~256ns at 250MHz clock) between       */
     /* OFF->ON and SLOW->NORM messages. Default is 8 (~2048ns).     */
     /* range: 8:4, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD min_dly;

     /* TimeScale: The FMS internal clock in core clocks units.      */
     /* 00 - 64 core clocks. 01 - 128 core clocks. 10 - 192 core     */
     /* clocks. 11 - 256 core clocks.                                */
     /* range: 13:12, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD time_scale;

  } __ATTRIBUTE_PACKED__ fms_parameters_reg;

  /* System Red Aging Configuration: Configures the aging           */
  /* period for system RED maximum queue size. When the             */
  /* maximum queue size for a specific port is aged, it is          */
  /* reset to 0, and the IQM will accept all packets. A value       */
  /* of 0 disables the aging mechanism (only incoming credits       */
  /* will update the table).                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0317 */

     /* SystemRedAgePeriod: Configures the aging period in 16k       */
     /* clocks units. Default value is ~0.5 seconds.                 */
     /* range: 13:0, access type: RW, default value: 0x1e84          */
     SOC_PETRA_REG_FIELD system_red_age_period;

  } __ATTRIBUTE_PACKED__ system_red_aging_configuration_reg;

  /* Interdigitated Mode: Selects (in 1K queue regions) to          */
  /* map queue to flow in an interdigitated manner. Note: Base       */
  /* flow for these queues should be >6144 (flows > 24K).           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0318 */

     /* InterdigitatedMode: Each bit corresponds to a 1K queue       */
     /* region. If bit n is set, queues 1024n to (1024(n+1)-1)       */
     /* are mapped according to: flow_id= SubFlowMode ?              */
     /* \{Base_flow[13:2],qnum[1:0],2'b10\} : \{base_flow[13:1],     */
     /* qnum[1], 1'b1, qnum[0]\} otherwise, queues are mapped        */
     /* according to: flow_id= SubFlowMode ?                         */
     /* \{Base_flow[13:1],qnum[1:0],1'b0\} : \{base_flow[13:0],      */
     /* qnum[1:0]\}                                                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD interdigitated_mode;

  } __ATTRIBUTE_PACKED__ interdigitated_mode_reg;

  /* Int Lp Dqcq Fc Config: Configures the relevant                 */
  /* thresholds for internal low priority DQCQ flow                 */
  /* control. Thrshold is given in 16B resolution.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0319 */

     /* IntLpDqcqFcSetTh: When crossed up and internal flow          */
     /* control is enabled, low priority DQCQ flow control is        */
     /* asserted.                                                    */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD int_lp_dqcq_fc_set_th;

     /* IntLpDqcqFcResetTh: When crossed down and internal flow      */
     /* control is asserted, low priority DQCQ flow control is       */
     /* cleared.                                                     */
     /* range: 29:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD int_lp_dqcq_fc_reset_th;

  } __ATTRIBUTE_PACKED__ int_lp_dqcq_fc_config_reg;

  /* Stored Credits Usage Configuration: The following              */
  /* register configures the usage of stored credits by the         */
  /* IPS. Stored credits are used when a new packet is               */
  /* received at a queue with credit balance bigger than the        */
  /* queue size, and the CRS is still OFF.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x031a */

     /* MulPktDeq: One bit per IPS queue type. If the relevant       */
     /* bit is set, the IPS may send up to MulPktDeqBytes on a       */
     /* DEQ command for queue using the stored credits.              */
     /* Otherwise only a single packet is allowed to be sent         */
     /* when using stored credits.                                   */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mul_pkt_deq;

     /* MulPktDeqBytes: The value, in 64B resolution, of the         */
     /* command bytes to send on a DEQ command for a queue using     */
     /* stored credits and its queue type MulPktDeq bit is set.      */
     /* A value of 0 means only a single packet is allowed to be     */
     /* sent.                                                        */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mul_pkt_deq_bytes;

  } __ATTRIBUTE_PACKED__ stored_credits_usage_configuration_reg;

  /* Deq Command Timeout Configuration: The following               */
  /* register holds the timeout value for the DEQ command           */
  /* timeout interrupt                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x031b */

     /* DeqCmdTimeoutTime: Value in clock ticks for DEQ command      */
     /* timeout. The mechanism is counts DEQ command sent to the     */
     /* IQM. If at a configurable time that the IPS didn't           */
     /* receive a DEQ report, an interrupt is asserted to signal     */
     /* DEQ command timeout. Value of 0 disables the timeout.        */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD deq_cmd_timeout_time;

  } __ATTRIBUTE_PACKED__ deq_command_timeout_configuration_reg;

  /* Push Queue Types Config: The following register holds          */
  /* the push queue type configuration. Push queue means that        */
  /* no credits are needed nor requested for the queue, and         */
  /* whenever an ENQ report is received for the queue, if           */
  /* applicable, the IPS will issue a DEQ command. The Deq          */
  /* command bytes are according to the configuration.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x031c */

     /* PushQueueType: Queue type to act as push queue type.         */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD push_queue_type;

     /* PushQueueWdDelEn: If set, the credit watchdog can issue      */
     /* events for the relevant queue, as well as delete. It is      */
     /* assumed that when using this configuration, a SCH flow       */
     /* will send 'keep-alive' credits to the push queue             */
     /* regardless of its state.                                     */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD push_queue_wd_del_en;

     /* PushQueueTypeEn: If set, queue type value PushQueueType      */
     /* disregards all THs and acta as a push queue type.            */
     /* Otherwise queue type is used as others.                      */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD push_queue_type_en;

     /* PushQueueCmdBytes: The value, in 64B resolution, of the      */
     /* command bytes to send on a DEQ command for a Push queue      */
     /* if PushQueueCmdBytesEn is set. A value of 0 means only a     */
     /* single packet is allowed to be sent.                         */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD push_queue_cmd_bytes;

     /* PushQueueCmdBytesEn: If set, a push queue max DEQ            */
     /* command bytes value is taken from PushQueueCmdBytes          */
     /* configuration. Otherwise the current MaxDeqCmdBytes is       */
     /* used.                                                        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD push_queue_cmd_bytes_en;

  } __ATTRIBUTE_PACKED__ push_queue_types_config_reg;

  /* Is Credit Flow Control Threshold: When the                     */
  /* ingress-shaping DQCQ is over a configured threshold, a         */
  /* credit flow-control indication is sent to relevant             */
  /* credit generator. The flow control is released when the        */
  /* DQCQ is below the reset threshold.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0321 */

     /* IsCrdtFcSet: When DQCQ crosses this threshold from           */
     /* above, credit flow control is set.                           */
     /* range: 11:0, access type: RW, default value: 0x80            */
     SOC_PETRA_REG_FIELD is_crdt_fc_set;

     /* IsCrdtFcReset: When DQCQ crosses this threshold from         */
     /* below, credit flow control is reset.                         */
     /* range: 27:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD is_crdt_fc_reset;

  } __ATTRIBUTE_PACKED__ is_credit_flow_control_threshold_reg;

  /* Del Queue Number: Holds the queue number and last credit       */
  /* time of last queue that entered the delete state, and          */
  /* the current credit WD time.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0340 */

     /* DelQueueNum: Delete queue number. This register is clear     */
     /* on read.                                                     */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD del_queue_num;

     /* QueueLastCrTime: Last credit watch cycle a credit was        */
     /* received.                                                    */
     /* range: 20:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD queue_last_cr_time;

     /* CurrentWdTime: Current credit watch cycle.                   */
     /* range: 28:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD current_wd_time;

  } __ATTRIBUTE_PACKED__ del_queue_number_reg;

  /* Lost Credit Queue Number: Holds the queue number of the        */
  /* lost credit and queue's DQCQ ID.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0341 */

     /* LostCrQueueNum: Lost credit's queue number. This             */
     /* register is clear on read.                                   */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lost_cr_queue_num;

     /* DqcqId: The relevant DQCQ ID.                                */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_id;

     /* DqcqNrdy: DQCQ was not ready.                                */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_nrdy;

     /* FmsNrdy: FMS was not ready.                                  */
     /* range: 24:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fms_nrdy;

  } __ATTRIBUTE_PACKED__ lost_credit_queue_number_reg;

  /* Credit Overflow Queue Num: Holds the queue number of the       */
  /* queue with an overfloed credit balance.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0342 */

     /* CreditOverflowQueueNum: Holds the queue number of the        */
     /* queue with an overfloed credit balance. This register is     */
     /* clear on read.                                               */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD credit_overflow_queue_num;

  } __ATTRIBUTE_PACKED__ credit_overflow_queue_num_reg;

  /* Deq Cmd Timeout Queue Num: Holds the queue number of the       */
  /* queue whose DEQ command has timed out.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0343 */

     /* DeqCmdTimeoutQueueNum: Holds the queue number of the         */
     /* queue whose DEQ command has timed out. This register is      */
     /* clear on read.                                               */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD deq_cmd_timeout_queue_num;

  } __ATTRIBUTE_PACKED__ deq_cmd_timeout_queue_num_reg;

  /* Empty Dqcq Id: Holds the empty (depth=0) DQCQ the logic        */
  /* tried to write to. Valid only when EmptyDqcqWrite               */
  /* interrupt is asserted.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0344 */

     /* EmptyDqcqId: Holds the empty (depth=0) DQCQ the logic        */
     /* tried to write to. Valid only when EmptyDqcqWrite            */
     /* interrupt is asserted. This register is clear on read.       */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD empty_dqcq_id;

  } __ATTRIBUTE_PACKED__ empty_dqcq_id_reg;

  /* Overflow Dqcq Id: Holds the overflowed DQCQ Id the logic       */
  /* tried to write to. Valid only when DqcqOverflow interrupt       */
  /* is asserted.                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0345 */

     /* OverflowQueueNum: Holds the overflowed queue number the      */
     /* logic tried to write. Valid only when DqcqOverflow           */
     /* interrupt is asserted.                                       */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD overflow_queue_num;

     /* OverflowDqcqId: Holds the overflowed DQCQ Id the logic       */
     /* tried to write to. Valid only when DqcqOverflow              */
     /* interrupt is asserted. This register is clear on read.       */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD overflow_dqcq_id;

  } __ATTRIBUTE_PACKED__ overflow_dqcq_id_reg;

  /* Active Push Queue Id: Holds the active push queue              */
  /* number. Valid only when ActivePushQueue interrupt is            */
  /* asserted.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0346 */

     /* ActivePushQueueNum: Holds the active push queue number.      */
     /* Valid only when ActivePushQueue interrupt is asserted.       */
     /* This register is clear on read.                              */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD active_push_queue_num;

  } __ATTRIBUTE_PACKED__ active_push_queue_id_reg;

  /* Manual Queue Operation: Valid only when EmptyDqcqWrite         */
  /* interrupt is asserted.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0380 */

     /* ManQueueId: Queue number to perform manual operation on.     */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD man_queue_id;

     /* RejectCreditsOnFlush: If set, and flush is triggered,        */
     /* all FCR credits for the flushed queue will be rejected       */
     /* until flush process ends.                                    */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD reject_credits_on_flush;

     /* DeqCmdCr2send: Valid for send packet trigger. Number of      */
     /* bytes to send from the queue, in 64B units. The actual       */
     /* amount of data that will be sent is rounded up to fit a      */
     /* full packet size (of the last packet sent). Value of 0       */
     /* triggers a single packet.                                    */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_cmd_cr2send;

     /* FsValue: Valid for FsTrigger only. If FsOverride is          */
     /* asserted, then the value of the flow status sent after       */
     /* FsTrigger will be FsValue.                                   */
     /* range: 25:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_value;

     /* FsOverride: If set, the value of the flow status sent        */
     /* after FsTrigger will be FsValue. Otherwise, queue's          */
     /* current CRS will be used.                                    */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_override;

     /* DelDqcq: Valid for send packet trigger and flush             */
     /* trigger. If set, queue will be added to delete DQCQ.         */
     /* Otherwise, queue will be added to its defined DQCQ.          */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD del_dqcq;

     /* FsTrigger: If set, a flow-status message will be             */
     /* triggered for ManQueueId, with respect to flow status        */
     /* configuration. The IPS will de-assert this bit once it's     */
     /* ready for another trigger.                                   */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_trigger;

     /* GrantCredit: If set, a single credit will be given to        */
     /* ManQueueId. When the IPS is ready for another trigger,       */
     /* this bit will be negated.                                    */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD grant_credit;

     /* FlushTrigger: If set, a queue flush is triggered. If         */
     /* DelDqcq set, the queue will enter delete mode, and will      */
     /* exit only when queue emptied, or credit arived for the       */
     /* queue. Otherwise, the queue will start sending data to       */
     /* its destination, until queue emptied or this bit is          */
     /* cleared by the user. The IPS will de-assert the bit when     */
     /* it is ready to enter another queue to flush.                 */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flush_trigger;

     /* SendPktTrigger: If set, a packet send is triggered. When     */
     /* the IPS is ready for another trigger, this bit will be       */
     /* negated.                                                     */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD send_pkt_trigger;

  } __ATTRIBUTE_PACKED__ manual_queue_operation_reg;

  /* Timer Configuration:                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0381 */

     /* GtimerCycle: The number of clocks the gtimer will count.     */
     /* range: 30:0, access type: RW, default value: 31'd250000000   */
     SOC_PETRA_REG_FIELD gtimer_cycle;

     /* GtimerResetOnTrigger: If set, the gtimer will output a       */
     /* reset signal when the count begins.                          */
     /* range: 31:31, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD gtimer_reset_on_trigger;

  } __ATTRIBUTE_PACKED__ timer_configuration_reg;

  /* Gtimer Trigger:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0382 */

     /* GtimerTrigger: When this register is written to, the         */
     /* gtimer starts counting. When this register is read, it       */
     /* gives the gtimer status (1= still counting, 0=count is       */
     /* over).                                                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_trigger_reg;

  /* Queue Num Filter: Filter for counters according to queue       */
  /* number.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0383 */

     /* QueueNumFilter: Queue number to filter by. All the           */
     /* applicable counter will count according to:                  */
     /* (event_q_num|QueueNumFilterMask) ==                          */
     /* (QueueNumFilter|QueueNumFilterMask)                          */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD queue_num_filter;

     /* QueueNumFilterMask: As described above.                      */
     /* range: 30:16, access type: RW, default value: 0x7fff         */
     SOC_PETRA_REG_FIELD queue_num_filter_mask;

  } __ATTRIBUTE_PACKED__ queue_num_filter_reg;

  /* Flow Status Filter: Filter for counters according to           */
  /* flow status fields.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0384 */

     /* FsDestPortId: Destination port ID to filter by.              */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fs_dest_port_id;

     /* FsDestDevId: Destination device ID to filter by.             */
     /* range: 18:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fs_dest_dev_id;

     /* FlowStatusFilter: Flow status to filter by.                  */
     /* range: 22:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flow_status_filter;

  } __ATTRIBUTE_PACKED__ flow_status_filter_reg;

  /* Flow Status Filter Mask: Mask for flow status filter           */
  /* fields.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0385 */

     /* FsDestPortIdMask: Destination port ID to filter by.          */
     /* range: 7:0, access type: RW, default value: 0xff             */
     SOC_PETRA_REG_FIELD fs_dest_port_id_mask;

     /* FsDestDevIdMask: Destination device ID to filter by.         */
     /* range: 18:8, access type: RW, default value: 0x7ff           */
     SOC_PETRA_REG_FIELD fs_dest_dev_id_mask;

     /* FlowStatusFilterMask: Flow status to filter by.              */
     /* range: 22:20, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD flow_status_filter_mask;

  } __ATTRIBUTE_PACKED__ flow_status_filter_mask_reg;

  /* Iqm Report Filter: Filter for counters according to IQM        */
  /* report fields.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0386 */

     /* DeqNotEnqFltr: Filter by deq_not_enq bit.                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD deq_not_enq_fltr;

     /* DiscardFltr: Filter by discard bit.                          */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD discard_fltr;

     /* WqupFltr: Filter by wqup bit.                                */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wqup_fltr;

     /* DeqNotEnqFltrMask: Mask filter by deq_not_enq bit.           */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD deq_not_enq_fltr_mask;

     /* DiscardFltrMask: Mask filter by discard bit.                 */
     /* range: 5:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD discard_fltr_mask;

     /* WqupFltrMask: Mask filter by wqup bit.                       */
     /* range: 6:6, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD wqup_fltr_mask;

  } __ATTRIBUTE_PACKED__ iqm_report_filter_reg;

  /* Dqcq Id Filter: Filter by DEQ command variables for DQCQ       */
  /* counters.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0387 */

     /* DqcqIdFilter: Filter by DQCQ ID.                             */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dqcq_id_filter;

     /* DqcqDestPortFilter: Filter by DEQ command destination        */
     /* port.                                                        */
     /* range: 11:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dqcq_dest_port_filter;

     /* DqcqDestDevFilter: Filter by DEQ command destination         */
     /* device.                                                      */
     /* range: 22:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_dest_dev_filter;

     /* DqcqIdFilterEn: Enable filtering by DQCQ ID.                 */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_id_filter_en;

     /* DqcqDestPortFilterEn: Enable filtering by DEQ command        */
     /* destination port.                                            */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_dest_port_filter_en;

     /* DqcqDestDevFilterEn: Enable filtering by DEQ command         */
     /* destination device.                                          */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_dest_dev_filter_en;

  } __ATTRIBUTE_PACKED__ dqcq_id_filter_reg;

  /* Qtype Filter: Filter applicable counters by queue type.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0388 */

     /* QueueTypeFilter: Filter by queue type.                       */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD queue_type_filter;

     /* QueueTypeFilterMask: Mask for queue type filter              */
     /* range: 7:4, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD queue_type_filter_mask;

  } __ATTRIBUTE_PACKED__ qtype_filter_reg;

  /* Fsmrq Max Occupancy: Holds the maximum occupancy in            */
  /* FSMRQ (low priority and high priority)                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a0 */

     /* LpFsmrqMaxOcc: Low-priority fsmrq maximum occupancy.         */
     /* This register is clear on read.                              */
     /* range: 11:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lp_fsmrq_max_occ;

     /* HpFsmrqMaxOcc: High-priority fsmrq maximum occupancy.        */
     /* range: 24:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD hp_fsmrq_max_occ;

  } __ATTRIBUTE_PACKED__ fsmrq_max_occupancy_reg;

  /* Dqcq Max Occupancy Hp: Holds the maximum occupancy in          */
  /* DQCQ (low priority and high priority), and the relevant        */
  /* DQCQ id                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a1 */

     /* HpDqcqMaxOcc: High-priority dqcq maximum occupancy. This     */
     /* register is clear on read.                                   */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD hp_dqcq_max_occ;

     /* HpDqcqMaxOccId: High-priority dqcq maximum occupancy ID.     */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD hp_dqcq_max_occ_id;

  } __ATTRIBUTE_PACKED__ dqcq_max_occupancy_hp_reg;

  /* Dqcq Max Occupancy Lp: Holds the maximum occupancy in          */
  /* DQCQ (low priority and high priority), and the relevant        */
  /* DQCQ id                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a2 */

     /* LpDqcqMaxOcc: Low-priority dqcq maximum occupancy. This      */
     /* register is clear on read.                                   */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lp_dqcq_max_occ;

     /* LpDqcqMaxOccId: Low-priority dqcq maximum occupancy ID.      */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD lp_dqcq_max_occ_id;

  } __ATTRIBUTE_PACKED__ dqcq_max_occupancy_lp_reg;

  /* Active Queue Count: Holds the number of queues with            */
  /* queue size>0                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a3 */

     /* MaxActiveQueueCount: Maximum active queue count (since       */
     /* last read). This register is clear on read.                  */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD max_active_queue_count;

     /* ActiveQueueCount: Instantaneous active queue count.          */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD active_queue_count;

  } __ATTRIBUTE_PACKED__ active_queue_count_reg;

  /* Fms Max Occupancy: Holds the maximum number of bins            */
  /* occupied in the FMS.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a4 */

     /* FmsMaxOccupancy: Last maximum value reached since last       */
     /* read. This register is clear on read.                        */
     /* range: 7:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fms_max_occupancy;

  } __ATTRIBUTE_PACKED__ fms_max_occupancy_reg;

  /* Int Lp Dqcq Fc Status: Holds the status of the internal        */
  /* low-priority DQCQ flow control.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a5 */

     /* LpDqcqQueueId: The queue ID of the high-priority queue       */
     /* which asserted the flow control.                             */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lp_dqcq_queue_id;

     /* LpDqcqQueueSize: The last reported queue size for the        */
     /* queue, in 16B resolution.                                    */
     /* range: 29:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD lp_dqcq_queue_size;

     /* LpDqcqFlowControl: The flow control state.                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD lp_dqcq_flow_control;

  } __ATTRIBUTE_PACKED__ int_lp_dqcq_fc_status_reg;

  /* Fsmrq Delay Counter: Holds the longest delay in clock          */
  /* units found through FSMRQ. Can test for all queues, or by       */
  /* filter. Data is reset when read; hence a new test will         */
  /* be initiated.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a6 */

     /* FsmrqDelayCounter: Holds the longest delay in clock          */
     /* units found through FSMRQ. Can test for all queues, or       */
     /* by filter. Data is reset when read; hence a new test         */
     /* will be initiated. This register is clear on read.           */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsmrq_delay_counter;

     /* FsmrqDelayQueue: Queue to test delay for.                    */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrq_delay_queue;

     /* FsmrqDelayByQueue: If set, delay test will be for            */
     /* FsmrqDelayQueue only. Otherwise, the mechanism will test     */
     /* for queues entering FSMRQ randomly.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrq_delay_by_queue;

  } __ATTRIBUTE_PACKED__ fsmrq_delay_counter_reg;

  /* Fms Delay Counter: Holds the longest delay in clock            */
  /* units found through FMS. Can test for all queues, or by         */
  /* filter. Data is reset when read; hence a new test will         */
  /* be initiated.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a7 */

     /* FmsDelayCounter: Holds the longest delay in clock units      */
     /* found through FMS. Can test for all queues, or by            */
     /* filter. Data is reset when read; hence a new test will       */
     /* be initiated. This register is clear on read.                */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fms_delay_counter;

     /* FmsDelayQueue: Queue to test delay for.                      */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fms_delay_queue;

     /* FmsDelayByQueue: If set, delay test will be for              */
     /* FsmrqDelayQueue only. Otherwise, the mechanism will test     */
     /* for queues entering FSMRQ randomly.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fms_delay_by_queue;

  } __ATTRIBUTE_PACKED__ fms_delay_counter_reg;

  /* Credit Fabric Latency Counter: Holds the longest delay         */
  /* in clock units found between an ON message sent for            */
  /* queue, and a credit received for the queue.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a8 */

     /* CrLtncyCounter: Holds the longest delay in clock units       */
     /* found between an ON message sent for queue, and a credit     */
     /* received for the queue. This register is clear on read.      */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cr_ltncy_counter;

     /* CrLtncyQue: Queue to test delay for.                         */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cr_ltncy_que;

  } __ATTRIBUTE_PACKED__ credit_fabric_latency_counter_reg;

  /* Flow Control Count Select: This registers selects the          */
  /* input for the flow control counter.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a9 */

     /* FcCountSel: 0-15: IPT context flow control 16-19: IPT        */
     /* FMC flow control 20-21: DQCQ FMC flow control 22: DQCQ       */
     /* IS flow control 23: IPS internal LP DQCQ flow control        */
     /* 24: IRR IS flow control                                      */
     /* range: 4:0, access type: RW, default value: 0x19             */
     SOC_PETRA_REG_FIELD fc_count_sel;

  } __ATTRIBUTE_PACKED__ flow_control_count_select_reg;

  /* Capture Queue Descriptor Config: This register                 */
  /* configures the capturing of a queue descriptor. Capturing       */
  /* is always done for a queue defined in the QueueNumFilter       */
  /* (without mask), and according to other configure values        */
  /* in this register. The logic capture the first queue             */
  /* descriptor after the read of the capture register.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03aa */

     /* CaptureCrs: Capture by CRS.                                  */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_crs;

     /* CaptureCrsEn: Enable capturing by CRS.                       */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_crs_en;

     /* CaptureFsmrqCtrl: Capture by FSMRQ control.                  */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_fsmrq_ctrl;

     /* CaptureFsmrqCtrlEn: Enable capturing by FSMRQ control.       */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_fsmrq_ctrl_en;

     /* CaptureInDqcq: Capture by DQCQ.                              */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_in_dqcq;

     /* CaptureInDqcqEn: Enable capturing by DQCQ.                   */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_in_dqcq_en;

     /* CaptureWdDel: Capture by WdDel.                              */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD capture_wd_del;

     /* CaptureWdDelEn: Enable capturing by WdDel.                   */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD capture_wd_del_en;

     /* CaptureOnePktDeq: Capture by One-Pkt-Deq.                    */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD capture_one_pkt_deq;

     /* CaptureOnePktDeqEn: Enable capturing by One-Pkt-Deq.         */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD capture_one_pkt_deq_en;

  } __ATTRIBUTE_PACKED__ capture_queue_descriptor_config_reg;

  /* Capture Queue Descriptor: This register holds the first        */
  /* captured queue descriptor values.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b0 */

     /* CptrdCrBal: Captured credit balance This register is         */
     /* clear on read.                                               */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cptrd_cr_bal;

     /* CptrdQsz: Captured queue size                                */
     /* range: 22:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_qsz;

     /* CptrdCrs: Captured CRS                                       */
     /* range: 25:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_crs;

     /* CptrdFsmrqCtrl: Captured FSMRQ control                       */
     /* range: 27:26, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_fsmrq_ctrl;

     /* CptrdInDqcq: Captured DQCQ                                   */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_in_dqcq;

     /* CptrdOnePktDeq: Captured One-Pkt-Deq                         */
     /* range: 29:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_one_pkt_deq;

     /* CptrdWdDel: Captured WdDel                                   */
     /* range: 30:30, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_wd_del;

     /* CptrdValid: Indicates values in this register are valid.     */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_valid;

  } __ATTRIBUTE_PACKED__ capture_queue_descriptor_reg;

  /* Max Cr Bal: This register holds the Max value of credit        */
  /* balance seen. Can be filtered by QueueNumFilter (with          */
  /* mask).                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b1 */

     /* MaxCrBal: Max value of credit balance seen. Can be           */
     /* filtered by QueueNumFilter (with mask). This register is     */
     /* clear on read.                                               */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD max_cr_bal;

     /* MaxCrBalQueue: Queue who's credit balance was the Max        */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD max_cr_bal_queue;

  } __ATTRIBUTE_PACKED__ max_cr_bal_reg;

  /* Max Fsmrq Req Queues: Holds the maximum number of queues       */
  /* in state FSMRQ request seen since last read.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b2 */

     /* MaxFsmrqReqQueues: Holds the maximum number of queues in     */
     /* state FSMRQ request seen since last read. This register      */
     /* is clear on read.                                            */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD max_fsmrq_req_queues;

     /* FsmrqReqQueues: Instantaneous fsmrq request count.           */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrq_req_queues;

  } __ATTRIBUTE_PACKED__ max_fsmrq_req_queues_reg;

  /* Max Port Queue Size: Holds the maximum port queue size         */
  /* received since last read from a defined system physical        */
  /* port id.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b3 */

     /* MaxPortQueueSize: Maximum port queue size received since     */
     /* last read from a defined system physical port id. This       */
     /* register is clear on read.                                   */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD max_port_queue_size;

     /* InsPortQueueSize: Instantaneous port queue size.             */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ins_port_queue_size;

     /* MaxPortQueueSizePortId: System Physical Port ID.             */
     /* range: 27:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD max_port_queue_size_port_id;

  } __ATTRIBUTE_PACKED__ max_port_queue_size_reg;

  /* Time In Slow: This register holds the clock count the          */
  /* queue defined in QueueNumFilter (without mask) was in          */
  /* CRS==SLOW. It is advisable to use this only with timer          */
  /* active.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b4 */

     /* TimeInSlow: This register holds the clock count the          */
     /* queue defined in QueueNumFilter (without mask) was in        */
     /* CRS==SLOW. It is advisable to use this only with timer       */
     /* active. This register is clear on read.                      */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD time_in_slow;

     /* TimeInSlowValid: Counter valid, or counter overflowd if      */
     /* not using timer.                                             */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD time_in_slow_valid;

  } __ATTRIBUTE_PACKED__ time_in_slow_reg;

  /* Time In Norm: This register holds the clock count the          */
  /* queue defined in QueueNumFilter (without mask) was in          */
  /* CRS==NORM. It is advisable to use this only with timer          */
  /* active.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b5 */

     /* TimeInNorm: This register holds the clock count the          */
     /* queue defined in QueueNumFilter (without mask) was in        */
     /* CRS==NORM. It is advisable to use this only with timer       */
     /* active. This register is clear on read.                      */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD time_in_norm;

     /* TimeInNormValid: Counter valid, or counter overflowd if      */
     /* not using timer.                                             */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD time_in_norm_valid;

  } __ATTRIBUTE_PACKED__ time_in_norm_reg;

  /* Fcr Credit Counter: Counts credit received from FCR. This       */
  /* counter may count according to timer and queue number          */
  /* filter.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d0 */

     /* FcrCreditCounter: Counts credit received from FCR. This      */
     /* counter may count according to timer and queue number        */
     /* filter.                                                      */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fcr_credit_counter;

     /* FcrCreditCounterOverflow: Counter overflowed, or counter     */
     /* valid after timer finished This register is clear on         */
     /* read.                                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fcr_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ fcr_credit_counter_reg;

  /* Global Credit Counter: Counts credit received from all         */
  /* sources. This counter may count according to timer.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d1 */

     /* GlobalCreditCounter: Counts credit received from all         */
     /* sources. This counter may count according to timer.          */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD global_credit_counter;

     /* GlobalCreditCounterOverflow: Counter overflowed, or          */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD global_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ global_credit_counter_reg;

  /* Gfmc Credit Counter: Counts credit granted to FMC queues       */
  /* under GFMC. This counter may count according to timer.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d2 */

     /* GfmcCreditCounter: Counts credit granted to FMC queues       */
     /* under GFMC. This counter may count according to timer.       */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD gfmc_credit_counter;

     /* GfmcCreditCounterOverflow: Counter overflowed, or            */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD gfmc_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ gfmc_credit_counter_reg;

  /* Bfmc1 Credit Counter: Counts credit granted to FMC             */
  /* queues under BFMC1. This counter may count according to         */
  /* timer.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d3 */

     /* Bfmc1CreditCounter: Counts credit granted to FMC queues      */
     /* under BFMC1. This counter may count according to timer.      */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bfmc1_credit_counter;

     /* Bfmc1CreditCounterOverflow: Counter overflowed, or           */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bfmc1_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ bfmc1_credit_counter_reg;

  /* Bfmc2 Credit Counter: Counts credit granted to FMC             */
  /* queues under BFMC2. This counter may count according to         */
  /* timer.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d4 */

     /* Bfmc2CreditCounter: Counts credit granted to FMC queues      */
     /* under BFMC2. This counter may count according to timer.      */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bfmc2_credit_counter;

     /* Bfmc2CreditCounterOverflow: Counter overflowed, or           */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bfmc2_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ bfmc2_credit_counter_reg;

  /* Bfmc3 Credit Counter: Counts credit granted to FMC             */
  /* queues under BFMC3. This counter may count according to         */
  /* timer.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d5 */

     /* Bfmc3CreditCounter: Counts credit granted to FMC queues      */
     /* under BFMC3. This counter may count according to timer.      */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bfmc3_credit_counter;

     /* Bfmc3CreditCounterOverflow: Counter overflowed, or           */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bfmc3_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ bfmc3_credit_counter_reg;

  /* Global Flow Status Counter: Counts all flow status             */
  /* messages sent from IPS (before FMS). This counter may           */
  /* count according to timer, queue number filter, and flow        */
  /* status filter.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d6 */

     /* GlobalFlowStatusCounter: Counts all flow status messages     */
     /* sent from IPS (before FMS). This counter may count           */
     /* according to timer, queue number filter, and flow status     */
     /* filter.                                                      */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD global_flow_status_counter;

     /* GlobalFlowStatusCounterOverflow: Counter overflowed, or      */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD global_flow_status_counter_overflow;

  } __ATTRIBUTE_PACKED__ global_flow_status_counter_reg;

  /* Fsmrq Flow Status Counter: Counts flow status messages         */
  /* generated by FSMRQ (before FMS). This counter may count         */
  /* according to timer, queue number filter, and flow status       */
  /* filter.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d7 */

     /* FsmrqFlowStatusCounter: Counts flow status messages          */
     /* generated by FSMRQ (before FMS). This counter may count      */
     /* according to timer, queue number filter, and flow status     */
     /* filter.                                                      */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsmrq_flow_status_counter;

     /* FsmrqFlowStatusCounterOverflow: Counter overflowed, or       */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrq_flow_status_counter_overflow;

  } __ATTRIBUTE_PACKED__ fsmrq_flow_status_counter_reg;

  /* Fms Flow Status Counter: Counts flow status messages           */
  /* sent to FCT after FMS. This counter may count according         */
  /* to timer, queue number filter, and flow status filter.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d8 */

     /* FmsFlowStatusCounter: Counts flow status messages sent       */
     /* to FCT after FMS. This counter may count according to        */
     /* timer, queue number filter, and flow status filter.          */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fms_flow_status_counter;

     /* FmsFlowStatusCounterOverflow: Counter overflowed, or         */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fms_flow_status_counter_overflow;

  } __ATTRIBUTE_PACKED__ fms_flow_status_counter_reg;

  /* Global Iqm Report Counter: Counts IQM reports handled by       */
  /* main IPS logic. This counter may count according to             */
  /* timer.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d9 */

     /* GlblIqmRprtCounter: Counts IQM reports handled by main       */
     /* IPS logic. This counter may count according to timer.        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD glbl_iqm_rprt_counter;

     /* GlblIqmRprtCounterOverflow: Counter overflowed, or           */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD glbl_iqm_rprt_counter_overflow;

  } __ATTRIBUTE_PACKED__ global_iqm_report_counter_reg;

  /* Programmable Iqm Report Counter: Counts IQM reports            */
  /* handled by main IPS logic. This counter may count               */
  /* according to timer, queue number filer and IQM report          */
  /* filter.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03da */

     /* PrgIqmRprtCounter: Counts IQM reports handled by main        */
     /* IPS logic. This counter may count according to timer,        */
     /* queue number filer and IQM report filter.                    */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prg_iqm_rprt_counter;

     /* PrgIqmRprtCounterOverflow: Counter overflowed, or            */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD prg_iqm_rprt_counter_overflow;

  } __ATTRIBUTE_PACKED__ programmable_iqm_report_counter_reg;

  /* Crwd Event Counter: Counts credit watchdog events              */
  /* handled by main IPS logic. This counter may count               */
  /* according to timer and queue number filer.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03db */

     /* CrwdCounter: Counts credit watchdog events handled by        */
     /* main IPS logic. This counter may count according to          */
     /* timer and queue number filer.                                */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crwd_counter;

     /* CrwdCounterOverflow: Counter overflowed, or counter          */
     /* valid after timer finished This register is clear on         */
     /* read.                                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crwd_counter_overflow;

  } __ATTRIBUTE_PACKED__ crwd_event_counter_reg;

  /* Deq Cmd Byte Counter: Counts the amount of credit              */
  /* command bytes sent to IQM, in 64B units. This counter may       */
  /* count according to timer, queue number filter, and DQCQ        */
  /* filters.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03dc */

     /* DeqCmdByteCounter: Counts the amount of credit command       */
     /* bytes sent to IQM, in 64B units. This counter may count      */
     /* according to timer, queue number filter, and DQCQ            */
     /* filters.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD deq_cmd_byte_counter;

     /* DeqCmdByteCounterOverflow: Counter overflowed, or            */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_cmd_byte_counter_overflow;

  } __ATTRIBUTE_PACKED__ deq_cmd_byte_counter_reg;

  /* Deq Cmd Counter: Counts the amount of DEQ commands sent        */
  /* to the IQM. This counter may count according to timer,          */
  /* queue number filter, and DQCQ filters.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03dd */

     /* DeqCmdCounter: Counts the amount of DEQ commands sent to     */
     /* the IQM. This counter may count according to timer,          */
     /* queue number filter, and DQCQ filters.                       */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD deq_cmd_counter;

     /* DeqCmdCounterOverflow: Counter overflowed, or counter        */
     /* valid after timer finished This register is clear on         */
     /* read.                                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_cmd_counter_overflow;

  } __ATTRIBUTE_PACKED__ deq_cmd_counter_reg;

  /* Masked Iqm Event Counter: Counts the number of IQM             */
  /* events masked at IPS input. This counter may count              */
  /* according to timer and queue number filter.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03de */

     /* MskdIqmEvntsCounter: Counts the number of IQM events         */
     /* masked at IPS input. This counter may count according to     */
     /* timer and queue number filter.                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mskd_iqm_evnts_counter;

     /* MskdIqmEvntsCounterOverflow: Counter overflowed, or          */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mskd_iqm_evnts_counter_overflow;

  } __ATTRIBUTE_PACKED__ masked_iqm_event_counter_reg;

  /* Flow Control Counter: Counts the number clocks the             */
  /* selected flow control signal was asserted. This counter         */
  /* may count according to timer and its dedicated select.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03df */

     /* FcCount: Counts the number clocks the selected flow          */
     /* control signal was asserted. This counter may count          */
     /* according to timer and its dedicated select.                 */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_count;

     /* FcCountOverflow: Counter overflowed, or counter valid        */
     /* after timer finished This register is clear on read.         */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_count_overflow;

  } __ATTRIBUTE_PACKED__ flow_control_counter_reg;

  /* Returned Credit Counter: Counts the number of credits          */
  /* returned to the SCH. This counter may count according to        */
  /* timer and queue filter.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03e0 */

     /* ReturnedCreditCount: Counts the number of credits            */
     /* returned to the SCH. This counter may count according to     */
     /* timer and queue filter.                                      */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD returned_credit_count;

     /* ReturnedCreditCountOverflow: Counter overflowed, or          */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD returned_credit_count_overflow;

  } __ATTRIBUTE_PACKED__ returned_credit_counter_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_IPS_REGS;
/* Block definition: IPT */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in the IPT.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0800 */

     /* SopEccError: If set, then there is an ECC error on SOP       */
     /* memory.                                                      */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD sop_ecc_error;

     /* MopEccError: If set, then there is a ECC error on MOP        */
     /* memory.                                                      */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mop_ecc_error;

     /* FdtcEccError: If set, then there is a ECC error on FDTC      */
     /* memory.                                                      */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdtc_ecc_error;

     /* BdqEccError: If set, then there is a ECC error on BDQ        */
     /* memory.                                                      */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdq_ecc_error;

     /* PdqEccError: If set, then there is a ECC error on PDQ        */
     /* memory.                                                      */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD pdq_ecc_error;

     /* SopEccFixed: If set, then the ECC fixed one bit error on     */
     /* SOP memory.                                                  */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD sop_ecc_fixed;

     /* MopEccFixed: If set, then the ECC fixed one bit error on     */
     /* MOP memory.                                                  */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mop_ecc_fixed;

     /* FdtcEccFixed: If set, then the ECC fixed one bit error       */
     /* on FDTC memory.                                              */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdtc_ecc_fixed;

     /* BdqEccFixed: If set, then the ECC fixed one bit error on     */
     /* BDQ memory.                                                  */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdq_ecc_fixed;

     /* PdqEccFixed: If set, then the ECC fixed one bit error on     */
     /* PDQ memory.                                                  */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pdq_ecc_fixed;

     /* CrcErrPkt: If set, then there is a CRC error on packets      */
     /* arriving from the MMU.                                       */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD crc_err_pkt;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0810 */

     /* SopEccErrorMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD sop_ecc_error_mask;

     /* MopEccErrorMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mop_ecc_error_mask;

     /* FdtcEccErrorMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdtc_ecc_error_mask;

     /* BdqEccErrorMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdq_ecc_error_mask;

     /* PdqEccErrorMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pdq_ecc_error_mask;

     /* SopEccFixedMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD sop_ecc_fixed_mask;

     /* MopEccFixedMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mop_ecc_fixed_mask;

     /* FdtcEccFixedMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdtc_ecc_fixed_mask;

     /* BdqEccFixedMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdq_ecc_fixed_mask;

     /* PdqEccFixedMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pdq_ecc_fixed_mask;

     /* CrcErrPktMask: Writing 0 masks the corresponding             */
     /* interrupt source.                                            */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crc_err_pkt_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0820 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_IPT_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0830 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_IPT_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0840 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set, to 0, one       */
     /* operation is performed. The CPU can read this field to       */
     /* determine the number of writes left.                         */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set, to 0, then the command has no timeout.       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0841 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0842 */

     /* IndirectCommandDataIncrement:                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_IPT_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* Disable Ecc: Disable Ecc logic                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0844 */

     /* DisableEcc: Disable Ecc logic                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD disable_ecc;

  } __ATTRIBUTE_PACKED__ disable_ecc_reg;

  /* Mirror Snoop fix                                */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0852 */

    /* range: 0:0, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD mirror_snoop_uc_fix_en;

  } __ATTRIBUTE_PACKED__ mirror_snp_fix_reg;

  /* Data Queue EGQThreshold: EGQ TX data queue threshold.          */
  /* The IPT stores the data read from the DRAM before it is        */
  /* sent to the EGQ. If the number of 64-byte cells stored         */
  /* in the FIFO is above the threshold then flow control is        */
  /* sent to the EGQ and traffic from local route gets strict       */
  /* priority in the EGQ.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0860 */

     /* DtqEgqTh: EGQ Tx Data queue threshold.                       */
     /* range: 4:0, access type: RW, default value: 0x19             */
     SOC_PETRA_REG_FIELD dtq_egq_th;

  } __ATTRIBUTE_PACKED__ data_queue_egqthreshold_reg;

  /* GCIMCILeaky Bucket Configuration Register0: Configures         */
  /* the GCI/MCI logic                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0862 */

     /* LkyBktMaxCnt: The maximum value a leaky bucket can reach     */
     /* range: 7:0, access type: RW, default value: 0x80             */
     SOC_PETRA_REG_FIELD lky_bkt_max_cnt;

     /* HoldMCIPrd: The period the IPT holds an MCI indication       */
     /* active. Setting this parameter to 0 disables this, and        */
     /* the indication comes directly from the FE.                   */
     /* range: 29:24, access type: RW, default value: 0x20           */
     SOC_PETRA_REG_FIELD hold_mciprd;

  } __ATTRIBUTE_PACKED__ gcimcileaky_bucket_configuration_0_reg;

  /* GCILeaky Bucket Configuration Register1: Configures the        */
  /* GCI/MCI logic                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0863 */

     /* LkyBktDcrRate1: The number of clocks to decrement leaky      */
     /* bucket 1. If set to 0, the leaky bucket will not             */
     /* decrement.                                                   */
     /* range: 5:0, access type: RW, default value: 0x4              */
     SOC_PETRA_REG_FIELD lky_bkt_dcr_rate1;

     /* LkyBktDcrRate2: The number of clocks to decrement leaky      */
     /* bucket 2. If set to 0, the leaky bucket will not             */
     /* decrement.                                                   */
     /* range: 13:8, access type: RW, default value: 0x2             */
     SOC_PETRA_REG_FIELD lky_bkt_dcr_rate2;

     /* LkyBktDcrRate3: The number of clocks to decrement leaky      */
     /* bucket 3. If set to 0, the leaky bucket will not             */
     /* decrement.                                                   */
     /* range: 21:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD lky_bkt_dcr_rate3;

     /* LkyBktDcrRate4: The number of clocks to decrement leaky      */
     /* bucket 4. If set to 0, the leaky bucket will not             */
     /* decrement. Note: considered by default as GFMC.              */
     /* range: 29:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD lky_bkt_dcr_rate4;

  } __ATTRIBUTE_PACKED__ gcileaky_bucket_configuration_1_reg;

  /* Mapping Traffic Class: Mapping eight traffic classes in        */
  /* the Soc_petra header to four traffic classes in the fap20b         */
  /* header type.                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0864 */

     /* ClassTable: Traffic class mapping 8 to 4 table               */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD class_table;

  } __ATTRIBUTE_PACKED__ mapping_traffic_class_reg;

  /* Fabric Header Extended Mode: Fap20b Fabric header in           */
  /* extended mode.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0865 */

     /* Extmode: If set, the devices in the system are in            */
     /* extended mode                                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD extmode;

  } __ATTRIBUTE_PACKED__ fabric_header_extended_mode_reg;

  /* CRCErr Rate Configuration Register0: Configures the CRC        */
  /* errors rate counters logic                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0866 */

     /* CRCErrRateDcr: The number of clocks to decrement the CRC     */
     /* errors rate counter.                                         */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD crcerr_rate_dcr;

     /* CRCErrRateMaxCnt: The maximum value the CRC errors           */
     /* counter can reach.                                           */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crcerr_rate_max_cnt;

  } __ATTRIBUTE_PACKED__ crcerr_rate_configuration_0_reg;

  /* CRCErr Rate Configuration Register1:                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0867 */

     /* CRCErrRateCngTh: The threshold above which the IPT stops     */
     /* transmitting packets to the fabric and the local path.       */
     /* If set to 0, the IPT never stops the traffic to the          */
     /* fabric and local path.                                       */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD crcerr_rate_cng_th;

  } __ATTRIBUTE_PACKED__ crcerr_rate_configuration_1_reg;

  /* CRCErr Weight Configuration Register0: Configures the          */
  /* CRC-errors weight logic.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0868 */

     /* CRCErrWeight: Weight for packet with CRC error.              */
     /* Increment the CRC weight counter                             */
     /* range: 4:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crcerr_weight;

     /* CRCNOErrWeight: Weight for packet without CRC error.         */
     /* Decrement the CRC weight counter                             */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crcnoerr_weight;

  } __ATTRIBUTE_PACKED__ crcerr_weight_configuration_0_reg;

  /* CRCErr Weight Configuration Register1: Configures the          */
  /* CRC errors weight logic                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0869 */

     /* CRCErrWeightMaxCnt: The maximum value the CRC errors         */
     /* weight counter can reach                                     */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD crcerr_weight_max_cnt;

     /* CRCErrWeightCngTh: The threshold above which the IPT         */
     /* stops transmitting packets to the fabric and the local       */
     /* path. If set to 0, the IPT never stops the traffic to        */
     /* the fabric and local path.                                   */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crcerr_weight_cng_th;

  } __ATTRIBUTE_PACKED__ crcerr_weight_configuration_1_reg;

  /* Force Local Or Fabric: Force traffic to local route or         */
  /* to fabric.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x086a */

     /* ForceLocal: Force all the traffic to local route.            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_local;

     /* ForceFabric: Force all the traffic to Fabric.                */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_fabric;

  } __ATTRIBUTE_PACKED__ force_local_or_fabric_reg;

  /* DRAMBuffer Pointer Queue Threshold0-1: DRAM buffer             */
  /* pointer queue thresholds. The IPT stores the DRAM buffer        */
  /* pointers in a FIFO with 16 contexts. If the number of          */
  /* Dbuff pointer stored in the context is above the               */
  /* threshold, flow control to IPS is sent.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0870 */

     /* DpqTh0: Context number 0 threshold, above which flow         */
     /* control to IPS is sent                                       */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_th_hp;

     /* DpqTh1: Context number 1 threshold, above which flow         */
     /* control to IPS is sent                                       */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_th_lp;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_threshold_reg[SOC_PB_REGS_DBUFF_PTR_Q_THRESH_NOF_REGS];

  /* DRAMBuffer Pointer Queue Multicast Threshold4-5: DRAM          */
  /* buffer pointer queue thresholds. The IPT stores the DRAM        */
  /* buffer pointers in a FIFO with 16 contexts. If the             */
  /* number of Dbuff pointer stored in the context is above         */
  /* the threshold, flow control to IPS is sent, for                */
  /* Multicast FIFOs, when working in fabric.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0878 */

     /* DpqMcTh4: Context number 4 threshold, above which flow       */
     /* control to IPS is sent, relvant only for High priority       */
     /* multicast context, in fabric.                                */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_mc_th4;

     /* DpqMcTh5: Context number 5 threshold, above which flow       */
     /* control to IPS is sent, relvant only for low priority        */
     /* multicast context, in fabric.                                */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_mc_th5;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_multicast_threshold4_5_reg;

  /* GCILeaky Bucket Configuration Register2: Configures the        */
  /* GCI leaky buckets thresholds                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0879 */

     /* LkyBktCngTh1: The threshold above which a leaky bucket 4     */
     /* (BFMC0) is considered congested                              */
     /* range: 7:0, access type: RW, default value: 0x4              */
     SOC_PETRA_REG_FIELD lky_bkt_cng_th1;

     /* LkyBktCngTh2: The threshold above which a leaky bucket 4     */
     /* (BFMC1) is considered congested                              */
     /* range: 15:8, access type: RW, default value: 0x4             */
     SOC_PETRA_REG_FIELD lky_bkt_cng_th2;

     /* LkyBktCngTh3: The threshold above which a leaky bucket 4     */
     /* (BFMC2) is considered congested                              */
     /* range: 23:16, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD lky_bkt_cng_th3;

     /* LkyBktCngTh4: The threshold above which a leaky bucket 4     */
     /* (GFMC) is considered congested                               */
     /* range: 31:24, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD lky_bkt_cng_th4;

  } __ATTRIBUTE_PACKED__ gcileaky_bucket_configuration_2_reg;

  /* DRAMBuffer Pointer Queue Size0-1: DRAM buffer queue            */
  /* size. The IPT stores the DRAM buffer pointers in a FIFO        */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The number of entries per context is            */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0880 */

     /* DpqSize0: Context number 0 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size0;

     /* DpqSize1: Context number 1 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size1;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size0_1_reg;

  /* DRAMBuffer Pointer Queue Size2-3: DRAM buffer queue            */
  /* size. The IPT stores the DRAM buffer pointers in a FIFO        */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The number of entries per context is            */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0881 */

     /* DpqSize2: Context number 2 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size2;

     /* DpqSize3: Context number 3 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size3;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size2_3_reg;

  /* DRAMBuffer Pointer Queue Size4-5: DRAM buffer queue            */
  /* size. The IPT stores the DRAM buffer pointers in a FIFO        */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The number of entries per context is            */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0882 */

     /* DpqSize4: Context number 4 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size4;

     /* DpqSize5: Context number 5 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size5;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size4_5_reg;

  /* DRAMBuffer Pointer Queue Size6-7: DRAM buffer queue            */
  /* size. The IPT stores the DRAM buffer pointers in a FIFO        */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The number of entries per context is            */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0883 */

     /* DpqSize6: Context number 6 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size6;

     /* DpqSize7: Context number 7 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size7;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size6_7_reg;

  /* DRAMBuffer Pointer Queue Size8-9: DRAM buffer queue            */
  /* size. The IPT stores the DRAM buffer pointers in a FIFO        */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The number of entries per context is            */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0884 */

     /* DpqSize8: Context number 8 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size8;

     /* DpqSize9: Context number 9 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size9;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size8_9_reg;

  /* DRAMBuffer Pointer Queue Size10-11: DRAM buffer queue          */
  /* size. The IPT stores the DRAM buffer pointers in a FIFO        */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The number of entries per context is            */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0885 */

     /* DpqSize10: Context number 10 Size. Number of lines in        */
     /* the shared memory assigned to it.                            */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size10;

     /* DpqSize11: Context number 11 Size. Number of lines in        */
     /* the shared memory assigned to it.                            */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size11;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size10_11_reg;

  /* DRAMBuffer Pointer Queue Size12-13: DRAM buffer queue          */
  /* size. The IPT stores the DRAM buffer pointers in a FIFO        */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The number of entries per context is            */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0886 */

     /* DpqSize12: Context number 12 Size. Number of lines in        */
     /* the shared memory assigned to it.                            */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size12;

     /* DpqSize13: Context number 13 Size. Number of lines in        */
     /* the shared memory assigned to it.                            */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size13;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size12_13_reg;

  /* DRAMBuffer Pointer Queue Size14-15: DRAM buffer queue          */
  /* size. The IPT stores the DRAM buffer pointers in a FIFO        */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The number of entries per context is            */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0887 */

     /* DpqSize14: Context number 14 Size. Number of lines in        */
     /* the shared memory assigned to it.                            */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size14;

     /* DpqSize15: Context number 15 Size. Number of lines in        */
     /* the shared memory assigned to it.                            */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size15;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size14_15_reg;

  /* DRAMBuffer Pointer Queue Start Address0-1: DRAM buffer         */
  /* queue Start. The IPT stores the DRAM buffer pointers in        */
  /* a FIFO with 16 contexts. The Dbuff pointers are stored         */
  /* in a shared memory. The context memory start address is        */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0890 */

     /* DpqStart0: Context number 0 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dpq_start0;

     /* DpqStart1: Context number 1 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0x100          */
     SOC_PETRA_REG_FIELD dpq_start1;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address0_1_reg;

  /* DRAMBuffer Pointer Queue Start Address2-3: DRAM buffer         */
  /* queue Start. The IPT stores the DRAM buffer pointers in        */
  /* a FIFO with 16 contexts. The Dbuff pointers are stored         */
  /* in a shared memory. The context memory start address is        */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0891 */

     /* DpqStart2: Context number 2 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0x200           */
     SOC_PETRA_REG_FIELD dpq_start2;

     /* DpqStart3: Context number 3 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0x300          */
     SOC_PETRA_REG_FIELD dpq_start3;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address2_3_reg;

  /* DRAMBuffer Pointer Queue Start Address4-5: DRAM buffer         */
  /* queue Start. The IPT stores the DRAM buffer pointers in        */
  /* a FIFO with 16 contexts. The Dbuff pointers are stored         */
  /* in a shared memory. The context memory start address is        */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0892 */

     /* DpqStart4: Context number 4 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0x400           */
     SOC_PETRA_REG_FIELD dpq_start4;

     /* DpqStart5: Context number 5 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0x500          */
     SOC_PETRA_REG_FIELD dpq_start5;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address4_5_reg;

  /* DRAMBuffer Pointer Queue Start Address6-7: DRAM buffer         */
  /* queue Start. The IPT stores the DRAM buffer pointers in        */
  /* a FIFO with 16 contexts. The Dbuff pointers are stored         */
  /* in a shared memory. The context memory start address is        */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0893 */

     /* DpqStart6: Context number 6 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0x600           */
     SOC_PETRA_REG_FIELD dpq_start6;

     /* DpqStart7: Context number 7 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0x700          */
     SOC_PETRA_REG_FIELD dpq_start7;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address6_7_reg;

  /* DRAMBuffer Pointer Queue Start Address8-9: DRAM buffer         */
  /* queue Start. The IPT stores the DRAM buffer pointers in        */
  /* a FIFO with 16 contexts. The Dbuff pointers are stored         */
  /* in a shared memory. The context memory start address is        */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0894 */

     /* DpqStart8: Context number 8 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0x800           */
     SOC_PETRA_REG_FIELD dpq_start8;

     /* DpqStart9: Context number 9 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0x900          */
     SOC_PETRA_REG_FIELD dpq_start9;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address8_9_reg;

  /* DRAMBuffer Pointer Queue Start Address10-11: DRAM buffer       */
  /* queue Start. The IPT stores the DRAM buffer pointers in        */
  /* a FIFO with 16 contexts. The Dbuff pointers are stored         */
  /* in a shared memory. The context memory start address is        */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0895 */

     /* DpqStart10: Context number 10 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0xa00           */
     SOC_PETRA_REG_FIELD dpq_start10;

     /* DpqStart11: Context number 11 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0xb00          */
     SOC_PETRA_REG_FIELD dpq_start11;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address10_11_reg;

  /* DRAMBuffer Pointer Queue Start Address12-13: DRAM buffer       */
  /* queue Start. The IPT stores the DRAM buffer pointers in        */
  /* a FIFO with 16 contexts. The Dbuff pointers are stored         */
  /* in a shared memory. The context memory start address is        */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0896 */

     /* DpqStart12: Context number 12 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0xc00           */
     SOC_PETRA_REG_FIELD dpq_start12;

     /* DpqStart13: Context number 13 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0xd00          */
     SOC_PETRA_REG_FIELD dpq_start13;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address12_13_reg;

  /* DRAMBuffer Pointer Queue Start Address14-15: DRAM buffer       */
  /* queue Start. The IPT stores the DRAM buffer pointers in        */
  /* a FIFO with 16 contexts. The Dbuff pointers are stored         */
  /* in a shared memory. The context memory start address is        */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0897 */

     /* DpqStart14: Context number 14 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0xe00           */
     SOC_PETRA_REG_FIELD dpq_start14;

     /* DpqStart15: Context number 15 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0xf00          */
     SOC_PETRA_REG_FIELD dpq_start15;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address14_15_reg;

  /* Transmit Data Queue Size0-7: Transmit data queue Size.         */
  /* IPT stores the data read from the DRAM before it is sent       */
  /* to the FDT, in FIFO with 7 contexts. The data stored in        */
  /* a shared memory. The context size is programmable.             */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0900 */

    /* DtqSize: Context number [0-7] Size. Number of lines in the   */
    /* shared memory ,assigned to it.                               */
    /* range: 8:0, access type: RW, default value: 0x48             */
    SOC_PETRA_REG_FIELD dtq_size[SOC_PB_TRANSMIT_DATA_QUEUE_NOF_FLDS];
  } __ATTRIBUTE_PACKED__ transmit_data_queue_size_reg[SOC_PB_TRANSMIT_DATA_QUEUE_NOF_REGS];

  /* Transmit Data Queue Size2-3: Transmit data queue Size.         */
  /* The IPT stores the data read from the DRAM before it is        */
  /* sent to the FDT, in a FIFO with 7 contexts. The data are       */
  /* stored in a shared memory. The context size is                 */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0901 */

     /* DtqSize2: Context number 2 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_size2;

     /* DtqSize3: Context number 3 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 24:16, access type: RW, default value: 0x48           */
     SOC_PETRA_REG_FIELD dtq_size3;

  } __ATTRIBUTE_PACKED__ transmit_data_queue_size2_3_reg;

  /* Transmit Data Queue Size4-5: Transmit data queue Size.         */
  /* The IPT stores the data read from the DRAM before it is        */
  /* sent to the FDT, in a FIFO with 7 contexts. The data are       */
  /* stored in a shared memory. The context size is                 */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0902 */

     /* DtqSize4: Context number 4 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_size4;

     /* DtqSize5: Context number 5 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 24:16, access type: RW, default value: 0x48           */
     SOC_PETRA_REG_FIELD dtq_size5;

  } __ATTRIBUTE_PACKED__ transmit_data_queue_size4_5_reg;

  /* Transmit Data Queue Size6: Transmit data queue Size. The       */
  /* IPT stores the data read from the DRAM before it is sent       */
  /* to the FDT, in a FIFO with 7 contexts. The data are            */
  /* stored in a shared memory. The context size is                 */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0903 */

     /* DtqSize6: Context number 6 Size. Number of lines in the      */
     /* shared memory assigned to it.                                */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_size6;

  } __ATTRIBUTE_PACKED__ transmit_data_queue_size6_reg;

  /* Transmit Data Queue Start Adress0-7: Transmit data queue       */
  /* Start address. IPT stores the data read from the DRAM          */
  /* before it is sent to the FDT, in FIFO with 7 contexts.         */
  /* The data stored in a shared memory. The context memory         */
  /* start address is programmable.                                 */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0910 */

    /* DtqStart0: Context number 0-7 Start. The shared memory       */
    /* address from above the context Data cells are stored         */
    /* range: 8:0, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD dtq_start[SOC_PB_TRANSMIT_DATA_QUEUE_NOF_FLDS];
  } __ATTRIBUTE_PACKED__ transmit_data_queue_start_adress_reg[SOC_PB_TRANSMIT_DATA_QUEUE_NOF_REGS];

  /* Transmit Data Queue Threshold0-1: Transmit data queue          */
  /* threshold. The IPT stores the data read from the DRAM,         */
  /* before it is sent to the FDT. If the number of 64-byte         */
  /* cells stored in the context is above the threshold, then       */
  /* IPT shaper bandwidth is divided by two                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0920 */

     /* DtqTh0: Context number 0 threshold, above which the          */
     /* shaper bandwidth is divided by two                           */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_th0;

     /* DtqTh1: Context number 1 threshold, above which the          */
     /* shaper bandwidth is divided by two                           */
     /* range: 24:16, access type: RW, default value: 0x48           */
     SOC_PETRA_REG_FIELD dtq_th1;

  } __ATTRIBUTE_PACKED__ transmit_data_queue_threshold0_1_reg;

  /* Transmit Data Queue Threshold2-3: Transmit data queue          */
  /* threshold. The IPT stores the data read from the DRAM,         */
  /* before it is sent to the FDT. If the number of 64-byte         */
  /* cells stored in the context is above the threshold, then       */
  /* IPT shaper bandwidth is divided by two                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0921 */

     /* DtqTh2: Context number 2 threshold, above which the          */
     /* shaper bandwidth is divided by two                           */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_th2;

     /* DtqTh3: Context number 3 threshold, above which the          */
     /* shaper bandwidth is divided by two                           */
     /* range: 24:16, access type: RW, default value: 0x48           */
     SOC_PETRA_REG_FIELD dtq_th3;

  } __ATTRIBUTE_PACKED__ transmit_data_queue_threshold2_3_reg;

  /* Transmit Data Queue Threshold4-5: Transmit data queue          */
  /* threshold. The IPT stores the data read from the DRAM,         */
  /* before it is sent to the FDT. If the number of 64-byte         */
  /* cells stored in the context is above the threshold, then       */
  /* IPT shaper bandwidth is divided by two                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0922 */

     /* DtqTh4: Context number 4 threshold, above which the          */
     /* shaper bandwidth is divided by two                           */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_th4;

     /* DtqTh5: Context number 5 threshold, above which the          */
     /* shaper bandwidth is divided by two                           */
     /* range: 24:16, access type: RW, default value: 0x48           */
     SOC_PETRA_REG_FIELD dtq_th5;

  } __ATTRIBUTE_PACKED__ transmit_data_queue_threshold4_5_reg;

  /* Transmit Data Queue Threshold6: Transmit data queue            */
  /* threshold. The IPT stores the data read from the DRAM,         */
  /* before it is sent to the FDT. If the number of 64-byte         */
  /* cells stored in the context is above the threshold, then       */
  /* IPT shaper bandwidth is divided by two                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0923 */

     /* DtqTh6: Context number 6 threshold, above which the          */
     /* shaper bandwidth is divided by two                           */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_th6;

  } __ATTRIBUTE_PACKED__ transmit_data_queue_threshold6_reg;

  /* shaper_max_credit_reg[4]: IPT schedules among the DRAM         */
  /* buffers queue, the data read requests bandwidth is             */
  /* shaped.*/
  /* addr - Shaper0-1 Max Credit - 0x0930*/
  /* addr - Shaper2-3 Max Credit - 0x0931*/
  /* addr - Shaper4-5 Max Credit - 0x0932*/
  /* addr - Shaper6-7 Max Credit - 0x0933*/
  /* Shaper0MaxCredit: Shaper0 Max burst size. both In mesh         */
  /* and fabric mode gates the request for local route.             */
  /* range: 15:0, access type: RW, default value: 0xffff            */
  /* Shaper1MaxCredit: Shaper1 Max burst size. In mesh mode       */
  /* gates the requests for context1 and in fabric mode gates     */
  /* the request for the fabric.                                  */
  /* range: 31:16, access type: RW, default value: 0xffff         */

  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0930 */
     SOC_PETRA_REG_FIELD shaper0_max_credit;
     SOC_PETRA_REG_FIELD shaper1_max_credit;

  } __ATTRIBUTE_PACKED__ shaper_max_credit_reg[SOC_PB_NOF_SHAPER_MAX_CREDIT_REGS];

  /* Shaper8 Max Credit: IPT schedules among the DRAM buffers       */
  /* queue, the data read requests bandwidth is shaped.             */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0934 */

    /* Shaper8MaxCredit: Shaper8 Max burst size. In mesh mode,      */
    /* gates the total read request bandwidth from the DRAM.        */
    /* Not applicable in fabric mode.                               */
    /* range: 15:0, access type: RW, default value: 0xffff          */
    SOC_PETRA_REG_FIELD shaper8_max_credit;

  } __ATTRIBUTE_PACKED__ shaper8_max_credit_reg;

  /* shaper_delay_reg[4]: IPT schedules among the DRAM buffers       */
  /* queue, the data read requests bandwidth is shaped.              */
  /* addr: Shaper0-1 Delay 0x2140 */
  /* addr: Shaper2-3 Delay 0x2141 */
  /* addr: Shaper4-5 Delay 0x2142 */
  /* addr: Shaper6-7 Delay 0x2143 */
  /* Shaper0Delay: Shaper0 time interval to add the credit.       */
  /* in two clocks cycles resolution. Both In mesh and fabric     */
  /* mode gates the request for local route.                      */
  /* range: 15:0, access type: RW, default value: 0xffff          */
  /* Shaper1Delay: Shaper1 time interval to add the credit.       */
  /* in two clocks cycles resolution. In mesh mode gates the      */
  /* requests for context1 and in fabric mode gates the           */
  /* request for the fabric.                                      */
  /* range: 31:16, access type: RW, default value: 0xffff         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0941 */

     SOC_PETRA_REG_FIELD shaper0_delay;

     SOC_PETRA_REG_FIELD shaper1_delay;

  } __ATTRIBUTE_PACKED__ shaper_delay_reg[SOC_PB_NOF_SHAPER_DELAY_REGS];

  /* Shaper8 Delay: IPT schedules among the DRAM buffers            */
  /* queue, the data read requests bandwidth is shaped.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0944 */

     /* Shaper8Delay: Shaper8 time interval to add the credit,       */
     /* in resolution of two clock cycles. In mesh mode, gates       */
     /* the total read request bandwidth from the DRAM. Not          */
     /* applicable in fabric mode.                                   */
     /* range: 15:0, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD shaper8_delay;

  } __ATTRIBUTE_PACKED__ shaper8_delay_reg;

  /* Shaper4 Slow Start Delay: IPT schedules among the DRAM         */
  /* buffers queue, the data read requests bandwidth is             */
  /* shaped. In Fabric, Multicast shapers have a slow start         */
  /* mechanism.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0945 */

     /* Shaper4SlowStartDelay0: Shaper4 time interval to add the     */
     /* credit, in resolution of two clock cycles. In fabric         */
     /* mode, this delay is used for time period 0, when context     */
     /* 4 changes status from empty to non empty. (GFMC)             */
     /* range: 15:0, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD shaper4_slow_start_delay0;

     /* Shaper4SlowStartDelay1: Shaper4 time interval to add the     */
     /* credit, in resolution of two clock cycles. In fabric         */
     /* mode, this delay is used for time period 1, after time       */
     /* period 0 expired. (GFMC)                                     */
     /* range: 31:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD shaper4_slow_start_delay1;

  } __ATTRIBUTE_PACKED__ shaper4_slow_start_delay_reg;

  /* Shaper5 Slow Start Delay: IPT schedules among the DRAM         */
  /* buffers queue, the data read requests bandwidth is             */
  /* shaped. In Fabric, Multicast shapers have a slow start         */
  /* mechanism.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0946 */

     /* Shaper5SlowStartDelay0: Shaper5 time interval to add the     */
     /* credit, in resolution of two clock cycles. In fabric         */
     /* mode, this delay is used for time period 0, when context     */
     /* 5 changes status from empty to non empty. (BFMC)             */
     /* range: 15:0, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD shaper5_slow_start_delay0;

     /* Shaper5SlowStartDelay1: Shaper5 time interval to add the     */
     /* credit, in resolution of two clock cycles. In fabric         */
     /* mode, this delay is used for time period 1, after time       */
     /* period 0 expired. (BFMC)                                     */
     /* range: 31:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD shaper5_slow_start_delay1;

  } __ATTRIBUTE_PACKED__ shaper5_slow_start_delay_reg;

  /*shaper_cal_reg[4]: IPT schedules among the DRAM buffers            */
  /* queue, the data read requests bandwidth is gated by            */
  /* shapers.                                                       */

   /* addr: Shaper0-1 Cal 0x0950 */
   /* addr: Shaper2-3 Cal 0x0951 */
   /* addr; Shaper4-5 Cal 0x0952 */
   /* addr: Shaper6-7 Cal 0x0953 */
   /* Shaper0Cal: Shaper0 credit to add, in bytes resolution.      */
   /* Both In mesh and fabric mode gates the request for local     */
   /* route.                                                       */
   /* range: 15:0, access type: RW, default value: 0xffff          */
   /* Shaper1Cal: Shaper1 credit to add, in bytes resolution.      */
   /* In mesh mode gates the requests for context1 and in          */
   /* fabric mode gates the request for the fabric.                */
   /* range: 31:16, access type: RW, default value: 0xffff         */

  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0950 */

     SOC_PETRA_REG_FIELD shaper0_cal;

     SOC_PETRA_REG_FIELD shaper1_cal;

  } __ATTRIBUTE_PACKED__ shaper_cal_reg[SOC_PB_NOF_SHAPER_CAL_REGS];

  /* Shaper8 Cal: IPT schedules among the DRAM buffers queue,       */
  /* the data read requests bandwidth is shaped.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0954 */

     /* Shaper8Cal: Shaper8 credit to add resolution of bytes.       */
     /* In mesh mode, gates the total read request bandwidth         */
     /* from the DRAM. Not applicable in fabric mode.                */
     /* range: 15:0, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD shaper8_cal;

  } __ATTRIBUTE_PACKED__ shaper8_cal_reg;

  /* Shaper4 Slow Start Cal: IPT schedules among the DRAM           */
  /* buffers queue, the data read requests bandwidth is             */
  /* shaped. In Fabric, Multicast shapers have a slow start         */
  /* mechanism.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0955 */

     /* Shaper4SlowStartCal0: Shaper4 credit to add resolution       */
     /* of bytes. In fabric mode, this calendar is used for time     */
     /* period 0, when context 4 changes status from empty to        */
     /* non empty. (GFMC)                                            */
     /* range: 15:0, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD shaper4_slow_start_cal0;

     /* Shaper4SlowStartCal1: Shaper4 credit to add resolution       */
     /* of bytes. In fabric mode, this delay is used for time        */
     /* period 1, after time period 0 expired. (GFMC)                */
     /* range: 31:16, access type: RW, default value: 0xffff         */
     SOC_PETRA_REG_FIELD shaper4_slow_start_cal1;

  } __ATTRIBUTE_PACKED__ shaper4_slow_start_cal_reg;

  /* Shaper5 Slow Start Cal: IPT schedules among the DRAM           */
  /* buffers queue, the data read requests bandwidth is             */
  /* shaped. In Fabric, Multicast shapers have a slow start         */
  /* mechanism.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0956 */

     /* Shaper5SlowStartCal0: Shaper5 credit to add resolution       */
     /* of bytes. In fabric mode, this calendar is used for time     */
     /* period 0, when context 5 changes status from empty to        */
     /* non empty. (BFMC)                                            */
     /* range: 15:0, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD shaper5_slow_start_cal0;

     /* Shaper5SlowStartCal1: Shaper5 credit to add resolution       */
     /* of bytes. In fabric mode, this delay is used for time        */
     /* period 1, after time period 0 expired. (BFMC)                */
     /* range: 31:16, access type: RW, default value: 0xffff         */
     SOC_PETRA_REG_FIELD shaper5_slow_start_cal1;

  } __ATTRIBUTE_PACKED__ shaper5_slow_start_cal_reg;

  /* Wfq Weight0: To determine priority between contexts, the       */
  /* IPT executes a WDRR. Each context gets a 16-bit weight         */
  /* and the result is that the ratio of the weight determine       */
  /* the traffic transmitted from each context, when context        */
  /* is backlogged                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0960 */

     /* Wfq0Weight: Weight0. In mesh mode, weight for local          */
     /* route. In fabric mode, weight for high-priority traffic      */
     /* for local route.                                             */
     /* range: 5:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD wfq0_weight;

     /* Wfq1Weight: Weight1. In mesh mode, weight for context1.      */
     /* In fabric mode, weight for fabric high-priority traffic.     */
     /* range: 13:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD wfq1_weight;

     /* Wfq2Weight: Weight2. In mesh mode, weight for context2.      */
     /* In fabric mode, weight for fabric Unicast high-priority      */
     /* traffic                                                      */
     /* range: 21:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD wfq2_weight;

     /* Wfq3Weight: Weight3. In mesh mode, weight for context3.      */
     /* In fabric mode, weight for fabric multicast                  */
     /* high-priority traffic (GFMC)                                 */
     /* range: 29:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD wfq3_weight;

  } __ATTRIBUTE_PACKED__ wfq_weight_reg[SOC_PB_IPT_WFQ_WEIGHT_REG_NOF_REGS];

  /* Slow Start Cfg Timer Period: IPT schedules among the           */
  /* DRAM buffers queue, the data read requests bandwidth is        */
  /* shaped. In Fabric, Multicast shapers have a slow start         */
  /* mechanism. The rate is configured for a random time            */
  /* period, randomized according to cfg timer setting. In 32       */
  /* clocks resolution.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0968 */

     /* Shaper4SlowStartCfgTimerPeriod0: Shaper 4, In fabric         */
     /* mode, slow start rate 0 is used for a random time            */
     /* period, randomized by this cfg, the random period is         */
     /* selected in range 0->2^CfgTimerPeriod, in 32 clocks          */
     /* resolution. (GFMC).                                          */
     /* range: 4:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD shaper4_slow_start_cfg_timer_period0;

     /* Shaper4SlowStartCfgTimerPeriod1: Shaper 4, In fabric         */
     /* mode, slow start rate 1 is used for a random time            */
     /* period, randomized by this cfg, the random period is         */
     /* selected in range 0->2^CfgTimerPeriod, in 32 clocks          */
     /* resolution. (GFMC).                                          */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD shaper4_slow_start_cfg_timer_period1;

     /* Shaper5SlowStartCfgTimerPeriod0: Shaper 5, In fabric         */
     /* mode, slow start rate 0 is used for a random time            */
     /* period, randomized by this cfg the random period is          */
     /* selected in range 0->2^CfgTimerPeriod, in 32 clocks          */
     /* resolution. (BFMC)                                           */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD shaper5_slow_start_cfg_timer_period0;

     /* Shaper5SlowStartCfgTimerPeriod1: Shaper 5, In fabric         */
     /* mode, slow start rate 1 is used for a random time            */
     /* period, randomized by this cfg the random period is          */
     /* selected in range 0->2^CfgTimerPeriod, in 32 clocks          */
     /* resolution. (BFMC)                                           */
     /* range: 28:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD shaper5_slow_start_cfg_timer_period1;

     /* Shaper4SlowStartEnable: When set, slow start mechanism       */
     /* is anbaled, otherwise, shaper rate is set according to       */
     /* Shaper4Delay and Shaper4Cal.                                 */
     /* range: 30:30, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD shaper4_slow_start_enable;

     /* Shaper5SlowStartEnable: When set, slow start mechanism       */
     /* is anbaled, otherwise, shaper rate is set according to       */
     /* Shaper5Delay and Shaper5Cal.                                 */
     /* range: 31:31, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD shaper5_slow_start_enable;

  } __ATTRIBUTE_PACKED__ slow_start_cfg_timer_period_reg;

  /* Ipt Enables: IPT enablers                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0969 */

     /* TdmEn: TDM enable: IPT recognizes TDM packets based on       */
     /* the                                                          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_en;

     /* TdmStripFabricCrcEn: Strip fabric crc for tdm cells only     */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_strip_fabric_crc_en;

     /* ActLinksFbrcShpEn: If set, enables fabric (clos) shaper      */
     /* adjustment based on reported number of active links by       */
     /* the FDT, otherwise, shaper rate is fix. Note: Not            */
     /* relevant in Mesh mode.                                       */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD act_links_fbrc_shp_en;

     /* ZeroActLinksRateEn: If set, enables minimal Deq shaper       */
     /* rate equivalent to 1 link when reported number of links      */
     /* is 0, otherwise, when the FDT reports 0 active links per     */
     /* context, the relevant context's shaper rate will be 0.       */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD zero_act_links_rate_en;

  } __ATTRIBUTE_PACKED__ ipt_enables_reg;

  /* Stamping Fabric Header Enable: IPT stamps the packet           */
  /* header stored in the DRAM before sending it to the             */
  /* fabric.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0970 */

     /* StampFapPort: If set, IPT stamps the Fap Port (from IQM)     */
     /* in the packet header                                         */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stamp_fap_port;

     /* StampDp: If set, IPT stamps the DP (from IQM) in the         */
     /* packet header                                                */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stamp_dp;

     /* StampFwdaction: If set, IPT stamps the Fwdaction (from       */
     /* IQM) in the packet header                                    */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stamp_fwdaction;

     /* StampOutlif: If set, IPT stamps the Outlif (from IQM) in     */
     /* the packet header                                            */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stamp_outlif;
     /* StampEep: If set, IPT stamps the Outlif (from IQM) in        */
     /* the eep extenstion packet header                             */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stamp_eep;

  } __ATTRIBUTE_PACKED__ stamping_fabric_header_enable_reg;

  /* Mapping Queue Type To Snoop Packet: Snoop table, Mapping       */
  /* Q-FWD-TYPE to snooped packet                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0971 */

     /* SnoopTable: If bit I is set then packet with (Q-FWD-TYPE     */
     /* == I) is snooped packet.                                     */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD snoop_table;

  } __ATTRIBUTE_PACKED__ mapping_queue_type_to_snoop_packet_reg;

  /* Crc Error Counter: CRC Error counter.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0972 */

     /* CrcErrCnt: CRC Error counter. This register is clear on      */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crc_err_cnt;

     /* CrcErrCntOvf: If set, then indicates that the counter        */
     /* has overflowed.                                              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crc_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ crc_error_counter_reg;

  /* Msb Mirror Data Bus: The MSB mirror data bus -                 */
  /* mdata[35:18].                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0973 */

     /* MsbMdataBus: mdata[35:18]                                    */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD msb_mdata_bus;

  } __ATTRIBUTE_PACKED__ msb_mirror_data_bus_reg;

  /* Lsb Mirror Data Bus: The LSB mirror data bus -                 */
  /* mdata[17:0].                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0974 */

     /* LsbMdataBus: mdata[17:0]                                     */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lsb_mdata_bus;

  } __ATTRIBUTE_PACKED__ lsb_mirror_data_bus_reg;

  /* Qnum Cnt Sel: The Qnum to be counted, otherwise count on       */
  /* total.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0975 */

     /* QnumCntSel: The Qnum to check BW for.                        */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qnum_cnt_sel;

     /* QnumCntSelEn: If set count packet according to               */
     /* QnumCntSel, otherwise count all packets.                     */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qnum_cnt_sel_en;

  } __ATTRIBUTE_PACKED__ qnum_cnt_sel_reg;

  /* Fdt Qnum Cnt Sel: The FDT Qnum to be counted , otherwise       */
  /* count total packets.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0976 */

     /* FdtQnumCntSel: Define the FDT Qnum to be counted.            */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdt_qnum_cnt_sel;

     /* FdtQnumCntSelEn: If set count packet according to            */
     /* FdtQnumCntSel, otherwise count all packets.                  */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdt_qnum_cnt_sel_en;

  } __ATTRIBUTE_PACKED__ fdt_qnum_cnt_sel_reg;

  /* Gtimer Config: GTIMER configuration.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0977 */

     /* TimerConfig: Period of time in clocks.                       */
     /* range: 30:0, access type: RW, default value: 31'hee6b27f     */
     SOC_PETRA_REG_FIELD timer_config;

  } __ATTRIBUTE_PACKED__ gtimer_config_reg;

  /* Gtimer Config Cont: GTIMER configuration.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0978 */

     /* ClearGtimer: Clear timer.                                    */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD clear_gtimer;

     /* ActivateGtimer: Activate timer.                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD activate_gtimer;

     /* GtimerActive: If set GTIMER is active.                       */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_active;

  } __ATTRIBUTE_PACKED__ gtimer_config_cont_reg;

  /* Cfg Event Cnt Sel: Select the source to count.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0979 */

     /* CfgEventCntSel: Configurable event counter (CfgEventCnt)     */
     /* event select: 3'b000 - ENQ2PCQ packets. 3'b001 - ENQ2BDQ     */
     /* buffers. 3'b010 - DEQ packets. 3'b011 - SOP FIFO writes.     */
     /* 3'b100 - MOP FIFO writes. 3'b101 - FDTC control cells.       */
     /* 3'b110 - FDTD data cells. 3'b111 - Valid GCIs.               */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfg_event_cnt_sel;

  } __ATTRIBUTE_PACKED__ cfg_event_cnt_sel_reg;

  /* Cfg Byte Cnt Src Sel: Byte count source select.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0980 */

     /* CfgByteCntSrcSel: Defines the source of the internal         */
     /* byte counter. 2'h0 - DEQ packet bytes (IPT2MMU read          */
     /* commands). 2'h1 - FDTC packet bytes (IPT2FDT data). 2'h2     */
     /* - EGQ bytes (IPT2EGQ data).                                  */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfg_byte_cnt_src_sel;

  } __ATTRIBUTE_PACKED__ cfg_byte_cnt_src_sel_reg;

  /* Gci Backoff Range Thresholds: Configures GCI congestion        */
  /* severity thresholds                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0982 */

     /* CngstLvlThresh0: Congestion severity level thresh, if CS     */
     /* < CngstLvlThresh0 than CS-Range is 2'd0                      */
     /* range: 9:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cngst_lvl_thresh0;

     /* CngstLvlThresh1: Congestion severity level thresh, if        */
     /* CngstLvlThresh0 < CS < CngstLvlThresh1 than CS-Range is      */
     /* 2'd1                                                         */
     /* range: 19:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cngst_lvl_thresh1;

     /* CngstLvlThresh2: Congestion severity level thresh, if        */
     /* CngstLvlThresh1 < CS < CngstLvlThresh2 than CS-Range is      */
     /* 2'd2, else CngstLvlThresh2 < CS CS-Range is 2'd3             */
     /* range: 29:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cngst_lvl_thresh2;

  } __ATTRIBUTE_PACKED__ gci_backoff_range_thresholds_reg;

  /* Gci Backoff CSWeights: Configures GCI congestion               */
  /* severity weights                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0983 */

     /* CngstLvlWorseWeight: Congestion severity worse weight        */
     /* (defines the weights of severity getting worse)              */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cngst_lvl_worse_weight;

     /* CngstLvlBetterWeight: Congestion severity better weight      */
     /* (defines the weights of severity getting better)             */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cngst_lvl_better_weight;

  } __ATTRIBUTE_PACKED__ gci_backoff_csweights_reg;

  /* Cnm Contorl: CnmControl                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0990 */

     /* CnmDuneHeaderFormat: Defines if dune architecture mode       */
     /* is used.                                                     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnm_dune_header_format;

     /* CnmDisableCnTag: Disables CN TAG in the generated CNM        */
     /* packet.                                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnm_disable_cn_tag;

     /* CnmSamplingMode: Defines if CNM packet is generated in       */
     /* Sampling mode                                                */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnm_sampling_mode;

     /* CnmOrigVlanUseTc: Defines if the CNM packet generated        */
     /* used the original packet traffic class. If not, takes        */
     /* the value in CnmOrigVlanPriority                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnm_orig_vlan_use_tc;

     /* CnmOrigVlanPriority: to be placed in the PDU vlan tag.       */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnm_orig_vlan_priority;

     /* CnmExtCpidMsb: CNM extension CPID msb bits, not in           */
     /* sampling mode.                                               */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cnm_ext_cpid_msb;

  } __ATTRIBUTE_PACKED__ cnm_contorl_reg;

  /* Cnm Ingress Vlan Edit Cmd Map: CNMvlaneditcmd                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0991 */

     /* CnmIngressVlanEditCmdMap: Vlan Edit command mapping,         */
     /* determins the VLAN tag format.                               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cnm_ingress_vlan_edit_cmd_map;

  } __ATTRIBUTE_PACKED__ cnm_ingress_vlan_edit_cmd_map_reg[SOC_PB_IPT_CNM_INGRESS_VLAN_EDIT_CMD_MAP_REG_MULT_NOF_REGS];

  /* Cnm FTMH: CNMFTMH                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0995 */

     /* CNMFtmhTrafficClass: Traffic class for the generated CNM     */
     /* FTMH                                                         */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnmftmh_traffic_class;

     /* CNMFtmhSrcSysPort: Src Sys port for the generated CNM        */
     /* FTMH, when in Dune Arch mode.                                */
     /* range: 15:3, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cnmftmh_src_sys_port;

     /* CNMFtmhOtmIsItm: if set, than the OTM port is taken from     */
     /* the IQM data, otherwise take CNMFtmhOtmPort                  */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnmftmh_otm_is_itm;

     /* CNMFtmhOtmPort: Otm port for the generated CNM FTMH if       */
     /* CNMFtmhOtmIsItm is not set, or the packet was ingress        */
     /* shaped.                                                      */
     /* range: 23:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnmftmh_otm_port;

     /* CNMFtmhDp: Drop precedence for the generated CNM FTMH        */
     /* range: 25:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnmftmh_dp;

     /* CNMFtmhQSig: queue signatrue for the generated CNM FTMH      */
     /* range: 27:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnmftmh_qsig;

     /* CNMFtmhMirrorDisable: mirror disable for the generated       */
     /* CNM FTMH                                                     */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnmftmh_mirror_disable;

  } __ATTRIBUTE_PACKED__ cnm_ftmh_reg;

  /* Cnm PPH: CNMPPH                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0996 */

     /* CNMPPhPktIsCtl: is packet control, for the generated CNM     */
     /* packet's PPH.                                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnmpph_pkt_is_ctl;

     /* CNMPPhVlanEditCmdWithCnm: vlan edit command in the           */
     /* generated CNM packet's PPH, when CN tag exists.              */
     /* range: 9:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnmpph_vlan_edit_cmd_with_cnm;

     /* CNMPPhVlanEditCmdWithoutCnm: vlan edit command in the        */
     /* generated CNM packet's PPH, when CN tag does not exist.      */
     /* range: 15:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnmpph_vlan_edit_cmd_without_cnm;

     /* CNMPPhEditPcpDei: edit PCP, for the generated CNM            */
     /* packet's PPH.                                                */
     /* range: 19:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnmpph_edit_pcp_dei;

  } __ATTRIBUTE_PACKED__ cnm_pph_reg;

  /* Cnm Vlan Tag: CNMVLANTAG                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0997 */

     /* VlanTagTpid: Vlan tag TPID when VLAN tag doesn't exist.      */
     /* If exists, taken from the orig packet.                       */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD vlan_tag_tpid;

     /* VlanTagPriority: Vlan tag priority when VLAN tag doesn't     */
     /* exist and CnmOrigVlanUseTc is not set. If exists taken       */
     /* from the orig packet.                                        */
     /* range: 18:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vlan_tag_priority;

     /* VlanTagCfi: Vlan tag CFI.                                    */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vlan_tag_cfi;

     /* VlanTagVid: Vlan tag VID when VLAN tag doesn't exist. If     */
     /* existsm taken from the orig packet.                          */
     /* range: 31:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vlan_tag_vid;

  } __ATTRIBUTE_PACKED__ cnm_vlan_tag_reg;

  /* Cnm PDU: CNMPDU                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0998 */

     /* CnmPduVersion: PDU version                                   */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnm_pdu_version;

     /* CnmPduCpidBase: Base for the CPID field in the PDU.          */
     /* Added to CnmPduCpidMsb.                                      */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnm_pdu_cpid_base;

  } __ATTRIBUTE_PACKED__ cnm_pdu_reg;

  /* Cnm Pdu Cpid Msb: CNMPDU2                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0999 */

     /* CnmPduCpidMsb: CNM PDU CPID msb bits. Added to               */
     /* CnmPduCpidBase.                                              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cnm_pdu_cpid_msb;

  } __ATTRIBUTE_PACKED__ cnm_pdu_cpid_msb_reg[SOC_PB_IPT_CNM_PDU_CPID_MSB_REG_MULT_NOF_REGS];

  /* Cnm Mac Sa: The MAC SA for the generated CNM packet            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x099b */

     /* CnmMacSa: The MAC SA for the generated CNM packet            */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cnm_mac_sa;

  } __ATTRIBUTE_PACKED__ cnm_mac_sa_reg[SOC_PB_IPT_CNM_MAC_SA_REG_MULT_NOF_REGS];

  /* Cnm Ether Type: The Ethernet type for the generated CNM        */
  /* packet                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x099d */

     /* CnmEtherType: The Ethernet type for the generated CNM        */
     /* packet                                                       */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cnm_ether_type;

  } __ATTRIBUTE_PACKED__ cnm_ether_type_reg;

  /* Ipt Intrnl Fmc Fc Map: Maps internal FMC flow controls         */
  /* to IPT context schedulers.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09a0 */

     /* Mci2IptGfmcFcMap: Enable MCI level to IPT GFMC scheduler     */
     /* flow control. Bit 1:0 - MCI1, MCI0                           */
     /* range: 1:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD mci2_ipt_gfmc_fc_map;

     /* Mci2IptBfmcFcMap: Enable MCI level to IPT BFMC scheduler     */
     /* flow control. Bit 1:0 - MCI1, MCI0                           */
     /* range: 3:2, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD mci2_ipt_bfmc_fc_map;

     /* GciLb2IptGfmcFcMap: Enable GCI leaky buckets to IPT GFMC     */
     /* scheduler flow control. 0- LB1 1- LB2 2- LB3 3- LB4          */
     /* range: 7:4, access type: RW, default value: 0x8              */
     SOC_PETRA_REG_FIELD gci_lb2_ipt_gfmc_fc_map;

     /* GciLb2IptBfmcFcMap: Enable GCI leaky buckets to IPT BFMC     */
     /* scheduler flow control. 0- LB1 1- LB2 2- LB3 3- LB4          */
     /* range: 11:8, access type: RW, default value: 0xf             */
     SOC_PETRA_REG_FIELD gci_lb2_ipt_bfmc_fc_map;

     /* GciBckof2IptGfmcFcMap: Enable GCI back-off to IPT GFMC       */
     /* scheduler flow control. 0- Timer 1 1- Timer 2 2- Timer 3     */
     /* range: 14:12, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD gci_bckof2_ipt_gfmc_fc_map;

     /* GciBckof2IptBfmcFcMap: Enable GCI back-off to IPT BFMC       */
     /* scheduler flow control. 0- Timer 1 1- Timer 2 2- Timer 3     */
     /* range: 18:16, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD gci_bckof2_ipt_bfmc_fc_map;

  } __ATTRIBUTE_PACKED__ ipt_intrnl_fmc_fc_map_reg;

  /* Ipt Fmc Ips Fc Map1: Maps IPT's generated flow controls        */
  /* to IPS credit generators                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09a1 */

     /* GciLb2IpsGfmcFcMap: Enable GCI leaky buckets to IPS's        */
     /* GFMC credit generator. 0- LB1 1- LB2 2- LB3 3- LB4           */
     /* range: 3:0, access type: RW, default value: 0x8              */
     SOC_PETRA_REG_FIELD gci_lb2_ips_gfmc_fc_map;

     /* GciLb2IpsBfmc2FcMap: Enable GCI leaky buckets to IPS's       */
     /* BFMC2 credit generator. 0- LB1 1- LB2 2- LB3 3- LB4          */
     /* range: 7:4, access type: RW, default value: 0xc              */
     SOC_PETRA_REG_FIELD gci_lb2_ips_bfmc2_fc_map;

     /* GciLb2IpsBfmc1FcMap: Enable GCI leaky buckets to IPS's       */
     /* BFMC1 credit generator. 0- LB1 1- LB2 2- LB3 3- LB4          */
     /* range: 11:8, access type: RW, default value: 0xe             */
     SOC_PETRA_REG_FIELD gci_lb2_ips_bfmc1_fc_map;

     /* GciLb2IpsBfmc0FcMap: Enable GCI leaky buckets to IPS's       */
     /* BFMC0 credit generator. 0- LB1 1- LB2 2- LB3 3- LB4          */
     /* range: 15:12, access type: RW, default value: 0xf            */
     SOC_PETRA_REG_FIELD gci_lb2_ips_bfmc0_fc_map;

     /* GciBckof2IpsGfmcFcMap: Enable GCI back-off flow control      */
     /* to IPS's GFMC credit generator. 0- Timer 1 1- Timer 2 2-     */
     /* Timer 3                                                      */
     /* range: 18:16, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD gci_bckof2_ips_gfmc_fc_map;

     /* GciBckof2IpsBfmc2FcMap: Enable GCI back-off flow control     */
     /* to IPS's BFMC2 credit generator. 0- Timer 1 1- Timer 2       */
     /* 2- Timer 3                                                   */
     /* range: 22:20, access type: RW, default value: 0x6            */
     SOC_PETRA_REG_FIELD gci_bckof2_ips_bfmc2_fc_map;

     /* GciBckof2IpsBfmc1FcMap: Enable GCI back-off flow control     */
     /* to IPS's BFMC1 credit generator. 0- Timer 1 1- Timer 2       */
     /* 2- Timer 3                                                   */
     /* range: 26:24, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD gci_bckof2_ips_bfmc1_fc_map;

     /* GciBckof2IpsBfmc0FcMap: Enable GCI back-off flow control     */
     /* to IPS's BFMC0 credit generator. 0- Timer 1 1- Timer 2       */
     /* 2- Timer 3                                                   */
     /* range: 30:28, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD gci_bckof2_ips_bfmc0_fc_map;

  } __ATTRIBUTE_PACKED__ ipt_fmc_ips_fc_map1_reg;

  /* Ipt Fmc Ips Fc Map2: Maps IPT's generated flow controls        */
  /* to IPS credit generators                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09a2 */

     /* Mci2IpsGfmcFcMap: Enable MCI level flow control to IPS's     */
     /* GFMC credit generator. Bit 1:0 - MCI1, MCI0                  */
     /* range: 1:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD mci2_ips_gfmc_fc_map;

     /* Mci2IpsBfmc2FcMap: Enable MCI level flow control to          */
     /* IPS's BFMC credit generator. Bit 1:0 - MCI1, MCI0            */
     /* range: 3:2, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD mci2_ips_bfmc2_fc_map;

     /* Mci2IpsBfmc1FcMap: Enable MCI level flow control to          */
     /* IPS's BFMC credit generator. Bit 1:0 - MCI1, MCI0            */
     /* range: 5:4, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD mci2_ips_bfmc1_fc_map;

     /* Mci2IpsBfmc0FcMap: Enable MCI level flow control to          */
     /* IPS's BFMC credit generator. Bit 1:0 - MCI1, MCI0            */
     /* range: 7:6, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD mci2_ips_bfmc0_fc_map;

     /* FmcBdq2IpsGfmcFcMap: Enable BDQs level flow control to       */
     /* IPS's GFMC credit generator (IPT's FMC contexts). Bit 1      */
     /* - IPT's GFMC BDQ level compared to DpqMcTh4 Bit0 - IPT's     */
     /* BFMC BDQ leve l compared to DpqMcTh5                         */
     /* range: 9:8, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD fmc_bdq2_ips_gfmc_fc_map;

     /* FmcBdq2IpsBfmc2FcMap: Enable BDQs level flow control to      */
     /* IPS's BFMC2 credit generator (IPT's FMC contexts). Bit 1     */
     /* - IPT's GFMC BDQ level compared to DpqMcTh4 Bit0 - IPT's     */
     /* BFMC BDQ level compared to DpqMcTh5                          */
     /* range: 11:10, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fmc_bdq2_ips_bfmc2_fc_map;

     /* FmcBdq2IpsBfmc1FcMap: Enable BDQs level flow control to      */
     /* IPS's BFMC1 credit generator (IPT's FMC contexts). Bit 1     */
     /* - IPT's GFMC BDQ level compared to DpqMcTh4 Bit0 - IPT's     */
     /* BFMC BDQ leve l compared to DpqMcTh5                         */
     /* range: 13:12, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fmc_bdq2_ips_bfmc1_fc_map;

     /* FmcBdq2IpsBfmc0FcMap: Enable BDQs level flow control to      */
     /* IPS's BFMC0 credit generator (IPT's FMC contexts). Bit 1     */
     /* - IPT's GFMC BDQ level compared to DpqMcTh4 Bit0 - IPT's     */
     /* BFMC BDQ leve l compared to DpqMcTh5                         */
     /* range: 15:14, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fmc_bdq2_ips_bfmc0_fc_map;

  } __ATTRIBUTE_PACKED__ ipt_fmc_ips_fc_map2_reg;

  /* Debug Controls: Debug configurations.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09d0 */

     /* GciMciCntSel: 3'b000- Count values of '00'. 3'b001-          */
     /* Count values of '01'. 3'b010 - Count values of '10'.         */
     /* 3'b011- Count values of '11'. 3'b100 - Count all non         */
     /* '00' incoming GCI/MCI indications. Else - Count all          */
     /* incoming GCI/MCI indications.                                */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci_mci_cnt_sel;

     /* MciCntEn: If set then the GciCnt will count MCI              */
     /* indication based on the GciMciCntSel configuration,          */
     /* otherwise, it will count GCI infdications.                   */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mci_cnt_en;

     /* EgqCntSel: Defines the source of the EGQ counter. 2'h0-      */
     /* Count only TDM packets. 2'h1- Count only CNM packets         */
     /* Else -Count all packets.                                     */
     /* range: 5:4, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD egq_cnt_sel;

     /* FdtDtqRdDis: If set, then FDT TX Data and Control fifos      */
     /* read is disabled. Note: this bit must stay 0 for normal      */
     /* IPT operation.                                               */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdt_dtq_rd_dis;

     /* EgqDtqRdDis: If set, then EGQ TX Data and Control fifos      */
     /* read is disabled. Note: this bit must stay 0 for normal      */
     /* IPT operation.                                               */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_dtq_rd_dis;

  } __ATTRIBUTE_PACKED__ debug_controls_reg;

  /* Cfg Event Cnt: Configurable event counter                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09d1 */

     /* CfgEventCnt: The counter counts event defined by             */
     /* CfgEventCntSel. This register is clear on read.              */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cfg_event_cnt;

     /* CfgEventCntOvf: If set, then indicates that CfgEventCnt      */
     /* has overflowed.                                              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cfg_event_cnt_ovf;

  } __ATTRIBUTE_PACKED__ cfg_event_cnt_reg;

  /* Gci Mci Cnt: Incoming GCI or MCI counter                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09d2 */

     /* GciMciCnt: Count incoming GCI arrived from the FDR           */
     /* (Fabric and FDR). The counter will account according to      */
     /* GciMciCntSel configuration. This register is clear on        */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD gci_mci_cnt;

     /* GciMciCntOvf: If set, then indicates that GciMciCnt has      */
     /* overflowed.                                                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD gci_mci_cnt_ovf;

  } __ATTRIBUTE_PACKED__ gci_mci_cnt_reg;

  /* Enq Pkt Cnt: ENQ packet counter (IQM)                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09d3 */

     /* EnqPktCnt: Coutns the packets received from the IQM.         */
     /* (This does not account for CNM packet) The counter can       */
     /* be configured to count per IPT BDQ number, accordin to       */
     /* QnumCntSel and QnumCntSelEn. This register is clear on       */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD enq_pkt_cnt;

     /* EnqPktCntOvf: If set, then indicates that EnqPktCnt has      */
     /* overflowed.                                                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD enq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ enq_pkt_cnt_reg;

  /* Egq Pkt Cnt: EGQ packet counter                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09d4 */

     /* EgqPktCnt: Coutns the packets forwarded to the EGQ.          */
     /* Note:The counter source is defined by EgqCntSel. This        */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD egq_pkt_cnt;

     /* EgqPktCntOvf: If set, then indicates that EgqPktCnt has      */
     /* overflowed.                                                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ egq_pkt_cnt_reg;

  /* Fdt Pkt Cnt: FDT packet counter                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09d5 */

     /* FdtPktCnt: Coutns the packets forwarded to the FDT. This     */
     /* counter can be configured to count per FDT Qnumber,          */
     /* according to FdtQnumCntSel. This register is clear on        */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fdt_pkt_cnt;

     /* FdtPktCntOvf: If set, then indicates that FdtPktCnt has      */
     /* overflowed.                                                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdt_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ fdt_pkt_cnt_reg;

  /* Lst Rd Dbuff: Last read DRAM buffer.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09d6 */

     /* LstRdDbuff: Presents the last read dram buffer number.       */
     /* In case of CRC error the Dran buffer number is latched,      */
     /* untill read. This register is clear on read.                 */
     /* range: 20:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lst_rd_dbuff;

     /* LstRdDbuffFreezed: If set, then LstRdDbuff is freezed        */
     /* due to CRC error detected.                                   */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD lst_rd_dbuff_freezed;

     /* LstRdDbuffValid: If set, then LstRdDbuff presents valid      */
     /* value.                                                       */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD lst_rd_dbuff_valid;

  } __ATTRIBUTE_PACKED__ lst_rd_dbuff_reg;

  /* Fdt Num Links Status0: FDT reported links (low                 */
  /* set)Presents the number of links reported by the FDT,          */
  /* for each of the IPT contexts.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09d7 */

     /* FdtNumLinks0: Number of active links reported for            */
     /* context 0. Note: in close mode (non-mesh) this presents      */
     /* the total number of fabric links.                            */
     /* range: 5:0, access type: RO, default value: 0x6              */
     SOC_PETRA_REG_FIELD fdt_num_links0;

     /* FdtNumLinks1: Number of active links reported for            */
     /* context 1.                                                   */
     /* range: 11:6, access type: RO, default value: 0x6             */
     SOC_PETRA_REG_FIELD fdt_num_links1;

     /* FdtNumLinks2: Number of active links reported for            */
     /* context 2.                                                   */
     /* range: 17:12, access type: RO, default value: 0x6            */
     SOC_PETRA_REG_FIELD fdt_num_links2;

     /* FdtNumLinks3: Number of active links reported for            */
     /* context 3.                                                   */
     /* range: 23:18, access type: RO, default value: 0x6            */
     SOC_PETRA_REG_FIELD fdt_num_links3;

     /* FdtNumLinks4: Number of active links reported for            */
     /* context 5.                                                   */
     /* range: 29:24, access type: RO, default value: 0x6            */
     SOC_PETRA_REG_FIELD fdt_num_links4;

  } __ATTRIBUTE_PACKED__ fdt_num_links_status_reg[SOC_PB_IPT_FDT_NUM_LINKS_STATUS_REG_NOF_REGS];

  /* Fifos Max Occ0: Bdqs and Dtqs maximal occupancy                */
  /* values. Watermark of IPT's internal fifos.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09d9 */

     /* BdqMaxOc: BDQ maximal occupancy. Presents the highest        */
     /* fifo size in the BDQs FIFOs (watermark). Units of Dram       */
     /* buffers or packet descriptor. The field is reset once        */
     /* read. This register is clear on read.                        */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bdq_max_oc;

     /* BdqMaxOcQnum: The Q number of the Bdq with the maximal       */
     /* occupancy.                                                   */
     /* range: 18:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bdq_max_oc_qnum;

     /* DtqMaxOc: DTQ (FDT Tx Data fifos) maximal occupancy.         */
     /* Presents the highest fifo size in the DTQs FIFOs             */
     /* (watermark). Out of the 7 DTQs pointing the FDT. Units       */
     /* of 64 byte words. The field is reset once read. This         */
     /* register is clear on read.                                   */
     /* range: 28:19, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD dtq_max_oc;

     /* DtqMaxOcQnum: The Q number of the DTQ (FDT Tx Data           */
     /* fifos) with the maximal occupancy.                           */
     /* range: 31:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD dtq_max_oc_qnum;

  } __ATTRIBUTE_PACKED__ fifos_max_occ0_reg;

  /* Fifos Max Oc1: Mop and EGQ-Tx maximal occupancy                */
  /* values. Watermark of IPT's internal fifos.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09da */

     /* EgqTxFifoMaxOc: EGQ TX FIFO maximal occupancy. Presents      */
     /* the highest size the EGQ TX has reached since last read      */
     /* (watermark). Units of 32 bytes of packet paylod. The         */
     /* field is reset once read. This register is clear on          */
     /* read.                                                        */
     /* range: 5:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_tx_fifo_max_oc;

     /* MopFifoMaxOc: MOP FIFO maximal occupancy. Presents the       */
     /* highest size the MOP has reached since last read             */
     /* (watermark). Units of Dram buffers or packet descriptor.     */
     /* The field is reset once read. This register is clear on      */
     /* read.                                                        */
     /* range: 20:10, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mop_fifo_max_oc;

  } __ATTRIBUTE_PACKED__ fifos_max_oc1_reg;

  /* Gci Lky Max Oc1: GCI leaky buckets watermarks                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09dd */

     /* GciLbMaxVal1: GCI leaky bucket number 0 maximal value.       */
     /* Will present the maximal value reached since last read.      */
     /* This register is clear on read.                              */
     /* range: 7:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci_lb_max_val1;

     /* GciLbMaxVal2: Same for Leaky bucket 1.                       */
     /* range: 15:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD gci_lb_max_val2;

     /* GciLbMaxVal3: Same for Leaky bucket 2.                       */
     /* range: 23:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD gci_lb_max_val3;

     /* GciLbMaxVal4: Same for Leaky bucket 3.                       */
     /* range: 31:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD gci_lb_max_val4;

  } __ATTRIBUTE_PACKED__ gci_lky_max_oc1_reg;

  /* Fmc Fc Status Vec: IPT FMC flow control state vectorThe        */
  /* register presents the variouseFabric multicast flow            */
  /* control indications. Note: all are steacky bits. Cleared        */
  /* on read.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09de */

     /* Gci2IptBkffGfmcFc: Gci backoff FC to IPT guranteed           */
     /* fabric multicast.                                            */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci2_ipt_bkff_gfmc_fc;

     /* Gci2IptBkffBfmcFc: Gci backoff FC to IPT best-effort         */
     /* fabric multicast.                                            */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci2_ipt_bkff_bfmc_fc;

     /* Gci2IptLb0Fc: Leaky bucket 0 FMC FC to IPT (Guranteed)       */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci2_ipt_lb0_fc;

     /* Gci2IptLb1Fc: Leaky bucket 1 FMC FC to IPT (Best effort)     */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci2_ipt_lb1_fc;

     /* Gci2IptMci0Fc: MCI 0 FMC FC to IPT (Guranteed)               */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci2_ipt_mci0_fc;

     /* Gci2IptMci1Fc: MCI 1 FMC FMC FC to IPT (Best effort)         */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci2_ipt_mci1_fc;

     /* Gci2IptFmcFc0: Combined FC to the GFMC PQDQ in the IPT.      */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci2_ipt_fmc_fc0;

     /* Gci2IptFmcFc1: Combined FC to the BFMC PQDQ in the IPT.      */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci2_ipt_fmc_fc1;

     /* Gci2IpsBkffGfmcFc: Gci backoff FC to IPS best-effort         */
     /* fabric multicast.                                            */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci2_ips_bkff_gfmc_fc;

     /* Gci2IpsBkffBfmc0Fc: Gci backoff FC best-effort fabric        */
     /* multicast 0 to IPS                                           */
     /* range: 9:9, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci2_ips_bkff_bfmc0_fc;

     /* Gci2IpsBkffBfmc1Fc: Gci backoff flow-control best-effort     */
     /* fabric multicast 1 to IPS                                    */
     /* range: 10:10, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD gci2_ips_bkff_bfmc1_fc;

     /* Gci2IpsBkffBfmc2Fc: Gci backoff flow-control best-effort     */
     /* fabric multicast 2 to IPS                                    */
     /* range: 11:11, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD gci2_ips_bkff_bfmc2_fc;

     /* Gci2IpsLb0Fc: Leaky bucket FMC0 FC to IPS                    */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD gci2_ips_lb0_fc;

     /* Gci2IpsLb1Fc: Leaky bucket FMC1 FC to IPS                    */
     /* range: 13:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD gci2_ips_lb1_fc;

     /* Gci2IpsLb2Fc: Leaky bucket FMC2 FC to IPS                    */
     /* range: 14:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD gci2_ips_lb2_fc;

     /* Gci2IpsLb3Fc: Leaky bucket GMC FC to IPS (Guranteed)         */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD gci2_ips_lb3_fc;

     /* Mci2IpsBfmc0Fc: Mci FC to IPS BFMC0                          */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mci2_ips_bfmc0_fc;

     /* Mci2IpsBfmc1Fc: Mci FC to IPS BFMC1                          */
     /* range: 17:17, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mci2_ips_bfmc1_fc;

     /* Mci2IpsBfmc2Fc: Mci FC to IPS BFMC2                          */
     /* range: 18:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mci2_ips_bfmc2_fc;

     /* Mci2IpsGfmcFc: Mci FC to IPS GFMC                            */
     /* range: 19:19, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mci2_ips_gfmc_fc;

     /* Ipt2IpsGfmcFc: Combined GFMC FC indication to IPS            */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipt2_ips_gfmc_fc;

     /* Ipt2IpsBfmc0Fc: Combined BFMC 0 FC indication to IPS         */
     /* range: 21:21, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipt2_ips_bfmc0_fc;

     /* Ipt2IpsBfmc1Fc: Combined GFMC 1 FC indication to IPS         */
     /* range: 22:22, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipt2_ips_bfmc1_fc;

     /* Ipt2IpsBfmc2Fc: Combined GFMC 2 FC indication to IPS         */
     /* range: 23:23, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipt2_ips_bfmc2_fc;

  } __ATTRIBUTE_PACKED__ fmc_fc_status_vec_reg;

  /* Gen Fc Status Vec: General BDQ based flow control status       */
  /* register. Presents flow-control that the IPT present to         */
  /* the IPS's DQCQs.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09df */

     /* Ipt2IpsBdqFc: BDQs level based flow control to IPS's         */
     /* DQCQs. Based on threshold registers: DpqTh0-15. Note:        */
     /* the flow controls are in pairs, where the even indexes       */
     /* refer to high-priority Qs in the IPT and in the IPS. In      */
     /* case of force-local the IPS will relate only to indexes      */
     /* 0 (high-p) and 1(low-p). This register is clear on read.     */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ipt2_ips_bdq_fc;

     /* Ipt2IpsFmcBdqFc: BDQs 4 and 5 level based flow control       */
     /* to IPS's DQCQs Based on FMC thresholds (DpqMcTh4 and         */
     /* DpqMcTh5). Context 4 related to GFMC. Context 5 related      */
     /* to BFMC 0,1,2.                                               */
     /* range: 17:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipt2_ips_fmc_bdq_fc;

  } __ATTRIBUTE_PACKED__ gen_fc_status_vec_reg;

  /* Gci Bkff Level: GCI random backoff - congestion level          */
  /* maximal value                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x09e0 */

     /* GciBkffMaxLevel: Presents the maximal level of the           */
     /* congestion sevirity level. The sevirity level is a           */
     /* runing average of the incoming GCI indications               */
     /* (increased by 2^16). The value is reset when read. This      */
     /* register is clear on read.                                   */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD gci_bkff_max_level;

  } __ATTRIBUTE_PACKED__ gci_bkff_level_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_IPT_REGS;
/* Block definition: MMU */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a00 */

     /* ErrorEcc: If set, indicates an ECC error.                    */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_ecc;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Ecc Interrupt Register: This register contains the             */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a01 */

     /* WafaaEccErr: If set, indicates there was an ECC error.       */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafaa_ecc_err;

     /* WafabEccErr: If set, indicates there was an ECC error.       */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafab_ecc_err;

     /* WafacEccErr: If set, indicates there was an ECC error.       */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafac_ecc_err;

     /* WafadEccErr: If set, indicates there was an ECC error.       */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafad_ecc_err;

     /* WafaeEccErr: If set, indicates there was an ECC error.       */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafae_ecc_err;

     /* WafafEccErr: If set, indicates there was an ECC error.       */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafaf_ecc_err;

     /* WafbaEccErr: If set, indicates there was an ECC error.       */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafba_ecc_err;

     /* WafbbEccErr: If set, indicates there was an ECC error.       */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbb_ecc_err;

     /* WafbcEccErr: If set, indicates there was an ECC error.       */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbc_ecc_err;

     /* WafbdEccErr: If set, indicates there was an ECC error.       */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbd_ecc_err;

     /* WafbeEccErr: If set, indicates there was an ECC error.       */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wafbe_ecc_err;

     /* WafbfEccErr: If set, indicates there was an ECC error.       */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wafbf_ecc_err;

     /* RafaEccErr: If set, indicates there was an ECC error.        */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafa_ecc_err;

     /* RafbEccErr: If set, indicates there was an ECC error.        */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafb_ecc_err;

     /* RafcEccErr: If set, indicates there was an ECC error.        */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafc_ecc_err;

     /* RafdEccErr: If set, indicates there was an ECC error.        */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafd_ecc_err;

     /* RafeEccErr: If set, indicates there was an ECC error.        */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafe_ecc_err;

     /* RaffEccErr: If set, indicates there was an ECC error.        */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD raff_ecc_err;

     /* WfafaEccErr: If set, indicates there was an ECC error.       */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafa_ecc_err;

     /* WfafbEccErr: If set, indicates there was an ECC error.       */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafb_ecc_err;

     /* WfafcEccErr: If set, indicates there was an ECC error.       */
     /* range: 20:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafc_ecc_err;

     /* WfafdEccErr: If set, indicates there was an ECC error.       */
     /* range: 21:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafd_ecc_err;

     /* WfafeEccErr: If set, indicates there was an ECC error.       */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafe_ecc_err;

     /* WfaffEccErr: If set, indicates there was an ECC error.       */
     /* range: 23:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfaff_ecc_err;

     /* RfafaEccErr: If set, indicates there was an ECC error.       */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafa_ecc_err;

     /* RfafbEccErr: If set, indicates there was an ECC error.       */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafb_ecc_err;

     /* RfafcEccErr: If set, indicates there was an ECC error.       */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafc_ecc_err;

     /* RfafdEccErr: If set, indicates there was an ECC error.       */
     /* range: 27:27, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafd_ecc_err;

     /* RfafeEccErr: If set, indicates there was an ECC error.       */
     /* range: 28:28, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafe_ecc_err;

     /* RfaffEccErr: If set, indicates there was an ECC error.       */
     /* range: 29:29, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfaff_ecc_err;

     /* IdfEccErr: If set, indicates there was an ECC error.         */
     /* range: 30:30, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD idf_ecc_err;

     /* FdfEccErr: If set, indicates there was an ECC error.         */
     /* range: 31:31, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdf_ecc_err;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a10 */

     /* ErrorEccMask: Writing 0 masks the corresponding              */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_ecc_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Ecc Interrupt Register Mask: Each bit in this register         */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a11 */

     /* WafaaEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafaa_ecc_err_mask;

     /* WafabEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafab_ecc_err_mask;

     /* WafacEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafac_ecc_err_mask;

     /* WafadEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafad_ecc_err_mask;

     /* WafaeEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafae_ecc_err_mask;

     /* WafafEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafaf_ecc_err_mask;

     /* WafbaEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafba_ecc_err_mask;

     /* WafbbEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbb_ecc_err_mask;

     /* WafbcEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbc_ecc_err_mask;

     /* WafbdEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbd_ecc_err_mask;

     /* WafbeEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wafbe_ecc_err_mask;

     /* WafbfEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wafbf_ecc_err_mask;

     /* RafaEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafa_ecc_err_mask;

     /* RafbEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafb_ecc_err_mask;

     /* RafcEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafc_ecc_err_mask;

     /* RafdEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafd_ecc_err_mask;

     /* RafeEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafe_ecc_err_mask;

     /* RaffEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD raff_ecc_err_mask;

     /* WfafaEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafa_ecc_err_mask;

     /* WfafbEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafb_ecc_err_mask;

     /* WfafcEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafc_ecc_err_mask;

     /* WfafdEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafd_ecc_err_mask;

     /* WfafeEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafe_ecc_err_mask;

     /* WfaffEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfaff_ecc_err_mask;

     /* RfafaEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafa_ecc_err_mask;

     /* RfafbEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafb_ecc_err_mask;

     /* RfafcEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafc_ecc_err_mask;

     /* RfafdEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafd_ecc_err_mask;

     /* RfafeEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafe_ecc_err_mask;

     /* RfaffEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfaff_ecc_err_mask;

     /* IdfEccErrMask: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD idf_ecc_err_mask;

     /* FdfEccErrMask: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdf_ecc_err_mask;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_register_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a20 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a21 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a22 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_2;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a23 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_3;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a24 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_4;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a25 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_5;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a26 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_6;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a27 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_7;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a28 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_8;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a29 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_9;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2a */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_10;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2b */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_11;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2c */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_12;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2d */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_13;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2e */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_14;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2f */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_15;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a30 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a31 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a32 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_2;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a33 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_3;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a34 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_4;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a35 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_5;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a36 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_6;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a37 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_7;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a38 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_8;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a39 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_9;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3a */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_10;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3b */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_11;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3c */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_12;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3d */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_13;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3e */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_14;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3f */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_15;

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a40 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically set          */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to        */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a41 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;
  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a42 */

     /* IndirectCommandDataIncrement:                                */
     /* IndirectCommandWrData[31:0] is incremented by this value     */
     /* after every indirect write. Addition is cyclic.              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_MMU_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* General Configuration Register: MMU General                    */
  /* Configuration bits.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a60 */

     /* DramBankNum: The number of banks per DRAM. 0-: 4 banks.      */
     /* 1-: 8 banks                                                  */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dram_bank_num;

     /* DramNum: The number of DRAMs. 0-: 6 DRAMs. 1-: 4 DRAMs.      */
     /* DRAMs C, F are not used. 2-: 3 DRAMs. DRAMs D, E, F are      */
     /* not used. 3-: 2 DRAMs. DRAMs B, C, E, F are not used.        */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dram_num;

     /* ScramblingBitPosition: Relevant when                         */
     /* ConsBanksAddrMapMode is set for 4/2 DRAM scenario.           */
     /* Should be set to 0 for 4 DRAMs. For 2 DRAMs should be        */
     /* set in the following manner: 0-: Buffer size up to 1024B     */
     /* 1-: Buffer size of 2048B 2,3-: Reserved                      */
     /* range: 7:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD scrambling_bit_position;

     /* DramColNum: The number of DRAM columns. 0-: 256 columns      */
     /* 1-: 512 columns 2-: 1024 columns 3-: 2048 columns 4-:        */
     /* 4096 columns 5, 6, 7-: 8192 columns                          */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dram_col_num;

     /* BankInterleavingMode: Relevant for working with 4 DRAMs      */
     /* only. Determines the number of bits to use for               */
     /* scrambling the address. 0-: 3 bits 1-: 4 bits 2-: 5 bits     */
     /* 3-: 6 bits 4-: 7 bits 5-: Reserved 6-: Reserved 7-:          */
     /* Reserved                                                     */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bank_interleaving_mode;

     /* InterleavingRvrseMode: Relevant for working with 4 DRAMs     */
     /* only. If this bit is set, the cell_address bits will be      */
     /* reversed before the bit scrambling is done.                  */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD interleaving_rvrse_mode;

     /* ConsBanksAddrMapMode: If set, uses a mapping function        */
     /* that sends consecutive words to consecutive banks            */
     /* range: 17:17, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cons_banks_addr_map_mode;

     /* LayerPeriodicity: Relevant for working with 6 DRAMs.         */
     /* range: 19:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD layer_periodicity;

     /* ReadFifosAllowed: Configures the minimum number of Read      */
     /* FIFOs that should be active in order to allow read           */
     /* command execution. A value of 0 disables this mechanism.     */
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD read_fifos_allowed;

     /* MinReadCommands: Configures the minimum number of            */
     /* commands to be performed even if there are not enough        */
     /* active FIFOs (to prevent deadlocks)                          */
     /* range: 31:24, access type: RW, default value: 0x20           */
     SOC_PETRA_REG_FIELD min_read_commands;

  } __ATTRIBUTE_PACKED__ general_configuration_reg;

  /* Bank Access Controller Configurations: This register           */
  /* contains general configuration bits for the Bank Access        */
  /* Controller (BAC) block.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a61 */

     /* WriteInhibitCntSat: Write Inhibit Counter Saturation         */
     /* Value - The number of consecutive READ commands each BAC     */
     /* can perform before switching to a WRITE command.             */
     /* range: 8:0, access type: RW, default value: 0x40             */
     SOC_PETRA_REG_FIELD write_inhibit_cnt_sat;

     /* AddressMapConfigGen: Determines the number of                */
     /* consecutive commands going to the same bank. This            */
     /* register affects the data written to the MMU FIFOs. The      */
     /* number of consecutive commands is                            */
     /* (2^AddressMapConfigGen). This register should not be         */
     /* configured with a value higher than 3.                       */
     /* range: 14:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD address_map_config_gen;

     /* AddressMapConfigRd: Determines the number of consecutive     */
     /* commands going to the same bank. This register affects       */
     /* the data read from the MMU FIFOs. The number of              */
     /* consecutive commands is (2^AddressMapConfigRd). Writing      */
     /* a value of 0x7 to this field allows unlimited commands       */
     /* to the same bank                                             */
     /* range: 18:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD address_map_config_rd;

     /* WrCmdDistance: Determines the number of commands between     */
     /* consecutive commands to the same bank (not the same row)     */
     /* range: 23:20, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD wr_cmd_distance;

     /* AllowConsecutive16Byte: If set, allows the BAC to send       */
     /* two consecutive 16B commands to the DRC. This bit can        */
     /* only be asserted if DRAM frequency < 2 * core frequency      */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD allow_consecutive16_byte;
     /* range: 25:25, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD pbhm;

     /* IndirectLogicalMode: This mode is relevant for indirect      */
     /* accesses going to the external DRAM. If set, the             */
     /* indirect address will represent the DRAM logical address     */
     /* (before address translator has converted it into the         */
     /* physical address). Otherwise, the indirect address           */
     /* represents the DRAM physical address.                        */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_logical_mode;

     /* FbcWrPriorityEnable: If set, the FBC write requests have     */
     /* priority over the regular packet read requests.              */
     /* range: 27:27, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fbc_wr_priority_enable;

     /* WrPriorityMode: Determines whether write commands will       */
     /* have priority over read commands in the BAC arbiter. 0-:     */
     /* Absolute priority to write commands 1-: Priority to          */
     /* write commands only when write is congested 2-: No           */
     /* priority 3-: Reserved                                        */
     /* range: 29:28, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD wr_priority_mode;

  } __ATTRIBUTE_PACKED__ bank_access_controller_configurations_reg;

  /* Ipt Data Fifo Configuration Register: This register            */
  /* configures the MMU IDF thresholds.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a62 */

     /* IdfPktTh: Determines the number of packet descriptors        */
     /* that can be stored in the PDC IPT Descriptor FIFO.           */
     /* range: 10:0, access type: RW, default value: 0x7ff           */
     SOC_PETRA_REG_FIELD idf_pkt_th;

     /* IdfSizeTh: Determines the number of bytes (in units of       */
     /* 64B) that can be stored in the PDC IPT Descriptor FIFO.      */
     /* range: 30:12, access type: RW, default value: 19'h7ffff      */
     SOC_PETRA_REG_FIELD idf_size_th;

     /* IdfUseSizeTh: If asserted, IDFSizeTh is used to              */
     /* determine the number of descriptors stored in the PDC        */
     /* IPT Descriptor FIFO. Otherwise, IPTPktTh is used.            */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD idf_use_size_th;

  } __ATTRIBUTE_PACKED__ ipt_data_fifo_configuration_reg;

  /* Idr Descriptor Counter: This register counts the number        */
  /* of descriptors sent from the IDR.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a64 */

     /* IdrDescCnt: IDR Descriptor debug counter. The counter        */
     /* counts descriptors coming from the IDR. This register is     */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD idr_desc_cnt;

     /* IdrDescCntOvf: IdrDescCnt overflow indication. When          */
     /* using CntByGt (count by gtime), the bit means                */
     /* "finished".                                                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD idr_desc_cnt_ovf;

  } __ATTRIBUTE_PACKED__ idr_descriptor_counter_reg;

  /* Ipt Descriptor Counter: This register counts the number        */
  /* of descriptors sent from the IPT.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a65 */

     /* IptDescCnt: IPT Descriptor debug counter. The counter        */
     /* counts descriptors coming from the IPT. This register is     */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ipt_desc_cnt;

     /* IptDescCntOvf: IPTDescCnt overflow indication. When          */
     /* using CntByGt (count by gtime), the bit means                */
     /* "finished".                                                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipt_desc_cnt_ovf;

  } __ATTRIBUTE_PACKED__ ipt_descriptor_counter_reg;

  /* Global Time Counter: Gtimer configuration.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a66 */

     /* GtPrd: Global timer period. Gtimer expires after             */
     /* TimePrd. Default value equivalent to 1[sec] @ 250[MHz]       */
     /* range: 30:0, access type: RW, default value: 31'hEE6B280     */
     SOC_PETRA_REG_FIELD gt_prd;

     /* GtRstCntrs: If asserted then all related counters are        */
     /* cleared when GtCntTrg is asserted.                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gt_rst_cntrs;

  } __ATTRIBUTE_PACKED__ global_time_counter_reg;

  /* Global Time Counter Trigger: Gtimer trigger.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a67 */

     /* GlbCntTrg: When set, the global-counter counter starts.      */
     /* Trigger is deasserted when counter expires.                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_cnt_trg;

  } __ATTRIBUTE_PACKED__ global_time_counter_trigger_reg;

  /* Global Time Counter Configuration: Defines which               */
  /* counters count according to the global-timer.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a68 */

     /* MmuCntByGt: If set, then the MMU's counters count            */
     /* according to the GlobalTimer.                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mmu_cnt_by_gt;

  } __ATTRIBUTE_PACKED__ global_time_counter_configuration_reg;

  /* Dram Periodic Training: This register controls the             */
  /* period between DRAM training sequences.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a6a */

     /* TrainingPeriod: Configures the period between two            */
     /* consecutive DRAM training sequences, in units of 1024        */
     /* cycles (core frequency). A value of 0 disables the           */
     /* periodic training sequence.                                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD training_period;

  } __ATTRIBUTE_PACKED__ dram_periodic_training_reg;

  /* ECC Configuration register: This register is used for          */
  /* configuring MMU ECC.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a70 */

     /* DisEcc: If set, disables the ECC mechanism in the block.     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_ecc;

  } __ATTRIBUTE_PACKED__ ecc_configuration_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_MMU_REGS;
/* Block definition: DRC */
typedef struct
{
  uint32   nof_instances; /* 6 */
  SOC_PETRA_REG_ADDR addr;

  /* DDR Controller Triggers: This register contains the DRC        */
  /* triggers needed for the reset and init (initialization)        */
  /* sequences.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1800 */

     /* DDRRstn: Perform a soft reset to all DRAM controller         */
     /* registers other than this register. When asserted,           */
     /* depending on the value of DDRDefValn, the configuration      */
     /* registers are loaded with either a hardware default          */
     /* value or the programmed value currently in the               */
     /* registers.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddrrstn;

     /* DDRDefValn: When negated after reset, the hardware           */
     /* defaults are loaded; Otherwise, the CPU programmed           */
     /* values are loaded.                                           */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddrdef_valn;

     /* DDRInitDis: If set, the DRC does not perform the init        */
     /* sequence after reset.                                        */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddrinit_dis;

     /* DDRCkeDis: If set, the DRC performs the init sequence        */
     /* without de-asserting the CKE signal towards the DRAM.        */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddrcke_dis;

  } __ATTRIBUTE_PACKED__ ddr_controller_triggers_reg;

  /* DDR Mode Register1: (See the DRAM data sheet for more          */
  /* details). In DDR3, this register is referred to as MR0         */
  /* and is written only once. In other DRAM types, the Mode         */
  /* register is written twice, once with this value and once       */
  /* with a second value. This is useful for resetting the          */
  /* DLL.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1801 */

     /* ModeRegWr1: The DDR init sequence requires two separate      */
     /* writes to the MR register. The register should contain       */
     /* the value of the DRAM MR register for the first write,       */
     /* as part of the init sequence.                                */
     /* range: 31:0, access type: RW, default value: 0x153           */
     SOC_PETRA_REG_FIELD mode_reg_wr1;

  } __ATTRIBUTE_PACKED__ ddr_mode_1_reg;

  /* DDR Mode Register2: (See the DRAM data sheet for more          */
  /* details). The Mode register is written twice, once with        */
  /* this value and once with a second value. This is useful        */
  /* for resetting the DLL. Not used for DDR3 and GDDR3.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1802 */

     /* ModeRegWr2: The DDR init sequence requires two separate      */
     /* writes to the MR register. The register should contain       */
     /* the value of the DRAM MR register for the second write,      */
     /* as part of the init sequence                                 */
     /* range: 31:0, access type: RW, default value: 0x53            */
     SOC_PETRA_REG_FIELD mode_reg_wr2;

  } __ATTRIBUTE_PACKED__ ddr_mode_2_reg;

  /* DDR Extended Mode Register1: This register contains the        */
  /* value written to the EMR during the DRAM init                  */
  /* sequence. In DDR3 this register is referred to as MR1.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1803 */

     /* ExtModeWr1: The DDR init sequence requires writing to        */
     /* the EMR register. The register should contain the value      */
     /* of the DRAM EMR register for the first write as part of      */
     /* the init sequence.                                           */
     /* range: 31:0, access type: RW, default value: 0x42            */
     SOC_PETRA_REG_FIELD ext_mode_wr1;

  } __ATTRIBUTE_PACKED__ ddr_extended_mode_1_reg;

  /* AC Operating Conditions1: This register contains DRAM          */
  /* parameter configurations.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1804 */

     /* DDRtRST: Number of clocks to wait after reset (in units      */
     /* of 32 clocks). The value 0 disables the mechanism.           */
     /* range: 13:0, access type: RW, default value: 0x765           */
     SOC_PETRA_REG_FIELD ddrt_rst;

     /* DDRtDLL: Number of clocks to wait for DLL stabilization      */
     /* (in units of 256 clocks). The value 0 disables the           */
     /* mechanism.                                                   */
     /* range: 21:14, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD ddrt_dll;

     /* DDRtRC: Period between the ACTIVE to the ACTIVE/AUTO         */
     /* REFRESH commands.                                            */
     /* range: 28:22, access type: RW, default value: 0x11           */
     SOC_PETRA_REG_FIELD ddrt_rc;

  } __ATTRIBUTE_PACKED__ ac_operating_conditions1_reg;

  /* AC Operating Conditions2: This register contains DRAM          */
  /* parameter configurations.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1805 */

     /* DDRtRRD: ACTIVE bank a to ACTIVE bank b command.             */
     /* range: 3:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD ddrt_rrd;

     /* DDRtRFC: AUTO REFRESH command period - the minimal time      */
     /* between the REFRESH command and the next ACTIVE command.     */
     /* range: 11:4, access type: RW, default value: 0x13            */
     SOC_PETRA_REG_FIELD ddrt_rfc;

     /* DDRtRCDR: ACTIVE to READ delay.                              */
     /* range: 16:12, access type: RW, default value: 0x5            */
     SOC_PETRA_REG_FIELD ddrt_rcdrd;

     /* DDRtRCDW: ACTIVE to WRITE delay.                             */
     /* range: 24:20, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD ddrt_rcdwr;

  } __ATTRIBUTE_PACKED__ ac_operating_conditions2_reg;

  /* Init Sequence Register: This register controls the             */
  /* number of clocks the DRC waits before issuing command to       */
  /* the DRAM during the init sequence.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1806 */

     /* InitWaitPRD: Wait period between commands during INIT        */
     /* sequence.                                                    */
     /* range: 6:0, access type: RW, default value: 0x20             */
     SOC_PETRA_REG_FIELD init_wait_prd;

  } __ATTRIBUTE_PACKED__ init_sequence_reg;

  /* AC Operating Conditions3: In the following register, if        */
  /* working with 16B bursts, BL=2. If working with 32B             */
  /* bursts, BL=4.(See the DRAM data sheet for details and          */
  /* for the timing diagram.)                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1807 */

     /* CntRASRDPRD: Period from Active command to a Read            */
     /* command with Auto Precharge (Should be calculated as         */
     /* DDRtRAS-BL.) DDRtRAS is a DRAM parameter                     */
     /* range: 6:0, access type: RW, default value: 0x9              */
     SOC_PETRA_REG_FIELD cnt_rasrdprd;

     /* CntRASWRPRD: Period from Active command to a write           */
     /* command with Auto Precharge (Should be calculated as         */
     /* DDRtRAS-BL-DDRtWR-DDRtWL) DDRtRAS and, DDRtWR are DRAM       */
     /* parameters. DDRtWL - DRAM Write latency.                     */
     /* range: 13:7, access type: RW, default value: 0x6             */
     SOC_PETRA_REG_FIELD cnt_raswrprd;

     /* CntRDAPPRD: Period from a Read command with Auto             */
     /* Precharge untill the Precharge command period is over.       */
     /* (Should be calculated as BL+DDRtRP+max(DDRtRTP,2CK).)        */
     /* DDRtRP is a DRAM parameter.                                  */
     /* range: 19:14, access type: RW, default value: 0x9            */
     SOC_PETRA_REG_FIELD cnt_rdapprd;

     /* CntWRAPPRD: Period from a Write command with Auto            */
     /* Precharge untill the Precharge command period is over.       */
     /* (Should be calculated as BL+DDRtRP+DDRtWR+DDRtWL)            */
     /* DDRtRP, and DDRtWR are DRAM parameters. DDRtWL - DRAM        */
     /* Write latency.                                               */
     /* range: 25:20, access type: RW, default value: 0xd            */
     SOC_PETRA_REG_FIELD cnt_wrapprd;

  } __ATTRIBUTE_PACKED__ ac_operating_conditions3_reg;

  /* CPU Commands: Allows cpu control over the DDR command          */
  /* bus (fallback for init sequence).                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1808 */

     /* BankAddress: The value to be put on the bus towards the      */
     /* DRAM when CpuCMDVld is set.                                  */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bank_address;

     /* Address: The value to be put on the bus towards the DRAM     */
     /* when CpuCMDVld is set.                                       */
     /* range: 17:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD address;

     /* We n: The value to be put on the bus towards the DRAM        */
     /* when CpuCMDVld is set.                                       */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD we_n;

     /* Cas n: The value to be put on the bus towards the DRAM       */
     /* when CpuCMDVld is set.                                       */
     /* range: 21:21, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cas_n;

     /* Ras n or Ref n: The value to be put on the bus towards       */
     /* the DRAM when CpuCMDVld is set.                              */
     /* range: 22:22, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ras_n_or_ref_n;

     /* Cs n: The value to be put on the bus towards the DRAM        */
     /* when CpuCMDVld is set.                                       */
     /* range: 23:23, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cs_n;

     /* cke: The value to be put on the bus towards the DRAM         */
     /* when CpuCMDVld is set.                                       */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cke;

     /* Res: The value to be put on the bus towards the DRAM         */
     /* when CpuCMDVld is set.                                       */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD res;

     /* Odt: The value to be put on the bus towards the DRAM         */
     /* when CpuCMDVld is set.                                       */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD odt;

     /* ConstVal: When asserted, forces the values in the cke,       */
     /* Res, and Odt fields permanently on the pins going to the     */
     /* DRAM (with no regard to CpuCMDVld).                          */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD const_val;

     /* StopBACCmds: When asserted, causes crdt signal from drc      */
     /* to bac to be de-asserted and prevents commands coming        */
     /* from bac from being inserted into the command queue          */
     /* fifo.                                                        */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stop_baccmds;

     /* CpuCMDVld: When asserted, causes the CPU command as          */
     /* represented in bits 26:0 to be output towards the DDR.       */
     /* It is asserted for one clock only and is then                */
     /* de-asserted by the DRC.                                      */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpu_cmdvld;

  } __ATTRIBUTE_PACKED__ cpu_commands_reg;

  /* Training Sequence: Controls the DRAM training sequence.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1809 */

     /* DDRTrnSeqGenPrd: Generation rate of training sequence in     */
     /* units of AUTO REFRESH command periods. Each time, an         */
     /* AUTO REFRESH command is executed; the counter is             */
     /* incremented by one. The value 0x0 disables the               */
     /* generation of the training sequences. This field must        */
     /* not hold a value higher than 0x1ffe.                         */
     /* range: 12:0, access type: RW, default value: 0x10            */
     SOC_PETRA_REG_FIELD ddrtrn_seq_gen_prd;

     /* DDRTrnSeqGenNum: The number of training sequence reads,      */
     /* continuously after reset. This burst of training             */
     /* sequences should bring the aligner into the correct          */
     /* state.                                                       */
     /* range: 21:13, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ddrtrn_seq_gen_num;

     /* StartTrainSeq: When asserted, causes the DRC to start        */
     /* the training sequence. The DRC de-asserts this bit.          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD start_train_seq;

  } __ATTRIBUTE_PACKED__ training_sequence_reg;

  /* Training Sequence Word: Training sequence word.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x180a */

     /* DDRTrnSeq: Training sequence word - bits [31:0]             */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ddrtrn_seq;

  } __ATTRIBUTE_PACKED__ training_sequence_word_reg[SOC_PB_DRAM_NOF_TRAIN_SEQ_WORDS_REGS];

  /* Training Sequence Address: This register controls the          */
  /* address the DRC will use for the training sequence.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1812 */

     /* TrnSeqAdd: The address to write the training sequence        */
     /* to.                                                          */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD trn_seq_add;

     /* TrnSeqAddVal: Valid bit for the address to write the         */
     /* training sequence. If the bit is reset, the register         */
     /* TrnSeqAdd is not used (the address of the last written       */
     /* write command is used)                                       */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD trn_seq_add_val;

  } __ATTRIBUTE_PACKED__ training_sequence_address_reg;

  /* DRC General Configurations: General configurations for         */
  /* the DRAM Controller.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1813 */

     /* NumCols: Determines the number of bits used for column       */
     /* addressing according to the following table: 0 : 8           */
     /* Column bits (256 columns) 1 : 9 Column bits (512             */
     /* columns) 2 : 10 Column bits (1024 columns) 3 : 11 Column     */
     /* bits (2048 columns) 4 : 12 Column bits (4096 columns)        */
     /* 5,6,7 : Reserved                                             */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_cols;

     /* APBitPos: Determines the position of the Auto Precharge      */
     /* bit in the address going to the DRAM according to the        */
     /* following table: 0 : AP is placed on addr[8] 1 : AP is       */
     /* placed on addr[9] 2 : AP is placed on addr[10] 3 : AP is     */
     /* placed on addr[11] 4 : AP is placed on addr[12] 5,6,7 :      */
     /* Reserved                                                     */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD apbit_pos;

     /* RefreshBurstSize: The number of consecutive refresh          */
     /* commands performed by the DRC. The DRC accumulates           */
     /* refresh commands until it needs to perform                   */
     /* RefreshBurstSize commands in a single burst.                 */
     /* range: 15:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD refresh_burst_size;

     /* RefreshDelayPrd: The number of clocks the DRC waits          */
     /* between stopping the BAC commands and performing the         */
     /* refresh command. This delay period is to ensure that the     */
     /* DRC command fifo is empty when refresh commands are          */
     /* performed.                                                   */
     /* range: 29:24, access type: RW, default value: 0x14           */
     SOC_PETRA_REG_FIELD refresh_delay_prd;

  } __ATTRIBUTE_PACKED__ drc_general_configurations_reg;

  /* Write Read Rates: This register controls the minimum           */
  /* period between two consecutive commands and also               */
  /* configures tFAW and tZQCS parameters.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1814 */

     /* CntWrPrd: Minimum period between two successive Write        */
     /* commands (bursts) and is calculated as CntWrPrd + (Burst     */
     /* length / 2).                                                 */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnt_wr_prd;

     /* CntRdPrd: Minimum period between two successive Read         */
     /* commands (bursts) and is calculated as CntRdPrd + (Burst     */
     /* length / 2).                                                 */
     /* range: 13:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cnt_rd_prd;

     /* DDRtFAW: No more than 4 banks may be activated in a          */
     /* rolling tFAW window.                                         */
     /* range: 22:16, access type: RW, default value: 0x11           */
     SOC_PETRA_REG_FIELD ddrt_faw;

     /* DDRtZQCS: DDR3 only. Minimum period after ZQ calibration     */
     /* in which no other DRAM command can be performed.             */
     /* range: 31:24, access type: RW, default value: 0x40           */
     SOC_PETRA_REG_FIELD ddrt_zqcs;

  } __ATTRIBUTE_PACKED__ write_read_rates_reg;

  /* DRAM Compliance Configuration Register: This register is       */
  /* used to configure the different DRAM types supported by        */
  /* the DRC.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1815 */

     /* WrLatency: DRAM Write latency parameter.                     */
     /* range: 3:0, access type: RW, default value: 0x4              */
     SOC_PETRA_REG_FIELD wr_latency;

     /* BurstSizeMode: If this bit is asserted, the DRC accesses     */
     /* the DRAM in 16B bursts. Otherwise, 32B bursts are used.      */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD burst_size_mode;

     /* DRAMType: 0 : Reserved GDDR1 1 : GDDR3 2 : DDR2 3 :          */
     /* DDR3 4 : Reserved RLDRAM                                     */
     /* range: 10:8, access type: RW, default value: 0x2             */
     SOC_PETRA_REG_FIELD dramtype;

     /* AddrTermHalf: If this bit is asserted, the address and       */
     /* command termination are set to 1/2 of ZQ. Otherwise, the     */
     /* termination is set to ZQ.                                    */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD addr_term_half;

     /* GDDR3DummyWrite: If this bit is asserted, the DRC            */
     /* perform a dummy MRS as required by Samsungs K4J55323QF       */
     /* device as part of its initialization sequence. Other         */
     /* devices might not require such a dummy command (Relevant     */
     /* for GDDR3 only).                                             */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gddr3_dummy_write;

     /* StaticOdtEn: If this bit is asserted, the DRC will           */
     /* assert the ODT pin after loading the extended mode           */
     /* register as part of the DRAM initialization sequence         */
     /* (relevant for DDR2 only).                                    */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD static_odt_en;

     /* DDRResetPolarity: If set, the reset signal towards the       */
     /* DRAM will be active high. Default is active low.             */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddrreset_polarity;

     /* Enable8Banks: This bit should be asserted when working       */
     /* with an 8-bank DRAM.                                         */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD enable8_banks;

  } __ATTRIBUTE_PACKED__ dram_compliance_configuration_reg;

  /* Extended Mode WR2 Register: The DDR2 init sequence             */
  /* requires three separate writes to the EMR register. The        */
  /* register should contain the value of the DRAM EMR              */
  /* register for the second write, as part of the init             */
  /* sequence (relevant for DDR2 only).                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1816 */

     /* ExtModeWr2: EMR Data                                         */
     /* range: 31:0, access type: RW, default value: 0x42            */
     SOC_PETRA_REG_FIELD ext_mode_wr2;

  } __ATTRIBUTE_PACKED__ extended_mode_wr2_reg;

  /* DDR2 Extended Mode WR3 Register: The DDR2 init sequence        */
  /* requires three separate writes to the EMR register. The        */
  /* register should contain the value of the DRAM EMR              */
  /* register for the third write, as part of the init              */
  /* sequence (relevant for DDR2 only).                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1817 */

     /* ExtModeWr3: EMR Data                                         */
     /* range: 31:0, access type: RW, default value: 0x42            */
     SOC_PETRA_REG_FIELD ext_mode_wr3;

  } __ATTRIBUTE_PACKED__ ddr2_extended_mode_wr3_reg;

  /* DDR Extended Mode Register2: In DDR2, this register            */
  /* should contain the value of the DRAM EMR2 register. In          */
  /* DDR3, this register should contain the value of the DRAM       */
  /* MR2 register.(relevant for DDR2 and DDR3 only)                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1818 */

     /* EMR2: EMR2 Data                                              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD emr2;

  } __ATTRIBUTE_PACKED__ ddr_extended_mode_2_reg;

  /* DDR Extended Mode Register3: In DDR2, this register            */
  /* should contain the value of the DRAM EMR3 register. In          */
  /* DDR3, this register should contain the value of the DRAM       */
  /* MR3 register.(relevant for DDR2 and DDR3 only)                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1819 */

     /* EMR3: EMR3 Data                                              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD emr3;

  } __ATTRIBUTE_PACKED__ ddr_extended_mode_3_reg;

  /* AC Operating Conditions4: This register contains DRAM          */
  /* parameter configurations. In the following register, if         */
  /* working with 16B bursts, BL=2. If working with 32B             */
  /* bursts, BL=4.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x181a */

     /* DDRtREFI: Average periodic refresh interval, in units of     */
     /* 32 clocks. The value 0 disables the auto refresh             */
     /* mechanism.                                                   */
     /* range: 12:0, access type: RW, default value: 0x4a            */
     SOC_PETRA_REG_FIELD ddrt_refi;

     /* CntWRRDPRD: Period between a Write command and a Read        */
     /* command (Should be calculated as                             */
     /* max(DDRtWL+BL+DDRtWTR,DDRtWL+BL+DDRtWR-2)) where DDRtWTR     */
     /* is a DRAM parameter.                                         */
     /* range: 20:16, access type: RW, default value: 0x6            */
     SOC_PETRA_REG_FIELD cnt_wrrdprd;

     /* CntRDWRPRD: Period between the end of a read burst and a     */
     /* Write command. Does not include the 4 four cycles of the     */
     /* Read burst. (Should be calculated as DDRtCAS + DDRtPCB +     */
     /* 1)                                                           */
     /* range: 28:24, access type: RW, default value: 0x6            */
     SOC_PETRA_REG_FIELD cnt_rdwrprd;

  } __ATTRIBUTE_PACKED__ ac_operating_conditions4_reg;

  /* Odt Configuration Register: ZQ Calibration and Dynamic         */
  /* ODT configurations                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x181b */

     /* DDR3ZQCalibGenPrd: Generation rate of ZQ Calibration         */
     /* commands in units of AUTO REFRESH command periods. Each      */
     /* time an AUTO REFRESH command is executed; the counter is     */
     /* incremented by one. A value 0x0 disables the generation      */
     /* of the ZQ Calibration commands. (This register is            */
     /* relevant for DDR3 only.)                                     */
     /* range: 12:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ddr3_zqcalib_gen_prd;

     /* DynOdtStartDelay: This register can be used to determine     */
     /* when the external ODT pin is asserted in relation to the     */
     /* write command. If this register receives the same value      */
     /* as WrLatency, the ODT pin will be asserted one cycle         */
     /* before the write data. If this register is set to 0, the     */
     /* ODT pin will be asserted one cycle before the Write          */
     /* command.                                                     */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dyn_odt_start_delay;

     /* DynOdtLength: This counter determines the number of          */
     /* clocks the external ODT pin will be asserted every write     */
     /* command. A value of 0x0 will cause the ODT pin to be a       */
     /* constant 0.                                                  */
     /* range: 28:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dyn_odt_length;

  } __ATTRIBUTE_PACKED__ odt_configuration_reg;

  /* BIST Configurations: Configures the DRAM BIST.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1820 */

     /* WriteWeight: Number of successive write commands to be       */
     /* performed in a BIST cycle. Setting WriteWeight to 0          */
     /* results in no BIST write commands. If PatternBitMode is      */
     /* set, this parameter should be set to 1.                      */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD write_weight;

     /* ReadWeight: Number of successive read commands to be         */
     /* performed in a BIST cycle. Setting ReadWeight to 0           */
     /* results in no BIST read commands. If PatternBitMode is       */
     /* set, this parameter should be set to 1.                      */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD read_weight;

     /* PatternBitMode: If set, the BIST composes the write/read     */
     /* pattern in the following manner. For each cycle, a           */
     /* different bit is selected from the BIST pattern register     */
     /* in an incremental manner. This bit is duplicated on all      */
     /* of the DRAM data bus (all DQs receive the same bit).         */
     /* This allows a controllable pattern that is 256 write         */
     /* cycles long. If this bit is reset, the pattern used is       */
     /* BistPattern.                                                 */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pattern_bit_mode;

     /* TwoAddrMode: If this is bit is set, the address used by      */
     /* the BIST always alternates between BistStartAddress and      */
     /* BistEndAddress.                                              */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD two_addr_mode;

     /* PRBSMode: If this bit is set, the PRBS will be used to       */
     /* generate the pattern towards the DRAM                        */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD prbsmode;

     /* IndWrRdAddrMode: If this bit is set, the addresses for       */
     /* write and read commands will be incremented in an            */
     /* independent manner.                                          */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ind_wr_rd_addr_mode;

     /* ConsAddr4Banks: If this bit is set, address bits [1:0]       */
     /* will be swapped with bits [4:3]. This will cause the         */
     /* BIST to send 4 consecutive commands to the same bank         */
     /* before incrementing the bank number, This bit should         */
     /* only be used when Enable8Banks == 0.                         */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cons_addr4_banks;

     /* ConsAddr8Banks: If this bit is set, address bits [2:0]       */
     /* will be swapped with bits [5:3]. This will cause the         */
     /* BIST to send 8 consecutive commands to the same bank         */
     /* before incrementing the bank number, This bit should         */
     /* only be used when Enable8Banks == 1.                         */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cons_addr8_banks;

     /* BistEn: Enable the BIST                                      */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_en;

  } __ATTRIBUTE_PACKED__ bist_configurations_reg;

  /* BIST Number Of Actions: Configures the DRAM BIST number        */
  /* of actions.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1821 */

     /* BistNumActions: The number of actions (writes or reads)      */
     /* to be performed by the BIST. Setting this register to 0      */
     /* causes the BIST to work in infinite mode                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_num_actions;

  } __ATTRIBUTE_PACKED__ bist_number_of_actions_reg;

  /* BIST Start Address: Configures the DRAM BIST Start             */
  /* Address.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1822 */

     /* BistStartAddress: The start address used by the BIST. If     */
     /* BistStartAddress equals BistEndAddress, the BIST always      */
     /* performs write and read commands to the same address.        */
     /* Otherwise, the address will start at BistStartAddress        */
     /* and be incremented every BIST cycle. When the address        */
     /* reaches BistEndAddress, the next address will once again     */
     /* be the BistStartAddress. The address is of the format:       */
     /* \{row, column, bank\} as configured in the NumCols           */
     /* register. Each address represents a 32B burst of data.       */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_start_address;

  } __ATTRIBUTE_PACKED__ bist_start_address_reg;

  /* BIST End Address: Configures the DRAM BIST End Address.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1823 */

     /* BistEndAddress: The start address used by the BIST. If       */
     /* BistStartAddress equals BistEndAddress, the BIST always      */
     /* performs write and read commands to the same address.        */
     /* Otherwise the address will start at BistStartAddress and     */
     /* be incremented every BIST cycle. When the address            */
     /* reaches BistEndAddress, the next address will once again     */
     /* be the BistStartAddress. The address is of the format:       */
     /* \{row, column, bank\} as configured in the NumCols           */
     /* register. Each address represents a 32B burst of data.       */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_end_address;

  } __ATTRIBUTE_PACKED__ bist_end_address_reg;

  /* BIST Single Bit Mask: Configures the DRAM BIST Single          */
  /* Bit Mask.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1824 */

     /* BistSingleMask: Setting bit N in BistSingleMask results      */
     /* in SingleErrCnt incrementing if an error is discovered       */
     /* in bits N, N+32, N+64 . . . N+224 after a BIST read was      */
     /* performed                                                    */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_single_mask;

  } __ATTRIBUTE_PACKED__ bist_single_bit_mask_reg;

  /* BIST Pattern Word7: Configures the DRAM BIST Pattern.          */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x1830 */

    /* BistPattern7: BIST Pattern word 7-BistPattern[31:0]          */
    /* range: 31:0, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD bist_pattern;

  } __ATTRIBUTE_PACKED__ bist_pattern_words_regs[SOC_PB_DRAM_NOF_PATTERN_REGS];

  /* BIST Pattern Word7: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1830 */

     /* BistPattern7: BIST Pattern word 7-BistPattern[31:0]          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern7;

  } __ATTRIBUTE_PACKED__ bist_pattern_word7_reg;

  /* BIST Pattern Word6: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1831 */

     /* BistPattern6: BIST Pattern word 6-BistPattern[63:32]         */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_pattern6;

  } __ATTRIBUTE_PACKED__ bist_pattern_word6_reg;

  /* BIST Pattern Word5: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1832 */

     /* BistPattern5: BIST Pattern word 5-BistPattern[95:64]         */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_pattern5;

  } __ATTRIBUTE_PACKED__ bist_pattern_word5_reg;

  /* BIST Pattern Word4: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1833 */

     /* BistPattern4: BIST Pattern word 4-BistPattern[127:96]        */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_pattern4;

  } __ATTRIBUTE_PACKED__ bist_pattern_word4_reg;

  /* BIST Pattern Word3: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1834 */

     /* BistPattern3: BIST Pattern word 3-BistPattern[159:128]       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern3;

  } __ATTRIBUTE_PACKED__ bist_pattern_word3_reg;

  /* BIST Pattern Word2: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1835 */

     /* BistPattern2: BIST Pattern word 2-BistPattern[191:160]       */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_pattern2;

  } __ATTRIBUTE_PACKED__ bist_pattern_word2_reg;

  /* BIST Pattern Word1: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1836 */

     /* BistPattern1: BIST Pattern word 1-BistPattern[223:192]       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern1;

  } __ATTRIBUTE_PACKED__ bist_pattern_word1_reg;

  /* BIST Pattern Word0: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1837 */

     /* BistPattern0: BIST Pattern word 0-BistPattern[255:224]       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern0;

  } __ATTRIBUTE_PACKED__ bist_pattern_word0_reg;

  /* BIST Full Mask Word7: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1838 */

     /* BistFullMask7: BIST Full Mask word 7-BistFullMask[31:0].     */
     /* Setting bit N in BistFullMask results in FullErrCnt          */
     /* incrementing if an error is discovered in bit N after a      */
     /* BIST read is performed                                       */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask7;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word7_reg;

  /* BIST Full Mask Word6: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1839 */

     /* BistFullMask6: BIST Full Mask word                           */
     /* 6-BistFullMask[63:32]. Setting bit N in BistFullMask         */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask6;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word6_reg;

  /* BIST Full Mask Word5: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183a */

     /* BistFullMask5: BIST Full Mask word                           */
     /* 5-BistFullMask[95:64]. Setting bit N in BistFullMask         */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask5;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word5_reg;

  /* BIST Full Mask Word4: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183b */

     /* BistFullMask4: BIST Full Mask word                           */
     /* 4-BistFullMask[127:96]. Setting bit N in BistFullMask        */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask4;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word4_reg;

  /* BIST Full Mask Word3: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183c */

     /* BistFullMask3: BIST Full Mask word                           */
     /* 3-BistFullMask[159:128]. Setting bit N in BistFullMask       */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask3;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word3_reg;

  /* BIST Full Mask Word2: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183d */

     /* BistFullMask2: BIST Full Mask word                           */
     /* 2-BistFullMask[191:160]. Setting bit N in BistFullMask       */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask2;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word2_reg;

  /* BIST Full Mask Word1: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183e */

     /* BistFullMask1: BIST Full Mask word                           */
     /* 1-BistFullMask[223:192]. Setting bit N in BistFullMask       */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask1;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word1_reg;

  /* BIST Full Mask Word0: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183f */

     /* BistFullMask0: BIST Full Mask word                           */
     /* 0-BistFullMask[255:224]. Setting bit N in BistFullMask       */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask0;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word0_reg;

  /* BIST Statuses: Statuses coming from the DRAM BIST.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1840 */

     /* BistFinished: This bit is set when BIST has completed        */
     /* BistNumActions actions. The bit will never be asserted       */
     /* if working in infinite mode (BistNumActions == 0). This      */
     /* register is clear on read.                                   */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_finished;

     /* CqfOverflow: This bit indicates an overflow in the DRC       */
     /* Command Queue FIFO. This register is clear on read.          */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cqf_overflow;

  } __ATTRIBUTE_PACKED__ bist_statuses_reg;

  /* BIST Full Mask Error Counter:                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1841 */

     /* FullErrCnt: This counter is incremented if an error is       */
     /* discovered in bit N after a BIST read command and bit N      */
     /* is not masked by BistFullMask. The counter stops at          */
     /* saturation. The counter is reset when BIST is enabled        */
     /* and after that it can be cleared by the CPU. This            */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD full_err_cnt;

  } __ATTRIBUTE_PACKED__ bist_full_mask_error_counter_reg;

  /* BIST Single Bit Mask Error Counter:                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1842 */

     /* SingleErrCnt: This counter is incremented if an error is     */
     /* discovered in bits N, N+32, N+64 . . . N+224 after a         */
     /* BIST read command and bit N is not masked by                 */
     /* BistSingleMask. The counter stops at saturation. The         */
     /* counter is reset when BIST is enabled and after that it      */
     /* can be cleared by the CPU. This register is clear on         */
     /* read.                                                        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD single_err_cnt;

  } __ATTRIBUTE_PACKED__ bist_single_bit_mask_error_counter_reg;

  /* BIST Error Occurred:                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1843 */

     /* ErrOccurred: Bit N in this register is set if an error       */
     /* occurs in bits N, N+32, N+64 . . . N+224 after a BIST        */
     /* read command. The register is reset when BIST is enabled     */
     /* and after that it can be cleared by the CPU. This            */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD err_occurred;

  } __ATTRIBUTE_PACKED__ bist_error_occurred_reg;

  /* BIST Global Error Counter:                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1844 */

     /* GlobalErrCnt: This counter is incremented if any error       */
     /* is discovered after a BIST read command. The counter         */
     /* stops at saturation. The counter is reset when BIST is       */
     /* enabled and after that it can be cleared by the CPU.         */
     /* This register is clear on read.                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD global_err_cnt;

  } __ATTRIBUTE_PACKED__ bist_global_error_counter_reg;

  /* Training Sequence Configuration Register: This register        */
  /* is used to configure the number of addresses used as           */
  /* part of the training sequence.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1858 */

     /* TrainSeqAddrNum: Specifies the number of addresses used      */
     /* as part of the training sequence in units of 64              */
     /* addresses.                                                   */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD train_seq_addr_num;

     /* TrainSeqUsePRBS: If set, uses a PRBS pattern for the         */
     /* first part of the training sequence.                         */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD train_seq_use_prbs;

  } __ATTRIBUTE_PACKED__ training_sequence_configuration_reg;

  /* DCF Enable */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x18b0 */

     /* range: 1:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD dcf_cmd;
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dcf_ovrd_en;
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dcf_enable;

  } __ATTRIBUTE_PACKED__ dcf;

} __ATTRIBUTE_PACKED__ SOC_PB_DRC_REGS;
/* Block definition: DPI */
typedef struct
{
  uint32   nof_instances; /* 6 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c00 */

     /* DpiErrorInt: dpi and phy training error indication           */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD dpi_error_int;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c10 */

     /* DpiErrorIntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dpi_error_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered. Address:                          */
  /* 0x0020-0x00210x0020 is used for writing bits 31:0.0x0021       */
  /* is used for writing bits 55:32.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c20 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_DPI_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation. Address: 0x0030-0x00310x0030 is used for        */
  /* writing bits 31:0.0x0031 is used for writing bits 55:32.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c30 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_DPI_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c40 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then the last command failed on             */
     /* timeout.                                                     */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c41 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform:             */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Dprc Enable: DPRC Enable register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c52 */

     /* DprcEn: DPRC enable.                                         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprc_en;

  } __ATTRIBUTE_PACKED__ dprc_enable_reg;

  /* DCF Register                                                  */
  /* Also includes miscellaneous configuration, e.g. DRAM-related   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c53 */

     /* DCF Register:                                                */
     /* range: 0:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dcf_lc;

     /* DCF Register:                                                */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dcf_fcmm;

     /* DCF Thresh:                                                  */
     /* range: 4:3, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD dcf_thresh;
     /* range: 9:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dcf_ovrd_vec;
     /* range: 11:10, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dcf_ovrd_pol;

  } __ATTRIBUTE_PACKED__ dcf_reg;

  /* Dpi Init Start: Start PHY initialization sequence.-            */
  /* Setting this bit causes the initialization sequence for        */
  /* the PHY DLL and data synchronization blocks.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c60 */

     /* DpiInitStart: Start PHY initialization sequence.-            */
     /* Setting this bit causes the initialization sequence for      */
     /* the PHY DLL and data synchronization blocks.                 */
     /* range: 0:0, access type: D, default value: 0x0               */
     SOC_PETRA_REG_FIELD dpi_init_start;

  } __ATTRIBUTE_PACKED__ dpi_init_start_reg;

  /* dpi_init_reset:                                                */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c61 */

    /* dpi_init_reset: Reset DPI and PHY initialization logic       */
    /* range: :, access type: D, default value: 0x0                 */
    SOC_PETRA_REG_FIELD dpi_init_reset;

  } __ATTRIBUTE_PACKED__ dpi_init_reset_reg;

  /* dpi init status: DPI and PHY status register                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c62 */

     /* ready: PHY and DPI initialization done indication            */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ready;

     SOC_PETRA_REG_FIELD init_dn;

     SOC_PETRA_REG_FIELD dll_mstr_s;

  } __ATTRIBUTE_PACKED__ dpi_init_status_reg;

  /* dll_control: DLL control register                                */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c62 */

    /* range: 31:0, access type: RO, default value: 0x0              */
    SOC_PETRA_REG_FIELD dll_control;

  } __ATTRIBUTE_PACKED__ dll_control_reg;

  /* ddl Periodic Training Register: Enable automatic               */
  /* periodic update and training of the DLL                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c64 */

     /* ddl auto trn en: Enable automatic periodic training of       */
     /* the DDL                                                      */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ddl_auto_trn_en;

  } __ATTRIBUTE_PACKED__ ddl_periodic_training_reg;

  /* ddl1_ctrl: DDL1 control Register                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c65 */

     /* PredefEn: predefined phase select override enable            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD predef_en;

     /* PredefMainPhSel: predefined 4 phase generator output         */
     /* phase selection                                              */
     /* range: 2:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD predef_main_ph_sel;

     /* PredefPh2Sel: predefined phase selection for synclk2         */
     /* clock gating                                                 */
     /* range: 4:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD predef_ph2_sel;

     /* unused4: unused                                              */
     /* range: 10:5, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD unused4;

     /* PredefDlSelHg: predefined half granularity vector            */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD predef_dl_sel_hg;

     /* PredefDlSelVec: predefined delay override count              */
     /* range: 19:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD predef_dl_sel_vec;

     /* PredefDlHcSelVec: predefined delay half cycle override       */
     /* count                                                        */
     /* range: 27:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD predef_dl_hc_sel_vec;

     /* PredefDlQcSelVec: predefined delay quarter cycle             */
     /* override count                                               */
     /* range: 31:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD predef_dl_qc_sel_vec;

  } __ATTRIBUTE_PACKED__ ddl_ctrl_reg_0[SOC_PB_DRAM_NOF_DLL_REGS];

  /* ddl1_ctrl: DDL1 control Register                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c66 */

     /* PredefDlQcSelVec: predefined delay quarter cycle             */
     /* override count                                               */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD predef_dl_qc_sel_vec;

     /* statPredefMode: status register to reflect predef ctrl       */
     /* required information                                         */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stat_predef_mode;

     /* predefPhUp: predefined phase up selection                    */
     /* range: 8:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD predef_ph_up;

     /* predefPhDn: predefined phase dn selection                    */
     /* range: 12:9, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD predef_ph_dn;

     /* TqcX8StepEn: Enable X8 step on Tqc dlwalk                    */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tqc_x8_step_en;

     /* fastDlwalkInc: defines the increment for delay line walk     */
     /* 00-1, 01-2, 10-3, 11-4, can be used for saving lock time     */
     /* and for faster tracking in cases where the jitter is         */
     /* larger                                                       */
     /* range: 15:14, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fast_dlwalk_inc;

     /* PhselMargin: predefined margin for the phase selection       */
     /* process in order to ensure safe selection counted in         */
     /* delay elements                                               */
     /* range: 17:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD phsel_margin;

     /* SelMargin: upper and lower limit margin                      */
     /* range: 19:18, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD sel_margin;

     /* TrainTrigThreshold: threshold for re-training trigger,       */
     /* can be programmed to 1/4 cycle +offset, where the offset     */
     /* can be 0,4,8,12 according to the programing of this          */
     /* field                                                        */
     /* range: 21:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD train_trig_threshold;

     /* TrainTrigEn: training trigger mode enable                    */
     /* range: 22:22, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD train_trig_en;

     /* unused7: unused                                              */
     /* range: 24:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD unused7;

     /* unused5: unused                                              */
     /* range: 27:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD unused5;

     /* PhselHcUp: phase selection selection for higher phase        */
     /* option                                                       */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD phsel_hc_up;

     /* unused6: unused                                              */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD unused6;

     /* unused1: unused                                              */
     /* range: 30:30, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD unused1;

     /* DlyMaxminMode: select maximum minimum peek detection on      */
     /* the status regsiter                                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dly_maxmin_mode;

  } __ATTRIBUTE_PACKED__ ddl_ctrl_reg_1[SOC_PB_DRAM_NOF_DLL_REGS];

  /* ddl1_ctrl: DDL1 control Register                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c67 */

     /* InsDlyCompThreshold: Insertion delay compensation            */
     /* threshold                                                    */
     /* range: 5:0, access type: RW, default value: 0xa              */
     SOC_PETRA_REG_FIELD ins_dly_comp_threshold;

     /* unused2: unused                                              */
     /* range: 9:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD unused2;

     /* PredefInsDlyMinVec: predefined Insertion delay               */
     /* compensation vector                                          */
     /* range: 15:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD predef_ins_dly_min_vec;

  } __ATTRIBUTE_PACKED__ ddl_ctrl_reg_2[SOC_PB_DRAM_NOF_DLL_REGS];

  /* ddl1_stat: DDL1 status Register                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c71 */

     /* PhSel: dune internal debug information.                      */
     /* range: 1:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ph_sel;

     /* MainPhSel: dune internal debug information.                  */
     /* range: 3:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD main_ph_sel;

     /* Ph2Sel: dune internal debug information.                     */
     /* range: 5:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ph2_sel;

     /* DlyMaxminMode: dune internal debug information.              */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD dly_maxmin_mode;

     /* PhselError: dune internal debug information.                 */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD phsel_error;

     /* HcSelVec: dune internal debug information.                   */
     /* range: 15:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD hc_sel_vec;

     /* SelVec: dune internal debug information.                     */
     /* range: 23:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD sel_vec;

     /* selHg: dune internal debug information.                      */
     /* range: 24:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD sel_hg;

     /* QcSelVec: dune internal debug information.                   */
     /* range: 31:25, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qc_sel_vec_0;

  } __ATTRIBUTE_PACKED__ ddl1_stat_lsb_reg[SOC_PB_DRAM_NOF_DLL_REGS];

  /* ddl1 stat: DDL1 status Register                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c72 */

     /* QcSelVec: dune internal debug information.                   */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD qc_sel_vec_1;

     /* train trigger: dune internal debug information.              */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD train_trigger;

     /* PhUp: dune internal debug information.                       */
     /* range: 5:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ph_up;

     /* PhselHcUp: dune internal debug information.                  */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD phsel_hc_up;

     /* unused1: unused                                              */
     /* range: 11:7, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD unused1;

     /* InsDlyMinVec: dune internal debug information.               */
     /* range: 17:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ins_dly_min_vec;

  } __ATTRIBUTE_PACKED__ ddl1_stat_msb_reg[SOC_PB_DRAM_NOF_DLL_REGS];

  /* calib bypass: Dune internal debug register                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c7b */

     /* set rndtrpDiff0: Dune internal debug register                */
     /* range: 4:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD set_rndtrp_diff0;

     /* set rndtrpDiff1: Dune internal debug register                */
     /* range: 9:5, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD set_rndtrp_diff1;

     /* set rndtrpDiff2: Dune internal debug register                */
     /* range: 14:10, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD set_rndtrp_diff2;

     /* set rndtrpDiff3: Dune internal debug register                */
     /* range: 19:15, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD set_rndtrp_diff3;

     /* calib bypass: Dune internal debug register                   */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD calib_bypass;

  } __ATTRIBUTE_PACKED__ calib_bypass_reg;

  /* calib bypass vec: Dune internal debug register                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c7c */

     /* set delay0: Dune internal debug register                     */
     /* range: 4:0, access type: RW, default value: 0xa              */
     SOC_PETRA_REG_FIELD set_delay0;

     /* set delay1: Dune internal debug register                     */
     /* range: 9:5, access type: RW, default value: 0xa              */
     SOC_PETRA_REG_FIELD set_delay1;

     /* set delay2: Dune internal debug register                     */
     /* range: 14:10, access type: RW, default value: 0xa            */
     SOC_PETRA_REG_FIELD set_delay2;

     /* set delay3: Dune internal debug register                     */
     /* range: 19:15, access type: RW, default value: 0xa            */
     SOC_PETRA_REG_FIELD set_delay3;

  } __ATTRIBUTE_PACKED__ calib_bypass_vec_reg;

  /* IoConfig: IO Configuration reister                             */
 
   struct
   {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c7f */
 
     /* : octet 0 termination control                                */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tximp45_oct0;
 
     /* : octet 0 pulldown                                           */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pd50_oct0;
 
     /* : octet 0 pullup                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pu50_oct0;
 
     /* : octet 1 termination control                                */
     /* range: 5:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tximp45_oct1;
 
     /* : octet 1 pulldown                                           */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pd50_oct1;
 
     /* : octet 1 pullup                                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pu50_oct1;
 
     /* : octet 2 termination control                                */
     /* range: 9:9, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tximp45_oct2;
 
     /* : octet 2 pulldown                                           */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pd50_oct2;
 
     /* : octet 2 pullup                                             */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pu50_oct2;
 
     /* : octet 3 termination control                                */
     /* range: 13:13, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tximp45_oct3;
 
     /* : octet 3 pulldown                                           */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pd50_oct3;
 
     /* : octet 3 pullup                                             */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pu50_oct3;
 
     /* : control bus termination control                            */
     /* range: 17:17, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tximp45_ctrl;
 
     /* : control bus pulldown                                       */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pd50_ctrl;
 
     /* : control bus pullup                                         */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pu50_ctrl;
 
     /* : clock bus termination control                              */
     /* range: 21:21, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tximp45_ck;
 
     /* : clock bus pulldown                                         */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pd50_ck;
 
     /* : clock bus pullup                                           */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pu50_ck;
 
     /* : enable ODT vref for vref pad                               */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD enodtvref;
 
     /* : enable output for all pads, in default and reset, the      */
     /* pads are disabled                                            */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD enable_outputs;
 
   } __ATTRIBUTE_PACKED__ io_config_reg;
 
 
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c80 */

    SOC_PETRA_REG_FIELD cr;

  } __ATTRIBUTE_PACKED__ io_calibration_status_reg;

  /* Io Odt Read Config: IO ODT Read configuration                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c81 */

     /* ioOdtReadRiseAloc: Read signal for IO ODT activation         */
     /* allocation, counted from the command time at DPI             */
     /* interface. Setting this field to Zero and the                */
     /* ioOdtReadFallAloc field to 5'h1f will result in ODT          */
     /* always asserted.                                             */
     /* range: 4:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD io_odt_read_rise_aloc;

     /* ioOdtReadFallAloc: Read signal for IO ODT activation         */
     /* allocation, counted from the command time at DPI             */
     /* interface. Setting this field to Zero and the                */
     /* ioOdtReadFallAloc field to 5'h1f will result in ODT          */
     /* always asserted.                                             */
     /* range: 9:5, access type: RW, default value: 0x6              */
     SOC_PETRA_REG_FIELD io_odt_read_fall_aloc;

     /* ioOdtReadRiseOfset: Read signal for IO ODT activation        */
     /* allocation, counted relative to data valid on the DPI        */
     /* loop delay, bit #14 selects up or down ofset (1 - up, 0      */
     /* -down)                                                       */
     /* range: 14:10, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD io_odt_read_rise_ofset;

     /* ioOdtReadFallOfset: Read signal for IO ODT de-activation     */
     /* allocation, counted relative to data valid on the DPI        */
     /* loop delay, bit #19 selects up or down ofset (1 - up, 0      */
     /* -down)                                                       */
     /* range: 19:15, access type: RW, default value: 0x10           */
     SOC_PETRA_REG_FIELD io_odt_read_fall_ofset;

     /* ioOdtReadOfsetEn: Read signal ofset allocation mode          */
     /* enable                                                       */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD io_odt_read_ofset_en;

     /* ioOdtDisable: disable ODT signal, when set the ODT will      */
     /* not be activated                                             */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD io_odt_disable;

  } __ATTRIBUTE_PACKED__ io_odt_read_config_reg;

  /* dpi general config */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c82 */

    /* Addr13OnWdqsEn: enable driving of addr13 info on wdqs        */
    /* range: 17:17, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD addr_13_on_wdqs_en;

  } __ATTRIBUTE_PACKED__ dpi_general_config_reg;

  /* Ddr Phy Mode: DDR PHY mode selection register                  */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c83 */

    /* Gddr3Mode: GDDR3 mode enable                                 */
    /* range: 1:1, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD gddr3_mode;

    /* Ddr3Mode: ddr3 mode enable                                   */
    /* range: 2:2, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD ddr3_mode;

  } __ATTRIBUTE_PACKED__ ddr_phy_mode_reg;

  /* dpi_rnd_trp_status_reg: Dune debug internal register                */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c84 */

    SOC_PETRA_REG_FIELD rnd_trp[SOC_PB_DRAM_NOF_RND_TRP_FLDS];
  } __ATTRIBUTE_PACKED__ dpi_rnd_trp_status_reg;

  /* dpi_rnd_trp_diff_status_reg: Dune debug internal register                */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c85 */

    SOC_PETRA_REG_FIELD rnd_trp_diff[SOC_PB_DRAM_NOF_RND_TRP_DIFF_FLDS];
  } __ATTRIBUTE_PACKED__ dpi_rnd_trp_diff_status_reg;

  /* ddio_bit_align_control_reg: Dune debug internal register                */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c87 */

    SOC_PETRA_REG_FIELD shift_val;
  } __ATTRIBUTE_PACKED__ ddio_bit_align_control_reg[SOC_PB_DRAM_NOF_SHIFT_REGS];

  /* Dpi Retrain: Start PHY training sequence.- Setting this        */
  /* bit causes the training sequence without DLL re-init.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c8b */

     /* DpiRetrain: Start PHY training sequence.- Setting this       */
     /* bit causes the training sequence without DLL re-init.        */
     /* range: 0:0, access type: D, default value: 0x0               */
     SOC_PETRA_REG_FIELD dpi_retrain;

  } __ATTRIBUTE_PACKED__ dpi_retrain_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_DPI_REGS;
/* Block definition: FDR 	 */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit(A-for links 0-17, B-for          */
  /* links 18-35).                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e00 */

     /* SrtdesccntoA: Discard cell counter overflow                  */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD srtdesccnto_a;

     /* OrgtimeerrA: Unexpected cell error in links 0-17             */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD orgtimeerr_a;

     /* IfmafoA: IFMA-FIFO-overflow. Note that if the IFM FIFO       */
     /* overflows, cells are not being overwritten.                  */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ifmafo_a;

     /* IfmbfoA: IFMB-FIFO-overflow. Note that if the IFM FIFO       */
     /* overflows, cells are not being overwritten.                  */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ifmbfo_a;

     /* CpudatacellfneA0: Links 0-11 CPU-FIFO-non-empty (this        */
     /* bit is not AC).                                              */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudatacellfne_a0;

     /* CpudatacellfneA1: Links 12-17 CPU-FIFO-non-empty (this       */
     /* bit is not AC).                                              */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudatacellfne_a1;

     /* AltoA: One of the links statuses went down-(registers        */
     /* 0x2369 and 0x236a)                                           */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD alto_a;

     /* FdraOutOfSync: Irrecoverable error in the FDR (links         */
     /* 17-0)                                                        */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_out_of_sync;

     /* FdraTagEccErr: ECC error occurred in the FDR descriptor      */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_tag_ecc_err;

     /* FdraFilrterDroppINTA: Cells dropped in the error filter      */
     /* of macra                                                     */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_filrter_dropp_inta;

     /* FdraFilrterDroppINTB: Cells dropped in the error filter      */
     /* of macrb                                                     */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdra_filrter_dropp_intb;

     /* SrtdesccntoB: Discard cell counter overflow                  */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srtdesccnto_b;

     /* OrgtimeerrB: Unexpected cell error in links18-35             */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD orgtimeerr_b;

     /* IfmafoB: IFMA-FIFO-overflow. Note that if the IFM FIFO       */
     /* overflows, cells are not being overwritten.                  */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ifmafo_b;

     /* IfmbfoB: IFMB-FIFO-overflow. Note that if the IFM FIFO       */
     /* overflows, cells are not being overwritten.                  */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ifmbfo_b;

     /* CpudatacellfneB0: Links 24-35 CPU-FIFO-non-empty (this       */
     /* bit is not AC).                                              */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpudatacellfne_b0;

     /* CpudatacellfneB1: Links 18-23 CPU-FIFO-non-empty (this       */
     /* bit is not AC).                                              */
     /* range: 21:21, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpudatacellfne_b1;

     /* AltoB : One of links statuses went down (registers           */
     /* 0x2369 and 0x236a)                                           */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD alto_b_;

     /* FdrbOutOfSync : Irrecoverable error in the FDR (links        */
     /* 35-18)                                                       */
     /* range: 23:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_out_of_sync_;

     /* FdrbTagEccErr: ECC error occurred in the FDR descriptor      */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_tag_ecc_err;

     /* FdrbFilrterDroppINTA: Cells dropped in the error filter      */
     /* of macra                                                     */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_filrter_dropp_inta;

     /* FdrbFilrterDroppINTB: Cells dropped in the error filter      */
     /* of macrb                                                     */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_filrter_dropp_intb;

     /* FdrOutpuOutOfSync: Irrecoverable error in the FDR output     */
     /* range: 30:30, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_outpu_out_of_sync;

     /* FdrOutTagEccErr: ECC error occurred in the FDR               */
     /* descriptor                                                   */
     /* range: 31:31, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_out_tag_ecc_err;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e10 */

     /* SrtdesccntoAMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD srtdesccnto_amask;

     /* OrgtimeerrAMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD orgtimeerr_amask;

     /* IfmafoAMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ifmafo_amask;

     /* IfmbfoAMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ifmbfo_amask;

     /* CpudatacellfneA0Mask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudatacellfne_a0_mask;

     /* CpudatacellfneA1Mask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudatacellfne_a1_mask;

     /* AltoMask: Writing 0 masks the corresponding interrupt        */
     /* source.                                                      */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD alto_mask;

     /* FdraOutOfSyncMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_out_of_sync_mask;

     /* FdraTagEccErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_tag_ecc_err_mask;

     /* FdraFilrterDroppINTAMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_filrter_dropp_intamask;

     /* FdraFilrterDroppINTBMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdra_filrter_dropp_intbmask;

     /* SrtdesccntoBMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srtdesccnto_bmask;

     /* OrgtimeerrBMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD orgtimeerr_bmask;

     /* IfmafoBMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ifmafo_bmask;

     /* IfmbfoBMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ifmbfo_bmask;

     /* CpudatacellfneB0Mask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpudatacellfne_b0_mask;

     /* CpudatacellfneB1Mask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpudatacellfne_b1_mask;

     /* AltoBMask: Writing 0 masks the corresponding interrupt       */
     /* source.                                                      */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD alto_bmask;

     /* FdrbOutOfSyncMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_out_of_sync_mask;

     /* FdrbTagEccErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_tag_ecc_err_mask;

     /* FdrbFilrterDroppINTAMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_filrter_dropp_intamask;

     /* FdrbFilrterDroppINTBMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_filrter_dropp_intbmask;

     /* FdrOutpuOutOfSyncMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_outpu_out_of_sync_mask;

     /* FdrOutTagEccErrMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_out_tag_ecc_err_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Fdr Enablers Register: Fdr command enabler                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e60 */

     SOC_PETRA_REG_FIELD bits_1_0;

     /* FDRMtchAct: Match-Action[1:0] 0: Count and forward 1:        */
     /* Count and discard 2: Count and Trapp 3: Count and Trapp      */
     /* and forward                                                  */
     /* range: 29:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrmtch_act;

     /* FDRMtchLogicnot: Inverts match filter logic.                 */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrmtch_logicnot;

  } __ATTRIBUTE_PACKED__ fdr_enablers_reg;

  /* Programmable Data Cell Counter0: Match filter to capture       */
  /* data cells to the cpu according to the match                   */
  /* action,Looks at bits 311:280 of the data cell.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e61 */

     /* PCMtchLb0:                                                   */
     /* Program-Counter-Match-Data-Cells-Labels0-match mask for      */
     /* bytes 0-3 of labels                                          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_lb0;

  } __ATTRIBUTE_PACKED__ programmable_data_cell_counter_reg[SOC_PB_FDR_PROGRAMMABLE_DATA_CELL_COUNTER_REG_NOF_REGS];

  /* Programmable Data Cell Counter Mask0: Filter                   */
  /* mask-masking for the match filter for masking irrelevant       */
  /* bits for the filter (Looks at bits 311:280 of the data         */
  /* cell.)                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e63 */

     /* PCMtchMsk0: PC-Match-Data-Cells-Mask#0[31:0]don't care       */
     /* bits' mask for bytes 0-3.                                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_msk0;

  } __ATTRIBUTE_PACKED__ programmable_data_cell_counter_mask_reg[SOC_PB_FDR_PROGRAMMABLE_DATA_CELL_COUNTER_MASK_REG_NOF_REGS];

  /* Link Level Flow Control: Link-Level flow-control               */
  /* threshold.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e65 */

     /* LnkLvlFcTh: The threshold at which to activate link          */
     /* level flow control                                           */
     /* range: 7:0, access type: RW, default value: 0x78             */
     SOC_PETRA_REG_FIELD lnk_lvl_fc_th;

  } __ATTRIBUTE_PACKED__ link_level_flow_control_reg;

  /* Filter Match Input Link: Match filter to capture data          */
  /* cells to the CPU according to the match action (same as        */
  /* above). Defines the option to trap cells from a specific       */
  /* input link or cells with a CRC error.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e66 */

     /* PcMtchLink: Input link for the match filter                  */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pc_mtch_link;

     /* PcMtchLinkOn: Enable bit for the link match                  */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pc_mtch_link_on;

     /* CrcMtchOn: Capture cells arriving with CRC errors from       */
     /* the MAC receive.                                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crc_mtch_on;

     /* DataMtchOn: Capture only data cells that match the           */
     /* filter                                                       */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD data_mtch_on;

  } __ATTRIBUTE_PACKED__ filter_match_input_link_reg;

  /* Programmable Cells Counter: Programmable-Cells-Counter         */
  /* -count all the cells trapped by the match filter.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e68 */

     /* PrgCellCnt: Programmable-Cells-Counter This 31-bit           */
     /* counter holds the number of matched cells. The counter       */
     /* does not stop at saturation.                                 */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prg_cell_cnt;

     /* PrgCellCntO: Programmable-Cells-Counter-Overflow This        */
     /* bit is set when the counter exceeds 31 bits.                 */
     /* range: 31:31, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD prg_cell_cnt_o;

  } __ATTRIBUTE_PACKED__ programmable_cells_counter_reg;

  /* Tsc Link Up Status From FDRA: FDRA links up signals            */
  /* -indicates that the FDR report these links as active           */
  /* links.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e69 */

     /* TscLinkUp_a: Reflects the Link "up" bitmap as computed       */
     /* and used by the FDR. (Link must be "up" for cells to be      */
     /* sent through). for links 0-17.                               */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fdrlink_up_a;

  } __ATTRIBUTE_PACKED__ link_up_status_from_fdra_reg;

  /* Tsc Link Up Statusf From FDRB: FDRB links up signals           */
  /* -indicate that the FDR report these links as active            */
  /* link.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e6a */

     /* TscLinkUp_b: Reflects the Link "up" bitmap as computed       */
     /* and used by the FDR. (Link must be "up" for cells to be      */
     /* sent through). for links 18-35.                              */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fdrlink_up_b;

  } __ATTRIBUTE_PACKED__ link_up_status_from_fdrb_reg;

  /* FDROverflows And Fifos Statuses FDRA: Fifos overflow           */
  /* indications for links 0-17.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e6b */

     /* CPUDataCellFOA0: CPU-buffer-FIFO-overflow. Note that if      */
     /* the CPU buffer overflows, this means that the newly          */
     /* arrived cell is discarded and then the overflow flag is      */
     /* set.                                                         */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudata_cell_foa0;

     /* CPUDataCellFOA1: CPU-buffer-FIFO-overflow. Note that if      */
     /* the CPU buffer overflows, this means that the newly          */
     /* arrived cell is discarded and then the overflow flag is      */
     /* set.                                                         */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudata_cell_foa1;

     /* MaxIFMAFFDRA: Maximum-IFM-FIFO-occupancy. The maximal        */
     /* number of cells that occurred in one of the IFM FIFOs        */
     /* since the last time this register was read. The value is     */
     /* reset when read.(Links 11:0)                                 */
     /* range: 9:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD max_ifmaf;

     /* MaxIFMBFFDRA: Maximum-IFM-FIFO-occupancy. The maximal        */
     /* number of cells that occurred in one of the IFM FIFOs        */
     /* since the last time this register was read. The value is     */
     /* reset when read.(Links 17:12)                                */
     /* range: 17:10, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD max_ifmbf;

     /* MaxIFMFANumFDRA: The IFM FIFO that had the maximum           */
     /* occupancy reported in the above. This register is clear      */
     /* on read.                                                     */
     SOC_PETRA_REG_FIELD max_ifmfanum;
     /* range: 25:22, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD max_ifmfbnum;

  } __ATTRIBUTE_PACKED__ fdroverflows_and_fifos_statuses_fdra_reg;

  /* FDROverflows And Fifos Statuses Fdr B: Fifos overflow          */
  /* indications for links 18-35.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e6c */

     /* CPUDataCellFOB0: CPU-buffer-FIFO-overflow. Note that if      */
     /* the CPU buffer overflows, this means that the newly          */
     /* arrived cell is discarded and then the overflow flag is      */
     /* set.                                                         */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudata_cell_fob0;

     /* CPUDataCellFOB1: CPU-buffer-FIFO-overflow. Note that if      */
     /* the CPU buffer overflows, this means that the newly          */
     /* arrived cell is discarded and then the overflow flag is      */
     /* set.                                                         */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudata_cell_fob1;

     /* MaxIFMAFFDRB: Maximum-IFM-FIFO-occupancy. The maximal        */
     /* number of cells that occurred in one of the IFM FIFOs        */
     /* since the last time this register was read. The value is     */
     /* reset when read.(Links 35:24)                                */
     /* range: 8:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD max_ifmaf;

     /* MaxIFMBFFDRB: Maximum-IFM-FIFO-occupancy. The maximal        */
     /* number of cells that occurred in one of the IFM FIFOs        */
     /* since the last time this register was read. The value is     */
     /* reset when read.(Links 23:18)                                */
     /* range: 15:9, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD max_ifmbf;

     SOC_PETRA_REG_FIELD max_ifmfanum;
     /* MaxIFMFBNumFDRB: The IFM FIFO that had the maximum           */
     /* occupancy reported in the above. This register is clear      */
     /* on read.                                                     */
     /* range: 23:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD max_ifmfbnum;

  } __ATTRIBUTE_PACKED__ fdroverflows_and_fifos_statuses_fdr_b_reg;

  /* Local Fifo Rci Level: FDR fifo rci level -sets the             */
  /* threshold per link fifo that will assert rci flow              */
  /* control to the scheduler.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e6f */

     /* RciLowLevel: Set the threshold per link fifo that assert     */
     /* rci flow control [0] to the scheduler. The value 0           */
     /* disables the fdr rci                                         */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rci_low_level;

     /* RciHighLevel: Set the threshold per link fifo that           */
     /* assert rci flow control [1] to the scheduler. The value 0     */
     /* disables the fdr rci                                         */
     /* range: 22:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rci_high_level;

  } __ATTRIBUTE_PACKED__ local_fifo_rci_level_reg;

  /* Cpu Data Cell A: LINKS 0-11 CPU-FIFO-cells.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e70 */

     /* CPUDataCellA: CPU-FIFO-cells[311:0] from side A of FDRA.     */
     /* Cells captured for the CPU are stored in a 312-bit wide      */
     /* FIFO. The CPU reads a 312-bit cell by reading ten 32-bit     */
     /* words. When reading word-9, the cell FIFO is advanced.       */
     /* CPUCellWord0= \{Data_cell[319:318],Data_cell[309:280]\}      */
     /* CPUCellWord1= \{Data_cell[279:248]\}                         */
     /* CPUCellWord9=\{Data_cell[23:8], 16'h0\}                      */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpudata_cell_a;

  } __ATTRIBUTE_PACKED__ cpu_data_cell_a_reg[SOC_PB_FDR_CPU_DATA_CELL_A_REG_MULT_NOF_REGS];

  /* Cpu Data Cell B: LINKS 12-17 CPU-FIFO-cells.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e80 */

     /* CPUDataCellB: CPU-FIFO-cells[311:0] from side B of FDRA.     */
     /* Cells captured for the CPU are stored in a 312-bit wide      */
     /* FIFO. The CPU reads a 312-bit cell by reading ten 32-bit     */
     /* words. When reading word-9, the cell FIFO is advanced.       */
     /* CPUCellWord0= \{Data_cell[319:318],Data_cell[309:280]\}      */
     /* CPUCellWord1= \{Data_cell[279:248]\}                         */
     /* CPUCellWord9=\{Data_cell[23:8], 16'h0\}                      */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpudata_cell_b;

  } __ATTRIBUTE_PACKED__ cpu_data_cell_b_reg[SOC_PB_FDR_CPU_DATA_CELL_B_REG_MULT_NOF_REGS];

  /* Cpu Data Cell C: LINKS 18-23 CPU-FIFO-cells.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e90 */

     /* CPUDataCellC: CPU-FIFO-cells[311:0] from side B of FDRB      */
     /* Cells captured for the CPU are stored in a 312-bit wide      */
     /* FIFO. The CPU reads a 312-bit cell by reading ten 32-bit     */
     /* words. When reading word-9, the cell FIFO is advanced.       */
     /* CPUCellWord0= \{Data_cell[319:318],Data_cell[309:280]\}      */
     /* CPUCellWord1= \{Data_cell[279:248]\}                         */
     /* CPUCellWord9=\{Data_cell[23:8], 16'h0\}                      */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpudata_cell_c;

  } __ATTRIBUTE_PACKED__ cpu_data_cell_c_reg[SOC_PB_FDR_CPU_DATA_CELL_C_REG_MULT_NOF_REGS];

  /* Cpu Data Cell D: LINKS 24-35 CPU-FIFO-cells                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2ea0 */

     /* CPUDataCellD: CPU-FIFO-cells[311:0] from side A of FDRB.     */
     /* Cells captured for the CPU are stored in a 312-bit wide      */
     /* FIFO. The CPU reads a 312-bit cell by reading ten 32-bit     */
     /* words. When reading word-9, the cell FIFO is advanced.       */
     /* CPUCellWord0= \{Data_cell[319:318],Data_cell[309:280]\}      */
     /* CPUCellWord1= \{Data_cell[279:248]\}                         */
     /* CPUCellWord9=\{Data_cell[23:8], 16'h0\}                      */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpudata_cell_d;

  } __ATTRIBUTE_PACKED__ cpu_data_cell_d_reg[SOC_PB_FDR_CPU_DATA_CELL_D_REG_MULT_NOF_REGS];

  /* Sorter Fifo Discard Counter A: Fdr discard counter             */
  /* -counts all discarded cells.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2eb1 */

     /* SrtDescCntB: FDR-FIFO-Discard Counter The counter does       */
     /* not stop at saturation. For links 18:35 This register is     */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srt_desc_cnt_b;

     /* SrtDescCntOB: FDR-FIFO-Discard Counter Overflow For          */
     /* links 28:35 This register is clear on read.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD srt_desc_cnt_ob;

  } __ATTRIBUTE_PACKED__ sorter_fifo_discard_counter_a_reg;

  /* Error Filter: FDR error filter. Enables filtering error         */
  /* cells before they are sent to the EGQ.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2eb2 */

     /* ErrorFilter: Error filter, enable filtering error on the     */
     /* packet or cell header before transmitting to the EGQ.        */
     /* Enable filtering cell size, header bits 319:264 and 8B       */
     /* packet header.                                               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_filter;

  } __ATTRIBUTE_PACKED__ error_filter_reg[SOC_PB_FDR_ERROR_FILTER_REG_MULT_NOF_REGS];

  /* Error Filter Mask: FDR error filter Mask. Enables              */
  /* masking non relevant bits in the filter                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2eb6 */

     /* ErrorFilterMask: Error filter . Enables masking non           */
     /* relevant bits in the cell                                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_filter_mask;

  } __ATTRIBUTE_PACKED__ error_filter_mask_reg[SOC_PB_FDR_ERROR_FILTER_MASK_REG_MULT_NOF_REGS];

  /* Error Filter Mask En: FDR error filter Mask activation         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2eba */

     /* ErrorFilterMaskEn: Error filter enable.                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_filter_mask_en;

  } __ATTRIBUTE_PACKED__ error_filter_mask_en_reg;

  /* Error Filter Cnt: FDR error filter cell counter                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2ebb */

     /* ErrorFilterCnt: Count number of dropped cells This           */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_filter_cnt;

     /* ErrorFilterCntO: Counter overflow. This register is          */
     /* clear on read This register is clear on read.                */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_filter_cnt_o;

  } __ATTRIBUTE_PACKED__ error_filter_cnt_reg;

  /* Error Filter2: FDR error filter stage 2, enable                */
  /* filtering error cells before sending to the egq                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2ec2 */

     /* ErrorFilter2: Error filter, enable filtering error on        */
     /* the packet or cell header before transmitting to the         */
     /* EGQ. Enable filtering cell size, header bits 319:264 and     */
     /* 8B packet header.                                            */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_filter2;

  } __ATTRIBUTE_PACKED__ error_filter2_reg[SOC_PB_FDR_ERROR_FILTER2_REG_MULT_NOF_REGS];

  /* Error Filter Mask2: FDR error filter Mask stage 2,             */
  /* masking non-relevant bits in the filter.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2ec6 */

     /* ErrorFilterMask2: Error filter, enable masking               */
     /* non-relevant bits in the cell                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_filter_mask2;

  } __ATTRIBUTE_PACKED__ error_filter_mask2_reg[SOC_PB_FDR_ERROR_FILTER_MASK2_REG_MULT_NOF_REGS];

  /* Gtimer Configuration register : Clock timer to enable          */
  /* counting cells in specific time period.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2eca */

     /* TimeCountConfig: Time period that all the counters           */
     /* count. When using this timer, the overflow bit of each       */
     /* counter indicates the end of the time count.                 */
     /* range: 30:0, access type: RW, default value: 31'hee6b27f     */
     SOC_PETRA_REG_FIELD time_count_config;

     /* CounterReset: Reset all gtimers counters.                    */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD counter_reset;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Activate Gtimer: Start counters that are defined as            */
  /* gtimer.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2ecb */

     /* ActivateGtimer: Starts counters that are defined as          */
     /* gtimer.                                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD activate_gtimer;

     /* UseGtimer: Enable using the gtimer to count cells in         */
     /* required period                                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD use_gtimer;

  } __ATTRIBUTE_PACKED__ activate_gtimer_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_FDR_REGS;
/* Block definition: FDT 	 */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c00 */

     /* UnrchDestEvt: Unreachable-Destination-Event. Set when a       */
     /* packet arrives at the FDT but there is no valid link to      */
     /* forward it to. The data of the packet is written to the      */
     /* UnrchDest register. It is an interrupt source, and is        */
     /* cleared when UnrchDest is read.                              */
     /* range: 0:0, access type: RO , default value: 0x0             */
     SOC_PETRA_REG_FIELD unrch_dest_evt;

     /* EccError: A double error was identified                      */
     /* range: 1:1, access type: RO , default value: 0x0             */
     SOC_PETRA_REG_FIELD ecc_error;

     /* EccErrorFixed: A single error was identified and fixed       */
     /* range: 2:2, access type: RO , default value: 0x0             */
     SOC_PETRA_REG_FIELD ecc_error_fixed;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c10 */

     /* UnrchDestEvtMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD unrch_dest_evt_mask;

     /* EccErrorMask: Writing 0 masks the corresponding              */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ecc_error_mask;

     /* EccErrorFixedMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ecc_error_fixed_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x2c30 */

    /* IndirectCommandRdData: Indirect read data.                   */
    /* range: 31:0, access type: RO, default value: 0x0             */
    SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_FDT_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x2c40 */

    /* IndirectCommandTrigger: Trigger indirect access as           */
    /* defined by the rest of the registers. The negation of        */
    /* this bit indicates that the operation has been               */
    /* completed.                                                   */
    /* range: 0:0, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD indirect_command_trigger;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address-             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x2c41 */

    /* IndirectCommandAddr: Indirect access address- Defines        */
    /* which indirect object is accessed.                           */
    /* range: 30:0, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD indirect_command_addr;

    /* IndirectCommandType: Type of command to perform: 0:          */
    /* Write operation. 1: Read operation.                          */
    /* range: 31:31, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* MC Static routing                            */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x2c52 */

    /* range: 0:0, access type: RW, default value: 0x1              */
    SOC_PETRA_REG_FIELD soc_pb_gc_bugfix;

    /* range: 1:1, access type: RW, default value: 0x1              */
    SOC_PETRA_REG_FIELD soc_petra_c_str_en;

    /* range: 10:4, access type: RW, default value: 0x1              */
    SOC_PETRA_REG_FIELD soc_petra_c_str_ofst;

    /* range: 13:12, access type: RW, default value: 0x1              */
    SOC_PETRA_REG_FIELD soc_petra_c_str_mode;

  } __ATTRIBUTE_PACKED__ stat_route_config_reg;


  /* Fdt Enabler Register: fdt enabler.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c60 */

     /* DiscardDllPkts: If set, all packets read out of IPT are      */
     /* discarded. The default value 0x1 ensures that no messages     */
     /* are sent before the FAP's Chip-ID is written. After           */
     /* initialization, DiscAllPkts should be reset.                 */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD discard_dll_pkts;

     /* SegmentPkt: Reserved                                         */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD segment_pkt;

     /* DelCrcPkt: If set, the last fabric cell of packets           */
     /* detected with CRC errors when read from the DRAM will        */
     /* not be sent into the fabric. The packet size in the           */
     /* header, therefore, will not coincide with the packet         */
     /* size arriving at the egress FAP, and the packet will be      */
     /* deleted.                                                     */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD del_crc_pkt;

     /* ContextStat: Define the context number that the              */
     /* statistics counter count.                                    */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD context_stat;

     /* UseCoexInMulticast: Enable coexist in multicast. If set,     */
     /* all multicast ids are considered as coexisting.              */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD use_coex_in_multicast;

     /* MaskTdmBmp: Enable masking the rtp for the bitmap of all     */
     /* reachable destinations for tdm trafic                        */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_tdm_bmp;

     /* DisLclrt: Disable local route traffic for TDM cells. All     */
     /* TDM traffic including local traffic will go to the           */
     /* fabric.                                                      */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_lclrt;

     /* RandLimkEn: Enable using random mechanism of link            */
     /* selection for TDM packets and for vsc in fabric mode         */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rand_limk_en;

     /* ForceAllLocal: Enable forcing all TDM traffic to the         */
     /* local interface                                              */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD force_all_local;

     /* En500MCell: Enable forcing all TDM traffic to the            */
     /* local interface                                              */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD en_500m_cell;

     /* CountByGtimer: enbale counting by Gtimer                     */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD count_by_gtimer;

     /* Use4segMode: Enable segement of 4 cells in the               */
     /* end of packet                                                */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD use_4seg_mode;

     /* Fe1200Mode: Enable fe1200 mode                              */
     /* (sending 256B for each link)                                */
     /* range: 16:16, access type: RW, default value: 0x0           */
     SOC_PETRA_REG_FIELD fe1200_mode;

     /* SmallPacketEn: Enable using packet sizes lower               */
     /* than 64B in vcs                                              */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD small_packet_en;

  } __ATTRIBUTE_PACKED__ fdt_enabler_reg;

  /* Transmitted Data Cells Counter: Counts all transmitted         */
  /* data cells.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c61 */

     /* DataCellCnt: Data-Cell-Counter. This 31-bit counter holds     */
     /* the number of data cells transmitted to the MACT (in 32B     */
     /* cell for FSC and 128B for VSC). The counter does not         */
     /* stop at saturation. The counter is reset when read. This      */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD data_cell_cnt;

     /* DataCellCnt0: Data-Cell-Counter-Overflow. This bit is set     */
     /* when the counter exceeds 31 bits. This register is clear     */
     /* on read.                                                     */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD data_cell_cnt0;

  } __ATTRIBUTE_PACKED__ transmitted_data_cells_counter_reg;

  /* Unreachable Destination Discarded Cells Counter: This          */
  /* register keeps the first destination that is unreachable       */
  /* from this source FAP.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c62 */

     /* UnrchDest: Unreachable destination.                          */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD unrch_dest;

     /* UnrchDestCnt: Unreachable destination counter. This          */
     /* register is clear on read.                                   */
     /* range: 28:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD unrch_dest_cnt;

     /* UnrchDestCnto: Unreachable destination counter overflow.     */
     /* This register is clear on read.                              */
     /* range: 29:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD unrch_dest_cnto;

  } __ATTRIBUTE_PACKED__ unreachable_destination_discarded_cells_counter_reg;

  /* Context Cell Counter: Requested context cell counter.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c63 */

     /* ContextCellCnt: Count cells for selected context. The        */
     /* context number is defined in register 0x2460. This           */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD context_cell_cnt;

     /* ContextCellCnto: Context cells counter overflow. This        */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD context_cell_cnto;

  } __ATTRIBUTE_PACKED__ context_cell_counter_reg;

  /* Desc Cell Counter: Descriptor cell counter.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c64 */

     /* DescCellCnt: Count all descriptors recived from the ipt      */
     /* or number of ire transaction in tdm mode (number of tdm      */
     /* packet is transaction number / 2 ) This register is          */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD desc_cell_cnt;

     /* DescCellCnto: Descriptor counter overflow. This register     */
     /* is clear on read.                                            */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD desc_cell_cnto;

  } __ATTRIBUTE_PACKED__ desc_cell_counter_reg;

  /* CRCDropped Cell Cnt: Counts all CRCcells that dropped in       */
  /* the fdt                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c65 */

     /* CrcDroppedCellCnt: Crc-Dropped-Cell-Counter. This 31-bit     */
     /* counter holds the number of data cells with CRC error        */
     /* that dropped in the FDT. This register is clear on read.     */
     /* This register is clear on read.                              */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crc_dropped_cell_cnt;

     /* CrcDroppedCellCnt0: Crc-Dropped-Crc-Counter-Overflow.        */
     /* This bit is set when the counter exceeds 31 bits. The        */
     /* overflow flag is cleared when read. This register is         */
     /* clear on read. This register is clear on read.               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crc_dropped_cell_cnt0;

  } __ATTRIBUTE_PACKED__ crcdropped_cell_cnt_reg;

  /* CPUData Cell: Writes source routed data cell from the          */
  /* CPU (16'h0081-16'h008a).                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c81 */

     /* CPUDataCell: The data cell is written in big-endian          */
     /* format (all dont care bits are removed and the rest are      */
     /* shifted to the MSB).                                         */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpudata_cell;

  } __ATTRIBUTE_PACKED__ cpu_data_cell_reg[SOC_PB_FDT_CPUDATA_CELL_REG_MULT_NOF_REGS];

  /* Transmit Cell Output Link Number: This register contains       */
  /* the output link number (out of36 links) for the                */
  /* source-routed data cell.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c8b */

     /* CpuLinkNum: The output link number (0-35) for the CPU        */
     /* cell.                                                        */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_link_num;

     /* CpuCellSize: The Cell Size of the CPU cell that will be      */
     /* transmitted in VCS (the relevant data is only 32B. All       */
     /* other bits will set to 0).                                   */
     /* range: 14:8, access type: RW, default value: 0x3f            */
     SOC_PETRA_REG_FIELD cpu_cell_size;

  } __ATTRIBUTE_PACKED__ transmit_cell_output_link_number_reg;

  /* Transmit Data Cell Trigger: This register contains the         */
  /* trigger object for transmitting a source-routed data           */
  /* cell.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c8c */

     /* CpuTrg: If set Triggers a cell transmit. Is reset once        */
     /* the cell is transmitted, or when output link number is       */
     /* bigger than 35.                                              */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_trg;

  } __ATTRIBUTE_PACKED__ transmit_data_cell_trigger_reg;

  /* Coexist Dupx2 Unicast Bitmap: 128-bits bitmap. Holds one       */
  /* bit for each of the first 256 destination ids, to              */
  /* indicate if the destination is a coexist destination.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c90 */

     /* CoexistDupx2UnicastBitmap: 128-bits bitmap. Holds one        */
     /* bit for each of the first 256 destination ids, to            */
     /* indicate if the destination is a coexist destination.        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD coexist_dupx2_unicast_bitmap;

  } __ATTRIBUTE_PACKED__ coexist_dupx2_unicast_bitmap_reg[SOC_PB_FDT_COEXIST_DUPX2_UNICAST_BITMAP_REG_MULT_NOF_REGS];

  /* Gci Link Mask: Gci links mask bitmap                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2ca7 */

     /* GciLinkMask: Bitmap of the gci leaky bucket in the fdt       */
     /* that mask link from sending data                             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD gci_link_mask;

  } __ATTRIBUTE_PACKED__ gci_link_mask_reg[SOC_PB_FDT_GCI_LINK_MASK_REG_MULT_NOF_REGS];

  /* Tdm Link Mask: Tdm links mask bitmap                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2ca9 */

     /* TdmLinkMask: Bitmap for masking all reachable                */
     /* destinations from the RTP for the TDM cells output link.     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_link_mask;

  } __ATTRIBUTE_PACKED__ tdm_link_mask_reg[SOC_PB_FDT_TDM_LINK_MASK_REG_MULT_NOF_REGS];

  /* CRCDropped Pck Cnt: Counts all CRC packets with size           */
  /* less than 128B that dropped in the fdt                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2cab */

     /* CrcDroppedPckCnt: Crc-Dropped-Packet-Counter. This           */
     /* 31-bit counter holds the number of data packets with         */
     /* size smaller than 128B with CRC error that dropped in        */
     /* the FDT. This register is clear on read. This register       */
     /* is clear on read.                                            */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crc_dropped_pck_cnt;

     /* CrcDroppedPckCnt0: Crc-Dropped-Packet-Counter-Overflow.      */
     /* This bit is set when the counter exceeds 31 bits. The        */
     /* overflow flag is cleared when read. This register is         */
     /* clear on read. This register is clear on read.               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crc_dropped_pck_cnt0;

  } __ATTRIBUTE_PACKED__ crcdropped_pck_cnt_reg;

  /* Tdm Cells Counter: Counts all transmitted TDM cells.           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2cac */

     /* TdmDataCellCnt: TDM-Data-Cell-Counter. This 31-bit            */
     /* counter holds the number of TDM cells transmitted to the     */
     /* MACT. The counter does not stop at saturation. The counter     */
     /* is reset when read. This register is clear on read.          */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_data_cell_cnt;

     /* TdmDataCellCnt0: TDM-Data-Cell-Counter-Overflow. This bit     */
     /* is set when the counter exceeds 31 bits. This register is     */
     /* clear on read. This register is clear on read.               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_data_cell_cnt0;

  } __ATTRIBUTE_PACKED__ tdm_cells_counter_reg;

  /* Local Tdm Cells Counter: Counts all transmitted TDM            */
  /* local cells.                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2cad */

     /* LocalTdmDataCellCnt: Local-TDM-Data-Cell-Counter. This        */
     /* 31-bit counter holds the number of TDM cells transmitted     */
     /* to the EGQ . The counter does not stop at saturation. The      */
     /* counter is reset when read. This register is clear on        */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD local_tdm_data_cell_cnt;

     /* LocalTdmDataCellCnt0: Local                                  */
     /* -TDM-Data-Cell-Counter-Overflow. This bit is set when the     */
     /* counter exceeds 31 bits. This register is clear on read.      */
     /* This register is clear on read.                              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD local_tdm_data_cell_cnt0;

  } __ATTRIBUTE_PACKED__ local_tdm_cells_counter_reg;

  /* Tdm And Link Load Configuration: New TDM configuration         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2cae */

     /* TdmDifSizeEn: Enable sending TDM packets with size           */
     /* different than 128B                                          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_dif_size_en;

     /* IptTdmDifSizeEn: Enable sending TDM packets coming from      */
     /* the IPT with size different than 128B                        */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ipt_tdm_dif_size_en;

     /* GciLinkLoadEvent: Define the relevant GCI event to count     */
     /* into the link load watchdog 00: link load disable 01:        */
     /* count only GCI event 01 10: count only GCI event 01 , 10     */
     /* 11: count all only GCI event                                 */
     /* range: 3:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD gci_link_load_event;

     /* Gcilinkloadwdp: Define the watchdog period to the link       */
     /* load leaky bucket. If the link does not receive a GCI        */
     /* indication for 2^(Gcilinkloadwdp+5), the leaky bucket        */
     /* will count down . A value 0 OR 7 resets the counters.        */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD gcilinkloadwdp;

     /* GciMaskResetTh: Define the FIFO level. Above it the FDT      */
     /* will ignore the link load vector. 0-24 for IP cells 0-32     */
     /* for TDM cells                                                */
     /* range: 12:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD gci_mask_reset_th;

     /* GciMaskResetHoldPd: Gci mask old period , define the         */
     /* time of holding the reset to the gci link mask in case       */
     /* of fifo above the TH . The hold period is in 32 clocks       */
     /* range: 15:13, access type: RW, default value: 0x5            */
     SOC_PETRA_REG_FIELD gci_mask_reset_hold_pd;

     /* CpuTdm2BytesFtmh: Tdm cpu packets from the ire comes         */
     /* with optimized FTMH                                          */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpu_tdm2_bytes_ftmh;

  } __ATTRIBUTE_PACKED__ tdm_and_link_load_configuration_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_FDT_REGS;
/* Block definition: FCR */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3200 */

     /* SrcDvCngLinkEv: Source device change link event One of       */
     /* the 36 link connectivity map entries has changed. Auto        */
     /* cleared when SrcDvCngLink is read. Note that after            */
     /* connecting to the fabric after system power up, this bit     */
     /* is set.                                                      */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD src_dv_cng_link_ev;

     /* CPUCntCellFNE: CPU-Control-FIFO not empty. The register       */
     /* presents the non-empty state of the FIFO and is cleared      */
     /* only when the last word is read from the FIFO.               */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpucnt_cell_fne;

     /* LocalRoutFsOvf: Local route flow status fifo over flow       */
     /* event Cleared when reading LocalRoutOvfCnt register.         */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD local_rout_fs_ovf;

     /* LocalRoutrcOvf: Local route reach fifo over flow event       */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD local_routrc_ovf;

     /* ReachFifoOvf: Reachability fifo over flow event              */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD reach_fifo_ovf;

     /* FlowFifoOvf: flow status fifo over flow event                */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD flow_fifo_ovf;

     /* CreditFifoOvf: credit fifo over flow event                   */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD credit_fifo_ovf;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3210 */

     /* SrcDvCngLinkEvMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD src_dv_cng_link_ev_mask;

     /* CPUCntCellFNEMask: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpucnt_cell_fnemask;

     /* LocalRoutfsOvfMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD local_routfs_ovf_mask;

     /* LocalRoutrcOvfMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD local_routrc_ovf_mask;

     /* ReachFifoovfMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD reach_fifoovf_mask;

     /* FlowFifoovfMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD flow_fifoovf_mask;

     /* CreditFifoovfMask: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD credit_fifoovf_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Gtimer Configuration register : Timer to enable counting       */
  /* cells in a specific time period.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3254 */

     /* TimeCountConfig: The time period that all the counters       */
     /* count.using this timer, the overflow bit of each counter     */
     /* indicates the end of the time count                          */
     /* range: 30:0, access type: RW, default value: 31'hee6b27f     */
     SOC_PETRA_REG_FIELD time_count_config;

     /* CounterReset: Reset all gtimers counters.                    */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD counter_reset;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Activate Gtimer: Start counters that are defined as            */
  /* gtimer.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3255 */

     /* ActivateGtimer: Starts counters that are defined as          */
     /* gtimer.                                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD activate_gtimer;

  } __ATTRIBUTE_PACKED__ activate_gtimer_reg;

  /* FCREnablers And Filter Match Input Link: fcr command           */
  /* enabler                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3260 */

     /* DisFlSts: Discard-Queue/Flow-Status-control cells.           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_fl_sts;

     /* DisCrdFCR: Discard-Credit-Cells.                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_crd_fcr;

     /* DisSR: Discard-Source-Routed control cells.                  */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_sr;

     /* TrapAllCnt: Trap-All control cells to the CPU.               */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD trap_all_cnt;

     /* MtchAct: Match-Action for programmable filter 0: Count       */
     /* and forward 1: Count and discard 2: Count and Trap 3:        */
     /* Count, Trap and forward (Copy).                              */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mtch_act;

     /* FCRMtchLogicNot: If set, reverses the logic of the           */
     /* programmable filter.                                         */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fcrmtch_logic_not;

     /* PcMtchLink: Input link for the match filter.                 */
     /* range: 12:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pc_mtch_link;

     /* PcMtchLinkOn: Enable bit for the link match.                 */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pc_mtch_link_on;

     /* FcrCountByGtimer: Enables using gtimer for status            */
     /* counters.                                                    */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fcr_count_by_gtimer;

  } __ATTRIBUTE_PACKED__ fcrenablers_and_filter_match_input_link_reg;

  /* Connectivity Map Change Event Registers0: Source device        */
  /* changed 0 - holds one bit per link to indicate if the          */
  /* source connected to links changed (for links31:0)              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3261 */

     /* SrcDvCngLinkL: A bit that is asserted indicates that a       */
     /* change occurred in the corresponding connectivity map        */
     /* register (SrcDvCngLinkL[0]=Link0...). Interrupt source for      */
     /* links 0 to 31 . The interrupt is cleared after reading       */
     /* SrcDvCngLinkH This register is clear on read. This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD src_dv_cng_link_l;

  } __ATTRIBUTE_PACKED__ connectivity_map_change_event_registers_reg[SOC_PB_FCR_CONNECTIVITY_MAP_CHANGE_EVENT_REGISTERS_REG_NOF_REGS];

  /* Fap20b Destination Id Bitmap: This 128-bit bitmap holds        */
  /* one bit for the first 128 device ids to indicate whether       */
  /* the source device is fap20b (1 is fap20b).                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3263 */

     /* Fap20bDestinationIdBitmap: This 128-bit bitmap holds one     */
     /* bit for the first 128 device ids to indicate whether the     */
     /* source device is fap20b (1 is fap20b).                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fap20b_destination_id_bitmap;

  } __ATTRIBUTE_PACKED__ fap20b_destination_id_bitmap_reg[SOC_PB_FCR_FAP20B_DESTINATION_ID_BITMAP_REG_MULT_NOF_REGS];

  /* Connectivity Map Registers[0..35]: The connectivity            */
  /* table holds the source device that is connected to each        */
  /* link (16'h0070-16'h0093, link #1 - address 70 , link #35       */
  /* - address 93)                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3270 */

     /* SourceDeviceID: Source Device ID of link N                   */
     /* (0=<N<=35). The unique programmable ID of the downstream      */
     /* device. (With this value one can know the device ID          */
     /* connected to this link.)                                     */
     /* range: 10:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD source_unit;

     /* SourceDeviceLevel: Source Device Level of link N.            */
     /* Indicates the source of the cell.x0x => FOP, 010 => FE3,     */
     /* X11 => FE2, 110 =>FE1                                        */
     /* range: 13:11, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD source_device_level;

     /* SourceDeviceLink: Source Device Link Number of link N        */
     /* The link number of the source device.                        */
     /* range: 20:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD source_device_link;

  } __ATTRIBUTE_PACKED__ connectivity_map_registers_reg[SOC_PB_FCR_REGS_CONNECTIVITY_MAP_REGISTERS_REG_ARRAY_SIZE];

  /* Credit Cells Counter: Credit-Cells-Counter -gtimer.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3294 */

     /* CreditCellsCounter: Credit-Cells-Counter. This register      */
     /* is clear on read.                                            */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD credit_cells_counter;

     /* CreditCellsCounterOvf: Credit Cells Counter over flow        */
     /* indication. This register is clear on read.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD credit_cells_counter_ovf;

  } __ATTRIBUTE_PACKED__ credit_cells_counter_reg;

  /* Flow Status Cells Counter: Flow Status-Cells-Counter           */
  /* -gtimer.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3295 */

     /* FsCellsCounter: Flow status-Cells-Counter. This register     */
     /* is clear on read.                                            */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fs_cells_counter;

     /* FsCellsCounterOvf: Flow status Cells Counter over flow       */
     /* indication. This register is clear on read.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_cells_counter_ovf;

  } __ATTRIBUTE_PACKED__ flow_status_cells_counter_reg;

  /* Reachability Cells Counter: Reachability-Cells-Counter -       */
  /* gtimer.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3296 */

     /* ReachCellsCounter: Reachability-Cells-Counter. This          */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD reach_cells_counter;

     /* ReachCellsCounterOvf: Reachability Cells Counter over        */
     /* flow indication. This register is clear on read.             */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD reach_cells_counter_ovf;

  } __ATTRIBUTE_PACKED__ reachability_cells_counter_reg;

  /* Total Cells Counter: Total-Cells-Counter -gtimer.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3298 */

     /* TotalCellsCounter: Total-Cells-Counter. This register is     */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_cells_counter;

     /* TotalCellsCounterOvf: Total Cells Counter over flow          */
     /* indication. This register is clear on read.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD total_cells_counter_ovf;

  } __ATTRIBUTE_PACKED__ total_cells_counter_reg;

  /* Cell Drop Counter0: Dropped cells counter 0 -count the         */
  /* dropped credits and flow status cells.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3299 */

     /* CreditDropCount: Credit_drop_count -counts dropped cells     */
     /* according to fifo overflow. This register is clear on        */
     /* read.                                                        */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD credit_drop_count;

     /* CreditDropCountOvf: Credit drop counter overflow             */
     /* indication. This register is clear on read.                  */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD credit_drop_count_ovf;

     /* FsDropCount: Fs_drop_count -counts dropped cells             */
     /* according to fifo overflow. This register is clear on        */
     /* read.                                                        */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_drop_count;

     /* FsDropCountOvf: Flow status drop counter overflow            */
     /* indication. This register is clear on read.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_drop_count_ovf;

  } __ATTRIBUTE_PACKED__ cell_drop_counter0_reg;

  /* Cell Drop Counter1: Dropped cells counter 1 -counts the        */
  /* dropped reachability cells.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x329a */

     /* ReachDropCount: Reach_drop_count -counts dropped cells       */
     /* according to fifo overflow. This register is clear on        */
     /* read.                                                        */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD reach_drop_count;

     /* ReachDropCountOvf: Reachability drop counter overflow        */
     /* indication. This register is clear on read.                  */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD reach_drop_count_ovf;

  } __ATTRIBUTE_PACKED__ cell_drop_counter1_reg;

  /* Programmable Control Cell Counter0: The following six          */
  /* registers, define a filter (compare value and mask) to         */
  /* be applied to all incoming control cells. Depending on          */
  /* the match or lack of it, an action is triggered as             */
  /* programmed. This is useful for debugging.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a1 */

     /* PCMtchCtrlLb0: PC-Match-Ctrl-Cells-Labels0 Match mask        */
     /* for bits [77:46] of cell.                                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_ctrl_lb0;

  } __ATTRIBUTE_PACKED__ programmable_control_cell_counter_reg[SOC_PB_FCR_PROGRAMMABLE_CONTROL_CELL_COUNTER_REG_NOF_REGS];

  /* Programmable Control Cell Counter Mask0: The mask              */
  /* registers mask the Don't Care bits in the filter.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a4 */

     /* PCMtchCtrlMsk0: PC-Match-Ctrl-Cells-Mask0 Don't care         */
     /* bits mask for bits [77:46] of cell.                          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_ctrl_msk0;

  } __ATTRIBUTE_PACKED__ programmable_control_cell_counter_mask_reg[SOC_PB_FCR_PROGRAMMABLE_CONTROL_CELL_COUNTER_MASK_REG_NOF_REGS];

  /* Programmable Cells Counter: Programmable-Cells-Counter         */
  /* -gtimer.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a7 */

     /* PrgCtrlCellCnt: Programmable-Cells-Counter. This             */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prg_ctrl_cell_cnt;

     /* PrgCtrlCellCnto: Programmable-Cells-Counter overflow.        */
     /* This register is clear on read.                              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD prg_ctrl_cell_cnto;

  } __ATTRIBUTE_PACKED__ programmable_cells_counter_reg;

  /* Control Cell FIFOBuffer: CPU-Control-FIFO-cells[77:8]          */
  /* -Cells captured for the CPU are stored in a 70-bit wide        */
  /* FIFO. (16'h00a9-16'h00ab)                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a9 */

     /* ControlCellFIFOBuffer: CPU-Control-FIFO-cells[77:8]          */
     /* -Cells captured for the CPU are stored in a 70-bit wide      */
     /* FIFO. The CPU may read a 70-bit cell by reading three        */
     /* 32-bit words. When reading word-2 the cell FIFO is           */
     /* advanced. (Word-0 contains cell[77:46], word-1 contains      */
     /* cell[45:14], and word-2 contains cell[13:8] and 26 '0'       */
     /* bits.)                                                       */
     /* range: 31:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD control_cell_fifobuffer;

  } __ATTRIBUTE_PACKED__ control_cell_fifobuffer_reg[SOC_PB_FCR_CONTROL_CELL_FIFOBUFFER_REG_MULT_NOF_REGS];

} __ATTRIBUTE_PACKED__ SOC_PB_FCR_REGS;
/* Block definition: FCT */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3000 */

     /* UnrchDestEvt: Unreachable-Destination-Event. Set when a      */
     /* packet arrives at the FCT but there is no valid link to      */
     /* forward it through. The data of the packet is written to     */
     /* the UnrchDest register. This is an interrupt source, and      */
     /* is cleared when UnrchDest is read.                           */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD unrch_dest_evt;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3010 */

     /* UnrchDestEvtMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD unrch_dest_evt_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Fct Enabler Register : Fct command register.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3060 */

     /* DisSts: Discards flow status control cells                   */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dis_sts;

     /* DisCrd: Discards credit control cells                        */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dis_crd;

     /* DisRch: Discards reachability control cells                  */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dis_rch;

     /* DisLclrt: Disables or enables control cells local            */
     /* routing 0:enabled 1:disabled                                 */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_lclrt;

     /* ForceAllLocal: Enable forcing all credits and flow           */
     /* status to the local rout interface                           */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_all_local;

     /*
      * A union of dis_sts, dis_crd and dis_rch
      *  Those fields (0 - 2) are used for controll cells enable/disable
      */
     SOC_PETRA_REG_FIELD stat_credit_and_rch_ctrl;

     /* CntByGtimer: Enable counting by gtimer (gtimer config        */
     /* via the fcr)                                                 */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnt_by_gtimer;

  } __ATTRIBUTE_PACKED__ fct_enabler_reg;

  /* Cpu Transmit Cell1: TxCtrCellBuff0-transmit control            */
  /* cells buffer. The CPU writes to a buffer the cell it            */
  /* wants to transmit                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3061 */

     /* CpuCellBuff0: Transmit control cells buffer. The CPU          */
     /* writes to a buffer the cell it wants to transmit . The       */
     /* mapping of the cell is as follows:                           */
     /* TxCtrCellBuff0=\{control_cell[77:46]\}                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_cell_buff0;

  } __ATTRIBUTE_PACKED__ cpu_transmit_cell1_reg;

  /* Cpu Transmit Cell2: TxCtrCellBuff1-transmit control            */
  /* cells buffer. The CPU writes to a buffer the cell it            */
  /* wants to transmit                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3062 */

     /* CpuCellBuff1: Transmit control cells buffer. The CPU          */
     /* writes to a buffer the cell it wants to transmit . The        */
     /* mapping of the cell is as follows:                           */
     /* TxCtrCellBuff1=\{control_cell[45:14]\}                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_cell_buff1;

  } __ATTRIBUTE_PACKED__ cpu_transmit_cell2_reg;

  /* Cpu Transmit Cell3: TxCtrCellBuff2-transmit control            */
  /* cells buffer. The CPU writes to a buffer the cell it            */
  /* wants to transmit                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3063 */

     /* CpuCellBuff2: Transmit control cells buffer. The CPU          */
     /* writes to a buffer the cell it wants to transmit . The        */
     /* mapping of the cell is as follows:                           */
     /* TxCtrCellBuff2=\{control_cell[13:8],26'h0\}                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_cell_buff2;

  } __ATTRIBUTE_PACKED__ cpu_transmit_cell3_reg;

  /* Cpu Transmit Cell Link Number: Transmit cell output            */
  /* link:define the output link for the source-routed              */
  /* control cell written from the CPU                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3064 */

     /* CpuLinkNum: Transmit cell output link                        */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_link_num;

  } __ATTRIBUTE_PACKED__ cpu_transmit_cell_link_number_reg;

  /* Cpu Transmit Cells Trigger : Transmit control cells            */
  /* trigger:when asserted by the CPU the cell written by the       */
  /* CPU is transmitted . The trigger is reset by the FCT           */
  /* once the cell is transmitted.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3066 */

     /* CpuTrg: Transmit control cells trigger                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_trg;

  } __ATTRIBUTE_PACKED__ cpu_transmit_cells_trigger_reg;

  /* Transmitted Control Cells Counter: Control cells               */
  /* counter:counts all the transmitted cell to the mac. The         */
  /* counter doesn't stop at saturation. The counter is              */
  /* cleared when read.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3070 */

     /* CtrlCellCnt: Control cells counter This register is          */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ctrl_cell_cnt;

     /* CtrlCellCnto: Control cells counter overflow . This bit      */
     /* is set when the counter exceed 31 bits This register is      */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ctrl_cell_cnto;

  } __ATTRIBUTE_PACKED__ transmitted_control_cells_counter_reg;

  /* Unreachable Destination : This register keeps the first        */
  /* destination that is unreacable from this source fap.           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3071 */

     /* UnrchDest: \{Cell type[2:0], destination-Id[10:0]\} of       */
     /* the unreachable (by RTP distribution table) control          */
     /* cell. Applied only toflow-status, credit or CPU              */
     /* destination-routed cells only. The register keeps its        */
     /* value until read by CPU. This register is clear on read.     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD unrch_dest;

     /* UnrchDestEvt: Unreachable destination event occurred.        */
     /* This register is clear on read.                              */
     /* range: 14:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD unrch_dest_evt;

     /* UnrchCrdtCnt: Counts every unreached credit. This            */
     /* register is clear on read.                                   */
     /* range: 30:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD unrch_crdt_cnt;

     /* UnrchCrdtCnto: Unreached credit counter overflow. This       */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD unrch_crdt_cnto;

  } __ATTRIBUTE_PACKED__ unreachable_destination_reg;

  /* Local Route Cells Counter : Control cell local route           */
  /* counter.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3072 */

     /* LocalRtCellcnt: Counts all local route cells. This           */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD local_rt_cellcnt;

     /* LocalRtCellcnto: Local route counter overflow. This          */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD local_rt_cellcnto;

  } __ATTRIBUTE_PACKED__ local_route_cells_counter_reg;

  /* Transmitted Fs Cells Counter: Flow status cells                */
  /* counter:counts all the transmitted flow status cell to         */
  /* the mac. The counter doesn't stop at saturation. The             */
  /* counter is cleared when read.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3075 */

     /* FsCellCnt: Fs cells counter This register is clear on        */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fs_cell_cnt;

     /* FsCellCnto: Fs cells counter overflow . This bit is set      */
     /* when the counter exceed 31 bits This register is clear       */
     /* on read.                                                     */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_cell_cnto;

  } __ATTRIBUTE_PACKED__ transmitted_fs_cells_counter_reg;

  /* Transmitted Cr Cells Counter: Credit status cells              */
  /* counter:counts all the transmitted Credit cell to the          */
  /* mac. The counter doesn't stop at saturation. The counter         */
  /* is cleared when read.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3076 */

     /* CrCellCnt: Credit cells counter This register is clear       */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cr_cell_cnt;

     /* CrCellCnto: Credit cells counter overflow . This bit is      */
     /* set when the counter exceed 31 bits This register is         */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cr_cell_cnto;

  } __ATTRIBUTE_PACKED__ transmitted_cr_cells_counter_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_FCT_REGS;
/* Block definition: MESH TOPOLOGY */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Mesh Topology Enablers:                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3400 */

     /* ForceSync: Must be set if the fabric interface is not        */
     /* connected with any other FAP                                 */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stan_aln;

     /* SyncMsgRxAdjFactor: Set for fabric-less topology: Set to     */
     /* 0x22 for 2-FAPs system. Set to 0x23 for 3 or more FAPs       */
     /* system. Set to 0 if an SOC_SAND_FE200 is used.                        */
     /* range: 8:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD in_system;

     /* SyncMsgTxAdjFactor: Do not change value                      */
     /* range: 16:9, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fld0;

     /* SyncMsgGenPeriod: Do not change value                        */
     /* range: 20:17, access type: RW, default value: 0xa            */
     SOC_PETRA_REG_FIELD fld1;

     /* SyncMsgReplicate: Must be asserted.                          */
     /* range: 23:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD reserved;

     /* DlyVldBitMsk: Must be asserted for fabric-less topology      */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD multi_fap;

     /* StanAln2: Must be set if the fabric interface is not         */
     /* connected with any other FAP                                 */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stan_aln2;

     /* trig: Must be asserted.                                 */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD trig;

  } __ATTRIBUTE_PACKED__ mesh_topology_reg;

  /* Init: Delay Test Cells configuration.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3403 */

     /* Init:                                                        */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD init;

     /* config1:                                                     */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD config1;

     /* config2: Must be de-asserted.                                */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD config2;

  } __ATTRIBUTE_PACKED__ init_reg;

  /* mesh_config_1_reg:                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr;  /* 0x3404 */

     /* Must be 0xD                                                 */
     SOC_PETRA_REG_FIELD mesh_config_1_reg;

  } __ATTRIBUTE_PACKED__ mesh_config_1_reg;

  /* mesh_config_2_reg:                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr;  /* 0x3405 */

     /* Must be 0xD                                                 */
     SOC_PETRA_REG_FIELD mesh_config_2_reg;

  } __ATTRIBUTE_PACKED__ mesh_config_2_reg;

  /* Time Cell Count:                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3440 */

     /* rcv_ctl1: DetectFap counter 1 This register is clear      */
     /* on read.                                                     */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcv_ctl1;

     /* RcvDlyTstCnt: DetectFap counter 2 This register is clear     */
     /* on read.                                                     */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcv_ctl2;

  } __ATTRIBUTE_PACKED__ fap_detect_ctrl_cells_cnt_reg;

  struct
  {
    SOC_PETRA_REG_ADDR  addr;  /* 0x3445 */

    SOC_PETRA_REG_FIELD status;

  } __ATTRIBUTE_PACKED__ mesh_status_cnt_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_MESH_REGS;
/* Block definition: RTP 	 */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3600 */

     /* LinkMaskChange: Link Mask Change                             */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_mask_change;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3610 */

     /* LinkMaskChangeMask: Bit 0 - Link Mask Change Mask Bit 1      */
     /* - not used                                                   */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_mask_change_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3620 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_RTP_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3630 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_RTP_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3640 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3641 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed.                           */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -:        */
     /* Write operation 1 -: Read operation                          */
     /* range: 31:31, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* RTP Enable: RTP Enable Register.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3660 */

     /* RTPWP: Watchdog-Period. Specifies the maximal time that      */
     /* can pass between the arrivals of two consecutive             */
     /* reachability messages from the same input link without       */
     /* declaring the link as malfunction. This parameter's          */
     /* units are 4096 chip clocks. A value of 0 disables            */
     /* watchdog operation.                                          */
     /* range: 3:0, access type: RW, default value: 0x8              */
     SOC_PETRA_REG_FIELD rtpwp;

     /* ACLM: ACL-Mask. Masks processing of the recieived ACL        */
     /* bit. If set, the ACL arriving is not considered for link     */
     /* up calculations.                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD aclm;

     /* RtpUpEn: Enables updatinges of of the reachability table     */
     /* by incoming reachability messages.                           */
     /* range: 6:6, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rtp_up_en;

     /* RtpEnMsk: Enable-Masking. If set, table data is masked       */
     /* with the link status.                                        */
     /* range: 7:7, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rtp_en_msk;

     /* RMGR: Reachability-Message-Generation-Period (in units       */
     /* of 128 chip clocks). Note that this is the generation        */
     /* rate of a single reachability message. Multiplying it by     */
     /* 36 is the period of sending one single message per           */
     /* output link (i.e., in units of 128*24=3072 chip clocks)      */
     /* and this should match the Watchdog-Period of the             */
     /* receiving device. Programming to values 4, 3, 2 or 1         */
     /* results in an undetermined operation. Programming to a       */
     /* value of 0 disables the generation of reachability           */
     /* messages. The default value 0x0 is to ensure that no         */
     /* reachability messages are sent before the FAP's Pipe-ID      */
     /* is written.                                                  */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rmgr;

     /* EnLocalLinkReduction: If set, the link state sent to the     */
     /* scheduler, for rate adaptation, is masked by the             */
     /* accessability of the local Soc_petra ID                          */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD en_local_link_reduction;

     /* EnLocalLinkReductionMC: If set, the link state sent to       */
     /* the scheduler, for rate adaptation, is masked by the         */
     /* all-reachable vector                                         */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD en_local_link_reduction_mc;

  } __ATTRIBUTE_PACKED__ rtp_enable_reg;

  /* RTP By Pass: RTP Bypass register                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3661 */

     /* FrcLnksHigh: Force-all-links-high.                           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_lnks_high;

     /* FrcLnkNumHigh: Force-link-number-high. The entire            */
     /* traffic is routed through link number FrcLnkNum.             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_lnk_num_high;

     /* FrcLnkNum: The number of the forced link.                    */
     /* range: 7:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_lnk_num;

  } __ATTRIBUTE_PACKED__ rtp_by_pass_reg;

  /* RTP Coexist configuration register:                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3662 */

     /* RTPCoexist: Bit per serial link that determines the LSB      */
     /* of the Soc_petra-ID that the RTP transmits in the                */
     /* reachability cells. This bit should be used when the         */
     /* Soc_petra is used in a system with SOC_SAND_FAP20V. The RTP will          */
     /* transmit over link "n" a source Soc_petra-ID ==                  */
     /* \{PipeID[10:1], DestCfg[n]\} This register corresponds       */
     /* to links 0 to 35                                             */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rtpcoexist;

  } __ATTRIBUTE_PACKED__ rtp_coexist_configuration_reg[SOC_PB_RTP_RTP_COEXIST_CONFIGURATION_REG_MULT_NOF_REGS];

  /* Multicast Link Up:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3664 */

     /* MCLinkUp: Multicast link up state for links 35:0. 1 -:       */
     /* The link is up. Multicast traffic may exit on that link.     */
     /* 0 -: The link cannot transfer spatial multicast traffic.     */
     /* Note: This register and the following one are meaningful     */
     /* only if bit BypassUpdate is set in the register              */
     /* "Multicast Distribution Configuration" allowed links         */
     /* update rate . Each bit in these registers is logically       */
     /* ANDed with the corresponding links state to determine        */
     /* the validity of the link for multicast traffic.              */
     /* range: 31:0, access type: RW, default value: 36'hfffffffff   */
     SOC_PETRA_REG_FIELD mclink_up;

  } __ATTRIBUTE_PACKED__ multicast_link_up_reg[SOC_PB_RTP_MULTICAST_LINK_UP_REG_MULT_NOF_REGS];

  /* Multicast Distribution Configuration register: Multicast       */
  /* distribution configuration                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3666 */

     /* MulNumTrav: The number of times the unicast distribution     */
     /* table is traversed prior to updating the                     */
     /* mc-available-links register: 0 -: The allowed multicast      */
     /* links are updated when the RTP finishes traversing the       */
     /* distribution table. 1 -: The allowed multicast links are     */
     /* updated when the RTP finishes traversing the                 */
     /* distribution table twice. 2 -: The allowed multicast         */
     /* links are updated when the RTP finishes traversing the       */
     /* distribution table three times. 3 -: The allowed             */
     /* multicast links are updated when the RTP finishes            */
     /* traversing the distribution table 4 times.                   */
     /* range: 1:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD mul_num_trav;

     /* BypassUpdate: When set, the state of the links for           */
     /* multicast distribution is taken from the "Multicast Link     */
     /* Up" register. In this case, bits 1:0 of this register        */
     /* are ignored.                                                 */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bypass_update;

     /* EnableMCLUpdates: Enables updates of the multicast links     */
     /* status register.                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_mclupdates;

     /* MCSlowUpdates: 0 - Performs as Soc_petraA, meaning, the          */
     /* traverse results are ANDed. This mode enables fast bring     */
     /* down of the all-reachable, and slow bring up. 1 - The        */
     /* traverse results are Ored. This mode enables slow bring      */
     /* down of the all-reachable and fast bring up. 2 - The         */
     /* traverse results are used for the all-reachable if all       */
     /* scans show same value. This mode enables slow jitter of      */
     /* the all-reachable, meaning, slow bring down and slow         */
     /* bring up.                                                    */
     /* range: 5:4, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD mcslow_updates;

  } __ATTRIBUTE_PACKED__ multicast_distribution_configuration_reg;

  /* Maximum Base Index:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3667 */

     /* MaxBI: This number sets that maximum base index that is      */
     /* transmitted by the Soc_petra in reachability messages.           */
     /* (MaxBI+1)*32-1 is the maximal allowable Soc_petra-ID in the      */
     /* system.                                                      */
     /* range: 5:0, access type: RW, default value: 0x3f             */
     SOC_PETRA_REG_FIELD max_bi;

  } __ATTRIBUTE_PACKED__ maximum_base_index_reg;

  /* Link Active Mask:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3668 */

     /* LnkActvMsk: Bit per serial link, indicating if the link      */
     /* is considered up (available). If a link is masked, data      */
     /* is not sent through it. This is used to mask the output      */
     /* from the RTP distribution table memory. Access: Read.        */
     /* range: 31:0, access type: RO, default value: 36'hfffffffff   */
     SOC_PETRA_REG_FIELD lnk_actv_msk;

  } __ATTRIBUTE_PACKED__ link_active_mask_reg[SOC_PB_RTP_LINK_ACTIVE_MASK_REG_MULT_NOF_REGS];

  /* ACL Received:                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3670 */

     /* ACLRecieve: ACL received on reachability message, for        */
     /* link N. A value of 0 means that the link is down.            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD aclrecieve;

  } __ATTRIBUTE_PACKED__ acl_received_reg[SOC_PB_RTP_ACL_RECEIVED_REG_MULT_NOF_REGS];

  /* Locally generated ACL:                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3672 */

     /* LocalACL: ACL value which is extracted from the MAC's        */
     /* leaky bucket for input link N, and sent out through          */
     /* output link N.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD local_acl;

  } __ATTRIBUTE_PACKED__ locally_generated_acl_reg[SOC_PB_RTP_LOCALLY_GENERATED_ACL_REG_MULT_NOF_REGS];

  /* MC Distribution map:                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3674 */

     /* MCDistribution: Returns the MC distribution map.             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mcdistribution;

  } __ATTRIBUTE_PACKED__ mc_distribution_map_reg[SOC_PB_RTP_MC_DISTRIBUTION_MAP_REG_MULT_NOF_REGS];

  /* Exclude Dest ID for MC Links 0:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3676 */

     /* DestID: Destination specified in this field is excluded      */
     /* from the construction of the mc-avail-links register.        */
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dest_id;

     /* Valid: Defines if DestID field is valid                      */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD valid;

  } __ATTRIBUTE_PACKED__ exclude_dest_id_for_mc_links__reg[SOC_PB_RTP_EXCLUDE_DEST_ID_FOR_MC_LINKS__REG_NOF_REGS];

  /* Allowed Links:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3680 */

     /* AllowedLinks: A bit set enables the link. A cleared bit      */
     /* will ensure no traffic is sent on that link. Cells are       */
     /* transmitted on Allowed links that are eligible for           */
     /* sending traffic (e.g. link status is up).                    */
     /* range: 31:0, access type: RW, default value: 36'hfffffffff   */
     SOC_PETRA_REG_FIELD allowed_links;

  } __ATTRIBUTE_PACKED__ allowed_links_reg[SOC_PB_RTP_ALLOWED_LINKS_REG_MULT_NOF_REGS];

  /* MC Traverse Rate:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3682 */

     /* MCTraverseRate: Defines the rate for scanning the UC         */
     /* table if order to build the MC-all-reachable vector. The     */
     /* units are in clock cycles.                                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mctraverse_rate;

  } __ATTRIBUTE_PACKED__ mc_traverse_rate_reg;

  /* Allowed Links for Reachability messages:                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3683 */

     /* AllowedLinksForRM: Defined links which are eligible to       */
     /* send reachability messages. This register is typically       */
     /* used for graceful link shutdown                              */
     /* range: 31:0, access type: RW, default value: 36'hfffffffff   */
     SOC_PETRA_REG_FIELD allowed_links_for_rm;

  } __ATTRIBUTE_PACKED__ allowed_links_for_reachability_messages_reg[SOC_PB_RTP_ALLOWED_LINKS_FOR_REACHABILITY_MESSAGES_REG_MULT_NOF_REGS];

} __ATTRIBUTE_PACKED__ SOC_PB_RTP_REGS;
/* Block definition: FABRIC MAC */
typedef struct
{
  uint32   nof_instances; /* 3 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c00 */

     /* IntReg1: If set, interrupt from InterruptRegister1 has       */
     /* occurred.                                                    */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_reg1;

     /* IntReg2: If set, interrupt from InterruptRegister2 has       */
     /* occurred.                                                    */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_reg2;

     /* IntReg3: If set, interrupt from InterruptRegister3 has       */
     /* occurred.                                                    */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_reg3;

     /* IntReg4: If set, interrupt from InterruptRegister4 has       */
     /* occurred.                                                    */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_reg4;

     /* IntReg5: If set, interrupt from InterruptRegister4 has       */
     /* occurred.                                                    */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_reg5;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Register1: This register contains the                */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c01 */

     /* RxCRCErrN Int: Receiver CRC Error at link N. The bit is      */
     /* asserted when a CRC error cell is detected.                  */
     /* range: 11:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_crcerr_n_int;

     /* WrongSize_Int: Wrong data cell size is detected on MACR.     */
     /* Valid only when FscEn=0.                                     */
     /* range: 23:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wrong_size_int;

  } __ATTRIBUTE_PACKED__ interrupt_1_reg;

  /* Interrupt Register2: This register contains the                */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c02 */

     /* LOS Int: Loss of Signal (LOS). The receiver of the           */
     /* SerDes has internal signal-detection circuitry. When 1,      */
     /* this indicates the presence of a weak signal condition       */
     /* (<85 mV differential) at the channels input line             */
     /* interface for AC-coupled links. The signal detection         */
     /* circuitry is intended to be an indication of gross           */
     /* signal error conditions, such as a bad connection or no      */
     /* transmitting signals.                                        */
     /* range: 11:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD los_int;

     /* RxMisAErrN Int: If set, a misalignment (comma code group     */
     /* error) is detected at the corresponding link N.              */
     /* range: 23:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mis_aerr_n_int;

  } __ATTRIBUTE_PACKED__ interrupt_2_reg;

  /* Interrupt Register3: This register contains the                */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c03 */

     /* LnklvlAgeN Int: This bit is asserted whenever the MAC N      */
     /* link-level flow-control aging mechanism is activated.        */
     /* range: 11:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD lnklvl_age_n_int;

     /* LnklvlHaltN Int: This bit is asserted whenever the MAC N     */
     /* receives a Halt bit in an incoming data cell.                */
     /* range: 23:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD lnklvl_halt_n_int;

  } __ATTRIBUTE_PACKED__ interrupt_3_reg;

  /* Interrupt Register4: This register contains the                */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c04 */

     /* OOF Int: Out-Of-Frame. The receiver FEC decoder lost the     */
     /* frame alignment. Valid when using FEC decoding.              */
     /* range: 11:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD oof_int;

     /* DecErr Int: Decoding error (uncorrectable) at the            */
     /* receiver FEC decoder. Valid when using FEC decoding.         */
     /* range: 23:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dec_err_int;

  } __ATTRIBUTE_PACKED__ interrupt_4_reg;

  /* Interrupt Register5: This register contains the                */
  /* interrupt sources residing in this unit.                       */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x3c01 */

    /* WrongSizeN_Int: This bit is asserted whenever the MAC N      */
    /* receives a data cell with an invalid size (not in the        */
    /* 64-128B range for Variable Sized Cells)                      */
    /* range: 23:12, access type: RC, default value: 0x0            */
    SOC_PETRA_REG_FIELD wrong_size_n_int;

  } __ATTRIBUTE_PACKED__ interrupt_5_reg;

  /* Interrupt Register5: This register contains the                */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c05 */

     /* TransmitErr Int: Transmission correctable error              */
     /* detected. Valid when using FEC decoding.                     */
     /* range: 11:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD transmit_err_int;

     /* RxCtrlOverflow Int: Receiver control FIFO overflow. If       */
     /* set, the transmitter side has sent a control cell too        */
     /* quickly. Adjust the control burst parameters at the          */
     /* transmitter side.                                            */
     /* range: 23:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ctrl_overflow_int;

  } __ATTRIBUTE_PACKED__ interrupt_6_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c10 */

     /* IntReg1 IntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_reg1_int_mask;

     /* IntReg2 IntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_reg2_int_mask;

     /* IntReg3 IntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_reg3_int_mask;

     /* IntReg4 IntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_reg4_int_mask;

     /* IntReg5 IntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_reg5_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Interrupt Mask Register1: Each bit in this register            */
  /* corresponds to an interrupt source in Interrupt                */
  /* Register1. The interrupt source is masked by writing 0         */
  /* to the relevant bit in this register.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c11 */

     /* RxCRCErrN IntMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_crcerr_n_int_mask;

     /* WrongSize IntMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 23:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wrong_size_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_1_reg;

  /* Interrupt Mask Register2: Each bit in this register            */
  /* corresponds to an interrupt source in Interrupt                */
  /* Register2. The interrupt source is masked by writing 0         */
  /* to the relevant bit in this register.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c12 */

     /* LOS IntMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD los_int_mask;

     /* RxMisAErrN IntMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 23:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mis_aerr_n_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_2_reg;

  /* Interrupt Mask Register3: Each bit in this register            */
  /* corresponds to an interrupt source in Interrupt                */
  /* Register3. The interrupt source is masked by writing 0         */
  /* to the relevant bit in this register.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c13 */

     /* LnklvlAgeN IntMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD lnklvl_age_n_int_mask;

     /* LnklvlHaltN IntMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 23:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD lnklvl_halt_n_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_3_reg;

  /* Interrupt Mask Register4: Each bit in this register            */
  /* corresponds to an interrupt source in Interrupt                */
  /* Register4. The interrupt source is masked by writing 0         */
  /* to the relevant bit in this register.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c14 */

     /* OOF IntMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD oof_int_mask;

     /* DecErr IntMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 23:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dec_err_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_4_reg;

  /* Interrupt Mask Register5: Each bit in this register            */
  /* corresponds to an interrupt source in Interrupt                */
  /* Register4. The interrupt source is masked by writing 0         */
  /* to the relevant bit in this register.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c15 */

     /* TransmitErr IntMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD transmit_err_int_mask;

     /* RxCtrlOverflow IntMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 23:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ctrl_overflow_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_5_reg;

  /* Loopback And Link Level Flow Control Enable Register:          */
  /* Single MAC Loopback and Link Level Flow control enable         */
  /* Register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c03 */

     /* LclLpbkOn: Local loopback enable. This mode causes           */
     /* transmitted data from the MAC transmit end to be input       */
     /* into the MAC receive end. The loopback is executed           */
     /* inside the fabric MAC and, therefore, data is not            */
     /* transmitted through the SerDes.                              */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD lcl_lpbk_on;

     /* DoubleRateEn: If set, the MAC works at a double rate         */
     /* (6.25Gbps).                                                  */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD double_rate_en;

     /* LnkLvlFcTxEn: Enables/Disables the Tx link level flow        */
     /* control. If set, the HALT flag is the result of the          */
     /* threshold of the FIFOs. If reset, the HALT flag is           */
     /* always set to 0.                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD lnk_lvl_fc_tx_en;

     /* LnkLvlFcRxEn: If set, HALT flag is extracted from            */
     /* incoming cells. If reset, the HALT flag is always set to     */
     /* 0.                                                           */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD lnk_lvl_fc_rx_en;

  } __ATTRIBUTE_PACKED__ loopback_and_link_level_flow_control_enable_reg[SOC_PB_NOF_PER_LINK_REGS];

  /* Cntrl Intrlvd Mode Reg: Control Interleaving                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c18 */

     /* CntrlIntrlvdMode: If set, enables interleaving of            */
     /* control cells inside data cells. This would decrease the     */
     /* amount of time control cells are pending inside the MAC      */
     /* buffers before being sent and their burstiness level.        */
     /* This mode is only available in VSC mode. Also, if set,       */
     /* alignments of subsequent cells is performed (rather than     */
     /* padding cells that end in the middle of words with           */
     /* commas) and, as a result, better utilization of the link     */
     /* is achieved.                                                 */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cntrl_intrlvd_mode;

  } __ATTRIBUTE_PACKED__ cntrl_intrlvd_mode_reg;

  /* General Configuration Register: MAC general                    */
  /* configuration.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c60 */

     /* DisLlfcCells: If set, disables the creation of empty         */
     /* cells at the transmission side. This bit must be reset       */
     /* after the FAP ID register is written with the correct        */
     /* FAP ID.                                                      */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD enable_serial_link;

     /* DelCRCErrCell: Receive MAC CRC error cell delete. If the     */
     /* bit is set and a CRC error is detected in an incoming        */
     /* non-TDM cell, the cell is deleted. Otherwise, the CRC is     */
     /* checked and the cell is forwarded regardless of the          */
     /* check result (see RxCRCErrN).                                */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD del_crcerr_cell;

     /* DelTDMCRCErrCel: Receive MAC TDM CRC error cell. If the      */
     /* bit is asserted and a CRC error is detected in an            */
     /* incoming TDM cell, the cell is deleted. If the bit is        */
     /* negated, the CRC is checked and the cell is forwarded        */
     /* regardless of the check result (see RxCRCErrN).              */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD del_tdmcrcerr_cel;

     /* DelDataCellLB: If set and the leaky bucket output is         */
     /* low, the unicast and multicast data cells are deleted.       */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD del_data_cell_lb;

     /* DelFSCrCellLB: If set and the leaky bucket output is         */
     /* low, the flow status and credit control cells are            */
     /* deleted                                                      */
     /* range: 9:9, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD del_fscr_cell_lb;

     /* DelALLCellsLB: If set and the leaky bucket output is         */
     /* low, all cells are deleted                                   */
     /* range: 10:10, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD del_allcells_lb;

     /* DelWrongSizeCell: Receive MAC wrong size cell Delete. If     */
     /* the bit is set and a cell arrived that is not in the         */
     /* range of 64-128B, the cell is deleted. This                  */
     /* configuration is only valid in Variable Size Cell (VSC)      */
     /* mode.                                                        */
     /* range: 11:11, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD del_wrong_size_cell;

     /* TxCntCfg: Transmit Control and Data Counters. These bits     */
     /* control the functionality of the MAC-transmit counters       */
     /* (see TxCellCntN). 0: The counter counts both data            */
     /* (including link-level flow-control cells) and control        */
     /* cells. 1: The counter counts only control cells. 2: The      */
     /* counter counts only data cells (including link-level         */
     /* flow-control cells). 3: Reserved 4: The counter counts       */
     /* link-level flow-control cells. 5: The counter counts         */
     /* both data (without link-level flow-control cells) and        */
     /* control cells. 6: The counter counts only data cells         */
     /* (without link-level flow-control cells).                     */
     /* range: 18:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_cnt_cfg;

     /* RxCntCfg: Receive Control and Data Counters. These bits      */
     /* control the functionality of the MAC receive counters,       */
     /* specifying which good cells are to be counted. 0: The        */
     /* counter counts both data and control cells. In the worst     */
     /* case, only reachability messages are present. Their rate     */
     /* can be as low as one per 32*2048(=2^16) clocks. During       */
     /* this time 65K bits can arrive, i.e., BER larger than         */
     /* 10^-5 will not allow link_up with control cells. 1: The      */
     /* counter counts only control cells. 2: The counter counts     */
     /* only data cells (including link-level flow-control           */
     /* cells). 3: Reserved 4: The counter counts link-level         */
     /* flow-control cells. 5: The counter counts both data          */
     /* (without link-level flow-control cells) and control          */
     /* cells. 6: The counter counts only data cells (without        */
     /* link-level flow-control cells).                              */
     /* range: 21:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_cnt_cfg;

  } __ATTRIBUTE_PACKED__ enablers_reg;

  /* Leaky Bucket Control Register: This register configures        */
  /* the MAC leaky bucket parameters. The leaky bucket               */
  /* protects the device from faulty links, using hysteresis        */
  /* of cell error-rate measurement. The leaky bucket is             */
  /* increased when cells with no CRC errors and no decoding        */
  /* errors arrive, and decreased when a faulty cell is             */
  /* detected.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c61 */

     /* BktFillRate: Bucket-Fill-Rate. Number of good cells that     */
     /* add a token to the bucket. BktFillRate [3:0] must be         */
     /* configured to be no bigger than 0xB. The number              */
     /* BktFillRate [3:0] is the exponent of 2, i.e., the number     */
     /* of good cells adding a token to the bucket is                */
     /* 2^BktFillRate [3:0]. Good cell is defined according to       */
     /* RxCntCfg.                                                    */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bkt_fill_rate;

     /* BktLinkUpTh: Bucket-Link-Up-Threshold. When the link is      */
     /* down and the leaky bucket reaches this threshold, the        */
     /* link status is changed to up. If the                         */
     /* Bucket-Link-Up-Threshold equals 0, the links are always      */
     /* up. The maximum value is 63.                                 */
     /* range: 9:4, access type: RW, default value: 0x20             */
     SOC_PETRA_REG_FIELD bkt_link_up_th;

     /* BktLinkDnTh: Bucket-Link-Down-Threshold. If the              */
     /* Bucket-Link-Down-Threshold equals 63, the links are          */
     /* always down (unless Bucket-Link-Up-Threshold equals 0)       */
     /* range: 17:12, access type: RW, default value: 0x10           */
     SOC_PETRA_REG_FIELD bkt_link_dn_th;

     /* SigDetBktRstEna: If set, the LOS (analog detection of        */
     /* minimum signal amplitude) from the SerDes can cause the      */
     /* leaky bucket counter to reset.                               */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sig_det_bkt_rst_ena;

     /* AlignLckBktRstEna: If set, the 8b/10b decoder and comma      */
     /* detector can cause the leaky bucket counter to reset         */
     /* (only valid when not using FEC).                             */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD align_lck_bkt_rst_ena;

     /* FecDecoderOofRstEna: If set, the OOF signal for FEC          */
     /* decoder can cause the leaky bucket counter to reset          */
     /* (only valid when using FEC).                                 */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fec_decoder_oof_rst_ena;

  } __ATTRIBUTE_PACKED__ leaky_bucket_control_reg;

  /* Control Cell Burst Register: This register configures          */
  /* the Control Cell Mode transmitted by the MAC.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c62 */

     /* CntrlBurstPeriod: Configures the amount of data (in          */
     /* units of 8 bytes) between two consecutive control cell       */
     /* bursts. This mechanism limits the rate of the control        */
     /* cells, so that the receiver can handle it. It is mostly      */
     /* relevant when working in VSC mode without cell               */
     /* interleaving (In this mode, the control cells can only       */
     /* be sent after the data cell is done. This could take a       */
     /* while when the cell size is large, causing potential         */
     /* control cell burstiness).                                    */
     /* range: 7:0, access type: RW, default value: 0x8              */
     SOC_PETRA_REG_FIELD cntrl_burst_period;

     /* MaxCtrlCellBurst: Configures the maximum number of           */
     /* control cells that can be transmitted as one single          */
     /* burst with no data cells separating them. The number of      */
     /* control cells in such a burst is determined by               */
     /* (MaxCntrlCellBurst + 1). A value of MaxCntrlCellBurst ==     */
     /* 0 results in at least one data cell separating for every     */
     /* control cell transmission.                                   */
     /* range: 10:9, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD max_cntrl_cell_burst;

     /* CntrlCellChar: The character representing a start of a       */
     /* control cell                                                 */
     /* range: 19:12, access type: RW, default value: 0x1c           */
     SOC_PETRA_REG_FIELD cntrl_cell_char;

     /* TDMFragmentNumber: Configures the fragment number to be      */
     /* used to identify a TDM cell.                                 */
     /* range: 28:20, access type: RW, default value: 0x180          */
     SOC_PETRA_REG_FIELD tdmfragment_number;

  } __ATTRIBUTE_PACKED__ control_cell_burst_and_tdmreg_reg;

  /* Receive Reset Register: During initialization, this            */
  /* register has to be reset to enable MAC receive. When           */
  /* unused links are kept in reset, power is saved.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c63 */

     /* FMACRxRstN: Reset link to MAC registers in the rx clock      */
     /* domain for link N. If set, the corresponding link is in      */
     /* reset.                                                       */
     /* range: 11:0, access type: RW, default value: 0xfff           */
     SOC_PETRA_REG_FIELD fmacrx_rst_n[SOC_PB_NOF_PER_LINK_REGS];

     /* FMACTxRstN: Reset link to MAC registers in the tx clock      */
     /* domain for link N. If set, the corresponding link is in      */
     /* reset.                                                       */
     /* range: 27:16, access type: RW, default value: 0xfff          */
     SOC_PETRA_REG_FIELD fmactx_rst_n[SOC_PB_NOF_PER_LINK_REGS];

  } __ATTRIBUTE_PACKED__ receive_reset_reg;

  /* Link Level Flow Control And Comma Configuration                */
  /* Register: MAC Link-Level Flow-control and Comma                */
  /* Configuration Register.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c64 */

     /* LnkLvlAgePrd: Link-level flow-control aging period. This     */
     /* period is the maximum time the MACT could stop the DCL       */
     /* due to link-level flow-control. The actual aging period      */
     /* is 2^LnkLvlAgePrd. Note that programming it to 0             */
     /* disables the aging counter.                                  */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD lnk_lvl_age_prd;

     /* LnkLvlFragNum: Fragment number indicating a link-level       */
     /* flow-control cell.                                           */
     /* range: 12:4, access type: RW, default value: 0x1ff           */
     SOC_PETRA_REG_FIELD lnk_lvl_frag_num;

     /* CmBrstSize: Number of consecutive commas to be               */
     /* transmitted. 0 means no commas are transmitted, if data      */
     /* is available. The number of commas to be transmitted is      */
     /* ((CmBrstSize+1)*2) in single rate and ((CmBrstSize+1)*4)     */
     /* in double rate.                                              */
     /* range: 23:16, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD cm_brst_size;

     /* CmTxPeriod: Number of cells between consecutive comma        */
     /* sequences. Configuring 0 in this register means that no      */
     /* comma sequences are generated. The number of commas to       */
     /* be transmitted is 2^CmTxPeriod. When CmTxByteMode is 1,      */
     /* the maximum value is 5'd16. Else, the maximum value is       */
     /* 5'd15.                                                       */
     /* range: 28:24, access type: RW, default value: 0x5            */
     SOC_PETRA_REG_FIELD cm_tx_period;

     /* CmTxByteMode: If CmTxByteMode is asserted, the comma         */
     /* period will be calculated according to transmitted           */
     /* bytes. Otherwise, the period will be calculated              */
     /* according to transmitted cells.                              */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cm_tx_byte_mode;

  } __ATTRIBUTE_PACKED__ link_level_flow_control_and_comma_configuration_reg;

  /* Forward Error Correction Enabler: Forward Error                */
  /* Correction (FEC) Encoding and Decoding enabler.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c65 */

     /* UseFec: Selects between two encoding functions. If set,      */
     /* use FEC encoder / decoder. Else, use 8b/10b encoder and      */
     /* 10b/8b decoder. Note: In FEC mode, the SerDes must be        */
     /* configured for raw data mode.                                */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD use_fec;

  } __ATTRIBUTE_PACKED__ forward_error_correction_enabler_reg;

  /* Forward Error Correction Configuration: Forward Error          */
  /* Correction (FEC) Encoding and Decoding configuration.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c66 */

     /* FecEncoderFecInhibit: FEC inhibit - the EOF marked data      */
     /* will be overwritten with zeros instead of the Fire-Code      */
     /* Checksum when set to one. Should be set to zero for          */
     /* normal operation.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fec_encoder_fec_inhibit;

     /* FecEncoderScrInhibit: Scrambler inhibit - data and           */
     /* checksum will be left unscrambled when scr_inh is set to     */
     /* one. Should be set to zero for normal operation.             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fec_encoder_scr_inhibit;

     /* FecDecoderFecInhibit: FEC inhibit - the EOF marked data      */
     /* will be overwritten with zeros instead of the Fire-Code      */
     /* Checksum when set to one. Should be set to zero for          */
     /* normal operation.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fec_decoder_fec_inhibit;

     /* FecDecoderScrInhibit: Scrambler inhibit - data and           */
     /* checksum will be left unscrambled when scr_inh is set to     */
     /* one. Should be set to zero for normal operation.             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fec_decoder_scr_inhibit;

     /* FecDecoderEcInhibit: Error correction inhibit - when         */
     /* one, the data is left uncorrected (while errors are          */
     /* still detected). Should be set to zero for normal            */
     /* operation.                                                   */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fec_decoder_ec_inhibit;

     /* FecDecoderAzInhibit: All-zero inhibit - when one,            */
     /* framing on an all-zero data stream will be suppressed        */
     /* (without this, all-zero data would look like valid           */
     /* frames). Should be set to one for normal operation.          */
     /* range: 5:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD fec_decoder_az_inhibit;

     /* FecDecoderIfCount: In-frame count - number of valid (and     */
     /* error free) subsequent frames that have to be found to       */
     /* validate the frame boundary (i.e. OOF=0). The full           */
     /* signal value range of 0 to 15 is valid, with 0 only          */
     /* requiring no validation. Should be set to 0001 (0x1) for     */
     /* normal operation.                                            */
     /* range: 11:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD fec_decoder_if_count;

     /* FecDecoderOfCount: Out-of-frame count - number of            */
     /* invalid frames (i.e. frames with transmission errors)        */
     /* that have to be found before declaring out-of-frame          */
     /* (i.e. OOF=1). The full signal value range of 0 to 255 is     */
     /* valid, with 0 forcing OOF=1. Should be set to 00001111       */
     /* (0x0f) for normal operation.                                 */
     /* range: 19:12, access type: RW, default value: 0xf            */
     SOC_PETRA_REG_FIELD fec_decoder_of_count;

  } __ATTRIBUTE_PACKED__ forward_error_correction_configuration_reg;

  /* Leaky Bucket0: MAC0-Received-Cell Counters.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c74 */

     /* LkyBktValue: The value of the six-bit leaky bucket used      */
     /* to measure the Cell Error Rate.                              */
     /* range: 5:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD lky_bkt_value;

     /* RxGoodCellCnt: Number of good cells received via a           */
     /* serial link. The value of the 12-bit counter that counts     */
     /* the number of good cells is used to decide when to add a     */
     /* token to the leaky bucket. The counter rolls over at         */
     /* saturation. The type of the cells counted is                 */
     /* configurable using the RxCntCfg field (offset 0x2Af0,        */
     /* bits 19:18)                                                  */
     /* range: 19:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_good_cell_cnt;

  } __ATTRIBUTE_PACKED__ leaky_bucket_reg[SOC_PB_FABRIC_MAC_LEAKY_BUCKET_REG_NOF_REGS];

  /* Transmit Cell Counters0: MAC0 Transmit Cell Counters.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c80 */

     /* TxCellCntN: Transmitted-Cell Counter through serial          */
     /* link. The type of the cells counted is configurable          */
     /* through the TxCntCfg bit. When read, this counter is         */
     /* auto cleared. At saturation, the counter rolls over.         */
     /* This register is clear on read.                              */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_cell_cnt_n;

     /* TxCellCntNOvf: TX cell counter overflow.                     */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_cell_cnt_novf;

  } __ATTRIBUTE_PACKED__ transmit_cell_counters_reg[SOC_PB_FABRIC_MAC_TRANSMIT_CELL_COUNTERS_REG_NOF_REGS];

  /* CRCError Counter0: Single MAC0 CRC Error Counter.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c8c */

     /* CRCErrCnt: This counter counts CRC errors on a specific      */
     /* link. This register is clear on read.                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crcerr_cnt;

     /* CRCErrCntOvf: This bit is set when CRC Error counter         */
     /* (CRCErrCnt) exceeds its maximum count. This register is      */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crcerr_cnt_ovf;

  } __ATTRIBUTE_PACKED__ crcerror_counter_reg[SOC_PB_FABRIC_MAC_CRCERROR_COUNTER_REG_NOF_REGS];

  /* Fec Transmission Error Counter0: Single MAC0 correctable       */
  /* transmission error.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c98 */

     /* TranErrCnt: This counter counts the detected                 */
     /* transmitting errors on a specific link. These errors are     */
     /* corrected by the FEC decoder. This register is clear on      */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tran_err_cnt;

     /* TranErrCntOvf: This bit is set when the counter exceeds      */
     /* its maximum count. This register is clear on read.           */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tran_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ fec_transmission_error_counter_reg[SOC_PB_FABRIC_MAC_FEC_TRANSMISSION_ERROR_COUNTER_REG_NOF_REGS];

} __ATTRIBUTE_PACKED__ SOC_PB_FABRIC_MAC_REGS;
/* Block definition: MSW */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4800 */

     /* SrdInterrupt: If set, indicates that an interrupt was        */
     /* created by one of the Serdes lanes.                          */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD srd_interrupt;

     /* Srd0MacroInterrupt: Serdes macro 0 interrupts                */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd0_macro_interrupt;

     /* Srd1MacroInterrupt: Serdes macro 1 interrupts                */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd1_macro_interrupt;

     /* Srd2MacroInterrupt: Serdes macro 2 interrupts                */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd2_macro_interrupt;

     /* Srd3MacroInterrupt: Serdes macro 3 interrupts                */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd3_macro_interrupt;

     /* SrdIpuInterruptGroupA: Group A Interrupt from IPU (8051)     */
     /* range: 20:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt_group_a;

     /* SrdEpbInterruptGroupA: Group A Interrupt from EPB. If        */
     /* set, indicates that EPB FSM detected overrun error. This     */
     /* error is cause when an EPB_OP is dispatched when a           */
     /* previous EPB_OP is still executing.                          */
     /* range: 21:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt_group_a;

     /* Srd4MacroInterrupt: Serdes macro 4 interrupts                */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd4_macro_interrupt;

     /* Srd5MacroInterrupt: Serdes macro 5 interrupts                */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd5_macro_interrupt;

     /* Srd6MacroInterrupt: Serdes macro 6 interrupts                */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd6_macro_interrupt;

     /* SrdIpuInterruptGroupB: Group B Interrupt from IPU (8051)     */
     /* range: 27:27, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt_group_b;

     /* SrdEpbInterruptGroupB: Group B Interrupt from EPB. If        */
     /* set, indicates that EPB FSM detected overrun error. This     */
     /* error is cause when an EPB_OP is dispatched when a           */
     /* previous EPB_OP is still executing.                          */
     /* range: 28:28, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt_group_b;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Srd Lane Interrupt Register: This register contains the        */
  /* interrupt sources from each of the Serdes lanes                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4801 */

     /* SrdLaneInterrupt: Interrupts from the 28 SerDes lanes.       */
     /* Bit N indicates an interrupt coming from Serdes lane N.      */
     /* range: 27:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd_lane_interrupt;

  } __ATTRIBUTE_PACKED__ srd_lane_interrupt_reg;

  /* Interrupt Mask Register: Interrupt Mask Register               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4810 */

     /* SrdInterruptMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD srd_interrupt_mask;

     /* Srd0MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd0_macro_interrupt_mask;

     /* Srd1MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd1_macro_interrupt_mask;

     /* Srd2MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd2_macro_interrupt_mask;

     /* Srd3MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd3_macro_interrupt_mask;

     /* SrdIpuInterruptMaskGroupA: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt_mask_group_a;

     /* SrdEpbInterruptGroupAMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt_group_amask;

     /* Srd4MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd4_macro_interrupt_mask;

     /* Srd5MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd5_macro_interrupt_mask;

     /* Srd6MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd6_macro_interrupt_mask;

     /* SrdIpuInterruptMaskGroupB: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt_mask_group_b;

     /* SrdEpbInterruptGroupBMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt_group_bmask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Srd Lane Interrupt Mask Register: SerDes Interrupt Mask        */
  /* Register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4811 */

     /* SrdLaneInterruptMask: Writing 0 masks the corresponding      */
     /* interrupt source                                             */
     /* range: 27:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd_lane_interrupt_mask;

  } __ATTRIBUTE_PACKED__ srd_lane_interrupt_mask_reg;

  /* Scif Control: This register is used for arbitration on         */
  /* the SCIF bus between its clients                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4860 */

     /* ScifEn: If set, enables the using of the SCIF interface      */
     /* for Serdes configurations                                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD scif_en;

     /* ScifAselEn: If set, enables the using of the SCIF ASEL       */
     /* bit to select which Serdes macro to access. Otherwise,       */
     /* the CPU configurations will be used                          */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD scif_asel_en;

     /* ScifAselReset: A soft reset for the SCIF ASEL block.         */
     /* Active high.                                                 */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD scif_asel_reset;

     /* ScifStarSel: Selects which Serdes group is being             */
     /* accessed by the SCIF. 0 : NIFA Serdes Group 1 : NIFB         */
     /* Serdes Group 2 : MAC Serdes Group A 3 : MAC Serdes Group     */
     /* B 4,5,7 : Reserved                                           */
     /* range: 6:4, access type: RW, default value: 0x6              */
     SOC_PETRA_REG_FIELD scif_star_sel;

     /* ScifMacroSel: Selects which Serdes macro is to be            */
     /* accessed inside a Serdes group by the SCIF                   */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD scif_macro_sel;

  } __ATTRIBUTE_PACKED__ scif_control_reg;

  /* Scif Status: This register shows the current SCIF              */
  /* configuration (from the external interface)                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4861 */

     /* ScifMacroSelStatus: Shows the Macro selected using the       */
     /* external SCIF                                                */
     /* range: 2:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD scif_macro_sel_status;

     /* ScifStarSelStatus: Shows the Serdes group selected using     */
     /* the external SCIF                                            */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD scif_star_sel_status;

     /* ScifAselStatus: Shows the status of the external SCIF        */
     /* ASEL pin                                                     */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD scif_asel_status;

     /* ScifExtEnStatus: Shows the status of the external SCIF       */
     /* enable pin                                                   */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD scif_ext_en_status;

  } __ATTRIBUTE_PACKED__ scif_status_reg;

  /* Srd0 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4900 */

     /* Srd0Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln0_cfga_reg;

  /* Srd0 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4901 */

     /* Srd0Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln0_stat_reg;

  /* Srd0 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4902 */

     /* Srd0Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln0_ebist_reg;

  /* Srd0 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4904 */

     /* Srd0Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln1_cfga_reg;

  /* Srd0 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4905 */

     /* Srd0Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln1_stat_reg;

  /* Srd0 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4906 */

     /* Srd0Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln1_ebist_reg;

  /* Srd0 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4908 */

     /* Srd0Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln2_cfga_reg;

  /* Srd0 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4909 */

     /* Srd0Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln2_stat_reg;

  /* Srd0 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x490a */

     /* Srd0Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln2_ebist_reg;

  /* Srd0 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x490c */

     /* Srd0Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln3_cfga_reg;

  /* Srd0 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x490d */

     /* Srd0Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln3_stat_reg;

  /* Srd0 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x490e */

     /* Srd0Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln3_ebist_reg;

  /* Srd0 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4910 */

     /* Srd0CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd0_cmu_cfga_reg;

  /* Srd0 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4911 */

     /* Srd0CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd0_cmu_cfgb_reg;

  /* Srd0 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4912 */

     /* Srd0CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd0_cmu_stat_reg;

  /* Srd1 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4920 */

     /* Srd1Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln0_cfga_reg;

  /* Srd1 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4921 */

     /* Srd1Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln0_stat_reg;

  /* Srd1 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4922 */

     /* Srd1Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln0_ebist_reg;

  /* Srd1 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4924 */

     /* Srd1Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln1_cfga_reg;

  /* Srd1 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4925 */

     /* Srd1Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln1_stat_reg;

  /* Srd1 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4926 */

     /* Srd1Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln1_ebist_reg;

  /* Srd1 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4928 */

     /* Srd1Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln2_cfga_reg;

  /* Srd1 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4929 */

     /* Srd1Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln2_stat_reg;

  /* Srd1 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x492a */

     /* Srd1Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln2_ebist_reg;

  /* Srd1 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x492c */

     /* Srd1Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln3_cfga_reg;

  /* Srd1 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x492d */

     /* Srd1Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln3_stat_reg;

  /* Srd1 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x492e */

     /* Srd1Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln3_ebist_reg;

  /* Srd1 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4930 */

     /* Srd1CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd1_cmu_cfga_reg;

  /* Srd1 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4931 */

     /* Srd1CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd1_cmu_cfgb_reg;

  /* Srd1 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4932 */

     /* Srd1CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd1_cmu_stat_reg;

  /* Srd2 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4940 */

     /* Srd2Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln0_cfga_reg;

  /* Srd2 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4941 */

     /* Srd2Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln0_stat_reg;

  /* Srd2 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4942 */

     /* Srd2Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln0_ebist_reg;

  /* Srd2 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4944 */

     /* Srd2Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln1_cfga_reg;

  /* Srd2 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4945 */

     /* Srd2Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln1_stat_reg;

  /* Srd2 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4946 */

     /* Srd2Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln1_ebist_reg;

  /* Srd2 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4948 */

     /* Srd2Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln2_cfga_reg;

  /* Srd2 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4949 */

     /* Srd2Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln2_stat_reg;

  /* Srd2 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x494a */

     /* Srd2Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln2_ebist_reg;

  /* Srd2 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x494c */

     /* Srd2Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln3_cfga_reg;

  /* Srd2 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x494d */

     /* Srd2Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln3_stat_reg;

  /* Srd2 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x494e */

     /* Srd2Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln3_ebist_reg;

  /* Srd2 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4950 */

     /* Srd2CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd2_cmu_cfga_reg;

  /* Srd2 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4951 */

     /* Srd2CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd2_cmu_cfgb_reg;

  /* Srd2 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4952 */

     /* Srd2CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd2_cmu_stat_reg;

  /* Srd3 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4960 */

     /* Srd3Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln0_cfga_reg;

  /* Srd3 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4961 */

     /* Srd3Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln0_stat_reg;

  /* Srd3 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4962 */

     /* Srd3Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln0_ebist_reg;

  /* Srd3 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4964 */

     /* Srd3Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln1_cfga_reg;

  /* Srd3 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4965 */

     /* Srd3Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln1_stat_reg;

  /* Srd3 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4966 */

     /* Srd3Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln1_ebist_reg;

  /* Srd3 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4968 */

     /* Srd3Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln2_cfga_reg;

  /* Srd3 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4969 */

     /* Srd3Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln2_stat_reg;

  /* Srd3 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x496a */

     /* Srd3Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln2_ebist_reg;

  /* Srd3 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x496c */

     /* Srd3Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln3_cfga_reg;

  /* Srd3 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x496d */

     /* Srd3Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln3_stat_reg;

  /* Srd3 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x496e */

     /* Srd3Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln3_ebist_reg;

  /* Srd3 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4970 */

     /* Srd3CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd3_cmu_cfga_reg;

  /* Srd3 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4971 */

     /* Srd3CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd3_cmu_cfgb_reg;

  /* Srd3 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4972 */

     /* Srd3CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd3_cmu_stat_reg;

  /* Srda Ipu Cfg:                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4978 */

     /* SrdaIpuCfg: Configuration Register for IPU (internal         */
     /* 8051), EPB bus, and SCIF access. Shared by all SerDeses      */
     /* range: 31:0, access type: RW, default value: `SRD_PCFG_DEFAULT */
     SOC_PETRA_REG_FIELD srda_ipu_cfg;

  } __ATTRIBUTE_PACKED__ srda_ipu_cfg_reg;

  /* Srda Epb Op:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4979 */

     /* SrdaEpbOp: EPB OP dispatch register. Writing to this         */
     /* register causes a write or read operation to be              */
     /* dispatched on the EPB bus.                                   */
     /* range: 31:0, access type: RW, default value: `SRD_EPB_OP_DEFAULT */
     SOC_PETRA_REG_FIELD srda_epb_op;

  } __ATTRIBUTE_PACKED__ srda_epb_op_reg;

  /* Srda Epb Rd:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x497a */

     /* SrdaEpbRd: EPB OP data read register. After a read from      */
     /* the EPB bus is finished, the read data and status are        */
     /* available here.                                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srda_epb_rd;

  } __ATTRIBUTE_PACKED__ srda_epb_rd_reg;

  /* Srd4 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4980 */

     /* Srd4Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd4_ln0_cfga_reg;

  /* Srd4 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4981 */

     /* Srd4Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd4_ln0_stat_reg;

  /* Srd4 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4982 */

     /* Srd4Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd4_ln0_ebist_reg;

  /* Srd4 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4984 */

     /* Srd4Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd4_ln1_cfga_reg;

  /* Srd4 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4985 */

     /* Srd4Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd4_ln1_stat_reg;

  /* Srd4 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4986 */

     /* Srd4Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd4_ln1_ebist_reg;

  /* Srd4 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4988 */

     /* Srd4Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd4_ln2_cfga_reg;

  /* Srd4 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4989 */

     /* Srd4Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd4_ln2_stat_reg;

  /* Srd4 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x498a */

     /* Srd4Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd4_ln2_ebist_reg;

  /* Srd4 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x498c */

     /* Srd4Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd4_ln3_cfga_reg;

  /* Srd4 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x498d */

     /* Srd4Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd4_ln3_stat_reg;

  /* Srd4 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x498e */

     /* Srd4Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd4_ln3_ebist_reg;

  /* Srd4 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4990 */

     /* Srd4CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd4_cmu_cfga_reg;

  /* Srd4 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4991 */

     /* Srd4CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd4_cmu_cfgb_reg;

  /* Srd4 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4992 */

     /* Srd4CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd4_cmu_stat_reg;

  /* Srd5 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a0 */

     /* Srd5Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd5_ln0_cfga_reg;

  /* Srd5 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a1 */

     /* Srd5Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd5_ln0_stat_reg;

  /* Srd5 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a2 */

     /* Srd5Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd5_ln0_ebist_reg;

  /* Srd5 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a4 */

     /* Srd5Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd5_ln1_cfga_reg;

  /* Srd5 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a5 */

     /* Srd5Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd5_ln1_stat_reg;

  /* Srd5 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a6 */

     /* Srd5Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd5_ln1_ebist_reg;

  /* Srd5 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a8 */

     /* Srd5Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd5_ln2_cfga_reg;

  /* Srd5 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a9 */

     /* Srd5Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd5_ln2_stat_reg;

  /* Srd5 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49aa */

     /* Srd5Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd5_ln2_ebist_reg;

  /* Srd5 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49ac */

     /* Srd5Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd5_ln3_cfga_reg;

  /* Srd5 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49ad */

     /* Srd5Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd5_ln3_stat_reg;

  /* Srd5 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49ae */

     /* Srd5Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd5_ln3_ebist_reg;

  /* Srd5 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49b0 */

     /* Srd5CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd5_cmu_cfga_reg;

  /* Srd5 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49b1 */

     /* Srd5CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd5_cmu_cfgb_reg;

  /* Srd5 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49b2 */

     /* Srd5CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd5_cmu_stat_reg;

  /* Srd6 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c0 */

     /* Srd6Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd6_ln0_cfga_reg;

  /* Srd6 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c1 */

     /* Srd6Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd6_ln0_stat_reg;

  /* Srd6 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c2 */

     /* Srd6Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd6_ln0_ebist_reg;

  /* Srd6 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c4 */

     /* Srd6Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd6_ln1_cfga_reg;

  /* Srd6 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c5 */

     /* Srd6Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd6_ln1_stat_reg;

  /* Srd6 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c6 */

     /* Srd6Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd6_ln1_ebist_reg;

  /* Srd6 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c8 */

     /* Srd6Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd6_ln2_cfga_reg;

  /* Srd6 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c9 */

     /* Srd6Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd6_ln2_stat_reg;

  /* Srd6 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49ca */

     /* Srd6Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd6_ln2_ebist_reg;

  /* Srd6 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49cc */

     /* Srd6Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd6_ln3_cfga_reg;

  /* Srd6 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49cd */

     /* Srd6Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd6_ln3_stat_reg;

  /* Srd6 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49ce */

     /* Srd6Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd6_ln3_ebist_reg;

  /* Srd6 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49d0 */

     /* Srd6CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd6_cmu_cfga_reg;

  /* Srd6 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49d1 */

     /* Srd6CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd6_cmu_cfgb_reg;

  /* Srd6 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49d2 */

     /* Srd6CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd6_cmu_stat_reg;

  /* Srdb Ipu Cfg:                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49f8 */

     /* SrdbIpuCfg: Configuration Register for IPU (internal         */
     /* 8051), EPB bus, and SCIF access. Shared by all SerDeses      */
     /* range: 31:0, access type: RW, default value: `SRD_PCFG_DEFAULT */
     SOC_PETRA_REG_FIELD srdb_ipu_cfg;

  } __ATTRIBUTE_PACKED__ srdb_ipu_cfg_reg;

  /* Srdb Epb Op:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49f9 */

     /* SrdbEpbOp: EPB OP dispatch register. Writing to this         */
     /* register causes a write or read operation to be              */
     /* dispatched on the EPB bus.                                   */
     /* range: 31:0, access type: RW, default value: `SRD_EPB_OP_DEFAULT */
     SOC_PETRA_REG_FIELD srdb_epb_op;

  } __ATTRIBUTE_PACKED__ srdb_epb_op_reg;

  /* Srdb Epb Rd:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49fa */

     /* SrdbEpbRd: EPB OP data read register. After a read from      */
     /* the EPB bus is finished, the read data and status are        */
     /* available here.                                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srdb_epb_rd;

  } __ATTRIBUTE_PACKED__ srdb_epb_rd_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_MSW_REGS;
/* Block definition: EGQ */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: EGQ interrupt register                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5800 */

     /* CpuPack32BytesErr: Error in packet from CPU interface.       */
     /* Error detected during packet reassembly from the ECI.        */
     /* Packet will be discarded. Cleared when '1' is written.       */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_pack32_bytes_err;

     /* CpuDataArrivedErr: Error in packet from CPU interface.       */
     /* CRC error detected in the arrived data from the ECI.         */
     /* Packet will be discarded. Cleared when '1' is written.       */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_data_arrived_err;

     /* PdmParErr: Parity error detected at packet descriptor        */
     /* memory. Cleared when '1' is written. If occurs, then         */
     /* soft reset is required.                                      */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD pdm_par_err;

     /* PlmParErr: Parity error detected at descriptor link          */
     /* memory. Cleared when '1' is written. If occurs then soft     */
     /* reset is required.                                           */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD plm_par_err;

     /* PacketAged: Port aging timer expired and packets have        */
     /* been aged.                                                   */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD packet_aged;

     /* IntVlantableOor: VLAN table was indexed with illegal         */
     /* (>4K) index. Cleared when '1' is written. If occurs,         */
     /* then VLAN table was accessed at index modulo 4K.             */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_vlantable_oor;

     /* VlanEmptyInt: VLAN membership entry is empty. Cleared        */
     /* when '1' is written.                                         */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD vlan_empty_int;

     /* IntDifAf: Discard FIFO is almost full. Cleared when '1'      */
     /* is written.                                                  */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_dif_af;

     /* CfcFcInt: Flow control from CFC. Refer to                    */
     /* CfcFlowControl. Cleared when '1' is written.                 */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD cfc_fc_int;

     /* NifaFcInt: Flow control from NIFA. Refer to                  */
     /* NifaFlowControl. Cleared when '1' is written.                */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifa_fc_int;

     /* NifbFcInt: Flow control from NIFB. Refer to                  */
     /* NifbFlowControl. Cleared when '1' is written.                */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifb_fc_int;

     /* SvemErrorCamTableFull: If set,                               */
     /* SvemErrorCamTableFullCounter is not equal to 0               */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_error_cam_table_full;

     /* SvemErrorTableCoherency: If set,                             */
     /* SvemErrorTableCoherencyCounter is not equal to 0             */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_error_table_coherency;

     /* SvemErrorDeleteUnknownKey: If set,                           */
     /* SvemErrorDeleteUnknownKeyCounter is not equal to 0           */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_error_delete_unknown_key;

     /* SvemErrorReachedMaxEntryLimit: If set,                       */
     /* SvemErrorReachedMaxEntryLimitCounter is not equal to 0       */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_error_reached_max_entry_limit;

     /* SvemWarningInsertedExisting: If set,                         */
     /* SvemWarningInsertedExistingCounter is not equal to 0         */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_warning_inserted_existing;

     /* SvemManagementUnitFailureValid: Asserts when,                */
     /* IsemManagementUnitFailure register contains valid data       */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_management_unit_failure_valid;

     /* SvemManagementCompleted: Asserts when reply fifo is not      */
     /* empty                                                        */
     /* range: 20:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_management_completed;

     /* ErppErrorCodeInt: Asserts when outlif resolution error       */
     /* code is valid.                                               */
     /* range: 21:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD erpp_error_code_int;

     /* ErppDiscardIntVec: If set then one of the interrupt bits     */
     /* in ErppDiscardIntReg has been set                            */
     /* range: 28:28, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD erpp_discard_int_vec;

     /* PktReasIntVec: If set then one of the interrupt bits in      */
     /* PktReasIntReg has been set                                   */
     /* range: 29:29, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_reas_int_vec;

     /* CntOvfIntVec: Overflow counter interrupt indication          */
     /* range: 30:30, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_ovf_int_vec;

     /* EccErrVec: If set then one of the bits in EccIntReg has      */
     /* been set                                                     */
     /* range: 31:31, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ecc_err_vec;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Erpp Discard Interrupt Register: This register holds           */
  /* interrupts related to discards in ERPP.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5801 */

     /* CnmInterceptDiscard: If set then a packet was discarded      */
     /* by CNM intercept filter. Cleared when '1' is written.        */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnm_intercept_discard;

     /* CfmTrapDiscard: If set then a packet was discarded by        */
     /* CFM trap filter. Cleared when '1' is written.                */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfm_trap_discard;

     /* NoVsiTranslationDiscard: If set then a packet was            */
     /* discarded by VSI translation filter. Cleared when '1' is     */
     /* written.                                                     */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD no_vsi_translation_discard;

     /* DssStackingDiscard: If set then a packet was discarded       */
     /* by DSS stacking filter. Cleared when '1' is written.         */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD dss_stacking_discard;

     /* LagMulticastDiscard: If set then a packet was discarded      */
     /* by LAG multicast filter. Cleared when '1' is written.        */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD lag_multicast_discard;

     /* ExcludeSrcDiscard: If set then a packet was discarded by     */
     /* source port filter. Cleared when '1' is written.             */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD exclude_src_discard;

     /* VlanMembershipDiscard: If set then a packet was              */
     /* discarded by VLAN membership filter. Cleared when '1' is     */
     /* written.                                                     */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD vlan_membership_discard;

     /* UnacceptableFrameTypeDiscard: If set then a packet was       */
     /* discarded by Uncceptable Frame type filter. Cleared when     */
     /* '1' is written.                                              */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD unacceptable_frame_type_discard;

     /* SrcEqualDestDiscard: If set then a packet was discarded      */
     /* by source port filter. Cleared when '1' is written.          */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD src_equal_dest_discard;

     /* UnknownDaDiscard: If set then a packet was discarded by      */
     /* unknown DA filter. Cleared when '1' is written.              */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD unknown_da_discard;

     /* SplitHorizonDiscard: If set then a packet was discarded      */
     /* by split-horizon filter. Cleared when '1' is written.        */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD split_horizon_discard;

     /* PrivateVlanDiscard: If set then a packet was discarded       */
     /* by private vlan filter. Cleared when '1' is written.         */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD private_vlan_discard;

     /* TtlScopeDiscard: If set then a packet was discarded by       */
     /* TTL scope filter. Cleared when '1' is written.               */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ttl_scope_discard;

     /* MtuViolationDiscard: If set then a packet was discarded      */
     /* by MTU violation filter. Cleared when '1' is written.        */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mtu_violation_discard;

     /* TrillTtlZeroDiscard: If set then a packet was discarded      */
     /* by Trill TTL filter filter. Cleared when '1' is written.     */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD trill_ttl_zero_discard;

     /* TrillSameInterfaceDiscard: If set then a packet was          */
     /* discarded by Trill same interface filter. Cleared when       */
     /* '1' is written.                                              */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD trill_same_interface_discard;

     /* BounceBackDiscard: If set then a packet was discarded by     */
     /* bounce back filter. Cleared when '1' is written.             */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD bounce_back_discard;

     /* IllegalEepDiscard: If set then a packet was discarded        */
     /* because illegal EEP.                                         */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD illegal_eep_discard;

  } __ATTRIBUTE_PACKED__ erpp_discard_interrupt_reg;

  /* Packet Reassembly Interrupt Register: This register            */
  /* holds interrupts related to packet reassembly.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5802 */

     /* VscPktSizeErr: VSC(Variable Size Cell) packet size           */
     /* error. Cleared when '1' is written. Relevant only in VSC     */
     /* mode.                                                        */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsc_pkt_size_err;

     /* VscMissingSopErr: VSC missing SOP error. Cleared when        */
     /* '1' is written. Relevant only in VSC mode.                   */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsc_missing_sop_err;

     /* VscFragNumErr: VSC fragment number error. Cleared when       */
     /* '1' is written. Relevant only in VSC mode.                   */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsc_frag_num_err;

     /* VscPktCrcErr: VSC packet CRC error. Cleared when '1' is      */
     /* written. Relevant only in VSC mode.                          */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsc_pkt_crc_err;

     /* VscSopIntrMopErr: VSC SOP in MOP error. Cleared when '1'     */
     /* is written. Relevant only in VSC mode.                       */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsc_sop_intr_mop_err;

     /* VscFix129Err: VSC Fix 129 error. Cleared when '1' is         */
     /* written. Relevant only in VSC mode.                          */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsc_fix129_err;

     /* VscEopSizeErr: VSC EOP size error. Cleared when '1' is       */
     /* written. Relevant only in VSC mode.                          */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsc_eop_size_err;

     /* FscSontsErr: FSC SONTS error. Cleared when '1' is            */
     /* written. Relevant only in FSC mode.                          */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fsc_sonts_err;

     /* FscPktSizeErr: FSC packet size error. Cleared when '1'       */
     /* is written. Relevant only in FSC mode.                       */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fsc_pkt_size_err;

     /* FscMissingSopErr: FSC missing SOP error. Cleared when        */
     /* '1' is written. Relevant only in FSC mode.                   */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fsc_missing_sop_err;

     /* FscFragNumErr: FSC fragment number error. Cleared when       */
     /* '1' is written. Relevant only in FSC mode.                   */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsc_frag_num_err;

     /* FscSopIntrMopErr: FSC SOP in MOP error. Cleared when '1'     */
     /* is written. Relevant only in FSC mode.                       */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsc_sop_intr_mop_err;

     /* FscEopSizeErr: FSC EOP size error. Cleared when '1' is       */
     /* written. Relevant only in FSC mode.                          */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsc_eop_size_err;

     /* FscSequenceErr: FSC sequence error. Cleared when '1' is      */
     /* written. Relevant only in FSC mode.                          */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsc_sequence_err;

     /* CsrPktSizeErr: CSR packet size error. Cleared when '1'       */
     /* is written.                                                  */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD csr_pkt_size_err;

     /* CsrUnexpectedEopErr: CSR unexpected EOP error. Cleared       */
     /* when '1' is written.                                         */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD csr_unexpected_eop_err;

     /* CsrMissingEopErr: CSR missing EOP error. Cleared when        */
     /* '1' is written.                                              */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD csr_missing_eop_err;

     /* CsrSopAndEopErr: CSR SOP and EOP error. Cleared when '1'     */
     /* is written.                                                  */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD csr_sop_and_eop_err;

     /* CsrSizeParityErr: CSR size parity error. Cleared when        */
     /* '1' is written.                                              */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD csr_size_parity_err;

     /* RejBuffSch: If set, indicates that all arriving              */
     /* scheduled packets are rejected due to buffers threshold.     */
     /* Cleared when '1' is written.                                 */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rej_buff_sch;

     /* RejBuffUsc: If set, indicates that all arriving              */
     /* unscheduled packets are rejected due to buffers              */
     /* threshold. Cleared when '1' is written.                      */
     /* range: 20:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rej_buff_usc;

     /* RejDescSch: If set, indicates that all arriving              */
     /* scheduled packets are rejected due to descriptor             */
     /* threshold. Cleared when '1' is written.                      */
     /* range: 21:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rej_desc_sch;

     /* RejDescUsc: If set, indicates that all arriving              */
     /* unscheduled packets are rejected due to descriptors          */
     /* threshold. Cleared when '1' is written.                      */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rej_desc_usc;

  } __ATTRIBUTE_PACKED__ packet_reassembly_interrupt_reg;

  /* Counter Interrupt Register: This register holds                */
  /* interrupts related to counters.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5803 */

     /* PrpSopCntOvfInt: Packet Filtering deny counter is            */
     /* overflowed. Cleared when PrpSopCnt is read. When             */
     /* overflow bit set, counter continues counting                 */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD prp_sop_cnt_ovf_int;

  } __ATTRIBUTE_PACKED__ counter_interrupt_reg;

  /* Ecc Interrupt Register: This register holds interrupts         */
  /* related to counters.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5804 */

     /* BuflinkEccErr: Buffer Link Memory. Cleared when '1' is       */
     /* written.                                                     */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD buflink_ecc_err;

     /* BuflinkEccFix: Buffer Link Memory. Cleared when '1' is       */
     /* written.                                                     */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD buflink_ecc_fix;

     /* RcntEccErr: Read counter memory. Cleared when '1' is         */
     /* written.                                                     */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcnt_ecc_err;

     /* RcntEccFix: Read counter memory. Cleared when '1' is         */
     /* written.                                                     */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcnt_ecc_fix;

     /* RrdmEccErr: RQP Descriptor context memory. Cleared when      */
     /* '1' is written.                                              */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rrdm_ecc_err;

     /* RrdmEccFix: RQP Descriptor context memory. Cleared when      */
     /* '1' is written.                                              */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rrdm_ecc_fix;

     /* RpdmEccErr: RQP Packet Reassembly Descriptor memory.         */
     /* Cleared when '1' is written.                                 */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rpdm_ecc_err;

     /* RpdmEccFix: RQP Packet Reassembly Descriptor memory.         */
     /* Cleared when '1' is written.                                 */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rpdm_ecc_fix;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5810 */

     /* MaskCpuPack32BytesErr: Writing 0 masks the corresponding     */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_cpu_pack32_bytes_err;

     /* MaskCpuDataArrivedErr: Writing 0 masks the corresponding     */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_cpu_data_arrived_err;

     /* MaskPdmParErr: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_pdm_par_err;

     /* MaskPlmParErr: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_plm_par_err;

     /* MaskPacketAged: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_packet_aged;

     /* MaskntVlantableOor: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD masknt_vlantable_oor;

     /* MaskIntUcfifoAf: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_int_ucfifo_af;

     /* MaskVlanEmptyInt: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_vlan_empty_int;

     /* MaskIntDifAf: Writing 0 masks the corresponding              */
     /* interrupt source                                             */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_int_dif_af;

     /* MaskPqpLbpTh: Writing 0 masks the corresponding              */
     /* interrupt source                                             */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_pqp_lbp_th;

     /* MaskCfcFcInt: Writing 0 masks the corresponding              */
     /* interrupt source                                             */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_cfc_fc_int;

     /* MaskNifaFcInt: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_nifa_fc_int;

     /* MaskNifbFcInt: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_nifb_fc_int;

     /* MaskCudIsntOutVsiInt: Writing 0 masks the corresponding      */
     /* interrupt source                                             */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_cud_isnt_out_vsi_int;

     /* SvemErrorCamTableFullMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_error_cam_table_full_mask;

     /* SvemErrorTableCoherencyMask: Writing 0 masks the             */
     /* corresponding interrupt source                               */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_error_table_coherency_mask;

     /* SvemErrorDeleteUnknownKeyMask: Writing 0 masks the           */
     /* corresponding interrupt source                               */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_error_delete_unknown_key_mask;

     /* SvemErrorReachedMaxEntryLimitMask: Writing 0 masks the       */
     /* corresponding interrupt source                               */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_error_reached_max_entry_limit_mask;

     /* SvemWarningInsertedExistingMask: Writing 0 masks the         */
     /* corresponding interrupt source                               */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_warning_inserted_existing_mask;

     /* SvemManagementUnitFailureValidMask: Writing 0 masks the      */
     /* corresponding interrupt source                               */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_management_unit_failure_valid_mask;

     /* SvemManagementCompletedMask: Writing 0 masks the             */
     /* corresponding interrupt source                               */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD svem_management_completed_mask;

     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD erpp_error_code_int_mask;

     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD erpp_discard_int_vec_mask;

     /* MaskPktReasIntVec: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_pkt_reas_int_vec;

     /* MaskCntOvfIntVec: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_cnt_ovf_int_vec;

     /* MaskEccErrVec: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_ecc_err_vec;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Erpp Discards Interrupt Register Mask:                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5811 */

     /* range: 0:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cnm_intercept_discard_mask;

     /* range: 1:1, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cfm_trap_discard_mask;

     /* range: 2:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD no_vsi_translation_discard_mask;

     /* range: 3:3, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dss_stacking_discard_mask;

     /* range: 4:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD lag_multicast_discard_mask;

     /* range: 5:5, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD exclude_src_discard_mask;

     /* range: 6:6, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD vlan_membership_discard_mask;

     /* range: 7:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD unacceptable_frame_type_discard_mask;

     /* range: 8:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD src_equal_dest_discard_mask;

     /* range: 9:9, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD unknown_da_discard_mask;

     /* range: 10:10, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD split_horizon_discard_mask;

     /* range: 11:11, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD private_vlan_discard_mask;

     /* range: 12:12, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ttl_scope_discard_mask;

     /* range: 13:13, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mtu_violation_discard_mask;

     /* range: 14:14, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD trill_ttl_zero_discard_mask;

     /* range: 15:15, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD trill_same_interface_discard_mask;

     /* range: 16:16, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bounce_back_discard_mask;

     /* range: 17:17, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD illegal_eep_discard_mask;

  } __ATTRIBUTE_PACKED__ erpp_discards_interrupt_register_mask_reg;

  /* Packet Reassembly Interrupt Register Mask:                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5812 */

     /* range: 0:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsc_pkt_size_err_mask;

     /* range: 1:1, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsc_missing_sop_err_mask;

     /* range: 2:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsc_frag_num_err_mask;

     /* range: 3:3, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsc_pkt_crc_err_mask;

     /* range: 4:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsc_sop_intr_mop_err_mask;

     /* range: 5:5, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsc_fix129_err_mask;

     /* range: 6:6, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsc_eop_size_err_mask;

     /* range: 7:, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsc_sonts_err_mask;

     /* range: 8:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsc_pkt_size_err_mask;

     /* range: 9:9, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsc_missing_sop_err_mask;

     /* range: 10:10, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsc_frag_num_err_mask;

     /* range: 11:11, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsc_sop_intr_mop_err_mask;

     /* range: 12:12, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsc_eop_size_err_mask;

     /* range: 13:13, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsc_sequence_err_mask;

     /* range: 14:14, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD csr_pkt_size_err_mask;

     /* range: 15:15, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD csr_unexpected_eop_err_mask;

     /* range: 16:16, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD csr_missing_eop_err_mask;

     /* range: 17:17, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD csr_sop_and_eop_err_mask;

     /* range: 18:18, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD csr_size_parity_err_mask;

     /* range: 19:19, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rej_buff_sch_mask;

     /* range: 20:20, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rej_buff_usc_mask;

     /* range: 21:21, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rej_desc_sch_mask;

     /* range: 22:22, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rej_desc_usc_mask;

  } __ATTRIBUTE_PACKED__ packet_reassembly_interrupt_register_mask_reg;

  /* Counter Interrupt Register Mask:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5813 */

     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD prp_sop_cnt_ovf_int_mask;

  } __ATTRIBUTE_PACKED__ counter_interrupt_register_mask_reg;

  /* Ecc Interrupt Register Mask:                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5814 */

     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD buflink_ecc_err_mask;

     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD buflink_ecc_fix_mask;

     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcnt_ecc_err_mask;

     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcnt_ecc_fix_mask;

     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rrdm_ecc_err_mask;

     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rrdm_ecc_fix_mask;

     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rpdm_ecc_err_mask;

     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rpdm_ecc_fix_mask;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_register_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5820 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_EGQ_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5830 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_EGQ_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5840 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* determine the number of writes left.                         */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5841 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5842 */

     /* IndirectCommandDataIncrement:                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_EGQ_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* EGQ Chciken Bits                    */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x5852 */

    /* range: 5:5, access type: RW, default value: 30'0     */
    SOC_PETRA_REG_FIELD eep_resolution_chicken_bit;

    /* range: 6:6, access type: RW, default value: 30'0     */
    SOC_PETRA_REG_FIELD egress_learning_chicken_bit;
    
  } __ATTRIBUTE_PACKED__ egq_chicken_bits;

  /* Gtimer Configuration: GTIMER configuration.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x585c */

     /* GtimerCycle: Period of time in clocks.                       */
     /* range: 29:0, access type: RW, default value: 30'hee6b280     */
     SOC_PETRA_REG_FIELD gtimer_cycle;

     /* GtimerEnable: Enable using Gtimer                            */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_enable;

     /* GtimerResetOnTrigger: Reset the Gtimer counter when          */
     /* triggered.                                                   */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_reset_on_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Gtimer Trigger: Gtimer trigger                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x585d */

     /* GtimerTrigger: Gtimer trigger                                */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_trigger_reg;

  /* Cpu Packet Control: CPU interface for packet transmit to       */
  /* the FAP when the CPU interface is working in                   */
  /* asynchronous (non-streaming) mode. This register               */
  /* triggers the transmission of a 32B of payload, which was       */
  /* written to the registers below.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x585e */

     /* SendPktFrag: Trigger to write a 32-byte packet fragment.     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD send_pkt_frag;

     /* StartOfPacket: Indicates the fragment contains start of      */
     /* packet                                                       */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD start_of_packet;

     /* EndOfPacket: Indicates the fragment contains end of          */
     /* packet                                                       */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_of_packet;

     /* PktFragErr: Indicates the fragment is error (for debug       */
     /* only)                                                        */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pkt_frag_err;

  } __ATTRIBUTE_PACKED__ cpu_packet_control_reg;

  /* Cpu Packet Fragmentation Words: Packet Fragmentation           */
  /* words for CPU non-streaming interface                          */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x585f */

    /* PacketWord7: Packet fragmentation words 7 for reg #0         */
    /* down to words 0 for reg #7.                                  */
    /* range: 31:0, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD packet_word;

  } __ATTRIBUTE_PACKED__ cpu_packet_fragmentation_words_reg[SOC_PB_CPU_PACKET_FRAGMENTATION_REGS];

  /* EGQBlock Init Status: EGQ internal memories                    */
  /* initialization status indication.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5867 */

     /* EGQBlockInit: If set, then block initialization is in        */
     /* process. This bit is cleared by the device upon              */
     /* completion of all initialization processes (approx. 4096     */
     /* clock cycles)                                                */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD egqblock_init;

  } __ATTRIBUTE_PACKED__ egqblock_init_status_reg;

  /* Ecc Corecction Disable: ECC correction disable setting         */
  /* bits for debug purpose                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5868 */

     /* BuflinkDisEcc: If set, then disables the ECC decoder on      */
     /* BufLink memory output                                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD buflink_dis_ecc;

     /* RcntDisEcc: If set, then disables the ECC decoder on         */
     /* RCNT memory output                                           */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcnt_dis_ecc;

     /* RrdmDisEcc: If set, then disables the ECC decoder on         */
     /* RRDM memory output                                           */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rrdm_dis_ecc;

     /* RpdmDisEcc: If set, then disables the ECC decoder on         */
     /* RPDM memory output                                           */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rpdm_dis_ecc;

  } __ATTRIBUTE_PACKED__ ecc_corecction_disable_reg;

  /* Maximum And Minimum Packet Size: Maximum fragment number       */
  /* supported size                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5869 */

     /* MaxFrgNum: Set the maximum supported fragment number         */
     /* after which cells arriving with a higher fragment number     */
     /* are recognized as error packet stream. The maximum           */
     /* packet size supported is 16K -128(16256). For VSC mode,      */
     /* the maximum fragment number should be 127. For fix-sized     */
     /* cell mode, it depends whether TDM mode is enabled. When      */
     /* TDM is enabled, the maximum fragment number should be        */
     /* 256, other wise should be 508.                               */
     /* range: 8:0, access type: RW, default value: 0x7f             */
     SOC_PETRA_REG_FIELD max_frg_num;

     /* FabricMinPktSize: Set the fabric minimum packet size         */
     /* supported.                                                   */
     /* range: 21:12, access type: RW, default value: 0x21           */
     SOC_PETRA_REG_FIELD fabric_min_pkt_size;

  } __ATTRIBUTE_PACKED__ maximum_fragment_number_reg;

  /* Tdm Frag Num Config1: Packets received from the fabric         */
  /* may be identified by a configurable TDM fragment number.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x586a */

     /* TdmFdrFragNum1En: Enables identifing TDM packets by a        */
     /* configurable fragment number set by the next register.       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_fdr_frag_num1_en;

     /* TdmFdrFragNum1Num: The first fragment number of TDM          */
     /* packet when TdmFdrFragNum1En is set                          */
     /* range: 12:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_fdr_frag_num1_num;

     /* TdmFdrFragNum2En: Enables identifing TDM packets by a        */
     /* configurable fragment number set by the next register.       */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_fdr_frag_num2_en;

     /* TdmFdrFragNum2Num: The second fragment number of TDM         */
     /* packet when TdmFdrFragNum2En is set                          */
     /* range: 28:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_fdr_frag_num2_num;

  } __ATTRIBUTE_PACKED__ tdm_frag_num_config1_reg;

  /* Tdm Frag Num Config2: Packets received from the fabric         */
  /* may be identified by a configurable TDM fragment number.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x586b */

     /* TdmFdrFragNum3En: Enables identifing TDM packets by a        */
     /* configurable fragment number set by the next register.       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_fdr_frag_num3_en;

     /* TdmFdrFragNum3Num: The third fragment number of TDM          */
     /* packet when TdmFdrFragNum3En is set                          */
     /* range: 12:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_fdr_frag_num3_num;

     /* TdmFdrFragNum4En: Enables identifing TDM packets by a        */
     /* configurable fragment number set by the next register.       */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_fdr_frag_num4_en;

     /* TdmFdrFragNum4Num: The forth fragment number of TDM          */
     /* packet when TdmFdrFragNum4En is set                          */
     /* range: 28:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_fdr_frag_num4_num;

  } __ATTRIBUTE_PACKED__ tdm_frag_num_config2_reg;

  /* Tdm Mcid Value Configuration: When TdmFdrOfp_8bEn is           */
  /* set, Multicast packets with a Multicast-ID in a                */
  /* configurable range are identified as TDM packets. This         */
  /* register configures the bottom and top values of this          */
  /* range.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x586c */

     /* TdmMcidValueBottom: The bottom value of the Multicast-ID     */
     /* range.                                                       */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_mcid_value_bottom;

     /* TdmMcidValueTop: The top value of the Multicast-ID           */
     /* range.                                                       */
     /* range: 29:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_mcid_value_top;

  } __ATTRIBUTE_PACKED__ tdm_mcid_value_configuration_reg;

  /* Tdm General Configuration: TDM general configuration           */
  /* Register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x586d */

     /* TdmFdrOfp_8bEn: If set then EGQ identifies packets           */
     /* according to OTM-Port for unicast packets. Unicast           */
     /* packets targeted to an OTM-Port configured as a TDM          */
     /* destination are identified as TDM packets. This register     */
     /* is relevant when working with standard FTMH.                 */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_fdr_ofp_8b_en;

     /* TdmFdrOfp_2bEn: If set then EGQ identifies packets           */
     /* according to OTM-Port for unicast packets. Unicast           */
     /* packets targeted to an OTM-Port configured as a TDM          */
     /* destination are identified as TDM packets. This register     */
     /* is relevant when working with optimized FTMH.                */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_fdr_ofp_2b_en;

     /* TdmFdrMcId_8bEn: If set then EGQ identifies packets          */
     /* according to Multicast-ID for multicast packets.             */
     /* Multicast packets with a Multicast-ID in a configurable      */
     /* range are identified as TDM packets. This register is        */
     /* relevant when working with standard FTMH.                    */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_fdr_mc_id_8b_en;

     /* TdmFdrMcId_2bEn: If set then EGQ identifies packets          */
     /* according to Multicast-ID for multicast packets.             */
     /* Multicast packets with a Multicast-ID in a configurable      */
     /* range are identified as TDM packets. This register is        */
     /* relevant when working with optimized FTMH.                   */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_fdr_mc_id_2b_en;

     /* TdmDropEn:                                                   */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_drop_en;

     /* Tdm_2bytesFtmh: If set then working with optimized FTMH.     */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_2bytes_ftmh;

     /* TdmContextMode: The EHP has multiple FIFO contexts of        */
     /* packets waiting to be written to the output queues. If       */
     /* set then TDM and data in separate contexts. Else,            */
     /* Unicast and multicast contexts - This is the normal          */
     /* mode.                                                        */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_context_mode;

     /* Tdm_2bytesShaperSizeEn: This register enables the EGQ        */
     /* shaper when working in Optimized FTMH mode.                  */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_2bytes_shaper_size_en;

     /* TdmStripFabricCrcEn: If set then TDM packet with no CRC.     */
     /* That means, no CRC check in RQP.                             */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_strip_fabric_crc_en;
  } __ATTRIBUTE_PACKED__ tdm_general_configuration_reg;

  /* Ofp2tdm Map: Mapping OTM-ports to TDM destination or           */
  /* not.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x586e */

     /* Ofp2tdmMap: Bit I confgiures whether OTM-port I is TDM.      */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ofp2tdm_map;

  } __ATTRIBUTE_PACKED__ ofp2tdm_map_reg[SOC_PB_EGQ_OFP2TDM_MAP_REG_MULT_NOF_REGS];

  /* Tdm Ehp Configuration: TDM general configuration               */
  /* Register cont.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5871 */

     /* Tdm_2bytesPktSize: This register sets the size of TDM        */
     /* packets when working with optimized FTMH                     */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_2bytes_pkt_size;

     /* TdmPktTc: Egress Traffic Class used for TDM packets.         */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_pkt_tc;

     /* TdmPktDp: Egress DP used for TDM packets.                    */
     /* range: 13:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_pkt_dp;

  } __ATTRIBUTE_PACKED__ tdm_ehp_configuration_reg;

  /* Egq Local And Fabric Arbiter: Arbitration priority             */
  /* settings between local route interface and fabric              */
  /* interface. Default mode (all fields clear) is Round            */
  /* Robin between local route and fabric interface                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5872 */

     /* LocalVsFabricArb: Configures the arbitration scheme          */
     /* between the local route interface to the fabric              */
     /* interface according to the following encoding of the 2       */
     /* LSBs: '00' - Round Robin '01' - Fabric route gets strict     */
     /* priority '10' - Local route gets strict priority '11' -      */
     /* Weighted round-robin arbitration between fabric route        */
     /* and local route. Arbitration ratio of 4:1 (fabric route      */
     /* gets high weight) If the MSB is set, then Local route        */
     /* gets strict priority when IPT_TX signal is set               */
     /* (threshold crossed indication from the IPT)                  */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD local_vs_fabric_arb;

  } __ATTRIBUTE_PACKED__ egq_local_and_fabric_arbiter_reg;

  /* Reassembly Reject Threshold Enable Configuration:              */
  /* Reassembly segments rejecting enable settings.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5873 */

     /* RejSchdDescThEn: Enable discard of scheduled packets         */
     /* during reassembly because not enough available               */
     /* descriptors                                                  */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rej_schd_desc_th_en;

     /* RejUnSchdDescThEn: Enable discard of unscheduled packets     */
     /* during reassembly because there are not enough available     */
     /* descriptors.                                                 */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rej_un_schd_desc_th_en;

     /* RejSchdBuffThEn: Enable discard of unscheduled packets       */
     /* during reassembly because there are not enough available     */
     /* descriptors.                                                 */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rej_schd_buff_th_en;

     /* RejUnSchdBuffThEn: Enable discard of unscheduled packets     */
     /* during reassembly because there are not enough available     */
     /* buffers                                                      */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rej_un_schd_buff_th_en;

  } __ATTRIBUTE_PACKED__ reassembly_reject_threshold_enable_configuration_reg;

  /* Scheduled Reject Buffer Threshold: Re-assembly rejects         */
  /* scheduled packets due to buffer occupancy thresholds.          */
  /* The threshold is defined as five bits of mantissa (MSB)        */
  /* and four bits of exponent (LSB).                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5874 */

     /* ClearReasRejSchdBuffTh: Configures the threshold number      */
     /* of available buffers to clear the reassembly reject flag     */
     /* for scheduled packets. The flag is cleared when this         */
     /* threshold is crossed from below. Admission of scheduled      */
     /* packets for reassembly resumes                               */
     /* range: 8:0, access type: RW, default value: 0x4a             */
     SOC_PETRA_REG_FIELD clear_reas_rej_schd_buff_th;

     /* SetReasRejSchdBuffTh: Configures the threshold number of     */
     /* available buffers to set the reassembly reject flag for      */
     /* scheduled packets. The flag is set when this threshold       */
     /* is crossed from above. When this flag is set, all             */
     /* arriving scheduled packets are rejected until the number     */
     /* of available buffers crosses the ClearReasRejSchdBuffTh      */
     /* from below                                                   */
     /* range: 24:16, access type: RW, default value: 0x4a           */
     SOC_PETRA_REG_FIELD set_reas_rej_schd_buff_th;

  } __ATTRIBUTE_PACKED__ schededuled_reject_buffer_threshold_reg;

  /* Scheduled Reject Descriptor Threshold: Reassembly reject       */
  /* scheduled packets due to descriptor occupancy                  */
  /* thresholds. The threshold is defined as five bits of           */
  /* mantissa (MSB) and four bits of exponent (LSB).                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5875 */

     /* ClearReasRejSchdDescTh: Configures the threshold number      */
     /* of available descriptors to clear the reassembly reject      */
     /* flag for scheduled packets. The flag is cleared when         */
     /* this threshold is crossed from below. Admission of           */
     /* scheduled packets for reassembly resumes                     */
     /* range: 8:0, access type: RW, default value: 0x8a             */
     SOC_PETRA_REG_FIELD clear_reas_rej_schd_desc_th;

     /* SetReasRejSchdDescTh: Configures the threshold number of     */
     /* available descriptors to set the reassembly reject flag      */
     /* for scheduled packets. The flag is set when this             */
     /* threshold is crossed from above. When this flag is set,       */
     /* all arriving scheduled packets are rejected until the        */
     /* number of available descriptors crosses the                  */
     /* ClearReasRejSchdDescTh from below                            */
     /* range: 24:16, access type: RW, default value: 0x8a           */
     SOC_PETRA_REG_FIELD set_reas_rej_schd_desc_th;

  } __ATTRIBUTE_PACKED__ scheduled_reject_descriptor_threshold_reg;

  /* Unscheduled Reject Buffer Threshold: Reassembly rejects        */
  /* unscheduled packets due to buffer occupancy thresholds.        */
  /* The threshold is defined as five bits of mantissa (MSB)        */
  /* and four bits of exponent (LSB).                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5876 */

     /* ClearReasRejUnSchdBuffTh: Configures the threshold           */
     /* number of available buffers to clear the reassembly          */
     /* reject flag for unscheduled packets. The flag is cleared     */
     /* when this threshold is crossed from below. Admission of      */
     /* unscheduled packets for reassembly resumes                   */
     /* range: 8:0, access type: RW, default value: 0x4a             */
     SOC_PETRA_REG_FIELD clear_reas_rej_un_schd_buff_th;

     /* SetReasRejUnSchdBuffTh: Configures the threshold number      */
     /* of available buffers to set the reassembly reject flag       */
     /* for unscheduled packets. The flag is set when this           */
     /* threshold is crossed from above. When this flag is set,      */
     /* all arriving unscheduled packets are rejected until the      */
     /* number of available buffers crosses the                      */
     /* ClearReasRejUnSchdBuffTh from below                          */
     /* range: 24:16, access type: RW, default value: 0x4a           */
     SOC_PETRA_REG_FIELD set_reas_rej_un_schd_buff_th;

  } __ATTRIBUTE_PACKED__ unscheduled_reject_buffer_threshold_reg;

  /* Unscheduled Reject Descriptor Threshold: Reassembly            */
  /* rejects unscheduled packets due to descriptor occupancy        */
  /* thresholds. The threshold is defined as five bits of           */
  /* mantissa (MSB) and four bits of exponent (LSB).                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5877 */

     /* ClearReasRejUnSchdDescTh: Configures the threshold           */
     /* number of available descriptors to clear the reassembly      */
     /* reject flag for unscheduled packets. The flag is cleared     */
     /* when this threshold is crossed from below. Admission of      */
     /* unscheduled packets for reassembly resumes                   */
     /* range: 8:0, access type: RW, default value: 0x8a             */
     SOC_PETRA_REG_FIELD clear_reas_rej_un_schd_desc_th;

     /* SetReasRejUnSchdDescTh: Configures the threshold number      */
     /* of available descriptors to set the reassembly reject        */
     /* flag for unscheduled packets. The flag is set when this      */
     /* threshold is crossed from above. When this flag is set,      */
     /* all arriving unscheduled packets are rejected until the      */
     /* number of available descriptors crosses the                  */
     /* ClearReasRejUnSchdDescTh from below                          */
     /* range: 24:16, access type: RW, default value: 0x8a           */
     SOC_PETRA_REG_FIELD set_reas_rej_un_schd_desc_th;

  } __ATTRIBUTE_PACKED__ unscheduled_reject_descriptor_threshold_reg;

  /* Multicast Packet Header Shim Layer Translation: Shim           */
  /* layer translation configurable fields for multicast            */
  /* headers. Transfers FAP20 fabric headers to Soc_petra fabric        */
  /* headers. Applicable when FAP20Mode is enabled and              */
  /* Fap20FabricHdrFormat.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5879 */

     /* McOutLifMsb: Sets value of OutLif Field                      */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mc_out_lif_msb;

     /* McEpphPresent: Sets value of EPPH Present bit                */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mc_epph_present;

     /* McIngQSig: Sets value of Ingress Q field                     */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mc_ing_qsig;

     /* McDp: Sets value of DP field                                 */
     /* range: 7:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mc_dp;

     /* McOutMirrorDisable: Sets value of Out Mirror Disable bit     */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mc_out_mirror_disable;

  } __ATTRIBUTE_PACKED__ multicast_packet_header_shim_layer_translation_reg;

  /* Shim Layer Translation Multicast Class Mapping Table:          */
  /* Shim layer multicast class mapping lookup table for            */
  /* multicast headers.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x587a */

     /* McClassMap4to8: Multicast class mapping 4 to 8 table         */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mc_class_map4to8;

  } __ATTRIBUTE_PACKED__ shim_layer_translation_multicast_class_mapping_table_reg;

  /* Unicast Packet Header Shim Layer Translation: Shim layer       */
  /* translation configurable fields for unicast header.            */
  /* Transfers FAP20 headers to Soc_petra headers.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x587b */

     /* UcEpphPresent: Sets value of EPPH Present bit                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD uc_epph_present;

     /* UcIngQSig: Sets value of Ingress Q field                     */
     /* range: 2:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD uc_ing_qsig;

     /* UcDp: Sets value of DP field                                 */
     /* range: 4:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD uc_dp;

     /* UcOutMirrorDisable: Sets value of Out Mirror Disable bit     */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD uc_out_mirror_disable;

  } __ATTRIBUTE_PACKED__ unicast_packet_header_shim_layer_translation_reg;

  /* Available Free Resources: Indicates the number of              */
  /* current available free descriptors and buffers in the          */
  /* EGQ (out from 8K available descriptors and 4K available        */
  /* buffers).                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x587d */

     /* AvailableFreeDescriptors: The number of available free       */
     /* descriptors                                                  */
     /* range: 13:0, access type: RO, default value: 0x2000          */
     SOC_PETRA_REG_FIELD available_free_descriptors;

     /* AvailableFreeBuffers: The number of available free           */
     /* buffers                                                      */
     /* range: 28:16, access type: RO, default value: 0xfff          */
     SOC_PETRA_REG_FIELD available_free_buffers;

  } __ATTRIBUTE_PACKED__ available_free_resources_reg;

  /* Fabric Route Sop Counter: Indicates the number Sop received   */
  /* from fabric and whether there was counter overflow            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x587e */

     /* FsrSopCnt: Counts the number of Sop received from fabric and */
     /*  whether there was counter overflow. This register is clear  */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsr_sop_cnt;

     /* FsrSopCntOvf: If set, then indicates that the counter has     */
     /* overflowed. This register is clear on read.                   */
     /* range: 31:31, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsr_sop_cnt_ovf;

  } __ATTRIBUTE_PACKED__ fabric_route_sop_counter;

  /* Local Route Sop Counter: Indicates the number Sop received   */
  /* from local and whether there was counter overflow            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x587f */

     /* LsrSopCnt: Counts the number of Sop received from local and  */
     /*  whether there was counter overflow. This register is clear  */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lsr_sop_cnt;

     /* LsrSopCntOvf: If set, then indicates that the counter has     */
     /* overflowed. This register is clear on read.                   */
     /* range: 31:31, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lsr_sop_cnt_ovf;

  } __ATTRIBUTE_PACKED__ local_route_sop_counter;

  /* CPU interface Sop Counter: Indicates the number Sop received   */
  /* from CPU interface and whether there was counter overflow            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5880 */

     /* CsrSopCnt: Counts the number of Sop received from CPU interface and */
     /*  whether there was counter overflow. This register is clear  */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD csr_sop_cnt;

     /* CsrSopCntOvf: If set, then indicates that the counter has     */
     /* overflowed. This register is clear on read.                   */
     /* range: 31:31, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD csr_sop_cnt_ovf;

  } __ATTRIBUTE_PACKED__ cpu_interface_sop_counter;

  /* Packet reassembly output Sop Counter: Indicates the number Sop completed   */
  /* packet reassembly without errors and whether there was counter overflow   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5881 */

     /* PrpSopCnt: Counts the number of Sop received transferred from EHP to PRP */
     /*  whether there was counter overflow. This register is clear  */
     /* on read.                                                     */
     /* range: 62:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prp_sop_cnt;

  } __ATTRIBUTE_PACKED__ packet_reassembly_sop_counter_0;

  /* Packet reassembly output Sop Counter: Indicates the number Sop completed   */
  /* packet reassembly without errors and whether there was counter overflow   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5882 */

     /* PrpSopCnt: Counts the number of Sop received transferred from EHP to PRP */
     /*  whether there was counter overflow. This register is clear  */
     /* on read.                                                     */
     /* range: 62:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prp_sop_cnt;

     /* PrpSopCntOvf: If set, then indicates that the counter has     */
     /* overflowed. This register is clear on read.                   */
     /* range: 63:63, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prp_sop_cnt_ovf;

  } __ATTRIBUTE_PACKED__ packet_reassembly_sop_counter_1;

  /* Packet Aged Counter: Packet Aged counter                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x588c */

     /* PktAgedCnt: Number of aged packets.                          */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pkt_aged_cnt;

     /* PktAgedCntOvf: If set, then indicates that the counter       */
     /* overflowed.                                                  */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_aged_cnt_ovf;

  } __ATTRIBUTE_PACKED__ packet_aged_counter_reg;

  /* Egress Replication Bitmap Group Value Configuration:           */
  /* Configure the values of the Out-LIF-Group that is mapped       */
  /* to replication with bitmap.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x588f */

     /* EgressRepBitmapGroupValueBot: The lowest value of            */
     /* Out-LIF-Group that is mapped to replication with bitmap      */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD egress_rep_bitmap_group_value_bot;

     /* EgressRepBitmapGroupValueTop: The upper value of             */
     /* Out-LIF-Group that is mapped to replication with bitmap      */
     /* range: 29:16, access type: RW, default value: 0xfff          */
     SOC_PETRA_REG_FIELD egress_rep_bitmap_group_value_top;

  } __ATTRIBUTE_PACKED__ egress_replication_bitmap_group_value_configuration_reg;

  /* Mc Priority Lookup Table: For egress replication, there        */
  /* are two multicast replication engines: one engine for          */
  /* low-priority packets and one for high-priority packets.        */
  /* The packets waiting for egress replication process are         */
  /* mapped to one of the engines (2 queues: MC1- High              */
  /* priority; MC2 - Low priority)                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5890 */

     /* McPriority: Index is: \{TC(3-bits),DP(2-bits)\}. The         */
     /* lookup result is one bit. If set, then multicast packet      */
     /* enters MC1 queue; otherwise, MC2 queue.                      */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mc_priority;

  } __ATTRIBUTE_PACKED__ mc_priority_lookup_table_reg;

  /* Multicast Link List Max Length: Multicast Link List max        */
  /* length in entries, in order to prevent loops in the link       */
  /* list table.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5891 */

     /* LinkListMaxLength: If the MC link list length is higher      */
     /* than this value, the EHP process only the first              */
     /* LinkListMaxLength entries                                    */
     /* range: 14:0, access type: RW, default value: 0x14            */
     SOC_PETRA_REG_FIELD link_list_max_length;

     /* LinkListMaxLengthVld: enables and disbales this function     */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD link_list_max_length_vld;

  } __ATTRIBUTE_PACKED__ multicast_link_list_max_length_reg;
  /* Cnm Cpid To Fc Type0: CPId To FC Type Table entries 0 to       */
  /* 2. The format of the table is as the following:Bit 0 -         */
  /* Generate LLFCBit 1 - Generate CBFC on class 0Bit 2 -           */
  /* Generate CBFC on class 1Bit 3 - Generate CBFC on class         */
  /* 2Bit 4 - Generate CBFC on class 3Bit 5 - Generate CBFC         */
  /* on class 4Bit 6 - Generate CBFC on class 5Bit 7 -              */
  /* Generate CBFC on class 6Bit 8 - Generate CBFC on class 7       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5892 */

     /* CnmCpid0ToFcType: CPId0 To FC Type Table                     */
     /* range: 8:0, access type: RW, default value: 0x0              */
     /* range: 17:9, access type: RW, default value: 0x0             */
     /* range: 26:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnm_cpid_to_fc_ll_type[SOC_PB_EGQ_CNM_CPID_TO_FC_TYPE_REG_NOF_FLDS];

     /* CnmCpid0ToFcType: CPId0 To FC Type Table                     */
     /* range: 8:0, access type: RW, default value: 0x0              */
     /* range: 17:9, access type: RW, default value: 0x0             */
     /* range: 26:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnm_cpid_to_fc_cb_type[SOC_PB_EGQ_CNM_CPID_TO_FC_TYPE_REG_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ cnm_cpid_to_fc_type_reg[SOC_PB_EGQ_CNM_CPID_TO_FC_TYPE_REG_NOF_REGS];

  /* Cnm General Config: CNM General Configuration                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5895 */

     /* ActionProfileCnmIntercept: Action-Profile when               */
     /* identifying a CNM packet.                                    */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD action_profile_cnm_intercept;

     /* ActionProfileCfmTrap: Action-Profile for CFM trap.           */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD action_profile_cfm_trap;

  } __ATTRIBUTE_PACKED__ cnm_general_config_reg;

  /* Cnm Timer Granularity Reg: CNM FC timer configuration          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5896 */

     /* CnmTimerGranularity: The assertion of the LLFC or CBFC       */
     /* is during CnmTimerGranularity * 3 clocks.                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cnm_timer_granularity;

  } __ATTRIBUTE_PACKED__ cnm_timer_granularity_reg;

  /* Action Profile1: Action Profile Register1                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58a4 */

     /* ActionProfileRqpDiscard: The action profile index for        */
     /* RQP discarded packets                                        */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD action_profile_rqp_discard;

  } __ATTRIBUTE_PACKED__ action_profile1_reg;

  /* Tc Dp Map Profile: This regsiter defines 2-bits profile        */
  /* per OFP used when indexing the TcDpMap table                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58ae */

     /* TcDpMapProfile: The 2-bits profile of OFP n is               */
     /* TcDpMapProfile[n*2+1:2n ]                                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tc_dp_map_profile[SOC_PB_EGQ_TC_DP_MAP_PROFILE_REG_MULT_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ tc_dp_map_profile_reg[SOC_PB_EGQ_TC_DP_MAP_PROFILE_REG_MULT_NOF_REGS];

  /* Learning Dis: Egress learning activation register per          */
  /* OFP                                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58b3 */

     /* LearningDis: If bit n is set then Egress learning for        */
     /* OFP n is disabled                                            */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD learning_dis;

  } __ATTRIBUTE_PACKED__ learning_dis_reg[SOC_PB_EGQ_LEARNING_DIS_REG_MULT_NOF_REGS];

  /* Marvel Configuration Register: Marvel configuration            */
  /* register                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58bd */

     /* MarvelMhMode: 0 - DSA Tag header type 1- Marvel MH           */
     /* header type                                                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD marvel_mh_mode;

     /* MarvelMidVidx: 0 - Multicast id is taken from vid bits       */
     /* 1- Multicast id is taken from the vidx bits                  */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD marvel_mid_vidx;

     /* MarvelDsaToAnalyzerIngressOfp: Map ingress analyzer          */
     /* packets to link (OFP)                                        */
     /* range: 9:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD marvel_dsa_to_analyzer_ingress_ofp;

     /* MarvelDsaToAnalyzerEgressOfp: Map Egress analyzer            */
     /* packets to link (OFP)                                        */
     /* range: 13:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD marvel_dsa_to_analyzer_egress_ofp;

     /* MarvelOtherLowPrTable: Map Traffic class (3 bits) to 1       */
     /* bit low priority queue                                       */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD marvel_other_low_pr_table;

     /* MarvelToCpuLowPr: Map TO_CPU packets to low priority         */
     /* queue                                                        */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD marvel_to_cpu_low_pr;

     /* MarvelToAnalyzerLowPr: Map TO_ANALYZER packets to low        */
     /* priority queue                                               */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD marvel_to_analyzer_low_pr;

  } __ATTRIBUTE_PACKED__ marvel_configuration_reg;

  /* Marvel Dx Forward Low Pr Table: Map QOS profile to 1 bit       */
  /* low priority queue                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58be */

     /* MarvelDxForwardLowPrTable: Map QOS profile to 1 bit low      */
     /* priority queue                                               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_dx_forward_low_pr_table;

  } __ATTRIBUTE_PACKED__ marvel_dx_forward_low_pr_table_reg[SOC_PB_EGQ_MARVEL_DX_FORWARD_LOW_PR_TABLE_REG_MULT_NOF_REGS];

  /* Marvel Port Map Table Other: Map Other packets to Link         */
  /* (OFP), table index is \{device_0,target_port[5:0]\}            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58c2 */

     /* MarvelPortMapTableOther: Map Other packets to Link           */
     /* (OFP), table index is \{device_0,target_port[5:0]\}          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_other;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_other_reg[SOC_PB_EGQ_MARVEL_PORT_MAP_TABLE_OTHER_REG_MULT_NOF_REGS];

  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58ca */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg[SOC_PB_EGQ_MARVEL_PORT_MAP_TABLE_CPU_REG_MULT_NOF_REGS];

  /* Egress De Queue Scheme: Configure the scheme of the            */
  /* egress dequeue. Select between two scheduling schemes.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58da */

     /* SchdQueueScheme: If set to 0 then: Strict priority           */
     /* between high-priority and low-priority Unicast, Strict       */
     /* priority between high-priority and low-priority              */
     /* Multicast, WDRR between Unicast and Multicast. If set to     */
     /* 1 then: Strict priority between high-priority Unicast        */
     /* and high-priority Multicast, WDRR between low-priority       */
     /* Unicast and low-priority Multicast, Strict priority          */
     /* between high-priority and low-priority traffic. If set       */
     /* to 2 then: WDRR between high-priority Unicast and            */
     /* high-priority Multicast, WDRR between low-priority           */
     /* Unicast and low-priority Multicast, Strict priority          */
     /* between high-priority and low-priority traffic.              */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD schd_queue_scheme;

  } __ATTRIBUTE_PACKED__ egress_de_queue_scheme_reg;

  /* Pqp Cpu Delay En: Enabling delay of 16 clocks between          */
  /* two sequential CPU selection in PQP arbiter.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58dc */

     /* CpuDelayEn: Bit 0 enables delay for OFP 0. Bits 7:1          */
     /* enable delay for OFPs 79-73.                                 */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_delay_en;

  } __ATTRIBUTE_PACKED__ pqp_cpu_delay_en_reg;

  /* Fast Port Configuration: Fast port configuration               */
  /* register in PQP. Relevant to OC768 mode and Interlaken.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58de */

     /* FastPortEn: If set then OFP number 1 will be able to be      */
     /* selected every 2 clocks.                                     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fast_port_en;

     /* FastPortWdrrEn: If set then the WDRR arbitration for         */
     /* port 1 is enabled. The weights are defined in the next       */
     /* register                                                     */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fast_port_wdrr_en;

  } __ATTRIBUTE_PACKED__ fast_port_configuration_reg;

  /*
   *	Manual modification to be adapted to Soc_petra-A names
   */

  /* Fast Port Wdrr Weights: Unicast versus multicast weights       */
  /* used only in Fat pipe mode.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58df */

     /* FastPortUnicastWeight: Unicast subqueue weight used in       */
     /* the WFQ scheduler.                                           */
     /* range: 7:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD oc768_unicast_weight;

     /* FastPortMulticastWeight: Multicast subqueue weight used      */
     /* in the WFQ scheduler.                                        */
     /* range: 15:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD oc768_multicast_weight;

     /* FastPortNewUnicastWeight: Unicast subqueue weight used       */
     /* in the WFQ scheduler.                                        */
     /* range: 23:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fast_port_new_unicast_weight;

     /* FastPortNewMulticastWeight: Multicast subqueue weight        */
     /* used in the WFQ scheduler.                                   */
     /* range: 31:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fast_port_new_multicast_weight;

  } __ATTRIBUTE_PACKED__ oc768_unicast_multicast_weight_reg;

  /* Statistics En:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58e0 */

     /* AdvaStatisticsEn:                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ad_statistics_en;

  } __ATTRIBUTE_PACKED__ ad_statistics_en_reg;

  /* Pqp2fqp Ofp Stop: Disables sending descriptors from PQP        */
  /* to FQP per OFP.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58e1 */

     /* Pqp2fqpOfpStop: If bit N is set then PQP will not send       */
     /* descriptors directed to OFP N.                               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pqp2fqp_ofp_stop;

  } __ATTRIBUTE_PACKED__ pqp2fqp_ofp_stop_reg[SOC_PB_EGQ_PQP2FQP_OFP_STOP_REG_MULT_NOF_REGS];

  /* Pqp Spr Per Port Dis: PQP per-port shaper enable. The           */
  /* PQP-shaper should be enabled when working in INTERLAKEN        */
  /* full-packet mode.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58e4 */

     /* PqpSprPerPortDis: If bit N is set then EGQ shaper is         */
     /* disabled in PQP for OFP N.                                   */
     /* range: 31:0, access type: RW, default value: 80'hffffffffffffffffffff */
     SOC_PETRA_REG_FIELD pqp_spr_per_port_dis;

  } __ATTRIBUTE_PACKED__ pqp_spr_per_port_dis_reg[SOC_PB_EGQ_PQP_SPR_PER_PORT_DIS_REG_MULT_NOF_REGS];

  /* Fqp Spr Per Port Dis: FQP per-port shaper enable. The FQP       */
  /* shaper should be disabled when working in INTERLAKEN           */
  /* full-packet mode.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58e7 */

     /* FqpSprPerPortDis: If bit N is set then EGQ shaper is         */
     /* disabled in FQP for OFP N.                                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fqp_spr_per_port_dis;

  } __ATTRIBUTE_PACKED__ fqp_spr_per_port_dis_reg[SOC_PB_EGQ_FQP_SPR_PER_PORT_DIS_REG_MULT_NOF_REGS];

  /* Queue Disabled: PQP queues disable.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58ea */

     /* QueueDisabled: If bit n is set then queue number n is        */
     /* blocked in EGQ and all traffic directed to this queue        */
     /* will be deleted.                                             */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD queue_disabled;

  } __ATTRIBUTE_PACKED__ queue_disabled_reg[SOC_PB_EGQ_QUEUE_DISABLED_REG_MULT_NOF_REGS];

  /* Unscheduled Resources Low Queues Thresholds For Drop           */
  /* Precedence0: Configuration of thresholds for total             */
  /* consumed resources in unscheduled low queues. The              */
  /* threshold is defined as five bits of mantissa (MSB) and        */
  /* four bits of exponent (LSB).                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58f4 */

     /* TotalUscWrds: Sets the threshold for the number of total     */
     /* consumed 32B words of multicast packets, above which         */
     /* unscheduled low-queues packets of multicast DP0 are          */
     /* rejected.                                                    */
     /* range: 8:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD total_usc_wrds;

     /* TotalUscPkts: Sets the threshold for the number of total     */
     /* packets above which unscheduled low-queues packets of        */
     /* multicast DP0 are rejected.                                  */
     /* range: 24:16, access type: RW, default value: 0x167          */
     SOC_PETRA_REG_FIELD total_usc_pkts;

  } __ATTRIBUTE_PACKED__ unsched_qs_threshs_for_dp_reg_0[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES][SOC_PETRA_NOF_DROP_PRECEDENCE];

  /* Unscheduled Resources Low Queues Thresholds For Drop           */
  /* Precedence0: Configuration of thresholds for total             */
  /* consumed resources in unscheduled low queues. The              */
  /* threshold is defined as five bits of mantissa (MSB) and        */
  /* four bits of exponent (LSB).                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58f5 */

     /* AvailUscDesc: Sets the thresholds for the number of          */
     /* available packet descriptors, below which unscheduled        */
     /* low-queues packets of multicast DP0 are rejected.            */
     /* range: 8:0, access type: RW, default value: 0x1f3            */
     SOC_PETRA_REG_FIELD avail_usc_desc;

     /* AvailUscBufs: Sets the threshold for the number of           */
     /* available data buffers, below which unscheduled              */
     /* low-queues packets of multicast DP0 are rejected.            */
     /* range: 24:16, access type: RW, default value: 0x1f2          */
     SOC_PETRA_REG_FIELD avail_usc_bufs;

  } __ATTRIBUTE_PACKED__ unsched_qs_threshs_for_dp_reg_1[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES][SOC_PETRA_NOF_DROP_PRECEDENCE];

  /* Unscheduled Resources Low Queues Thresholds For Drop           */
  /* Precedence0: Configuration of thresholds for total             */
  /* consumed resources in unscheduled low queues. The              */
  /* threshold is defined as five bits of mantissa (MSB) and        */
  /* four bits of exponent (LSB).                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58f6 */

     /* TotalUscBufs: Sets the threshold for the number of data      */
     /* buffers, above which unscheduled low-queues packets of       */
     /* multicast DP0 are rejected.                                  */
     /* range: 8:0, access type: RW, default value: 0x2a             */
     SOC_PETRA_REG_FIELD total_usc_bufs;

     /* UchQueueWrdsType0: Sets the threshold for the number of      */
     /* total 32B words in unscheduled low queues of DP0 and         */
     /* type 0, above which packets to these queues are              */
     /* rejected.                                                    */
     /* range: 24:16, access type: RW, default value: 0x10           */
     SOC_PETRA_REG_FIELD uch_queue_wrds_type0;

  } __ATTRIBUTE_PACKED__ unsched_qs_threshs_for_dp_reg_2[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES][SOC_PETRA_NOF_DROP_PRECEDENCE];

  /* Unscheduled Resources Low Queues Thresholds For Drop           */
  /* Precedence0: Configuration of thresholds for total             */
  /* consumed resources in unscheduled low queues. The              */
  /* threshold is defined as five bits of mantissa (MSB) and        */
  /* four bits of exponent (LSB).                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58f7 */

     /* UchQueueWrdsType1: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of DP0 and type      */
     /* 1, above which packets to these queues are rejected.         */
     /* range: 8:0, access type: RW, default value: 0x127            */
     SOC_PETRA_REG_FIELD uch_queue_wrds_type1;

     /* UchQueueWrdsType2: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of DP0 and type      */
     /* 2, above which packets to these queues are rejected.         */
     /* range: 24:16, access type: RW, default value: 0x127          */
     SOC_PETRA_REG_FIELD uch_queue_wrds_type2;

  } __ATTRIBUTE_PACKED__ unsched_qs_threshs_for_dp_reg_3[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES][SOC_PETRA_NOF_DROP_PRECEDENCE];

  /* Unscheduled Resources Low Queues Thresholds For Drop           */
  /* Precedence0: Configuration of thresholds for total             */
  /* consumed resources in unscheduled low queues. The              */
  /* threshold is defined as five bits of mantissa (MSB) and        */
  /* four bits of exponent (LSB).                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58f8 */

     /* UchQueueWrdsType3: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of DP0 and type      */
     /* 3, above which packets to these queues are rejected.         */
     /* range: 8:0, access type: RW, default value: 0x127            */
     SOC_PETRA_REG_FIELD uch_queue_wrds_type3;

     /* UchQueuePktsType0: Sets the threshold for the number of      */
     /* total descriptors in unscheduled low queues of DP0 and       */
     /* type 0, above which packets tothese queues are rejected.     */
     /* range: 24:16, access type: RW, default value: 0x10           */
     SOC_PETRA_REG_FIELD uch_queue_pkts_type0;

  } __ATTRIBUTE_PACKED__ unsched_qs_threshs_for_dp_reg_4[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES][SOC_PETRA_NOF_DROP_PRECEDENCE];

  /* Unscheduled Resources Low Queues Thresholds For Drop           */
  /* Precedence0: Configuration of thresholds for total             */
  /* consumed resources in unscheduled low queues. The              */
  /* threshold is defined as five bits of mantissa (MSB) and        */
  /* four bits of exponent (LSB).                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58f9 */

     /* UchQueuePktsType1: Sets the threshold for the number of      */
     /* total descriptors in scheduled low queues of DP0 and         */
     /* type 1, above which packets to these queues are              */
     /* rejected.                                                    */
     /* range: 8:0, access type: RW, default value: 0x127            */
     SOC_PETRA_REG_FIELD uch_queue_pkts_type1;

     /* UchQueuePktsType2: Sets the threshold for the number of      */
     /* total descriptors in scheduled low queues of DP0 and         */
     /* type 2, above which packets to these queues are              */
     /* rejected.                                                    */
     /* range: 24:16, access type: RW, default value: 0x127          */
     SOC_PETRA_REG_FIELD uch_queue_pkts_type2;

  } __ATTRIBUTE_PACKED__ unsched_qs_threshs_for_dp_reg_5[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES][SOC_PETRA_NOF_DROP_PRECEDENCE];

  /* Unscheduled Resources Low Queues Thresholds For Drop           */
  /* Precedence0: Configuration of thresholds for total             */
  /* consumed resources in unscheduled low queues. The              */
  /* threshold is defined as five bits of mantissa (MSB) and        */
  /* four bits of exponent (LSB).                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x58fa */

     /* UchQueuePktsType3: Sets the threshold for the number of      */
     /* total descriptors in scheduled low queues of DP0 and         */
     /* type 3, above which packets to these queues are              */
     /* rejected.                                                    */
     /* range: 8:0, access type: RW, default value: 0x127            */
     SOC_PETRA_REG_FIELD uch_queue_pkts_type3;

  } __ATTRIBUTE_PACKED__ unsched_qs_threshs_for_dp_reg_6[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES][SOC_PETRA_NOF_DROP_PRECEDENCE];

  /* Scheduled Low Queues Resource Consumption Thresholds:          */
  /* Configuration of thresholds for total consumed resources       */
  /* in scheduled low queues. The threshold is defined as           */
  /* five bits of mantissa (MSB) and four bits of exponent          */
  /* (LSB).                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x592c */

     /* TotalSchWrds: Sets the threshold for the number of total     */
     /* consumed 32B words, above which arrived scheduled low        */
     /* queue packets are rejected.                                  */
     /* range: 8:0, access type: RW, default value: 0x169            */
     SOC_PETRA_REG_FIELD total_sch_wrds;

     /* TotalSchPkts: Sets the threshold for the number of total     */
     /* number of packets, above which arrived scheduled low         */
     /* queue packets are rejected.                                  */
     /* range: 24:16, access type: RW, default value: 0x167          */
     SOC_PETRA_REG_FIELD total_sch_pkts;

  } __ATTRIBUTE_PACKED__ sched_qs_rsc_consumption_threshs_reg_0[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES];

  /* Scheduled Low Queues Resource Consumption Thresholds:          */
  /* Configuration of thresholds for total consumed resources       */
  /* in scheduled low queues. The threshold is defined as           */
  /* five bits of mantissa (MSB) and four bits of exponent          */
  /* (LSB).                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x592d */

     /* AvailSchDscs: Sets the threshold for the number of           */
     /* available packet descriptors, below which arrived            */
     /* scheduled low queue packets are rejected.                    */
     /* range: 8:0, access type: RW, default value: 0x1f3            */
     SOC_PETRA_REG_FIELD avail_sch_dscs;

     /* AvailSchBufs: Sets the threshold for the number of           */
     /* available data buffers, below which arrived scheduled        */
     /* low queue packets are rejected.                              */
     /* range: 24:16, access type: RW, default value: 0x1f2          */
     SOC_PETRA_REG_FIELD avail_sch_bufs;

  } __ATTRIBUTE_PACKED__ sched_qs_rsc_consumption_threshs_reg_1[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES];

  /* Scheduled Low Queues Resource Consumption Thresholds:          */
  /* Configuration of thresholds for total consumed resources       */
  /* in scheduled low queues. The threshold is defined as           */
  /* five bits of mantissa (MSB) and four bits of exponent          */
  /* (LSB).                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x592e */

     /* SchQueueWrdsType0: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 0, above     */
     /* which packets to these queues are rejected.                  */
     /* range: 8:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type0;

     /* SchQueueWrdsType1: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 1, above     */
     /* which packets to these queues are rejected.                  */
     /* range: 24:16, access type: RW, default value: 0x107          */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type1;

  } __ATTRIBUTE_PACKED__ sched_qs_rsc_consumption_threshs_reg_2[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES];

  /* Scheduled Low Queues Resource Consumption Thresholds:          */
  /* Configuration of thresholds for total consumed resources       */
  /* in scheduled low queues. The threshold is defined as           */
  /* five bits of mantissa (MSB) and four bits of exponent          */
  /* (LSB).                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x592f */

     /* SchQueueWrdsType2: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 2, above     */
     /* which packets to these queues are rejected.                  */
     /* range: 8:0, access type: RW, default value: 0x107            */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type2;

     /* SchQueueWrdsType3: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 3, above     */
     /* which packets to these queues are rejected.                  */
     /* range: 24:16, access type: RW, default value: 0x107          */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type3;

  } __ATTRIBUTE_PACKED__ sched_qs_rsc_consumption_threshs_reg_3[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES];

  /* Scheduled Low Queues Resource Consumption Thresholds:          */
  /* Configuration of thresholds for total consumed resources       */
  /* in scheduled low queues. The threshold is defined as           */
  /* five bits of mantissa (MSB) and four bits of exponent          */
  /* (LSB).                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5930 */

     /* SchQueuePktsType0 : Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 2, above     */
     /* which packets to these queues are rejected.                  */
     /* range: 8:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sch_queue_pkts_type0;

     /* SchQueuePktsType1 : Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 2, above     */
     /* which packets to these queues are rejected.                  */
     /* range: 24:16, access type: RW, default value: 0x107           */
     SOC_PETRA_REG_FIELD sch_queue_pkts_type1;

  } __ATTRIBUTE_PACKED__ sched_qs_rsc_consumption_threshs_reg_4[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES];


   /* Scheduled Low Queues Resource Consumption Thresholds:          */
  /* Configuration of thresholds for total consumed resources       */
  /* in scheduled low queues. The threshold is defined as           */
  /* five bits of mantissa (MSB) and four bits of exponent          */
  /* (LSB).                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5931 */

     /* SchQueuePktsType2 : Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 2, above     */
     /* which packets to these queues are rejected.                  */
     /* range: 8:0, access type: RW, default value: 0x107            */
     SOC_PETRA_REG_FIELD sch_queue_pkts_type2;

     /* SchQueuePktsType3 : Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 2, above     */
     /* which packets to these queues are rejected.                  */
     /* range: 24:16, access type: RW, default value: 0x107           */
     SOC_PETRA_REG_FIELD sch_queue_pkts_type3;

  } __ATTRIBUTE_PACKED__ sched_qs_rsc_consumption_threshs_reg_5[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES];

  /* Total Resources Consumption Thresholds Configuration For       */
  /* Device Flow Control: Egress resources consumption              */
  /* thresholds configuration for device flow-control. The          */
  /* threshold is defined as five bits of mantissa (MSB) and        */
  /* four bits of exponent (LSB).                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5938 */

     /* TotalDvcFcSchWrds: Sets the threshold for the number of      */
     /* total consumed 32B scheduled words, above which device       */
     /* flow-control is asserted.                                    */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD total_dvc_fc_sch_wrds;

     /* TotalDvcFcSchBufs: Sets the threshold for the number of      */
     /* total consumed scheduled data buffers, above which           */
     /* device flow-control is asserted.                             */
     /* range: 24:16, access type: RW, default value: 0x1f7          */
     SOC_PETRA_REG_FIELD total_dvc_fc_sch_bufs;

  } __ATTRIBUTE_PACKED__ total_rcs_consumption_threshs_conf_for_dev_flow_ctrl_reg_0;

  /* Total Resources Consumption Thresholds Configuration For       */
  /* Device Flow Control: Egress resources consumption              */
  /* thresholds configuration for device flow-control. The          */
  /* threshold is defined as five bits of mantissa (MSB) and        */
  /* four bits of exponent (LSB).                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5939 */

     /* TotalDvcFcSchDscs: Sets the threshold for the number of      */
     /* total scheduled packet descriptors, above which device       */
     /* flow-control is asserted.                                    */
     /* range: 8:0, access type: RW, default value: 0x1f8            */
     SOC_PETRA_REG_FIELD total_dvc_fc_sch_dscs;

     /* TotalDvcFcWrds: Sets the threshold for the number of         */
     /* total consumed 32B words, above which device                 */
     /* flow-control is asserted.                                    */
     /* range: 24:16, access type: RW, default value: 0x1fa          */
     SOC_PETRA_REG_FIELD total_dvc_fc_wrds;

  } __ATTRIBUTE_PACKED__ total_rcs_consumption_threshs_conf_for_dev_flow_ctrl_reg_1;

  /* Total Resources Consumption Thresholds Configuration For       */
  /* Device Flow Control: Egress resources consumption              */
  /* thresholds configuration for device flow-control. The          */
  /* threshold is defined as five bits of mantissa (MSB) and        */
  /* four bits of exponent (LSB).                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x593a */

     /* TotalDvcFcBufs: Sets the thresholds of the number of         */
     /* total consumed data buffers, above which device              */
     /* flow-control is asserted.                                    */
     /* range: 8:0, access type: RW, default value: 0x1f7            */
     SOC_PETRA_REG_FIELD total_dvc_fc_bufs;

     /* TotalDvcFcDscs: Sets the thresholds of the number of         */
     /* total packet descriptors, above which device                 */
     /* flow-control is asserted.                                    */
     /* range: 24:16, access type: RW, default value: 0x1f8          */
     SOC_PETRA_REG_FIELD total_dvc_fc_dscs;

  } __ATTRIBUTE_PACKED__ total_rcs_consumption_threshs_conf_for_dev_flow_ctrl_reg_2;

  /* Mci0 Thresholds Configuration: Configurations of               */
  /* thresholds for Mci0. Thresholds are defined as five bits       */
  /* of mantissa (MSB) and four bits of exponent (LSB).             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x593b */

     /* TotalUscWrds: Sets the threshold for the number of total     */
     /* consumed 32B unscheduled words, above which Mci0 is          */
     /* asserted.                                                    */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD total_usc_wrds;

     /* TotalUscPkts: Sets the threshold for the number of total     */
     /* unscheduled packets, above which Mci0 is asserted.           */
     /* range: 24:16, access type: RW, default value: 0x1f8          */
     SOC_PETRA_REG_FIELD total_usc_pkts;

  } __ATTRIBUTE_PACKED__ mci_thresolds_configuration_reg_0[SOC_PB_NOF_MCI_LVLS_FOR_THRESH_CONF_REGS];

  /* Mci0 Thresholds Configuration: Configurations of               */
  /* thresholds for Mci0. Thresholds are defined as five bits       */
  /* of mantissa (MSB) and four bits of exponent (LSB).             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x593c */

     /* TotalUscBufs: Sets the threshold for the number of total     */
     /* consumed unscheduled data buffers, above which Mci0 is       */
     /* asserted.                                                    */
     /* range: 8:0, access type: RW, default value: 0x1f7            */
     SOC_PETRA_REG_FIELD total_usc_bufs;

     /* TotalDscs: Sets the threshold for the number of total        */
     /* consumed packet descriptors, above which Mci0 is             */
     /* asserted.                                                    */
     /* range: 24:16, access type: RW, default value: 0x1f8          */
     SOC_PETRA_REG_FIELD total_dscs;

  } __ATTRIBUTE_PACKED__ mci_thresolds_configuration_reg_1[SOC_PB_NOF_MCI_LVLS_FOR_THRESH_CONF_REGS];

  /* Channelized Ports Total Packets Flow Control Threshold:        */
  /* Configuration of thresholds for total number of packets        */
  /* in channelized ports. When the number of packets for the       */
  /* channel crosses the threshold, flow-control is asserted.       */
  /* The threshold is defined as five bits of mantissa (MSB)        */
  /* and four bits of exponent (LSB).                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x593f */

     /* TotalCpNPktsTh: Sets the threshold for the number of         */
     /* total packets to the channelized port index N, above         */
     /* which the channelized port flow control signal is            */
     /* asserted. The CP indexing is as follows: CP 0-7 - Nif A      */
     /* CP 8-15 - Nif B CP 16 - CPU interface CP 17 - Recycling      */
     /* interface                                                    */
     /* range: 31:0, access type: RW, default value: 281'h1f801f801f801f801f801f801f801f801f801f801f801f801f801f801f801f801f801f8 */
     SOC_PETRA_REG_FIELD total_cp_npkts_th[SOC_PB_NOF_CH_PORTS_TOTAL_FC_THRESH_FLDS];

  } __ATTRIBUTE_PACKED__ channelized_ports_total_packets_flow_control_threshold_reg[SOC_PB_EGQ_CHANNELIZED_PORTS_TOTAL_PACKETS_FLOW_CONTROL_THRESHOLD_REG_MULT_NOF_REGS];

  /* Channelized Ports Total Words Flow Control Threshold:          */
  /* Configuration of thresholds for total number of words in       */
  /* channelized ports. When the number of words for the            */
  /* channel crosses the threshold, flow-control is asserted.       */
  /* The threshold is defined as five bits of mantissa (MSB)        */
  /* and four bits of exponent (LSB).                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5948 */

     /* TotalCpNWrdsTh: Sets the threshold for the number of         */
     /* total words to the channelized port index N, above which     */
     /* the channelized port flow control signal is asserted.        */
     /* The CP indexing is as follows: CP 0-7 - Nif A CP 8-15 -      */
     /* Nif B CP 16 - CPU interface CP 17 - Recycling interface      */
     /* range: 31:0, access type: RW, default value: 281'h1fa01fa01fa01fa01fa01fa01fa01fa01fa01fa01fa01fa01fa01fa01fa01fa01fa01fa */
     SOC_PETRA_REG_FIELD total_cp_nwrds_th[SOC_PB_NOF_CH_PORTS_TOTAL_FC_THRESH_FLDS];

  } __ATTRIBUTE_PACKED__ channelized_ports_total_words_flow_control_threshold_reg[SOC_PB_EGQ_CHANNELIZED_PORTS_TOTAL_WORDS_FLOW_CONTROL_THRESHOLD_REG_MULT_NOF_REGS];

  /* Scheduled Low Queues Ofp Flow Control Threshold Types:         */
  /* Flow-Control Thresholds of scheduled low queue size, per       */
  /* queue type. The threshold is defined as five bits of           */
  /* mantissa (MSB) and four bits of exponent (LSB).                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5951 */

     /* FclWrdsType0: Sets the thresholds of the number of total     */
     /* 32B words in scheduled queues of type 0, above which         */
     /* flow control to these ports is asserted.                     */
     /* range: 8:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fcl_wrds_type0;

     /* FclWrdsType1: Sets the thresholds of the number of total     */
     /* 32B words in scheduled queues of type 1, above which         */
     /* flow control to these ports is asserted.                     */
     /* range: 24:16, access type: RW, default value: 0x164          */
     SOC_PETRA_REG_FIELD fcl_wrds_type1;

  } __ATTRIBUTE_PACKED__ sched_qs_ofp_flow_ctrl_thresh_types_reg_0[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES];

  /* Scheduled Low Queues Ofp Flow Control Threshold Types:         */
  /* Flow-Control Thresholds of scheduled low queue size, per       */
  /* queue type. The threshold is defined as five bits of           */
  /* mantissa (MSB) and four bits of exponent (LSB).                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5952 */

     /* FclWrdsType2: Sets the thresholds of the number of total     */
     /* 32B words in scheduled queues of type 2, above which         */
     /* flow control to these ports is asserted.                     */
     /* range: 8:0, access type: RW, default value: 0x164            */
     SOC_PETRA_REG_FIELD fcl_wrds_type2;

     /* FclWrdsType3: Sets the thresholds of the number of total     */
     /* 32B words in scheduled queues of type 3, above which         */
     /* flow control to these ports is asserted.                     */
     /* range: 24:16, access type: RW, default value: 0x1f4          */
     SOC_PETRA_REG_FIELD fcl_wrds_type3;

  } __ATTRIBUTE_PACKED__ sched_qs_ofp_flow_ctrl_thresh_types_reg_1[SOC_PB_REGS_NOF_EGR_Q_PRIORITIES];

  /* Disable Mci: Forces the MCI bits driven by the EGQ to 0,       */
  /* thus disabling egress-to-ingress flow control for              */
  /* Spatial Multicast traffic.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5955 */

     /* Mci0Dis: If set, then disables the MCI0 signal to the        */
     /* MAC (signal forced to '0')                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mci0_dis;

     /* Mci1Dis: If set, then disables the MCI1 signal to the        */
     /* MAC (signal forced to '0')                                   */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mci1_dis;

     /* ErpFcEn: If set, then disables the MCI1 and uses the         */
     /* MCI1 threshold configuration for the scheduler egress        */
     /* replication-port flow-control indication. Otherwise,         */
     /* egress replication-port flow-control indication is           */
     /* forced to '0'.                                               */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD erp_fc_en;

  } __ATTRIBUTE_PACKED__ disable_mci_reg;

  /* Ofp Threshold Type Select: Per OFP threshold type              */
  /* select. Each OFP is configured to one of four possible         */
  /* sets of thresholds that dictate which thresholds will be       */
  /* used by that port.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5957 */

     /* QThSel: Each two bits configure the OFP port type.           */
     /* QThSel[2n+1:2n] selects the threshold set for port n.        */
     /* range: 31:0, access type: RW, default value: 160'h5555555555555555555555555555555555555555 */
     SOC_PETRA_REG_FIELD qth_sel[SOC_PB_NOF_OFP_TH_TYPE_SEL_FLDS];

  } __ATTRIBUTE_PACKED__ ofp_threshold_type_select_reg[SOC_PB_EGQ_OFP_THRESHOLD_TYPE_SELECT_REG_MULT_NOF_REGS];

  /* Total Used Descriptor Counter: Total number of consumed        */
  /* descriptors for all packets.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5961 */

     /* TotalDesc: Indicates the number of descriptors used for      */
     /* all packets.                                                 */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_desc;

  } __ATTRIBUTE_PACKED__ total_used_descriptor_counter_reg;

  /* Total Available Descriptor Counter: Total number of            */
  /* available descriptors for all packets.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5962 */

     /* TotalAvailDesc: Indicates the number of available            */
     /* descriptors.                                                 */
     /* range: 13:0, access type: RO, default value: 0x2000          */
     SOC_PETRA_REG_FIELD total_avail_desc;

  } __ATTRIBUTE_PACKED__ total_available_descriptor_counter_reg;

  /* Total Scheduled Used Descriptor Counter: Total number of       */
  /* consumed descriptors for scheduled packets.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5963 */

     /* TotalSchDesc: Indicates the number of descriptors used       */
     /* for scheduled packets                                        */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_sch_desc;

  } __ATTRIBUTE_PACKED__ total_scheduled_used_descriptor_counter_reg;

  /* Total Unscheduled Used Descriptor Counter: Total number        */
  /* of consumed descriptors for unscheduled packets.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5964 */

     /* TotalUscDesc: Indicates the number of descriptors used       */
     /* for unscheduled packets                                      */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_usc_desc;

  } __ATTRIBUTE_PACKED__ total_unscheduled_used_descriptor_counter_reg;

  /* Total Used Unicast High Descriptor Counter: Total number       */
  /* of consumed descriptors for Unicast high packets.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5965 */

     /* TotalDescUch: Indicates the number of descriptors used       */
     /* for Unicast high packets.                                    */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_desc_uch;

  } __ATTRIBUTE_PACKED__ total_used_unicast_high_descriptor_counter_reg;

  /* Total Used Unicast Low Descriptor Counter: Total number        */
  /* of consumed descriptors for Unicast low packets.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5966 */

     /* TotalDescUcl: Indicates the number of descriptors used       */
     /* for Unicast low packets.                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_desc_ucl;

  } __ATTRIBUTE_PACKED__ total_used_unicast_low_descriptor_counter_reg;

  /* Total Used Multicast High Descriptor Counter: Total            */
  /* number of consumed descriptors for Multicast high              */
  /* packets.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5967 */

     /* TotalDescMch: Indicates the number of descriptors used       */
     /* for Multicast high packets.                                  */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_desc_mch;

  } __ATTRIBUTE_PACKED__ total_used_multicast_high_descriptor_counter_reg;

  /* Total Used Multicast Low Descriptor Counter: Total             */
  /* number of consumed descriptors for Multicast low               */
  /* packets.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5968 */

     /* TotalDescMcl: Indicates the number of descriptors used       */
     /* for Multicast low packets.                                   */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_desc_mcl;

  } __ATTRIBUTE_PACKED__ total_used_multicast_low_descriptor_counter_reg;

  /* Total Scheduled Used Buffers: Total number of consumed         */
  /* buffers for scheduled packets.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5969 */

     /* TotalSchBufs: Indicates the number of buffers used for       */
     /* scheduled packets                                            */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_sch_bufs;

  } __ATTRIBUTE_PACKED__ total_scheduled_used_buffers_reg;

  /* Total Unscheduled Used Buffers: Total number of consumed       */
  /* buffers for unscheduled packets.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x596a */

     /* TotalUscBufs: Indicates the number of buffers used for       */
     /* unscheduled packets                                          */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_usc_bufs;

  } __ATTRIBUTE_PACKED__ total_unscheduled_used_buffers_reg;

  /* Total Scheduled Used Words: Total number of consumed           */
  /* words for scheduled packets.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x596b */

     /* TotalSchWrds: Indicates the number of words used for         */
     /* scheduled packets                                            */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_sch_wrds;

  } __ATTRIBUTE_PACKED__ total_scheduled_used_words_reg;

  /* Total Unscheduled Used Words: Total number of consumed         */
  /* words for unscheduled packets.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x596c */

     /* TotalUscWrds: Indicates the number of words used for         */
     /* unscheduled packets                                          */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_usc_wrds;

  } __ATTRIBUTE_PACKED__ total_unscheduled_used_words_reg;

  /* Total Mal0 Used Packets: Total number of consumed              */
  /* packets for MAL0.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x596d */

     /* TotalNifaCh0CpPkts: Indicates the number of packets used     */
     /* for MAL0                                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch0_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal0_used_packets_reg;

  /* Total Mal1 Used Packets: Total number of consumed              */
  /* packets for MAL1.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x596e */

     /* TotalNifaCh1CpPkts: Indicates the number of packets used     */
     /* for MAL1                                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch1_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal1_used_packets_reg;

  /* Total Mal2 Used Packets: Total number of consumed              */
  /* packets for MAL2.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x596f */

     /* TotalNifaCh2CpPkts: Indicates the number of packets used     */
     /* for MAL2                                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch2_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal2_used_packets_reg;

  /* Total Mal3 Used Packets: Total number of consumed              */
  /* packets for MAL3.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5970 */

     /* TotalNifaCh3CpPkts: Indicates the number of packets used     */
     /* for MAL3                                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch3_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal3_used_packets_reg;

  /* Total Mal4 Used Packets: Total number of consumed              */
  /* packets for MAL4.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5971 */

     /* TotalNifaCh4CpPkts: Indicates the number of packets used     */
     /* for MAL4                                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch4_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal4_used_packets_reg;

  /* Total Mal5 Used Packets: Total number of consumed              */
  /* packets for MAL5.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5972 */

     /* TotalNifaCh5CpPkts: Indicates the number of packets used     */
     /* for MAL5                                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch5_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal5_used_packets_reg;

  /* Total Mal6 Used Packets: Total number of consumed              */
  /* packets for MAL6.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5973 */

     /* TotalNifaCh6CpPkts: Indicates the number of packets used     */
     /* for MAL6                                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch6_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal6_used_packets_reg;

  /* Total Mal7 Used Packets: Total number of consumed              */
  /* packets for MAL7.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5974 */

     /* TotalNifaCh7CpPkts: Indicates the number of packets used     */
     /* for MAL7                                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch7_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal7_used_packets_reg;

  /* Total Mal8 Used Packets: Total number of consumed              */
  /* packets for MAL8.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5975 */

     /* TotalNifbCh0CpPkts: Indicates the number of packets used     */
     /* for MAL8                                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch0_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal8_used_packets_reg;

  /* Total Mal9 Used Packets: Total number of consumed              */
  /* packets for MAL9.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5976 */

     /* TotalNifbCh1CpPkts: Indicates the number of packets used     */
     /* for MAL9                                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch1_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal9_used_packets_reg;

  /* Total Mal10 Used Packets: Total number of consumed             */
  /* packets for MAL10                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5977 */

     /* TotalNifbCh2CpPkts: Indicates the number of packets used     */
     /* for MAL10                                                    */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch2_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal10_used_packets_reg;

  /* Total Mal11 Used Packets: Total number of consumed             */
  /* packets for MAL11                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5978 */

     /* TotalNifbCh3CpPkts: Indicates the number of packets used     */
     /* for MAL11                                                    */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch3_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal11_used_packets_reg;

  /* Total Mal12 Used Packets: Total number of consumed             */
  /* packets for MAL12                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5979 */

     /* TotalNifbCh4CpPkts: Indicates the number of packets used     */
     /* for MAL12                                                    */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch4_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal12_used_packets_reg;

  /* Total Mal13 Used Packets: Total number of consumed             */
  /* packets for MAL13                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x597a */

     /* TotalNifbCh5CpPkts: Indicates the number of packets used     */
     /* for MAL13                                                    */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch5_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal13_used_packets_reg;

  /* Total Mal14 Used Packets: Total number of consumed             */
  /* packets for MAL14                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x597b */

     /* TotalNifbCh6CpPkts: Indicates the number of packets used     */
     /* for MAL14                                                    */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch6_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal14_used_packets_reg;

  /* Total Mal15 Used Packets: Total number of consumed             */
  /* packets for MAL15                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x597c */

     /* TotalNifbCh7CpPkts: Indicates the number of packets used     */
     /* for MAL15                                                    */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch7_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_mal15_used_packets_reg;

  /* Total CPUUsed Packets: Total number of consumed packets        */
  /* for CPU packets.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x597d */

     /* TotalCpuCpPkts: Indicates the number of packets used for     */
     /* CPU packets                                                  */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_cpu_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_cpuused_packets_reg;

  /* Total Recycling Used Packets: Total number of consumed         */
  /* packets for Recycling packets.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x597e */

     /* TotalRcyCpPkts: Indicates the number of packets used for     */
     /* Recycling packets                                            */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_rcy_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_recycling_used_packets_reg;

  /* Unicast Egress Packet Header Compensation For Type A:          */
  /* Header compensation for unicast packets. Type A selected       */
  /* when PCT. HeaderCompensationType is reset.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5982 */

     /* HdrAdjustUcRawTypeA: Credit adjust for unicast packets       */
     /* and port type 'RAW'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD hdr_adjust_uc_raw;

     /* HdrAdjustUcCpuTypeA: Credit adjust for unicast packets       */
     /* and port type 'CPU'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD hdr_adjust_uc_cpu;

     /* HdrAdjustUcEthTypeA: Credit adjust for unicast packets       */
     /* and port type 'ETH'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hdr_adjust_uc_eth;

     /* HdrAdjustUcTmTypeA: Credit adjust for unicast packets        */
     /* and port type 'TM'. Adjust credit for up to 32B with MSB     */
     /* as sign indication.                                          */
     /* range: 31:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hdr_adjust_uc_tm;

  } __ATTRIBUTE_PACKED__ unicast_egress_packet_header_compensation_reg[SOC_PB_REGS_PER_HDR_CR_DSCNT_TYPE_REGS];

 /* Multicast Egress Packet Header Compensation For Type A:        */
  /* Header compensation for multicast packets. Type A              */
  /* selected when PCT. HeaderCompensationType is reset.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5984 */

     /* HdrAdjustMcRawTypeA: Credit adjust for unicast packets       */
     /* and port type 'RAW'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD hdr_adjust_mc_raw;

     /* HdrAdjustMcCpuTypeA: Credit adjust for unicast packets       */
     /* and port type 'CPU'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD hdr_adjust_mc_cpu;

     /* HdrAdjustMcEthTypeA: Credit adjust for unicast packets       */
     /* and port type 'ETH'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hdr_adjust_mc_eth;

     /* HdrAdjustMcTmTypeA: Credit adjust for unicast packets        */
     /* and port type 'TM'. Adjust credit for up to 32B with MSB     */
     /* as sign indication.                                          */
     /* range: 31:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hdr_adjust_mc_tm;

  } __ATTRIBUTE_PACKED__ multicast_egress_packet_header_compensation_reg[SOC_PB_REGS_PER_HDR_CR_DSCNT_TYPE_REGS];

  /* Egress Interface No Fragmentation Mode Configuration:          */
  /* Interface fragmentation mode settings.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5986 */

     /* NifaNoFrag: If set, then corresponding Nif A MAL works       */
     /* in no- fragmentation mode. Relevant only when MAL in         */
     /* channelized mode.                                            */
     /* range: 7:0, access type: RW, default value: 0x0              */
     /* NifbNoFrag: If set, then corresponding Nif B MAL works       */
     /* in no- fragmentation mode. Relevant only when MAL in         */
     /* channelized mode.                                            */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD nif_no_frag[SOC_PB_REG_NOF_MALS];

     /* RcyNoFrag: If set, then recycling interface works in         */
     /* no-fragmentation mode.                                       */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_no_frag;

     /* CpuNoFrag: If set, then CPU interface works in               */
     /* no-fragmentation mode.                                       */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpu_no_frag;

  } __ATTRIBUTE_PACKED__ egress_interface_no_fragmentation_mode_configuration_reg;

  /* Egress Aging Settings: Egress out queues aging mechanism       */
  /* settings.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5987 */

     /* AgingEna: If set, enables the aging mechanism in the         */
     /* egress out queues                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD aging_ena;

     /* AgingFc: If set, then aging queues according to flow         */
     /* control to the OFP                                           */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD aging_fc;

     /* AgingRdQ: If set, then aging queues according to the OFP     */
     /* last access                                                  */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD aging_rd_q;

     /* AgingTime: Aging timer settings. Sets the period for         */
     /* aging: '000' - 128 K clocks '001' - 512 K clocks '010' -     */
     /* 1M clocks '011' - 8 M clock '100' - 32 M clocks '101' -      */
     /* 64 M clocks '110' - 128 M clocks '111' - 256 M clocks        */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD aging_time;

  } __ATTRIBUTE_PACKED__ egress_aging_settings_reg;

  /* Ofp Aging Enable Settings: Aging enable per OFP. If set,       */
  /* enables the aging on this OFP. Also depends on global          */
  /* AgingEna bit configuration.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5988 */

     /* PortAgingEn: If set, enables the aging mechanism on the      */
     /* OFP according bitmap. This bit functionality is ANDed        */
     /* with the AgingEna bit.                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_aging_en;

  } __ATTRIBUTE_PACKED__ ofp_aging_enable_settings_reg[SOC_PB_EGQ_OFP_AGING_ENABLE_SETTINGS_REG_MULT_NOF_REGS];

  /* Ofp Force Aging: Force aging bit per OFP. If set, forces       */
  /* the aging on this OFP. Also depends on global AgingEna         */
  /* bit configuration.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x598b */

     /* OfpForceAging: If set, forces the aging mechanism on the     */
     /* OFP according ports bitmap. This bit functionality is        */
     /* ANDed with the AgingEna bit.                                 */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ofp_force_aging;

  } __ATTRIBUTE_PACKED__ ofp_force_aging_reg[SOC_PB_EGQ_OFP_FORCE_AGING_REG_MULT_NOF_REGS];

  /* FQPConfiguration: Force egress out queues not ready.           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x598e */

     /* ForceNotRdy: If set, then all egress OFP queues are set      */
     /* to be "not ready" to receive arrived segments.               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_not_rdy;

     /* CfcFcDis: If set, then EGQ will ignore flow-control from     */
     /* CFC.                                                         */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfc_fc_dis;

  } __ATTRIBUTE_PACKED__ fqpconfiguration_reg;

  /* Egress Port Priority Configuration Pqp: Configure the          */
  /* OFP egress priority in PQP. The priority is applicable         */
  /* only for OFP connected to Nif ports.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x598f */

     /* PortPriorityPqp: Each two bits set the OFP priority          */
     /* according to the following encoding: 2'b00 - High            */
     /* Priority 2'b01 - Mid Priority 2'b10,2'b11 - Low Priority     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_priority_pqp;

  } __ATTRIBUTE_PACKED__ egress_port_priority_configuration_pqp_reg[SOC_PB_EGQ_EGRESS_PORT_PRIORITY_CONFIGURATION_PQP_REG_MULT_NOF_REGS];

  /* Egress Port Priority Configuration: Configure the OFP          */
  /* egress priority in FQP. The priority is applicable only        */
  /* for OFP connected to Nif ports.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5994 */

     /* PortPriority: Each two bits set the OFP priority             */
     /* according to the following encoding: 2'b00 - High            */
     /* Priority 2'b01 - Mid Priority 2'b10,2'b11 - Low Priority     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_priority[SOC_PB_NOF_EGR_PORT_PRIO_CONF_FLDS];

  } __ATTRIBUTE_PACKED__ egress_port_prio_conf_reg[SOC_PB_EGQ_EGRESS_PORT_PRIORITY_CONFIGURATION_REG_MULT_NOF_REGS];

  /* Mapping Configuration Mal0 In Spaui: Bitmap of OFP             */
  /* mapping to NIF MAL0 when working in Spaui mode.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5999 */

     /* MapMal0Spaui: If bit N is set, then the corresponding        */
     /* OFP is associated with Nif A channelized port 0 (Port 0      */
     /* in MAL 0)                                                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD map_mal_spaui;

  } __ATTRIBUTE_PACKED__ mapping_configuration_mal_in_spaui_reg[SOC_PB_NOF_MAP_CONF_CHNIF_REGS][SOC_PB_EGQ_MAPPING_CONFIGURATION_MAL0_IN_SPAUI_REG_MULT_NOF_REGS];

  /* Mapping Configuration Mal0 In Sgmii: Mapping                   */
  /* configuration for NIF MAL0 in Sgmii mode.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x599c */

     /* MapMal0Sgmii: Defines the mapping of non-channelized NIF     */
     /* ports 0-3 (Nif A MAL0). Each 8 bits represent an OFP         */
     /* index and valid bit. If the valid bit is set then the        */
     /* index represent the OFP that is mapped to the                */
     /* non-channelized port. For non-channelized port N [8N+7]      */
     /* represent the valid bit and [8N+6:8N] represent the OFP      */
     /* index.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ofp_index[SOC_PB_NOF_MAP_CONF_CHNIF_NOF_FLDS];
     SOC_PETRA_REG_FIELD valid[SOC_PB_NOF_MAP_CONF_CHNIF_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ mapping_configuration_mal_in_sgmii_reg[SOC_PB_NOF_MAP_CONF_CHNIF_REGS];

  /* Mapping Configuration For Recycling Ports: Bitmap of OFP       */
  /* mapping to recycling interface                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59d9 */

     /* MapRcyPort: If bit N is set, then the corresponding OFP      */
     /* is associated with the recycling interface                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD map_rcy_port;

  } __ATTRIBUTE_PACKED__ mapping_configuration_for_recycling_ports_reg[SOC_PB_EGQ_MAPPING_CONFIGURATION_FOR_RECYCLING_PORTS_REG_MULT_NOF_REGS];

  /* Mapping Configuration For Cpu Ports: Bitmap of OFP             */
  /* mapping to CPU and OLP interface.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59dc */

     /* MapCpuPort: If set, then maps the OFP to the ECI             */
     /* interface. Bit 0 - maps OFP 0 Bits 6:1 - maps OFP 78:73      */
     /* Bit 7 - maps OFP 79 OFP 0 and OFP 73 - OFP 78 are            */
     /* applicable for CPU interface, while OFP 79 is applicable     */
     /* for the OLP interface                                        */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD map_cpu_port;

  } __ATTRIBUTE_PACKED__ mapping_configuration_for_cpu_ports_reg;

  /* Disable Egress OFP: Disable settings for egrees OFPs (debug).  */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x59dd - 0x59df */

    /* range: 79:0, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD disable_egress_ofp;

  } __ATTRIBUTE_PACKED__ disable_egress_ofp_reg[SOC_PB_REG_NOF_FAP_PORT_REGS];

  /* Fragmentation Queues Ready Words Threshold: Per OFP            */
  /* fragmentation queues threshold. If threshold crossed           */
  /* from below, then the corresponding OFP fragmentation           */
  /* queue is not ready to receive arriving descriptors.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59e0 */

     /* FqRdyTh: Indicates the words thresholds in the               */
     /* fragmentation egress out queues. When crossed from           */
     /* below, the appropriate queue becomes "not ready" to          */
     /* receive new descriptors.                                     */
     /* range: 9:0, access type: RW, default value: 0x40             */
     SOC_PETRA_REG_FIELD fq_rdy_th;

  } __ATTRIBUTE_PACKED__ fragmentation_queues_ready_words_threshold_reg;

  /* Fc From Cfc High Enable: FC from CFC high enable.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59e3 */

     /* FcFromCfcHighEn: FC from CFC HIGH enable vector              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_from_cfc_high_en;

  } __ATTRIBUTE_PACKED__ fc_from_cfc_high_enable_reg[SOC_PB_EGQ_FC_FROM_CFC_HIGH_ENABLE_REG_MULT_NOF_REGS];

  struct
  {
     SOC_PETRA_REG_ADDR  addr; /*  0x59e6-0x59e8  */

     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fqempty;

  } __ATTRIBUTE_PACKED__ fragmentation_queues_empty_indication[3] ;

  /* Oc768 Configuration: OC768 mode general configuration          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59e9 */

     /* SeqnumMskDis: Sequence number masking. If set then           */
     /* sequence number is 16 bits, otherwise 15 bits.               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD seqnum_msk_dis;

  } __ATTRIBUTE_PACKED__ oc768_configuration_reg;

  /* Oc768 Qm1 Mask: OC768 mode FAP ports masking                   */
  /* Oc768 Qm2 Mask: OC768 mode FAP ports masking                   */
  /* Oc768 Qm3 Mask: OC768 mode FAP ports masking                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59ea */

     /* Oc768Qm1Mask: OC768 mode FAP port 1 masking                  */
     /* Oc768Qm2Mask: OC768 mode FAP port 2 masking                  */
     /* Oc768Qm3Mask: OC768 mode FAP port 3 masking                  */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD oc768_qm_mask;

  } __ATTRIBUTE_PACKED__ oc768_qm_mask_reg[SOC_PB_REG_NOF_RESEQS];

  /* Spaui Sel: Configures the MALs mode. For each MAL,             */
  /* configure whether it works in SPAUI mode or SGMII mode.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59eb */

     /* SpauiSel: If set, the corresponding channelized port is      */
     /* SPAUI; otherwise, it is Sgmii.                               */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD spaui_sel;

     /* Mal_isSgmii_2_5: If set, the corresponding MAL is Sgmii      */
     /* 2.5G                                                         */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mal_is_sgmii_2_5;

  } __ATTRIBUTE_PACKED__ spaui_sel_reg;

  /* Nif Port Is Sgmii 2 5: Configures the NIF ports mode.          */
  /* For each NIF port, configure whether it works in SGMII         */
  /* 2.5G mode.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59ec */

     /* NifPortIsSgmii_2_5: If set, the corresponding NIF port       */
     /* is Sgmii 2.5G                                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD nif_port_is_sgmii_2_5;

  } __ATTRIBUTE_PACKED__ nif_port_is_sgmii_2_5_reg[SOC_PB_EGQ_NIF_PORT_IS_SGMII_2_5_REG_MULT_NOF_REGS];

  /* Spaui Port Delay: Configures the minimum gap in clocks         */
  /* between consecutive NIF Spaui ports to be selected by          */
  /* the FQP scheduler.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59ee */

     /* SpauiPortDelay: SpauiPortDelay Each 4 bits represents        */
     /* the corresponding Spaui port delay. Below are the            */
     /* correct values: SPAUI port: 8 ILAKEN-100G port: 1            */
     /* ILAKEN-50G port: 3                                           */
     /* range: 31:0, access type: RW, default value: 64'h1111111111111111 */
     SOC_PETRA_REG_FIELD spaui_port_delay;

  } __ATTRIBUTE_PACKED__ spaui_port_delay_reg[SOC_PB_EGQ_SPAUI_PORT_DELAY_REG_MULT_NOF_REGS];

  /* Sgmii Port Delay: Configures the minimum gap in clocks         */
  /* between consecutive NIF Sgmii port to be selected by the       */
  /* FQP scheduler. Sgmii ports in the same MAL have the same       */
  /* delay.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59f0 */

     /* SgmiiPortDelay: Each 4 bits represents the corresponding     */
     /* Sgmii port delay. The port delay should be 8.                */
     /* range: 31:0, access type: RW, default value: 64'h1111111111111111 */
     SOC_PETRA_REG_FIELD sgmii_port_delay;

  } __ATTRIBUTE_PACKED__ sgmii_port_delay_reg[SOC_PB_EGQ_SGMII_PORT_DELAY_REG_MULT_NOF_REGS];

  /* Cpu Olp Rcy Port Delay Configuration:                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59f2 */

     /* CpuPortDelay: Configures the minimum gap in clocks           */
     /* between consecutive CPU ports to be selected by the FQP      */
     /* scheduler. All CPU ports have the same delay. The port       */
     /* delay is 4 bits wide.                                        */
     /* range: 3:0, access type: RW, default value: 0x8              */
     SOC_PETRA_REG_FIELD cpu_port_delay;

     /* OlpPortDelay: Configures the minimum gap in clocks           */
     /* between consecutive OLP port to be selected by the FQP       */
     /* scheduler. The port delay is 4 bits wide.                    */
     /* range: 7:4, access type: RW, default value: 0x8              */
     SOC_PETRA_REG_FIELD olp_port_delay;

     /* RcyPortDelay: Configures the minimum gap in clocks           */
     /* between consecutive RCY port to be selected by the FQP       */
     /* scheduler. All RCY ports have the same delay. The port       */
     /* delay is 4 bits wide.                                        */
     /* range: 11:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD rcy_port_delay;

  } __ATTRIBUTE_PACKED__ cpu_olp_rcy_port_delay_configuration_reg;

  /* FQPScheduler Configuration: Configures whether request         */
  /* or higher request from delete, OLP, recycle, and CPU           */
  /* interfaces is enabled.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59f3 */

     /* CfgDelReqEn: Configures whether request from delete FIFO     */
     /* is enabled                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfg_del_req_en;

     /* CfgOlpReqEn: Configures whether request from OLP is          */
     /* enabled                                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfg_olp_req_en;

     /* CfgCpuReqEn: Configures whether request from CPU FIFO is     */
     /* enabled                                                      */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfg_cpu_req_en;

     /* CfgRcyReqEn: Configures whether request from RCY FIFO is     */
     /* enabled                                                      */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfg_rcy_req_en;

     /* CfgDelHigherEn: Configures whether higher priority           */
     /* request from delete FIFO is enabled                          */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfg_del_higher_en;

     /* CfgOlpHigherEn: Configures whether higher priority           */
     /* request from OLP is enabled                                  */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfg_olp_higher_en;

     /* CfgCpuHigherEn: Configures whether higher priority           */
     /* request from CPU FIFO is enabled                             */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfg_cpu_higher_en;

     /* CfgRcyHigherEn: Configures whether higher priority           */
     /* request from RCY FIFO is enabled                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfg_rcy_higher_en;

     /* NifSpOvrCpu: Configures whether NIF gets strict priority     */
     /* over the CPU interface.                                      */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nif_sp_ovr_cpu;

     /* NifSpOvrRcy: Configures whether NIF gets strict priority     */
     /* over the RCY interface.                                      */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nif_sp_ovr_rcy;

     /* CpuStrictPrEn: CPU strict priority enable in the FQP         */
     /* scheduler. If set CPU interface gets strict priority         */
     /* over all other interfaces; else the scheduler works in       */
     /* round-robin between all the interfaces.                      */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpu_strict_pr_en;

     /* WorkConservingModeEn: Configures whether EGQ scheduler       */
     /* is work conserving.                                          */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD work_conserving_mode_en;

     /* WorkConservingModeCancelEn:                                  */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD work_conserving_mode_cancel_en;

  } __ATTRIBUTE_PACKED__ fqpscheduler_configuration_reg;

  /* Nif Interlaken Mode: NIF Interlaken mode enable                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59f4 */

     /* CfgIlaken0: Configures whether NIFA works in Interlaken      */
     /* mode.                                                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     /* CfgIlaken1: Configures whether NIFB works in Interlaken      */
     /* mode.                                                        */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfg_ilaken[SOC_PB_REG_NOF_ILKNS];

  } __ATTRIBUTE_PACKED__ nif_interlaken_mode_reg;

  /* Nrdy Th Sel: For each FQP txi, selects one from 7 nrdy         */
  /* thresholds.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59f5 */

     /* NrdyThSel: Regarding txi N, NrdyThSel[3N+2:3N] selects       */
     /* which nrdy threshold is relevant for txi N. There are 67     */
     /* FQP txi.                                                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD nrdy_th_sel;

  } __ATTRIBUTE_PACKED__ nrdy_th_sel_reg[SOC_PB_EGQ_NRDY_TH_SEL_REG_MULT_NOF_REGS];

  /* Nrdy Th0 2: Nrdy thersholds 0, 1 and 2                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59fc */

     /* NrdyTh0: FQP txi Nrdy threshold0                             */
     /* range: 9:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD nrdy_th0;

     /* NrdyTh1: FQP txi Nrdy threshold1                             */
     /* range: 19:10, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD nrdy_th1;

     /* NrdyTh2: FQP txi Nrdy threshold2                             */
     /* range: 29:20, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD nrdy_th2;

  } __ATTRIBUTE_PACKED__ nrdy_th0_2_reg;

  /* Nrdy Th3 5: Nrdy thersholds 3, 4 and 5                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59fd */

     /* NrdyTh3: FQP txi Nrdy threshold3                             */
     /* range: 9:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD nrdy_th3;

     /* NrdyTh4: FQP txi Nrdy threshold4                             */
     /* range: 19:10, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD nrdy_th4;

     /* NrdyTh5: FQP txi Nrdy threshold5                             */
     /* range: 29:20, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD nrdy_th5;

  } __ATTRIBUTE_PACKED__ nrdy_th3_5_reg;

  /* Nrdy Th6 7: Nrdy thersholds 6 and 7                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59fe */

     /* NrdyTh6: FQP txi Nrdy threshold6                             */
     /* range: 9:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD nrdy_th6;

     /* NrdyTh7: FQP txi Nrdy threshold7                             */
     /* range: 19:10, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD nrdy_th7;

  } __ATTRIBUTE_PACKED__ nrdy_th6_7_reg;

  /* Mal Priority3 Index0 3: MALS 0-3 priority3 index.              */
  /* Mal Priority3 Index4 7: MALS 4-7 priority3 index.              */
  /* Mal Priority3 Index8 11: MALS 8-11 priority3 index.            */
  /* Mal Priority3 Index12 15: MALS 12-15 priority3 index.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x59ff */

     /* Mal0Priority3Index: MAL 0 priority 3 index.                  */
     /* range: 6:0, access type: RW, default value: 0x0              */
     /* Mal1Priority3Index: MAL 1 priority 3 index.                  */
     /* range: 14:8, access type: RW, default value: 0x0             */
     /* Mal2Priority3Index: MAL 2 priority 3 index.                  */
     /* range: 22:16, access type: RW, default value: 0x0            */
     /* Mal3Priority3Index: MAL 3 priority 3 index.                  */
     /* range: 30:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mal_priority3_index[SOC_PB_REG_NOF_MAL_PRIO3_FLDS];
  } __ATTRIBUTE_PACKED__ mal_priority3[SOC_PB_REG_NOF_MAL_PRIO3_REGS];

  /* Nif Mal Enable Register: Per NIF MAL configuration             */
  /* register                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a03 */

     /* NifCancelEn: If NIF MAL n is Interlaken interface, then      */
     /* bit n should be 0, otherwise 1.                              */
     /* range: 15:0, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD nif_cancel_en;

     /* HigherReqEnPerMal: Higher request enable per NIF MAL.        */
     /* range: 31:16, access type: RW, default value: 0xffff         */
     SOC_PETRA_REG_FIELD higher_req_en_per_mal;

  } __ATTRIBUTE_PACKED__ nif_mal_enable_reg;

  /* Egress Shaper Enable Settings: Enable the operation of         */
  /* all shapers.                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a04 */

     /* SchEna: If set, then the shapers for the egress              */
     /* interfaces are enabled.                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD sch_enable;

     /* SprSetSel: If set, then the shapers set B is selected.       */
     /* Otherwise, shapers set A is selected.                        */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD spr_set_sel;

  } __ATTRIBUTE_PACKED__ egress_shaper_enable_settings_reg;

  /* Egress Shapers Credit Memory Init Status: Egress shapers       */
  /* credit memory initialization status indication.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a05 */

     /* SchInit: When set, indicates shaper credit memory            */
     /* initialization procedure. The initialization is              */
     /* triggered by enabling shaper enable register 'SchEna'.       */
     /* Reset when initialization completed.                         */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD sch_init;

  } __ATTRIBUTE_PACKED__ egress_shapers_credit_memory_init_status_reg;

  /* Egress Shaper Calendars Arbitration Cycle Length: Set          */
  /* the cycle length of the CALCAL memory.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a06 */

     /* CalCalLenA: This parameter specifies the length of           */
     /* calendars calendar. The calendar length is the value of      */
     /* this parameter plus 1                                        */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cal_cal_len[SOC_PB_NOF_INSTANCES_EGQ_CAL_SETS];

  } __ATTRIBUTE_PACKED__ egress_shaper_calendars_arbitration_cycle_length_reg;

  /* Egress Shaper Configuration AFor Nif Mal0: Nif MAL0            */
  /* interface Shaper.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a07 */

     /* NifMal0SprRateA: Number of bandwidth credits, in units       */
     /* of 1/256th byte, to allocate for Nif MAL0 every core         */
     /* clock cycle. If core-clock runs at 250MHz, this              */
     /* corresponds to the number of 1/256th bytes to allocate       */
     /* every 4ns. For a bandwidth of 10Gbps, this register          */
     /* needs to be configured to 1280 or 0x500.                     */
     /* range: 15:0, access type: RW, default value: 0x500           */
     SOC_PETRA_REG_FIELD spr_rate;

     /* NifMal0SprMaxBurstA: The maximum value that credit for       */
     /* Nif MAL0 may have.                                           */
     /* range: 28:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD spr_max_burst;

  } __ATTRIBUTE_PACKED__ egress_shpr_conf_nif_reg[SOC_PB_EGR_SHPR_CONF_NIF_NOF_REGS];

  /* Egress Shaper Configuration For Recycle Interface Ports:       */
  /* Recycling interface Shaper.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a17 */

     /* RcySprRateA: Number of bandwidth credits, in units of        */
     /* 1/256th byte, to allocate for RCY every core clock           */
     /* cycle. If core-clock runs at 250MHz, this corresponds to     */
     /* the number of 1/256th bytes to allocate every 4ns. For a     */
     /* bandwidth of 10Gbps, this register needs to be               */
     /* configured to 1280 or 0x500.                                 */
     /* range: 15:0, access type: RW, default value: 0x500           */
     SOC_PETRA_REG_FIELD rcy_spr_rate;

     /* RcySprMaxBurstA: The maximum value that credit for RCY       */
     /* may have.                                                    */
     /* range: 28:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD rcy_spr_max_burst;

  } __ATTRIBUTE_PACKED__ egress_shpr_conf_for_recycle_interface_ports_reg;

  /* Egress Shaper Configuration AFor Eci Ports: ECI                */
  /* interface shaper configuration. Used for port shaping of       */
  /* CPU ports and OLP port.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a18 */

     /* CpuSprRateA: Number of bandwidth credits, in units of        */
     /* 1/256th byte, to allocate for CPU every core clock           */
     /* cycle. If core-clock runs at 250MHz, this corresponds to     */
     /* the number of 1/256th bytes to allocate every 4ns. For a     */
     /* bandwidth of 10Gbps, this register needs to be               */
     /* configured to 1280 or 0x500.                                 */
     /* range: 15:0, access type: RW, default value: 0x500           */
     SOC_PETRA_REG_FIELD cpu_spr_rate;

     /* CpuSprMaxBurstA: The maximum value that credit for CPU       */
     /* may have.                                                    */
     /* range: 28:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD cpu_spr_max_burst;

  } __ATTRIBUTE_PACKED__ egress_shpr_conf_for_eci_ports_reg;
 
  /* Egress Shaper Configuration For Olp Port: OLP interface        */
  /* shaper configuration. Used for port shaping of OLP port.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a19 */

     /* OlpSprScm: How many credits to add to port.                  */
     /* range: 24:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD olp_spr_scm;

  } __ATTRIBUTE_PACKED__ egress_shaper_configuration_for_olp_port_reg;

  /* Egress Shaper Configuration For Nif Calendars Length:          */
  /* Lengths of Shaper Calendars of the channelized Nif             */
  /* ports.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a1a */

     /* NifChSprCalLenA: This parameter specifies the length         */
     /* of shaper calendar for CH0. The calendar length is the       */
     /* value of this parameter plus 1.                              */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nif_ch_spr_cal_len[SOC_PB_EGR_SHPR_PER_NIF_GRP_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ egress_shpr_conf_for_nif_cal_len_reg[SOC_PB_EGR_SHPR_PER_NIF_GRP_NOF_REGS];

  /* Egress Shaper Configuration For Other Calendars Length:        */
  /* Lengths of Shaper Calendars of the non-channelized NifA        */
  /* and NifB ports, Recycling and CPU interfaces.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a1e */

     /* RcySprCalLenA: This parameter specifies the length of        */
     /* shaper calendar for RCY. The calendar length is the          */
     /* value of this parameter plus 1.                              */
     /* range: 14:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcy_spr_cal_len;

     /* CpuSprCalLenA: This parameter specifies the length of        */
     /* shaper calendar for CPU. The calendar length is the          */
     /* value of this parameter plus 1.                              */
     /* range: 22:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpu_spr_cal_len;

  } __ATTRIBUTE_PACKED__ egress_shpr_conf_for_other_calendars_length_reg;

  /* Check Bw To Ofp: The OFP to check BW to; otherwise,            */
  /* check total BW.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a36 */

     /* OfpToCheckBw: The OFP to check BW to.                        */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ofp_to_check_bw;

     /* CheckBwToOfp: If set check BW to OfpToCheckBw;               */
     /* otherwise, check total BW.                                   */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD check_bw_to_ofp;

  } __ATTRIBUTE_PACKED__ check_bw_to_ofp_reg;

  /* Gtimer Config: GTIMER configuration.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a37 */

     /* TimerConfig: Period of time in clocks.                       */
     /* range: 30:0, access type: RW, default value: 31'hee6b27f     */
     SOC_PETRA_REG_FIELD timer_config;

  } __ATTRIBUTE_PACKED__ gtimer_config_reg;

  /* Gtimer Config Cont: GTIMER configuration.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5a38 */

     /* ClearGtimer: Clear timer.                                    */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD clear_gtimer;

     /* ActivateGtimer: Activate timer.                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD activate_gtimer;

     /* GtimerActive: If set GTIMER is active.                       */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_active;

  } __ATTRIBUTE_PACKED__ gtimer_config_cont_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_EGQ_REGS;
/* Block definition: EPNI  */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: EPNI interrupt register                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a00 */

     /* MirrOvfInt: If set, then mirroring FIFO in the egress        */
     /* queue has overflowed.                                        */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD mirr_ovf_int;

     /* InvalidMplsCmdInt: If set, then the forwarding unit has      */
     /* received mpls swap command with mpls command different       */
     /* than SWAP.                                                   */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD invalid_mpls_cmd_int;

     /* InvalidIpTunnelCmdInt: If set, then the encapsulation        */
     /* unit has received IP tunnel command with forwarding code     */
     /* different than IP.                                           */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD invalid_ip_tunnel_cmd_int;

     /* InvalidEthCodeInt: If set, then the Link unit has            */
     /* received forwarding code different than ethernet and         */
     /* encapsulation entry pointer which is NULL.                   */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD invalid_eth_code_int;

     /* EsemIntVec: If set then one of the bits in EsemIntReg        */
     /* has been set                                                 */
     /* range: 27:27, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD esem_int_vec;

     /* EccErrVec: If set then one of the bits in EccIntReg has      */
     /* been set                                                     */
     /* range: 28:28, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ecc_err_vec;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Ecc Int Reg:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a01 */

     /* PrdmEccErr: PNI Rcy FIFO descriptor memory                   */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD prdm_ecc_err;

     /* PrdmEccFix: PNI Rcy FIFO descriptor memory                   */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD prdm_ecc_fix;

     /* MdmEccErr: PNI Mirroring FIFO descriptor memory              */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mdm_ecc_err;

     /* MdmEccFix: PNI Mirroring FIFO descriptor memory              */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mdm_ecc_fix;

  } __ATTRIBUTE_PACKED__ ecc_int_reg;

  /* Esem Int Reg: This register contains the interrupt             */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a02 */

     /* EsemErrorCamTableFull: If set,                               */
     /* EsemErrorCamTableFullCounter NEQ 0                           */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD esem_error_cam_table_full;

     /* EsemErrorTableCoherency: If set,                             */
     /* EsemErrorTableCoherencyCounter NEQ 0                         */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD esem_error_table_coherency;

     /* EsemErrorDeleteUnknownKey: If set,                           */
     /* EsemErrorDeleteUnknownKeyCounter NEQ 0                       */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD esem_error_delete_unknown_key;

     /* EsemErrorReachedMaxEntryLimit: If set,                       */
     /* EsemErrorReachedMaxEntryLimitCounter NEQ 0                   */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD esem_error_reached_max_entry_limit;

     /* EsemWarningInsertedExisting: If set,                         */
     /* EsemWarningInsertedExistingCounter NEQ 0                     */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD esem_warning_inserted_existing;

     /* EsemManagementUnitFailureValid: If Asserted,                 */
     /* EsemManagementUnitFailure register contains valid data       */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD esem_management_unit_failure_valid;

     /* EsemManagementCompleted: Asserts when reply fifo is not      */
     /* empty                                                        */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD esem_management_completed;

  } __ATTRIBUTE_PACKED__ esem_int_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a10 */

     /* MaskMirrOvf: Writing 0 masks the corresponding interrupt     */
     /* source                                                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_mirr_ovf;

     /* MaskInvalidMplsCmdInt: Writing 0 masks the corresponding     */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_invalid_mpls_cmd_int;

     /* MaskInvalidIpTunnelCmdInt: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_invalid_ip_tunnel_cmd_int;

     /* MaskInvalidEthCodeInt: Writing 0 masks the corresponding     */
     /* interrupt source                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_invalid_eth_code_int;

     /* MaskEsemIntVec: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_esem_int_vec;

     /* MaskEccErrVec: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_ecc_err_vec;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Ecc Int Reg Mask:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a11 */

     /* EccIntRegMask: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ecc_int_reg_mask;

  } __ATTRIBUTE_PACKED__ ecc_int_reg_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a20 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_EPNI_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a30 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_EPNI_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a40 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set, to 0, one       */
     /* operation is performed. The cpu can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set, to 0, then the command has no timeout.       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a41 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a42 */

     /* IndirectCommandDataIncrement:                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_EPNI_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* Gtimer Configuration: GTIMER configuration.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a58 */

     /* GtimerCycle: Period of time in clocks.                       */
     /* range: 29:0, access type: RW, default value: 30'hee6b280     */
     SOC_PETRA_REG_FIELD gtimer_cycle;

     /* GtimerEnable: Enable using Gtimer                            */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_enable;

     /* GtimerResetOnTrigger: Reset the Gtimer counter when          */
     /* triggered.                                                   */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_reset_on_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;

  /* Gtimer Trigger: Gtimer trigger                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a59 */

     /* GtimerTrigger: Gtimer trigger                                */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_trigger;

  } __ATTRIBUTE_PACKED__ gtimer_trigger_reg;

  /* Recycling Interface Priority Settings: Configuration of        */
  /* the priority scheme between the recycling queue and the        */
  /* mirroring queue on the egress recycling interface.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a5a */

     /* RcySpOrRr: If set, then recycling queue gets strict          */
     /* priority. Otherwise, it gets round-robin scheduling          */
     /* between recycling queue and mirroring queue                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcy_sp_or_rr;

  } __ATTRIBUTE_PACKED__ recycling_interface_priority_settings_reg;

  /* Ecc Corecction Disable: Ecc correction disable, setting        */
  /* bits for debug purpose.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a5b */

     /* PrdmDisEcc: If set, then disables the ECC decoder on         */
     /* PRDM memory output                                           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD prdm_dis_ecc;

     /* MdmDisEcc: If set, then disables the ECC decoder on MDM      */
     /* memory output                                                */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mdm_dis_ecc;

  } __ATTRIBUTE_PACKED__ ecc_corecction_disable_reg;

  /* Egress Interface No Fragmentation Mode Configuration:          */
  /* Interface fragmentation mode settings.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a5c */

     /* NifaNoFrag: If set, then Nif A channelized port works in     */
     /* no- fragmentation mode. NifaNoFrag[i] refers to Nif          */
     /* Port[i*4]. This register controls only the interface         */
     /* from EGQ to NIF and not the scheduling between the OFPs.     */
     /* range: 7:0, access type: RW, default value: 0x0              */
     /* NifbNoFrag: If set, then Nif B channelized port works in     */
     /* no- fragmentation mode. NifbNoFrag[i] refers to Nif          */
     /* Port[32+i*4]. This register controls only the interface      */
     /* from EGQ to NIF and not the scheduling between the OFPs.     */
     /* range: 15:8, access type: RW, default value: 0x0             */

     SOC_PETRA_REG_FIELD nif_no_frag[SOC_PB_REG_NOF_MALS];


     /* RcyNoFrag: If set, then recycling interface works in         */
     /* no-fragmentation mode. This register controls only the       */
     /* interface from EGQ to IRE and not the scheduling between     */
     /* the OFPs.                                                    */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_no_frag;

     /* CpuNoFrag: If set, then CPU interface works in               */
     /* no-fragmentation mode. This register controls only the       */
     /* interface from the EGQ to CPU and not the scheduling         */
     /* between the OFPs.                                            */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpu_no_frag;

  } __ATTRIBUTE_PACKED__ egress_interface_no_fragmentation_mode_configuration_reg;

  /* Map Ofp To Mirr Channel: Mapping OFP to outbound               */
  /* mirroring channel                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a5d */

     /* MapOfpToMirrCha: Each six bits configure the outbound        */
     /* mirror channel for OFP[0-79]. MapOfpToMirrCha[N*6+5:N*6]     */
     /* selects the outbound mirror channel set for port N.          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD map_ofp_to_mirr_cha;

  } __ATTRIBUTE_PACKED__ map_ofp_to_mirr_channel_reg[SOC_PB_EPNI_MAP_OFP_TO_MIRR_CHANNEL_REG_MULT_NOF_REGS];

  /* Check Bw To Packet Descriptor: The packet descriptor to        */
  /* check BW to. If all descriptors are masked                     */
  /* (MaskCheckBwToPacketDescriptor) check total BW.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a6d */

     /* OfpToCheckBw: The OFP to check BW to.                        */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ofp_to_check_bw;

     /* FifoToCheckBw: The FIFO to check BW to.                      */
     /* range: 9:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fifo_to_check_bw;

     /* NifPortToCheckBw: The NIF port to check BW to.               */
     /* range: 17:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nif_port_to_check_bw;

     /* NifChannelToCheckBw: The NIF channel to check BW to.         */
     /* range: 23:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nif_channel_to_check_bw;

     /* OutboundMirrorToCheckBw: Check BW to outbound mirror.        */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD outbound_mirror_to_check_bw;

  } __ATTRIBUTE_PACKED__ check_bw_to_packet_descriptor_reg;

  /* Mask Check Bw To Packet Descriptor: Each bit in                */
  /* CheckBwToPacketDescriptor can be masked.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a6e */

     /* MaskOfpToCheckBw: Mask the OFP to check BW to.               */
     /* range: 7:0, access type: RW, default value: 0xff             */
     SOC_PETRA_REG_FIELD mask_ofp_to_check_bw;

     /* MaskFifoToCheckBw: Mask the FIFO to check BW to.             */
     /* range: 9:8, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD mask_fifo_to_check_bw;

     /* MaskNifPortToCheckBw: Mask the NIF port to check BW to.      */
     /* range: 17:12, access type: RW, default value: 0x3f           */
     SOC_PETRA_REG_FIELD mask_nif_port_to_check_bw;

     /* MaskNifChannelToCheckBw: Mask the NIF channel to check       */
     /* BW to.                                                       */
     /* range: 23:18, access type: RW, default value: 0x3f           */
     SOC_PETRA_REG_FIELD mask_nif_channel_to_check_bw;

     /* MaskOutboundMirrorToCheckBw: Don't check BW to outbound      */
     /* mirror.                                                      */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD mask_outbound_mirror_to_check_bw;

  } __ATTRIBUTE_PACKED__ mask_check_bw_to_packet_descriptor_reg;

  /* Gtimer Config: GTIMER configuration.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a6f */

     /* TimerConfig: Period of time in clocks.                       */
     /* range: 30:0, access type: RW, default value: 31'hee6b27f     */
     SOC_PETRA_REG_FIELD timer_config;

  } __ATTRIBUTE_PACKED__ gtimer_config_reg;

  /* Gtimer Config Cont: GTIMER configuration.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a70 */

     /* ClearGtimer: Clear timer.                                    */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD clear_gtimer;

     /* ActivateGtimer: Activate timer.                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD activate_gtimer;

     /* GtimerActive: If set GTIMER is active.                       */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_active;

  } __ATTRIBUTE_PACKED__ gtimer_config_cont_reg;

  /* Ofp2tdm Map: Mapping OTM-ports to TDM destination.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a71 */

     /* Ofp2tdmMap: Configures whether the corresponding OFP is      */
     /* TDM port.                                                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ofp2tdm_map;

  } __ATTRIBUTE_PACKED__ ofp2tdm_map_reg[SOC_PB_EPNI_OFP2TDM_MAP_REG_MULT_NOF_REGS];

  /* Tdm Epe Configuration: TDM optimized mode configuration.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a74 */

     /* Tdm_2bytesPktSize: The packet size when working with TDM     */
     /* optimized FTMH mode.                                         */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_2bytes_pkt_size;

     /* Tdm_2bytesFtmh: If set then working with optemized FTMH      */
     /* mode.                                                        */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_2bytes_ftmh;

  } __ATTRIBUTE_PACKED__ tdm_epe_configuration_reg;

  /* Tdm En Crc Per Port: Birmap mapping ports for CRC              */
  /* removal                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a75 */

     /* TdmEnCrcPerPort: If set then packets directed to the         */
     /* corresponding OFP with CRC.                                  */
     /* range: 31:0, access type: RW, default value: 80'hffffffffffffffffffff */
     SOC_PETRA_REG_FIELD tdm_en_crc_per_port;

  } __ATTRIBUTE_PACKED__ tdm_en_crc_per_port_reg[SOC_PB_EPNI_TDM_EN_CRC_PER_PORT_REG_MULT_NOF_REGS];

  /* Fat Pipe Configuration: Fat-Pipe Configuration.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a78 */

     /* FatPipePorts: If FatPipePorts[i] is set then                 */
     /* Out-Tm-Port[i+1] is part of a Fat-Pipe port and a            */
     /* sequence number is added to the MSB of the packet.           */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fat_pipe_ports;

     /* SeqnumMskDis: If set then the sequence number is 16          */
     /* bits; else the sequence number is 15 bits.                   */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD seqnum_msk_dis;

     /* SeqnumMskMsb: If SeqnumMskDis is not set, then the           */
     /* sequence number added to the packet header MSB is            */
     /* SeqnumMskMsb, SeqNumCnt[14:0]\}; else SeqNumCnt[15:0]        */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD seqnum_msk_msb;

  } __ATTRIBUTE_PACKED__ fat_pipe_configuration_reg;

  /* Otmh Ext Config: Reserved values for OTMH extensions.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a8b */

     /* OtmhSrcextBits15to13: The value for OTMH Source              */
     /* extension bits 15:13                                         */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD otmh_srcext_bits15to13;

     /* OtmhDestextBits15to13: The value for OTMH destination        */
     /* extension bits 15:13                                         */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD otmh_destext_bits15to13;

  } __ATTRIBUTE_PACKED__ otmh_ext_config_reg;
  /* Pmc Parity En: PMM header generation configuration             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3acf */

     /* PmcParityEn: If set then ETPP will generates PMM header      */
     /* (relevant for TDM application). Lfem2 of Copy-Engines2       */
     /* is hard-coded to generate the parity bit of the new          */
     /* header created.                                              */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD pmc_parity_en;

  } __ATTRIBUTE_PACKED__ pmc_parity_en_reg;

  /* Mirror Enable: Mirror enable vector                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3ad0 */

     /* MirrorEnable: Index is \{mirr_vid_index[2:0],                */
     /* PP-Port[5:0]\}, output is 1-bit indicates whether to         */
     /* mirror the packet or not.                                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mirror_enable;

  } __ATTRIBUTE_PACKED__ mirror_enable_reg[SOC_PB_EPNI_MIRROR_ENABLE_REG_MULT_NOF_REGS];

} __ATTRIBUTE_PACKED__ SOC_PB_EPNI_REGS;
/* Block definition: CFC */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in the CFC.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4600 */

     /* ObrxaLockErr: OOB-RX0 is not locked. Did not find a          */
     /* correct framing pattern.                                     */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrx_lock_err[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

     /* ObrxaOutOfFrm: OOB-RX0: Out-Of-Frame error counter is        */
     /* above OutOfFrmTh.                                            */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrx_out_of_frm[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

     /* ObrxaDip2Alarm: OOB-RX0: DIP2 error counter is above         */
     /* Dip2AlarmTh                                                  */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrx_dip2_alarm[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

     /* ObrxaFrmErr: OOB-RX0: Frame error occurred. If asserted,     */
     /* then FrmErrCnt0 holds the number of errors.                  */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrx_frm_err[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

     /* ObrxaDip2Err: OOB-RX0: DIP2 error detected. If asserted,     */
     /* then Dip2ErrCnt0 holds the number of errors.                 */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrx_dip2_err[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

     /* Ilkn0OobRxCrcErr: ILKN-RX0: CRC error received               */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_crc_err;

     /* Ilkn0OobRxOverflow: ILKN-RX0: Overflow error received        */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_overflow;

     /* Ilkn0OobRxIfStatErr: ILKN-RX0: Interface-Status error        */
     /* received                                                     */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_if_stat_err;

     /* Ilkn0OobRxLanesStatErr: ILKN-RX0: Lane-Status error          */
     /* received If asserted, Ilkn0RxLanesStatus holds map of        */
     /* the lanes errors                                             */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_lanes_stat_err;

     /* Ilkn1OobRxCrcErr: ILKN-RX1: CRC error received               */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_crc_err;

     /* Ilkn1OobRxOverflow: ILKN-RX1: Overflow error received        */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_overflow;

     /* Ilkn1OobRxIfStatErr: ILKN-RX1: Interface-Status error        */
     /* received                                                     */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_if_stat_err;

     /* Ilkn1OobRxLanesStatErr: ILKN-RX0: Lane-Status error          */
     /* received If asserted, Ilkn1RxLanesStatus holds map of        */
     /* the lanes errors                                             */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_lanes_stat_err;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4610 */

     /* ObrxaLockErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxa_lock_err_mask;

     /* ObrxbLockErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxb_lock_err_mask;

     /* ObrxaOutOfFrmMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxa_out_of_frm_mask;

     /* ObrxbOutOfFrmMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxb_out_of_frm_mask;

     /* ObrxaDip2AlarmMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxa_dip2_alarm_mask;

     /* ObrxbDip2AlarmMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxb_dip2_alarm_mask;

     /* ObrxaFrmErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxa_frm_err_mask;

     /* ObrxbFrmErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxb_frm_err_mask;

     /* ObrxaDip2ErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxa_dip2_err_mask;

     /* ObrxbDip2ErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxb_dip2_err_mask;

     /* Ilkn0OobRxCrcErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_crc_err_mask;

     /* Ilkn0OobRxOverflowMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_overflow_mask;

     /* Ilkn0OobOxIfStatErrMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn0_oob_ox_if_stat_err_mask;

     /* Ilkn0OobRxLaneStatErrMask: Writing 0 masks the               */
     /* corresponding interrupt source.                              */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_lane_stat_err_mask;

     /* Ilkn1OobRxCrcErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_crc_err_mask;

     /* Ilkn1OobRxOverflowMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_overflow_mask;

     /* Ilkn1OobOxIfStatErrMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn1_oob_ox_if_stat_err_mask;

     /* Ilkn1OobRxLaneStatErrMask: Writing 0 masks the               */
     /* corresponding interrupt source.                              */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_lane_stat_err_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4620 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg[SOC_PB_CFC_INDIRECT_COMMAND_WR_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4630 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg[SOC_PB_CFC_INDIRECT_COMMAND_RD_DATA_REG_MULT_NOF_REGS];

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4640 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets the     */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access                      */
  /* address. Defines which indirect object is accessed.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4641 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform. 0:          */
     /* Write operation 1: Read operation                            */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Indirect Command Data Increment:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4642 */

     /* IndirectCommandDataIncrement:                                */
     /* IndirectCommandWrData[31:0] is incremented by this value     */
     /* after every indirect write. Addition is cyclic.              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_data_increment;

  } __ATTRIBUTE_PACKED__ indirect_command_data_increment_reg[SOC_PB_CFC_INDIRECT_COMMAND_DATA_INCREMENT_REG_MULT_NOF_REGS];

  /* FC priority Fix                             */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x4652 */

    /* range: 0:0, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD sch_to_egq_priority_fc_fix_en;

    /* range: 1:1, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD ilkn_rx_to_egq_port_fc_fix_en;

  } __ATTRIBUTE_PACKED__ sch_to_egq_priority_fc_fix_en_reg;

  /* Cfc Enablers: CFC Enable bits                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4654 */

     /* CfcEn: CFC disabled prevents flow-control (present X-On)     */
     /* indications to all destinations. Note: In this state,        */
     /* the CFC does not present them to the destinations and        */
     /* mask all incoming flow control                               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfc_en;

     /* GlbRscToRclOfpHpCfg: Set High-Priority FC to recycle         */
     /* OFPs in the SCH/EGQ by the high-priority resource            */
     /* indication. 1'b0 - No FC is sent 1'b1 - FC is set for        */
     /* Low and High OFPs                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_rsc_to_rcl_ofp_hp_cfg;

     /* GlbRscToRclOfpLpCfg: Set Low-Priority FC to recycle OFPs     */
     /* in the SCH/EGQ by the low-priority resource indication.      */
     /* 1'b0 - FC is set for Low priority OFPs only 1'b1 - FC is     */
     /* set for Low and High priority OFPs                           */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_rsc_to_rcl_ofp_lp_cfg;

     /* GlbRscToSchRclHrEn: If set, enables FC on recycle            */
     /* aggregate HRs by the Global-Resource FC. FC to the           */
     /* Scheduler.                                                   */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_rsc_to_sch_rcl_hr_en;

     /* GlbRscToSchRclOfpEn: If set, enables FC on recycle OFPs      */
     /* by the Global-Resource FC. FC to the SCH.                    */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_rsc_to_sch_rcl_ofp_en;

     /* GlbRscToEgqRclOfpEn: If set, enables FC on recycle OFPs      */
     /* by the Global-Resource FC. FC to the EGQ.                    */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_rsc_to_egq_rcl_ofp_en;

     /* RclVsqToSchHrEn: If set, enables FC on aggregate HRs by      */
     /* the 32 Recycle classes VSQs (68->99). FC to the              */
     /* Scheduler.                                                   */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcl_vsq_to_sch_hr_en;

     /* OobRxToSchHrEn: If set, enables FC on the 128                */
     /* hierarchical HRs via the 128 OOB FC Scheduler-based          */
     /* indications. FC to the Scheduler.                            */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD oob_rx_to_sch_hr_en;

     /* OobRxToEgqEn: If set, enables FC of EGQ's OFP (outgoing      */
     /* FAP ports) via the 80 OOB FCs (OFP-based). FC to the         */
     /* EGQ.                                                         */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD oob_rx_to_egq_en;

     /* IlknRxToSchHrEn: If set, enables FC on 128 hierarchical      */
     /* HRs via the 128 OOB FC Scheduler-based indications. FC       */
     /* to the Scheduler.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx_to_sch_hr_en;

     /* IlknRxToEgqEn: If set, enables FC of EGQ's OFP (outgoing     */
     /* FAP ports) via the 80 OOB FCs (OFP-based). FC to the         */
     /* EGQ.                                                         */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx_to_egq_en;

     /* FrcNifLlvlEn: If set, all link-level NIF's FCs will be       */
     /* asserted when High-priority global resource FC is            */
     /* asserted. Otherwise, the NIF's link-level FC are not         */
     /* affected by the High-Priority global resources FC.           */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD frc_nif_llvl_en;

     /* FrcNifClsbEn: If set, all CLSB NIF's FCs will be             */
     /* asserted when High-priority global resource FC is            */
     /* asserted. Otherwise, the NIF's link-level FC are not         */
     /* affected by the High-Priority global resources FC.           */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD frc_nif_clsb_en;

     /* EgqToSchDeviceEn: If set, enables the Device FC from the     */
     /* EGQ to the Scheduler.                                        */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_to_sch_device_en;

     /* EgqToSchErpEn: If set, enables the Egress replication        */
     /* port FC from the EGQ to the Scheduler ERP-Port HR.           */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_to_sch_erp_en;

     /* EgqToSchChPortEn: If set, enables the channelized ports      */
     /* FC from the EGQ to the Scheduler Channelized Ports HRs.      */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_to_sch_ch_port_en;

     /* EgqToSchCpuPortEn: If set, enables the channelized CPU       */
     /* port FC from the EGQ to the Scheduler CPU-Port HR.           */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_to_sch_cpu_port_en;

     /* EgqToSchRclPortEn: If set, enables the channelized           */
     /* Recycling port FC from the EGQ to the Scheduler              */
     /* Recycle-Port HR.                                             */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_to_sch_rcl_port_en;

     /* EgqToSchOfpLpEn: If set, enables the high-priority OFP       */
     /* FC from the EGQ to the Scheduler Low-Priority OFP HRs.       */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_to_sch_ofp_lp_en;

     /* EgqToSchOfpHpEn: If set, enables the high-priority OFP       */
     /* FC from the EGQ to the Scheduler High-Priority OFP HRs.      */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_to_sch_ofp_hp_en;

     /* NifClsbVsqSrcSel: Selects the source for NIF's               */
     /* class-based FC. If set, selects VSQs 100->227                */
     /* (statistics-tag VSQs). This is the default setting.          */
     /* Otherwise, selects VSQs 36->99 (Q category 2/3 &             */
     /* connection-class). Note: If NifClsbVsqSrcSel iset set:       */
     /* Bit 0 set FC for class 0 and 1; bit 1 set FC for class 2     */
     /* and 3; ... Else: 64 LSBs are taken from VSQs 36-99 and       */
     /* 64 MSBs are zero.                                            */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nif_clsb_vsq_src_sel;

     /* OobRxToNifFastLlfcEn: If set, enables fast link-level FC     */
     /* received from SPI OOB and forwarded to NIF (stops NIF        */
     /* Tx).                                                         */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_rx_to_nif_fast_llfc_en;

     /* IlknRxToNifFastLlfcEn: If set, enables fast link-level       */
     /* FC received from ILKN and forwarded to NIF (stops NIF        */
     /* Tx).                                                         */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx_to_nif_fast_llfc_en;

  } __ATTRIBUTE_PACKED__ cfc_enablers_reg;

  /* Lp Glb Rsc To Nif Clsb Map: Low-priority global to NIF         */
  /* Class-based mapping.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4655 */

     /* LpGlbRscToNifClsbMap: The 128-bit bitmap that defines        */
     /* the class-based FCs presented to NIF that should be          */
     /* asserted when the Low-Priority global resource FC is         */
     /* asserted by the IQM.                                         */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD lp_glb_rsc_to_nif_clsb_map;

  } __ATTRIBUTE_PACKED__ lp_glb_rsc_to_nif_clsb_map_reg[SOC_PB_CFC_LP_GLB_RSC_TO_NIF_CLSB_MAP_REG_MULT_NOF_REGS];

  /* Glb Rsc To Rcl Ofp Hp Map: High-Priority OFPs linked to        */
  /* the recycle classes                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4659 */

     /* GlbRscToRclOfpHpMap: This register defines the 80-bit        */
     /* bitmap that defines the HP OFPs aggregates in the SCH        */
     /* that are assigned to recycle classes. This register          */
     /* includes bits 79:48 of the bitmap.                           */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD glb_rsc_to_rcl_ofp_hp_map;

  } __ATTRIBUTE_PACKED__ glb_rsc_to_rcl_ofp_hp_map_reg[SOC_PB_CFC_GLB_RSC_TO_RCL_OFP_HP_MAP_REG_MULT_NOF_REGS];

  /* Glb Rsc To Rcl Ofp Lp Map: Low-Priority OFPs linked to         */
  /* the recycle classes                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x465c */

     /* GlbRscToRclOfpLpMap: This register defines the 80-bit        */
     /* bitmap that defines the LP OFPs aggregates in the SCH        */
     /* that are assigned to recycle classes. This register          */
     /* includes bits 79:48 of the bitmap.                           */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD glb_rsc_to_rcl_ofp_lp_map;

  } __ATTRIBUTE_PACKED__ glb_rsc_to_rcl_ofp_lp_map_reg[SOC_PB_CFC_GLB_RSC_TO_RCL_OFP_LP_MAP_REG_MULT_NOF_REGS];

  /* Glb Rsc To Sch Rcl Hr Map: Low-Priority OFPs linked to         */
  /* the recycle classes                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x465f */

     /* GlbRscToSchRclHrMap: This register defines the 32-bit        */
     /* bitmap that defines the aggregates in the SCH that are       */
     /* assigned to recycle classes.                                 */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD glb_rsc_to_sch_rcl_hr_map;

  } __ATTRIBUTE_PACKED__ glb_rsc_to_sch_rcl_hr_map_reg;

  /* Ilkn Rx To Sch Hr Mask: ILKN to Scheduler HR FC                */
  /* indications mask                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4660 */

     /* IlknRxToSchHrMask: Masks Scheduler HR FC indications         */
     /* (from ILKN) 1 - enables FC indication 0 - mask out the       */
     /* FC indication                                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_to_sch_hr_mask;

  } __ATTRIBUTE_PACKED__ ilkn_rx_to_sch_hr_mask_reg[SOC_PB_CFC_ILKN_RX_TO_SCH_HR_MASK_REG_MULT_NOF_REGS];

  /* Oob Rx To Sch Hr Mask: SPI4 OOB to Scheduler HR FC             */
  /* indications mask                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4664 */

     /* OobRxToSchHrMask: Masks Scheduler HR FC indications          */
     /* (from OOB) 1 - enables FC indication 0 - mask out the FC     */
     /* indication                                                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_to_sch_hr_mask;

  } __ATTRIBUTE_PACKED__ oob_rx_to_sch_hr_mask_reg[SOC_PB_CFC_OOB_RX_TO_SCH_HR_MASK_REG_MULT_NOF_REGS];

  /* Nif Clsb To Sch Hr Mask: NIF to Scheduler HR FC                */
  /* indications mask                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4668 */

     /* NifClsbToSchHrMask: Masks Scheduler HR FC indications        */
     /* (from NIF-CLSB) 1 - enables FC indication 0 - mask out       */
     /* the FC indication                                            */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD nif_clsb_to_sch_hr_mask;

  } __ATTRIBUTE_PACKED__ nif_clsb_to_sch_hr_mask_reg[SOC_PB_CFC_NIF_CLSB_TO_SCH_HR_MASK_REG_MULT_NOF_REGS];

  /* Oob Pad Configuration: Out-Of-Band PAD Configuration           */
  /* register - ILKN and SPI4                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x466c */

     /* OobIntrfbSel: If set, then OOB interface B operates as       */
     /* status transmit. Otherwise, the interface operates as        */
     /* status receive.                                              */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD oob_intrfb_sel;

     /* OobRxARstn: Resets OOB interface A. Active low. Note:        */
     /* The interface should only be brought out of reset when a     */
     /* valid OOB clock is present.                                  */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD oob_rx_rstn[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

     /* OobModeA: Selects between ILKN and SPI4 on OOB interface     */
     /* A: 1'b1 - ILKN 1'b0 - SPI4                                   */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD oob_mode[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

     /* IlknOobTxRstn: Reset the ILKN-OOB TX interface               */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_oob_tx_rstn;

     /* IlknOobAPolarity: Set polarity for ILKN-OOB-RX FC            */
     /* indications of interface A. If unset than FC indications     */
     /* match Interlaken definition, otherwise FC indications        */
     /* are inverted. Note: Interlaken defines a value of 1 as       */
     /* XON, and a value of 0 as XOFF.                               */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_oob_polarity[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

     /* OobAPolarity: Set polarity for SPI4-OOB FC indications       */
     /* of interface A. If unset than FC indications match SPI4      */
     /* definition, otherwise FC indications are inverted. Note:     */
     /* SPI4 defines a value of 0 as XON, and a value of 1 as        */
     /* XOFF.                                                        */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD oob_polarity[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

     /* IlknOobIfStatPolarity: Set polarity for ILKN-OOB             */
     /* interface status indications of interface A. If unset        */
     /* than interface status indications match Interlaken           */
     /* definition, otherwise interface status indications are       */
     /* inverted. Note: Interlaken defines a value of 1 as           */
     /* healthy, and a value of 0 as unhealthy.                      */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_oob_if_stat_polarity;

     /* IlknOobLnStatPolarity: Set polarity for ILKN-OOB lanes       */
     /* status indications of interface B. If unset than lanes       */
     /* status indications match Interlaken definition,              */
     /* otherwise lanes status indications are inverted. Note:       */
     /* Interlaken defines a value of 1 as healthy, and a value      */
     /* of 0 as unhealthy.                                           */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_oob_ln_stat_polarity;

  } __ATTRIBUTE_PACKED__ oob_pad_configuration_reg;

  /* Ilkn0 Configuration: ILKN0 configurationNotes: * If OOB        */
  /* is selected, uses only interface A.* If InBand is              */
  /* selected, uses only ILKN-Port 0.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x466d */

     /* Ilkn0RxEn: If set, ILKN0 Flow-Control RX interface is        */
     /* enabled Note: * InBand/OOB according to Ilkn0RxSel           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx_en;

     /* Ilkn0TxEn: If set, ILKN0 Flow-Control TX interface is        */
     /* enabled Note: * If OOB is selected, TX is disabled           */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_tx_en;

     /* Ilkn0RxSel: Selects the source of ILKN0: 0 - ILKN            */
     /* In-Band 1 - ILKN OOB Note: If OOB is selected, uses only     */
     /* interface A.                                                 */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_rx_sel;

     /* Ilkn0TxSel: Selects the source of ILKN0: 0 - ILKN            */
     /* In-Band 1 - ILKN is disabled                                 */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_tx_sel;

     /* Ilkn0RxCalLen: ILKN0 RX calendar length minus 1 Notes: *     */
     /* Affects only on OOB flow control * Can be updated only       */
     /* when OobRxARstn is negated.                                  */
     /* range: 11:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn_rx_cal_len;

     /* Ilkn0TxCalLen: ILKN0 TX calendar length minus 1 Notes: *     */
     /* settings for OOB or in-band flow control.                    */
     /* range: 19:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_tx_cal_len;

     /* Ilkn0RxErrStatusSel: Select status indication when error     */
     /* (Status/ Interface) is recieved. Notes: * When unset XON     */
     /* status is sent, otherwise XOFF. * Indication are             */
     /* according ILKN definition and IlknOobAPolarity.              */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn_rx_err_status_sel;

  } __ATTRIBUTE_PACKED__ ilkn_configuration_reg[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

  /* Ilkn Oob Configuration: ILKN OOB configuration                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x466f */

     /* IlknOobRxLanesCfg: ILKN RX lanes config: 1'b0 - ILKN0        */
     /* LaneStatus indications are received from ILKN0 OOB           */
     /* interface and ILKN1 LaneStatus indications are received      */
     /* from ILKN1 OOB interface. 1'b1 - All LaneStatus              */
     /* indications are received from ILKN0 OOB interface.           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_oob_rx_lanes_cfg;

     /* IlknOobTxLanes: ILKN OOB TX number of lanes minus 1          */
     /* Note: * If Ilkn1TxSel is set, IlknOobTxLanes may be          */
     /* updated only when IlknOobTxRstn is negated.                  */
     /* range: 5:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_oob_tx_lanes;

     /* IlknOobTxLanesCfg: ILKN TX lanes config: 1'b0 - NIF          */
     /* LaneStatus indications bits [23:0] are used for the          */
     /* ILKN-OOB. Support in ILKN 24 / 2 ILKN 12 / 1 ILKN0 12.       */
     /* 1'b1 - NIF LaneStatus indications bits [23:12] are used      */
     /* for ILKN-OOB. Support in 1 ILKN1 12. Note: Number of         */
     /* lanes that are presented on the OOB interface are set by     */
     /* IlknOobTxLanes.                                              */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn_oob_tx_lanes_cfg;

  } __ATTRIBUTE_PACKED__ ilkn_oob_configuration_reg;

  /* Ilkn Oob Tx Mask: Mask ILKN TX lanes and interface             */
  /* status indication                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4670 */

     /* IlknOobTxLanesMask: Mask 24 bits of lanes status             */
     /* indication sent by the ILKN OOB interface. 1'b0 - Lane       */
     /* is masked 1'b1 - Lane is not masked                          */
     /* range: 23:0, access type: RW, default value: 24'hffffff      */
     SOC_PETRA_REG_FIELD ilkn_oob_tx_lanes_mask;

     /* IlknOobTxIntf0Mask: Mask interface status indication of      */
     /* RX-ILKN0 sent by the ILKN OOB interface. 1'b0 -              */
     /* Interface is masked 1'b1 - Interface is not masked           */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ilkn_oob_tx_intf0_mask;

     /* IlknOobTxIntf1Mask: Mask interface status indication of      */
     /* RX-ILKN1 sent by the ILKN OOB interface. 1'b0 -              */
     /* Interface is masked 1'b1 - Interface is not masked           */
     /* range: 25:25, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ilkn_oob_tx_intf1_mask;

  } __ATTRIBUTE_PACKED__ ilkn_oob_tx_mask_reg;

  /* Ilkn Oob Tx Force: Force ILKN TX lanes and interface           */
  /* status indication                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4671 */

     /* FrcIlknOobTxLanes: Force 24 bits of lanes status             */
     /* indication sent by the ILKN OOB interface. 1'b0 - Lane       */
     /* is not forced up 1'b1 - Lane is forced up Note: * Unused     */
     /* lanes should be forced up                                    */
     /* range: 23:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_ilkn_oob_tx_lanes;

     /* FrcIlknOobTxIntf0: Force interface status indication of      */
     /* RX-ILKN0 sent by the ILKN OOB interface. 1'b0 -              */
     /* Interface is not forced up 1'b1 - Interface is forced up     */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD frc_ilkn_oob_tx_intf0;

     /* FrcIlknOobTxIntf1: Force interface status indication of      */
     /* RX-ILKN1 sent by the ILKN OOB interface. 1'b0 -              */
     /* Interface is not forced up 1'b1 - Interface is forced up     */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD frc_ilkn_oob_tx_intf1;

  } __ATTRIBUTE_PACKED__ ilkn_oob_tx_force_reg;

  /* Ilkn0 Oob Rx Crc Err Cnt: ILKN0 RX CRC error counter           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4672 */

     /* Ilkn0OobRxCrcErrCnt: ILKN0 OOB RX CRC error counter This     */
     /* register is clear on read.                                   */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_crc_err_cnt;

     /* Ilkn0OobRxCrcErrCntOvf: ILKN0 OOB RX CRC error counter       */
     /* overflow                                                     */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_crc_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ ilkn0_oob_rx_crc_err_cnt_reg;

  /* Ilkn1 Oob Rx Crc Err Cnt: ILKN1 RX lane status                 */
  /* indication                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4673 */

     /* Ilkn1OobRxCrcErrCnt: ILKN1 OOB RX CRC error counter This     */
     /* register is clear on read.                                   */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_crc_err_cnt;

     /* Ilkn1OobRxCrcErrCntOvf: ILKN1 OOB RX CRC error counter       */
     /* overflow                                                     */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_crc_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ ilkn1_oob_rx_crc_err_cnt_reg;

  /* Ilkn0 Oob Rx Lanes Status: ILKN0 RX lane status                */
  /* indication                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4674 */

     /* Ilkn0OobRxLanesStatus: Lanes status indication received      */
     /* by the ILKN0 OOB interface. This register is clear on        */
     /* read. This register is clear on read.                        */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_lanes_status;

  } __ATTRIBUTE_PACKED__ ilkn0_oob_rx_lanes_status_reg;

  /* Ilkn1 Oob Rx Lanes Status: ILKN1 RX lane status                */
  /* indication                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4675 */

     /* Ilkn1OobRxLanesStatus: Lanes status indication received      */
     /* by the ILKN1 OOB interface. This register is clear on        */
     /* read. This register is clear on read.                        */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_lanes_status;

  } __ATTRIBUTE_PACKED__ ilkn1_oob_rx_lanes_status_reg;

  /* Ilkn Oob Rx Fc Status Sel: Select 32 indications to be         */
  /* presented in ILKN-OOB-RX stutus registers.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4676 */

     /* Ilkn0OobRxFcStatusSel: Select 32 of 256 out of band FC       */
     /* indications to be presented in Ilkn0OobRxFcStatus            */
     /* register. 0 - indications 0-31 1 - indications 32-63 2 -     */
     /* indications 64-95, ...                                         */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_fc_status_sel;

     /* Ilkn1OobRxFcStatusSel: Select 32 of 256 out of band FC       */
     /* indications to be presented in Ilkn1OobRxFcStatus            */
     /* register. 0 - indications 0-31 1 - indications 32-63 2 -     */
     /* indications 64-95, ...                                         */
     /* range: 5:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_fc_status_sel;

     /* Ilkn0IbRxFcStatusSel: Select 32 of 256 inband FC             */
     /* indications to be presented in Ilkn0IbRxFcStatus             */
     /* register. 0 - indications 0-31 1 - indications 32-63 2 -     */
     /* indications 64-95, ...                                         */
     /* range: 8:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ilkn0_ib_rx_fc_status_sel;

     /* Ilkn1IbRxFcStatusSel: Select 32 of 256 inband FC             */
     /* indications to be presented in Ilkn1IbRxFcStatus             */
     /* register. 0 - indications 0-31 1 - indications 32-63 2 -     */
     /* indications 64-95, ...                                         */
     /* range: 11:9, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn1_ib_rx_fc_status_sel;
  } __ATTRIBUTE_PACKED__ ilkn_oob_rx_fc_status_sel_reg;

  /* Ilkn0 Oob Rx Fc Status: ILKN0 OOB RX FC status                 */
  /* indication                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4677 */

     /* Ilkn0OobRxFcStatus: Flow control status indications          */
     /* received by the ILKN0 OOB interface. (Sticky bits).          */
     /* Note: The 32 indications presented are set by                */
     /* Ilkn0OobRxFcStatus field in IlknOobRxFcStatusSel             */
     /* register. This register is clear on read. This register      */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn0_oob_rx_fc_status;

  } __ATTRIBUTE_PACKED__ ilkn0_oob_rx_fc_status_reg;

  /* Ilkn1 Oob Rx Fc Status: ILKN1 OOB RX FC status                 */
  /* indication                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4678 */

     /* Ilkn1OobRxFcStatus: Flow control status indications          */
     /* received by the ILKN1 OOB interface. (Sticky bits) Note:     */
     /* The 32 indications presented are set by                      */
     /* Ilkn1OobRxFcStatus field in IlknOobRxFcStatusSel             */
     /* register. This register is clear on read. This register      */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn1_oob_rx_fc_status;

  } __ATTRIBUTE_PACKED__ ilkn1_oob_rx_fc_status_reg;

  /* Ilkn0 Ib Rx Fc Status: ILKN0 InBand RX FC status               */
  /* indication                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4679 */

     /* Ilkn0IbRxFcStatus: Flow control status indications           */
     /* received by the ILKN0 InBand interface. (Sticky bits).       */
     /* Note: The 32 indications presented are set by                */
     /* IlknIbRxFcStatus field in IlknIbRxFcStatusSel register.      */
     /* This register is clear on read. This register is clear       */
     /* on read.                                                     */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn0_ib_rx_fc_status;

  } __ATTRIBUTE_PACKED__ ilkn0_ib_rx_fc_status_reg;

  /* Ilkn1 Ib Rx Fc Status: ILKN1 InBand RX FC status               */
  /* indication                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x467a */

     /* Ilkn1IbRxFcStatus: Flow control status indications           */
     /* received by the ILKN1 InBand interface. (Sticky bits)        */
     /* Note: The 32 indications presented are set by                */
     /* Ilkn1IbRxFcStatus field in IlknIbRxFcStatusSel register.     */
     /* This register is clear on read. This register is clear       */
     /* on read.                                                     */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ilkn1_ib_rx_fc_status;

  } __ATTRIBUTE_PACKED__ ilkn1_ib_rx_fc_status_reg;

  /* Out Of Band Tx Configuration0: SPI4 Out-of-band transmit       */
  /* interface settings.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x467b */

     /* TxCalLen: Status transmit (OOB) calendar length. Defines     */
     /* the number of OOB-tx channels in a single calendar.          */
     /* (Maximum calendar length: 512 channels)                      */
     /* range: 9:0, access type: RW, default value: 0x200            */
     SOC_PETRA_REG_FIELD tx_cal_len;

     /* TxCalM: Status transmit (OOB) calendar-M. The number of      */
     /* calendar repetitions within a status frame. Total status     */
     /* frame length: TxCalLen X TxCalM + 2                          */
     /* range: 15:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tx_cal_m;

     /* OobTxEn: Out-Of-Band flow control transmit interface         */
     /* enable.                                                      */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_tx_en;

  } __ATTRIBUTE_PACKED__ out_of_band_tx_configuration0_reg;

  /* Out Of Band Tx Configuration1: SPI4 Out-of-band transmit       */
  /* interface settings.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x467c */

     /* OutStatPhaseSel: Defines the Transmit Stat clock edge        */
     /* where rstat_out[1:0] (fc-status) should change its           */
     /* value. If set, rstat_out[1:0] changes at falling edge of      */
     /* Stat-Out Clk otherwise, rstat_out[1:0] changes at rising     */
     /* edge of Stat-Out Clk.                                        */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD out_stat_phase_sel;

     /* OutStatSpeed: Define the OBTX clock speed. If set then       */
     /* Oob-Tx clock will be 62.5MHz; else 125MHz.                   */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD out_stat_speed;

  } __ATTRIBUTE_PACKED__ out_of_band_tx_configuration1_reg;

  /* Out Of Band Rx0 Configuration0: SPI4 Out-of-band receive       */
  /* interface-A settings.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x467d */

     /* RxCalLen: Status receive A (OOBrx-A) calendar length.        */
     /* Defines the number of OOB-rx channels in a single            */
     /* calendar. (Maximum calendar length: 512 channels)            */
     /* range: 9:0, access type: RW, default value: 0x200            */
     SOC_PETRA_REG_FIELD rx_cal_len;

     /* RxCalM: Status receive A (OOBrx-A) calendar-M. The           */
     /* number of calendar repetitions within a status frame.        */
     /* Total status frame length: RxCalLen X RxCalM + 2             */
     /* range: 15:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_cal_m;

     /* OobRxEn: Out-Of-Band flow-control receive interface-A        */
     /* enable.                                                      */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_rx_en;

     /* OobRxLbEn: Enables leaky-bucket algorithm for measuring      */
     /* the error rate by LB1 and LB2. If set, then LB1 and LB2       */
     /* are decremented whenever DIP2GoodToBadRatio error free       */
     /* frames are received. If 0, then LB1 and LB2 are reset to     */
     /* 0 when DIP2GoodToBadRatio error free frames are              */
     /* received.                                                    */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_rx_lb_en;

     /* OofrmStsSel: If set, then when OOB is in out-of-frame        */
     /* state, it presents flow-control 'on' indication to CFC       */
     /* core (2'b10). Else, then when in out-of-frame, a             */
     /* flow-control 'off' is presented (2'b00).                     */
     /* range: 18:18, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD oofrm_sts_sel;

     /* InStatPhaseSel: Determine the phase selection to sample      */
     /* the incoming Stat[1:0]. If set, then Stat is sampled on       */
     /* the fc_clk rising edge. Otherwise, Stat is sampled on        */
     /* the fc_clk falling edge.                                     */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD in_stat_phase_sel;

  } __ATTRIBUTE_PACKED__ out_of_band_rx_configuration_reg[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

  /* Out Of Band Rx0 Threshold Configuration0: SPI4                 */
  /* Out-of-band receive interface-A settings.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x467e */

     /* Dip2Good2BadRatio: Number of error-free frames received      */
     /* that either clear or decrement LB1 and LB2 (according to     */
     /* the value of OobRxLbEn). A value of 0 causes any             */
     /* error-free frame to clear the leaky buckets, regardless      */
     /* of the value of OobRxLbEn.                                   */
     /* range: 7:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD dip2_good2_bad_ratio;

     /* MaxFrmPattrn: Number of consecutive framing patterns         */
     /* received on TSTAT before declaring out-of-frame state.       */
     /* range: 15:8, access type: RW, default value: 0x3             */
     SOC_PETRA_REG_FIELD max_frm_pattrn;

     /* InFrmTh: Number of consecutive error-free frames that        */
     /* place the OOB-rx status path into the in-frame state         */
     /* range: 23:16, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD in_frm_th;

     /* OutOfFrmTh: Level of LB1 that forces the OOB-rx path to      */
     /* enter out-of-frame state.                                    */
     /* range: 31:24, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD out_of_frm_th;

  } __ATTRIBUTE_PACKED__ out_of_band_rx_threshold_configuration0_reg[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

  /* Out Of Band Rx0 Threshold Configuration1: SPI4                 */
  /* Out-Of-band receive-interface-A settings.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x467f */

     /* Dip2AlrmTh: Level of LB2 that forces the OOB-rx path to      */
     /* declare a DIP-alarm. This state is indicated to the data     */
     /* source.                                                      */
     /* range: 7:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD dip2_alrm_th;

  } __ATTRIBUTE_PACKED__ out_of_band_rx_threshold_configuration1_reg[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

  /* Oob Rx0 Error Counter: SPI4 Out-Of-band                        */
  /* receive-interface-A status.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4683 */

     /* FrmErrCnt: Number of framing errors. Frame Error defined     */
     /* when the OOB-rx fails to synchronize on the frame's          */
     /* sync. This register is clear on read.                        */
     /* range: 6:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD frm_err_cnt;

     /* FrmErrCntOvf: FrnErrCnt overflow.                            */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD frm_err_cnt_ovf;

     /* Dip2ErrCnt: Number of Dip2 errors detected.                  */
     /* range: 14:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD dip2_err_cnt;

     /* Dip2ErrCntOvf: Dip2ErrCnt overflow.                          */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD dip2_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ oob_rx_error_counter_reg[SOC_PB_REG_BLK_NOF_INSTANCES_OOB];

  /* Force Scheduler Flow Control: Force -Scheduler's flow          */
  /* controls by CPU.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4685 */

     /* FrcSchDevFc: If set, forces the device flow control          */
     /* presented to the SCH.                                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_sch_dev_fc;

     /* FrcSchErpFc: If set, forces the ERP                          */
     /* (egress-replication-port) flow control presented to the      */
     /* SCH.                                                         */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_sch_erp_fc;

     /* FrcSchChnPortFc: Enables forcing of the eight                */
     /* channelized ports flow control presented to the SCH.         */
     /* range: 17:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_sch_chn_port_fc;

     /* FrcSchCpuPortFc: Enables forcing of the CPU port flow        */
     /* control presented to the SCH.                                */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD frc_sch_cpu_port_fc;

     /* FrcSchRclPortFc: Enables forcing of the Recycle port         */
     /* flow control presented to the SCH.                           */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD frc_sch_rcl_port_fc;

  } __ATTRIBUTE_PACKED__ force_scheduler_flow_control_reg;

  /* Frc Sch Hr Fc: Force Scheduler's flow controls by CPU.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4686 */

     /* FrcSchHrFc: This bitmap forces general HR flow-control       */
     /* signals presented to the EGQ.                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_sch_hr_fc;

  } __ATTRIBUTE_PACKED__ frc_sch_hr_fc_reg[SOC_PB_CFC_FRC_SCH_HR_FC_REG_MULT_NOF_REGS];

  /* Frc Sch Ofp Hr Fc: Forces Scheduler's OFP HR flow              */
  /* controls by CPU.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4687 */

     /* FrcSchOfpHrFc: This bitmap forces the flow-control           */
     /* signals presented to the SCH OFP HRs.                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_sch_ofp_hr_fc;

  } __ATTRIBUTE_PACKED__ frc_sch_ofp_hr_fc_reg[SOC_PB_CFC_FRC_SCH_OFP_HR_FC_REG_MULT_NOF_REGS];

  /* Frc Egq Ofp Fc: Forces EGQ's flow controls by CPU.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x468d */

     /* FrcEgqOfpFc: This bitmap forces the flow-control signals     */
     /* presented to the EGQ                                         */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_egq_ofp_fc;

  } __ATTRIBUTE_PACKED__ frc_egq_ofp_fc_reg[SOC_PB_CFC_FRC_EGQ_OFP_FC_REG_MULT_NOF_REGS];

  /* Frc Nif Lnk Fc: Forces NIF flow controls by CPU.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4690 */

     /* FrcNifLnkFc: This bitmap forces the link-level               */
     /* flow-control signals presented to NIF.                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_nif_lnk_fc;

  } __ATTRIBUTE_PACKED__ frc_nif_lnk_fc_reg[SOC_PB_CFC_FRC_NIF_LNK_FC_REG_MULT_NOF_REGS];

  /* Frc Nif Clsb Fc: Forces NIF flow controls by CPU.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4692 */

     /* FrcNifClsbFc: This bitmap forces the class-based             */
     /* flow-control signals presented to NIF.                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_nif_clsb_fc;

  } __ATTRIBUTE_PACKED__ frc_nif_clsb_fc_reg[SOC_PB_CFC_FRC_NIF_CLSB_FC_REG_MULT_NOF_REGS];

  /* Frc Nif Fast Llfc: Forces fast link-level flow controls        */
  /* presented to the NIFs, by the CPU.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4696 */

     /* FrcNifFastLlfc: This bitmap forces the Link-level            */
     /* flow-control signals received by the OOB (SPI/ILKN) and      */
     /* presented to NIF.                                            */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_nif_fast_llfc;

  } __ATTRIBUTE_PACKED__ frc_nif_fast_llfc_reg[SOC_PB_CFC_FRC_NIF_FAST_LLFC_REG_MULT_NOF_REGS];

  /* Egq Fc Status: Flow control status indications received        */
  /* by the EGQ interface.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4698 */

     /* EgqDevFc: Device flow control status indications             */
     /* received by the EGQ interface. (Sticky bit) This             */
     /* register is clear on read.                                   */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_dev_fc;

     /* EgqErpFc: ERP flow control status indications received       */
     /* by the EGQ interface. (Sticky bit) This register is          */
     /* clear on read.                                               */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_erp_fc;

     /* EgqChnPortFc: NIF channalized ports flow control status      */
     /* indications received by the EGQ interface. (Sticky bit)      */
     /* This register is clear on read.                              */
     /* range: 17:2, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD egq_chn_port_fc;

     /* EgqCpuPortFc: CPU port flow control status indications       */
     /* received by the EGQ interface. (Sticky bit) This             */
     /* register is clear on read.                                   */
     /* range: 18:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_cpu_port_fc;

     /* EgqRclPortFc: Recycle port flow control status               */
     /* indications received by the EGQ interface. (Sticky bit)      */
     /* This register is clear on read.                              */
     /* range: 19:19, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_rcl_port_fc;

  } __ATTRIBUTE_PACKED__ egq_fc_status_reg;

  /* Egq Fc Sel: Select the ports to present out of the EGQ's       */
  /* received flow controls (Status).                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4699 */

     /* EgqOfpFcSel: Select the ports to present out of the          */
     /* EGQ's received OFP flow controls. 0 - select OFP 0 to 31     */
     /* of the low priority FC indications. 1 - select OFP 32 to     */
     /* 63 of the low priority FC indications. 2 - select OFP 64     */
     /* to 79 of the low priority FC indications. 3 - select OFP     */
     /* 0 to 31 of the low priority FC indications. 4 - select       */
     /* OFP 32 to 63 of the low priority FC indications. 5 -         */
     /* select OFP 64 to 79 of the low priority FC indications.      */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_ofp_fc_sel;

     /* EgqLlFcSel: Select the links to present out of the EGQ's     */
     /* received link level flow controls. 0 - select OFP 0 to       */
     /* 31 of the low priority FC indications. 1 - select OFP 32     */
     /* to 63 of the low priority FC indications.                    */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_ll_fc_sel;

     /* EgqClsbFcSel: Select the class base index to present out     */
     /* of the EGQ's received link level flow controls. 0 -          */
     /* select indexes 0 to 31. 1 - select indexes 32 to 63. 2 -     */
     /* select indexes 64 to 95. 3 - select indexes 96 to 127.       */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_clsb_fc_sel;

  } __ATTRIBUTE_PACKED__ egq_fc_sel_reg;

  /* Egq Ofp Fc: EGQ's received OFP flow controls (Status).         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x469a */

     /* EgqOfpFc: OFP flow control status indications received       */
     /* by the EGQ interface. (Sticky bit) Note: The 32              */
     /* indications presented are set by EgqOfpFcSel field in        */
     /* EgqFcSel register. This register is clear on read. This      */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD egq_ofp_fc;

  } __ATTRIBUTE_PACKED__ egq_ofp_fc_reg;

  /* Egq Ll Fc: EGQ's received link level flow controls             */
  /* (Status).                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x469b */

     /* EgqLlFc: Link level flow control status indications          */
     /* received by the EGQ interface. (Sticky bit) Note: The 32     */
     /* indications presented are set by EgqOfpFcSel field in        */
     /* EgqFcSel register. This register is clear on read. This      */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD egq_ll_fc;

  } __ATTRIBUTE_PACKED__ egq_ll_fc_reg;

  /* Egq Clsb Fc: EGQ's received link level flow controls           */
  /* (Status).                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x469c */

     /* EgqClsbFc: Class based flow control status indications       */
     /* received by the EGQ interface. (Sticky bit) Note: The 32     */
     /* indications presented are set by EgqOfpFcSel field in        */
     /* EgqFcSel register. This register is clear on read. This      */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD egq_clsb_fc;

  } __ATTRIBUTE_PACKED__ egq_clsb_fc_reg;

  /* Nif Fc Sel: Select the ports to be presented out of the        */
  /* NIF's received flow controls (Status).                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x469d */

     /* NifAfFcSel: Select the links to present out of the NIF's     */
     /* AF indications received flow controls (Status). 0 -          */
     /* select links 0 to 31 of the FC indications. 1 - select       */
     /* links 32 to 63 of the FC indications.                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nif_af_fc_sel;

     /* NifClsbFcSel: Select the links to present out of the         */
     /* NIF's CLSB indications received flow controls (Status):      */
     /* 0 - select indexes 0 to 31. 1 - select indexes 32 to 63.     */
     /* 2 - select indexes 64 to 95. 3 - select indexes 96 to        */
     /* 127.                                                         */
     /* range: 2:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nif_clsb_fc_sel;

  } __ATTRIBUTE_PACKED__ nif_fc_sel_reg;

  /* Nif Af Fc: Present the NIF's received flow controls            */
  /* (Status).                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x469e */

     /* NifAfFc: Almost full status indications received by the      */
     /* NIF interface. (Sticky bit) Note: Links presented are        */
     /* set by NifAfFcSel field. This register is clear on read.     */
     /* This register is clear on read.                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD nif_af_fc;

  } __ATTRIBUTE_PACKED__ nif_af_fc_reg;

  /* Nif Clsb Fc: Present the NIF's received flow controls          */
  /* (Status).                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x469f */

     /* NifClsbFc: Class base flow control status indications        */
     /* received by the NIF interface. (Sticky bit) Note: Links      */
     /* presented are set by NifClsbFcSel field. This register       */
     /* is clear on read. This register is clear on read.            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD nif_clsb_fc;

  } __ATTRIBUTE_PACKED__ nif_clsb_fc_reg;

  /* Obrx Fc Sel: Select the flow control indications to be         */
  /* presented out of the SPI4-OOB-RX received flow controls        */
  /* (Status).                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x46a0 */

     /* ObrxaSchbFcSel: Select the scheduler based flow control      */
     /* indications to be presented out of the SPI4-OOB-RX           */
     /* received flow controls (Status): 0 - select indexes 0 to     */
     /* 31 1 - select indexes 32 to 63 2 - select indexes 64 to      */
     /* 95 3 - select indexes 96 to 127                              */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxa_schb_fc_sel;

     /* ObrxaOfpFcSel: Select the OFP flow control indications       */
     /* to be presented out of the SPI4-OOB-RX received flow         */
     /* controls (Status). 0 - select OFPs 0 to 31 of the low        */
     /* priority FC indications. 1 - select OFPs 32 to 63 of the     */
     /* low priority FC indications. 2 - select OFPs 64 to 79 of     */
     /* the low priority FC indications. 3 - select OFPs 0 to 31     */
     /* of the low priority FC indications. 4 - select OFPs 32       */
     /* to 63 of the low priority FC indications. 5 - select         */
     /* OFPs 64 to 79 of the low priority FC indications.            */
     /* range: 4:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxa_ofp_fc_sel;

     /* ObrxaNifFcSel: Select the NIF link flow control              */
     /* indications to be presented out of the SPI4-OOB-RX           */
     /* received flow controls (Status). 0 - select links 0 to       */
     /* 31. 1 - select links 32 to 63.                               */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxa_nif_fc_sel;

     /* ObrxbSchbFcSel: Select the scheduler based flow control      */
     /* indications to be presented out of the SPI4-OOB-RX           */
     /* received flow controls (Status): 0 - select indexes 0 to     */
     /* 31 1 - select indexes 32 to 63 2 - select indexes 64 to      */
     /* 95 3 - select indexes 96 to 127                              */
     /* range: 7:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrxb_schb_fc_sel;

     /* ObrxbOfpFcSel: Select the OFP flow control indications       */
     /* to be presented out of the SPI4-OOB-RX received flow         */
     /* controls (Status). 0 - select OFPs 0 to 31 of the low        */
     /* priority FC indications. 1 - select OFPs 32 to 63 of the     */
     /* low priority FC indications. 2 - select OFPs 64 to 79 of     */
     /* the low priority FC indications. 3 - select OFPs 0 to 31     */
     /* of the low priority FC indications. 4 - select OFPs 32       */
     /* to 63 of the low priority FC indications. 5 - select         */
     /* OFPs 64 to 79 of the low priority FC indications.            */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrxb_ofp_fc_sel;

     /* ObrxbNifFcSel: Select the NIF link flow control              */
     /* indications to be presented out of the SPI4-OOB-RX           */
     /* received flow controls (Status). 0 - select links 0 to       */
     /* 31. 1 - select links 32 to 63.                               */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD obrxb_nif_fc_sel;

  } __ATTRIBUTE_PACKED__ obrx_fc_sel_reg;

  /* Obrxa Schb Fc: Presents flow controls received on the          */
  /* SPI4 OOB-interface.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x46a1 */

     /* ObrxaSchbFc: Scheduler-based flow control status             */
     /* indications received by the SPI4 Out-Of-Band interface.      */
     /* (Sticky bit). This status accumulates FCs from both          */
     /* OOB-RX interfaces. Note: Flow controls presented are set     */
     /* by NifAfFcSel field. This register is clear on read.         */
     /* This register is clear on read.                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrxa_schb_fc;

  } __ATTRIBUTE_PACKED__ obrxa_schb_fc_reg;

  /* Obrxa Ofp Fc: Presents flow controls received on the           */
  /* SPI4 OOB-interface.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x46a2 */

     /* ObrxaOfpFc: OFP-based (outgoing fap port) received           */
     /* flow-controls from the SPI4 Out-Of-Band interfaces. This     */
     /* status accumulates FCs from both OOB-RX interfaces.          */
     /* Note: Flow controls presented are set by NifAfFcSel          */
     /* field. This register is clear on read. This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrxa_ofp_fc;

  } __ATTRIBUTE_PACKED__ obrxa_ofp_fc_reg;

  /* Obrxa Nif Fc: Presents flow controls received on the           */
  /* SPI4 OOB-interface.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x46a3 */

     /* ObrxaNifFc: OFP-based (outgoing fap port) received           */
     /* flow-controls from the SPI4 Out-Of-Band interfaces. This     */
     /* status accumulates FCs from both OOB-RX interfaces.          */
     /* Note: Flow controls presented are set by ObrxNifFcSel        */
     /* field. This register is clear on read. This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrxa_nif_fc;

  } __ATTRIBUTE_PACKED__ obrxa_nif_fc_reg;

  /* Obrxb Schb Fc: Presents flow controls received on the          */
  /* SPI4 OOB-interface.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x46a4 */

     /* ObrxbSchbFc: Scheduler-based flow control status             */
     /* indications received by the SPI4 Out-Of-Band interface.      */
     /* (Sticky bit). This status accumulates FCs from both          */
     /* OOB-RX interfaces. Note: Flow controls presented are set     */
     /* by NifAfFcSel field. This register is clear on read.         */
     /* This register is clear on read.                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrxb_schb_fc;

  } __ATTRIBUTE_PACKED__ obrxb_schb_fc_reg;

  /* Obrxb Ofp Fc: Presents flow controls received on the           */
  /* SPI4 OOB-interface.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x46a5 */

     /* ObrxbOfpFc: OFP-based (outgoing fap port) received           */
     /* flow-controls from the SPI4 Out-Of-Band interfaces. This     */
     /* status accumulates FCs from both OOB-RX interfaces.          */
     /* Note: Flow controls presented are set by NifAfFcSel          */
     /* field. This register is clear on read. This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrxb_ofp_fc;

  } __ATTRIBUTE_PACKED__ obrxb_ofp_fc_reg;

  /* Obrxb Nif Fc: Presents flow controls received on the           */
  /* SPI4 OOB-interface.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x46a6 */

     /* ObrxbNifFc: OFP-based (outgoing fap port) received           */
     /* flow-controls from the SPI4 Out-Of-Band interfaces. This     */
     /* status accumulates FCs from both OOB-RX interfaces.          */
     /* Note: Flow controls presented are set by ObrxNifFcSel        */
     /* field. This register is clear on read. This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrxb_nif_fc;

  } __ATTRIBUTE_PACKED__ obrxb_nif_fc_reg;

  /* Iqm Glbl Fc Status: Presents Global flow controls              */
  /* received from the IQM (STE).                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x46a7 */

     /* FrBdbFcLp: IQM's free-BDB low-priority flow control.         */
     /* This register is clear on read. This register is clear       */
     /* on read.                                                     */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_bdb_fc_lp;

     /* FrBdbFcHp: IQM's free-BDB high-priority flow control.        */
     /* This register is clear on read.                              */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_bdb_fc_hp;

     /* FrUcDbFcLp: IQM's free-unicast dbuffs low-priority flow      */
     /* control. This register is clear on read.                     */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_uc_db_fc_lp;

     /* FrUcDbFcHp: IQM's free-unicast dbuffs high-priority flow     */
     /* control. This register is clear on read.                     */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_uc_db_fc_hp;

     /* FrFlMcDbFcLp: IQM's free-full-multicast dbuffs               */
     /* low-priority flow control. This register is clear on         */
     /* read.                                                        */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_fl_mc_db_fc_lp;

     /* FrFlMcDbFcHp: IQM's free-full-multicast dbuffs               */
     /* high-priority flow control. This register is clear on        */
     /* read.                                                        */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_fl_mc_db_fc_hp;

  } __ATTRIBUTE_PACKED__ iqm_glbl_fc_status_reg;

  /* Iqm Vsq Fc Status Sel: Select the flow control                 */
  /* indications to be presented out of the VSQs received           */
  /* flow controls (Status).                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x46a8 */

     /* IqmVsqFcStatusSel: Select the flow control indications       */
     /* to be presented out of the VSQs received flow controls       */
     /* (Status): 0 - select VSQs 0 to 3 (VSQ-A) 1 - select VSQs     */
     /* 4 to 35 (VSQ-B) 2 - select VSQs 36 to 67 (VSQ-C) 3 -         */
     /* select VSQs 68 to 99 (VSQ-C) 4 - select VSQs 100 to 131      */
     /* (VSQ-D) 5 - select VSQs 132 to 163 (VSQ-D) 6 - select        */
     /* VSQs 164 to 195 (VSQ-D) 7 - select VSQs 196 to 227           */
     /* (VSQ-D) 8 - select VSQs 228 to 259 (VSQ-D) 9 - select        */
     /* VSQs 260 to 291 (VSQ-D) 10 - select VSQs 292 to 323          */
     /* (VSQ-D) 11 - select VSQs 324 to 355 (VSQ-D)                  */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD iqm_vsq_fc_status_sel;

  } __ATTRIBUTE_PACKED__ iqm_vsq_fc_status_sel_reg;

  /* Iqm Vsq Fc Status: Presents VSQs flow controls received        */
  /* from the IQM (STE).                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x46a9 */

     /* VsqFc: Present 32 of the 356 flow controls generated by      */
     /* the IQM-VSQ (STE). Sticky bits. Note: Flow controls          */
     /* presented are set by qmVsqFcStatusSel field. This            */
     /* register is clear on read. This register is clear on         */
     /* read.                                                        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsq_fc;

  } __ATTRIBUTE_PACKED__ iqm_vsq_fc_status_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_CFC_REGS;
/* Block definition: SCH */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit. The interrupts indicated        */
  /* by CL are cleared when writing 1 to the relevant bit           */
  /* position in this register.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4200 */

     /* SmpBadMsg: Indication that bad message was sent to the       */
     /* scheduler, in order to check what was the bad message        */
     /* and clear this bit do the following: verify that bit[28]     */
     /* of register 0x4307 is set to 1. Read register 0x4265         */
     /* Read register 0x4264                                         */
     /* range: 0:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD smp_bad_msg;

     /* ActFlow BadParams: Interrupt source mirror. In order to      */
     /* check which flow is badly configured in the scheduler        */
     /* and to clear this bit read register 0x4268.                  */
     /* range: 2:2, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD act_flow_bad_params;

     /* ShpFlow BadParams: In order to check which flow is badly     */
     /* configured in the shaper and to clear this bit read          */
     /* register 0x4269.                                             */
     /* range: 3:3, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD shp_flow_bad_params;

     /* RestartFlowEvent: In order to get the flow number that       */
     /* was restarted and to clear this bit read register            */
     /* 0x426a.                                                      */
     /* range: 4:4, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD restart_flow_event;

     /* SMPFullLevel1: SMP FIFO in pipe reached level1.              */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpfull_level1;

     /* SMPFullLevel2: SMP FIFO in pipe reached level2.              */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpfull_level2;

     /* FCTFIFOOvf: The fifo towards the FCT is full                 */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fctfifoovf;

     /* EccErrorFixed: indication the one ECC error occurred on      */
     /* one of the memories that contain ECC - the error was         */
     /* fixed. In order to clear this bit user has to clear bits     */
     /* [12:0] of register 0x4201.                                   */
     /* range: 20:20, access type: R, default value: 0x0             */
     SOC_PETRA_REG_FIELD ecc_error_fixed;

     /* EccError: indication the two ECC error occurred on one       */
     /* of the memories that contain ECC - the error cannot be       */
     /* fixed so soft-init for the scheduler is required. In         */
     /* order to clear this bit user has to clear bits [28:16]       */
     /* of register 0x4201.                                          */
     /* range: 24:24, access type: R, default value: 0x0             */
     SOC_PETRA_REG_FIELD ecc_error;

  } __ATTRIBUTE_PACKED__ interrupt_reg;

  /* ECC status register: This register contains ECC status         */
  /* per each of the memories.                                      */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x4201 */

    /* ECC Error fields:                                            */
    /* range: 16:28, access type: RC, default value: 0x0            */
    SOC_PETRA_REG_FIELD ecc_error_fields;

  } __ATTRIBUTE_PACKED__ ecc_status_reg;

  /* Interrupt Mask Data: Each bit in this register                 */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4210 */

     /* SmpBadMsgMask: Writing 0 masks the corresponding             */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD smp_bad_msg_mask;

     /* ActFlow BadParamsMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD act_flow_bad_params_mask;

     /* ShpFlow BadParamsMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD shp_flow_bad_params_mask;

     /* RestartFlowEventMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD restart_flow_event_mask;

     /* SMPFullLevel1Mask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpfull_level1_mask;

     /* SMPFullLevel2Mask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpfull_level2_mask;

     /* FCTFIFOOvfMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fctfifoovf_mask;

     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ecc_error_fixed_mask;

     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ecc_error_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_data_reg;

  /* Indirect Command Wr Data: Indirect write data: Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered. 0x4220 is used for writing       */
  /* bits 31:0.0x4221 is used for writing bits 63:32.0x4222         */
  /* is used for writing bits 95:64.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x8420 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg;

  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation. 0x4230 is used for reading bits                */
  /* 31:0.0x4231 is used for reading bits 63:32.0x4232 is           */
  /* used for reading bits 95:64.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x8430 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg;

  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4240 */

     /* IndirectCommandTrigger: Triggers indirect access, as         */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;

  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4241 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0:          */
     /* D193Write operation 1: Read operation.                       */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Credit Counter: This register counts the credits that          */
  /* the scheduler generates.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4260 */

     /* CreditCnt: Counts issued credits that match the filter.      */
     /* This register is clear on read.                              */
     /* range: 30:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD credit_cnt;

     /* CreditOvf: The counter has overflowed. This register is      */
     /* clear on read.                                               */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD credit_ovf;

  } __ATTRIBUTE_PACKED__ credit_counter_reg;

  /* Scheduler Counter: This register counts internal credits       */
  /* that are sent to aggregate schedulers.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4261 */

     /* CMLSCHCreditCnt: Counts credits issued to a scheduler        */
     /* that match the filter. This register is clear on read.       */
     /* range: 30:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD cmlschcredit_cnt;

     /* CMLSCHCreditOvf: Indicates that the counter has              */
     /* overflowed. This register is clear on read.                  */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD cmlschcredit_ovf;

  } __ATTRIBUTE_PACKED__ scheduler_counter_reg;

  /* Incorrect Status Message - Register 1: This register           */
  /* shows the details of a message that was received by the        */
  /* scheduler and failed authentication. Note: Register 2          */
  /* should be read before Register 1. Configuration register        */
  /* 0x4307.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4264 */

     /* SMPMsgFlow: Flow ID in the message                           */
     /* range: 15:0, access type: R, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpmsg_flow;

     /* SMPMsgPort: Port of the Msg received                         */
     /* range: 22:16, access type: R, default value: 0x0             */
     SOC_PETRA_REG_FIELD smpmsg_port;

     /* SMPMsgType: Indicates the type of message received           */
     /* range: 27:24, access type: R, default value: 0x0             */
     SOC_PETRA_REG_FIELD smpmsg_type;

     /* SMPMsgBadVal: Indicates that the message received was        */
     /* bad. This register is clear on read.                         */
     /* range: 30:30, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpmsg_bad_val;

     /* SMPMsgVal: Indicates a flow-status message was received.     */
     /* This register is clear on read.                              */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpmsg_val;

  } __ATTRIBUTE_PACKED__ incorrect_status_message_1_reg;

  /* Incorrect Status Message - Register 2: This register           */
  /* shows the details of a message that received by the            */
  /* scheduler and failed authentication. Note: This register        */
  /* should be read before register 1. Configuration register        */
  /* 0x4307.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4265 */

     /* SMPMsgFap: Source fap of the message                         */
     /* range: 10:0, access type: R, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpmsg_fap;

     /* SMPMsgQue: Source queue of the message                       */
     /* range: 30:16, access type: R, default value: 0x0             */
     SOC_PETRA_REG_FIELD smpmsg_que;

  } __ATTRIBUTE_PACKED__ incorrect_status_message_2_reg;

  /* SMP Message Counter: This counter counts the messages          */
  /* received by the SMP. Configuration register 0x4307.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4266 */

     /* SMPMsgCnt: Counts the number of messages received at the     */
     /* SMP configured according to SMP counter configuration.       */
     /* This register is clear on read.                              */
     /* range: 30:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD smpmsg_cnt;

     /* SMPMsgCntOvf: Indicates that the counter has overflowed.     */
     /* This register is clear on read.                              */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpmsg_cnt_ovf;

  } __ATTRIBUTE_PACKED__ smp_message_counter_reg;

  /* Attempt to Activate Flow / Scheduler with Bad                  */
  /* Parameters: This register latches internal flow                */
  /* activation events, If the scheduler attempts to activate       */
  /* flow with bad parameters the register latches the flow         */
  /* and its parameters until the register is read.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4268 */

     /* ActFlowId: The flow Id or Scheduler that had bad             */
     /* parameters in the FDM. This register is clear on read.       */
     /* range: 15:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD act_flow_id;

     /* ActFlowCOSN Valid: The Flow or Scheduler has bad             */
     /* parameters in the FDM COS 0. This register is clear on       */
     /* read.                                                        */
     /* range: 16:16, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD act_flow_cosn_valid;

     /* ActFlowBadSch: The flow is not connected to a scheduler      */
     /* (and according the SEM, the father is not a scheduler).      */
     /* This register is clear on read.                              */
     /* range: 20:20, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD act_flow_bad_sch;

     /* ActFlow BadParams: This message is valid. This message       */
     /* is generated at the process of activating a flow. This       */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD act_flow_bad_params;

  } __ATTRIBUTE_PACKED__ attempt_to_activate_flow_scheduler_with_bad_parameters_reg;

  /* Attempt to Activate A shaper with Bad Parameters:              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4269 */

     /* ShpFlowId: The flow ID/Scheduler that had bad parameters     */
     /* in the SHD. This register is clear on read.                  */
     /* range: 15:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD shp_flow_id;

     /* ShpFlow BadParams: This message is valid. This message       */
     /* is generated while activating a flow on the shaper if        */
     /* the COS of the shaper is not valid in the SHD table -        */
     /* either overflow or zero. This register is clear on read.     */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD shp_flow_bad_params;

  } __ATTRIBUTE_PACKED__ attempt_to_activate_a_shaper_with_bad_parameters_reg;

  /* Last Flow Restart Event: This register holds the last          */
  /* flow number that was restarted. A restart flow event           */
  /* happens when certain parameters of the flow change while       */
  /* it is being installed on the scheduler. For example:           */
  /* Certain types of QoS or the scheduler it is installed          */
  /* on.                                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x426a */

     /* RestartFlowId: The flow ID/Scheduler that was restarted.     */
     /* This register is clear on read.                              */
     /* range: 15:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD restart_flow_id;

     /* RestartFlowEvent: A restart flow event has occurred.         */
     /* This register is clear on read.                              */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD restart_flow_event;

  } __ATTRIBUTE_PACKED__ last_flow_restart_event_reg;

  /* SCL - SMP Messages: This register holds the last message       */
  /* sent from the SCL to the SMP. If the bit SMPSCLMsgThrow        */
  /* is valid, then the message is kept until the register is       */
  /* read.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x426c */

     /* SMPSCLMsgID: The flow ID of the last message kept.           */
     /* range: 15:0, access type: R, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpsclmsg_id;

     /* SMPSCLMsgStatus: The Status of the last message kept.        */
     /* range: 17:16, access type: R, default value: 0x0             */
     SOC_PETRA_REG_FIELD smpsclmsg_status;

     /* SMPSCLMsgType: 0 - Aggregate Message 1 - Restart Message     */
     /* range: 20:20, access type: R, default value: 0x0             */
     SOC_PETRA_REG_FIELD smpsclmsg_type;

     /* SMPSCLMsgThrow: The SCL wrote a message to the SMP while     */
     /* its fifos were full. This register is clear on read.         */
     /* range: 24:24, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpsclmsg_throw;

     /* SMPSCLMsg: The SCL wrote a message to the SMP. This          */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpsclmsg;

  } __ATTRIBUTE_PACKED__ scl_smp_messages_reg;

  /* DVS Credit Counter: Holds the DVS counter                      */
  /* result. Configuration register 0x439a                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4270 */

     /* DVSCreditCnt: Counts issued credits that match the           */
     /* filter. This register is clear on read.                      */
     /* range: 30:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD dvscreditcnt;

     /* DVSCreditCntOvf/Fin: The counter has overflowed. This        */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvscreditcntovf;

  } __ATTRIBUTE_PACKED__ dvs_credit_counter_reg;

  /* DVS RCI Counter: Counts RCI events. Configuration               */
  /* register 0x439b.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4271 */

     /* DVSRCICnt: Counts the number of clocks that RCI was          */
     /* issued at the port. This register is clear on read.          */
     /* range: 30:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD dvsrcicnt;

     /* DVSRCICntFin: Count finished. This register is clear on      */
     /* read.                                                        */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvsrcicnt_fin;

  } __ATTRIBUTE_PACKED__ dvs_rci_counter_reg;

  /* DVS Flow Control Counter: Count FC events per port             */
  /* Configuration register 0x439b.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4272 */

     /* DVSFCCnt: Counts the number of clocks that flow control      */
     /* was issued at the port. This register is clear on read.      */
     /* range: 30:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD dvsfccnt;

     /* DVSFCCntFin: Count finished. This register is clear on       */
     /* read.                                                        */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvsfccnt_fin;

  } __ATTRIBUTE_PACKED__ dvs_flow_control_counter_reg;

  /* DVS Link Status: Holds the number of links/RCI level           */
  /* that the scheduler sees.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4273 */

     /* DVSLinkCnt: The number of links the DVS sees during          */
     /* connection                                                   */
     /* range: 5:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD dvslink_cnt;

     /* DVSRciLevel: Current RCI level                               */
     /* range: 10:8, access type: R, default value: 0x0              */
     SOC_PETRA_REG_FIELD dvsrci_level;

     /* DVSMaxRciLevel: The max RCI level since last read (water     */
     /* mark). This register is clear on read.                       */
     /* range: 14:12, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvsmax_rci_level;

  } __ATTRIBUTE_PACKED__ dvs_link_status_reg;

  /* Scheduler Configuration Register : Main configurations         */
  /* of the scheduler.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4301 */

     /* CountByGtimer: Global bit, if set then all gtimer            */
     /* supported counters will count according to gtimer,           */
     /* otherwise the counter will count according to its own        */
     /* cnt_by_gtimer bit.                                           */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD count_by_gtimer;

     /* SubFlowEnable: Enables mapping one flow/queue (F) - to       */
     /* two sub-flows. If set and the respective bit in the          */
     /* Flow-Sub-Flow-Mapping-Table is also set, then even flow      */
     /* F is mapped to flows EVEN(F) and EVEN(F)+1.                  */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sub_flow_enable;

     /* SMPDisableFabric: If this bit is set, then the SMP stops     */
     /* processing messages coming from the fabric.                  */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpdisable_fabric;

     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD no_msg;

     /* DiscardCredits: If this bit is set, the CML discards all     */
     /* credits.                                                     */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD discard_credits;

     /* VirtualFlow Enable: If this bit is set the scheduler         */
     /* treats flows that have queue 0 assigned in the FFQ as        */
     /* virtual flows and does not send them to the fabric. See      */
     /* Flow to FIP Mapping, Flow to Queue Mapping and Flow Slow     */
     /* Enable Mode.                                                 */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD virtual_flow_enable;

  } __ATTRIBUTE_PACKED__ scheduler_configuration_reg;

  /* Shaper Configuration Register 1.: Main configurations of       */
  /* the shaper                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4302 */

     /* ShaperSlowRate1: The rate the shaper gives to flows in       */
     /* the Slow state. This value is interpreted like               */
     /* \{PeakRateExp, PeakRateMan\} in the SHDS table. [See the     */
     /* description and table in Shaper Descriptor Memory Static     */
     /* (SHDS)]. The shaper chooses between this value and the       */
     /* ShaperSlowRate2 if the flow is slow_enabled (see FFQ),       */
     /* based on the SlowRate2SelEven setting in the SHDS. If        */
     /* SlowRate2SelEven is set, the slow rate used for the flow     */
     /* is SlowRate2.                                                */
     /* range: 17:8, access type: RW, default value: 0x083 ~400Mbps  */
     SOC_PETRA_REG_FIELD shaper_slow_rate1;

     /* ShaperSlowRate2: See above description for                   */
     /* ShaperSlowRate1.                                             */
     /* range: 29:20, access type: RW, default value: 0x41 ~266Mbps  */
     SOC_PETRA_REG_FIELD shaper_slow_rate2;

  } __ATTRIBUTE_PACKED__ shaper_configuration_1_reg;

  /* Credit Counter Configuration Reg1: Registers 0x4304 and        */
  /* 0x4305 configure the credit counter. The counter result        */
  /* is written to address 0x4260. This register is only            */
  /* Relevant when FilterByFlow in 0x4305 is set.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4304 */

     /* FilterFlow: Which flow value to match.                       */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD filter_flow;

     /* FilterFlowMask: Mask of FilterFlow. If set the               */
     /* corresponding bit in FilterFlow must match the flow          */
     /* credit. Otherwise the corresponding bit in FilterFlow is     */
     /* Don`t care.                                                  */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD filter_flow_mask;

  } __ATTRIBUTE_PACKED__ credit_counter_configuration_1_reg;

  /* Credit Counter Configuration Reg2: Registers 0x4304 and        */
  /* 0x4305 configure the credit counter. The counter result        */
  /* is written to address 0x4260. This register is only            */
  /* Relevant when FilterByFlow in 0x4305 is set.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4305 */

     /* FilterDestFap: Which ID to match (flow or sub flow).         */
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD filter_dest_fap;

     /* FilterByDestFap: When set, only credits to the destined      */
     /* fap are counted.                                             */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD filter_by_dest_fap;

     /* FilterByFlow: When set, only credits to the programmed       */
     /* flow id (or sub flow id) are counted. Programmed flow id     */
     /* is set in register 0x4304.                                   */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD filter_by_flow;

     /* FilterBySubFlow: When 0, matches flow ID. When set,          */
     /* matches sub flow ID (if FilterByFlow is set).                */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD filter_by_sub_flow;

     /* CntByGtimer: If this bit is enabled the counter is           */
     /* controlled by the global timer                               */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_by_gtimer;

  } __ATTRIBUTE_PACKED__ credit_counter_configuration_2_reg;

  /* Credit Scheduler Counter in the CML Configuration: The         */
  /* counter counts credits that are sent from the CML to the       */
  /* STL. Counter result in 0x4261                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4306 */

     /* FilterSch: Which scheduler to match                          */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD filter_sch;

     /* FilterSchMask: Mask of FilterSch                             */
     /* range: 29:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD filter_sch_mask;

     /* CntByGtimer: If this bit is enabled the counter is           */
     /* controlled by the global timer                               */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_by_gtimer;

  } __ATTRIBUTE_PACKED__ credit_scheduler_counter_in_the_cml_configuration_reg;

  /* SMP Message Counter and Status Configuration: The              */
  /* message counter counts status message processed by the         */
  /* SMP. Counter result 0x4266.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4307 */

     /* SMPCntType: Type of Message to count 0 - Fabric off 1 -      */
     /* Fabric slow 2 - Fabric fast 3 - Fabric no change 4 -         */
     /* Fabric Off with credit 7 - Fabric No Change with credit      */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpcnt_type;

     /* SMPFilterByType: Count according to SMPCntType               */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpfilter_by_type;

     /* SMPCntFlow/Port: Count messages received for this flow/      */
     /* port                                                         */
     /* range: 23:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD smpcnt_flow_port;

     /* SMPFilterByFlow/Port: Count only status messages             */
     /* concerning SMPCntFlow/Port: 0 - Do not filter by             */
     /* SMPCntFlow/Port 1 - Filter messages to FLOW                  */
     /* SMPCntFlow/Port 2 - Count all returned credits to SMP 3      */
     /* - Filter only returned credit to PORT SMPCntFlow/Port        */
     /* range: 25:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpfilter_by_flow_port;

     /* CntByTimer: Use global timer when counting messages.         */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_by_timer;

  } __ATTRIBUTE_PACKED__ smp_message_counter_and_status_configuration_reg;

  /* Global Timer Configuration Register: This register             */
  /* configures the global timer, if it is set then all             */
  /* counters that have an option operate according to it           */
  /* when GtimerAct is set.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4308 */

     /* GtimerCnt: Specifies how many clocks the gtimer will be      */
     /* active for. This should be configurse according to           */
     /* coustumer exact clock.                                       */
     /* range: 30:0, access type: RW, default value: ARRAY(0x8d57558) */
     SOC_PETRA_REG_FIELD gtimer_cnt;

     /* GtimerClrCnt: If set, all counters that are operating        */
     /* according to Global Timer are cleared when GtimerAct is      */
     /* activated. Otherwise counters that were not reset            */
     /* explicitly and count according to Gtimer continue            */
     /* counting from the previous number.                           */
     /* range: 31:31, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD gtimer_clr_cnt;

  } __ATTRIBUTE_PACKED__ global_timer_configuration_reg;

  /* Global Timer Activation Register: This register operates       */
  /* the global timer                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4309 */

     /* GtimerAct: When this bit is written all counters that        */
     /* count according to gtimer start counting.                    */
     /* range: 0:0, access type: WCLR, default value: 0x0            */
     SOC_PETRA_REG_FIELD gtimer_act;

  } __ATTRIBUTE_PACKED__ global_timer_activation_reg;

  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430a */

     SOC_PETRA_REG_FIELD scl_cr_cnt_by_flow;

     SOC_PETRA_REG_FIELD scl_cr_cnt_flow;

  } __ATTRIBUTE_PACKED__ credit_cnt_cfg_agg_reg;

  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430b */

     /* range: 2:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dlm_ena;

     /* range: 13:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dlm_bw;

  } __ATTRIBUTE_PACKED__ dlm_reg;

  /* Switch CIR EIR in dual shapers: This register defines in       */
  /* dual shapers the Class scheduler is the CIR or the EIR         */
  /* scheduler.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430c */

     /* SwitchCIREIR: By default (SwitchCIREIR[i] == 0) the          */
     /* FQ/HR is assigned as the CIR and the CL is assigned as       */
     /* the EIR when dual shaper is active. If SwitchCIREIR[i]       */
     /* is set then CL 256i-256i+255 with corresponding FQ 256i      */
     /* - 256i+255 or if bit 31 is set then HR 0-255 are             */
     /* switched and then the CL acts as CIR and the FQ/HR as        */
     /* EIR                                                          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD switch_cireir;

  } __ATTRIBUTE_PACKED__ switch_cir_eir_in_dual_shapers_reg;

  /* FSF Composite Configuration: This register defines             */
  /* whether flows are comprised off odd and even sub-flows         */
  /* or only from odd or even flows.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430d */

     /* FSFCompOddEven: Each bit i, specifies how sub-flows          */
     /* between 24k+ik and 24k+ik+1k-1 are assigned to flows. If     */
     /* FSFCompOddEven[i] == 1, the even flow is composited from     */
     /* even or odd subflows. If FSFCompOddEven[i] == 0, then        */
     /* each four sub flows are assigned to two adjacent flows.      */
     /* Flow x is composited of sub flow x and sub flow x+2.         */
     /* range: 31:0, access type: RW, default value: 0xffffffff      */
     SOC_PETRA_REG_FIELD fsfcomp_odd_even;

  } __ATTRIBUTE_PACKED__ fsf_composite_configuration_reg;

  /* Select flow to queue mapping: This register defines if         */
  /* flows are mapped to queues in interdigitated mode. In          */
  /* this mode flows 0 and 1 of each quartet are used for           */
  /* scheduler elements and not mapped to queues. Hence, the        */
  /* scheduler maps only flows 2,3 or 2 only (in case of            */
  /* composite) to the queues.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430e */

     /* InterDig: Bit i relates to flows 24k+1k*i                    */
     /* -24k+1k*i+1k-1. If InterDig = 0 and SubFlowMode = 0 then     */
     /* Q=\{BaseQueueNum, flow[1:0]\} If InterDig = 0 and            */
     /* SubFlowMode = 1 then Q=\{BaseQueueNum, flow[2:1]\} If        */
     /* InterDig = 1 and SubFlowMode = 0 then Q=\{BaseQueueNum,      */
     /* flow[2], flow[0]\} If InterDig = 1 and SubFlowMode = 1       */
     /* then Q=\{BaseQueueNum, flow[3:2]\}                           */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD inter_dig;

  } __ATTRIBUTE_PACKED__ select_flow_to_queue_mapping_reg;

  /* System Red Configuration: This register configures the         */
  /* system red mechanism in the scheduler                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430f */

     /* AgingTimerCfg : Every AgingTimerCfgx1296 ns (at 4nanosec     */
     /* clk), the aging mechanism accesses the queue size saved      */
     /* for a port. If a message is received with an updated         */
     /* queue size since the last time the aging mechanism           */
     /* accessed the port, this mechanism continues on to the        */
     /* next port. Otherwise, it changes the queue size              */
     /* according to ResetXpiredQSZ. If ResetXpiredQSZ is set,       */
     /* the mechanism resets the queue size. Otherwise it            */
     /* decrements it by one. Note: If AgingTimerCfg is set to 0     */
     /* or 1, then the aging mechanism does not decrement the        */
     /* queue size values.                                           */
     /* range: 20:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD aging_timer_cfg;

     /* ResetXpiredQSZ : See description of AgingTimerCfg            */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD reset_xpired_qsz;

     /* AgingOnlyDecPQS: if this bit is set then only aging          */
     /* events decrements the relevant PQS entry, otherwise          */
     /* Aging and flow status messages can decrement it.             */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD aging_only_dec_pqs;

     /* EnableSysRed : If this bit is set, then the system red       */
     /* mechanism is active in the scheduler; Otherwise, it is       */
     /* disabled.                                                    */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD enable_sys_red;

  } __ATTRIBUTE_PACKED__ system_red_configuration_reg;

  /* HRPort En Register 1: This register enables the root           */
  /* ports.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4310 */

     /* HRPortEn31_0: Enables root port for HR numbers 31 to 0.      */
     /* (Schedulers 16159:16128; flows indexes 56445:56321 in        */
     /* interval of 4, e.g. \{56445, 56441, 56437, ...,              */
     /* 56321\}).                                                    */
     /* HRPortEn63_32: Enables root port for HR numbers 63 to        */
     /* 32. (Schedulers 16191:16160; flows indexes 56573:56449       */
     /* in interval of 4, e.g. \{56573, 56569, 56565, ...,           */
     /* 56449\}).                                                    */
     /* HRPortEn81_64: Enables root port for HR numbers 81 to        */
     /* 64. (Schedulers 16209:16192; flows indexes 56642:56574       */
     /* in interval of 4.                                            */
     /* range: 31:0, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD hrport_en;

  } __ATTRIBUTE_PACKED__ hrport_en_reg[SOC_PB_HRPORT_EN_NOF_REGS];

  /* HR Flow Control Mask 0 1 : This register sets which            */
  /* priorities are affecte by high and low port flow               */
  /* control. Which mask to use per HR is configured in the         */
  /* SHC memory.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4318 */

     /* HRFCMask0: There are 5 valid masks: 1- 16'h1 (masks SP1)     */
     /* 2- 16'h3 (masks SP1 and SP2) 3- 16'h7 (masks SP1, SP2        */
     /* and SP3) 4- 16'h7fff (masks all priorities besides BE)       */
     /* 5- 16'h1ff - only for Enhanced HR or Dual HR (for Dual       */
     /* it masks SP1, SP2, SP3 and WFQ1 and for Enhanced it          */
     /* masks SP1-SP9)                                               */
     /* range: 15:0, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD hrfcmask0;

     /* HRFCMask1: See above                                         */
     /* range: 31:16, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD hrfcmask1;

  } __ATTRIBUTE_PACKED__ hr_flow_control_mask_0_1_reg;

  /* HR Flow Control Mask 2 3 : This register sets which FLLs       */
  /* are affecte dy high and low port flow control. Which           */
  /* mask to use per HR is configured in the SHC memory             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4319 */

     /* HRFCMask2: See above                                         */
     /* range: 15:0, access type: RW, default value: 0x7             */
     SOC_PETRA_REG_FIELD hrfcmask2;

     /* HRFCMask3: See above                                         */
     /* range: 31:16, access type: RW, default value: 0x7fff         */
     SOC_PETRA_REG_FIELD hrfcmask3;

  } __ATTRIBUTE_PACKED__ hr_flow_control_mask_2_3_reg;

  /* Device Scheduler (DVS) Config0: This register forces a         */
  /* pause for each of NIFs [31:0] (one bit per NIF). If set        */
  /* then the corresponding Nif is paused.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4320 */

     /* NIFForcePause0: Stops NIFxx credits-one bit per NIF          */
     /* (xx=[31:0])                                                  */
     /* range: 31:0, access type: RW, default value: 0xffffffff      */
     SOC_PETRA_REG_FIELD nifforce_pause0;

  } __ATTRIBUTE_PACKED__ dvs_config_reg[SOC_PB_SCH_DVS_CONFIG_REG_NOF_REGS];

  /* Device Scheduler (DVS) Config2: The register forces a          */
  /* pause for CPU, RCY, ERP, OLP and Devices Pause .               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4322 */

     /* CPUForcePause: Stops CPU NIF credits                         */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD cpuforce_pause;

     /* RCYForcePause : Stops RCY NIF credits                        */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rcyforce_pause;

     /* ERPForcePause : Stops ERP NIF credits                        */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD erpforce_pause;

     /* OLPForcePause : Stops OLP NIF credits                        */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD olpforce_pause;

     /* ForcePause: Stops the DVS credits                            */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD force_pause;

  } __ATTRIBUTE_PACKED__ dvs_config1_reg;

  /* Device Scheduler (DVS) Weight Config0-3: This regsiter         */
  /* configures the WFQ weight.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4323 */

     /* WFQWeightXX: Configures the value for weight0 between        */
     /* [1-1023]. Value 0 disables the weight. (1 is the highest     */
     /* weight and 1023 is the lowest.)                              */
     /* range: 9:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wfqweight_xx;

     /* WFQWeightXX+1: Configures the value for weight1 between      */
     /* [1-1023]. Value 0 disables the weight. (1 is the highest     */
     /* weight and 1023 is the lowest.)                              */
     /* range: 25:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfqweight_xx_plus_1;

  } __ATTRIBUTE_PACKED__ dvs_weight_config_reg[SOC_PB_NOF_DVS_WEIGHT_CONFIG_REGS];

  /* RCI Params: RCI configuration register0, if enabled then       */
  /* when generating credits the DVS takes into consideration       */
  /* the RCI level otherwise the DVS generates credits as if        */
  /* the RCI level is 0.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4327 */

     /* RCIEna: Enable RCI bucket when RCI events received from      */
     /* fabric.                                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rciena;

     /* FapRCIEna: Enable RCI bucket according to the FAP RCI        */
     /* indicators.                                                  */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fap_rciena;

     /* RCIIncVal: RCI bucket increments by this value when an       */
     /* RCI bit is received.                                         */
     /* range: 10:4, access type: RW, default value: 0x10            */
     SOC_PETRA_REG_FIELD rciinc_val;

  } __ATTRIBUTE_PACKED__ rci_params_reg;

  /* RCI Decrement Values: RCI configuration register1, The         */
  /* RCIDecrement values determine the transition between the       */
  /* different RCI levels                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4328 */

     /* RCIDecrement0: RCI decrements by (value*2 + 1) every I       */
     /* cell.                                                        */
     /* range: 3:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rcidecrement0;

     /* RCIDecrement1: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 7:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rcidecrement1;

     /* RCIDecrement2: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 11:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD rcidecrement2;

     /* RCIDecrement3: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 15:12, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD rcidecrement3;

     /* RCIDecrement4: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 19:16, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD rcidecrement4;

     /* RCIDecrement5: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 23:20, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD rcidecrement5;

     /* RCIDecrement6: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 27:24, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD rcidecrement6;

     /* RCIDecrement7: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 31:28, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD rcidecrement7;

  } __ATTRIBUTE_PACKED__ rci_decrement_values_reg;

  /* NIF[0-3],[16-19] CAL Config (Ch NIF): ChNIF                    */
  /* configuration register0: Configures the length of the          */
  /* Active and standby calendars, and the weight of ChNIF.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4330 */

     /* CalALen/CalBLen: The length of the primary calendar of ChNIFxx =     */
     /* CAL_A_Len + 1. If CAL_A_Len is 0, then the length of the     */
     /* calendar is 1.                                               */
     /* range: 9:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cal_len[SOC_PB_CH_NIF_CAL_LEN_NOF_FLDS];

     /* ChNIFxxWeight: Selects one of the eight configured           */
     /* weights. (Weights are defined in registers                   */
     /* 0x4323-0x4326)                                               */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ch_nifxx_weight;

     /* DVSCalendarSelChNIFxx: Selects which Calendar is active.     */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvscalendar_sel_ch_nifxx;

  } __ATTRIBUTE_PACKED__ ch_nif_cal_config_reg[SOC_PB_NOF_CH_NIF_CAL_REGS];

  /* NIF[0-3],[16-19] Rates (Ch NIF): ChNIF configuration           */
  /* register: configures the rate of all of the OFPs related       */
  /* to the ChNIF, and the ChNIF shaper rate.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4331 */

     /* NIFRates (ChNIF): This value defines the calendar            */
     /* traversal rate. Every ChNIFxxSumOfPorts/64 the next          */
     /* scheduler is visited and may be awarded a credit.            */
     /* ChNIFxxSumOfPorts and the number of the slots it             */
     /* occupies determines the number of credits given to the       */
     /* port. If ChNIFxxSumOfPorts = 0 then the ChNIFxx ports        */
     /* will not receive credits. ChNIFxxSumOfPorts cannot be        */
     /* lower then 64. To calculate the rate do the following:       */
     /* Rate[Gbps] = (Credit_Size*8*64)/(4*ChNIFxxSumOfPorts)        */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ch_nifxx_sum_of_ports;

     /* ChNIFxxMaxCrRate: This value defines the maximal credit      */
     /* rate given to the ports on ChNIFxx (ChNIF shaper rate),      */
     /* that means that ChNIFxx will be awarded a credit every       */
     /* ChNIFxxMaxCrRate clocks. If ChNIF0MaxCrRate = 0 then no      */
     /* credits will given to the ChNIF. To calculate the rate       */
     /* do the following: Rate[Gbps] =                               */
     /* (Credit_Size*8)/(4*ChNIFxxSumOfPorts)                        */
     /* range: 31:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ch_nifxx_max_cr_rate;

  } __ATTRIBUTE_PACKED__ ch_nif_reg[SOC_PB_NOF_CH_NIF_RATE_REGS];

  /* NIF[4-15], [20-31],[36-47], [52-63] Config (Port NIF):         */
  /* OnePortNif configuration register: Configures the shaper       */
  /* rate of the PortNif, its weight, and the related Port.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4354 */

     /* PortNIFxxMaxCrRate: This value is the Port NIF maximum       */
     /* rate. Every PortNIF4MaxCrRate/64, the NIF can be awarded     */
     /* a credit. If PortNIF4MaxCrRate = 0, then PortNIF port        */
     /* will not receive credits. PortNIFMaxCrRate cannot be         */
     /* lower than 64.                                               */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_nifxx_max_cr_rate;

     /* NIFxxPort id: The Port ID PortNIF mapped to.                 */
     /* range: 26:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifxx_port_id;

     /* PortNIFxxWeight: Selects one of the eight configured         */
     /* weights. (Weights are defined in registers                   */
     /* 0x4323-0x4326)                                               */
     /* range: 30:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD port_nifxx_weight;

  } __ATTRIBUTE_PACKED__ port_nif_reg[SOC_PB_NOF_1PORT_NIF_RATE_REGS];

  /* CPU CAL Configuration Register: CPU configuration              */
  /* register0: configures the length of the Active and             */
  /* standby calendars, and the weight of CPU.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4390 */

     /* CalALen/CalBLen: The length of the primary calendar of CPU =         */
     /* CAL_A_Len + 1. If CAL_A_Len is 0, then the length of the     */
     /* calendar is 1.                                               */
     /* range: 9:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cal_len[SOC_PB_CH_NIF_CAL_LEN_NOF_FLDS];

     /* CPUWeight: Selects one of the eight configured weights.      */
     /* (Weights are defined in registers 0x4323-0x4326)             */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpuweight;

     /* DVSCalendarSelCPU: The Active calendar for the CPU           */
     /* interface                                                    */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvscalendar_sel_cpu;

  } __ATTRIBUTE_PACKED__ cpu_cal_configuration_reg;

  /* CPU Rates0: CPU configuration register1: configures the        */
  /* rate of all of the CPU port related to CPU interface.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4391 */

     /* CPUSumOfPorts: This value defines the calendar traversal     */
     /* rate. Every CPUSumOfPorts/64, the next scheduler is          */
     /* visited and may be awarded a credit. CPUSumOfPorts and       */
     /* the number of the slots it occupies determine the number     */
     /* of credits given to the port. If CPUSumOfPorts = 0, then     */
     /* the CPU ports will not receive credits. CPUSumOfPorts        */
     /* cannot be lower than 64. To calculate the rate do the        */
     /* following: Rate[Gbps] =                                      */
     /* (Credit_Size*8*64)/(4*CPUSumOfPorts)                         */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpusum_of_ports;

  } __ATTRIBUTE_PACKED__ cpu_rates0_reg;

  /* CPU Rate1: CPU configuration register2: Configures the         */
  /* CPU interface shaper rate.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4392 */

     /* CPUMaxCrRate: CPU interface shaper rate. Defines the         */
     /* number of clocks between credits to the CPU port. If= 0,     */
     /* then no credits will given to the CPU. To calculate the      */
     /* rate do the following: Rate[Gbps] =                          */
     /* (Credit_Size*8)/(4*CPUMaxCrRate)                             */
     /* range: 21:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpumax_cr_rate;

  } __ATTRIBUTE_PACKED__ cpu_rate1_reg;

  /* RCY CAL Configuration: Recycle Interface configuration         */
  /* register0: Configures the length of the Active and             */
  /* standby calendars, and the weight of RCY interface.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4394 */

     /* CalALen: The length of the primary calendar of RCY =         */
     /* CAL_A_Len + 1. If CAL_A_Len is 0, then the length of the     */
     /* calendar is 1.                                               */
     /* range: 9:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cal_len[SOC_PB_CH_NIF_CAL_LEN_NOF_FLDS];

     /* RCYWeight: Selects one of the eight configured weights.      */
     /* (Weights are defined in registers 0x4323-0x4326)             */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcyweight;

     /* DVSCalendarSelRCY: The Active calendar for the RCY           */
     /* interface.                                                   */
     /* range: 28:28, access type: R, default value: 0x0             */
     SOC_PETRA_REG_FIELD dvscalendar_sel_rcy;

  } __ATTRIBUTE_PACKED__ rcy_cal_configuration_reg;

  /* RCY Rate0: RCY configuration register1: Configures the         */
  /* rate of all of the RCY ports related to RCY interface.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4395 */

     /* RCYSumOfPorts: This value defines the calendar traversal     */
     /* rate. Every RCYSumOfPorts/64, the next scheduler is          */
     /* visited and may be awarded a credit. RCYSumOfPorts and       */
     /* the number of the slots it occupies determine the number     */
     /* of credits given to the port. If RCYSumOfPorts = 0, then     */
     /* the RCY ports will not receive credits. RCYSumOfPorts        */
     /* cannot be lower than 64. To calculate the rate do the        */
     /* following: Rate[Gbps] =                                      */
     /* (Credit_Size*8*64)/(4*RCYSumOfPorts)                         */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcysum_of_ports;

  } __ATTRIBUTE_PACKED__ rcy_rate0_reg;

  /* RCY Rate1: RCY configuration register2: Configures the         */
  /* RCY interface shaper rate.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4396 */

     /* RCYMaxCrRate: RCY interface shaper rate. Defines the         */
     /* number of clocks between credits to the RCY port. If= 0,     */
     /* then no credits will given to the RCY. To calculate the      */
     /* rate do the following: Rate[Gbps] =                          */
     /* (Credit_Size*8)/(4*RCYMaxCrRate)                             */
     /* range: 21:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcymax_cr_rate;

  } __ATTRIBUTE_PACKED__ rcy_rate1_reg;

  /* ERP Config: Egress Replication Port configuration              */
  /* register: Configures the shaper rate of the ERP, its           */
  /* weight, and the related Port.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4398 */

     /* ERPMaxCrRate: This value ERP maximum rate. Every             */
     /* ERPMaxCrRate/64, the NIF can be awarded a credit. If         */
     /* ERPMaxCrRate = 0, then ERP port will not receive             */
     /* credits. ERPMaxCrRate cannot be lower than 64.               */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD erpmax_cr_rate;

     /* ERPPort id: Mapping ERP to outgoing FAP Port.                */
     /* range: 26:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD erpport_id;

     /* ERPWeight: Selects one of the eight configured weights.      */
     /* (Weights are defined in registers 0x4323-0x4326)             */
     /* range: 30:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD erpweight;

  } __ATTRIBUTE_PACKED__ erp_config_reg;

  /* OLP Config: Off Load Processor configuration register:         */
  /* Configures the shaper rate of the OLP, its weight, and         */
  /* the related Port.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4399 */

     /* OLPMaxCrRate: This value the OLP maximum rate. Every         */
     /* OLPMaxCrRate/64, the NIF can be awarded a credit. If         */
     /* OLPMaxCrRate = 0, then OLP port will not receive             */
     /* credits. OLPMaxCrRate cannot be lower than 64.               */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD olpmax_cr_rate;

     /* OLPPort id: Mapping OLP to outgoing FAP Port.                */
     /* range: 26:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD olpport_id;

     /* OLPWeight: Selects one of the eight configured weights.      */
     /* (Weights are defined in registers 0x4323-0x4326)             */
     /* range: 30:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD olpweight;

  } __ATTRIBUTE_PACKED__ olp_config_reg;

  /* DVS Credit Counter Configuration register: The DVS             */
  /* credit counter can be configured to count credits issued       */
  /* to Port/Interface.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x439a */

     /* DVSFilterPort: Which Port to count credits for.              */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dvsfilter_port;

     /* DVSFilterNIF: Which NIF to count credits for.                */
     /* range: 18:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvsfilter_nif;

     /* CntByPort: If this bit is set, then the counter counts       */
     /* credit by port DVSFilterPort                                 */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_by_port;

     /* CntByNIF: If this bit is set, then the counter counts        */
     /* credit by NIF DVSFilterNIF                                   */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_by_nif;

     /* CntByGtimer: Use global timer when counting credits.         */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_by_gtimer;

  } __ATTRIBUTE_PACKED__ dvs_credit_counter_configuration_reg;

  /* DVS FC and RCI Counters Configuration register: Counts         */
  /* FC and RCI events. Counter result 0x4272.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x439b */

     /* FCCntPort: Which Port to count the FC events for.            */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fccnt_port;

     /* FCInterface: Which Channelized Interface to count FC         */
     /* events for: 0: Interface 0 1: Interface 1 2: Interface 2     */
     /* 3: Interface 3 4: Interface 16 5: Interface 17 6:            */
     /* Interface 18 7: Interface 19 8: Interface 32 9:              */
     /* Interface 33 10: Interface 34 11: Interface 35 12:           */
     /* Interface 48 13: Interface 49 14: Interface 50 15:           */
     /* Interface 51 16: CPU 17: RCY 18: ERP                         */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fcinterface;

     /* CLFC: Class FC - which HR to count FC for                    */
     /* range: 19:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD clfc;

     /* CntHighFC: If set then the counter will count high FC        */
     /* events to FCCntPort port                                     */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_high_fc;

     /* CntLowFC: If set then the counter will count low FC          */
     /* events to FCCntPort port                                     */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_low_fc;

     /* CntInterfaceFC: If set then the counter will count FC        */
     /* events to interface FCInterface                              */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_interface_fc;

     /* CntCLFC: If set then the counter will count FC events to     */
     /* HR num (128+CLFC)                                            */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_clfc;

     /* CntDeviceFC: If set then the counter will count Device       */
     /* FC events                                                    */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_device_fc;

     /* CntRCIEvents: If set then the counter will count RCI         */
     /* events from the FE                                           */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_rcievents;

     /* CntFAPRCIEvents: If set then the coutner will count RCI      */
     /* events from the FAP                                          */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_faprcievents;

     /* CNTRCIByLevel: if both CntRCIEvents and CntFAPRCIEvents      */
     /* are set to 0, then the counter will count the period in      */
     /* which the scheduler was in RCI level CNTRCIByLevel           */
     /* range: 30:28, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD cntrciby_level;

     /* CntByGtimer: Use global timer when counting FC and RCI       */
     /* events                                                       */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_by_gtimer;

  } __ATTRIBUTE_PACKED__ dvs_fc_and_rci_counters_configuration_reg;

  /* STL Group Config0: Configures the group of the scheduler       */
  /* port-the group should be the same as in the FGM memory         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x43a0 */

     /* Port0Group: The group of Port0-one of the three groups       */
     /* \{0,1,2\}                                                    */
     /* range: 1:0 , access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_group[SOC_PB_NOF_STL_GROUP_CONFIG_FLDS];
  } __ATTRIBUTE_PACKED__ stl_group_config_reg[SOC_PB_NOF_STL_GROUP_CONFIG_REGS];

  /* SCH Fabric Multicast Port Configuration register:              */
  /* Multicast Ports configuration register: Maps each              */
  /* multicast class to the HR.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x43a6 */

     struct
     {
       /* Multicast GFMC Port ID one of 80 outgoing FAP ports.     */
       /* range: 6:0,   access type: RW, default value: 0x0        */
       /* range: 14:08, access type: RW, default value: 0x0        */
       /* range: 22:16, access type: RW, default value: 0x0        */
       /* range: 30:24, access type: RW, default value: 0x0        */
       SOC_PETRA_REG_FIELD port_id;

       /* If this bit is set, then the scheduler enables the IPS   */
       /* to generate credits for the Multicast Class0 port.       */
       /* range: 07:07, access type: RW, default value: 0x0        */
       /* range: 15:15, access type: RW, default value: 0x0        */
       /* range: 23:23, access type: RW, default value: 0x0        */
       /* range: 31:31, access type: RW, default value: 0x0        */
       SOC_PETRA_REG_FIELD enable;
     } __ATTRIBUTE_PACKED__ multicast_class[SOC_PETRA_NOF_MULTICAST_CLASSES];

  } __ATTRIBUTE_PACKED__ sch_fabric_multicast_port_configuration_reg;

  /* Ingress Shaping Port Configuration: Ingress shaping            */
  /* configuration register: Defines/enables the HR for             */
  /* ingress Shaping.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x43a7 */

     /* IngressShapingPortID: Ingress Shaping Port ID-one of 80      */
     /* outgoing FAP ports                                           */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ingress_shaping_port_id;

     /* IngressShapingEnable: If set, then the scheduler enables     */
     /* the IPS to generate credits for the ingress shaping          */
     /* port.                                                        */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ingress_shaping_enable;

  } __ATTRIBUTE_PACKED__ ingress_shaping_port_configuration_reg;

  struct
  {
      SOC_PETRA_REG_ADDR  addr;  /* 0x43aa */

      SOC_PETRA_REG_FIELD delay;

      SOC_PETRA_REG_FIELD enable;

  } __ATTRIBUTE_PACKED__ smp_internal_messages;

  /* Force High FC Register 0: This register forces flow            */
  /* control to a port scheduler.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x43b0 */

     /* ForceHighFC31 0: Forces flow control for root port           */
     /* numbers 31 to 0. Depending on ForceFCOveride this bit        */
     /* either exlusively set flow control on the respective         */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_high_fc31_0;

  } __ATTRIBUTE_PACKED__ force_high_fc__reg[SOC_PB_SCH_FORCE_HIGH_FC__REG_NOF_REGS];

  /* Force Low FC Register 0: This register forces low flow         */
  /* control to a port scheduler.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x43b4 */

     /* ForceLowFC31 0: Forces low flow control for root port        */
     /* numbers 31 to 0. Depending on ForceLowFCOveride this bit     */
     /* either exlusively set flow control on the respective         */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_low_fc31_0;

  } __ATTRIBUTE_PACKED__ force_low_fc__reg[SOC_PB_SCH_FORCE_LOW_FC__REG_NOF_REGS];

  /* Force Aggr FC Register 0: This register forces flow            */
  /* control to an aggregate scheduler.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x43b8 */

     /* ForceAggrFC159 128: Forces flow control for HR aggregate     */
     /* numbers 159 to 128. Depending on ForceAggrFCOveride this     */
     /* bit either exlusively set flow control on the respective     */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_aggr_fc159_128;

  } __ATTRIBUTE_PACKED__ force_aggr_fc__reg[SOC_PB_SCH_FORCE_AGGR_FC__REG_NOF_REGS];

  /* Force FC Configuration Register: This register forces          */
  /* flow control to an aggregate scheduler.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x43bc */

     /* ForceHighFCOverride: If this bit is set, the high flow       */
     /* control value set by the CPU in registers 0x43B0 -           */
     /* 0x43B3 is the only source of flow control. Otherwise,        */
     /* the bits in registers 0x43B0 - 0x43B3 are | with the         */
     /* regular source of flow control to the ports.                 */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_high_fcoverride;

     /* ForceLowFCOverride: If this bit is set, the high flow        */
     /* control value set by the CPU in registers 0x43B4 -           */
     /* 0x43B6 is the only source of flow control. Otherwise,        */
     /* the bits in registers 0x43B4 - 0x43B6 are | with the         */
     /* regular source of flow control to the ports.                 */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_low_fcoverride;

     /* AggrFCEn: If this bit is set flow control for HR             */
     /* aggregates 128-255 is enabled.                               */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD aggr_fcen;

     /* ForceAggrFCOverride: If this bit is set only the flow        */
     /* control value set by the CPU in registers 0x43B8 -           */
     /* 0x43BB is the only source of aggr flow control.              */
     /* Otherwise, the bits in registers 0x43B8 - 0x43BB are |       */
     /* with the regular source of aggregate flow control to the     */
     /* ports                                                        */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_aggr_fcoverride;

  } __ATTRIBUTE_PACKED__ force_fc_configuration_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_SCH_REGS;
/* Block definition: SERDES  */
typedef struct
{
  uint32   nof_instances; /* 3 */
  SOC_PETRA_REG_ADDR addr;

  /* srd0 LN0 cfga: SerDes Lane 0 Configurations                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0000 */

     /* LN_MaskDisparityErrors: If set, will ignore 8/10             */
     /* disparity errors. Set to <1> for QSGMII mode. This bit       */
     /* is only relevant for NIF SerDeses.                           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_mask_disparity_errors;

     /* LN TxIdle: If set, overrides Tx data with 0.                 */
     /* range: 1:1, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD ln_tx_idle;

     /* LN TxInv: If set, inverses polarity of high speed Tx         */
     /* data (PADs).                                                 */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD ln_tx_inv;

     /* RxNearestCommaAlign: If set, comma alignment will be         */
     /* done to the nearest character (rather than to the            */
     /* nearest 20b word received from serdes). This will insert     */
     /* smaller skew (up to 10UI).                                   */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD rx_nearest_comma_align;

     /* LN TxRate: Lane Tx rate: [00] - full rate. [01] - half       */
     /* rate. [10] - quarter rate. [11] - eighth rate.               */
     /* range: 5:4, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD ln_tx_rate;

     /* LN RxRate: Lane Rx rate: [00] - full rate. [01] - half       */
     /* rate. [10] - quarter rate. [11] - eighth rate.               */
     /* range: 7:6, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD ln_rx_rate;

     /* LN_DecoupleDisparity: If set, will keep two separated        */
     /* running disparities, one for odd characters and one for      */
     /* even characters. This may be used when running RXAUI and     */
     /* implementing the BOM functions between the comma             */
     /* detector and the 8/10 decoder. This mode affects both Rx     */
     /* and Tx paths. Set to 0 for normal operation. This bit is     */
     /* only relevant for NIF SerDeses.                              */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_decouple_disparity;

     /* LN RxIdle: If set, overrides Rx data (LDOUT[19:0]) with      */
     /* 0.                                                           */
     /* range: 9:9, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD ln_rx_idle;

     /* LN RxInv: If set, inverses polarity of high speed Rx         */
     /* data (PADs).                                                 */
     /* range: 10:10, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_rx_inv;

     /* LN RxAlignEnReq: If set, comma re-alignment is only          */
     /* enabled if the Rx PCS FSM explicitly enabled it.             */
     /* Otherwise, comma re-alignment is always enabled. Set to      */
     /* 1 for use by NIF.                                            */
     /* range: 11:11, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD ln_rx_align_en_req;

     /* LN RxCommaDetMaskLSB: If set, masks comma detection by       */
     /* previously detected commas that are exactly 10b (1           */
     /* character) shifted left. Set to 1 for XAUI modes.            */
     /* range: 12:12, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_rx_comma_det_mask_lsb;

     /* LN RxCommaDetMaskMSB: If set, mask Comma Detection by        */
     /* previously detected commas that are exactly 10b (1           */
     /* character) shifted right. Set to 1 for XAUI modes.           */
     /* range: 13:13, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_rx_comma_det_mask_msb;

     /* LN RxPcsSyncFsmInit: If set, will reset the Rx PCS           */
     /* Synchronization FSM.                                         */
     /* range: 14:14, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_rx_pcs_sync_fsm_init;

     /* LN ShareCfg: If set, use LN0_cfga to configure this          */
     /* lane. If set for lane 0, will source the LN0_cfga from       */
     /* another SerDes macro: source srd0_LN0_cfga from              */
     /* srd1_LN0_cfga source srd1_LN0_cfga from srd0_LN0_cfga        */
     /* source srd2_LN0_cfga from srd1_LN2_cfga source               */
     /* srd3_LN0_cfga from srd2_LN2_cfga This will allow             */
     /* simultaneous configuration of all lanes in XAUI/SPAUI        */
     /* modes, and will reduce inter-lane skew.                      */
     /* range: 15:15, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_share_cfg;

     /* LN IntEnRxDecodeErr: If set, enables interrupt on            */
     /* detection by Rx 8B/10B decoder of code group error by        */
     /* either decoder.                                              */
     /* range: 16:16, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_int_en_rx_decode_err;

     /* LN IntEnRxDispErr: If set, enables interrupt on              */
     /* detection by Rx 8B/10B decoder of running disparity          */
     /* error by either decoder.                                     */
     /* range: 17:17, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_int_en_rx_disp_err;

     /* LN IntEnRxCommaRealign: If set, enables interrupt on Rx      */
     /* comma realignment.                                           */
     /* range: 18:18, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_int_en_rx_comma_realign;

     /* LN IntEnRxSigDetChange: If set, enable interrupt on Rx       */
     /* Signal Detect status change.                                 */
     /* range: 19:19, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD ln_int_en_rx_sig_det_change;

     /* LN IntSelRxPcsSyncFsm: Reserved (DFT).                       */
     /* range: 23:20, access type: UNDEF, default value: 0xf         */
     SOC_PETRA_REG_FIELD ln_int_sel_rx_pcs_sync_fsm;

     /* EBIST RxEn: If set, enables the External (Dune) Rx BIST.     */
     /* range: 24:24, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ebist_rx_en;

     /* EBIST TxEn: If set, enables the External (Dune) Tx BIST.     */
     /* range: 25:25, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ebist_tx_en;

     /* EBIST PrbsPolSel: If set, uses PRBS7 random sequence.        */
     /* Otherwise, uses PRBS23 random sequence for BIST.             */
     /* range: 26:26, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ebist_prbs_pol_sel;

     /* EBIST TxConstDataEn: If set, SerDes will transmit            */
     /* constant data. The 20b data is taken from the                */
     /* LN_TxConstData register (shared by all lanes).               */
     /* range: 27:27, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ebist_tx_const_data_en;

     /* EBIST CntMode: Select which events will be counted by        */
     /* the External BIST: [00] - External Bist Errors [01] -        */
     /* reserved [10] - Rx Disparity Errors [11] - Rx Code           */
     /* Errors                                                       */
     /* range: 29:28, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ebist_cnt_mode;

     /* ExtTxDataOvrdEn: If set, SerDes will transmit 20b data       */
     /* from external source (i.e. from ILKN module). Set to 1       */
     /* when in ILKN mode or for fabric SRDs when in FEC mode.       */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ext_tx_data_ovrd_en;

     /* TxUseExtByteToggle: If set, lane will be synced to           */
     /* external byte polarity source (even / odd position) that     */
     /* is shared by all lanes in MACROCELL (taken from lane 0).     */
     /* This is used to reduce Tx skew between XAUI lanes when       */
     /* moving 10b data from logical lanes to the SRD 20b            */
     /* physical lanes. Set to <1> for XAUI 4-lane-SR/DR or          */
     /* 6-lane-DR modes, and to <0> for SGMII or XAUI 6L-SR          */
     /* modes. This configuration exist only in NIF SerDeses.        */
     /* range: 31:31, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD tx_use_ext_byte_toggle;

  } __ATTRIBUTE_PACKED__ srd_ln_cfga_reg[SOC_PB_SRD_NOF_PER_QRTT_REGS][SOC_PB_SRD_NOF_PER_LANE_REGS];

  /* srd0 LN0 stat: SerDes Lane 0 Indications                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0001 */

     /* LN RxSigDet: Stabilized lane signal detect status            */
     /* (defined by LN_RxSigDetMode and LN_RxSigDetCnt).             */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_sig_det;

     /* LN RxSigDetChange: If set, indicates that lane signal        */
     /* detect status has changed (one or more times). This          */
     /* register is clear on read.                                   */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_sig_det_change;

     /* CMU_TxTrimming: Internal indication that Tx trim             */
     /* sequence is in progress (TxLLK).                             */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cmu_tx_trimming;

     /* CMU_PLL_Rst: Internal indication that PLL reset sequence     */
     /* is in progress (TXPORST).                                    */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cmu_pll_rst;

     /* LN_RxRst: Internal indication that Rx reset/trim             */
     /* sequence is in progress (RXPORST).                           */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_rst;

     /* LN_RxSigLost: Internal lane signal-loss indication           */
     /* (LOSRX).                                                     */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_sig_lost;

     /* LN_RxFreqInvld: Internal indication that lane recovered      */
     /* frequency is invalid (RXFRQINVLD).                           */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_freq_invld;

     /* LN_RxSyncStat: If set, indicates that Rx PCS Sync FSM        */
     /* has achieved synchronization. (Used by NIF Only.)            */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_sync_stat;

     /* LN RxPcsSyncFsmInd: Reserved (DFT). This register is         */
     /* clear on read.                                               */
     /* range: 9:9, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_pcs_sync_fsm_ind;

     /* LN RxCodeErr: If set, Rx 8B/10B decoder detected             */
     /* decoding error in some word. This register is clear on       */
     /* read.                                                        */
     /* range: 13:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_code_err;

     /* LN RxDispErr: If set, Rx 8B/10B decoder detected running     */
     /* disparity error in some word. This register is clear on      */
     /* read.                                                        */
     /* range: 15:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_disp_err;

     /* LN RxCommaAlignEn: Reserved (DFT).                           */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_comma_align_en;

     /* LN RxCommaRealign: Rx comma realignment occurred. This       */
     /* register is clear on read.                                   */
     /* range: 17:17, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_comma_realign;

     /* LN RxCommaAlignment: Reserved.                               */
     /* range: 24:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_comma_alignment;

  } __ATTRIBUTE_PACKED__ srd_ln_stat_reg[SOC_PB_SRD_NOF_PER_QRTT_REGS][SOC_PB_SRD_NOF_PER_LANE_REGS];

  /* srd0 LN0 EBIST: SerDes Lane 0 EBIST Indications                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0002 */

     /* EBIST ErrCnt: Indicates the number of External BIST          */
     /* errors in received data. This register is clear on read.     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ebist_err_cnt;

     /* EBIST Sync: If set, indicates that external BIST PRBS is     */
     /* synchronized with incoming data. This register is clear      */
     /* on read.                                                     */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ebist_sync;

  } __ATTRIBUTE_PACKED__ srd_ln_ebist_reg[SOC_PB_SRD_NOF_PER_QRTT_REGS][SOC_PB_SRD_NOF_PER_LANE_REGS];

  /* srd0 cmu cfga: SerDes CMU Configurations                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0010 */

     /* CMU MacroPd: Macro power down (CMU and lanes).               */
     /* range: 0:0, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD cmu_macro_pd;

     /* CMU MacroRst: Master (async) reset for CMU and lanes.        */
     /* Does not reset register content. Hold for 8 RefClk           */
     /* cycles.                                                      */
     /* range: 1:1, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD cmu_macro_rst;

     /* CMU StartTrim: Start the internal trim sequence. Set to      */
     /* 1 only after all internal registers are configured.          */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD cmu_start_trim;

     /* CMU TrimSelf: Trim without using the internal P8051          */
     /* (IPU).                                                       */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD cmu_trim_self;

     /* CMU PLLN: PLL divider ratio. May be overridden by REFDIV     */
     /* register. f(VCOOUT)=f(RefClk) * 10 * (1+PLLM) /              */
     /* (1+PLLN). PLLM+1=1~5. PLLN+1=1~4.                            */
     /* range: 5:4, access type: UNDEF, default value: 0x3           */
     SOC_PETRA_REG_FIELD cmu_plln;

     /* CMU PLLM: PLL divider ratio. May be overridden by VCODIV     */
     /* register. f(VCOOUT)=f(RefClk) * 10 * (1+PLLM) /              */
     /* (1+PLLN). PLLM+1=1~5. PLLN+1=1~4.                            */
     /* range: 8:6, access type: UNDEF, default value: 0x4           */
     SOC_PETRA_REG_FIELD cmu_pllm;

     /* LN 20b Mode: Select Tx double rate mode (20b/cycle).         */
     /* This bit must be set (1) for MAC SerDeses. For NIF, if       */
     /* set to 1, the Tx physcal lane (PL) is mapped into two        */
     /* logical lanes (LL). Each LL receives 10b that are muxed      */
     /* into the PL (i.e. 6.25 Gbps Double-Rate modes). When set     */
     /* to 0, the NIF drives 10b each cycle using a x2 Tx clock,     */
     /* accumulation of 20b is done by the SerDes Tx channel         */
     /* (i.e. 1.25 / 3.125 Gbps Single-Rate modes). NOTE: Rx is      */
     /* always 20b. LL demuxing is done in Rx BOM. This does not     */
     /* affect the SerDes bitrate itself (LN_TxRate and              */
     /* LN_RxRate). It only affects the interface to the             */
     /* NIF/MAC. Same configuration is used for all lanes in         */
     /* macrocell.                                                   */
     /* range: 9:9, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD ln_20b_mode;

     /* LN TxSyncFifoEn: If set, Tx data from all lanes will be      */
     /* synced to XCK[0] (from lane 0) before driven to SerDes.      */
     /* Otherwise, synchronization is done per lane, using the       */
     /* internal TxFIFO of the serdes (up to 20UI might be           */
     /* caused by this). Set to <1> for XAUI where reduced Tx        */
     /* skew is desired. Set to <0> for SGMII or 6-lanes XAUI,       */
     /* and for MSW (Fabric) interfaces. This register is            */
     /* relevant only for NIF SRDs.                                  */
     /* range: 10:10, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_tx_sync_fifo_en;

     /* LN_TxSyncFifoRstn: If set to 0, Tx synchronizer will be      */
     /* reset. This register must be set to 1 after SRD Tx clock     */
     /* of lane 0 becomes valid. This register is relevant only      */
     /* for NIF SRDs.                                                */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_tx_sync_fifo_rstn;

     /* LN TxobPd: Lane power down.                                  */
     /* range: 15:12, access type: UNDEF, default value: 0xf         */
     SOC_PETRA_REG_FIELD ln_txob_pd;

     /* LN_RxSigDetMode: Select which indications to use for         */
     /* SigDet. This is a 6b bitmap, where each bit qualifies an     */
     /* indication from the SerDes. Set any of these bits to one     */
     /* to qualify the coresponding indication: [0] - SerDes         */
     /* SigDet indication (LOSRX). [1] - SerDes Rx reset in          */
     /* progress (RXPORST). [2] - SerDes Rx recovered clock not      */
     /* locked (RXFRQINVLD). [3] - SerDes Tx reset in progress       */
     /* (TXPORST). [4] - SerDes PLL reset in progress (TXLLK).       */
     /* [5] - Override (to 0). Select all 0 to always indicate       */
     /* SigDet.                                                      */
     /* range: 21:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ln_rx_sig_det_mode;

     /* LN_TxSwapI1En: If set, the Tx 8/10 encoder will replace      */
     /* /I2/ by /I1/. This is required for 1000 Base-X and SGMII     */
     /* links, and must be disabled for QSGMII, XAUI/RXAUI and       */
     /* SPAUI links. Same value is used by all SRD lanes of the      */
     /* QSRD. Only valid for NIF SRDs.                               */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_tx_swap_i1_en;

     /* LN RxSigDetCnt: How many SigDet stable cycles are            */
     /* required.                                                    */
     /* range: 31:24, access type: UNDEF, default value: 0xa         */
     SOC_PETRA_REG_FIELD ln_rx_sig_det_cnt;

  } __ATTRIBUTE_PACKED__ srd_cmu_cfga_reg[SOC_PB_SRD_NOF_PER_QRTT_REGS];

  /* srd0 cmu cfgb: SerDes CMU Configurations (Con't)               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0011 */

     /* LN TxConstData: Data used for transmitting a constant        */
     /* 20b pattern (enabled by EBIST_TxConstDataEn). Data is        */
     /* shared by all lanes.                                         */
     /* range: 19:0, access type: UNDEF, default value: 20'h00000    */
     SOC_PETRA_REG_FIELD ln_tx_const_data;

     /* CMU MSEL IN: Reserved. Set 20b mode. Always set to 1.        */
     /* range: 23:23, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD cmu_msel_in;

     /* LN PcompEn: Reserved. (same for all lanes). Write as 0.      */
     /* range: 24:24, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_pcomp_en;

     /* LN SetCtl: Reserved. (Same for all lanes). Write as 0.       */
     /* range: 27:25, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_set_ctl;

     /* LN TxRdetEn: Reserved. (Same for all lanes). Write as 0.     */
     /* range: 28:28, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_tx_rdet_en;

     /* LN TxBeaconEn: Reserved. (Same for all lanes). Write as      */
     /* 0.                                                           */
     /* range: 29:29, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_tx_beacon_en;

     /* LN MacPhyPD: Reserved. (Same for all lanes). Write as 0.     */
     /* range: 31:30, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_mac_phy_pd;

  } __ATTRIBUTE_PACKED__ srd_cmu_cfgb_reg[SOC_PB_SRD_NOF_PER_QRTT_REGS];

  /* srd0 cmu stat: SerDes SMU Status                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0012 */

     /* CMU TxTrimming: Tx trim sequence in progress (TxLLK).        */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cmu_tx_trimming;

     /* CMU PLL Rst: Internal PLL reset sequence in progress         */
     /* (TXPORST).                                                   */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cmu_pll_rst;

     /* LN RxRst: Lane Rx reset/trim sequence in progress            */
     /* (RXPORST).                                                   */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_rst;

     /* LN RxSigDet: Stabilized lane signal detect status            */
     /* (defined by LN_RxSigDetMode and LN_RxSigDetCnt).             */
     /* range: 11:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ln_rx_sig_det;

     /* LN RxSyncStat: Synchronization status of each lane           */
     /* (output of the Rx PCS Sync FSM). Used by NIF Only.           */
     /* range: 15:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_sync_stat;

     /* LN IntInd: If set, each bit indicates that corresponding     */
     /* SerDes Lane created interrupt. (For further information,     */
     /* see in ln_stat register.)                                    */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_int_ind;

     /* CMU SCIF DataOut: Reserved. SCIF Data out.                   */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cmu_scif_data_out;

     /* CMU SCIF IntReq: Reserved. SCIF Int Req (from                */
     /* macrocell).                                                  */
     /* range: 21:21, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cmu_scif_int_req;

     /* LN PCG2P: Reserved. Polling Compliance indication.           */
     /* range: 27:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_pcg2_p;

     /* LN PCG2N: Reserved. Polling Compliance indication.           */
     /* range: 31:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_pcg2_n;

  } __ATTRIBUTE_PACKED__ srd_cmu_stat_reg[SOC_PB_SRD_NOF_PER_QRTT_REGS];

  /* Srd Ipu Cfg: Configuration Register for IPU (internal          */
  /* 8051), EPB bus, and SCIF access. Shared by all SerDeses        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0078 */

     /* IramRst: Master reset for the 8051 core and the SFR          */
     /* registers.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD iram_rst;

     /* Rst8051: Reset for the 8051 core (does not affect            */
     /* register contents). Should be set for 8 cycles or more.      */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rst8051;

     /* EPB_Rst: Resets all EPB interface signals.                   */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD epb_rst;

     /* ExtScifRst: Reset for shift register written by SCIFASEL     */
     /* pin. Resets this shift register to broadcast value,          */
     /* where the SCIF_EN_IPU and SCIF_EN_CMU bits can be used       */
     /* to control the SCIF.                                         */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ext_scif_rst;

     /* ClkSel8051: Reserved (write as 2).                           */
     /* range: 5:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD clk_sel8051;

     /* PD8051: Power down for the 8051 (does not affect             */
     /* register contents).                                          */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pd8051;

     /* ClkPd8051: Power down for the 8051 clock (freeze             */
     /* operation).                                                  */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD clk_pd8051;

     /* ChanID: Reserved (write as 6).                               */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD chan_id;

     /* INT8051: If set, forces an interrupt request to the          */
     /* 8051. IPU enters ISR until de-assertion of this bit.         */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD int8051;

     /* EPB_IntTimeoutEn: Reserved (write as 1).                     */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD epb_int_timeout_en;

     /* SCIF_IpuEnOnCmuSel: Reserved (write as 0).                   */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD scif_ipu_en_on_cmu_sel;

     /* IPU_ParityEn: If set, IPU (8051) will check parity when      */
     /* accessing memory.                                            */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipu_parity_en;

     /* IPU_ParityForceErr: If set, forces IPU (8051) to insert      */
     /* parity error. Testing only.                                  */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipu_parity_force_err;

     /* IPU_ParityErrIntEn: If set, interrupt will be created        */
     /* when IPU (8051) encounters parity error.                     */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipu_parity_err_int_en;

     /* IPU_INTREQ_IntEn: If set, interrupt will be created when     */
     /* IPU (8051) receives an interrupt request.                    */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipu_intreq_int_en;

     /* IPU_INTACK_IntEn: If set, interrupt will be created when     */
     /* IPU (8051) acknowledges interrupt request and enters         */
     /* ISR.                                                         */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipu_intack_int_en;

     /* IPU_8051PromLoaded: Reserved (scratch pad). Should be        */
     /* set by software after 8051 8k PROM was uploaded, and         */
     /* will remain set until chip is reset. User application        */
     /* may use this bit as indication of the PROM status.           */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ipu_8051_prom_loaded;

     /* EPB_SlowFsm: Reserved (write as 0).                          */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD epb_slow_fsm;

     /* EPB_SkipIntAckRelease: If set, EPB FSM will skip the         */
     /* IntAckRel state and will not wait for ACK signal to          */
     /* clear after an EPB transaction is complete. Set to <1>       */
     /* if manually forcing INT REQ (using the INT8051               */
     /* register).                                                   */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD epb_skip_int_ack_release;

  } __ATTRIBUTE_PACKED__ srd_ipu_cfg_reg;

  /* Srd Epb Op: EPB OP dispatch register. Writing to this          */
  /* register causes a write or read operation to be                */
  /* dispatched on the EPB bus.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0079 */

     /* Addr_Element: EPB element address inside selected            */
     /* channel.                                                     */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD addr_element;

     /* Addr_Channel: EPB channel address select: [3-0] = Rx/Tx      */
     /* channels. [5-4] = Reserved. [6] = Reserved (8051 block).     */
     /* [7] = CMU block.                                             */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD addr_channel;

     /* Addr_Global: Select all Rx/Tx channels.                      */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD addr_global;

     /* Addr_Reg: EPB register address inside selected element.      */
     /* range: 14:9, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD addr_reg;

     /* Addr_IpuCs: EPB Chip Select for IPU (internal 8051).         */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD addr_ipu_cs;

     /* MacroSel: EPB SerDes macro selector for CMU chip select.     */
     /* range: 17:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD macro_sel;

     /* MacroSelAll: EPB Select all SerDes macros (broadcast).       */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD macro_sel_all;

     /* WrEn: EPB Write OP (1) or read OP (0).                       */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wr_en;

     /* IntReq: Wait for interrupt acknowledge before accessing      */
     /* the EPB.                                                     */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD int_req;

     /* IntHold: Continue holding the interrupt request after        */
     /* the EPB access is complete (to speedup the next EPB          */
     /* access).                                                     */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD int_hold;

     /* Data: EPB write data.                                        */
     /* range: 31:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD data;

  } __ATTRIBUTE_PACKED__ srd_epb_op_reg;

  /* Srd Epb Rd: EPB OP data read register. After a read from       */
  /* the EPB bus is finished, the read data and status are          */
  /* available here.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x007a */

     /* Addr Element: EPB element address inside selected            */
     /* channel.                                                     */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD addr_element;

     /* Addr Channel: EPB channel address select: [3-0] = Rx/Tx      */
     /* channels. [5-4] = Reserved. [6] = Reserved (8051 block).     */
     /* [7] = CMU block.                                             */
     /* range: 6:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD addr_channel;

     /* Addr Global: Select all Rx/Tx channels.                      */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD addr_global;

     /* Addr Reg: EPB register address inside selected element.      */
     /* range: 14:9, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD addr_reg;

     /* Addr IpuCs: EPB Chip Select for IPU (internal 8051).         */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD addr_ipu_cs;

     /* MacroSel: EPB SerDes macro selector for CMU chip select.     */
     /* range: 17:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD macro_sel;

     /* MacroSelAll: EPB Select all SerDes macros (broadcast).       */
     /* range: 18:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD macro_sel_all;

     /* WrOp: EPB indicate last OP was WRITE (1) or READ (0).        */
     /* range: 19:19, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD wr_op;

     /* Error: EPB operation (read or write) did not complete,       */
     /* is in progress or had invalid OP. User should check this     */
     /* bit to ensure last OP completed successfully. Cleared        */
     /* upon dispatch of new OP (i.e. write to SrdEpbOp              */
     /* register).                                                   */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD error;

     /* Valid: EPB READ operation completed and read data is now     */
     /* valid. Cleared upon dispatch of new OP (i.e. write to        */
     /* SrdEpbOp register).                                          */
     /* range: 21:21, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD valid;

     /* IntReq: EPB indicate status of P8051 (IPU) interrupt         */
     /* request.                                                     */
     /* range: 22:22, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD int_req;

     /* IntAck: EPB indicate status of P8051 (IPU) interrupt         */
     /* acknowledge.                                                 */
     /* range: 23:23, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD int_ack;

     /* Data: EPB read data from the CMUs/P8051.                     */
     /* range: 31:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD data;

  } __ATTRIBUTE_PACKED__ srd_epb_rd_reg;

} __ATTRIBUTE_PACKED__ SOC_PB_SERDES_REGS;
/* Block definition: MCC   */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* SMS Register:                                                  */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x4e00 */

    /* range: 31:0, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD sms;

    /* range: 31:31, access type: RW, default value: 0x0            */
    /* Writing '1' activates the command. Negated by the logic upon */
    /* completion                                                   */
    SOC_PETRA_REG_FIELD cmd_active;

  } __ATTRIBUTE_PACKED__ sms_reg;

  /* TAP Configuration Register:                                    */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x4e01 */
    /* range: 0:0, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD tap_val;

    /* range: 4:4, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD tap_cmd;


    /* range: 31:0, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD tap;

  } __ATTRIBUTE_PACKED__ tap_config_reg;

  /* TAP Result-0 Register:                                         */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x4e02 */

    /* range: 31:0, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD res;

  } __ATTRIBUTE_PACKED__ tap_res_0_reg;

  /* TAP Result-1 Register:                                         */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x4e03 */
    /* range: 3:0, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD shift;

    /* range: 9:4, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD mask;

    /* range: 31:0, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD res;

  } __ATTRIBUTE_PACKED__ tap_res_1_reg;

  /* Memory Configuration Register: This register contains          */
  /* bits for configuring the memories at powerup                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e04 */

     /* MbistMode: This bit must be asserted after chip powerup      */
     /* in order to be able to repair faulty memories. This bit      */
     /* must be de-asserted for normal operation                     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mbist_mode;

     /* RepairMemories: This bit must be asserted after chip         */
     /* powerup. As a result, the Soc_petra will read memory repair      */
     /* information from the EFUSE and will send repair commands     */
     /* towards the memories. MbistMode configuration bit must       */
     /* be set before asserting this bit.                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD repair_memories;

     /* Dm: This enables control over virage DFT \{dm2,dm1,dm0\}     */
     /* bits                                                         */
     /* range: 18:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dm;

  } __ATTRIBUTE_PACKED__ memory_configuration_reg;

  /* Ready Sms Statuses1                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e05 */

     /* ReadySms1  */
     SOC_PETRA_REG_FIELD ready_sms1 ;

  } __ATTRIBUTE_PACKED__ ready_sms_statuses1;

  /* Ready Sms Statuses2                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e06 */

     /* ReadySms2  */
     SOC_PETRA_REG_FIELD ready_sms2 ;

  } __ATTRIBUTE_PACKED__ ready_sms_statuses2;

  /* Fail Sms Statuses1                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e07 */

     /* FailSms1  */
     SOC_PETRA_REG_FIELD fail_sms1 ;

  } __ATTRIBUTE_PACKED__ fail_sms_statuses1;


  /* Fail Sms Statuses2                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e08 */

     /* FailSms1  */
     SOC_PETRA_REG_FIELD fail_sms2 ;

  } __ATTRIBUTE_PACKED__ fail_sms_statuses2;

  /* SFP Ready Register:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e09 */

     /* range: 0:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sfp_ready;

  } __ATTRIBUTE_PACKED__ sfp_ready_reg;

  /* TAP General Register1:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e10 */

     /* range: 31:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gen1;

  } __ATTRIBUTE_PACKED__ tap_gen_reg_1;

  /* TAP General Register2:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e11 */

     /* range: 31:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gen2;

  } __ATTRIBUTE_PACKED__ tap_gen_reg_2;

  /* Mbist Resets: This register controls all the MBIST reset       */
  /* signals                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e0a */

     /* SmsRst: Resets all MBIST processors.                         */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD sms_rst;

     /* SfpRst: Resets the SFP (Shared Fuse Processor)               */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD sfp_rst;

     /* MbistReset: Resets the WRCK domain of the MBIST              */
     /* processors                                                   */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mbist_reset;

  } __ATTRIBUTE_PACKED__ mbist_resets_reg;

  /* TAP TMS Value Register1:                                    */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x4e20 */

    /* range: 31:0, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD gen;

  } __ATTRIBUTE_PACKED__ tap_tms_value_reg_1;

  /* TAP TMS Value Register2:                                    */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x4e21 */

    /* range: 31:0, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD gen;

  } __ATTRIBUTE_PACKED__ tap_tms_value_reg_2;

} __ATTRIBUTE_PACKED__ SOC_PB_MCC_REGS;

  /* Blocks definition } */
  typedef struct
  {
    SOC_PB_ECI_REGS eci;
    SOC_PB_OLP_REGS olp;
    SOC_PB_NIF_REGS nif;
    SOC_PB_NIF_MAC_LANE_REGS nif_mac_lane;
    SOC_PB_NBI_REGS nbi;
    SOC_PB_IRE_REGS ire;
    SOC_PB_IDR_REGS idr;
    SOC_PB_IRR_REGS irr;
    SOC_PB_IHP_REGS ihp;
    SOC_PB_IHB_REGS ihb;
    SOC_PB_IQM_REGS iqm;
    SOC_PB_QDR_REGS qdr;
    SOC_PB_IPS_REGS ips;
    SOC_PB_IPT_REGS ipt;
    SOC_PB_MMU_REGS mmu;
    SOC_PB_DRC_REGS drc;
    SOC_PB_DPI_REGS dpi;
    SOC_PB_FDR_REGS fdr;
    SOC_PB_FDT_REGS fdt;
    SOC_PB_FCR_REGS fcr;
    SOC_PB_FCT_REGS fct;
    SOC_PB_MESH_REGS mesh_topology;
    SOC_PB_RTP_REGS rtp;
    SOC_PB_FABRIC_MAC_REGS fabric_mac;
    SOC_PB_MSW_REGS msw;
    SOC_PB_EGQ_REGS egq;
    SOC_PB_EPNI_REGS epni;
    SOC_PB_CFC_REGS cfc;
    SOC_PB_SCH_REGS sch;
    SOC_PB_SERDES_REGS serdes;
    SOC_PB_MCC_REGS mcc;
  } __ATTRIBUTE_PACKED__ SOC_PB_REGS;

/* } */

/*************
 * GLOBALS   *
 *************/
/* { */

/* } */

/*************
 * FUNCTIONS *
 *************/
/* { */

/*****************************************************
*NAME
* soc_pb_regs_get
*TYPE:
*  PROC
*FUNCTION:
*  Get a pointer to registers database.
*  The database is per chip-version.
*INPUT:
*  SOC_SAND_DIRECT:
*    SOC_SAND_OUT SOC_PB_REGS  **soc_pb_regs - pointer to pb
*                           registers database.
*  SOC_SAND_INDIRECT:
*    None.
*OUTPUT:
*  SOC_SAND_DIRECT:
*    error indication
*  SOC_SAND_INDIRECT:
*    *soc_pb_regs.
*REMARKS:
*    If the database is not initialized - error will be indicated.
*    soc_pb_is_reg_db_initialized should be called before
*    calling to this function.
*SEE ALSO:
*****************************************************/
uint32
  soc_pb_regs_get(
    SOC_SAND_OUT SOC_PB_REGS  **soc_pb_regs
  );

/*****************************************************
*NAME
*  soc_pb_regs_init
*TYPE:
*  PROC
*FUNCTION:
*  Dynamically allocates and initializes Pb registers database.
*
*INPUT:
*  SOC_SAND_DIRECT:
*    None.
*  SOC_SAND_INDIRECT:
*    None.
*OUTPUT:
*  SOC_SAND_DIRECT:
*    error indication
*  SOC_SAND_INDIRECT:
*    None.
*REMARKS:
*   Calling upon already initialized registers will do nothing
*   User must make sure that this function is called after a semaphore was taken
*SEE ALSO:
*****************************************************/
uint32
  soc_pb_regs_init(void);

SOC_PB_REGS*
  soc_pb_regs(void);

/* } */

#include <soc/dpp/SAND/Utils/sand_footer.h>

/* } __SOC_PB_CHIP_REGS_INCLUDED__*/
#endif

