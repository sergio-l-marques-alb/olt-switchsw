/*
 *         
 * $Id:$
 * 
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *         
 *     
 * DO NOT EDIT THIS FILE!
 *
 */

#ifndef _PORTMOD_H__H_
#define _PORTMOD_H__H_

#include <phymod/phymod.h>
#include <phymod/phymod_diagnostics.h>
#include <soc/portmod/portmod_defs.h>

/*!
 * @enum portmod_dispatch_type_e
 * @brief Supported Drivers 
 */ 
typedef enum portmod_dispatch_type_e {
#ifdef PORTMOD_PM4X25_SUPPORT
    portmodDispatchTypePm4x25,
#endif /*PORTMOD_PM4X25_SUPPORT  */
#ifdef PORTMOD_PM4X10_SUPPORT
    portmodDispatchTypePm4x10,
#endif /*PORTMOD_PM4X10_SUPPORT  */
#ifdef PORTMOD_PM12X10_SUPPORT
    portmodDispatchTypePm12x10,
#endif /*PORTMOD_PM12X10_SUPPORT  */
#ifdef PORTMOD_PM4x10Q_SUPPORT
    portmodDispatchTypePm4x10Q,
#endif /*PORTMOD_PM4x10Q_SUPPORT  */
#ifdef PORTMOD_PM_OS_ILKN_SUPPORT
    portmodDispatchTypePmOsILKN,
#endif /*PORTMOD_PM_OS_ILKN_SUPPORT  */
#ifdef PORTMOD_DNX_FABRIC_SUPPORT
    portmodDispatchTypeDnx_fabric,
#endif /*PORTMOD_DNX_FABRIC_SUPPORT  */
    portmodDispatchTypeCount
} portmod_dispatch_type_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_dispatch_type_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_dispatch_type_t validation */
int portmod_dispatch_type_t_validate(int unit, portmod_dispatch_type_t portmod_dispatch_type);

/*!
 * @struct portmod_default_user_access_s
 * @brief Expected user access structure when using PM default bus 
 */ 
typedef struct portmod_default_user_access_s {
    int unit; /**< Unit that will be used for phy access */
    int blk_id; /**< S-Bus block id */
    int mblk_id; /**< S-Bus mem block id */
    sal_mutex_t mutex; /**< Mutex operation for phy access */
} portmod_default_user_access_t;

/* portmod_default_user_access_t initialization and validation */
int portmod_default_user_access_t_validate(int unit, const portmod_default_user_access_t* portmod_default_user_access);
int portmod_default_user_access_t_init(int unit, portmod_default_user_access_t* portmod_default_user_access);

#define PORTMOD_PCS_8B9B_LFEC _SHR_PORT_PCS_8B9BLFEC
#define PORTMOD_PCS_8B10B _SHR_PORT_PCS_8B10B
#define PORTMOD_PCS_64B66B_FEC _SHR_PORT_PCS_64B66BFEC /**< 64/66b FEC */
#define PORTMOD_PCS_64B66B_BEC _SHR_PORT_PCS_64B66BBEC /**< 64/66b BEC */
#define PORTMOD_PCS_64B66B _SHR_PORT_PCS_64B66B /**< 64/66b without FEC */
#define PORTMOD_PCS_64B66B_RS_FEC _SHR_PORT_PCS_64B66B_RS_FEC /**< 64/66b reed solomon FEC */
#define PORTMOD_PCS_64B66B_LOW_LATENCY_RS_FEC _SHR_PORT_PCS_64B66B_LOW_LATENCY_RS_FEC /**< 64/66b low latency reed solomon FEC */
#define PORTMOD_PCS_UNKNOWN _SHR_PORT_PCS_UNKNOWN /**< unknown pcs */

typedef _shr_port_pcs_t portmod_port_pcs_t;

/*! 
 * @brief Flags for port enable set. no flags means RX+TX for MAC and PHY 
 */ 
#define PORTMOD_PORT_ENABLE_MAC 0x1 /**< enable/disable the MAC(RX/TX according to the flags) */
#define PORTMOD_PORT_ENABLE_PHY 0x2 /**< enable/disable the Serdes (RX/TX according to the flags) */
#define PORTMOD_PORT_ENABLE_TX 0x4 /**< enable/disable TX */
#define PORTMOD_PORT_ENABLE_RX 0x8 /**< enable/disable RX */

#define PORTMOD_PORT_ENABLE_MAC_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_MAC)
#define PORTMOD_PORT_ENABLE_PHY_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_PHY)
#define PORTMOD_PORT_ENABLE_TX_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_TX)
#define PORTMOD_PORT_ENABLE_RX_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_RX)

#define PORTMOD_PORT_ENABLE_MAC_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_MAC)
#define PORTMOD_PORT_ENABLE_PHY_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_PHY)
#define PORTMOD_PORT_ENABLE_TX_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_TX)
#define PORTMOD_PORT_ENABLE_RX_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_RX)

#define PORTMOD_PORT_ENABLE_MAC_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_MAC ? 1 : 0)
#define PORTMOD_PORT_ENABLE_PHY_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_PHY ? 1 : 0)
#define PORTMOD_PORT_ENABLE_TX_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_TX ? 1 : 0)
#define PORTMOD_PORT_ENABLE_RX_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_RX ? 1 : 0)

/*! 
 * @brief properties for portmod_port_encoding_set, portmod_port_encoding_get 
 */ 
#define PORTMOD_ENCODING_LOW_LATENCY_LLFC 0x1
#define PORTMOD_ENCODING_FEC_ERROR_DETECT 0x2 /**< enable/disable the MAC(RX/TX according to the flags) */
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC 0x4 /**< enable/disable the MAC(RX/TX according to the flags) */

#define PORTMOD_ENCODING_LOW_LATENCY_LLFC_SET(properties) ((properties) |= PORTMOD_ENCODING_LOW_LATENCY_LLFC)
#define PORTMOD_ENCODING_FEC_ERROR_DETECT_SET(properties) ((properties) |= PORTMOD_ENCODING_FEC_ERROR_DETECT)
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC_SET(properties) ((properties) |= PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC)

#define PORTMOD_ENCODING_LOW_LATENCY_LLFC_CLR(properties) ((properties) &= ~PORTMOD_ENCODING_LOW_LATENCY_LLFC)
#define PORTMOD_ENCODING_FEC_ERROR_DETECT_CLR(properties) ((properties) &= ~PORTMOD_ENCODING_FEC_ERROR_DETECT)
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC_CLR(properties) ((properties) &= ~PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC)

#define PORTMOD_ENCODING_LOW_LATENCY_LLFC_GET(properties) ((properties) & PORTMOD_ENCODING_LOW_LATENCY_LLFC ? 1 : 0)
#define PORTMOD_ENCODING_FEC_ERROR_DETECT_GET(properties) ((properties) & PORTMOD_ENCODING_FEC_ERROR_DETECT ? 1 : 0)
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC_GET(properties) ((properties) & PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC ? 1 : 0)


/*!
 * @enum portmod_loopback_mode_e
 * @brief looopback modes for portmod_port_loopback_set, portmod_port_loopback_get 
 */ 
typedef enum portmod_loopback_mode_e {
    portmodLoopbackMacOuter = 0,
    portmodLoopbackMacCore = 1,
    portmodLoopbackMacPCS = 2,
    portmodLoopbackMacAsyncFifo = 3,
    portmodLoopbackPhyGloopPCS = 4,
    portmodLoopbackPhyGloopPMD = 5,
    portmodLoopbackPhyRloopPCS = 6, /**< remote PHY loopback in the PCS layer */
    portmodLoopbackPhyRloopPMD = 7, /**< remote PHY loopback in the PMD layer */
    portmodLoopbackCount
} portmod_loopback_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_loopback_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_loopback_mode_t validation */
int portmod_loopback_mode_t_validate(int unit, portmod_loopback_mode_t portmod_loopback_mode);

/*!
 * @struct portmod_port_diag_info_s
 * @brief This structure return port diagnostics information from the PMM 
 */ 
typedef struct portmod_port_diag_info_s {
    int original_port; /**< in case of alias this field will be the original port */
    soc_port_if_t interface; /**< interface type */
    int pm_id; /**< pm id which the port belongs */
    soc_pbmp_t phys; /**< The PHYs that assemble the port */
    int sub_phy; /**< qsgmii only; Sub PHY index */
} portmod_port_diag_info_t;

/* portmod_port_diag_info_t initialization and validation */
int portmod_port_diag_info_t_validate(int unit, const portmod_port_diag_info_t* portmod_port_diag_info);
int portmod_port_diag_info_t_init(int unit, portmod_port_diag_info_t* portmod_port_diag_info);


/*!
 * @struct portmod_pm_diag_info_s
 * @brief PM diagnostics information 
 */ 
typedef struct portmod_pm_diag_info_s {
    portmod_dispatch_type_t type; /**< PM type */
    soc_pbmp_t phys; /**< Which PHYs are connected to the PM */
} portmod_pm_diag_info_t;

/* portmod_pm_diag_info_t initialization and validation */
int portmod_pm_diag_info_t_validate(int unit, const portmod_pm_diag_info_t* portmod_pm_diag_info);
int portmod_pm_diag_info_t_init(int unit, portmod_pm_diag_info_t* portmod_pm_diag_info);


/*!
 * @struct portmod_port_interface_config_s
 * @brief  This structure contains the rate, settings as medium, scrambler en, etc. and flags which allow/forbid the change of PLL/TX parameters/FW configuration/etc. 
 */ 
typedef struct portmod_port_interface_config_s {
    soc_port_if_t interface;
    int speed;
    uint32 interface_modes; /**< see PHYMOD_INTERFACE_MODES_ */
    uint32 flags; /**< see PHYMOD_IF_FLAGS_ */
} portmod_port_interface_config_t;

/* portmod_port_interface_config_t initialization and validation */
int portmod_port_interface_config_t_validate(int unit, const portmod_port_interface_config_t* portmod_port_interface_config);
int portmod_port_interface_config_t_init(int unit, portmod_port_interface_config_t* portmod_port_interface_config);

typedef struct portmod_port_add_info_s {
    portmod_port_interface_config_t interface_config;
    soc_pbmp_t phys;
    int sub_phy; /**< qsgmii only; Sub PHY index */
    uint8 autoneg_en;
    uint8 link_training_en;
} portmod_port_add_info_t;

/* portmod_port_add_info_t initialization and validation */
int portmod_port_add_info_t_validate(int unit, const portmod_port_add_info_t* portmod_port_add_info);
int portmod_port_add_info_t_init(int unit, portmod_port_add_info_t* portmod_port_add_info);


/*!
 * @struct portmod_dnx_fabric_create_info_s
 * @brief Dune Fabric PM specific information required for PM add API. 
 */ 
typedef struct portmod_dnx_fabric_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity[PHYMOD_MAX_LANES_PER_CORE]; /**< Lanes Polarity */
    int fmac_schan_id; /**< FMAC schan id */
    int fsrd_schan_id; /**< FSRD schan id */
    int fsrd_internal_quad; /**< Core instance in FSRD */
} portmod_dnx_fabric_create_info_t;

/* portmod_dnx_fabric_create_info_t initialization and validation */
int portmod_dnx_fabric_create_info_t_validate(int unit, const portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info);
int portmod_dnx_fabric_create_info_t_init(int unit, portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info);


/*!
 * @struct portmod_pm4x25_create_info_s
 * @brief PM4X25 specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x25_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity[PHYMOD_MAX_LANES_PER_CORE]; /**< Lanes Polarity */
    uint8 in_pm_12x10; /**< is the PM part of a PM12x10 block */
} portmod_pm4x25_create_info_t;

/* portmod_pm4x25_create_info_t initialization and validation */
int portmod_pm4x25_create_info_t_validate(int unit, const portmod_pm4x25_create_info_t* portmod_pm4x25_create_info);
int portmod_pm4x25_create_info_t_init(int unit, portmod_pm4x25_create_info_t* portmod_pm4x25_create_info);


/*!
 * @struct portmod_pm4x10_create_info_s
 * @brief PM4X10 specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x10_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity[PHYMOD_MAX_LANES_PER_CORE]; /**< Lanes Polarity */
    uint8 in_pm_12x10; /**< is the PM part of a PM12x10 block */
} portmod_pm4x10_create_info_t;

/* portmod_pm4x10_create_info_t initialization and validation */
int portmod_pm4x10_create_info_t_validate(int unit, const portmod_pm4x10_create_info_t* portmod_pm4x10_create_info);
int portmod_pm4x10_create_info_t_init(int unit, portmod_pm4x10_create_info_t* portmod_pm4x10_create_info);


/*!
 * @struct portmod_pm12x10_create_info_s
 * @brief PM12X10 specific information required for PM add API. 
 */ 
typedef struct portmod_pm12x10_create_info_s {
    portmod_pm4x10_create_info_t pm4x10_infos[3]; /**< initialization information for the three pm4x10 in the pm12x10 */
} portmod_pm12x10_create_info_t;

/* portmod_pm12x10_create_info_t initialization and validation */
int portmod_pm12x10_create_info_t_validate(int unit, const portmod_pm12x10_create_info_t* portmod_pm12x10_create_info);
int portmod_pm12x10_create_info_t_init(int unit, portmod_pm12x10_create_info_t* portmod_pm12x10_create_info);


/*!
 * @struct portmod_pm4x10q_create_info_s
 * @brief PM4X10Q specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x10q_create_info_s {
    portmod_pm4x10_create_info_t pm4x10_info; /**< initialization information for the pm4x10 in the pm4x10Q */
} portmod_pm4x10q_create_info_t;

/* portmod_pm4x10q_create_info_t initialization and validation */
int portmod_pm4x10q_create_info_t_validate(int unit, const portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info);
int portmod_pm4x10q_create_info_t_init(int unit, portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info);


/*!
 * @struct portmod_pm_identifier_s
 * @brief This struct defines specific PM 
 */ 
typedef struct portmod_pm_identifier_s {
    portmod_dispatch_type_t type; /**< PM type */
    int phy; /**< First PHY of the PM */
} portmod_pm_identifier_t;

/* portmod_pm_identifier_t initialization and validation */
int portmod_pm_identifier_t_validate(int unit, const portmod_pm_identifier_t* portmod_pm_identifier);
int portmod_pm_identifier_t_init(int unit, portmod_pm_identifier_t* portmod_pm_identifier);


/*!
 * @struct portmod_ilkn_os_create_info_s
 * @brief Open Silicon ILKN information required for PM add API. 
 */ 
typedef struct portmod_ilkn_os_create_info_s {
    int nof_aggregated_pms; /**< Number of PMs controlled by this ILKN PM */
    portmod_pm_identifier_t* controlled_pms; /**< Array of PMs controlled by this ILKN PM */
} portmod_ilkn_os_create_info_t;

/* portmod_ilkn_os_create_info_t initialization and validation */
int portmod_ilkn_os_create_info_t_validate(int unit, const portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info);
int portmod_ilkn_os_create_info_t_init(int unit, portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info);

typedef union portmod_pm_specific_create_info_u {
    portmod_pm4x10_create_info_t pm4x10;
    portmod_pm4x10q_create_info_t pm4x10q;
    portmod_pm4x25_create_info_t pm4x25;
    portmod_pm12x10_create_info_t pm12x10;
    portmod_ilkn_os_create_info_t os_ilkn;
    portmod_dnx_fabric_create_info_t dnx_fabric;
} portmod_pm_specific_create_info_t;


/*!
 * @struct portmod_remote_fault_control_s
 * @brief  This struct contains the parameters that  
 */ 
typedef struct portmod_remote_fault_control_s {
    uint8 enable; /**< enable/disable processing of local fault messages */
    uint8 drop_tx_on_fault; /**< drop tx data in case of fault */
} portmod_remote_fault_control_t;

/* portmod_remote_fault_control_t initialization and validation */
int portmod_remote_fault_control_t_validate(int unit, const portmod_remote_fault_control_t* portmod_remote_fault_control);
int portmod_remote_fault_control_t_init(int unit, portmod_remote_fault_control_t* portmod_remote_fault_control);

typedef struct portmod_local_fault_control_s {
    uint8 enable; /**< enable/disable processing of remote fault messages */
    uint8 drop_tx_on_fault; /**< drop tx data in case of fault */
} portmod_local_fault_control_t;

/* portmod_local_fault_control_t initialization and validation */
int portmod_local_fault_control_t_validate(int unit, const portmod_local_fault_control_t* portmod_local_fault_control);
int portmod_local_fault_control_t_init(int unit, portmod_local_fault_control_t* portmod_local_fault_control);


/*!
 * @struct portmod_llfc_control_s
 * @brief  link level flow control configuration 
 */ 
typedef struct portmod_llfc_control_s {
    uint8 rx_enable; /**< enable LLFX in RX path */
    uint8 tx_enable; /**< enable LLFX in TX path */
    uint8 crc_ignore;
    uint8 in_ipg_only; /**< llfc messages will be inserted only during IPG */
} portmod_llfc_control_t;

/* portmod_llfc_control_t initialization and validation */
int portmod_llfc_control_t_validate(int unit, const portmod_llfc_control_t* portmod_llfc_control);
int portmod_llfc_control_t_init(int unit, portmod_llfc_control_t* portmod_llfc_control);


/*!
 * @struct portmod_pfc_control_s
 * @brief  priority flow control configuration 
 */ 
typedef struct portmod_pfc_control_s {
    uint8 rx_enable;
    uint8 tx_enable;
    uint8 stats_en; /**< enable PFC counters */
    uint8 force_xon; /**< Instructs MAC to send Xon message to all classes of service */
    int refresh_timer; /**< use -1 for disable this feature; Threshold for pause timer to cause XOFF to be resent */
    int xoff_timer; /**< Time value sent in the Timer Field for classes in XOFF state */
} portmod_pfc_control_t;

/* portmod_pfc_control_t initialization and validation */
int portmod_pfc_control_t_validate(int unit, const portmod_pfc_control_t* portmod_pfc_control);
int portmod_pfc_control_t_init(int unit, portmod_pfc_control_t* portmod_pfc_control);


/*!
 * @struct portmod_pause_control_s
 * @brief  pause flow control configuration 
 */ 
typedef struct portmod_pause_control_s {
    uint8 rx_enable;
    uint8 tx_enable;
    int refresh_timer; /**< use -1 for disable this feature; Threshold for pause timer to cause XOFF to be resent */
    int xoff_timer; /**< Time value sent in the Timer Field for classes in XOFF state */
} portmod_pause_control_t;

/* portmod_pause_control_t initialization and validation */
int portmod_pause_control_t_validate(int unit, const portmod_pause_control_t* portmod_pause_control);
int portmod_pause_control_t_init(int unit, portmod_pause_control_t* portmod_pause_control);


/*!
 * @struct portmod_pm_create_info_s
 * @brief This struct contains the required information in order to add new PM to the PMM and create PM DB. 
 */ 
typedef struct portmod_pm_create_info_s {
    portmod_dispatch_type_t type; /**< PM type */
    int first_blk_id; /**< block id */
    soc_pbmp_t phys; /**< which PHYs belongs to the PM */
    portmod_pm_specific_create_info_t pm_specific_info;
} portmod_pm_create_info_t;

/* portmod_pm_create_info_t initialization and validation */
int portmod_pm_create_info_t_validate(int unit, const portmod_pm_create_info_t* portmod_pm_create_info);
int portmod_pm_create_info_t_init(int unit, portmod_pm_create_info_t* portmod_pm_create_info);

#define PORTMOD_SIDE_SYSTEM (0)
#define PORTMOD_SIDE_LINE (1)

#define PORTMOD_PHYN_LAST_ONE (-1)


/*!
 * @struct portmod_access_get_params_s
 * @brief This struct used to select the access structure that will return from port_phy_lane_access_get 
 */ 
typedef struct portmod_access_get_params_s {
    int phyn; /**< hop number. 0-internal phy. 1 and up- external phys. -1 means the last one */
    int sys_side; /**< sys/line side.values: PORTMOD_SIDE_LINE, PORTMOD_SIDE_SYSTEM */
    int lane; /**< specific lane index. -1 means return all lanes */
} portmod_access_get_params_t;

/* portmod_access_get_params_t initialization and validation */
int portmod_access_get_params_t_validate(int unit, const portmod_access_get_params_t* portmod_access_get_params);
int portmod_access_get_params_t_init(int unit, portmod_access_get_params_t* portmod_access_get_params);


/*!
 * @struct portmod_pm_instances_s
 * @brief This struct contains information about number of instances for PM type 
 */ 
typedef struct portmod_pm_instances_s {
    portmod_dispatch_type_t type; /**< Port Macro type */
    int instances; /**< the number of instances of the specified Port Macro type */
} portmod_pm_instances_t;

/* portmod_pm_instances_t initialization and validation */
int portmod_pm_instances_t_validate(int unit, const portmod_pm_instances_t* portmod_pm_instances);
int portmod_pm_instances_t_init(int unit, portmod_pm_instances_t* portmod_pm_instances);

/*! 
 * portmod_create
 *
 * @brief Allocate PMM memory for the specified unit.
                Should be recalled in case of Warm Boot 
 *
 * @param [in]  unit            - unit id
 * @param [in]  max_ports       - Max ports that should be supported in portmod for the specified unit
 * @param [in]  max_phys        - Max PHYs that should be supported in portmod for the specified unit
 * @param [in]  nof_pm_instances   - Number of elements of the pm_instances array
 * @param [in]  pm_instances    - 
 */
int portmod_create(int unit, int max_ports, int max_phys, int nof_pm_instances, const portmod_pm_instances_t* pm_instances);

/*! 
 * portmod_destroy
 *
 * @brief Release unit PMM resources. 
 *
 * @param [in]  unit            - unit id
 */
int portmod_destroy(int unit);

/*! 
 * portmod_port_macro_add
 *
 * @brief Add new port macro to the unit PMM; <br> In case of warm boot should be re called in the same order as called in cold boot  
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_info         - 
 */
int portmod_port_macro_add(int unit, const portmod_pm_create_info_t* pm_info);




/*! 
 * portmod_port_add
 *
 * @brief Add new port. Add the port to the PM DB. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  add_info        - 
 */
int portmod_port_add(int unit, int port, const portmod_port_add_info_t* add_info);



/*! 
 * portmod_port_remove
 *
 * @brief Remove the port from the PM and PMM. 
            portmod_port_enable_set(unit, port, 0); should be called before 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_remove(int unit, int port);


/*! 
 * portmod_port_first_phy_get
 *
 * @brief get the first phy of the specified port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  phy             - 
 * @param [out]  sub_phy         - 
 */
int portmod_port_first_phy_get(int unit, int port, int* phy, int* sub_phy);

/*! 
 * portmod_port_enable_set
 *
 * @brief Port enable 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  flags           - see PORTMOD_PORT_ENABLE_...
 * @param [in]  enable          - 
 */
int portmod_port_enable_set(int unit, int port, int flags, int enable);
/*! 
 * portmod_port_enable_get
 *
 * @brief Port enable 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  flags           - see PORTMOD_PORT_ENABLE_...
 * @param [out]  enable          - 
 */
int portmod_port_enable_get(int unit, int port, int flags, int* enable);

/*! 
 * portmod_port_interface_config_set
 *
 * @brief set/get the interface, speed and encapsulation for the specified port.
            For the First port within core this function initialize the PM, MAC and PHY before configure the port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 */
int portmod_port_interface_config_set(int unit, int port, const portmod_port_interface_config_t* config);
/*! 
 * portmod_port_interface_config_get
 *
 * @brief set/get the interface, speed and encapsulation for the specified port.
            For the First port within core this function initialize the PM, MAC and PHY before configure the port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config          - 
 */
int portmod_port_interface_config_get(int unit, int port, portmod_port_interface_config_t* config);

/*! 
 * portmod_port_encoding_set
 *
 * @brief chage port PCS encoding  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  properties      - 
 * @param [in]  encoding        - 
 */
int portmod_port_encoding_set(int unit, int port, uint32 properties, portmod_port_pcs_t encoding);
/*! 
 * portmod_port_encoding_get
 *
 * @brief chage port PCS encoding  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  properties      - 
 * @param [out]  encoding        - 
 */
int portmod_port_encoding_get(int unit, int port, uint32* properties, portmod_port_pcs_t* encoding);

/*! 
 * portmod_port_cl72_set
 *
 * @brief Port cl72 set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_cl72_set(int unit, int port, int enable);
/*! 
 * portmod_port_cl72_get
 *
 * @brief Port cl72 set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_cl72_get(int unit, int port, int* enable);

/*! 
 * portmod_port_loopback_set
 *
 * @brief Port speed set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  loopback_type   - 
 * @param [in]  enable          - 
 */
int portmod_port_loopback_set(int unit, int port, portmod_loopback_mode_t loopback_type, int enable);
/*! 
 * portmod_port_loopback_get
 *
 * @brief Port speed set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  loopback_type   - 
 * @param [out]  enable          - 
 */
int portmod_port_loopback_get(int unit, int port, portmod_loopback_mode_t loopback_type, int* enable);

/*! 
 * portmod_port_ability_local_get
 *
 * @brief get port auto negotiation local ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ability         - 
 */
int portmod_port_ability_local_get(int unit, int port, const portmod_port_ability_t* ability);

/*! 
 * portmod_port_autoneg_set
 *
 * @brief Set/Get autoneg 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  an              - 
 */
int portmod_port_autoneg_set(int unit, int port, const phymod_autoneg_control_t* an);
/*! 
 * portmod_port_autoneg_get
 *
 * @brief Set/Get autoneg 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  an              - 
 */
int portmod_port_autoneg_get(int unit, int port, phymod_autoneg_control_t* an);

/*! 
 * portmod_port_link_get
 *
 * @brief get link status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  link            - link indication up/down
 */
int portmod_port_link_get(int unit, int port, int* link);

/*! 
 * portmod_port_prbs_config_set
 *
 * @brief PRBS configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [in]  config          - PRBS configuration
 */
int portmod_port_prbs_config_set(int unit, int port, int mode, int flags, const phymod_prbs_t* config);
/*! 
 * portmod_port_prbs_config_get
 *
 * @brief PRBS configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [out]  config          - PRBS configuration
 */
int portmod_port_prbs_config_get(int unit, int port, int mode, int flags, phymod_prbs_t* config);

/*! 
 * portmod_port_prbs_enable_set
 *
 * @brief PRBS enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [in]  enable          - 
 */
int portmod_port_prbs_enable_set(int unit, int port, int mode, int flags, int enable);
/*! 
 * portmod_port_prbs_enable_get
 *
 * @brief PRBS enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [out]  enable          - 
 */
int portmod_port_prbs_enable_get(int unit, int port, int mode, int flags, int* enable);

/*! 
 * portmod_port_prbs_status_get
 *
 * @brief PRBS status get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - see PHYMOD_PRBS_STATUS_FLAGS_
 * @param [out]  status          - 
 */
int portmod_port_prbs_status_get(int unit, int port, int mode, int flags, phymod_prbs_status_t* status);

/*! 
 * portmod_port_nof_lanes_set
 *
 * @brief Number of lanes set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  nof_lanes       - 
 */
int portmod_port_nof_lanes_set(int unit, int port, int nof_lanes);
/*! 
 * portmod_port_nof_lanes_get
 *
 * @brief Number of lanes set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  nof_lanes       - 
 */
int portmod_port_nof_lanes_get(int unit, int port, int* nof_lanes);

/*! 
 * portmod_ilkn_retranstmit_config_set
 *
 * @brief ILKN retransmit configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  retransmit_config   - 
 */
int portmod_ilkn_retranstmit_config_set(int unit, int port, const ilkn_retransmit_config_t* retransmit_config);
/*! 
 * portmod_ilkn_retranstmit_config_get
 *
 * @brief ILKN retransmit configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  retransmit_config   - 
 */
int portmod_ilkn_retranstmit_config_get(int unit, int port, ilkn_retransmit_config_t* retransmit_config);

/*! 
 * portmod_port_lanes_assign
 *
 * @brief assign lane map to specific port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  assign_map      - 
 */
int portmod_port_lanes_assign(int unit, int port, const portmod_lanes_assign_info_t* assign_map);

/*! 
 * portmod_port_lanes_retrieve
 *
 * @brief retrieve lane map of specific port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  assign_map      - 
 */
int portmod_port_lanes_retrieve(int unit, int port, portmod_lanes_assign_info_t* assign_map);

/*! 
 * portmod_port_firmware_mode_set
 *
 * @brief Set port PHYs' firmware mode 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  fw_mode         - 
 */
int portmod_port_firmware_mode_set(int unit, int port, phymod_firmware_mode_t fw_mode);
/*! 
 * portmod_port_firmware_mode_get
 *
 * @brief Set port PHYs' firmware mode 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  fw_mode         - 
 */
int portmod_port_firmware_mode_get(int unit, int port, phymod_firmware_mode_t* fw_mode);

/*! 
 * portmod_port_runt_threshold_set
 *
 * @brief Filter packets smaller than the specified threshold 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - packets smaller than the specified values will be filtered
 */
int portmod_port_runt_threshold_set(int unit, int port, int value);
/*! 
 * portmod_port_runt_threshold_get
 *
 * @brief Filter packets smaller than the specified threshold 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - packets smaller than this value are filtered
 */
int portmod_port_runt_threshold_get(int unit, int port, int* value);

/*! 
 * portmod_port_max_packet_size_set
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - the max packet size
 */
int portmod_port_max_packet_size_set(int unit, int port, int value);
/*! 
 * portmod_port_max_packet_size_get
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - the max packet size
 */
int portmod_port_max_packet_size_get(int unit, int port, int* value);

/*! 
 * portmod_port_pad_size_set
 *
 * @brief TX pad packets to the specified size. values smaller than 17 means pad is disabled. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_pad_size_set(int unit, int port, int value);
/*! 
 * portmod_port_pad_size_get
 *
 * @brief TX pad packets to the specified size. values smaller than 17 means pad is disabled. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_pad_size_get(int unit, int port, int* value);

/*! 
 * portmod_port_tx_mac_sa_set
 *
 * @brief set/get the MAC source address that will be sent in case of Pause/LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mac_sa          - 
 */
int portmod_port_tx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa);
/*! 
 * portmod_port_tx_mac_sa_get
 *
 * @brief set/get the MAC source address that will be sent in case of Pause/LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mac_sa          - 
 */
int portmod_port_tx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa);

/*! 
 * portmod_port_rx_mac_sa_set
 *
 * @brief set/get SA recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mac_sa          - 
 */
int portmod_port_rx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa);
/*! 
 * portmod_port_rx_mac_sa_get
 *
 * @brief set/get SA recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mac_sa          - 
 */
int portmod_port_rx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa);

/*! 
 * portmod_port_tx_average_ipg_set
 *
 * @brief set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_tx_average_ipg_set(int unit, int port, int value);
/*! 
 * portmod_port_tx_average_ipg_get
 *
 * @brief set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_tx_average_ipg_get(int unit, int port, int* value);

/*! 
 * portmod_port_tx_preamble_length_set
 *
 * @brief set/get Number of preamble bytes for transmit IEEE packets; this value should include the K.SOP and SFD character as well 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_tx_preamble_length_set(int unit, int port, int value);
/*! 
 * portmod_port_tx_preamble_length_get
 *
 * @brief set/get Number of preamble bytes for transmit IEEE packets; this value should include the K.SOP and SFD character as well 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_tx_preamble_length_get(int unit, int port, int* value);

/*! 
 * portmod_port_local_fault_control_set
 *
 * @brief local fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_local_fault_control_set(int unit, int port, const portmod_local_fault_control_t* control);
/*! 
 * portmod_port_local_fault_control_get
 *
 * @brief local fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_local_fault_control_get(int unit, int port, portmod_local_fault_control_t* control);

/*! 
 * portmod_port_remote_fault_control_set
 *
 * @brief remote fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_remote_fault_control_set(int unit, int port, const portmod_remote_fault_control_t* control);
/*! 
 * portmod_port_remote_fault_control_get
 *
 * @brief remote fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_remote_fault_control_get(int unit, int port, portmod_remote_fault_control_t* control);

/*! 
 * portmod_port_local_fault_status_get
 *
 * @brief local fault steatus get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_local_fault_status_get(int unit, int port, int* value);

/*! 
 * portmod_port_remote_fault_status_get
 *
 * @brief remote fault status get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_remote_fault_status_get(int unit, int port, int* value);

/*! 
 * portmod_port_local_fault_status_clear
 *
 * @brief local fault steatus clear 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_local_fault_status_clear(int unit, int port);

/*! 
 * portmod_port_remote_fault_status_clear
 *
 * @brief remote fault status clear 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_remote_fault_status_clear(int unit, int port);

/*! 
 * portmod_port_pause_control_set
 *
 * @brief set/get Pause FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_pause_control_set(int unit, int port, const portmod_pause_control_t* control);
/*! 
 * portmod_port_pause_control_get
 *
 * @brief set/get Pause FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_pause_control_get(int unit, int port, portmod_pause_control_t* control);

/*! 
 * portmod_port_pfc_control_set
 *
 * @brief set/get PFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_pfc_control_set(int unit, int port, const portmod_pfc_control_t* control);
/*! 
 * portmod_port_pfc_control_get
 *
 * @brief set/get PFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_pfc_control_get(int unit, int port, portmod_pfc_control_t* control);

/*! 
 * portmod_port_llfc_control_set
 *
 * @brief set/get LLFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_llfc_control_set(int unit, int port, const portmod_llfc_control_t* control);
/*! 
 * portmod_port_llfc_control_get
 *
 * @brief set/get LLFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_llfc_control_get(int unit, int port, portmod_llfc_control_t* control);

/*! 
 * portmod_port_core_access_get
 *
 * @brief get port cores' phymod access 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phyn            - the number of hops from the internal phy. 0 - internal, 1- first external PHY, etc.
 * @param [in]  max_cores       - the output array number of elements
 * @param [out]  core_access_arr   - port phymod cores array
 * @param [out]  nof_cores       - number of core access structutres filled by the function
 */
int portmod_port_core_access_get(int unit, int port, int phyn, int max_cores, phymod_core_access_t* core_access_arr, int* nof_cores);

/*! 
 * portmod_port_phy_lane_access_get
 *
 * @brief Get lane phymod access structure. can be used for per lane operations 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  params          - 
 * @param [in]  max_phys        - the output array number of elements
 * @param [out]  access          - 
 * @param [out]  nof_phys        - number of phy access structutres filled by the function
 */
int portmod_port_phy_lane_access_get(int unit, int port, const portmod_access_get_params_t* params, int max_phys, phymod_phy_access_t* access, int* nof_phys);

/*! 
 * portmod_pm_diag_info_get
 *
 * @brief get PM diag info 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - pm id
 * @param [out]  diag_info       - 
 */
int portmod_pm_diag_info_get(int unit, int pm_id, portmod_pm_diag_info_t* diag_info);

/*! 
 * portmod_port_diag_info_get
 *
 * @brief get port diag info 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  diag_info       - 
 */
int portmod_port_diag_info_get(int unit, int port, portmod_port_diag_info_t* diag_info);

#endif /*_PORTMOD_H_*/
