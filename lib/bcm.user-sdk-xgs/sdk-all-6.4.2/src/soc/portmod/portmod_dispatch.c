/*
 *         
 * $Id:$
 * 
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *         
 *     
 * DO NOT EDIT THIS FILE!
 *
 */

#include <soc/types.h>
#include <soc/error.h>
#include <soc/portmod/portmod_internal.h>
#include <soc/portmod/portmod.h>
#include <soc/portmod/portmod_dispatch.h>


        
#ifdef _ERR_MSG_MODULE_NAME 
#error "_ERR_MSG_MODULE_NAME redefined" 
#endif
#define _ERR_MSG_MODULE_NAME BSL_LS_SOC_PORT

#ifdef PORTMOD_PM4X25_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x25_driver;
#endif
#ifdef PORTMOD_PM4X10_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x10_driver;
#endif
#ifdef PORTMOD_PM12X10_SUPPORT
extern __portmod__dispatch__t__ portmod_pm12x10_driver;
#endif
#ifdef PORTMOD_PM4x10Q_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x10Q_driver;
#endif
#ifdef PORTMOD_PM_OS_ILKN_SUPPORT
extern __portmod__dispatch__t__ portmod_pmOsILKN_driver;
#endif
#ifdef PORTMOD_DNX_FABRIC_SUPPORT
extern __portmod__dispatch__t__ portmod_dnx_fabric_driver;
#endif

__portmod__dispatch__t__* __portmod__dispatch__[portmodDispatchTypeCount] = {
#ifdef PORTMOD_PM4X25_SUPPORT
    &portmod_pm4x25_driver,
#endif
#ifdef PORTMOD_PM4X10_SUPPORT
    &portmod_pm4x10_driver,
#endif
#ifdef PORTMOD_PM12X10_SUPPORT
    &portmod_pm12x10_driver,
#endif
#ifdef PORTMOD_PM4x10Q_SUPPORT
    &portmod_pm4x10Q_driver,
#endif
#ifdef PORTMOD_PM_OS_ILKN_SUPPORT
    &portmod_pmOsILKN_driver,
#endif
#ifdef PORTMOD_DNX_FABRIC_SUPPORT
    &portmod_dnx_fabric_driver,
#endif

};

int portmod_dispatch_type_t_validate(int unit, portmod_dispatch_type_t portmod_dispatch_type)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_dispatch_type >= portmodDispatchTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_default_user_access_t_validate(int unit, const portmod_default_user_access_t* portmod_default_user_access)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_default_user_access == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_default_user_access_t_init(int unit, portmod_default_user_access_t* portmod_default_user_access)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_default_user_access == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_default_user_access NULL parameter"));
    }
    portmod_default_user_access->unit = -1;
    portmod_default_user_access->blk_id = -1;
    portmod_default_user_access->mblk_id = -1;
    portmod_default_user_access->mutex = NULL;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_loopback_mode_t_validate(int unit, portmod_loopback_mode_t portmod_loopback_mode)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_loopback_mode >= portmodLoopbackCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_diag_info_t_validate(int unit, const portmod_port_diag_info_t* portmod_port_diag_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_diag_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_diag_info_t_init(int unit, portmod_port_diag_info_t* portmod_port_diag_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_diag_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_diag_info NULL parameter"));
    }
    portmod_port_diag_info->interface = phymodInterfaceCount;
    SOC_PBMP_CLEAR(portmod_port_diag_info->phys);
    portmod_port_diag_info->sub_phy = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_diag_info_t_validate(int unit, const portmod_pm_diag_info_t* portmod_pm_diag_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_diag_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_diag_info->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_diag_info_t_init(int unit, portmod_pm_diag_info_t* portmod_pm_diag_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_diag_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_diag_info NULL parameter"));
    }
    portmod_pm_diag_info->type = portmodDispatchTypeCount;
    SOC_PBMP_CLEAR(portmod_pm_diag_info->phys);

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_interface_config_t_validate(int unit, const portmod_port_interface_config_t* portmod_port_interface_config)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_interface_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_interface_config_t_init(int unit, portmod_port_interface_config_t* portmod_port_interface_config)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_interface_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_interface_config NULL parameter"));
    }
    portmod_port_interface_config->interface = SOC_PORT_IF_NULL;
    portmod_port_interface_config->speed = 0;
    portmod_port_interface_config->interface_modes = 0;
    portmod_port_interface_config->flags = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_add_info_t_validate(int unit, const portmod_port_add_info_t* portmod_port_add_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_add_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, &portmod_port_add_info->interface_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface_config validation failed"));
    }

    switch(portmod_port_add_info->sub_phy) {
        case 0:
        case 1:
        case 2:
        case 3:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("sub_phy not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_add_info_t_init(int unit, portmod_port_add_info_t* portmod_port_add_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_add_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_add_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_interface_config_t_init(unit, &portmod_port_add_info->interface_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface_config initialization failed"));
    }

    SOC_PBMP_CLEAR(portmod_port_add_info->phys);
    portmod_port_add_info->sub_phy = 0;
    portmod_port_add_info->autoneg_en = 0;
    portmod_port_add_info->link_training_en = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_dnx_fabric_create_info_t_validate(int unit, const portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_dnx_fabric_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_dnx_fabric_create_info_t_init(int unit, portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_dnx_fabric_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_dnx_fabric_create_info NULL parameter"));
    }
    portmod_dnx_fabric_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_dnx_fabric_create_info->access);
    phymod_lane_map_t_init(&portmod_dnx_fabric_create_info->lane_map);
    portmod_dnx_fabric_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_dnx_fabric_create_info->external_fw_loader = NULL;
    portmod_dnx_fabric_create_info->fmac_schan_id = -1;
    portmod_dnx_fabric_create_info->fsrd_schan_id = -1;
    portmod_dnx_fabric_create_info->fsrd_internal_quad = -1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x25_create_info_t_validate(int unit, const portmod_pm4x25_create_info_t* portmod_pm4x25_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x25_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_pm4x25_create_info->in_pm_12x10) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("in_pm_12x10 not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x25_create_info_t_init(int unit, portmod_pm4x25_create_info_t* portmod_pm4x25_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x25_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x25_create_info NULL parameter"));
    }
    portmod_pm4x25_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm4x25_create_info->access);
    phymod_lane_map_t_init(&portmod_pm4x25_create_info->lane_map);
    portmod_pm4x25_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm4x25_create_info->external_fw_loader = NULL;
    portmod_pm4x25_create_info->in_pm_12x10 = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10_create_info_t_validate(int unit, const portmod_pm4x10_create_info_t* portmod_pm4x10_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x10_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_pm4x10_create_info->in_pm_12x10) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("in_pm_12x10 not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10_create_info_t_init(int unit, portmod_pm4x10_create_info_t* portmod_pm4x10_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x10_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x10_create_info NULL parameter"));
    }
    portmod_pm4x10_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm4x10_create_info->access);
    phymod_lane_map_t_init(&portmod_pm4x10_create_info->lane_map);
    portmod_pm4x10_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm4x10_create_info->external_fw_loader = NULL;
    portmod_pm4x10_create_info->in_pm_12x10 = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm12x10_create_info_t_validate(int unit, const portmod_pm12x10_create_info_t* portmod_pm12x10_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm12x10_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm12x10_create_info_t_init(int unit, portmod_pm12x10_create_info_t* portmod_pm12x10_create_info)
{
    int _array_iter;

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm12x10_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm12x10_create_info NULL parameter"));
    }
    for(_array_iter = 0 ; _array_iter < 3 ; _array_iter++){
        if(SOC_E_NONE != portmod_pm4x10_create_info_t_init(unit, &portmod_pm12x10_create_info->pm4x10_infos[_array_iter])) {
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_infos initialization failed"));
        }
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_create_info_t_validate(int unit, const portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x10q_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm4x10_create_info_t_validate(unit, &portmod_pm4x10q_create_info->pm4x10_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_create_info_t_init(int unit, portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x10q_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x10q_create_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pm4x10_create_info_t_init(unit, &portmod_pm4x10q_create_info->pm4x10_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_info initialization failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_identifier_t_validate(int unit, const portmod_pm_identifier_t* portmod_pm_identifier)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_identifier == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_identifier->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_identifier_t_init(int unit, portmod_pm_identifier_t* portmod_pm_identifier)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_identifier == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_identifier NULL parameter"));
    }
    portmod_pm_identifier->type = portmodDispatchTypeCount;
    portmod_pm_identifier->phy = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ilkn_os_create_info_t_validate(int unit, const portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_ilkn_os_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm_identifier_t_validate(unit, portmod_ilkn_os_create_info->controlled_pms)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("controlled_pms validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ilkn_os_create_info_t_init(int unit, portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_ilkn_os_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_ilkn_os_create_info NULL parameter"));
    }
    portmod_ilkn_os_create_info->nof_aggregated_pms = phymodRefClkCount;
    portmod_ilkn_os_create_info->controlled_pms = NULL;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_remote_fault_control_t_validate(int unit, const portmod_remote_fault_control_t* portmod_remote_fault_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_remote_fault_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_remote_fault_control_t_init(int unit, portmod_remote_fault_control_t* portmod_remote_fault_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_remote_fault_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_remote_fault_control NULL parameter"));
    }
    portmod_remote_fault_control->enable = 0;
    portmod_remote_fault_control->drop_tx_on_fault = 1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_local_fault_control_t_validate(int unit, const portmod_local_fault_control_t* portmod_local_fault_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_local_fault_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_local_fault_control_t_init(int unit, portmod_local_fault_control_t* portmod_local_fault_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_local_fault_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_local_fault_control NULL parameter"));
    }
    portmod_local_fault_control->enable = 0;
    portmod_local_fault_control->drop_tx_on_fault = 1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_llfc_control_t_validate(int unit, const portmod_llfc_control_t* portmod_llfc_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_llfc_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_llfc_control_t_init(int unit, portmod_llfc_control_t* portmod_llfc_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_llfc_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_llfc_control NULL parameter"));
    }
    portmod_llfc_control->rx_enable = 1;
    portmod_llfc_control->tx_enable = 1;
    portmod_llfc_control->crc_ignore = 0;
    portmod_llfc_control->in_ipg_only = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_control_t_validate(int unit, const portmod_pfc_control_t* portmod_pfc_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pfc_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_control_t_init(int unit, portmod_pfc_control_t* portmod_pfc_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pfc_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pfc_control NULL parameter"));
    }
    portmod_pfc_control->rx_enable = 0;
    portmod_pfc_control->tx_enable = 0;
    portmod_pfc_control->stats_en = 1;
    portmod_pfc_control->force_xon = 0;
    portmod_pfc_control->refresh_timer = -1;
    portmod_pfc_control->xoff_timer = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pause_control_t_validate(int unit, const portmod_pause_control_t* portmod_pause_control)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pause_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pause_control_t_init(int unit, portmod_pause_control_t* portmod_pause_control)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pause_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pause_control NULL parameter"));
    }
    portmod_pause_control->rx_enable = 0;
    portmod_pause_control->tx_enable = 0;
    portmod_pause_control->refresh_timer = 0xc000;
    portmod_pause_control->xoff_timer = 0xFFFF;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_create_info_t_validate(int unit, const portmod_pm_create_info_t* portmod_pm_create_info)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_create_info->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_create_info_t_init(int unit, portmod_pm_create_info_t* portmod_pm_create_info)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_create_info NULL parameter"));
    }
    portmod_pm_create_info->type = portmodDispatchTypeCount;
    portmod_pm_create_info->first_blk_id = -1;
    SOC_PBMP_CLEAR(portmod_pm_create_info->phys);
    sal_memset(&(portmod_pm_create_info->pm_specific_info), 0, sizeof(portmod_pm_specific_create_info_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_access_get_params_t_validate(int unit, const portmod_access_get_params_t* portmod_access_get_params)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_access_get_params == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_access_get_params->sys_side) {
        case PORTMOD_SIDE_LINE:
        case  PORTMOD_SIDE_SYSTEM:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("sys_side not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_access_get_params_t_init(int unit, portmod_access_get_params_t* portmod_access_get_params)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_access_get_params == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_access_get_params NULL parameter"));
    }
    portmod_access_get_params->phyn = -1;
    portmod_access_get_params->sys_side = PORTMOD_SIDE_LINE;
    portmod_access_get_params->lane = -1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_instances_t_validate(int unit, const portmod_pm_instances_t* portmod_pm_instances)
{
        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_instances == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_instances->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_instances_t_init(int unit, portmod_pm_instances_t* portmod_pm_instances)
{

        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_instances == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_instances NULL parameter"));
    }
    portmod_pm_instances->type = portmodDispatchTypeCount;
    portmod_pm_instances->instances = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_interface_type_is_supported(int unit, pm_info_t pm_info, soc_port_if_t interface, int* is_supported)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(is_supported == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("is_supported NULL parameter"));
    }
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_interface_type_is_supported) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_interface_type_is_supported(unit, interface, is_supported);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_interface_type_is_supported isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_init(int unit, const portmod_pm_create_info_internal_t* pm_add_info, int wb_buffer_index, pm_info_t pm_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_add_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_init) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_init(unit, pm_add_info, wb_buffer_index, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_init isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_destroy(int unit, pm_info_t pm_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_destroy) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_destroy(unit, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_destroy isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_attach(int unit, int port, const portmod_port_add_info_t* add_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_add_info_t_validate(unit, add_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("add_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_attach) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_attach(unit, port, pm_info, add_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_attach isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_bypass_set(int unit, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, enable, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_bypass_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, enable, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_bypass_set(unit, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_bypass_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_detach(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_detach) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_detach(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_detach isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_enable_set(int unit, int port, int flags, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    switch(enable) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_enable_set(unit, port, pm_info, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_enable_get(int unit, int port, int flags, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_enable_get(unit, port, pm_info, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interface_config_set(int unit, int port, const portmod_port_interface_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interface_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interface_config_set(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interface_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interface_config_get(int unit, int port, portmod_port_interface_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_interface_config_t_init(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interface_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interface_config_get(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interface_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encoding_set(int unit, int port, uint32 properties, portmod_port_pcs_t encoding)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encoding_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encoding_set(unit, port, pm_info, properties, encoding);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encoding_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encoding_get(int unit, int port, uint32* properties, portmod_port_pcs_t* encoding)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(properties == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("properties NULL parameter"));
    }
    if(encoding == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("encoding NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encoding_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encoding_get(unit, port, pm_info, properties, encoding);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encoding_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_loopback_set(int unit, int port, portmod_loopback_mode_t loopback_type, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_loopback_mode_t_validate(unit, loopback_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback_type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_loopback_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_loopback_set(unit, port, pm_info, loopback_type, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_loopback_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_loopback_get(int unit, int port, portmod_loopback_mode_t loopback_type, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_loopback_mode_t_validate(unit, loopback_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback_type validation failed"));
    }

    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_loopback_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_loopback_get(unit, port, pm_info, loopback_type, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_loopback_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_local_get(int unit, int port, const portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_local_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_local_get(unit, port, pm_info, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_local_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_set(int unit, int port, const phymod_autoneg_control_t* an)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_set(unit, port, pm_info, an);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_get(int unit, int port, phymod_autoneg_control_t* an)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(an == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("an NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_get(unit, port, pm_info, an);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_link_get(int unit, int port, int* link)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(link == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("link NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_link_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_link_get(unit, port, pm_info, link);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_link_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_config_set(int unit, int port, int mode, int flags, const phymod_prbs_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_set(unit, port, pm_info, mode, flags, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_config_get(int unit, int port, int mode, int flags, phymod_prbs_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_get(unit, port, pm_info, mode, flags, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_enable_set(int unit, int port, int mode, int flags, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    switch(enable) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_set(unit, port, pm_info, mode, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_enable_get(int unit, int port, int mode, int flags, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_get(unit, port, pm_info, mode, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_status_get(int unit, int port, int mode, int flags, phymod_prbs_status_t* status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_status_get(unit, port, pm_info, mode, flags, status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_nof_lanes_set(int unit, int port, int nof_lanes)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_set(unit, port, pm_info, nof_lanes);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_nof_lanes_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_nof_lanes_get(int unit, int port, int* nof_lanes)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(nof_lanes == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_lanes NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_get(unit, port, pm_info, nof_lanes);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_nof_lanes_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ilkn_retranstmit_config_set(int unit, int port, const ilkn_retransmit_config_t* retransmit_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_set(unit, port, pm_info, retransmit_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ilkn_retranstmit_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ilkn_retranstmit_config_get(int unit, int port, ilkn_retransmit_config_t* retransmit_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(retransmit_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("retransmit_config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_get(unit, port, pm_info, retransmit_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ilkn_retranstmit_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lanes_assign(int unit, int port, const portmod_lanes_assign_info_t* assign_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lanes_assign) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lanes_assign(unit, port, pm_info, assign_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lanes_assign isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lanes_retrieve(int unit, int port, portmod_lanes_assign_info_t* assign_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(assign_map == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("assign_map NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lanes_retrieve) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lanes_retrieve(unit, port, pm_info, assign_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lanes_retrieve isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_firmware_mode_set(int unit, int port, phymod_firmware_mode_t fw_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_set(unit, port, pm_info, fw_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_firmware_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_firmware_mode_get(int unit, int port, phymod_firmware_mode_t* fw_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(fw_mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fw_mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_get(unit, port, pm_info, fw_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_firmware_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_runt_threshold_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_runt_threshold_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_runt_threshold_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_runt_threshold_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_max_packet_size_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_max_packet_size_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_max_packet_size_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_max_packet_size_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pad_size_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pad_size_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pad_size_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pad_size_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pad_size_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pad_size_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pad_size_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pad_size_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_set(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_sa_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_get(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_sa_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_set(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_sa_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_get(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_sa_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_average_ipg_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_average_ipg_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_average_ipg_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_average_ipg_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_preamble_length_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_preamble_length_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_preamble_length_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_preamble_length_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_control_set(int unit, int port, const portmod_local_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_local_fault_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_control_get(int unit, int port, portmod_local_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_local_fault_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_control_set(int unit, int port, const portmod_remote_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_remote_fault_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_control_get(int unit, int port, portmod_remote_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_remote_fault_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_status_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_status_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_status_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_status_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_status_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_status_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pause_control_set(int unit, int port, const portmod_pause_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pause_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pause_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pause_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pause_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pause_control_get(int unit, int port, portmod_pause_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pause_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pause_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pause_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pause_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_control_set(int unit, int port, const portmod_pfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pfc_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_control_get(int unit, int port, portmod_pfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pfc_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_llfc_control_set(int unit, int port, const portmod_llfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_llfc_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_llfc_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_llfc_control_get(int unit, int port, portmod_llfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_llfc_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_llfc_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_core_access_get(int unit, int port, int phyn, int max_cores, phymod_core_access_t* core_access_arr, int* nof_cores)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(core_access_arr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_access_arr NULL parameter"));
    }
    if(nof_cores == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_cores NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_core_access_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_core_access_get(unit, port, pm_info, phyn, max_cores, core_access_arr, nof_cores);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_core_access_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_lane_access_get(int unit, int port, const portmod_access_get_params_t* params, int max_phys, phymod_phy_access_t* access, int* nof_phys)
{

    portmod_dispatch_type_t __type__;
    int __rv__;
        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_access_get_params_t_validate(unit, params)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("params validation failed"));
    }

    if(access == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("access NULL parameter"));
    }
    if(nof_phys == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_phys NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_lane_access_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_lane_access_get(unit, port, pm_info, params, max_phys, access, nof_phys);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_lane_access_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}



#undef _ERR_MSG_MODULE_NAME
