/* $Id: soc_petra_chip_regs.h,v 1.10 Broadcom SDK $
 * $Copyright: Copyright 2015 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
*/

#ifndef __SOC_PETRA_CHIP_REGS_INCLUDED__
/* { */
#define __SOC_PETRA_CHIP_REGS_INCLUDED__

/*************
 * INCLUDES  *
 *************/
/* { */
#include <soc/dpp/SAND/Utils/sand_header.h>

#include <soc/dpp/SAND/Utils/sand_framework.h>
#include <soc/dpp/SAND/SAND_FM/sand_cell.h>
#include <soc/dpp/Petra/petra_chip_defines.h>
#include <soc/dpp/Petra/petra_api_general.h>
#ifdef LINK_PB_LIBRARIES
#include <soc/dpp/Petra/PB_TM/pb_chip_regs.h>
#endif
/* } */

/*************
 * DEFINES   *
 *************/
/* { */
#define  SOC_PETRA_BLK_NOF_INSTANCES_ECI              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_OLP              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_NIF              2
#define  SOC_PETRA_BLK_NOF_INSTANCES_MAL              8
#define  SOC_PETRA_BLK_NOF_INSTANCES_IRE              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_IDR              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_IRR              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_IHP              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_IQM              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_QDR              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_IPS              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_IPT              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_MMU              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_DRC              6
#define  SOC_PETRA_BLK_NOF_INSTANCES_DPI              6
#define  SOC_PETRA_BLK_NOF_INSTANCES_FDR              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_FDT              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_FCR              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_FCT              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_MESH_TOPOLOGY    1
#define  SOC_PETRA_BLK_NOF_INSTANCES_RTP              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_FABRIC_MAC       3
#define  SOC_PETRA_BLK_NOF_INSTANCES_MSW              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_EGQ              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_EPN              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_CFC              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_SCH              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_SERDES           4


#define  SOC_PETRA_NOF_INSTANCES_EGQ_CAL_SETS         2

/* Out Of Band interfaces*/
#define  SOC_PETRA_BLK_NOF_INSTANCES_MCC              1
#define  SOC_PETRA_BLK_NOF_INSTANCES_OOB              2
#define  SOC_PETRA_BLK_NOF_OOB_CONF_REGS              3
#define  SOC_PETRA_BLK_NOF_OOB_ERROR_REGS             1


#define  SOC_PETRA_NOF_WFQ_REGS                       2
#define  SOC_PETRA_NOF_SHAPER_MAX_CREDIT_REGS         4
#define  SOC_PETRA_NOF_SHAPER_DELAY_REGS              4
#define  SOC_PETRA_NOF_SHAPER_CAL_REGS                4

#define  SOC_PETRA_NOF_RJCT_ADMIT_TMPLTS              8
#define  SOC_PETRA_NOF_DBUFFS_THS                     3
#define  SOC_PETRA_NOF_DBUFFS_VALS                    4

#define  SOC_PETRA_NOF_CH_NIF_RATE_REGS               8
#define  SOC_PETRA_NOF_CH_NIF_CAL_REGS                8

#define  SOC_PETRA_NOF_1PORT_NIF_RATE_REGS            24

#define  SOC_PETRA_NOF_DVS_WEIGHT_CONFIG_REGS         4

#define  SOC_PETRA_NOF_STL_GROUP_CONFIG_REGS          6
#define  SOC_PETRA_NOF_STL_GROUP_CONFIG_FLDS          16

#define  SOC_PETRA_NOF_OFP_TH_TYPE_SEL_REGS           5
#define  SOC_PETRA_NOF_OFP_TH_TYPE_SEL_FLDS           16

#define  SOC_PETRA_NOF_UNSCHED_QS_THRESH_FOR_DP_REGS  4
#define  SOC_PETRA_REGS_NOF_EGR_Q_PRIORITIES          2

#define  SOC_PETRA_NOF_SCHED_QS_RSC_CONS_THR_REGS     4
#define  SOC_PETRA_NOF_SCHED_QS_FC_CONS_THR_REGS      2

#define SOC_PETRA_NOF_TRANSMIT_DATA_CELLS_REGISTERS   (SOC_SAND_DATA_CELL_UINT32_SIZE)

#define  SOC_PETRA_NOF_CH_PORTS_TOTAL_FC_THRESH_REGS  5
#define  SOC_PETRA_NOF_CH_PORTS_TOTAL_FC_THRESH_FLDS  2
#define  SOC_PETRA_NOF_MCI_LVLS_FOR_THRESH_CONF_SKIP  2

#define  SOC_PETRA_NOF_MCI_LVLS_FOR_THRESH_CONF_REGS  2

#define  SOC_PETRA_NOF_EGR_PORT_PRIO_CONF_REGS        5
#define  SOC_PETRA_NOF_EGR_PORT_PRIO_CONF_FLDS        16

#define  SOC_PETRA_NOF_MAP_CONF_CHNIF_REGS            8
#define  SOC_PETRA_NOF_MAP_CONF_PER_CHNIF_REGS        3

#define  SOC_PETRA_NOF_MAP_CONF_NONCH_NIF_REGS        6
#define  SOC_PETRA_NOF_MAP_CONF_NONCH_NIF_FLDS        4

#define  SOC_PETRA_NOF_ACTIVE_MC_LINKS_REGS           2
#define  SOC_PETRA_NOF_ALLOWED_LINKS_REGS             2

#define  SOC_PETRA_NOF_CLASS_TABLE_L_FLDS             4

#define  SOC_PA_NOF_DEBUG_HEADER_REGS              3

/* $Id: soc_petra_chip_regs.h,v 1.10 Broadcom SDK $
 * This is the number of serdeses in single MAC group.
 * 3 MAC groups exist.
 */
#define  SOC_PETRA_NOF_PER_LINK_REGS                  12
/*
 * Address offset between 2 consecutive per-serdes registers
 */

#define  SOC_PETRA_NOF_COEXIST_MAP_REGS               4

#define  SOC_PETRA_QDR_NOF_PATTERN_REGS                8
#define  SOC_PETRA_DRAM_NOF_PATTERN_REGS               8
#define  SOC_PETRA_DRAM_NOF_TRAIN_SEQ_WORDS_REGS       8
#define  SOC_PETRA_DRC_NOF_BIST_ENABLES                6

#define  SOC_PETRA_DRAM_NOF_DLL_REGS                   4
#define  SOC_PETRA_DRAM_NOF_RND_TRP_FLDS               4
#define  SOC_PETRA_DRAM_NOF_RND_TRP_DIFF_FLDS          4
#define  SOC_PETRA_DRAM_NOF_SHIFT_REGS                 4

/*
 * Fabrics registers with bit-per-link, 36 bits
 */
#define  SOC_PETRA_NOF_BIT_PER_LINK_REGS              2

#define  SOC_PETRA_NOF_FAP20B_MAP_REGS                4

#define  SOC_PETRA_NOF_LOW_PRIORITY_CONTROL_REGS      2

#define  SOC_PETRA_NOF_CLS2FAP_PORT_MAP_REGS          2

#define  SOC_PETRA_SCH_HR_MASK_NOF_REGS                   4

#define  SOC_PETRA_RCY2FAP_PORT_HR_MAP_REGS           3
#define  SOC_PETRA_PTC_CUSTOM_MACRO_CMD_NOF_REGS      8
#define  SOC_PETRA_PTC_CUSTOM_PROTOCOLS_NOF_REGS      7

#define  SOC_PETRA_PTC_ETHERNET_TYPES_NOF_REGS        4
#define  SOC_PETRA_PTC_ETHERNET_TYPES_NOF_FLDS        2

#define  SOC_PETRA_PTC_IP_PROTOCOLS_NOF_REGS          2
#define  SOC_PETRA_PTC_IP_PROTOCOLS_NOF_FLDS          4
#define  SOC_PETRA_MAP_OFP_TO_MIRR_CHANNEL_NOF_REGS   15

#define SOC_PETRA_CPU_PACKET_FRAGMENTATION_REGS       8

/*
 * Must be SOC_PETRA_NOF_MAC_LANES
 */
#define  SOC_PETRA_EGR_SHPR_CONF_NIF_NOF_REGS 8
/* 0xe1ef - 0xe1e1 */
#define  SOC_PETRA_INSTANCES_EGQ_CAL_SETS_OFFSET      0xe
#define  SOC_PETRA_EGR_SHPR_PER_NIF_GRP_NOF_REGS      2
#define  SOC_PETRA_EGR_SHPR_PER_NIF_GRP_NOF_FLDS      4

#define  SOC_PETRA_CH_NIF_CAL_LEN_NOF_FLDS            2

#define SOC_PETRA_HRPORT_EN_NOF_REGS                   3

#define SOC_PETRA_SRD_NOF_PER_LANE_REGS       4
#define SOC_PETRA_SRD_NOF_PER_QRTT_REGS       4
/* 0x20(srd1_LN0_cfga) - 0x0(srd0_LN0_cfga)*/
#define SOC_PETRA_SRD_QRTT_DELTA_OFFSET       0x20

#define SOC_PETRA_REGS_IRE_NOF_CPU_PKT_DATA_REGS    8

#define SOC_PETRA_REGS_PER_SNOOP_CMD_NOF_FLDS      15

#define SOC_PETRA_REGS_PER_TC_NOF_FLDS              8

#define SOC_PETRA_REGS_SGMII_NOF_LINKS              4

#define SOC_PETRA_NIF_PORTS_FC_THRESH_NOF_FLDS      4
#define SOC_PETRA_NIF_PORTS_FC_THRESH_NOF_REGS      2

#define SOC_PETRA_REGS_PER_HDR_CR_DSCNT_TYPE_REGS   2

#define SOC_PETRA_REGS_MC_2_MCDP_TABLE_REGS         2

#define SOC_PETRA_REGS_DBUFF_PTR_Q_THRESH_NOF_REGS  8

#define SOC_PETRA_TRANSMIT_DATA_QUEUE_NOF_REGS      4
#define SOC_PETRA_TRANSMIT_DATA_QUEUE_NOF_FLDS      2

#define SOC_PETRA_COUNTERS_FAP_PORTS_NOF_FLDS       4

#define SOC_PETRA_NOF_FAP_PORT_REGS                 3

/* } */

/*************
 *  MACROS   *
 *************/
/* { */
  /* Solve the Fdt Enabler Register Errata causing bit-shift        */
  /* on read. When reading, bits 4 - 31 appear as 3 - 30.           */
  /* Bits 0 - 2 are read OK                                         */
  /* Note: it is wrong to access this register using                */
  /* soc_petra_write_fld, since it performs Read-Modify-Write.          */
  /* Instead, read the whole register, use                          */
  /* SOC_PETRA_REGS_FDT_ENABLER_READ_ADJUST macro to adjust the value,  */
  /* modify and write                                               */
#define SOC_PETRA_REGS_FDT_ENABLER_READ_ADJUST(fdt_reg_val)               \
{                                                                     \
  if (SOC_PETRA_IS_DEV_PETRA_A)                                           \
  {                                                                   \
  fdt_reg_val = ((SOC_SAND_GET_BITS_RANGE(fdt_reg_val, 30, 3) << (3+1)) | \
                 (SOC_SAND_GET_BITS_RANGE(fdt_reg_val, 2, 0)) );          \
  }                                                                   \
}
/* } */

/*************
 * TYPE DEFS *
 *************/
/* { */

typedef enum
{
  SOC_PETRA_REGS_SRD_INST_BASE = 100,
  SOC_PETRA_REGS_SRD_INST_NIFA = 101,
  SOC_PETRA_REGS_SRD_INST_NIFB = 102,
  SOC_PETRA_REGS_SRD_INST_MSWA = 103,
  SOC_PETRA_REGS_SRD_INST_MSWB = 104,
  SOC_PETRA_REGS_SRD_INST_LAST = 105
} SOC_PETRA_REGS_SRD_INSTANCE;

#define SOC_PETRA_REGS_SRD_NOF_INSTANCES 4

#define SOC_PETRA_REGS_TCAM_NOF_CYCLES  2
#define SOC_PETRA_REGS_TCAM_NOF_BANKS   4
/* Blocks definition { */
#ifdef LINK_PA_LIBRARIES

/* Pcmi Config: Pcmi count period                                 */
typedef struct
{
  SOC_PETRA_REG_ADDR  addr;

  /* CntrData: Pcmi count period.                                 */
  /* range: 30:0, access type: RW, default value: 0x0             */
  SOC_PETRA_REG_FIELD cntr_data;

} __ATTRIBUTE_PACKED__ SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT;

/* Pcmi Results: Pcmi count Results                               */
typedef struct
{
  SOC_PETRA_REG_ADDR  addr;

  /* PcmIvrgocCntr: the result of the osc counter.                */
  /* range: 29:0, access type: RO, default value: 0x0             */
  SOC_PETRA_REG_FIELD pcm_ivrgoc_cntr;

  /* PcmIvClkExp: indicates the counting ended.                   */
  /* range: 30:30, access type: RO, default value: 0x0            */
  SOC_PETRA_REG_FIELD pcm_iv_clk_exp;

  /* PcmIvrgocOverflw: indicates there was an ovf in the count.   */
  /* range: 31:31, access type: RO, default value: 0x0            */
  SOC_PETRA_REG_FIELD pcm_ivrgoc_overflw;

} __ATTRIBUTE_PACKED__ SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT;

/* Block definition: ECI */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Version Register: The device version.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0000 */

     /* ChipType: Chip type                                          */
     /* range: 23:4, access type: RO, default value: 20'hfa080       */
     SOC_PETRA_REG_FIELD chip_type;

     /* DbgVer: Debug Version. The version (bug correction) of       */
     /* the device. Each device may have several versions. (The      */
     /* first version is 1.)                                         */
     /* range: 27:24, access type: RO, default value: 0x1            */
     SOC_PETRA_REG_FIELD dbg_ver;

     /* ChipVer: Device Version. Indicates the version               */
     /* (different functionality) of the device. (The first          */
     /* version's value is 1.)                                       */
     /* range: 31:28, access type: RO, default value: 0x1            */
     SOC_PETRA_REG_FIELD chip_ver;

  } __ATTRIBUTE_PACKED__ version_reg;


  /* Identification Register: The identification of FAP. This       */
  /* is a unique number identifies the FAP.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0001 */

     /* PipeID: ID of FAP. This register contains a number that      */
     /* identifies the FAP. It is unique in the system.              */
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pipe_id;

  } __ATTRIBUTE_PACKED__ identification_reg;

  /* Oc768cMode Register                                            */
  /* Also includes miscellaneous configuration, e.g. DRAM-related   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0002 */

     /* Oc768cMode:                                                  */
     /* If set, the Oc768c mode is active (FAP ports 1 through 4     */
     /* perform packet re-sequencing).                               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD oc768c_mode;

     /* range: 3:2, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD dcf_a;
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dcf_p;
     /* range: 5:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dcf_disable;

  } __ATTRIBUTE_PACKED__ oc768c_and_misc_reg;

  /* Spare register. Used by SW for managment flags                 */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0003 */
    /* range: 29:29, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD hot_init_done;
    /* range: 31:31, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD sch_flow_ipf_is_prop_not_inverse;
  } __ATTRIBUTE_PACKED__ spare_flags_reg;

  /* Device revision register                                        */
  /* Allows to identify Soc_petra revision (e.g Rev-A, Rev-b...          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0004 */
     /* Revision (debug version)                                     */
     /* Indicates the version (different functionality) of the       */
     /* device.                                                      */
     /* 0x0 - Rev A0                                                 */
     /* 0x10 - Rev A1                                                */
     /* 0x30 - Rev A2                                                */
     /* range: 11:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD revision;
  } __ATTRIBUTE_PACKED__ revision_reg;


  /* Cpu Asynchronous Packet Data:                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0005 */

     /* CpuAsynchronousPacketData: TDATA[15:0] TCMD[18:16]           */
     /* TDV[20] Same meaning to data and command like in             */
     /* streaming mode.                                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdata;

     SOC_PETRA_REG_FIELD tcmd;

     SOC_PETRA_REG_FIELD tdv;

  } __ATTRIBUTE_PACKED__ cpu_asynchronous_packet_data_reg;


  /* Unicast Dbuff Pointers Start: The following registers          */
  /* describe the partition of the ingress DRAM buffers             */
  /* between Unicast, Mini Multicast, and Full Multicast            */
  /* dbuffs. Any dbuff in the system can be defined as              */
  /* Unicast dbuff.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0007 */

     /* UcDbPtrStart: Pointer to first DRAM buffer for Unicast       */
     /* type dbuffs.                                                 */
     /* range: 20:0, access type: RW, default value: 21'h12000       */
     SOC_PETRA_REG_FIELD uc_db_ptr_start;

  } __ATTRIBUTE_PACKED__ unicast_dbuff_pointers_start_reg;


  /* Unicast Dbuff Pointers End:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0008 */

     /* UcDbPtrEnd: Pointer to last DRAM buffer for Unicast type     */
     /* dbuffs.                                                      */
     /* range: 20:0, access type: RW, default value: 21'h1fffff      */
     SOC_PETRA_REG_FIELD uc_db_ptr_end;

  } __ATTRIBUTE_PACKED__ unicast_dbuff_pointers_end_reg;


  /* Mini Multicast Dbuff Pointers Start: Up to 64K dbuffs          */
  /* can be defined as Mini Multicast dbuffs. They have an          */
  /* associated 2 bits User-Count. These dbuffs are used for        */
  /* snooping and mirroring, or for Multicast where four or         */
  /* less copies are required.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0009 */

     /* MnMulDbPtrStart: Pointer to first DRAM buffer for Mini       */
     /* Multicast type dbuffs.                                       */
     /* range: 20:0, access type: RW, default value: 0x2000          */
     SOC_PETRA_REG_FIELD mn_mul_db_ptr_start;

  } __ATTRIBUTE_PACKED__ mini_multicast_dbuff_pointers_start_reg;


  /* Mini Multicast Dbuff Pointers End:                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000a */

     /* MnMulDbPtrEnd: Pointer to last DRAM buffer for Mini          */
     /* Multicast type dbuffs.                                       */
     /* range: 20:0, access type: RW, default value: 21'h11fff       */
     SOC_PETRA_REG_FIELD mn_mul_db_ptr_end;

  } __ATTRIBUTE_PACKED__ mini_multicast_dbuff_pointers_end_reg;


  /* Full Multicast Dbuff Pointers Start: Up to 8K dbuffs can       */
  /* be defined as Full Multicast dbuffs. They have an              */
  /* associated 12 bits User-Count. These dbuffs are used for       */
  /* Multicast packets.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000b */

     /* FlMulDbPtrStart: Pointer to first DRAM buffer for Full       */
     /* Multicast type dbuffs.                                       */
     /* range: 20:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fl_mul_db_ptr_start;

  } __ATTRIBUTE_PACKED__ full_multicast_dbuff_pointers_start_reg;


  /* Full Multicast Dbuff Pointers End:                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000c */

     /* FlMulDbPtrEnd: Pointer to last DRAM buffer for Full          */
     /* Multicast type dbuffs.                                       */
     /* range: 20:0, access type: RW, default value: 0x1fff          */
     SOC_PETRA_REG_FIELD fl_mul_db_ptr_end;

  } __ATTRIBUTE_PACKED__ full_multicast_dbuff_pointers_end_reg;


  /* Soc_petra Soft Reset: When triggered, the corresponding            */
  /* block will perform a software reset.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000d */

     /* MasReset: Performs soft reset for the IPS block.             */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mas_reset;

     /* NifaReset: Performs soft reset for the IQM block.            */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD nifa_reset;

     /* NifbReset: Performs soft reset for the QDR block.            */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD nifb_reset;

     /* SchReset: Performs soft reset for the IPT block.             */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD sch_reset;

     /* IhpReset: Performs soft reset for the MMU block.             */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ihp_reset;

     /* DprcaReset: Performs soft reset for the DPRCA block.         */
     /* range: 5:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dprc_reset[SOC_PETRA_BLK_NOF_INSTANCES_DRC];

     /* IrdpReset: Performs soft reset for the IRE block.            */
     /* range: 11:11, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD irdp_reset;

     /* MmuReset: Performs soft reset for the IHP block.             */
     /* range: 12:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD mmu_reset;

     /* EgqReset: Performs soft reset for the IDR block.             */
     /* range: 13:13, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD egq_reset;

     /* EpniReset: Performs soft reset for the IRR block.            */
     /* range: 14:14, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD epni_reset;

     /* FdrcReset: Performs soft reset for the FDT block.            */
     /* range: 15:15, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fdrc_reset;

     /* PtsReset: Performs soft reset for the FDR block.             */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD pts_reset;

     /* IqmReset: Performs soft reset for the FCT block.             */
     /* range: 17:17, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD iqm_reset;

     /* OlpReset: Performs soft reset for the OLP block.             */
     /* range: 18:18, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD olp_reset;

     /* MdioReset: Performs soft reset for the MDIO block.           */
     /* range: 19:19, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD mdio_reset;

     /* CfcReset: Performs soft reset for the CFC block.             */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cfc_reset;

     /* MccReset: Performs soft reset for the MCC block.             */
     /* range: 21:21, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD mcc_reset;

     /* QdioReset: Performs soft reset for the QDIO block.           */
     /* range: 22:22, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD qdio_reset;

  } __ATTRIBUTE_PACKED__ soc_petra_soft_reset_reg;


  /* Soc_petra Soft Init: When triggered, the corresponding block       */
  /* will perform a software init. No need to reconfig the          */
  /* corresponding block.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000e */

     /* IpsInit: Performs soft init for the IPS block.               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ips_init;

     /* IqmInit: Performs soft init for the IQM block.               */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD iqm_init;

     /* QdrInit: Performs soft init for the QDR block.               */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_init;

     /* IptInit: Performs soft init for the IPT block.               */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ipt_init;

     /* MmuInit: Performs soft init for the MMU block.               */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mmu_init;

     /* DprcaInit - DprcfInit:                                       */
     /* Performs soft init for the DPRCA block.                      */
     /* range: 10:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprc_init[SOC_PETRA_BLK_NOF_INSTANCES_DRC];

     /* IreInit: Performs soft init for the IRE block.               */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ire_init;

     /* IhpInit: Performs soft init for the IHP block.               */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ihp_init;

     /* IdrInit: Performs soft init for the IDR block.               */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD idr_init;

     /* IrrInit: Performs soft init for the IRR block.               */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD irr_init;

     /* FdtInit: Performs soft init for the FDT block.               */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdt_init;

     /* FdrInit: Performs soft init for the FDR block.               */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_init;

     /* FctInit: Performs soft init for the FCT block.               */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fct_init;

     /* FcrInit: Performs soft init for the FCR block.               */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fcr_init;

     /* RtpInit: Performs soft init for the RTP block.               */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rtp_init;

     /* EgqInit: Performs soft init for the EGQ block.               */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_init;

     /* EpniInit: Performs soft init for the EPNI block.             */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD epni_init;

     /* MacaInit: Performs soft init for the MACA block.             */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD maca_init;

     /* MacbInit: Performs soft init for the MACB block.             */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD macb_init;

     /* MaccInit: Performs soft init for the MACC block.             */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD macc_init;

     /* SchInit: Performs soft init for the SCH block.               */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sch_init;

     /* OlpInit: Performs soft init for the OLP block.               */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD olp_init;

     /* MswInit: Performs soft init for the MSW block.               */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD msw_init;

     /* MccInit: Performs soft init for the MCC block.               */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mcc_init;

     /* NifaInit: Performs soft init for the NIFA block.             */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifa_init;

     /* NifbInit: Performs soft init for the NIFB block.             */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifb_init;

     /* MdioInit: Performs soft init for the MDIO block.             */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mdio_init;

  } __ATTRIBUTE_PACKED__ soc_petra_soft_init_reg;


  /* Ingress Shaping Queue Boundaries: Defines a continuous         */
  /* range of queues that are used for Ingress shaped               */
  /* packets. This assignment is meaningful for the                 */
  /* statistics matrix that the IQM maintains.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x000f */

     /* IspQnumLow: First queue ID for ingress shaping queues.       */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD isp_qnum_low;

     /* IspQnumHigh: Last queue ID for ingress shaping queues.       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD isp_qnum_high;

  } __ATTRIBUTE_PACKED__ ingress_shaping_queue_boundaries_reg;


  /* Fabric Multicast Queue Boundaries: Defines a continuous        */
  /* range of queues that are used for Fabric Multicast             */
  /* packets. This assignment is meaningful for the                 */
  /* statistics matrix that the IQM maintains.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0010 */

     /* FmcQnumLow: First queue ID for fabric multicast queues.      */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fmc_qnum_low;

     /* FmcQnumHigh: Last queue ID for fabric multicast queues.      */
     /* range: 30:16, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fmc_qnum_high;

  } __ATTRIBUTE_PACKED__ fabric_multicast_queue_boundaries_reg;


  /* Drc Bist Enables: This registers enables each one of the       */
  /* DRAM BISTs in the DRAM controller blocks.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0011 */

     /* DrcaBistEn: If set, enables the BIST module in DRCA.         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drca_bist_en;

     /* DrcbBistEn: If set, enables the BIST module in DRCB.         */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drcb_bist_en;

     /* DrccBistEn: If set, enables the BIST module in DRCC.         */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drcc_bist_en;

     /* DrcdBistEn: If set, enables the BIST module in DRCD.         */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drcd_bist_en;

     /* DrceBistEn: If set, enables the BIST module in DRCE.         */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drce_bist_en;

     /* DrcfBistEn: If set, enables the BIST module in DRCF.         */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drcf_bist_en;

     /* DrcfBistEn: If set, enables the BIST module in DRCF.         */
     /* range: i:i, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drcs_bist_en[SOC_PETRA_DRC_NOF_BIST_ENABLES];

  } __ATTRIBUTE_PACKED__ drc_bist_enables_reg;


  /* General Controls:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0012 */

     /* FscEn: If set, cell mode is fixed size cell. Otherwise       */
     /* variable size cell.                                          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fsc_en;

     /* MeshMode: Mesh mode selection. If set, the device works      */
     /* in mesh mode.                                                */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mesh_mode;

     /* SelStatDataOut: Selection between the statistics data        */
     /* and the mirror data bus to be sent out to pads. If set,      */
     /* the statistics data is sent out to pads. Otherwise, the      */
     /* mirror data is sent out to pads.                             */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD sel_stat_data_out;

     /* StatDdrMode: If set statistics pads are in DDR mode,         */
     /* otherwise statistics pads are in SDR mode.                   */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_ddr_mode;

     /* StatTagEn: If set, the first 4B of every incoming            */
     /* ingress packet consist of the statistics tag.                */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_tag_en;

     /* QdrParSel: If set, the QDR data is parity protected (4       */
     /* bits parity, 32 bits of data). Otherwise, the QDR data       */
     /* is ECC protected (6 bits for ECC, 30 bits of data).          */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_par_sel;

     /* AddDramCrc: If set, a 16b CRC is appended to the end of      */
     /* the packet (aligned to the last two bytes of a 32B           */
     /* word).                                                       */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD add_dram_crc;

     /* NoFabCrc: If set, the packet will be sent across the         */
     /* fabric without a 16b packet CRC. Otherwise, the packet       */
     /* will be sent with 16b CRC.                                   */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD no_fab_crc;

     /* En_16kMul: If set, the device supports 16K multicast         */
     /* groups.                                                      */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD en_16k_mul;

     /* TdmMode: If set, every cell entering the device must be      */
     /* TDM. Otherwise data traffic.                                 */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_mode;

     /* StatOe: If set the statistics interface is output,           */
     /* otherwise input.                                             */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_oe;

     /* DbuffSize: The size of a data buffer in the DRAM: 0 -        */
     /* 256 bytes 1 - 512 bytes 2 - 1024 bytes 3 - 2048 bytes        */
     /* range: 17:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dbuff_size;

     /* FtmhExtMode: Determines the FTMH extension mode. May be      */
     /* one of the following: 2'b00 - Never add an FTMH              */
     /* extension 2'b01 - Add FTMH extension only if multicast       */
     /* 2'b1x - Always add an FTMH extension                         */
     /* range: 21:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ftmh_ext_mode;

     /* HdrType: Header type: 2'b00 - Soc_petra Header type 2'b01 -      */
     /* FAP20 Header type 2'b10 - SOC_SAND_FAP10M Header type 2'b11 -         */
     /* Reserved                                                     */
     /* range: 25:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hdr_type;

     /* StatOutPhase: 00 - Statistics data is in phase with the      */
     /* clock. 01 - Statistics data is 90 degrees to the clock.      */
     /* 10 - Statistics data is 180 degrees to the clock. 11 -       */
     /* Statistics data is 270 degrees to the clock.                 */
     /* range: 29:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_out_phase;

  } __ATTRIBUTE_PACKED__ general_controls_reg;


  /* Svlan Tpid Configuration Register: SVLAN TPID                  */
  /* configuration for Ethernet header parsing. This values         */
  /* is used to identify the presence of an SVLAN tag in the        */
  /* Ethernet header.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0013 */

     /* SvlanTpidVal: If set, SVLAN TPID is valid.                   */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD svlan_tpid_val;

     /* SvlanTpid: Configurable TPID that is used to identify an     */
     /* SVLAN tag in the Ethernet header.                            */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD svlan_tpid;

  } __ATTRIBUTE_PACKED__ svlan_tpid_configuration_reg;


  /* Cvlan Tpid Configuration Register: CVLAN TPID                  */
  /* configuration for Ethernet header parsing. This values         */
  /* is used to identify the presence of a CVLAN tag in the         */
  /* Ethernet header.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0014 */

     /* CvlanTpidVal: If set, CVLAN TPID is valid.                   */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD cvlan_tpid_val;

     /* CvlanTpid: Configurable TPID that is used to identify a      */
     /* CVLAN tag in the Ethernet header.                            */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cvlan_tpid;

  } __ATTRIBUTE_PACKED__ cvlan_tpid_configuration_reg;


  /* RLAG2 Configuration Register: Defines the range of             */
  /* System ports which are reserved for configuring LAG with       */
  /* two ports.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0015 */

     /* RLAG2Low: The first System port ID which is interpreted      */
     /* as RLAG of type 2.                                           */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rlag2_low;

     /* RLAG2High: The last System port ID which is interpreted      */
     /* as RLAG of type 2.                                           */
     /* range: 27:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rlag2_high;

  } __ATTRIBUTE_PACKED__ rlag2_configuration_reg;


  /* RLAG4 Configuration Register: Defines the range of             */
  /* System ports which are reserved for configuring LAG with       */
  /* four ports.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0016 */

     /* RLAG4Low: The first System port ID which is interpreted      */
     /* as RLAG of type 4.                                           */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rlag4_low;

     /* RLAG4High: The last System port ID which is interpreted      */
     /* as RLAG of type 4.                                           */
     /* range: 27:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rlag4_high;

  } __ATTRIBUTE_PACKED__ rlag4_configuration_reg;


  /* Endian Mode: The device works by default in big endian         */
  /* mode. In order to work in little endian mode, all bits         */
  /* of this register must be set.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0017 */

     /* LittleEndian: If all bits set, the device works in           */
     /* little endian mode.                                          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD little_endian;

  } __ATTRIBUTE_PACKED__ endian_mode_reg;


  /* Byte Access Order: The byte (8-bit) access order for           */
  /* 32-bit asynchronous read/write transaction.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0018 */

     /* FourthByteAccess: The fourth byte CPU read/write from/to     */
     /* (address[1:0]). Write the same value also to bits: 9:8,      */
     /* 17:16, 25:24.                                                */
     /* range: 1:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD fourth_byte_access;

     /* ThirdByteAccess: The third byte CPU read/write from/to       */
     /* (address[1:0]). Write the same value also to bits:           */
     /* 11:10, 19:18, 27:26.                                         */
     /* range: 3:2, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD third_byte_access;

     /* SecondByteAccess: The second byte CPU read/write from/to     */
     /* (address[1:0]). Write the same value also to bits:           */
     /* 13:12, 21:20, 29:28.                                         */
     /* range: 5:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD second_byte_access;

     /* FirstByteAccess: The first byte CPU read/write from/to       */
     /* (address[1:0]). Write the same value also to bits:           */
     /* 15:14, 23:22, 31:30.                                         */
     /* range: 7:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD first_byte_access;

  } __ATTRIBUTE_PACKED__ byte_access_order_reg;

  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0019 */
  } __ATTRIBUTE_PACKED__ mesh_ctxt_reg;

  /* Test Register: To verify the CPU interface of the              */
  /* device. By reading the inverted value, it is assured           */
  /* that a read following a write will have to drive the bus       */
  /* in order for the read to be successful.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001a */

     /* TestRegister: This register is for the CPU interface         */
     /* testing. When read, it returns ~TestRegister (i.e., the      */
     /* value is inverted).                                          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD test_register;

  } __ATTRIBUTE_PACKED__ test_reg;


  /* Power Down And Cpu Streaming If Statuses: Power down and       */
  /* Status of the CPU interface following the Power Up             */
  /* Configuration.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001b */

     /* MacaPd: If set MACA is powered down.                         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD maca_pd;

     /* MacbPd: If set MACB is powered down.                         */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD macb_pd;

     /* MaccPd: If set MACC is powered down.                         */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD macc_pd;

     /* MswPd: If set MSW is powered down.                           */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD msw_pd;

     /* NifaPd: If set NIFA is powered down.                         */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifa_pd;

     /* DprcaPd: If set DPRCA is powered down.                       */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprca_pd;

     /* DprcbPd: If set DPRCB is powered down.                       */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcb_pd;

     /* DprccPd: If set DPRCC is powered down.                       */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcc_pd;

     /* DprcdPd: If set DPRCD is powered down.                       */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcd_pd;

     /* DprcePd: If set DPRCE is powered down.                       */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprce_pd;

     /* DprcfPd: If set DPRCF is powered down.                       */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dprcf_pd;

     /* PdmcaPd: If set PDMCA is powered down.                       */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pdmca_pd;

     /* PdmcbPd: If set PDMCB is powered down.                       */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pdmcb_pd;

     /* QdioPd: If set QDIO is powered down.                         */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdio_pd;

     /* CpuifMode: 0 - Asynchronous mode is selected. 1 -            */
     /* Streaming mode is selected.                                  */
     /* range: 16:16, access type: RO, default value: PUC            */
     SOC_PETRA_REG_FIELD cpuif_mode;

     /* CpuifSpeed: 0 - 125 MHz DDR 1 - 125 MHz SDR 2 - 62.5 MHz     */
     /* DDR 3 - 62.5 MHz SDR                                         */
     /* range: 21:20, access type: RO, default value: PUC            */
     SOC_PETRA_REG_FIELD cpuif_speed;

     /* CpuifOutPhase: 00 - Data is in phase with the clock. 01      */
     /* - Data is 90 degrees to the clock. 10 - Data is 180          */
     /* degrees to the clock. 11 - Data is 270 degrees to the        */
     /* clock.                                                       */
     /* range: 25:24, access type: RO, default value: PUC            */
     SOC_PETRA_REG_FIELD cpuif_out_phase;

     /* CpuifInPhase: 0 - Clock phase is inverted. 1 - Clock         */
     /* keeps phase.                                                 */
     /* range: 26:26, access type: RO, default value: PUC            */
     SOC_PETRA_REG_FIELD cpuif_in_phase;

  } __ATTRIBUTE_PACKED__ power_down_and_cpu_streaming_if_statuses_reg;


  /* Cpu Streaming If Configurations: Configuration for the         */
  /* CPU streaming interface.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001c */

     /* CpuifMultiPortMode: If set, the CPU streaming IF is in       */
     /* Multi Port Mode. Otherwise, the CPU is in Single Port        */
     /* Mode.                                                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_multi_port_mode;

     /* CpuifEnableTimeoutcnt: If set, the CSI time-out counter      */
     /* is activated and the CSI will send a read reply command      */
     /* back to the CPU after CpuifTimeoutPrd cycles, if no read     */
     /* reply was received from the Soc_petra blocks.                    */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD cpuif_enable_timeoutcnt;

     /* CpuifTimeoutPrd: Number of cycles the CSI waits for a        */
     /* read reply from the Soc_petra blocks before issuing a read       */
     /* reply command.                                               */
     /* range: 22:16, access type: RW, default value: 0x64           */
     SOC_PETRA_REG_FIELD cpuif_timeout_prd;

     /* CpuifQuietMode: If set, the CSI will not send a reply        */
     /* command for write requests. As for read requests, the        */
     /* CSI will send a 32b reply command containing the read        */
     /* data only.                                                   */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpuif_quiet_mode;

     /* CpuifNoDisBadParity: If set, the CSI does not discard        */
     /* data received with a parity error and treats it as valid     */
     /* data. Default is to set this register to assist in the       */
     /* bring-up phase. The application should clear this            */
     /* register after CPU interface is working.                     */
     /* range: 25:25, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cpuif_no_dis_bad_parity;

  } __ATTRIBUTE_PACKED__ cpu_streaming_if_configurations_reg;


  /* Olp Streaming If Configurations: Configuration for the         */
  /* internal Off-Load Processor, which can act like a master       */
  /* and initiate commands to the various blocks via the CSI.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001d */

     /* OlpifEnableTimeoutcnt: If set, the CSI time-out counter      */
     /* is activated and the CSI will send a read reply command      */
     /* back to the OLP after OlpifTimeoutPrd cycles, if no read     */
     /* reply was received from the Soc_petra blocks.                    */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD olpif_enable_timeoutcnt;

     /* OlpifTimeoutPrd: Number of cycles the CSI waits for a        */
     /* read reply from the Soc_petra blocks before issuing a read       */
     /* reply command.                                               */
     /* range: 22:16, access type: RW, default value: 0x64           */
     SOC_PETRA_REG_FIELD olpif_timeout_prd;

     /* OlpifQuietMode: If set, the CSI will not send a reply        */
     /* command for write requests. As for read requests, the        */
     /* CSI will send a 32b reply command containing the read        */
     /* data only.                                                   */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD olpif_quiet_mode;

  } __ATTRIBUTE_PACKED__ olp_streaming_if_configurations_reg;


  /* Cpu Streaming If Interrupts: This register contains the        */
  /* CPU streaming interrupt sources residing in the                */
  /* ECI. Writing a value of 1 to the relevant bit in the            */
  /* interrupt register clears it (event interrupts).               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001e */

     /* CpuifRxPktPrtyErr: Indicates a parity error inside a         */
     /* received packet from the CPU. <B>This bit is used in CPU     */
     /* asynchronous mode to indicate packet data to CPU is          */
     /* valid.</B>                                                   */
     /* range: 0:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_rx_pkt_prty_err;

     /* CpuifRxCmdPrtyErr: Indicates a parity error inside a         */
     /* received command from the CPU.                               */
     /* range: 1:1, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_prty_err;

     /* CpuifRxPktSeqErr: Indicates a bad sequence of commands       */
     /* during the reception of a packet from the CPU.               */
     /* range: 2:2, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_rx_pkt_seq_err;

     /* CpuifRxCmdTypeErr: Indicates an error in a register          */
     /* command because the command type from the CPU                */
     /* (WRITE/READ) was not valid.                                  */
     /* range: 3:3, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_type_err;

     /* CpuifRxCmdSeqErr: Indicates a bad sequence of commands       */
     /* during a received register command from the CPU.             */
     /* range: 4:4, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_seq_err;

     /* CpuifReadRegTimeout: Indicates a timeout has occurred        */
     /* while waiting for a read reply from the ECI. In this         */
     /* case, the device will generate a read reply command with     */
     /* data 0xDEADBEEF.                                             */
     /* range: 5:5, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_read_reg_timeout;

     /* CpuifTxSopErr: Indicates a missing SOP command to the        */
     /* CPU in single port mode.                                     */
     /* range: 8:8, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_tx_sop_err;

     /* CpuifTxEopErr: Indicates a missing EOP command to the        */
     /* CPU in single port mode.                                     */
     /* range: 9:9, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD cpuif_tx_eop_err;

     /* CpuifBadParityData: Contains the 16b data for the last       */
     /* CPU interface transaction on which the parity error          */
     /* occurred.                                                    */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpuif_bad_parity_data;

  } __ATTRIBUTE_PACKED__ cpu_streaming_if_interrupts_reg;


  /* Cpu Streaming If Interrupts Mask Register: Each bit in         */
  /* this register corresponds to the interrupt source in the       */
  /* previous Interrupt Register. The interrupt source is           */
  /* masked by writing 0 to the relevant bit in this                */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x001f */

     /* CpuifRxPktPrtyErrMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_rx_pkt_prty_err_mask;

     /* CpuifRxCmdPrtyErrMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_prty_err_mask;

     /* CpuifRxPktSeqErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_rx_pkt_seq_err_mask;

     /* CpuifRxCmdTypeErrMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_type_err_mask;

     /* CpuifRxCmdSeqErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_rx_cmd_seq_err_mask;

     /* CpuifReadRegTimeoutMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_read_reg_timeout_mask;

     /* CpuifTxSopErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_tx_sop_err_mask;

     /* CpuifTxEopErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpuif_tx_eop_err_mask;

  } __ATTRIBUTE_PACKED__ cpu_streaming_if_interrupts_mask_reg;


  /* Olp Streaming If Interrupts: This register contains the        */
  /* OLP streaming interrupt sources residing in the                */
  /* ECI. Writing a value of 1 to the relevant bit in the            */
  /* interrupt register clears it (event interrupts).               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0020 */

     /* OlpifRxPktSeqErr: Indicates a bad sequence of commands       */
     /* during the reception of a packet from OLP.                   */
     /* range: 2:2, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD olpif_rx_pkt_seq_err;

     /* OlpifRxCmdTypeErr: Indicates an error in a register          */
     /* command because the command type from OLP (WRITE/READ)       */
     /* was not valid.                                               */
     /* range: 3:3, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD olpif_rx_cmd_type_err;

     /* OlpifRxCmdSeqErr: Indicates a bad sequence of commands       */
     /* during a received register command from OLP.                 */
     /* range: 4:4, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD olpif_rx_cmd_seq_err;

     /* OlpifReadRegTimeout: Indicates a timeout has occurred        */
     /* while waiting for a read reply from the ECI. In this         */
     /* case, the device will generate a read reply command with     */
     /* data 0xDEADBEEF.                                             */
     /* range: 5:5, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD olpif_read_reg_timeout;

     /* OlpifTxSopErr: Indicates a missing SOP command to the        */
     /* OLP in single port mode.                                     */
     /* range: 8:8, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD olpif_tx_sop_err;

     /* OlpifTxEopErr: Indicates a missing EOP command to the        */
     /* OLP in single port mode.                                     */
     /* range: 9:9, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD olpif_tx_eop_err;

  } __ATTRIBUTE_PACKED__ olp_streaming_if_interrupts_reg;


  /* Olp Streaming If Interrupts Mask Register: Each bit in         */
  /* this register corresponds to the interrupt source in the       */
  /* previous Interrupt Register. The interrupt source is           */
  /* masked by writing 0 to the relevant bit in this                */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0021 */

     /* OlpifRxPktSeqErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olpif_rx_pkt_seq_err_mask;

     /* OlpifRxCmdTypeErrMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olpif_rx_cmd_type_err_mask;

     /* OlpifRxCmdSeqErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olpif_rx_cmd_seq_err_mask;

     /* OlpifReadRegTimeoutMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olpif_read_reg_timeout_mask;

     /* OlpifTxSopErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olpif_tx_sop_err_mask;

     /* OlpifTxEopErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olpif_tx_eop_err_mask;

  } __ATTRIBUTE_PACKED__ olp_streaming_if_interrupts_mask_reg;


  /* Asynchronous Mode Interrupts: This register contains the       */
  /* asynchronous mode interrupt sources residing in the            */
  /* ECI. Writing a value of 1 to the relevant bit in the            */
  /* interrupt register clears it (event interrupts).               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0022 */

     /* AsynchByteOrderErr: Indicates a disorder byte access in      */
     /* asynchronous mode transaction.                               */
     /* range: 0:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD asynch_byte_order_err;

  } __ATTRIBUTE_PACKED__ asynchronous_mode_interrupts_reg;


  /* Asynchronous Mode Interrupts Mask Register: Each bit in        */
  /* this register corresponds to the interrupt source in the       */
  /* previous Interrupt Register. The interrupt source is           */
  /* masked by writing 0 to the relevant bit in this                */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0023 */

     /* AsynchByteOrderErrMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD asynch_byte_order_err_mask;

  } __ATTRIBUTE_PACKED__ asynchronous_mode_interrupts_mask_reg;


  /* Cpu Pads Configurations: Configures the CPU HSTL pads.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0024 */

     /* CpuCrVal: Overrides the resistance compensation bits         */
     /* going to the HSTL pads from the reference cell. If           */
     /* UseCrCfg is set, this value will be sent to the pads.        */
     /* Otherwise, pads will receive the resistance compensation     */
     /* value from the reference cell.                               */
     /* range: 4:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_cr_val;

     /* CpuUseCrCfg: If set, the value in CrVal is sent to the       */
     /* pads. Otherwise, pads will receive the resistance            */
     /* compensation value from the reference cell.                  */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_use_cr_cfg;

     /* CpuEnODT: If set, enables On Die Termination in the          */
     /* pads. This bit receives value during powerup.                */
     /* range: 12:12, access type: RW, default value: PUC            */
     SOC_PETRA_REG_FIELD cpu_en_odt;

     /* CpuTxIMP: Output impedance programmability bit. This bit     */
     /* receives value during powerup.                               */
     /* range: 13:13, access type: RW, default value: PUC            */
     SOC_PETRA_REG_FIELD cpu_tx_imp;

     /* CpuCr: Reflects the resistance compensation value from       */
     /* the reference cell.                                          */
     /* range: 20:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpu_cr;

  } __ATTRIBUTE_PACKED__ cpu_pads_configurations_reg;


  /* Misc Pads Configurations: Configures the miscellaneous         */
  /* HSTL pads.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0025 */

     /* MiscCrVal: Overrides the resistance compensation bits        */
     /* going to the HSTL pads from the reference cell. If           */
     /* UseCrCfg is set, this value will be sent to the pads.        */
     /* Otherwise, pads will receive the resistance compensation     */
     /* value from the reference cell.                               */
     /* range: 4:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD misc_cr_val;

     /* MiscUseCrCfg: If set, the value in CrVal is sent to the      */
     /* pads. Otherwise, pads will receive the resistance            */
     /* compensation value from the reference cell.                  */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD misc_use_cr_cfg;

     /* MiscEnODT: If set, enables On Die Termination in the         */
     /* pads.                                                        */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD misc_en_odt;

     /* MiscTxIMP: Output impedance programmability bit.             */
     /* range: 13:13, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD misc_tx_imp;

     /* MiscCr: Reflects the resistance compensation value from      */
     /* the reference cell.                                          */
     /* range: 20:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD misc_cr;

  } __ATTRIBUTE_PACKED__ misc_pads_configurations_reg;


  /* Tdm Configuration: TDM cells configuration.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0026 */

     /* TdmFrgNum: Set the fragment number that define TDM cell      */
     /* in the device. If we have FAP20B in the system this          */
     /* value must remain in the default value.                      */
     /* range: 8:0, access type: RW, default value: 0x180            */
     SOC_PETRA_REG_FIELD tdm_frg_num;

  } __ATTRIBUTE_PACKED__ tdm_configuration_reg;


  /* Ddr Pll Config: DDR PLL configuration.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0027 */

     /* DdrPllM:                                                     */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_pll_m;

     /* DdrPllN:                                                     */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ddr_pll_n;

     /* DdrPllK:                                                     */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_pll_k;

     /* DdrPllP:                                                     */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddr_pll_p;

  } __ATTRIBUTE_PACKED__ ddr_pll_config_reg;


  /* Qdr Pll Config: QDR PLL configuration.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0028 */

     /* QdrPllM:                                                     */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_pll_m;

     /* QdrPllN:                                                     */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD qdr_pll_n;

     /* QdrPllK:                                                     */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_pll_k;

     /* QdrPllP:                                                     */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_pll_p;

  } __ATTRIBUTE_PACKED__ qdr_pll_config_reg;


  /* Ddr Pll Ext Prog: DDR PLL external VCO gain, charge-pump       */
  /* current and loop-filter resistance programming.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0029 */

     /* DdrPllVprog:                                                 */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_pll_vprog;

     /* DdrPllIprog:                                                 */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_pll_iprog;

     /* DdrPllRprog:                                                 */
     /* range: 11:8, access type: RW, default value: 0x4             */
     SOC_PETRA_REG_FIELD ddr_pll_rprog;

  } __ATTRIBUTE_PACKED__ ddr_pll_ext_prog_reg;


  /* Qdr Pll Ext Prog: QDR PLL external VCO gain, charge-pump       */
  /* current and loop-filter resistance programming.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002a */

     /* QdrPllVprog:                                                 */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_pll_vprog;

     /* QdrPllIprog:                                                 */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_pll_iprog;

     /* QdrPllRprog:                                                 */
     /* range: 11:8, access type: RW, default value: 0x4             */
     SOC_PETRA_REG_FIELD qdr_pll_rprog;

  } __ATTRIBUTE_PACKED__ qdr_pll_ext_prog_reg;


  /* Pll Resets: DDR and QDR PLL reset.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002b */

     /* DdrPllRstN:                                                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_pll_rst_n;

     /* QdrPllRstN:                                                  */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_pll_rst_n;

     /* QdrPllSel: 0 - select QDR PLL. 1 - select core PLL.          */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_pll_sel;

  } __ATTRIBUTE_PACKED__ pll_resets_reg;


  /* Test Mux Config: Clock Test Mux configuration.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002c */

     /* TestMuxSel: 00 - DDR lock 01 - QDR lock 10 - DDR clock       */
     /* (after divider) 11 - QDR clock (after divider)               */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD test_mux_sel;

     /* TestMuxDiv: Clock divider for test mux. The clock is         */
     /* divided by (1<<TestMuxDiv).                                  */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD test_mux_div;

     /* DdrLock:                                                     */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr_lock;

     /* CoreLock:                                                    */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD core_lock;

     /* QdrLock:                                                     */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_lock;

  } __ATTRIBUTE_PACKED__ test_mux_config_reg;


  /* Msb Mirror Data Bus: The MSB mirror data bus -                 */
  /* mdata[35:18].                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002d */

     /* MsbMdataBus: mdata[35:18]                                    */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD msb_mdata_bus;

  } __ATTRIBUTE_PACKED__ msb_mirror_data_bus_reg;


  /* Lsb Mirror Data Bus: The LSB mirror data bus -                 */
  /* mdata[17:0].                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002e */

     /* LsbMdataBus: mdata[17:0]                                     */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lsb_mdata_bus;

  } __ATTRIBUTE_PACKED__ lsb_mirror_data_bus_reg;


  /* Udr Reg0: The UDR LSB bits programmed in efuse.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x002f */

     /* UdrReg0: The UDR LSB bits programmed in efuse.               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD udr_reg0;

  } __ATTRIBUTE_PACKED__ udr_reg0_reg;


  /* Udr Reg1: The UDR MSB bits programmed in efuse.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0030 */

     /* UdrReg1: The UDR MSB bits programmed in efuse.               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD udr_reg1;

  } __ATTRIBUTE_PACKED__ udr_reg1_reg;


  /* Mdio Cfg: MDIO Configuration Register.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0080 */

     /* CFG_TICK_CNT: Number of core clock cycles (250MHz) in        */
     /* each MDC phase. According to IEEE spec, MDC frequency        */
     /* should not exceed 2.5 MHz. Use value of <50> (or higher)     */
     /* for 2.5 MHz MDC clock (or slower).                           */
     /* range: 11:0, access type: UNDEF, default value: 0x32         */
     SOC_PETRA_REG_FIELD cfg_tick_cnt;

     /* CFG_TA_LENGTH: Reserved. Number of Turn Around (TA) bits     */
     /* to wait between Tx and Rx of data. Use value of <1>.         */
     /* range: 14:12, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD cfg_ta_length;

     /* CFG_INIT: If set, all MDIO registers and FSM will be         */
     /* reset. Set to <0> for normal operation.                      */
     /* range: 16:16, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD cfg_init;

     /* CFG_PD: Power Down mode. If set, MDIO clocks will be         */
     /* disabled. Set to <0> for normal operation.                   */
     /* range: 17:17, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD cfg_pd;

  } __ATTRIBUTE_PACKED__ mdio_cfg_reg;


  /* Mdio Op: MDIO OP Register. OP is dispatched after it is         */
  /* written to this register. When read, returns the last           */
  /* dispatched OP.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0081 */

     /* OP_DATA: Data to write to device. If this is a READ OP,      */
     /* this data will be ignored. If clause 45 format is used,      */
     /* this is the ADDRESS/DATA field.                              */
     /* range: 15:0, access type: UNDEF, default value: 0x0          */
     SOC_PETRA_REG_FIELD op_data;

     /* OP_TA: TurnAround bits are needed for READ Ops               */
     /* (contention prevention). In WRITE Ops simply transmit        */
     /* <10>.                                                        */
     /* range: 17:16, access type: UNDEF, default value: 0x2         */
     SOC_PETRA_REG_FIELD op_ta;

     /* OP_REGAD: Address of a register of the PHY device. If        */
     /* clause 45 format is used, this is the DEVAD field            */
     /* (Device Address).                                            */
     /* range: 22:18, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD op_regad;

     /* OP_PHYAD: Address of a PHY device. If clause 45 format       */
     /* is used, this is the PRTAD field (Port Address).             */
     /* range: 27:23, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD op_phyad;

     /* OP_OP: OP type. Use <10> for read or <01> for write OP.      */
     /* If clause 45 format is used, use also <00> to write to       */
     /* address register and <11> for read with automatic            */
     /* address increment after read.                                */
     /* range: 29:28, access type: UNDEF, default value: 0x2         */
     SOC_PETRA_REG_FIELD op_op;

     /* OP_ST: Start of frame. Use <01> for IEEE 802.3 clause 22     */
     /* compliance, and <00> for clause 45 compliance.               */
     /* range: 31:30, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD op_st;

  } __ATTRIBUTE_PACKED__ mdio_op_reg;


  /* Mdio Stat: MDIO Status Register. This register returns          */
  /* the results of the last dispatched OP.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0082 */

     /* STAT_DATA: For READ Ops, this is the data returned from      */
     /* the PHY device. For WRITE Ops this is the DATA/ADDRESS       */
     /* field of the MdioOp register.                                */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_data;

     /* STAT_TA: TA field of the MdioOp register.                    */
     /* range: 17:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_ta;

     /* STAT_REGAD: REGAD/DEVAD field of the MdioOp register.        */
     /* range: 22:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_regad;

     /* STAT_PHYAD: PHYAD/PRTAD field of the MdioOp register.        */
     /* range: 27:23, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_phyad;

     /* STAT_RD_EN: MSB of the OP field of the MdioOp register.      */
     /* <1> indicates this was a READ OP, <0> indicates a WRITE      */
     /* OP.                                                          */
     /* range: 29:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rd_en;

     /* STAT_TYPE: LSB of the OP ST field. <1> for Clause 22         */
     /* format, and <0> for clause 45 format.                        */
     /* range: 30:30, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_type;

     /* STAT_VALID: Indicates execution of last dispatched OP is     */
     /* complete.                                                    */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_valid;

  } __ATTRIBUTE_PACKED__ mdio_stat_reg;


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg;


  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg;


  /* Interrupt Block Mask Register: Each bit in this register       */
  /* corresponds to the interrupt source in the                     */
  /* InterruptBlockSourceRegister. The interrupt source is          */
  /* masked by writing 0 to the relevant bit in this                */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0100 */

     /* IpsIntMask: Writing 0 masks the IPS interrupt source.        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ips_int_mask;

     /* IqmIntMask: Writing 0 masks the IQM interrupt source.        */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD iqm_int_mask;

     /* QdrIntMask: Writing 0 masks the QDR interrupt source.        */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_int_mask;

     /* IptIntMask: Writing 0 masks the IPT interrupt source.        */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ipt_int_mask;

     /* MmuIntMask: Writing 0 masks the MMU interrupt source.        */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mmu_int_mask;

     /* DprcaIntMask: Writing 0 masks the DPRCA interrupt            */
     /* source.                                                      */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprca_int_mask;

     /* DprcbIntMask: Writing 0 masks the DPRCB interrupt            */
     /* source.                                                      */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcb_int_mask;

     /* DprccIntMask: Writing 0 masks the DPRCC interrupt            */
     /* source.                                                      */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcc_int_mask;

     /* DprcdIntMask: Writing 0 masks the DPRCD interrupt            */
     /* source.                                                      */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprcd_int_mask;

     /* DprceIntMask: Writing 0 masks the DPRCE interrupt            */
     /* source.                                                      */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprce_int_mask;

     /* DprcfIntMask: Writing 0 masks the DPRCF interrupt            */
     /* source.                                                      */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dprcf_int_mask;

     /* IreIntMask: Writing 0 masks the IRE interrupt source.        */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ire_int_mask;

     /* IhpIntMask: Writing 0 masks the IHP interrupt source.        */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ihp_int_mask;

     /* IdrIntMask: Writing 0 masks the IDR interrupt source.        */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD idr_int_mask;

     /* IrrIntMask: Writing 0 masks the IRR interrupt source.        */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD irr_int_mask;

     /* FdtIntMask: Writing 0 masks the FDT interrupt source.        */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdt_int_mask;

     /* FdrIntMask: Writing 0 masks the FDR interrupt source.        */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_int_mask;

     /* FctIntMask: Writing 0 masks the FCT interrupt source.        */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fct_int_mask;

     /* FcrIntMask: Writing 0 masks the FCR interrupt source.        */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fcr_int_mask;

     /* RtpIntMask: Writing 0 masks the RTP interrupt source.        */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rtp_int_mask;

     /* EgqIntMask: Writing 0 masks the EGQ interrupt source.        */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_int_mask;

     /* EpniIntMask: Writing 0 masks the EPNI interrupt source.      */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD epni_int_mask;

     /* MacaIntMask: Writing 0 masks the MACA interrupt source.      */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD maca_int_mask;

     /* MacbIntMask: Writing 0 masks the MACB interrupt source.      */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD macb_int_mask;

     /* MaccIntMask: Writing 0 masks the MACC interrupt source.      */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD macc_int_mask;

     /* SchIntMask: Writing 0 masks the SCH interrupt source.        */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sch_int_mask;

     /* OlpIntMask: Writing 0 masks the OLP interrupt source.        */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD olp_int_mask;

     /* CfcIntMask: Writing 0 masks the CFC interrupt source.        */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cfc_int_mask;

     /* MswIntMask: Writing 0 masks the MSW interrupt source.        */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD msw_int_mask;

     /* PdmcaIntMask: Writing 0 masks the PDMCA interrupt            */
     /* source.                                                      */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pdmca_int_mask;

     /* PdmcbIntMask: Writing 0 masks the PDMCB interrupt            */
     /* source.                                                      */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pdmcb_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_block_mask_reg;


  /* Interrupt Block Mask Register Cont: Each bit in this           */
  /* register corresponds to the interrupt source in the            */
  /* InterruptBlockSourceRegister. The interrupt source is          */
  /* masked by writing 0 to the relevant bit in this                */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0101 */

     /* NifaIntMask: Writing 0 masks the NIFA interrupt source.      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifa_int_mask;

     /* NifbIntMask: Writing 0 masks the NIFB interrupt source.      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifb_int_mask;

     /* MdioIntMask: Writing 0 masks the MDIO interrupt source.      */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mdio_int_mask;

     /* EciIntMask: Writing 0 masks the ECI interrupt source.        */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD eci_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_block_mask_register_cont_reg;


  /* Interrupt Block Source Register: A bit read HIGH               */
  /* indicates that there is an interrupt from the                  */
  /* corresponding source. This bit will only be cleared            */
  /* after the interrupt source is handled inside the               */
  /* relevant block.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0104 */

     /* IpsIntReg: IPS interrupt was set.                            */
     /* range: 0:0, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD ips_int_reg;

     /* IqmIntReg: IQM interrupt was set.                            */
     /* range: 1:1, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD iqm_int_reg;

     /* QdrIntReg: QDR interrupt was set.                            */
     /* range: 2:2, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD qdr_int_reg;

     /* IptIntReg: IPT interrupt was set.                            */
     /* range: 3:3, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD ipt_int_reg;

     /* MmuIntReg: MMU interrupt was set.                            */
     /* range: 4:4, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD mmu_int_reg;

     /* DprcaIntReg: DPRCA interrupt was set.                        */
     /* range: 5:5, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD dprca_int_reg;

     /* DprcbIntReg: DPRCB interrupt was set.                        */
     /* range: 6:6, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD dprcb_int_reg;

     /* DprccIntReg: DPRCC interrupt was set.                        */
     /* range: 7:7, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD dprcc_int_reg;

     /* DprcdIntReg: DPRCD interrupt was set.                        */
     /* range: 8:8, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD dprcd_int_reg;

     /* DprceIntReg: DPRCE interrupt was set.                        */
     /* range: 9:9, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD dprce_int_reg;

     /* DprcfIntReg: DPRCF interrupt was set.                        */
     /* range: 10:10, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD dprcf_int_reg;

     /* IreIntReg: IRE interrupt was set.                            */
     /* range: 11:11, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD ire_int_reg;

     /* IhpIntReg: IHP interrupt was set.                            */
     /* range: 12:12, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD ihp_int_reg;

     /* IdrIntReg: IDR interrupt was set.                            */
     /* range: 13:13, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD idr_int_reg;

     /* IrrIntReg: IRR interrupt was set.                            */
     /* range: 14:14, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD irr_int_reg;

     /* FdtIntReg: FDT interrupt was set.                            */
     /* range: 15:15, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD fdt_int_reg;

     /* FdrIntReg: FDR interrupt was set.                            */
     /* range: 16:16, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD fdr_int_reg;

     /* FctIntReg: FCT interrupt was set.                            */
     /* range: 17:17, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD fct_int_reg;

     /* FcrIntReg: FCR interrupt was set.                            */
     /* range: 18:18, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD fcr_int_reg;

     /* RtpIntReg: RTP interrupt was set.                            */
     /* range: 19:19, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD rtp_int_reg;

     /* EgqIntReg: EGQ interrupt was set.                            */
     /* range: 20:20, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD egq_int_reg;

     /* EpniIntReg: EPNI interrupt was set.                          */
     /* range: 21:21, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD epni_int_reg;

     /* MacaIntReg: MACA interrupt was set.                          */
     /* range: 22:22, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD maca_int_reg;

     /* MacbIntReg: MACB interrupt was set.                          */
     /* range: 23:23, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD macb_int_reg;

     /* MaccIntReg: MACC interrupt was set.                          */
     /* range: 24:24, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD macc_int_reg;

     /* SchIntReg: SCH interrupt was set.                            */
     /* range: 25:25, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD sch_int_reg;

     /* OlpIntReg: OLP interrupt was set.                            */
     /* range: 26:26, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD olp_int_reg;

     /* CfcIntReg: CFC interrupt was set.                            */
     /* range: 27:27, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD cfc_int_reg;

     /* MswIntReg: MSW interrupt was set.                            */
     /* range: 28:28, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD msw_int_reg;

     /* PdmcaIntReg: PDMCA interrupt was set.                        */
     /* range: 29:29, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD pdmca_int_reg;

     /* PdmcbIntReg: PDMCB interrupt was set.                        */
     /* range: 30:30, access type: RO, default value: undef          */
     SOC_PETRA_REG_FIELD pdmcb_int_reg;

  } __ATTRIBUTE_PACKED__ interrupt_block_source_reg;


  /* Interrupt Block Source Register Cont: A bit read HIGH          */
  /* indicates that there is an interrupt from the                  */
  /* corresponding source. This bit will only be cleared            */
  /* after the interrupt source is handled inside the               */
  /* relevant block.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0105 */

     /* NifaIntReg: NIFA interrupt was set.                          */
     /* range: 0:0, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD nifa_int_reg;

     /* NifbIntReg: NIFB interrupt was set.                          */
     /* range: 1:1, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD nifb_int_reg;

     /* MdioIntReg: MDIO interrupt was set.                          */
     /* range: 2:2, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD mdio_int_reg;

     /* EciIntReg: ECI interrupt was set.                            */
     /* range: 3:3, access type: RO, default value: undef            */
     SOC_PETRA_REG_FIELD eci_int_reg;

  } __ATTRIBUTE_PACKED__ interrupt_block_source_register_cont_reg;


  /* Mask All Interrupts:                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0108 */

     /* AllIntMask: When set LOW, masks all interrupt sources.       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD all_int_mask;

  } __ATTRIBUTE_PACKED__ mask_all_interrupts_reg;


  /* Override Interrupt:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0109 */

     /* OverrideInterrupt: If set interrupt pin is active            */
     /* regardless interrupt sources.                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD override_interrupt;

  } __ATTRIBUTE_PACKED__ override_interrupt_reg;

  /* Fat Pipe Conf:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0198 */

     /* Fat Pipe enable configuration            */
     /* range: 31:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fatp_conf;

  } __ATTRIBUTE_PACKED__ fatp_conf_reg;

  /* Fat Pipe Enable:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x01ab */

     /* Fat Pipe enable configuration            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fatp_enable;

  } __ATTRIBUTE_PACKED__ fatp_enable_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_ECI_REGS;
/* Block definition: OLP */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4400 */

     /* EndReadErr: If set, indicates that an end indication         */
     /* error during a read command has occurred on the Command      */
     /* Reception Machine (CRM).                                     */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_read_err;

     /* EndWriteErr: If set, indicates that an end indication        */
     /* error during a write command has occurred on the Command     */
     /* Reception Machine (CRM).                                     */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_write_err;

     /* StartErr: If set, indicates that a start indication          */
     /* error has occurred on the Command Reception Machine          */
     /* (CRM).                                                       */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD start_err;

     /* EndReadExpErr: If set, indicates that an end indication      */
     /* during a read command did not assert compared to the         */
     /* expected value on the Command Reception Machine (CRM).       */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_read_exp_err;

     /* EndWriteExpErr: If set, indicates that an end indication     */
     /* during a write command did not assert compared to the        */
     /* expected value on the Command Reception Machine (CRM).       */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_write_exp_err;

     /* StartExpErr: If set, indicates that a start indication       */
     /* did not assert compared to the expected value on the         */
     /* Command Reception Machine (CRM).                             */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD start_exp_err;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4410 */

     /* EndReadErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_read_err_mask;

     /* EndWriteErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_write_err_mask;

     /* StartErrMask: Writing 0 masks the corresponding              */
     /* interrupt source                                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD start_err_mask;

     /* EndReadExpErrMask: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_read_exp_err_mask;

     /* EndWriteExpErrMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_write_exp_err_mask;

     /* StartExpErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD start_exp_err_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;



  /* Indirect Command Wr Data: Indirect write data - data           */
  /* that will be written to the addressed object when an           */
  /* indirect write operation is triggered.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4420 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Rd Data: Indirect read data - data is         */
  /* returned by an indirect read operation.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4430 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command: Used to send indirect commands and           */
  /* receive their status.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4440 */

     /* IndirectCommandTrigger: Trigger indirect access, as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automactically sets        */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one for each write command. If set to 0,         */
     /* only one operation is performed. The CPU can read this       */
     /* field to find the number of writes that are left to          */
     /* perform.                                                     */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then the last command failed on             */
     /* timeout.                                                     */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4441 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;

  /* Scratch Pad: Reserved for software's use                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4452 */

     /* ScratchPad: Reserved for software's use                      */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD scratch_pad;

  } __ATTRIBUTE_PACKED__ scratch_pad_reg;

  /* Incremental Mode Configurations: Packet Generation             */
  /* Engine (PGE) Incremental Mode Configurations.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4461 */

     /* IncVal: Packet Generation Engine (PGE) Incremental           */
     /* Value. A 16b value to add to a specific 16 bits in the       */
     /* Packet.                                                      */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD inc_val;

     /* IncOffset: Packet Generation Engine (PGE) Incremental        */
     /* Offset. Determines a specific 2 bytes to be added to         */
     /* IncVal. (Alignment is in 2-Bytes resolution).                */
     /* range: 28:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD inc_offset;

  } __ATTRIBUTE_PACKED__ incremental_mode_configurations_reg;


  /* Packet Configuration Register: Packet Generation Engine        */
  /* (PGE) Packet Configuration register.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4462 */

     /* PcktLength: The size of the packet generated by the          */
     /* Packet Generation Engine (PGE)                               */
     /* range: 13:0, access type: RW, default value: 0x7f            */
     SOC_PETRA_REG_FIELD pckt_length;

     /* PcktLengthMode: Packet Generation Engine (PGE) Mode for      */
     /* the case when the PcktLength is bigger than 128 bytes: 0     */
     /* - cyclic mode - the PgeMem will be repeatedly                */
     /* concatenated until required size is achieved. 1-             */
     /* incremental mode - the packet is padded by 32b words         */
     /* until size is achieved. Each new 32b word is the sum of      */
     /* previous 32b word and PcktLengthIncVal.                      */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pckt_length_mode;

  } __ATTRIBUTE_PACKED__ packet_configuration_reg;


  /* Packet Counter Configuration: Packet Generation Engine         */
  /* (PGE) Packet Counter.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4463 */

     /* PcktCnt: Number of packets to be generated by the PGE.       */
     /* 0xffffffff - indicates continuous mode 0x0 - stops the       */
     /* PGE on the next packet boundary.                             */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pckt_cnt;

  } __ATTRIBUTE_PACKED__ packet_counter_configuration_reg;


  /* Packet Delay Configuration: Packet Generation Engine           */
  /* (PGE) Packet Delay.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4464 */

     /* PcktDelay: Number of cycles delay between one packet and     */
     /* the next, in addition to 4 cycles delay.                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pckt_delay;

  } __ATTRIBUTE_PACKED__ packet_delay_configuration_reg;


  /* Packet Length Incremental Value: Packet Generation             */
  /* Engine (PGE) Packet Length Incremental value.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4465 */

     /* PcktLengthIncVal: A 32b value to add to the next 32b         */
     /* word when PcktLengthMode is 1 (incremental).                 */
     /* range: 31:0, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD pckt_length_inc_val;

  } __ATTRIBUTE_PACKED__ packet_length_incremental_value_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_OLP_REGS;
/* Block definition: NIF 0X14000,0X15000 */
typedef struct
{
  uint32   nof_instances; /* 2 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: NIF Main interrupt register.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5000 */

     /* MalInterrupt: MAC Lane 0 Interrupts. (For further            */
     /* information, see InterruptRegister for MAC Lane 0.)          */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD mal_interrupt[SOC_PETRA_MAX_NIFS_PER_MAL];

     /* SrdInterrupt: If set, indicates an interrupt was             */
     /* generated by one of the SerDes lanes or the IPU (IPU)       */
     /* in the coresponding SRD Group.                               */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD srd_interrupt;

     /* RxInterrupt: If set, indicates an interrupt was              */
     /* generated by one of the SerDes lanes or the IPU (IPU)       */
     /* in the coresponding SRD Group.                               */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_interrupt;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Srd Interrupt Register:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5001 */

     /* SrdLaneInterrupt: Interrupts from the 16 SerDes lanes.       */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd_lane_interrupt;

     /* SrdIpuInterrupt: If set, indicates that IPU (IPU)           */
     /* triggered an interrupt (due to IPU parity error, IntReq     */
     /* or IntAck).                                                  */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt;

     /* SrdEpbInterrupt: If set, indicates that EPB FSM detected     */
     /* overrun error. This error is caused when an EPB_OP is        */
     /* dispatched when a previous EPB_OP is still executing.        */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt;

  } __ATTRIBUTE_PACKED__ srd_interrupt_reg;


  /* Rx Interrupt Register:                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5002 */

     /* RxPaebInterrupt: If set, indicates Rx PA/EB                  */
     /* synchronization error has occurred. This may be a result     */
     /* of large PPM reference clock offset combined with very       */
     /* large packets in slow SGMII 10/100 links.                    */
     /* range: 21:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_paeb_interrupt;

  } __ATTRIBUTE_PACKED__ rx_interrupt_reg;


  /* Interrupt Mask Register: Interrupt Mask Register.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5010 */

     /* MalInterruptMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mal_interrupt_mask[SOC_PETRA_MAX_NIFS_PER_MAL];

     /* SrdInterruptMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD srd_interrupt_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Srd Interrupt Mask Register: SerDes Interrupt Mask             */
  /* Register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5011 */

     /* SrdLaneInterruptMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd_lane_interrupt_mask;

     /* SrdIpuInterruptMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt_mask;

     /* SrdEpbInterruptMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt_mask;

  } __ATTRIBUTE_PACKED__ srd_interrupt_mask_reg;


  /* Rx Interrupt Mask Register:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5012 */

     /* RxPaebInterruptMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 21:0, access type: RW, default value: 22'h000000      */
     SOC_PETRA_REG_FIELD rx_paeb_interrupt_mask;

  } __ATTRIBUTE_PACKED__ rx_interrupt_mask_reg;


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg;


  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg;


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg1;


  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg1;


  /* NIF_Status: Status register of Tx MAC Lane FIFO each of        */
  /* the MAC Lanes.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5060 */

     /* LaneStatus: If set, indicates that the relevant Tx MAC       */
     /* Lane FIFO (MLF) crossed the TxAlmostFullThreshold for        */
     /* that MAL. This implies that the egress oversubscribes        */
     /* the Tx path. Bit 0 of each lane (register bits 0, 4, 8,      */
     /* 12) used for XAUI.                                           */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lane_status;

  } __ATTRIBUTE_PACKED__ nif_status_reg;


  /* NIF_Config: Global NIF configuration and status register       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5061 */

     /* Serdes_G4_En: If set, the fourth SerDes group may be         */
     /* used by the NIF. Otherwise, it is used for communicating     */
     /* with FE.                                                     */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD serdes_g4_en;

     /* ConfigErr: If set, indicates that the user has               */
     /* configured the NIF in an invalid way. This results from      */
     /* invalid configuration of MAC lanes for single/double         */
     /* rate or 32/48 bit mode. (See Soc_petra data sheet.)              */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD config_err;

     /* PDMC_En: If set, PDMC ports are enabled and data is          */
     /* allowed into the Ingress path. Otherwise, PDMC ports are     */
     /* held in reset and data is masked.                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pdmc_en;

     /* PDMC_PD: If set, PDMC clocks are powered down.               */
     /* range: 9:9, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD pdmc_pd;

     /* PDMC_LoopbackEn: If set, PDMC will operate in loopback       */
     /* mode (Rx path will receve same clock as Tx path).            */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pdmc_loopback_en;

     /* PDMC_ExtLoopbackEn: If set, PDMC will operate in             */
     /* external loopback mode (both Rx and Tx paths will receve     */
     /* clocks from core clock divided by 2, i.e. 125 MHz clk).      */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pdmc_ext_loopback_en;

  } __ATTRIBUTE_PACKED__ nif_config_reg;


  /* NIF_DFT: NIF internal DFT features that reset specific         */
  /* sub-modules                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5062 */

     /* InitCfcCalendar: If set, CFC Callendar interface will be     */
     /* reset.                                                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD init_cfc_calendar;

     /* InitTxSplitter: If set, Tx Splitter (EGQ interface) will     */
     /* be reset.                                                    */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD init_tx_splitter;

     /* InitRxInterleaver: If set, Rx Interleaver (IRE               */
     /* interface) will be reset.                                    */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD init_rx_interleaver;

     /* InitMalHardReset: If set, MAL will be hard reset             */
     /* (inlcuding CPU registers).                                   */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD init_mal_hard_reset;

     /* InitMalSoftReset: If set, MAL will be soft reset             */
     /* (excluding CPU registers).                                   */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD init_mal_soft_reset;

     /* InitPdmcHardReset: If set, PDMC will be hard reset           */
     /* (inlcuding CPU registers).                                   */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD init_pdmc_hard_reset;

  } __ATTRIBUTE_PACKED__ nif_dft_reg;


  /* NIF_BOM_DFT: NIF internal DFT features to monitor PPM in       */
  /* RxBOM-Elastic-Buffers                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5063 */

     /* RxPaebRdPtrSel: Reserved.                                    */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_paeb_rd_ptr_sel;

     /* RxMalA_PaebRdPtrValid: Reserved.                             */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mal_a_paeb_rd_ptr_valid;

     /* RxMalB_PaebRdPtrValid: Reserved.                             */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mal_b_paeb_rd_ptr_valid;

     /* RxMalC_PaebRdPtrValid: Reserved.                             */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mal_c_paeb_rd_ptr_valid;

     /* RxMalD_PaebRdPtrValid: Reserved.                             */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mal_d_paeb_rd_ptr_valid;

     /* RxMalA_PaebRdPtrInd: Reserved.                               */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mal_a_paeb_rd_ptr_ind;

     /* RxMalB_PaebRdPtrInd: Reserved.                               */
     /* range: 23:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mal_b_paeb_rd_ptr_ind;

     /* RxMalC_PaebRdPtrInd: Reserved.                               */
     /* range: 27:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mal_c_paeb_rd_ptr_ind;

     /* RxMalD_PaebRdPtrInd: Reserved.                               */
     /* range: 31:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mal_d_paeb_rd_ptr_ind;

  } __ATTRIBUTE_PACKED__ nif_bom_dft_reg;


  /* BIST_Tx CFG: NIF BIST Tx Configuration                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5080 */

     /* BIST_TxEn: If set, start transmitting BIST data.             */
     /* Otherwse, reset the BIST Tx hardware and counters.           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_tx_en;

     /* BIST_TxFlowContinuity: If set, packet indexing will be       */
     /* continuous among flows. Otherwise, the indexing will         */
     /* reset to 0 each time a new flow begins.                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_tx_flow_continuity;

     /* BIST_TxPort: Select one of the 4 NIF MAC Lanes (2 msbs       */
     /* of the Port indicaiton) for BIST test. The 2 lsbs of the     */
     /* port are defined in the flow descriptor.                     */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_tx_port;

     /* BIST_TxNumberOfFlows: Select how many flows should be        */
     /* transmitted.                                                 */
     /* range: 31:12, access type: RW, default value: 0xa            */
     SOC_PETRA_REG_FIELD bist_tx_number_of_flows;

  } __ATTRIBUTE_PACKED__ bist_tx_cfg_reg;


  /* BIST_Tx Pkt Length Seed: NIF BIST Tx Seed for Packet           */
  /* length randomization function                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5081 */

     /* BIST_TxPktLengthSeed: Seed for the 14b LFSR used to          */
     /* randomize the packet length                                  */
     /* range: 13:0, access type: RW, default value: 0x3a3a          */
     SOC_PETRA_REG_FIELD bist_tx_pkt_length_seed;

  } __ATTRIBUTE_PACKED__ bist_tx_pkt_length_seed_reg;


  /* BIST_Tx Breakpoint: NIF BIST Tx Breakpoint                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5082 */

     /* BIST_TxBreakpointOnPkt: Set limit for the total number       */
     /* of packets to transmit. The Tx BIST will stop the test       */
     /* after that packet was transmitted.                           */
     /* range: 29:0, access type: RW, default value: 30'h3fffffff    */
     SOC_PETRA_REG_FIELD bist_tx_breakpoint_on_pkt;

  } __ATTRIBUTE_PACKED__ bist_tx_breakpoint_reg;


  /* BIST_Tx Status1: NIF BIST Tx Status Counters                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5083 */

     /* BIST_TxCntPkts: Indicate total number of packets that        */
     /* were transmitted (updated after EOP and IPG were sent).      */
     /* range: 29:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_cnt_pkts;

     /* BIST_TxDone: Indicate test is done (all packets and all      */
     /* flows were transmitted, or Breakpoint was reached).          */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_tx_done;

  } __ATTRIBUTE_PACKED__ bist_tx_status1_reg;


  /* BIST_Tx Status2: NIF BIST Tx Status Counters                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5084 */

     /* BIST_TxCntFlows: Indicate number of flows that were          */
     /* transmitted (updated after last pkt of flow was sent).       */
     /* range: 19:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_cnt_flows;

  } __ATTRIBUTE_PACKED__ bist_tx_status2_reg;


  /* BIST_Tx Status3: NIF BIST Tx Status Counters                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5085 */

     /* BIST_TxCntErrPkts: Indicate number of packets that were      */
     /* transmitted with deliberate CRC errors.                      */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_cnt_err_pkts;

  } __ATTRIBUTE_PACKED__ bist_tx_status3_reg;


  /* BIST_Tx Flow Desc1: NIF BIST Tx Flow Descriptor                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5090 */

     /* FlowDescDataSeed: Seed for the data generation mechanism     */
     /* (see DataType field). Note should be taken to use seed       */
     /* values other than 0 when in random data type mode. Bits      */
     /* [4:0] are used to load the error insertion LFSR, and         */
     /* bits [30:28] are used to enable error insertion on BOP,      */
     /* EOP and SOP (respectively).                                  */
     /* range: 31:0, access type: UNDEF, default value: 0x0          */
     SOC_PETRA_REG_FIELD flow_desc_data_seed;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc1_reg_0;


  /* BIST_Tx Flow Desc1: NIF BIST Tx Flow Descriptor                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5091 */

     /* FlowDescIpg: Set idle time between generated packets.        */
     /* This time is measured in 8B quantas at system core clock     */
     /* (250MHz).                                                    */
     /* range: 7:0, access type: UNDEF, default value: 0x2           */
     SOC_PETRA_REG_FIELD flow_desc_ipg;

     /* FlowDescPktsInFlow: Set the number of packet to generate     */
     /* befor moving to the next flow.                               */
     /* range: 17:8, access type: UNDEF, default value: 0x64         */
     SOC_PETRA_REG_FIELD flow_desc_pkts_in_flow;

     /* FlowDescMinPktLength: Set the minimal packet length (see     */
     /* PktLengthMask).                                              */
     /* range: 31:18, access type: UNDEF, default value: 0x40        */
     SOC_PETRA_REG_FIELD flow_desc_min_pkt_length;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc1_reg_1;


  /* BIST_Tx Flow Desc1: NIF BIST Tx Flow Descriptor                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5092 */

     /* FlowDescPktLengthMask: Packet length is determined by        */
     /* MinPktLength field + masked random value. The masked         */
     /* random value is taken from 14b LFSR after it is masked       */
     /* by PktLengthMask field of the flow descriptor.               */
     /* range: 13:0, access type: UNDEF, default value: 0xf          */
     SOC_PETRA_REG_FIELD flow_desc_pkt_length_mask;

     /* FlowDescPT: Set the PT bits of the BCT.                      */
     /* range: 16:14, access type: UNDEF, default value: 0x3         */
     SOC_PETRA_REG_FIELD flow_desc_pt;

     /* FlowDescLLFC: Set the LLFC bit of the BCT.                   */
     /* range: 17:17, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD flow_desc_llfc;

     /* FlowDescInsertErrorInc: Step for error insertion             */
     /* counter. This affects the per-packet probability of          */
     /* error insertion and location where error is indicated to     */
     /* the Tx MAC (SOP, BOP, EOP or combinations). Use value of     */
     /* 1 for 1:4 chance, value of 2 for 1:2 chance and value of     */
     /* 4 for 100% error insertion. Other velues are reserved.       */
     /* range: 22:18, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD flow_desc_insert_error_inc;

     /* FlowDescInsertError: If set, CRC errors will be inserted     */
     /* into the Tx packets.                                         */
     /* range: 23:23, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD flow_desc_insert_error;

     /* FlowDescDataType: Select the data type for packet data       */
     /* generation: [00] Constant data (taken from the 32b           */
     /* SEED). [01] Incremental data (start counting from the        */
     /* SEED). [10] Random data based on LFSR (reset to the          */
     /* SEED). [11] Reserved (unsupported Pause Frames, use seed     */
     /* as pause quanta).                                            */
     /* range: 25:24, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD flow_desc_data_type;

     /* FlowDescPort: Select the SGMII port (2 lsbs of the port      */
     /* indication).                                                 */
     /* range: 27:26, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD flow_desc_port;

     /* FlowDescValid: If set, descriptor will be used by the Tx     */
     /* BIST.                                                        */
     /* range: 28:28, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD flow_desc_valid;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc1_reg_2;


  /* BIST_Tx Flow Desc2:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5094 */

     /* BIST_TxFlowDesc2: NIF BIST Tx Flow Descriptor                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_flow_desc2;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc2_reg_0;


  /* BIST_Tx Flow Desc2:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5095 */

     /* BIST_TxFlowDesc2: NIF BIST Tx Flow Descriptor                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_flow_desc2;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc2_reg_1;


  /* BIST_Tx Flow Desc2:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5096 */

     /* BIST_TxFlowDesc2: NIF BIST Tx Flow Descriptor                */
     /* range: 28:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_flow_desc2;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc2_reg_2;


  /* BIST_Tx Flow Desc3:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5098 */

     /* BIST_TxFlowDesc3: NIF BIST Tx Flow Descriptor                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_flow_desc3;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc3_reg_0;


  /* BIST_Tx Flow Desc3:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5099 */

     /* BIST_TxFlowDesc3: NIF BIST Tx Flow Descriptor                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_flow_desc3;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc3_reg_1;


  /* BIST_Tx Flow Desc3:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x509a */

     /* BIST_TxFlowDesc3: NIF BIST Tx Flow Descriptor                */
     /* range: 28:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_flow_desc3;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc3_reg_2;


  /* BIST_Tx Flow Desc4:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x509c */

     /* BIST_TxFlowDesc4: NIF BIST Tx Flow Descriptor                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_flow_desc4;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc4_reg_0;


  /* BIST_Tx Flow Desc4:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x509d */

     /* BIST_TxFlowDesc4: NIF BIST Tx Flow Descriptor                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_flow_desc4;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc4_reg_1;


  /* BIST_Tx Flow Desc4:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x509e */

     /* BIST_TxFlowDesc4: NIF BIST Tx Flow Descriptor                */
     /* range: 28:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_tx_flow_desc4;

  } __ATTRIBUTE_PACKED__ bist_tx_flow_desc4_reg_2;


  /* BIST_Rx CFG: NIF BIST Rx Configuration                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50a0 */

     /* BIST_RxEn: If set, start monitoring Rx data. Otherwse,       */
     /* reset the BIST Rx hardware and counters.                     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_rx_en;

     /* BIST_RxFlowContinuity: If set, packet indexing will be       */
     /* continuous among flows. Otherwise, the indexing will         */
     /* reset to 0 each time a new flow begins.                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_rx_flow_continuity;

     /* BIST_RxPort: Select one of the 16 NIF ports. Packets         */
     /* received from that port will be monitored by the BIST Rx     */
     /* checker.                                                     */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_rx_port;

  } __ATTRIBUTE_PACKED__ bist_rx_cfg_reg;


  /* BIST_Rx Status1: NIF BIST Rx Indications                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50a1 */

     /* BIST_RxCntPkts: Indicate number of packets that were         */
     /* received (updated after EOP).                                */
     /* range: 29:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_cnt_pkts;

  } __ATTRIBUTE_PACKED__ bist_rx_status1_reg;


  /* BIST_Rx Status2: NIF BIST Rx Indications                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50a2 */

     /* BIST_RxCntFlows: Indicate number of flows that were          */
     /* received. Updated on first packet of each flow               */
     /* (identified by packet index = 0). Not relevant when flow     */
     /* continuity is enabled.                                       */
     /* range: 19:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_cnt_flows;

  } __ATTRIBUTE_PACKED__ bist_rx_status2_reg;


  /* BIST_Rx Err Cnt1: NIF BIST Rx Error Counters                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50a3 */

     /* BIST_RxCntErrData: Indicate number of packets with Data      */
     /* mismatch errors.                                             */
     /* range: 7:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_rx_cnt_err_data;

     /* BIST_RxCntErrLength: Indicate number of packets with         */
     /* Length mismatch errors.                                      */
     /* range: 15:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_cnt_err_length;

     /* BIST_RxCntErrIndex: Indicate number of packets with          */
     /* Index mismatch errors.                                       */
     /* range: 23:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_cnt_err_index;

     /* BIST_RxErrStatus: Indicate accumulated error status          */
     /* during entire test. Each bit represents a different type     */
     /* of error: [0] Packet Index error (i.e. a packet was          */
     /* skipped). [1] Packet Data error. [2] Packet length           */
     /* error. [3] Packets with CRC errors that were not             */
     /* detected. [4] Other MAC/PCS errors.                          */
     /* range: 28:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_err_status;

  } __ATTRIBUTE_PACKED__ bist_rx_err_cnt1_reg;


  /* BIST_Rx Err Cnt2: NIF BIST Rx Error Counters                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50a4 */

     /* BIST_RxCntErrCrcMiss: Indicate number of packets with        */
     /* deliberate CRC errors that were not detected by MAC.         */
     /* range: 7:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_rx_cnt_err_crc_miss;

     /* BIST_RxCntErrMAC: Indicate number of packets received        */
     /* with MAC errors (excluding deliberate CRC errors).           */
     /* range: 15:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_cnt_err_mac;

     /* BIST_RxCntCrcOk: Indicate number of packets with             */
     /* deliberate CRC errors that were properly detected by         */
     /* MAC.                                                         */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_cnt_crc_ok;

  } __ATTRIBUTE_PACKED__ bist_rx_err_cnt2_reg;


  /* BIST_Rx Cnt Event Sel: NIF BIST Rx Event Counter:              */
  /* Qualify events to count. More than one event may be            */
  /* qualified simultaneously.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50a5 */

     /* BIST_RxCntEventMacErr: Count packets with MAC/PCS            */
     /* errors.                                                      */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD bist_rx_cnt_event_mac_err;

     /* BIST_RxCntEventCrcMissErr: Count undetected CRC errors       */
     /* (packets with descriptor that indicates they were            */
     /* transmitted with CRC error that was not detected by          */
     /* receiver).                                                   */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD bist_rx_cnt_event_crc_miss_err;

     /* BIST_RxCntEventPktLengthErr: Count packets with length       */
     /* mismatch errors (that doesn't match the packet               */
     /* descriptor).                                                 */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD bist_rx_cnt_event_pkt_length_err;

     /* BIST_RxCntEventPktDataErr: Count packets with data           */
     /* mismatch errors (that doesn't match the packet               */
     /* descriptor).                                                 */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD bist_rx_cnt_event_pkt_data_err;

     /* BIST_RxCntEventPktIndexErr: Count packets with index         */
     /* mismatch errors (that doesn't match the packet               */
     /* descriptor).                                                 */
     /* range: 4:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD bist_rx_cnt_event_pkt_index_err;

     /* BIST_RxCntEventPktEop: Count EOP's.                          */
     /* range: 5:5, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD bist_rx_cnt_event_pkt_eop;

     /* BIST_RxCntEventGoodPkts: Count packets that were             */
     /* received without any MAC/PCS errors or any CRC errors        */
     /* (regardless of the BIST check results).                      */
     /* range: 6:6, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD bist_rx_cnt_event_good_pkts;

     /* BIST_RxCntEventPktChkOk: Count packets that were             */
     /* received without any MAC/PCS errors or any BIST Checker      */
     /* errors (i.e. packets that match their descriptor).           */
     /* range: 7:7, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD bist_rx_cnt_event_pkt_chk_ok;

  } __ATTRIBUTE_PACKED__ bist_rx_cnt_event_sel_reg;


  /* BIST_Rx Cnt Event: NIF BIST Rx Event Counter                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50a6 */

     /* BIST_RxCntEvent: Indicate number of events that were         */
     /* detected. The type of the events are selected by             */
     /* BIST_RxCntEventSel register.                                 */
     /* range: 29:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_cnt_event;

  } __ATTRIBUTE_PACKED__ bist_rx_cnt_event_reg;


  /* BIST_Rx Snapshot1: NIF BIST Rx Snapshot control                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50a7 */

     /* BIST_RxSnapshot1Limit: The snapshot mechanism will           */
     /* perform the snapshot after the number of selected events     */
     /* reaches this limit.                                          */
     /* range: 29:0, access type: RW, default value: 30'h3fffffff    */
     SOC_PETRA_REG_FIELD bist_rx_snapshot1_limit;

     /* BIST_RxSnapshot1Type: Select the type of events to           */
     /* monitor by the snapshot mechanism. Once event counter        */
     /* reaches the limit, the snapshot of the descriptor will       */
     /* be taken. Possible types are: [00] - off [01] - use the      */
     /* event counter [10] - use the total number of packets         */
     /* counter [11] - use flow number counter and packet index      */
     /* (from descriptor). In this case, flow number will be         */
     /* compared to bits [29:10] of the limit, and the packet        */
     /* index to bits [9:0] of the limit.                            */
     /* range: 31:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_snapshot1_type;

  } __ATTRIBUTE_PACKED__ bist_rx_snapshot1_reg;


  /* BIST_Rx Snapshot1 Data: NIF BIST Rx Snapshot data              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50a8 */

     /* BIST_RxSnapshotPktDesc: Descriptor snapshot                  */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_snapshot_pkt_desc;

  } __ATTRIBUTE_PACKED__ bist_rx_snapshot1_data_reg_0;


  /* BIST_Rx Snapshot1 Data: NIF BIST Rx Snapshot data              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50a9 */

     /* BIST_RxSnapshotPktDesc: Descriptor snapshot                  */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_snapshot_pkt_desc;

  } __ATTRIBUTE_PACKED__ bist_rx_snapshot1_data_reg_1;


  /* BIST_Rx Snapshot1 Data: NIF BIST Rx Snapshot data              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50aa */

     /* BIST_RxSnapshotPktIndex: Index of the packet since the       */
     /* beginning of the test                                        */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_snapshot_pkt_index;

     /* BIST_RxSnapshotFlowIndex: Index of the flow since the        */
     /* beginning of the test                                        */
     /* range: 31:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_snapshot_flow_index;

  } __ATTRIBUTE_PACKED__ bist_rx_snapshot1_data_reg_2;


  /* BIST_Rx Snapshot1 Data: NIF BIST Rx Snapshot data              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50ab */

     /* BIST_RxSnapshotFlowIndex: Index of the flow since the        */
     /* beginning of the test                                        */
     /* range: 11:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_snapshot_flow_index;

     /* BIST_RxSnapshotValid: Indicate snapshot data is valid        */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_snapshot_valid;

     /* BIST_RxSnapshotPktErr: Error indications from last           */
     /* packt. Each bit represents a different type of error:        */
     /* [0] Packet index mismatch error [1] Packet data mismatch     */
     /* error [2] Packet length mismatch error [3] Packet CRC        */
     /* error was not detected [4] Packet was received with          */
     /* MAC/PCS or CRC errors (this is unmasked indication from      */
     /* MAC, and includes deliberate CRC errors as indicated by      */
     /* the packet descriptor).                                      */
     /* range: 20:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_snapshot_pkt_err;

     /* BIST_RxSnapshotErrSticky: Sticky error indications from      */
     /* the beginning of the test until the snapshot was taken.      */
     /* Each bit represents a different type of error: [0]           */
     /* Packet index mismatch error [1] Packet data mismatch         */
     /* error [2] Packet length mismatch error [3] Packet CRC        */
     /* error was not detected [4] Packet was received with          */
     /* MAC/PCS or CRC errors (excluding deliberate CRC errors,      */
     /* as indicated by the packet descriptor).                      */
     /* range: 28:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_snapshot_err_sticky;

  } __ATTRIBUTE_PACKED__ bist_rx_snapshot1_data_reg_3;


  /* BIST_Rx Snapshot2: NIF BIST Rx Snapshot control                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50ac */

     /* BIST_RxSnapshot2Limit: The snapshot mechanism will           */
     /* perform the snapshot after the number of selected events     */
     /* reaches this limit.                                          */
     /* range: 29:0, access type: RW, default value: 30'h3fffffff    */
     SOC_PETRA_REG_FIELD bist_rx_snapshot2_limit;

     /* BIST_RxSnapshot2Type: Select the type of events to           */
     /* monitor by the snapshot mechanism. Once event counter        */
     /* reaches the limit, the snapshot of the descriptor will       */
     /* be taken. Possible types are: [00] - off [01] - use the      */
     /* event counter [10] - use the total number of packets         */
     /* counter [11] - use flow number counter and packet index      */
     /* (from descriptor). In this case, flow number will be         */
     /* compared to bits [29:10] of the limit, and the packet        */
     /* index to bits [9:0] of the limit.                            */
     /* range: 31:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_rx_snapshot2_type;

  } __ATTRIBUTE_PACKED__ bist_rx_snapshot2_reg;


  /* BIST_Rx Snapshot2 Data:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50ad */

     /* BIST_RxSnapshot2Data: NIF BIST Rx Snapshot data (see bit     */
     /* definitions of BIST_RxSnapshot1Data)                         */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_snapshot2_data;

  } __ATTRIBUTE_PACKED__ bist_rx_snapshot2_data_reg_0;


  /* BIST_Rx Snapshot2 Data:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50ae */

     /* BIST_RxSnapshot2Data: NIF BIST Rx Snapshot data (see bit     */
     /* definitions of BIST_RxSnapshot1Data)                         */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_snapshot2_data;

  } __ATTRIBUTE_PACKED__ bist_rx_snapshot2_data_reg_1;


  /* BIST_Rx Snapshot2 Data:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50af */

     /* BIST_RxSnapshot2Data: NIF BIST Rx Snapshot data (see bit     */
     /* definitions of BIST_RxSnapshot1Data)                         */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_snapshot2_data;

  } __ATTRIBUTE_PACKED__ bist_rx_snapshot2_data_reg_2;


  /* BIST_Rx Snapshot2 Data:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x50b0 */

     /* BIST_RxSnapshot2Data: NIF BIST Rx Snapshot data (see bit     */
     /* definitions of BIST_RxSnapshot1Data)                         */
     /* range: 28:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_rx_snapshot2_data;

  } __ATTRIBUTE_PACKED__ bist_rx_snapshot2_data_reg_3;


  /* srd0_LN0_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5100 */

     /* srd0_LN0_cfga: SerDes Lane 0 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln0_cfga_reg;


  /* srd0_LN0_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5101 */

     /* srd0_LN0_stat: SerDes Lane 0 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln0_stat_reg;


  /* srd0_LN0_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5102 */

     /* srd0_LN0_EBIST: SerDes Lane 0 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln0_ebist_reg;


  /* srd0_LN1_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5104 */

     /* srd0_LN1_cfga: SerDes Lane 1 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln1_cfga_reg;


  /* srd0_LN1_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5105 */

     /* srd0_LN1_stat: SerDes Lane 1 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln1_stat_reg;


  /* srd0_LN1_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5106 */

     /* srd0_LN1_EBIST: SerDes Lane 1 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln1_ebist_reg;


  /* srd0_LN2_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5108 */

     /* srd0_LN2_cfga: SerDes Lane 2 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln2_cfga_reg;


  /* srd0_LN2_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5109 */

     /* srd0_LN2_stat: SerDes Lane 2 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln2_stat_reg;


  /* srd0_LN2_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x510a */

     /* srd0_LN2_EBIST: SerDes Lane 2 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln2_ebist_reg;


  /* srd0_LN3_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x510c */

     /* srd0_LN3_cfga: SerDes Lane 3 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln3_cfga_reg;


  /* srd0_LN3_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x510d */

     /* srd0_LN3_stat: SerDes Lane 3 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln3_stat_reg;


  /* srd0_LN3_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x510e */

     /* srd0_LN3_EBIST: SerDes Lane 3 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln3_ebist_reg;


  /* srd0_cmu_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5110 */

     /* srd0_cmu_cfga: SerDes CMU Configurations                     */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd0_cmu_cfga_reg;


  /* srd0_cmu_cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5111 */

     /* srd0_cmu_cfgb: SerDes CMU Configurations (Con't)             */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd0_cmu_cfgb_reg;


  /* srd0_cmu_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5112 */

     /* srd0_cmu_stat: SerDes SMU Status                             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd0_cmu_stat_reg;


  /* srd1_LN0_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5120 */

     /* srd1_LN0_cfga: SerDes Lane 0 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln0_cfga_reg;


  /* srd1_LN0_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5121 */

     /* srd1_LN0_stat: SerDes Lane 0 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln0_stat_reg;


  /* srd1_LN0_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5122 */

     /* srd1_LN0_EBIST: SerDes Lane 0 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln0_ebist_reg;


  /* srd1_LN1_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5124 */

     /* srd1_LN1_cfga: SerDes Lane 1 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln1_cfga_reg;


  /* srd1_LN1_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5125 */

     /* srd1_LN1_stat: SerDes Lane 1 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln1_stat_reg;


  /* srd1_LN1_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5126 */

     /* srd1_LN1_EBIST: SerDes Lane 1 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln1_ebist_reg;


  /* srd1_LN2_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5128 */

     /* srd1_LN2_cfga: SerDes Lane 2 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln2_cfga_reg;


  /* srd1_LN2_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5129 */

     /* srd1_LN2_stat: SerDes Lane 2 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln2_stat_reg;


  /* srd1_LN2_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x512a */

     /* srd1_LN2_EBIST: SerDes Lane 2 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln2_ebist_reg;


  /* srd1_LN3_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x512c */

     /* srd1_LN3_cfga: SerDes Lane 3 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln3_cfga_reg;


  /* srd1_LN3_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x512d */

     /* srd1_LN3_stat: SerDes Lane 3 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln3_stat_reg;


  /* srd1_LN3_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x512e */

     /* srd1_LN3_EBIST: SerDes Lane 3 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln3_ebist_reg;


  /* srd1_cmu_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5130 */

     /* srd1_cmu_cfga: SerDes CMU Configurations                     */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd1_cmu_cfga_reg;


  /* srd1_cmu_cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5131 */

     /* srd1_cmu_cfgb: SerDes CMU Configurations (Con't)             */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd1_cmu_cfgb_reg;


  /* srd1_cmu_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5132 */

     /* srd1_cmu_stat: SerDes SMU Status                             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd1_cmu_stat_reg;


  /* srd2_LN0_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5140 */

     /* srd2_LN0_cfga: SerDes Lane 0 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln0_cfga_reg;


  /* srd2_LN0_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5141 */

     /* srd2_LN0_stat: SerDes Lane 0 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln0_stat_reg;


  /* srd2_LN0_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5142 */

     /* srd2_LN0_EBIST: SerDes Lane 0 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln0_ebist_reg;


  /* srd2_LN1_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5144 */

     /* srd2_LN1_cfga: SerDes Lane 1 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln1_cfga_reg;


  /* srd2_LN1_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5145 */

     /* srd2_LN1_stat: SerDes Lane 1 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln1_stat_reg;


  /* srd2_LN1_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5146 */

     /* srd2_LN1_EBIST: SerDes Lane 1 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln1_ebist_reg;


  /* srd2_LN2_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5148 */

     /* srd2_LN2_cfga: SerDes Lane 2 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln2_cfga_reg;


  /* srd2_LN2_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5149 */

     /* srd2_LN2_stat: SerDes Lane 2 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln2_stat_reg;


  /* srd2_LN2_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x514a */

     /* srd2_LN2_EBIST: SerDes Lane 2 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln2_ebist_reg;


  /* srd2_LN3_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x514c */

     /* srd2_LN3_cfga: SerDes Lane 3 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln3_cfga_reg;


  /* srd2_LN3_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x514d */

     /* srd2_LN3_stat: SerDes Lane 3 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln3_stat_reg;


  /* srd2_LN3_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x514e */

     /* srd2_LN3_EBIST: SerDes Lane 3 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln3_ebist_reg;


  /* srd2_cmu_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5150 */

     /* srd2_cmu_cfga: SerDes CMU Configurations                     */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd2_cmu_cfga_reg;


  /* srd2_cmu_cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5151 */

     /* srd2_cmu_cfgb: SerDes CMU Configurations (Con't)             */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd2_cmu_cfgb_reg;


  /* srd2_cmu_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5152 */

     /* srd2_cmu_stat: SerDes SMU Status                             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd2_cmu_stat_reg;


  /* srd3_LN0_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5160 */

     /* srd3_LN0_cfga: SerDes Lane 0 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln0_cfga_reg;


  /* srd3_LN0_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5161 */

     /* srd3_LN0_stat: SerDes Lane 0 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln0_stat_reg;


  /* srd3_LN0_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5162 */

     /* srd3_LN0_EBIST: SerDes Lane 0 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln0_ebist_reg;


  /* srd3_LN1_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5164 */

     /* srd3_LN1_cfga: SerDes Lane 1 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln1_cfga_reg;


  /* srd3_LN1_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5165 */

     /* srd3_LN1_stat: SerDes Lane 1 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln1_stat_reg;


  /* srd3_LN1_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5166 */

     /* srd3_LN1_EBIST: SerDes Lane 1 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln1_ebist_reg;


  /* srd3_LN2_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5168 */

     /* srd3_LN2_cfga: SerDes Lane 2 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln2_cfga_reg;


  /* srd3_LN2_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5169 */

     /* srd3_LN2_stat: SerDes Lane 2 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln2_stat_reg;


  /* srd3_LN2_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x516a */

     /* srd3_LN2_EBIST: SerDes Lane 2 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln2_ebist_reg;


  /* srd3_LN3_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x516c */

     /* srd3_LN3_cfga: SerDes Lane 3 Configurations                  */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln3_cfga_reg;


  /* srd3_LN3_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x516d */

     /* srd3_LN3_stat: SerDes Lane 3 Indications This register       */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln3_stat_reg;


  /* srd3_LN3_EBIST:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x516e */

     /* srd3_LN3_EBIST: SerDes Lane 3 EBIST Indications This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln3_ebist_reg;


  /* srd3_cmu_cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5170 */

     /* srd3_cmu_cfga: SerDes CMU Configurations                     */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd3_cmu_cfga_reg;


  /* srd3_cmu_cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5171 */

     /* srd3_cmu_cfgb: SerDes CMU Configurations (Con't)             */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd3_cmu_cfgb_reg;


  /* srd3_cmu_stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5172 */

     /* srd3_cmu_stat: SerDes SMU Status                             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd3_cmu_stat_reg;


  /* Srd Ipu Cfg:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5178 */

     /* SrdIpuCfg: Configuration Register for IPU (internal          */
     /* IPU), EPB bus, and SCIF access. Shared by all SerDeses      */
     /* in SRD Star.                                                 */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_PCFG_DEFAULT */
     SOC_PETRA_REG_FIELD srd_ipu_cfg;

  } __ATTRIBUTE_PACKED__ srd_ipu_cfg_reg;


  /* Srd Epb Op:                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5179 */

     /* SrdEpbOp: EPB OP dispatch register. Writing to this          */
     /* register causes a write or read operation to be              */
     /* dispatched on the EPB bus.                                   */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_EPB_OP_DEFAULT */
     SOC_PETRA_REG_FIELD srd_epb_op;

  } __ATTRIBUTE_PACKED__ srd_epb_op_reg;


  /* Srd Epb Rd:                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x517a */

     /* SrdEpbRd: EPB OP data read register. After a read from       */
     /* the EPB bus is finished, the read data and status are        */
     /* available here.                                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd_epb_rd;

  } __ATTRIBUTE_PACKED__ srd_epb_rd_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_NIF_REGS;
/* Block definition: NIF MAC LANE */
typedef struct
{
  uint32   nof_instances; /* 8 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: MAL Interrupt register                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5200 */

     /* LinkStatusChangeInt: If set, indicates change in link        */
     /* status of corresponding MAC Lane.                            */
     /* range: 3:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_status_change_int;

     /* RxPcsLnSyncStatChangeInt: If set, indicates that Rx PCS      */
     /* synchronization status of corresponding logical lane has     */
     /* changed.                                                     */
     /* range: 9:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_pcs_ln_sync_stat_change_int;

     /* RxPcsSyncStatChangeInt: If set, indicates change in Rx       */
     /* PCS synchronization status of relevant logical lanes.        */
     /* Set when all relevant lanes achieve sync, or when all        */
     /* lanes were synced and one or more lanes loose sync.          */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_sync_stat_change_int;

     /* RxPcsLocalFaultInt: If set, indicates XAUI Rx PCS got a      */
     /* local fault.                                                 */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_local_fault_int;

     /* RxPcsRemoteFaultInt: If set, indicates XAUI Rx PCS           */
     /* detected a Remote Fault (indicated by link partner).         */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_remote_fault_int;

     /* SgmiiGotRemoteFaultInt: If set, indicates that SGMII Rx      */
     /* PCS received a remote fault indication from link partner     */
     /* (see AutoNegStatus register).                                */
     /* range: 16:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD sgmii_got_remote_fault_int;

     /* StatRxInt: If set, indicates that one of the Rx              */
     /* Statistics counters reached 75% of its maximal value.        */
     /* range: 17:17, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_int;

     /* StatTxInt: If set, indicates that one of the Tx              */
     /* Statistics counters reached 75% of its maximal value.        */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tx_int;

     /* ErrorInterrupt: If set, indicates one or more of the         */
     /* ErrInterruptRegister bits were set.                          */
     /* range: 19:19, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_interrupt;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Err Interrupt Register: MAL Error Interrupt register           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5201 */

     /* TxMlfOverrunErrorInt: If set, indicates that any one of      */
     /* the Tx MAC Lane FIFOs (MLF) had an overrun error. Data       */
     /* was lost. This implies a bandwidth configuration error       */
     /* in the egress. For more detailed information, see the        */
     /* TxMLFConfigStatus register.                                  */
     /* range: 3:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_mlf_overrun_error_int;

     /* RxMlfOverrunErrorInt: If set, indicates that any one of      */
     /* the Rx MAC Lane FIFOs (MLF) had an overrun error. Data       */
     /* was lost. This implies a bandwidth configuration error       */
     /* in the ingress. For more detailed information, see the       */
     /* RxMLFConfigStatus register.                                  */
     /* range: 7:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mlf_overrun_error_int;

     /* MacTxErrInt: If set, indicates that MAC Lane encountered     */
     /* a Tx error (i.e. starvation or frame check errors). Lane     */
     /* 0 indication is shared by XAUI.                              */
     /* range: 11:8, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD mac_tx_err_int;

     /* MacRxErrInt: If set, indicates that MAC Lane encountered     */
     /* an Rx error (i.e. Frame Check Error during packet or         */
     /* between packets). Lane 0 indication is shared by XAUI.       */
     /* range: 15:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD mac_rx_err_int;

     /* TxTafOverflowErrInt: If set, indicates that TAF had on       */
     /* overflow error.                                              */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_taf_overflow_err_int;

     /* RxRafOverflowErrInt: If set, indicates that RAF had on       */
     /* overflow error.                                              */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_raf_overflow_err_int;

     /* TxMlfPktTooShortErrInt: If set, indicates that Tx MLF        */
     /* received a packet of 32B or less.                            */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_mlf_pkt_too_short_err_int;

     /* TxA48OverflowErrInt: If set, indicates that Tx A48           */
     /* overflowed.                                                  */
     /* range: 24:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_a48_overflow_err_int;

     /* RxPcsDeskewErrInt: If set, indicates a single or a few       */
     /* unaligned ||A|| columns were detected by XAUI Rx PCS         */
     /* Deskew function, while link was up.                          */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_deskew_err_int;

     /* RxPcsDeskewErrFatalInt: If set, indicates XAUI Rx PCS        */
     /* deskew function could not realign incoming data. This        */
     /* may be caused by accumulated skew of more than 80UI (at      */
     /* the deskew function), or if the ||A|| column has errors      */
     /* (not all lanes contain an /A/ character).                    */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_deskew_err_fatal_int;

  } __ATTRIBUTE_PACKED__ err_interrupt_reg;


  /* Interrupt Mask Register: MAL Interrupt Mask Register           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5210 */

     /* LinkStatusChangeIntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_status_change_int_mask;

     /* RxPcsLnSyncStatChangeIntMask: Writing 0 masks the            */
     /* corresponding interrupt source.                              */
     /* range: 9:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_pcs_ln_sync_stat_change_int_mask;

     /* RxPcsSyncStatChangeIntMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_sync_stat_change_int_mask;

     /* RxPcsLocalFaultIntMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_local_fault_int_mask;

     /* RxPcsRemoteFaultIntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_remote_fault_int_mask;

     /* SgmiiGotRemoteFaultIntMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 16:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sgmii_got_remote_fault_int_mask;

     /* StatRxIntMask: Writing 0 masks the corresponding             */
     /* interrupt source.                                            */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_rx_int_mask;

     /* StatTxIntMask: Writing 0 masks the corresponding             */
     /* interrupt source.                                            */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tx_int_mask;

     /* ErrorInterruptMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_interrupt_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Err Interrupt Mask Register: MAL Error Interrupt Mask          */
  /* Register                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5211 */

     /* TxMlfOverrunErrorIntMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_mlf_overrun_error_int_mask;

     /* RxMlfOverrunErrorIntMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_mlf_overrun_error_int_mask;

     /* MacTxErrIntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mac_tx_err_int_mask;

     /* MacRxErrIntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mac_rx_err_int_mask;

     /* TxTafOverflowErrIntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_taf_overflow_err_int_mask;

     /* RxRafOverflowErrIntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_raf_overflow_err_int_mask;

     /* TxMlfPktTooShortIntErrMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_mlf_pkt_too_short_int_err_mask;

     /* TxA48OverflowErrIntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 24:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_a48_overflow_err_int_mask;

     /* RxPcsDeskewErrIntMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_deskew_err_int_mask;

     /* RxPcsDeskewErrFatalIntMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_deskew_err_fatal_int_mask;

  } __ATTRIBUTE_PACKED__ err_interrupt_mask_reg;


  /* MAL Configuration register 1                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5212 */

     /* If set, enable the Tx FC to handle fast toggling CBFC        */
     /* indications from CFC.                                        */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cbfc_edge_detector;

     /* If set, enable the Tx FC to handle fast toggling LLFC        */
     /* indications from CFC or Rx MLF.                              */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD llfc_edge_detector;

     /* If set, enable the Tx FC to process refresh timer events.    */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD refresh_timer_events;

  } __ATTRIBUTE_PACKED__ mal_config1_reg;

  /* Link Status Register: MAL Status indications                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5213 */

     /* LinkStatus: Current link status. In XAUI mode, bit 0         */
     /* indicates that all lanes are comma aligned and that lane     */
     /* alignment (deskew) has been achieved. Equivalent to          */
     /* link_fault variable in IEEE 802.3ae Clause 46.3.4.2. In      */
     /* 1G Ethernet mode, each bit indicates that the XMIT           */
     /* indication for the corresponding lane's AutoNegotiation      */
     /* FSM is XMIT=DATA. In SGMII mode, each bit reflects the       */
     /* link status bit received from the PHY.                       */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_status;

     /* LinkStatusSticky: Sticky bit of link status (latch low       */
     /* if link failed. Clear on read.). This register is clear      */
     /* on read.                                                     */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_status_sticky;

     /* RxPcsSyncStat: Indicate all relevant logical lanes           */
     /* achieved synchronization. Relevant only to XAUI modes        */
     /* (2,3,4 or 6-lanes).                                          */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_sync_stat;

     /* RxPcsLocalFault: Indicate XAUI RxPCS has a local fault.      */
     /* range: 13:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_local_fault;

     /* RxPcsRemoteFault: Indicate XAUI RxPCS identified a           */
     /* remote fault indication from link partner.                   */
     /* range: 14:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_remote_fault;

     /* RxPcsLnSyncStat: Indicate link status of relevant            */
     /* logical lanes.                                               */
     /* range: 21:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pcs_ln_sync_stat;

  } __ATTRIBUTE_PACKED__ link_status_reg;


  /* Enable Register: MAL Reset controls                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5214 */

     /* MalEn: If set, the MAL is enabled and XauiRx/TxLaneEn or     */
     /* SgmiiRx/TxLaneEn may be set. Otherwise all lanes             */
     /* (XAUI+SGMII) are held at reset. This bit should only be      */
     /* set after all NIF and SerDes configurations we set, and      */
     /* SerDes completed it's reset sequence (SerDes clocks are      */
     /* stable).                                                     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mal_en;

     /* XauiRxLaneEn: If set, XAUI Rx lane is enabled. Otherwise     */
     /* it is held at reset. This register is only relevant if       */
     /* MalEn is set and SgmiiMode bit is deasserted.                */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD xaui_rx_lane_en;

     /* XauiTxLaneEn: If set, XAUI Tx lane is enabled. Otherwise     */
     /* it is held at reset. This register is only relevant if       */
     /* MalEn is set and SgmiiMode bit is deasserted.                */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD xaui_tx_lane_en;

     /* SgmiiRxLaneEn: If set, corresponding SGMII Rx lane is        */
     /* enabled. Otherwise it is held at reset. This register is     */
     /* only relevant if MalEn is set and SgmiiMode bit is           */
     /* asserted.                                                    */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD sgmii_rx_lane_en;

     /* SgmiiTxLaneEn: If set, corresponding SGMII Tx lane is        */
     /* enabled. Otherwise it is held at reset. This register is     */
     /* only relevant if MalEn is set and SgmiiMode bit is           */
     /* asserted.                                                    */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sgmii_tx_lane_en;

     /* TxFlushEgress: Reserved. (set to 0).                         */
     /* range: 19:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_flush_egress;

     /* RxXauiPcsResetDeskew: If set, XAUI Rx PCS Deskew FSM         */
     /* will be reset.                                               */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_xaui_pcs_reset_deskew;

     /* RxXauiMacReset: If set, XAUI Rx PCS Deskew FSM will be       */
     /* reset.                                                       */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_xaui_mac_reset;

  } __ATTRIBUTE_PACKED__ enable_reg;


  /* Tx MLFConfig Status: Configuration and Status Register         */
  /* of Tx MAC Lane FIFO (MLF)                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5215 */

     /* TxAlmostFullThreshold: Tx MLF Almost Full Watermark. In      */
     /* SGMII, one watermark is used for all FIFOs. When MLF has     */
     /* more than this number of valid entries, the ready is         */
     /* de-asserted and the TxMlfAlmostFullStatus is set. Valid      */
     /* values range <0~63>. Use <24> for XAUI and <4> for           */
     /* SGMII.                                                       */
     /* range: 7:0, access type: RW, default value: 0x18             */
     SOC_PETRA_REG_FIELD tx_almost_full_threshold;

     /* StartTxThreshold: Configures number of 256b words which      */
     /* MLF must accumulate before starting to transmit packet.      */
     /* Used to prevent MAC starvation during packet                 */
     /* transmission. Value should be smaller by 1 than              */
     /* TxAlmostFullThreshold.                                       */
     /* range: 15:8, access type: RW, default value: 0x17            */
     SOC_PETRA_REG_FIELD start_tx_threshold;

     /* TxDiscardTooShortPkts: Reserved (set to 0).                  */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_discard_too_short_pkts;

     /* TxRepeater: Reserved (set to 0). If set, Tx MLF will      */
     /* take data from Rx MLF instead from EGQ. EGQ data will be     */
     /* ignored.                                                   */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_repeater;

     /* TxRepeaterPort: Reserved (set to 0). If RxRepeater        */
     /* register is set, this will determine which of the SGMII      */
     /* ports (Tx MLF) will give read eanbles to the Rx MLF.         */
     /* Only one port may be active. Other ports must be             */
     /* disabled. TxRepeater must be set.                          */
     /* range: 19:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_repeater_port;

     /* TxResetMlf: Reserved (set to 0).                             */
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_reset_mlf;

     /* TxMlfAlmostFullStatus: Reserved.                             */
     /* range: 27:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_mlf_almost_full_status;

     /* TxMlfOverrunError: If set, indicates that corresponding      */
     /* lane MLF experienced overrun and data was lost. Lane 0       */
     /* is shared for XAUI. This register is clear on read.          */
     /* range: 31:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_mlf_overrun_error;

  } __ATTRIBUTE_PACKED__ tx_mlfconfig_status_reg;


  /* Rx MLFConfig Status: Configuration and Status Register         */
  /* of Rx MAC Lane FIFO (MLF)                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x14216 */

     /* RxAlmostFullThreshold: Rx MLF Almost Full Watermark. In      */
     /* SGMII, one watermark used for all FIFOs. When MLF has        */
     /* more than this number of valid entries, the                  */
     /* RxMlfAlmostFullStatus is set and a pause frame is sent       */
     /* to the link partner.                                         */
     /* range: 7:0, access type: RW, default value: 0x14             */
     SOC_PETRA_REG_FIELD rx_almost_full_threshold;

     /* RxDiscardTooShortPkts: If set, Rx MLF will discard           */
     /* packets that are 32B or less (excluding CRC) and flagged     */
     /* with error indication by the Rx MAC (as configured by        */
     /* RxMinPktLength and SgmiiRxMinPktLength registers).           */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_discard_too_short_pkts;

     /* RxEnsureDiscardInd: If set, Rx MLF will ensure               */
     /* indication of discarded packets (due to packet too           */
     /* short) is always propagated to Ingress. This is done by      */
     /* flaging the next packet with error. Otherwise, no            */
     /* indication is propagated to the Ingress due to packets       */
     /* that are dropped because they were too short. This           */
     /* option is only relevant if RxDiscardTooShortPkts is          */
     /* enabled.                                                     */
     /* range: 17:17, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_ensure_discard_ind;

     /* RxEnsureOverflowInd: If set, Rx MLF will ensure              */
     /* indication of discarded entries (due to MLF overflow) is     */
     /* always propagated to Ingress. This is done by flaging        */
     /* the next entry with error even if it belongs to the next     */
     /* packet. Otherwise, next entry is flaged only if it           */
     /* belongs to the same packet (cleared on next SOP).            */
     /* range: 18:18, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_ensure_overflow_ind;

     /* RxRepeater: Reserved (set to 0). If set, Rx MLF will      */
     /* use read enables from Tx MLF instead of from IRE. Using      */
     /* TxRepeater=1 with RxRepeater=1 will give full repeater       */
     /* and Ingress should be disabled. Using TxRepeater=1 With      */
     /* RxRepeater=0 will use Tx path as monitor for Rx datapath     */
     /* to IRE. If RxRepeater=1, only one port may be active in      */
     /* this MAL.                                                 */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_repeater;

     /* RxResetMlf: Reserved (set to 0).                             */
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_reset_mlf;

     /* RxMlfAlmostFullStatus: Reserved. If set, indicates         */
     /* that corresponding lane MLF reached almost full              */
     /* threshold.                                                 */
     /* range: 27:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_almost_full_status;

     /* RxMlfOverrunError: If set, indicates that corresponding      */
     /* lane MLF experienced overrun and data was lost. This         */
     /* register is clear on read.                                   */
     /* range: 31:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mlf_overrun_error;

  } __ATTRIBUTE_PACKED__ rx_mlfconfig_status_reg;


  /* Async Fifo Config: Configuration register of                   */
  /* asynchronous FIFO between core-clock FIFO and Tx/Rx MAC.       */
  /* TAF: FIFO in Tx path, RAF: FIFO in Rx path.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5217 */

     /* TxExtraDelayRd: Reserved (set to 1).                         */
     /* range: 1:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tx_extra_delay_rd;

     /* TxExtraDelayWr: Reserved (set to 1).                         */
     /* range: 5:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tx_extra_delay_wr;

     /* RxExtraDelayRd: Reserved (set to 1).                         */
     /* range: 9:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_extra_delay_rd;

     /* RxExtraDelayWr: Reserved (set to 1).                         */
     /* range: 13:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_extra_delay_wr;

     /* TAF_AF_WM: TAF Almost Full Watermark. When TAF has more      */
     /* than TAF_AF_WM valid entries, the read_en is                 */
     /* de-asserted. This is unused in Soc_petra.                        */
     /* range: 19:16, access type: RW, default value: 0xa            */
     SOC_PETRA_REG_FIELD taf_af_wm;

     /* RAF_AE_WM: RAF Almost Empty Watermark. This is unused in     */
     /* Soc_petra.                                                       */
     /* range: 23:20, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD raf_ae_wm;

     /* RAF_EnsureOverflowInd: If set, RAF will ensure               */
     /* indication of discarded entries (due to FIFO overflow)       */
     /* is always propagated to Ingress. This is done by flaging     */
     /* the next entry with error even if it belongs to the next     */
     /* packet. Otherwise, next entry is flaged only if it           */
     /* belongs to the same packet (cleared on next SOP).            */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD raf_ensure_overflow_ind;

  } __ATTRIBUTE_PACKED__ async_fifo_config_reg;


  /* XAUI_Config: Standard MAC XAUI configurations                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5218 */

     /* RxMinPktLength: Rx minimal packet length. Packets            */
     /* shorter than this threshold (including 3B or 4B CRC if       */
     /* present) will be flagged with error indication and           */
     /* dropped in the RxMLF (if less than 32B) or in the            */
     /* Ingress.                                                     */
     /* range: 7:0, access type: RW, default value: 0x40             */
     SOC_PETRA_REG_FIELD rx_min_pkt_length;

     /* TxMinPktLength: Tx minimal packet length. Packets            */
     /* shorter than this threshold (not including the 3B or 4B      */
     /* CRC, if added) will be padded with zeroes. If CRC will       */
     /* be added to the packet, it will be caluclated on the         */
     /* entire packet (including the trailing zeroes).               */
     /* range: 15:8, access type: RW, default value: 0x3c            */
     SOC_PETRA_REG_FIELD tx_min_pkt_length;

     /* IpgDicThreshold: Deficit Idle Count threshold (average       */
     /* number of IPG characters to insert by Tx MAC). Minimum       */
     /* is 1 (only /T/ character).                                   */
     /* range: 23:16, access type: RW, default value: 0xc            */
     SOC_PETRA_REG_FIELD ipg_dic_threshold;

     /* IpgDicEnable: If set, the value in IpgDicThreshold           */
     /* register will be treated as the average number of            */
     /* characters between frames (IPG length), and credits will     */
     /* be transferred between successive IPGs. Otherwise, the       */
     /* value in the IpgDicThreshold register will be the            */
     /* minimum IPG value. To configure full IPG compression,        */
     /* disable the DIC, and set the threshold to 1.                 */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ipg_dic_enable;

     /* MaskCheckEnd: If set, disables PCS check_end function,       */
     /* defined in IEEE 803.2ae Rx PCS state machine (Clause         */
     /* 48.2.6.1.4). Should be set when working with IPG             */
     /* compression.                                                 */
     /* range: 25:25, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD mask_check_end;

     /* IdleRandPolynom: Select one of two polynomials for           */
     /* generation of Idle sequences (IEEE 802.3 Figure 48-5)        */
     /* [0] X^7 + X^6 + 1 [1] X^7 + X^3 + 1                          */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD idle_rand_polynom;

     /* TxTermPktOnErr: Reserved (set to 1).                         */
     /* range: 27:27, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tx_term_pkt_on_err;

     /* TxInsert_E_OnErr: Reserved (set to 0).                       */
     /* range: 28:28, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tx_insert_e_on_err;

     /* LFS_OvrdSendIdle: Override value for the LFS Send-Idle       */
     /* signal (Remote Fault) going to Tx PCS FSM. (used when        */
     /* LFS_OvrdEn is set).                                          */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD lfs_ovrd_send_idle;

     /* LFS_OvrdSendQ: Override value for the LFS Send-Q signal      */
     /* (Local Fault) going to Tx PCS FSM. (used when LFS_OvrdEn     */
     /* is set).                                                     */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD lfs_ovrd_send_q;

     /* LFS_OvrdEn: If set, enables override of the LFS              */
     /* Send-Idle and Send-Q signals. Otherwise, this value is       */
     /* taken from the Link Fault Signaling (LFS) FSM.               */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD lfs_ovrd_en;

  } __ATTRIBUTE_PACKED__ xaui_config_reg;


  /* SPAUI_Extensions: SPAUI Extentions to standard XAUI            */
  /* configuration (Rx)                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5219 */

     /* MAL_48bMode: If set, MAC works in 6-Lanes (48 bit) mode.     */
     /* Otherwise, MAC works in 4-Lanes (32 bit) mode. This          */
     /* configuration affects SerDes allocation and is shared by     */
     /* Rx and Tx paths.                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mal_48b_mode;

     /* RxCrcCheckEn: If set, Rx MAC will check CRC-32/24 on the     */
     /* received packets. Otherwise, CRC-32/24 check results are     */
     /* ignored.                                                     */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_crc_check_en;

     /* RxCrcTerminateEn: If set, Rx MAC will remove 4B/3B from      */
     /* the end of the received packet and will not transfere        */
     /* these bytes to the Ingress. These bytes represent the        */
     /* 4B/3B CRC-32/24.                                             */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_crc_terminate_en;

     /* RxCrc24Mode: If set, Rx MAC will use non-standard 3B         */
     /* CRC-24. Otherwise standard 4B CRC-32 will be used.           */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_crc24_mode;

     /* RxBctSize: Determines the number of bytes in the BCT (0,     */
     /* 1 or 2 bytes). This information is required when             */
     /* preamble size of less than one column is used (so MAC        */
     /* will know how many bytes to skip). 1B BCT means only CH      */
     /* field is received. 0B BCT means BCT is not used.             */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_bct_size;

     /* RxPreambleSize: Preamble column size: [2] - complete to      */
     /* two columns. [1] - complete to one column. [0] - less        */
     /* than one column (i.e. only /S/ and/or BCT).                  */
     /* range: 7:6, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD rx_preamble_size;

     /* RxBctChPosition: Index of the byte containing the CH         */
     /* (Channel) field inside the first column of the preamble.     */
     /* Possible values are 0 (if no /S/ in preamble), 1, 2, 3,      */
     /* and 4, 5 (if 48b mode is selected). If RxBctEnCH is set,     */
     /* the CH will be extracted from this byte of the preamble.     */
     /* Otherwise, CH will be forced to 8'h00.                       */
     /* range: 10:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD rx_bct_ch_position;

     /* RxPreambleSOP: If set, Rx MAC will expect /S/ character      */
     /* at the beginning of a packet. Otherwise this character       */
     /* will be skipped (i.e. when full compression is               */
     /* configured).                                                 */
     /* range: 11:11, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_preamble_sop;

     /* RxBctEnLlfc: If set, the NIF extracts the Link Level         */
     /* Flow Control (LLFC) bit from the BCT header and passes       */
     /* on to FCR. Otherwise, the NIF ignores this bit and           */
     /* forces the received LLFC to a constant 1'b0 (XON).           */
     /* RxBctLlfc field (RxFlowControlConfig register) instructs     */
     /* the NIF (FCR) how to handle the LLFC indication.             */
     /* RxBctEnLlfc overrides the LLFC value.                        */
     /* range: 12:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_bct_en_llfc;

     /* RxBctEnCH: If set, the NIF extracts the Channel (CH)         */
     /* bits from the BCT header and passes on to ingress (exact     */
     /* location of the CH field inside the first column of the      */
     /* BCT is determined by RxBctChPosition register).              */
     /* Otherwise, the NIF ignores these bits and forces the         */
     /* channel to 8'h00.                                            */
     /* range: 13:13, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_bct_en_ch;

     /* RxBctEnBT: If set, the NIF extracts the Burst Type (BT)      */
     /* bits from the BCT header and passes on to ingress.           */
     /* Otherwise, the NIF ignores these bits and forces the         */
     /* burst type to a constant 3'b011 (Full Packet).               */
     /* range: 14:14, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_bct_en_bt;

     /* RxBctEnCrcCheck: If set, the NIF checks the CRC-4 on the     */
     /* BCT and reports errors on the packet. Otherwise, the NIF     */
     /* does not check CRC-4 on BCT.                                 */
     /* range: 15:15, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_bct_en_crc_check;

     /* Rx_BOM_DeskewErrEn: If set, XAUI Rx PCS Deskew FSM will      */
     /* consider BOM (Byte Order Mux) alignment errors as deskew     */
     /* errors that affect FSM.                                      */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_bom_deskew_err_en;

     /* RxDeskew_A_OnEvenLanes: Reserved. (write as 0).              */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_deskew_a_on_even_lanes;

     /* RxEnsureFceInd: If set, Rx MAC will ensure Frame Check       */
     /* Errors (FCE) indications are propagated to Ingress. This     */
     /* might cause the next packet to be marked with error even     */
     /* if it is a valid error free packet (in case the packet       */
     /* containing the error was dropped). This mode should be       */
     /* enabled when opperating in channelized interleaved mode,     */
     /* where it will prevent the risk of FCE errors causing a       */
     /* BOP to be dropped without any indication to Ingress SAR      */
     /* function.                                                    */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_ensure_fce_ind;

     /* RxAltCrcMode: If set, Rx MAC will use alternative CRC32      */
     /* methode and will include the first character of preamble     */
     /* (/S/) in the CRC calculation. This character will be         */
     /* considered as 8'hFB (regardless of the actual character      */
     /* being raceived).                                             */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_alt_crc_mode;

     /* TxAltCrcMode: If set, Tx MAC will use alternative CRC32      */
     /* methode and will include the first character of preamble     */
     /* (/S/) in the CRC calculation. This character will be         */
     /* considered as 8'hFB (regardless of the actual character      */
     /* being transmitted).                                          */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_alt_crc_mode;

  } __ATTRIBUTE_PACKED__ spaui_extensions_reg;


  /* SPAUI_Extensions_Tx: SPAUI Extentions to standard XAUI         */
  /* configuration (Tx)                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x521a */

     /* TxSopOnEvenOnly: If set, allow /S/ characters to be          */
     /* transmitted on even columns only. Otherwise, /S/             */
     /* characters transmitted on any column.                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_sop_on_even_only;

     /* Tx_A_OnEvenOnly: If set, allow ||A|| columns to be           */
     /* transmitted on even columns only. Otherwise, ||A||           */
     /* columns may be transmitted on any column.                    */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_a_on_even_only;

     /* TxCrcInsertEn: If set, Tx MAC will insert 3B or 4B CRC       */
     /* at the end of the packet.                                    */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tx_crc_insert_en;

     /* TxCrc24Mode: If set, Tx MAC will use non-standard 3B         */
     /* CRC-24. Otherwise standard 4B CRC-32 will be used.           */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_crc24_mode;

     /* TxBctSize: Determines the number of BCT bytes that Tx        */
     /* MAC will insert into the preamble (0, 1 or 2 bytes). 1B      */
     /* BCT means only CH field is sent.                             */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_bct_size;

     /* TxPreambleSize: Preamble column size: [2] - complete to      */
     /* two columns. [1] - complete to one column. [0] - less        */
     /* than one column (i.e. only /S/ and/or BCT).                  */
     /* range: 7:6, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD tx_preamble_size;

     /* TxBctChPosition: Index of the byte containing the CH         */
     /* (Channel) field inside the first column of the preamble.     */
     /* Possible values are 0 (if no /S/ in preamble), 1, 2, 3,      */
     /* and 4, 5 (if 48b mode is selected).                          */
     /* range: 10:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD tx_bct_ch_position;

     /* TxPreambleSOP: If set, Tx MAC will insert /S/ character      */
     /* at the beginning of a packet.                                */
     /* range: 11:11, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tx_preamble_sop;

     /* TxBctOvrdLlfc: If set, the NIF will override the             */
     /* transmitted LLFC with value defined by                       */
     /* TxBctOvrdLlfcValue register. This does not affect how        */
     /* NIF (FCT) handles flow control indications from CFC and      */
     /* RxMLF (see TxBctLlfc).                                       */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_llfc;

     /* TxBctOvrdCh: If set, the NIF will override the               */
     /* transmitted CH (Channel) with value defined by               */
     /* TxBctOvrdChValue register.                                   */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_ch;

     /* TxBctOvrdBt: If set, the NIF will override the               */
     /* transmitted BT (Burst Type) with value defined by            */
     /* TxBctOvrdBtValue register.                                   */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_bt;

     /* TxBctOvrdCrc: If set, the NIF will override the              */
     /* transmitted BCT CRC-4 with value defined by                  */
     /* TxBctOvrdCrcValue register.                                  */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_crc;

     /* TxBctOvrdChValue: Value used to override the transmitted     */
     /* CH (Channel).                                                */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_ch_value;

     /* TxBctOvrdBtValue: Value used to override the transmitted     */
     /* BT (Burst Type).                                             */
     /* range: 26:24, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_bt_value;

     /* TxBctOvrdLlfcValue: Value used to override the               */
     /* transmitted LLFC.                                            */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_llfc_value;

     /* TxBctOvrdCrcValue: Value used to override the                */
     /* transmitted BCT CRC-4.                                       */
     /* range: 31:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_ovrd_crc_value;

  } __ATTRIBUTE_PACKED__ spaui_extensions_tx_reg;


  /* SPAUI_Insert Idle Config: Configurations of special mode       */
  /* to force insertion of idle characters at given intervals       */
  /* when using IPG compression.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x521b */

     /* InsertIdlesCount: How often to insert Idle, double-Idle      */
     /* or triple-Idle columns (steps of 256 TxClk cycles).          */
     /* Ignored when not working with full IPG compression           */
     /* range: 23:0, access type: RW, default value: 24'h000000      */
     SOC_PETRA_REG_FIELD insert_idles_count;

     /* InsertIdlesMode: Number of Idle columns to insert once       */
     /* the number of columns in InsertIdlesCount register is        */
     /* reached: [00] - off [01] - single Idle insertion [10] -      */
     /* double Idle insertion [11] - triple Idle insertion           */
     /* range: 29:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD insert_idles_mode;

  } __ATTRIBUTE_PACKED__ spaui_insert_idle_config_reg;


  /* BOM: BOM (Byte Order Mux) Config and Status register           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x521c */

     /* Rx_BOM_En: If set, SPAUI Rx BOM function (Byte Order         */
     /* Mux) will be enabled (for double rate lanes) when the        */
     /* XAUI Rx PCS deskew function indicates a deskew error.        */
     /* When enabled, the BOM function will monitor /A/              */
     /* characters on logical lanes (LL) that were demuxed from      */
     /* the same Physical Lane (PL), and ensure they are mapped      */
     /* to the correct LL of the MAL.                                */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rx_bom_en;

     /* Rx_BOM_A_OnLSB: Reserved. (write as 0).                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_bom_a_on_lsb;

     /* Rx_BOM_A_OnMSB: Reserved. (write as 0).                      */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_bom_a_on_msb;

     /* Srd_DR_ModeInd: If set, indicates that SerDes attached       */
     /* to the MAC Lane opperates at double-rate mode (2 logical     */
     /* lanes muxed over one physical SerDes lanes).                 */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD srd_dr_mode_ind;

     /* RxSwapLL: If set, order of the SerDes Physical Lanes         */
     /* (PL) will be swapped when mapped into Logical Lanes          */
     /* (LL): 4-lane-SR XAUI: PL0->LL3, PL1->LL2, PL2->LL1,          */
     /* PL3->LL0. 6-lane-SR SPAUI: PL0->LL5, PL1->LL4, PL2->LL3,     */
     /* PL3->LL2, PL4->LL1, PL5->LL0. When in double-rate (DR)       */
     /* mode, should set also BOM_SwapLL_Pair in order to            */
     /* achieve proper lane swapping.                                */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_swap_ll;

     /* RxSwapLL_Pair: If set, swap the order of each pair of        */
     /* Logical Lanes (LL) that were muxed together on a Double      */
     /* Rate (DR) Physical Lane (PL): For 4-lane-DR XAUI:            */
     /* LL0<->LL1, LL2<->LL3. For 6-lane-DR SPAUI: LL0<->LL1,        */
     /* LL2<->LL3, LL4<->LL5. When used together with                */
     /* BOM_SwapLL, will generate the following mapping:             */
     /* 4-lane-DR XAUI: PL0->LL3+LL2, PL1->LL1+LL0. 6-lane-DR        */
     /* SPAUI: PL0->LL5+LL4, PL1->LL3+LL2, PL2->LL1+LL0.             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_swap_ll_pair;

     /* TxSwapLL: Same as RxSwapLL for Tx.                           */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_swap_ll;

     /* TxSwapLL_Pair: Same as RxSwapLL_Pair for Tx.                 */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_swap_ll_pair;

     /* Tx_K_MappingEn: If set, corresponding Tx PCS logical         */
     /* lane will use value from TxMappingValue register instead     */
     /* of the IEEE defined value for comma mapping (/K28.5/ =       */
     /* 8'hBC). This will allow link partner to use alternative      */
     /* BOM method by allowing comma alignment only to logical       */
     /* lanes 0, 2 or 4 (in double rate links). Use <6'h2A> to       */
     /* enable this mode.                                            */
     /* range: 13:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_k_mapping_en;

     /* Tx_A_MappingEn: Reserved. (write as 0).                      */
     /* range: 19:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_a_mapping_en;

     /* TxMappingValue: Alternative value used to map /K/            */
     /* (comma) characters (instead of IEEE /K28.5/). BIT [8]        */
     /* (MSB) will be used as RxC, other bits ([7:0]) will be        */
     /* used as RxD.                                                 */
     /* range: 28:20, access type: RW, default value: 0x1bc          */
     SOC_PETRA_REG_FIELD tx_mapping_value;

  } __ATTRIBUTE_PACKED__ bom_reg;


  /* XAUI_Rx Pcs Deskew Ind: Debug register for XAUI Rx PCS         */
  /* Deskew function.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x521d */

     /* RxPcsDeskewMuxInd: Reserved (testing). Debug register         */
     /* indicating detected skew of each lane (relative to the       */
     /* leading lane), as they are measured by the RxPCS.            */
     /* Increments of 10 UI. Lane 0 skew is on bits [2:0], Lane      */
     /* 1 skew on bits [6:4], ..., lane 5 on bits [22:20].           */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_pcs_deskew_mux_ind;

     /* Rx_BOM_AlignStatus: Reserved (testing). If set, indicates     */
     /* bytes in relevant double-rate SerDes lane were swapped       */
     /* to provide correct byte ordering. This indicates comma       */
     /* alignment is 10b (1 character) off from SerDes sampling      */
     /* position.                                                    */
     /* range: 30:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_bom_align_status;

  } __ATTRIBUTE_PACKED__ xaui_rx_pcs_deskew_ind_reg;


  /* Tx Flow Control Config: Configuration options for              */
  /* outgoing (Tx) Link-Level Flow Control.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5220 */

     /* TxLlfcOnMlfReq: If set, FCT will send link level flow        */
     /* control (pause frame or BCT. LLFC) to link partner when       */
     /* requested to do so by the RxMLF (as indicated by the         */
     /* RxMLF almost full indication). Otherwise, FCT will           */
     /* ignore requests from the RxMLF.                              */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD tx_llfc_on_mlf_req;

     /* TxLlfcOnCfcReq: If set, FCT will send link level flow        */
     /* control (pause frame or BCT. LLFC) to link partner when       */
     /* requested to do so by the CFC. Otherwise, FCT will           */
     /* ignore requests from the CFC.                                */
     /* range: 7:4, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD tx_llfc_on_cfc_req;

     /* XonOnEdge: If set, the NIF will send an XON indication       */
     /* to link partner (pause frame or BCT. LLFC) on negedge of      */
     /* flow-control-generation indication from CFC or RxMLF (as     */
     /* masked by TxLlfcOnCfcReq and TxLlfcOnMlfReq,                 */
     /* respectively). Lane 0 is shared for XAUI.                    */
     /* range: 11:8, access type: RW, default value: 0xf             */
     SOC_PETRA_REG_FIELD xon_on_edge;

     /* TxPauseFrame: If set, NIF can generate standard 802.3x       */
     /* pause frames in response to flow control indications         */
     /* from CFC and RxMLF (as masked by TxLlfcOnCfcReq and          */
     /* TxLlfcOnMlfReq, respectively). Must be disabled if           */
     /* TxBctLlfc is enabled. Lane 0 is shared for XAUI.             */
     /* range: 15:12, access type: RW, default value: 0xf            */
     SOC_PETRA_REG_FIELD tx_pause_frame;

     /* TxBctLlfc: If set, NIF can generate BCT. LLFC in response     */
     /* to flow control indications from CFC and RxMLF (as           */
     /* masked by TxLlfcOnCfcReq and TxLlfcOnMlfReq,                 */
     /* respectively). Particularly, this register enables the       */
     /* generation of empty flow control bursts when no outgoing     */
     /* trafic exists. (This register only affects NIF behaviour     */
     /* when no outgoing traffic exists). This is only relevant      */
     /* in SPAUI interfaces that use 2B BCT. Must be disabled if     */
     /* TxPauseFrame is enabled.                                     */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_bct_llfc;

  } __ATTRIBUTE_PACKED__ tx_flow_control_config_reg;


  /* Tx Flow Control Config2: Configuration options for             */
  /* outgoing (Tx) Class-Based Flow Control.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5221 */

     /* TxCbfc: If set, NIF can generate CBFC frames. Otherwise,     */
     /* indications from the CFC to send CBFC will be ignored.       */
     /* Lane 0 is shared for XAUI.                                   */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_cbfc;

     /* TxClassTableL0: Tables for mapping CBFC classes of each      */
     /* SGMII lane to the two gen_cbfc inputs for the lane. The      */
     /* classes up to and including this number will be sent a       */
     /* pause frame with either the pause quanta or XOFF             */
     /* whenever the LSB of gen_cbfc for this lane has a             */
     /* posedge. The remaining classes are affected by the MSB.      */
     /* Note that this table is for Tx only, and the following       */
     /* register is for Rx. This register is only relevant in        */
     /* SGMII mode.                                                  */
     /* range: 6:4, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD tx_class_table_l[SOC_PETRA_NOF_CLASS_TABLE_L_FLDS];
  } __ATTRIBUTE_PACKED__ tx_flow_control_config2_reg;


  /* Tx Flow Control Timer Config: Additional timer per MAC         */
  /* Lane meant to allow for level-based flow control               */
  /* indications. Cleared each time a pause frame of relevant       */
  /* type (LLFC or CBFC) sent. If expires, and value of flow        */
  /* control indication has not changed, the flow control           */
  /* will be refreshed, and an additional pause frame               */
  /* identical to the previous one will be sent over the            */
  /* link. Note that this timer applies only to the                 */
  /* indications received from the CFC, and not to the Rx           */
  /* FIFO overflow indication.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5222 */

     /* FctTimer: The unit of this timer is identical to the         */
     /* unit of the pause quanta, 512 bit times of the               */
     /* particular application. The recommended value is             */
     /* slightly less than the configured pause quanta.              */
     /* range: 15:0, access type: RW, default value: 0x10            */
     SOC_PETRA_REG_FIELD fct_timer;

     /* FctTimerEn: If set, enables timer.                           */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fct_timer_en;

  } __ATTRIBUTE_PACKED__ tx_flow_control_timer_config_reg;


  /* Tx Pause Quanta: Pause quanta for outgoing pause frames.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5223 */

     /* TxPauseQuanta: 16 bit pause quanta used for all outgoing     */
     /* (Tx) MAC control frames (pause frames and CBFC frames).      */
     /* Only one pause quanta per MAC lane is supported.             */
     /* range: 15:0, access type: RW, default value: 0x10            */
     SOC_PETRA_REG_FIELD tx_pause_quanta;

  } __ATTRIBUTE_PACKED__ tx_pause_quanta_reg;


  /* Tx Pause Frame Source Addr:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5224 */

     /* TxPauseFrameSourceAddr: 48 bit source address used for       */
     /* all outgoing (Tx) MAC control frames (pause frames and       */
     /* CBFC frames). Not inserted to frames received from           */
     /* egress.                                                      */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_pause_frame_source_addr;

  } __ATTRIBUTE_PACKED__ tx_pause_frame_source_addr_reg_0;


  /* Tx Pause Frame Source Addr:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5225 */

     /* TxPauseFrameSourceAddr: 48 bit source address used for       */
     /* all outgoing (Tx) MAC control frames (pause frames and       */
     /* CBFC frames). Not inserted to frames received from           */
     /* egress.                                                      */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_pause_frame_source_addr;

  } __ATTRIBUTE_PACKED__ tx_pause_frame_source_addr_reg_1;


  /* Rx Flow Control Config: Contains configuration options         */
  /* for reception of incoming (Rx) MAC control frames (pause       */
  /* frames and CBFC frames).                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5226 */

     /* RxCbfc: If set, the NIF can receive and terminate CBFC       */
     /* frames. Otherwise, CBFC frames are ignored. Lane 0 is        */
     /* shared for XAUI.                                             */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD rx_cbfc;

     /* RxClassTableL0: Table for mapping received CBFC frame        */
     /* class info to information passed to central flow control     */
     /* block.                                                       */
     /* range: 6:4,8:10,12:14,16:18 access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD rx_class_table_l[SOC_PETRA_NOF_CLASS_TABLE_L_FLDS];

     /* RxCbfc: If set, the NIF can receive and terminate CBFC       */
     /* frames. Otherwise, CBFC frames are ignored. Lane 0 is        */
     /* shared for XAUI.                                             */

     /* FlatMode: If set, the NIF will never stop the Tx link,       */
     /* and will instead treat a BCT. LLFC or standard 802.3x         */
     /* pause frame as a type of CBFC and pass it on to the CFC      */
     /* for processing. Lane 0 is shared for XAUI.                   */
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flat_mode;

     /* RxTerminatePause: If set, the NIF Rx path will terminate     */
     /* Pause Frames (standard LLFC or extended CFBC frames).        */
     /* Terminated frames will not be passed to Ingress. This        */
     /* configuration does not affect the processing of Pause        */
     /* Frames by the NIF-FCR.                                       */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_terminate_pause;

     /* RxTerminateMacCtrl: If set, the NIF Rx path will             */
     /* terminate Mac Control Frames (including Pause Frames).       */
     /* Terminated frames will not be passed to Ingress. This        */
     /* configuration does not affect the processing of MAC Ctrl     */
     /* frames (inluding Pause Frames) by the NIF-FCR.               */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_terminate_mac_ctrl;

     /* RxTerminateFcBurst: If set, the NIF Rx path will             */
     /* terminate SPAUI Flow Control Bursts (BCT. PT=3'b111).         */
     /* Terminated frames will not be passed to Ingress. This        */
     /* configuration does not affect the processing of FC           */
     /* Bursts by the NIF-FCR.                                       */
     /* range: 26:26, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_terminate_fc_burst;

     /* RxMaskMacCtrl: If set, the NIF Rx path will ignore Mac       */
     /* Control Frames (including Pause Frames). Ignored frames      */
     /* will not be passed to NIF-FCR. Otherwise, FCR will           */
     /* receive these frames for processing and extract Flow         */
     /* Control information (i.e. Pause conditions). This            */
     /* configuration does not affect the termination of these       */
     /* frames by the NIF (as defined by the RxTerminateMacCtrl      */
     /* register) or the handling of BCT. LLFC.                       */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mask_mac_ctrl;

     /* RxMaskFcBurst: Reserved (set to 1).                          */
     /* range: 28:28, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_mask_fc_burst;

     /* RxBctLlfc: If set, the NIF (FCR) ignores standard 802.3x     */
     /* pause frames and relates only to the BCT. LLFC                */
     /* indication. Otherwise, the NIF ignores the BCT. LLFC.         */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_bct_llfc;

  } __ATTRIBUTE_PACKED__ rx_flow_control_config_reg;


  /* LLFC_Pause Quanta: Pause quanta for BCT. LLFC                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5227 */

     /* LLFC_PauseQuanta: NIF treats reception of BCT. LLFC           */
     /* indication as reception of standard pause frame with         */
     /* pause quanta equal to value in this register. Since each     */
     /* new packet with BCT rcvd at Rx re-loads the LLFC timer,      */
     /* the recommended value is slightly larger than size of        */
     /* jumbo frame + IPG.                                           */
     /* range: 15:0, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD llfc_pause_quanta;

  } __ATTRIBUTE_PACKED__ llfc_pause_quanta_reg;


  /* Tx Flow Control Overrides: Override Tx FC indications          */
  /* from CFC.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5228 */

     /* TxCfcFastLlfcEn: If set, allows CFC FAST LLFC                */
     /* indications to propagate to FCT. Otherwise, CFC FAST         */
     /* LLFC indications are masked. These indications cause the     */
     /* Tx path to stop transmision on the next packet boundary.     */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD tx_cfc_fast_llfc_en;

     /* TxCfcFastLlfcForce: If set, forces CFC FAST LLFC             */
     /* indications to 1.                                            */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_cfc_fast_llfc_force;

     /* TxCfcGenLlfcEn: If set, allows CFC GEN LLFC indications      */
     /* to propagate to FCT. Otherwise, CFC LLFC indications are     */
     /* masked. These indications cause the FCT to transmit an       */
     /* LLFC indication to link partner (either a pause frame or     */
     /* BCT. LLFC).                                                   */
     /* range: 11:8, access type: RW, default value: 0xf             */
     SOC_PETRA_REG_FIELD tx_cfc_gen_llfc_en;

     /* TxCfcGenLlfcForce: If set, forces CFC GEN LLFC               */
     /* indications to 1.                                            */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_cfc_gen_llfc_force;

     /* TxCfcGenCbfcEn: If set, allows CFC GEN CBFC indications      */
     /* to propagate to FCT. Otherwise, CFC LLFC indications are     */
     /* masked. These indications cause FCT to trasmit a CBFC        */
     /* pause frame to link partner.                                 */
     /* range: 23:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD tx_cfc_gen_cbfc_en;

     /* TxCfcGenCbfcForce: If set, forces CFC GEN LLFC               */
     /* indications to 1.                                            */
     /* range: 31:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_cfc_gen_cbfc_force;

  } __ATTRIBUTE_PACKED__ tx_flow_control_overrides_reg;


  /* Rx Flow Control Overrides1: Override Rx FC indications         */
  /* from FCR to FCT.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5229 */

     /* RxStartEn: If set, allows FCR Start indication to            */
     /* propagate to FCT. FCT will track how long this               */
     /* indication is held high and will pause the Tx data           */
     /* stream for this duration (on the next packet boundary).      */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD rx_start_en;

     /* RxStartForce: If set, will force the FCR Start               */
     /* indication to 1.                                             */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rx_start_force;

     /* RxStopEn: If set, allows the FCR Stop indication to          */
     /* propagate to FCR. Once indicated, the FCT will reset the     */
     /* counter that determines for how long the Tx data stream      */
     /* should be pased. This indication is normaly the result       */
     /* of receiving a pause frame with XON indication from link     */
     /* partner.                                                     */
     /* range: 11:8, access type: RW, default value: 0xf             */
     SOC_PETRA_REG_FIELD rx_stop_en;

     /* RxStopForce: If set, will force the FCR Stop indication      */
     /* to 1.                                                        */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_stop_force;

     /* RxPauseForce: If set, forces the FCR timers to reset as      */
     /* if FCR received a new pause indication. This will cause      */
     /* Tx to pause for one pause quanta on rising edge of this      */
     /* register.                                                    */
     /* range: 19:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_pause_force;

     /* RxFcLinkSpeedForce: If set, received pause quanta timer      */
     /* will assume link speed is 1GE. Otherwise will use link       */
     /* speed from autonegotiation (i.e. elongating the bit time     */
     /* by 10 or 100 as needed).                                     */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_fc_link_speed_force;

  } __ATTRIBUTE_PACKED__ rx_flow_control_overrides1_reg;


  /* Rx Flow Control Overrides2: Override Rx FC indications         */
  /* from FCR to CFC.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x522a */

     /* CfcPausedIndicEn: If set, FCR pause conditions will be       */
     /* indicated to CFC. Otherwise, these indications will be       */
     /* forced to 0 (not-paused).                                    */
     /* range: 7:0, access type: RW, default value: 0xff             */
     SOC_PETRA_REG_FIELD cfc_paused_indic_en;

     /* CfcPausedIndicForce: If set, FCR pause conditions            */
     /* indicated to CFC will be forced to 1 (paused).               */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cfc_paused_indic_force;

  } __ATTRIBUTE_PACKED__ rx_flow_control_overrides2_reg;


  /* Statistics: Statistic Module Configurations                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5230 */

     /* StatRxInit: Init the Rx statistics counters (per port).      */
     /* Should be asserted and deasserted after MAC lane is          */
     /* enabled. Init is done on rising edge of this register        */
     /* and takes 4 cycles to complete.                              */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_rx_init;

     /* StatTxInit: Init the Tx statistics counters (per port).      */
     /* Should be asserted and deasserted after MAC lane is          */
     /* enabled.                                                     */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_tx_init;

     /* StatRxInitErr: Indicates that the port Rx statistics are     */
     /* in the process of being cleared.                             */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_rx_init_err;

     /* StatTxInitErr: Indicates that the port Tx statistics are     */
     /* in the process of being cleared.                             */
     /* range: 9:9, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_tx_init_err;

     /* StatRxIncludeBctCrcErr: If set, count BCT CRC-4 errors       */
     /* as packet CRC-32 errors. Otherwise, BCT errors are not       */
     /* counted. Relevant only when 2B BCT is used.                  */
     /* range: 12:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD stat_rx_include_bct_crc_err;

     /* StatRxAllow1522: If set, packets larger than 1522 bytes      */
     /* (including CRC) are counted as Jumbo packets. Otherwise,     */
     /* packets larger than 1518 (including CRC) are counted as      */
     /* Jumbo packets.                                               */
     /* range: 13:13, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD stat_rx_allow1522;

     /* StatRxMaxPktLength: Maximal Pkt Length (including CRC).      */
     /* Packets longer than this are counted as packets with         */
     /* errors. This threshold represents maximal length of          */
     /* jumbo packets, and should be larger than the longest         */
     /* packet length bin (1518 or 1522 bytes). Otherwise,           */
     /* multiple binning may occure.                                 */
     /* range: 31:16, access type: RW, default value: 0xa000         */
     SOC_PETRA_REG_FIELD stat_rx_max_pkt_length;

  } __ATTRIBUTE_PACKED__ statistics_reg;


  /* Statistics Rd Select: Statistic counters read                  */
  /* selection. Once a counter selection is written to this          */
  /* register, the counters value will be copied to                 */
  /* StatRdCntLSB and StatRdCntMSB registers and the counter        */
  /* itself will be cleared.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5231 */

     /* StatRdCntSel: Select counter to read from: Rx Counters:      */
     /* [00] Rx OK Packets. Number of packets w/o CRC/BCT/FCE or     */
     /* pkt length errors. Includes all pkt types. (34b) [01] Rx     */
     /* Octats in valid frames (including CRC). (40b) [04] Rx        */
     /* Pkts with Frame errors. (34b) [05] Rx Pkts with CRC          */
     /* errors. (34b) [06] Rx Pkts with BCT errors. (8b) [08] Rx     */
     /* Pause Frames. (34b) [09] Rx MAC Control Frames               */
     /* (excluding Pause frames). (34b) [0a] Rx MCAST pkts.          */
     /* (34b) [0b] Rx BCAST pkts. (34b) Rx Pkt Length Bins for       */
     /* CRC-32 mode (or CRC-24 mode): (34b) [10] 0..63B              */
     /* (0..62B). [11] 64B (63B). [12] 65..127B (64..127B). [13]     */
     /* 128..255B. [14] 256..511B. [15] 512..1023B. [16]             */
     /* 1024..1517/1521B. [17] 1518/1522..<max_pkt_length-1> B.      */
     /* [18] Pkts larger than <max_pkt_length> B. Tx Counters:       */
     /* [20] Tx Octates in valid frames (including CRC). (40b)       */
     /* [24] Tx OK Normal Packets (excluding pause frames,           */
     /* M-CAST and B-CAST frames). (34b) [25] Tx MCAST Pkts.         */
     /* (34b) [26] Tx BCAST Pkts. (34b) [27] Tx Pause Frames.        */
     /* (excluding FC bursts). (34b)                                 */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_rd_cnt_sel;

     /* StatRdPortSel: For SGMII, select one of 4 ports to read      */
     /* from. For XAUI, always use StatRdPortSel=<00>.               */
     /* range: 9:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_rd_port_sel;

  } __ATTRIBUTE_PACKED__ statistics_rd_select_reg;


  /* Statistics Rd LSB: Statistic counters read data (LSBs)         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5232 */

     /* StatRdCntLSB: Data returned from the selected statistics     */
     /* counter (according to StatRdCntSel). Whenever                */
     /* StatRdCntSel register is written to, the selected            */
     /* counter is cleared and its contents is moved to the          */
     /* StatisticsRdLSB and StatisticsRdMSB registers. This is a     */
     /* saturation counter.                                          */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_rd_cnt_lsb;

  } __ATTRIBUTE_PACKED__ statistics_rd_lsb_reg;


  /* Statistics Rd MSB: Statistic counters read data (MSBs)         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5233 */

     /* StatRdCntMSB: Data returned from the selected statistics     */
     /* counter (according to StatRdCntSel). Whenever                */
     /* StatRdCntSel register is written to, the selected            */
     /* counter is cleared and its contents is moved to the          */
     /* StatisticsRdLSB and StatisticsRdMSB registers. This is a     */
     /* saturation counter.                                          */
     /* range: 7:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD stat_rd_cnt_msb;

  } __ATTRIBUTE_PACKED__ statistics_rd_msb_reg;


  /* Stat Rx Discards Ln0: Statistic counter of Rx Discards.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5234 */

     /* StatRxDiscardsLn0: Statistic counter of number of good       */
     /* packets received that were discarded due to FIFO             */
     /* overflow for port 0. This is cleared on read. This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_rx_discards_ln0;

  } __ATTRIBUTE_PACKED__ stat_rx_discards_ln0_reg;


  /* Stat Rx Discards Ln1: Statistic counter of Rx Discards.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5235 */

     /* StatRxDiscardsLn1: Statistic counter of number of good       */
     /* packets received that were discarded due to FIFO             */
     /* overflow for port 1. This is cleared on read. This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_rx_discards_ln1;

  } __ATTRIBUTE_PACKED__ stat_rx_discards_ln1_reg;


  /* Stat Rx Discards Ln2: Statistic counter of Rx Discards.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5236 */

     /* StatRxDiscardsLn2: Statistic counter of number of good       */
     /* packets received that were discarded due to FIFO             */
     /* overflow for port 2. This is cleared on read. This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_rx_discards_ln2;

  } __ATTRIBUTE_PACKED__ stat_rx_discards_ln2_reg;


  /* Stat Rx Discards Ln3: Statistic counter of Rx Discards.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5237 */

     /* StatRxDiscardsLn3: Statistic counter of number of good       */
     /* packets received that were discarded due to FIFO             */
     /* overflow for port 3. This is cleared on read. This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_rx_discards_ln3;

  } __ATTRIBUTE_PACKED__ stat_rx_discards_ln3_reg;


  /* SGMII_Config: SGMII Configurations                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5238 */

     /* SgmiiMode: If set, MAL will work in 1G Ethernet/SGMII        */
     /* mode, with 4 separate lanes. Otherwise, MAL will work as     */
     /* XAUI.                                                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD sgmii_mode;

     /* FastSgmiiMode: If set, MAL will work in 2.5G                 */
     /* Ethernet/SGMII mode, with 2 separate lanes (lane 0 and       */
     /* lane 2). Set only if SgmiiMode is enabled.                   */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fast_sgmii_mode;

     /* SgmiiRxCrcCheckEn: If set, enables CRC-32 checks on          */
     /* received packets. Otherwise the CRC check result is          */
     /* masked and ignored. Regardless of the checking, 4B will      */
     /* be removed from the end of the packet. Same enable is        */
     /* used by all SGMII lanes.                                     */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD sgmii_rx_crc_check_en;

     /* SgmiiCMode: If set, the respective lane will work as     */
     /* an SGMII MAC which communicates with an external PHY         */
     /* device. Otherwise, the lane will act as a standard 1G        */
     /* Ethernet MAC/PHY and connect directly to the fiber.          */
     /* range: 7:4, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD sgmii_c_mode;

     /* SgmiiRxMinPktLength: Rx minimal packet length. Packets       */
     /* shorter than this threshold (including 4B CRC) will be       */
     /* flagged with error indication and dropped in the RxMLF       */
     /* (if less than 32B) or in the Ingress. This threshold is      */
     /* shared by all Sgmii lanes.                                   */
     /* range: 15:8, access type: RW, default value: 0x40            */
     SOC_PETRA_REG_FIELD sgmii_rx_min_pkt_length;

     /* SgmiiTxMinPktLength: Tx minimal packet length. Packets       */
     /* shorter than this threshold (not including the 4B CRC)       */
     /* will be padded with zeroes. The CRC-32 will be               */
     /* caluclated on the entire packet (including the trailing      */
     /* zeroes). This threshold is shared by all Sgmii lanes.        */
     /* range: 23:16, access type: RW, default value: 0x3c           */
     SOC_PETRA_REG_FIELD sgmii_tx_min_pkt_length;

     /* SgmiiTxIpgLength: Determines the IPG length (number of       */
     /* idle characters between packets). For standard 1GE links     */
     /* use default of <12> and minimum effective value of <5>       */
     /* (determined by standard Tx PCS FSM). 10/100MHz links may     */
     /* use lower values. Same value is shared by all SGMII          */
     /* lanes.                                                       */
     /* range: 31:24, access type: RW, default value: 0xc            */
     SOC_PETRA_REG_FIELD sgmii_tx_ipg_length;

  } __ATTRIBUTE_PACKED__ sgmii_config_reg;


  /* SGMII_Config2: SGMII configurations (cont)                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x5239 */

     /* PrefetchConst: Constant for generating credits to get        */
     /* the next 64b words from Tx MLF. Credits will be              */
     /* generated after the number of bytes sent to MAC (from        */
     /* the recent 64b word) matches the constant. Set to <6>        */
     /* for fast SGMII links (2.5G), and to <2> for standard         */
     /* SGMII (1GE). Same value is used by all SGMII lanes.          */
     /* NOTE: cannot set this register to a low value (<4) when      */
     /* using also EarlySopPrefetch.                                 */
     /* range: 2:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD prefetch_const;

     /* EarlySopPrefetchConst: Constant for generating an early      */
     /* prefetch credit to get the next 64b word from Tx MLF. If     */
     /* set to <0>, early prefetch will be disabled. Otherwise,      */
     /* will generate a credit after the number of preamble          */
     /* bytes sent by MAC matches the constant. Set to <7> for       */
     /* fast SGMII links (2.5G), and to <0> for standard SGMII       */
     /* (1GE). Same value is used by all SGMII lanes.                */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD early_sop_prefetch_const;

     /* TxMaxCredits: If set, TxMLF will accumulate up to 3          */
     /* credits. Otherwise limit is 2 credits. Set to <1> for        */
     /* fast SGMII links (2.5GE), and to <0> for standard SGMII      */
     /* links (1GE). Same value is used by all SGMII lanes.          */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tx_max_credits;

     /* TxEarlyFcRelease: If set, Tx Aligner (A8) will               */
     /* speculatively resume credits to MLF as soon as FCT Pause     */
     /* frames EOP is detected. Otherwise, will wait a few more      */
     /* cycles to ensure the Aligner completed sending of the        */
     /* EOP word to TxMAC. Set to <1> for slow 10/100/1000 Mbps      */
     /* links and to <0> for 2.5 GE links. Same value is used by     */
     /* all SGMII lanes.   (setting to <1> on fast links may         */
     /* cause a few more IPG's after Pause Frames).                  */
     /* range: 9:9, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD tx_early_fc_release;

     /* FctLargeDelay: If set, adds large delay before handling      */
     /* FCT requests to send pause frames or to stop link            */
     /* (needed to allow Tx MLF to react). Should be set for         */
     /* fast SGMII links (2.5G), disabled for standard links         */
     /* (1GE).                                                       */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fct_large_delay;

     /* AN_XMIT_Ovrd_L0: Override the XMIT signal from               */
     /* AutoNegotiation process to Tx PCS (Lane 0): [001] force      */
     /* XMIT = CONFIGURATION [010] force XMIT = IDLE [100] force     */
     /* XMIT = DATA [111] use XMIT default value from AutoNeg        */
     /* FSM                                                          */
     /* range: 18:16, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD an_xmit_ovrd_l[SOC_PETRA_REGS_SGMII_NOF_LINKS];
  } __ATTRIBUTE_PACKED__ sgmii_config2_reg;


  /* Auto Neg Config: SGMII AutoNeg Configuration                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x523a */

     /* EnableAutoNeg: If set, enables AutoNegotiation. If           */
     /* AutoNegotiation is disabled, device capabilities must be     */
     /* decided previously between the two PHYs. (Identical to       */
     /* register 0.12 in standard Management Registers.)             */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD enable_auto_neg;

     /* RestartAutoNeg: If set, AutoNegotiation process FSM will     */
     /* be held at restart state. Renegotiation proccess will        */
     /* start on falling edge of this register.                      */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD restart_auto_neg;

     /* SendOffline: Request to send to link partner an Offline      */
     /* request via the AutoNeg process. Note that the NIF will      */
     /* not shut down the link in this case, and must be             */
     /* disabled by software (via MalEn bit)                         */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD send_offline;

     /* SendRemoteFault: Reserved (set to 0).                        */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD send_remote_fault;

     /* LinkSpeedOvrdEn: If set, link speed value will be taken      */
     /* from LinkSpeedOvrdValue.                                     */
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD link_speed_ovrd_en;

     /* LinkSpeedL0: 10/100/1000 Mbps over 1GE SGMII link.     */
     /* If LinkSpeedOvrdEn for this lane is enabled, this field      */
     /* will override the Link Speed indicated to the SGMII MAC      */
     /* (lane 0). Otherwise, this field is read only indication      */
     /* of the link speed that was negotiated by the Auto Neg        */
     /* function. Possible values: [11] Reserved (Auto Neg did       */
     /* not complete) [10] 1Gbps [01] 100 Mbps [00] 10 Mbps          */
     /* range: 25:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD link_speed_l[SOC_PETRA_REGS_SGMII_NOF_LINKS];

  } __ATTRIBUTE_PACKED__ auto_neg_config_reg;


  /* Auto Neg Config2: SGMII AutoNeg Configuration (cont)           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x523b */

     /* NumClocksInHundredUs: Number of RxClk cycles in 100 us.      */
     /* Used by SGMII AutoNeg process to calibrate the link          */
     /* timer. Default for RxClk of 125 MHz                          */
     /* range: 23:0, access type: RW, default value: 24'h012500      */
     SOC_PETRA_REG_FIELD num_clocks_in_hundred_us;

     /* PartnerPauseOvrdEn: If set, partner pause capability         */
     /* will be overriden by PartnerPauseOvrdValue.                  */
     /* range: 27:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD partner_pause_ovrd_en;

     /* PartnerPauseOvrdValue: If PartnerPauseOvrdEn is set,         */
     /* partner pause capability will be overriden by this           */
     /* register. Same value is shared by all overriden lanes.       */
     /* range: 28:28, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD partner_pause_ovrd_value;

  } __ATTRIBUTE_PACKED__ auto_neg_config2_reg;


  /* Auto Neg Status: SGMII AutoNeg Status register.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x523c */

     /* AutoNegComplete: If set, indicates that AutoNeg process      */
     /* is complete. (Identical to Register 1.5 in standard          */
     /* Management Registers.)                                       */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD auto_neg_complete;

     /* AutoNegError: If set, indicates that AutoNegotiation         */
     /* process ended in Soc_petra's sending an AutoNegotiation          */
     /* error failure to link partner, since link partner            */
     /* advertised only half-duplex capability. Link status will     */
     /* either be lowered, or remain low. This register is clear     */
     /* on read.                                                     */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD auto_neg_error;

     /* PartnerPauseRx: If set, indicates that link partner is       */
     /* able to receive standard IEEE 802.3x pause frames. Reads     */
     /* 1'b1 in SGMII mode in case an OR is done with bit read       */
     /* from PHY. Only valid with AutoNegComplete bit for            */
     /* corresponding lane.                                          */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD partner_pause_rx;

     /* GotRemoteFault: If set, indicates that received fault        */
     /* indication from link partner. In Ethernet mode,              */
     /* indication is Remote Fault in AutoNegotiation config         */
     /* register. In SGMII mode, indication is received from         */
     /* PHY. Identical to Register 1.4 in standard Management        */
     /* Registers. This register is clear on read.                   */
     /* range: 23:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD got_remote_fault;

     /* RemoteFaultTypeL0: Indication of type of Remote Fault        */
     /* received from Link Partner in config_reg base page. Note     */
     /* that upon reception of a Remote Fault, the link will be      */
     /* shut down and the LinkStatusChange interrupt will be         */
     /* set. Encoding as in Table 37-3 in IEEE standard [00] No      */
     /* error, link OK [01] Offline request by link partner [10]     */
     /* Link failure detected by partner [11] AutoNegotiation        */
     /* Error Only valid with GotRemoteFault bit for                 */
     /* corresponding lane.                                          */
     /* range: 25:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD remote_fault_type_l[SOC_PETRA_REGS_SGMII_NOF_LINKS];
  } __ATTRIBUTE_PACKED__ auto_neg_status_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_NIF_MAC_LANE_REGS;
/* Block definition: IRE */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in the IRE.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2400 */

     /* CpuIfErrDataArrived: If set, then erroneous data has         */
     /* arrived from CPU (data descriptor error bit was set).        */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_err_data_arrived;

     /* CpuIf_32bytesPackErr: If set, then an error flag was         */
     /* inserted and accompanied the corresponding CPU packet        */
     /* data. This occurs when the CPU 16-bit to 32-byte packing     */
     /* is not yet complete and another SOP is received before       */
     /* the expected EOP.                                            */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_32bytes_pack_err;

     /* CpuIfPacketSizeErr: If set, then an error flag was           */
     /* inserted and accompanied the corresponding CPU packet        */
     /* data. This happens when the CPU packet size is too small     */
     /* (less than 33B).                                             */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_packet_size_err;

     /* CpuIf_64bytesPackErr: If set, then an error flag was         */
     /* inserted and accompanied the corresponding CPU packet        */
     /* data. This occurs when packing 32-byte to 64-byte and a      */
     /* SOP or a data from a different port arrives while the 32     */
     /* most-significant bytes are already occupied.                 */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_64bytes_pack_err;

     /* OlpIfErrDataArrived: If set, then erroneous data has         */
     /* arrived from OLP (data descriptor error bit was set).        */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_err_data_arrived;

     /* OlpIf_32bytesPackErr: If set, then an error flag was         */
     /* inserted and accompanied the corresponding OLP packet        */
     /* data. This occurs when the OLP 16-bit to 32-byte packing     */
     /* is not yet complete and another SOP is received before       */
     /* the expected EOP.                                            */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_32bytes_pack_err;

     /* OlpIfPacketSizeErr: If set, then an error flag was           */
     /* inserted and accompanied the corresponding OLP packet        */
     /* data. This happens when the OLP packet size is too small     */
     /* (less than 33B).                                             */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_packet_size_err;

     /* OlpIf_64bytesPackErr: If set, then an error flag was         */
     /* inserted and accompanied the corresponding OLP packet        */
     /* data. This occurs when packing 32-byte to 64-byte and a      */
     /* SOP or a data from a different port arrives while the 32     */
     /* most-significant bytes are already occupied.                 */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_64bytes_pack_err;

     /* NifaErrDataArrived: If set, then erroneous data has          */
     /* arrived from NIFA (data descriptor error bit was set).       */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifa_err_data_arrived;

     /* NifaPacketSizeErr: If set, then an error flag was            */
     /* inserted and accompanied the corresponding NIFA packet       */
     /* data. This happens when the NIFA packet size is too          */
     /* small (less than 33B).                                       */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifa_packet_size_err;

     /* Nifa_64bytesPackErr: If set, then an error flag was          */
     /* inserted and accompanied the corresponding NIFA packet       */
     /* data. This occurs when packing 32-byte to 64-byte and a      */
     /* SOP or a data from a different port arrives while the 32     */
     /* most-significant bytes are already occupied.                 */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifa_64bytes_pack_err;

     /* NifbErrDataArrived: If set, then erroneous data has          */
     /* arrived from NIFB (data descriptor error bit was set).       */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifb_err_data_arrived;

     /* NifbPacketSizeErr: If set, then an error flag was            */
     /* inserted and accompanied the corresponding NIFB packet       */
     /* data. This happens when the NIFB packet size is too          */
     /* small (less than 33B).                                       */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifb_packet_size_err;

     /* Nifb_64bytesPackErr: If set, then an error flag was          */
     /* inserted and accompanied the corresponding NIFB packet       */
     /* data. This occurs when packing 32-byte to 64-byte and a      */
     /* SOP or a data from a different port arrives while the 32     */
     /* most-significant bytes are already occupied.                 */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifb_64bytes_pack_err;

     /* RcyErrDataArrived: If set, then erroneous data has           */
     /* arrived from Recycling (data descriptor error bit was        */
     /* set).                                                        */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_err_data_arrived;

     /* RcyPacketSizeErr: If set, then an error flag was             */
     /* inserted and accompanied the corresponding Recycling         */
     /* packet data. This happens when the Recycling packet size     */
     /* is too small (less than 33B).                                */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_packet_size_err;

     /* Rcy_64bytesPackErr: If set, then an error flag was           */
     /* inserted and accompanied the corresponding Recycling         */
     /* packet data. This occurs when packing 32-byte to 64-byte     */
     /* and a SOP or a data from a different port arrives while      */
     /* the 32 most-significant bytes are already occupied.          */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_64bytes_pack_err;

     /* BurstErrFollowSopNotValid: If set, then an error flag        */
     /* was inserted and accompanied the corresponding word          */
     /* (64B) in the Word Store Logic. This occurs when the Word     */
     /* following SOP was not valid. Since words arrive in burst     */
     /* of two words, they can be less only if an EOP is             */
     /* received.                                                    */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_not_valid;

     /* BurstErrFollowSopDifContext: If set, then an error flag      */
     /* was inserted and accompanied the corresponding word          */
     /* (64B) in the Word Store Logic. This occurs when the Word     */
     /* following a SOP was not of the same context (FAP port).      */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_dif_context;

     /* BurstErrFollowSopIsSop: If set, then an error flag was       */
     /* inserted and accompanied the corresponding word (64B) in     */
     /* the Word Store Logic. This occurs when the Word              */
     /* following a SOP was another SOP.                             */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_is_sop;

     /* BurstErrFollowSopIsErr: If set, then an error flag was       */
     /* inserted and accompanied the corresponding word (64B) in     */
     /* the Word Store Logic. This occurs when the Word              */
     /* following SOP was a ERR.                                     */
     /* range: 20:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_is_err;

     /* FapPortErr: An invalid port/channel arrived to IRE. Word     */
     /* is discarded. Refer to register InvalidPort.                 */
     /* range: 21:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fap_port_err;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2410 */

     /* CpuIfErrDataArrivedMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_err_data_arrived_mask;

     /* CpuIf_32bytesPackErrMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_32bytes_pack_err_mask;

     /* CpuIfPacketSizeErrMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_packet_size_err_mask;

     /* CpuIf_64bytesPackErrMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_64bytes_pack_err_mask;

     /* OlpIfErrDataArrivedMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_err_data_arrived_mask;

     /* OlpIf_32bytesPackErrMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_32bytes_pack_err_mask;

     /* OlpIfPacketSizeErrMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_packet_size_err_mask;

     /* OlpIf_64bytesPackErrMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD olp_if_64bytes_pack_err_mask;

     /* NifaErrDataArrivedMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifa_err_data_arrived_mask;

     /* NifaPacketSizeErrMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifa_packet_size_err_mask;

     /* Nifa_64bytesPackErrMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifa_64bytes_pack_err_mask;

     /* NifbErrDataArrivedMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifb_err_data_arrived_mask;

     /* NifbPacketSizeErrMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifb_packet_size_err_mask;

     /* Nifb_64bytesPackErrMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifb_64bytes_pack_err_mask;

     /* RcyErrDataArrivedMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_err_data_arrived_mask;

     /* RcyPacketSizeErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_packet_size_err_mask;

     /* Rcy_64bytesPackErrMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_64bytes_pack_err_mask;

     /* BurstErrFollowSopNotValidMask: Writing 0 masks the           */
     /* corresponding interrupt source.                              */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_not_valid_mask;

     /* BurstErrFollowSopDifContextMask: Writing 0 masks the         */
     /* corresponding interrupt source.                              */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_dif_context_mask;

     /* BurstErrFollowSopIsSopMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_is_sop_mask;

     /* BurstErrFollowSopIsErrMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD burst_err_follow_sop_is_err_mask;

     /* FapPortErrMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fap_port_err_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2420 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2421 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2422 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_2;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2423 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_3;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2430 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2431 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2432 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_2;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2433 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_3;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2440 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets the     */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one for each write command. If set to 0, one     */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. The timeout period is in        */
     /* periods of 256 clocks. If set to 0, then the command has     */
     /* no timeout.                                                  */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2441 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* Dynamic Configuration: General dynamic configuration           */
  /* registers. The bits in this register may be changed on         */
  /* the fly.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2454 */

     /* EnableDataPath: If set, the IRE allows data words from       */
     /* the interfaces to pass through. This register is reset       */
     /* with the block's soft reset.                                 */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_data_path;

  } __ATTRIBUTE_PACKED__ dynamic_configuration_reg;


  /* Cpu Fap Port Configuration Register: This is the               */
  /* incoming CPU FAP port in the system.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2455 */

     /* CpuFapPort: Incoming CPU FAP port.                           */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_fap_port;

  } __ATTRIBUTE_PACKED__ cpu_fap_port_configuration_reg;


  /* Olp Fap Port Configuration Register: This is the               */
  /* incoming OLP FAP port in the system.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2456 */

     /* OlpFapPort: Incoming OLP FAP port.                           */
     /* range: 6:0, access type: RW, default value: 0x5              */
     SOC_PETRA_REG_FIELD olp_fap_port;

  } __ATTRIBUTE_PACKED__ olp_fap_port_configuration_reg;


  /* Nif Groups Scheduling Weights: A scheduler selects the         */
  /* interface (NIFA or NIFB) to be transferred according to        */
  /* the weight given to each interface.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2457 */

     /* NifaWeight: NIFA weight. Legal values: 1-8.                  */
     /* range: 3:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD nifa_weight;

     /* NifbWeight: NIFB weight. Legal values: 1-8.                  */
     /* range: 7:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD nifb_weight;

  } __ATTRIBUTE_PACKED__ nif_groups_scheduling_weights_reg;


  /* Recycling Shaper: Recycling token bucket configuration.        */
  /* The token bucket guarantees a CIR BW to recycling, with        */
  /* a strict priority over the NIF data. The maximum rate is       */
  /* 3.75 Gbps.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2458 */

     /* RcyShaperTimerCycles: Every RcyShaperTimerCycles cycles      */
     /* grants RcyShaperGrantSize bytes to the token bucket. A       */
     /* value of 0 indicates a grant every clock cycle.              */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcy_shaper_timer_cycles;

     /* RcyShaperGrantSize: How many bytes to grant the bucket.      */
     /* A value of zero disables the shaper.                         */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcy_shaper_grant_size;

     /* RcyShaperMaxBurst: Maximum burst in bytes that the           */
     /* shaper is enabled. A value smaller than 128 disables the     */
     /* shaper.                                                      */
     /* range: 29:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcy_shaper_max_burst;

  } __ATTRIBUTE_PACKED__ recycling_shaper_reg;


  /* Ingress Mac Type Register: For each MAC lane, this             */
  /* register indicates whether the system provides one             */
  /* channelized XAUI port or four SGMII ports.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2459 */

     /* IngMacTypeReg: 1 - SGMII. 0 - XAUI.                          */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ing_mac_type_reg;

  } __ATTRIBUTE_PACKED__ ingress_mac_type_reg;


  /* Word Fifo Thresholds: A pair of thresholds to regulate         */
  /* the incoming WDF (Word Data FIFO) data, which holds the        */
  /* packet that was selected from one of the incoming              */
  /* interfaces. <B>These thresholds should not be changed          */
  /* without consulting DUNE.</B>                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x245a */

     /* ThresholdWdfLow: Low threshold. Must be equal (no            */
     /* hysteresis) or lower than the high threshold. Legal          */
     /* values: 1 up to ThresholdWdfHigh                             */
     /* range: 8:0, access type: RW, default value: 0xfa             */
     SOC_PETRA_REG_FIELD threshold_wdf_low;

     /* ThresholdWdfHigh: High threshold. Legal values: 1-250        */
     /* range: 24:16, access type: RW, default value: 0xfa           */
     SOC_PETRA_REG_FIELD threshold_wdf_high;

  } __ATTRIBUTE_PACKED__ word_fifo_thresholds_reg;


  /* Word Fifo Status: Word FIFO status.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x245b */

     /* WdfEmpty: WDF is empty.                                      */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD wdf_empty;

     /* WdfFull: WDF is full. Value is latched when FIFO is full     */
     /* and cleared when register is read. This register is          */
     /* clear on read.                                               */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD wdf_full;

     /* WdfFifoCount: Current number of words in the FIFO.           */
     /* range: 16:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD wdf_fifo_count;

  } __ATTRIBUTE_PACKED__ word_fifo_status_reg;


  /* Ihp Fifo Thresholds: A pair of thresholds to regulate          */
  /* the incoming HPF (IHP FIFO) data, which holds the packet       */
  /* header that was selected from one of the incoming              */
  /* interfaces. <B>These thresholds should not be changed          */
  /* without consulting DUNE.</B>                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x245c */

     /* ThresholdHpfLow: Low threshold. Must be equal (no            */
     /* hysteresis) or lower than the high threshold. Legal          */
     /* values: 1 up to ThresholdHpfHigh                             */
     /* range: 6:0, access type: RW, default value: 0x3a             */
     SOC_PETRA_REG_FIELD threshold_hpf_low;

     /* ThresholdHpfHigh: High threshold. Legal values: 1-58         */
     /* range: 14:8, access type: RW, default value: 0x3a            */
     SOC_PETRA_REG_FIELD threshold_hpf_high;

  } __ATTRIBUTE_PACKED__ ihp_fifo_thresholds_reg;


  /* Ihp Fifo Status: IHP FIFO status.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x245d */

     /* HpfEmpty: HPF is empty.                                      */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD hpf_empty;

     /* HpfFull: HPF is full. Value is latched when FIFO is full     */
     /* and cleared when register is read. This register is          */
     /* clear on read.                                               */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD hpf_full;

     /* HpfFifoCount: Current number of words in the FIFO.           */
     /* range: 14:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD hpf_fifo_count;

  } __ATTRIBUTE_PACKED__ ihp_fifo_status_reg;


  /* Packet Edit Fifo Thresholds: A pair of thresholds to           */
  /* regulate the incoming PEF (Packet Edit FIFO) data, which       */
  /* holds the packet edit data that arrived from IHP.              */
  /* <B>These thresholds should not be changed without              */
  /* consulting DUNE.</B>                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x245e */

     /* ThresholdPefLow: Low threshold. Must be equal (no            */
     /* hysteresis) or lower than the high threshold. Legal          */
     /* values: 1 up to ThresholdPefHigh                             */
     /* range: 5:0, access type: RW, default value: 0x1f             */
     SOC_PETRA_REG_FIELD threshold_pef_low;

     /* ThresholdPefHigh: High threshold. Legal values: 1-31         */
     /* range: 13:8, access type: RW, default value: 0x1f            */
     SOC_PETRA_REG_FIELD threshold_pef_high;

  } __ATTRIBUTE_PACKED__ packet_edit_fifo_thresholds_reg;


  /* Packet Edit Fifo Status: PEF FIFO status.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x245f */

     /* PefEmpty: PEF is empty.                                      */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD pef_empty;

     /* PefFull: PEF is full. Value is latched when FIFO is full     */
     /* and cleared when register is read. This register is          */
     /* clear on read.                                               */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD pef_full;

     /* PefFifoCount: Current number of words in the FIFO.           */
     /* range: 13:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD pef_fifo_count;

     /* PefCount: Current number of words in the FIFO plus           */
     /* editing data that is supposed to arrive from the IHP         */
     /* pipe and corresponds to packet headers which are already     */
     /* in pipe. The PEF must be able to sink the editing data.      */
     /* range: 21:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD pef_count;

  } __ATTRIBUTE_PACKED__ packet_edit_fifo_status_reg;


  /* Cpu Interface Select Non Streaming Packet Path: Enables        */
  /* CPU to transmit packets through the Asynchronous path          */
  /* (Non-streaming).                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2460 */

     /* CpuIfSelNonStreamPkt: If set, the non-streaming CPU          */
     /* packet path is selected.                                     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_sel_non_stream_pkt;

  } __ATTRIBUTE_PACKED__ cpu_interface_select_non_streaming_packet_path_reg;


  /* Cpu Interface Packet Control: Interface for sending a          */
  /* packet from the CPU in Non-streaming (Asynchronous)            */
  /* mode.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2461 */

     /* CpuIfPktSendData: The trigger to send 32 bytes of packet     */
     /* data. Should be set when data and control are ready to       */
     /* be sent. Auto clear when data is sent.                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_pkt_send_data;

     /* CpuIfPktStart: Indicates that packet data contains Start     */
     /* Of Packet.                                                   */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_pkt_start;

     /* CpuIfPktEnd: Indicates that packet data contains End Of      */
     /* Packet.                                                      */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_pkt_end;

     /* CpuIfPktErr: Debug mode to force an error on the             */
     /* transmitted packet.                                          */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_pkt_err;

     /* CpuIfPktBe: Number of valid bytes in packet data - valid     */
     /* only if EOP exists.                                          */
     /* range: 8:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_if_pkt_be;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_control_reg;


  /* Cpu Interface Packet Data: Asynchronous interface CPU          */
  /* packet data. The CPU sends the packet in segments of           */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2462 - 2469*/

     /* CpuIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_regs[SOC_PETRA_REGS_IRE_NOF_CPU_PKT_DATA_REGS];



  /* Cpu Interface Packet Data: Asynchronous interface CPU          */
  /* packet data. The CPU sends the packet in segments of           */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2462 */

     /* CpuIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_0;


  /* Cpu Interface Packet Data: Asynchronous interface CPU          */
  /* packet data. The CPU sends the packet in segments of           */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2463 */

     /* CpuIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_1;


  /* Cpu Interface Packet Data: Asynchronous interface CPU          */
  /* packet data. The CPU sends the packet in segments of           */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2464 */

     /* CpuIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_2;


  /* Cpu Interface Packet Data: Asynchronous interface CPU          */
  /* packet data. The CPU sends the packet in segments of           */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2465 */

     /* CpuIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_3;


  /* Cpu Interface Packet Data: Asynchronous interface CPU          */
  /* packet data. The CPU sends the packet in segments of           */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2466 */

     /* CpuIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_4;


  /* Cpu Interface Packet Data: Asynchronous interface CPU          */
  /* packet data. The CPU sends the packet in segments of           */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2467 */

     /* CpuIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_5;


  /* Cpu Interface Packet Data: Asynchronous interface CPU          */
  /* packet data. The CPU sends the packet in segments of           */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2468 */

     /* CpuIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_6;


  /* Cpu Interface Packet Data: Asynchronous interface CPU          */
  /* packet data. The CPU sends the packet in segments of           */
  /* 32B.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2469 */

     /* CpuIfPktData: The 32 bytes of packet data.                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_if_pkt_data;

  } __ATTRIBUTE_PACKED__ cpu_interface_packet_data_reg_7;


  /* Invalid Port: An invalid port/channel arrived to IRE.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x246a */

     /* Port: For CPU: [7] - 0-CPU, 1-OLP [6:0] - IFP For NIF:       */
     /* [10] - 0-NIFA, 1-NIFB [9:6] - NIF Port [5:0] - NIF           */
     /* Channel For RCY: [5:0] - Egress Recycling channel This       */
     /* register is clear on read.                                   */
     /* range: 10:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD port;

     /* Interface: 0 - CPU 1 - NIF 2 - RCY This register is          */
     /* clear on read.                                               */
     /* range: 13:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD interfac;

  } __ATTRIBUTE_PACKED__ invalid_port_reg;


  /* Reset Rxi Interfaces: Reset the RXI interfaces.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x246d */

     /* ResetCpuRxi: Reset the CPU RXI.                              */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD reset_cpu_rxi;

     /* ResetOlpRxi: Reset the OLP RXI.                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD reset_olp_rxi;

     /* ResetNifaRxi: Reset the NIFA RXI.                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD reset_nifa_rxi;

     /* ResetNifbRxi: Reset the NIFB RXI.                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD reset_nifb_rxi;

     /* ResetRcyRxi: Reset the Recycling RXI.                        */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD reset_rcy_rxi;

  } __ATTRIBUTE_PACKED__ reset_rxi_interfaces_reg;


} __ATTRIBUTE_PACKED__ SOC_PETRA_IRE_REGS;
/* Block definition: IDR */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2800 */

     /* ErrorUnicastRecycle: If set, indicates that a unicast DP     */
     /* wasn't recycled                                              */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_unicast_recycle;

     /* ErrorMiniMulticastRecycle: If set, indcates that a mini      */
     /* multicast DP wasn't recycled                                 */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_mini_multicast_recycle;

     /* ErrorFullMulticastRecycle: If set, indicates that a full     */
     /* multicast DP wasn't recycled                                 */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_full_multicast_recycle;

     /* ErrorReassembly: If set, indicates that the reassembly       */
     /* error counter is non-zero                                    */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_reassembly;

     /* ErrorTimeout: If set, indicates a timeout error of the       */
     /* reassembly controller                                        */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_timeout;

     /* ErrorEcc: If set, indicates an ECC error.                    */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_ecc;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Ecc Interrupt Register: This register contains the             */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2801 */

     /* ErrorChunkStatusEcc: If set, indicates there was an ECC      */
     /* error.                                                       */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_chunk_status_ecc;

     /* ErrorChunkFifoEcc: If set, indicates there was an ECC        */
     /* error.                                                       */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_chunk_fifo_ecc;

     /* ErrorUnicastDpEcc: If set, indicates there was an ECC        */
     /* error.                                                       */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_unicast_dp_ecc;

     /* ErrorMiniMulticastDpEcc: If set, indicates there was an      */
     /* ECC error.                                                   */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_mini_multicast_dp_ecc;

     /* ErrorFullMulticastDpEcc: If set, indicates there was an      */
     /* ECC error.                                                   */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_full_multicast_dp_ecc;

     /* ErrorFreePcbsEcc: If set, indicates there was an ECC         */
     /* error.                                                       */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_free_pcbs_ecc;

     /* ErrorPcbLinkTableEcc: If set, indicates there was an ECC     */
     /* error.                                                       */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_pcb_link_table_ecc;

     /* ErrorPrmDpEcc: If set, indicates there was an ECC error.     */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_prm_dp_ecc;

     /* ErrorPrmPdEcc: If set, indicates there was an ECC error.     */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_prm_pd_ecc;

     /* ErrorPrmCdEcc: If set, indicates there was an ECC error.     */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_prm_cd_ecc;

     /* ErrorReassemblyStatusEcc: If set, indicates there was an     */
     /* ECC error.                                                   */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_reassembly_status_ecc;

     /* ErrorWordIndexEcc: If set, indicates there was an ECC        */
     /* error.                                                       */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_word_index_ecc;

     /* ErrorBufferTypeEcc: If set, indicates there was an ECC       */
     /* error.                                                       */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_buffer_type_ecc;

     /* ErrorCompletePcEcc: If set, indicates there was an ECC       */
     /* error.                                                       */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_complete_pc_ecc;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_reg;


  /* Interrupt Register Mask: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2810 */

     /* ErrorUnicastRecycleMask: Writing 0 masks the                 */
     /* corresponding interrupt source                               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_unicast_recycle_mask;

     /* ErrorMiniMulticastRecycleMask: Writing 0 masks the           */
     /* corresponding interrupt source                               */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_mini_multicast_recycle_mask;

     /* ErrorFullMulticastRecycleMask: Writing 0 masks the           */
     /* corresponding interrupt source                               */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_full_multicast_recycle_mask;

     /* ErrorReassemblyMask: Writing 0 masks the corresponding       */
     /* interrupt source                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_reassembly_mask;

     /* ErrorTimeoutMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_timeout_mask;

     /* ErrorEccMask: Writing 0 masks the corresponding              */
     /* interrupt source                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_ecc_mask;

  } __ATTRIBUTE_PACKED__ interrupt_register_mask_reg;


  /* Ecc Interrupt Mask Register: Each bit in this register         */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2811 */

     /* ErrorChunkStatusEccMask: Writing 0 masks the                 */
     /* corresponding interrupt source                               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_chunk_status_ecc_mask;

     /* ErrorChunkFifoEccMask: Writing 0 masks the corresponding     */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_chunk_fifo_ecc_mask;

     /* ErrorUnicastDpEccMask: Writing 0 masks the corresponding     */
     /* interrupt source                                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_unicast_dp_ecc_mask;

     /* ErrorMiniMulticastDpEccMask: Writing 0 masks the             */
     /* corresponding interrupt source                               */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_mini_multicast_dp_ecc_mask;

     /* ErrorFullMulticastDpEccMask: Writing 0 masks the             */
     /* corresponding interrupt source                               */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_full_multicast_dp_ecc_mask;

     /* ErrorFreePcbsEccMask: Writing 0 masks the corresponding      */
     /* interrupt source                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_free_pcbs_ecc_mask;

     /* ErrorPcbLinkTableEccMask: Writing 0 masks the                */
     /* corresponding interrupt source                               */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_pcb_link_table_ecc_mask;

     /* ErrorPrmDpEccMask: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_prm_dp_ecc_mask;

     /* ErrorPrmPdEccMask: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_prm_pd_ecc_mask;

     /* ErrorPrmCdEccMask: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_prm_cd_ecc_mask;

     /* ErrorReassemblyStatusEccMask: Writing 0 masks the            */
     /* corresponding interrupt source                               */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_reassembly_status_ecc_mask;

     /* ErrorWordIndexEccMask: Writing 0 masks the corresponding     */
     /* interrupt source                                             */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_word_index_ecc_mask;

     /* ErrorBufferTypeEccMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_buffer_type_ecc_mask;

     /* ErrorCompletePcEccMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_complete_pc_ecc_mask;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_mask_reg;


  /* Indirect Command Wr Data: Indirect write data - Data           */
  /* that is written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2820 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Wr Data: Indirect write data - Data           */
  /* that is written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2821 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;


  /* Indirect Command Wr Data: Indirect write data - Data           */
  /* that is written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2822 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_2;


  /* Indirect Command Wr Data: Indirect write data - Data           */
  /* that is written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2823 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_3;


  /* Indirect Command Wr Data: Indirect write data - Data           */
  /* that is written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2824 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_4;


  /* Indirect Command Wr Data: Indirect write data - Data           */
  /* that is written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2825 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_5;


  /* Indirect Command Wr Data: Indirect write data - Data           */
  /* that is written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2826 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_6;


  /* Indirect Command Wr Data: Indirect write data - Data           */
  /* that is written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2827 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_7;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2830 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2831 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2832 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_2;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2833 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_3;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2834 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_4;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2835 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_5;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2836 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_6;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2837 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_7;


  /* Indirect Command: Indirect Commands - Used to send             */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2840 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set, to 0, one       */
     /* operation is performed. The CPU can read this field to        */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set, to 0, then the command has no timeout.       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address -            */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2841 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg;


  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg;


  /* Reset Status Register: Bits in this register specify           */
  /* when initialization has finished.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2900 */

     /* ContextStatusInitDone: If set, then the context status       */
     /* memory has completed initialization                          */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD context_status_init_done;

     /* ChunkStatusInitDone: If set, then the chunk status           */
     /* memory has completed initialization                          */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD chunk_status_init_done;

     /* WordIndexFifoInitDone: If set, then the word index FIFO      */
     /* memory has completed initialization                          */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD word_index_fifo_init_done;

     /* FreePcbFifoInitDone: If set, then the free PCB FIFO          */
     /* memory has completed initialization                          */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD free_pcb_fifo_init_done;

  } __ATTRIBUTE_PACKED__ reset_status_reg;


  /* Static Configuration: General static configuration             */
  /* register. The bits in this register may be changed only        */
  /* during initial configuration.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2901 */

     /* DisEcc: if set ecc is disabled for all memories              */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_ecc;

     /* EnableBufferChange: If set, then a unicast buffer may be     */
     /* used instead of a mini-multicast buffer                      */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_buffer_change;

     /* ReassemblyNoMmcMirrorOnly: If set, then when there are       */
     /* no mini multicast buffers, only the mirror copy of the       */
     /* packet is sent. If there is not a mirror copy or if this     */
     /* bit is not set, only the forwarding copy is sent.            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD reassembly_no_mmc_mirror_only;

     /* FbcInternalReuse: If set, the FBC reuses returned            */
     /* pointers, i.e. if possible, dbuff pointers are not           */
     /* returned to the external memory and are re-used.             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fbc_internal_reuse;

     /* FbcUnicastAutogenEnable: If set, then unicast dbuff          */
     /* pointers are generated; otherwise, only the unicast          */
     /* pointers in external memory are used.                        */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fbc_unicast_autogen_enable;

     /* FbcMiniMulticastAutogenEnable: If set, then mini             */
     /* multicast dbuff pointers are generated; otherwise, only      */
     /* the mini multicast pointers in external memory are used.     */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fbc_mini_multicast_autogen_enable;

     /* FbcFullMulticastAutogenEnable: If set, then full             */
     /* multicast dbuff pointers are generated; otherwise, only      */
     /* the full multicast pointers in external memory are used.     */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fbc_full_multicast_autogen_enable;

  } __ATTRIBUTE_PACKED__ static_configuration_reg;


  /* Dynamic Configuration: General dynamic configuration           */
  /* registers. The bits in this register may be changed on         */
  /* the fly.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2902 */

     /* EnableDataPath: If set, the FBC allows data words to         */
     /* pass through. This register is reset with the block's        */
     /* soft reset.                                                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_data_path;

     /* FbcHalt: If set, the FBC stops releasing new buffers to      */
     /* the RCT                                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fbc_halt;

     /* CheckMinSize: If set, the minimum size of the packet is      */
     /* checked                                                      */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD check_min_size;

     /* CheckMaxSize: If set, the maximum size of the packet is      */
     /* checked                                                      */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD check_max_size;

     /* CheckMinOrgSize: If set, the minimum size of the packet      */
     /* before editing is checked                                    */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD check_min_org_size;

     /* CheckMaxOrgSize: If set, the minimum size of the packet      */
     /* before editing is checked                                    */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD check_max_org_size;

     /* MaxDpThreshold: The maximum number of dbuff pointers per     */
     /* packet minus one (example: 3'b000 is one DP)                 */
     /* range: 8:6, access type: RW, default value: 0x6              */
     SOC_PETRA_REG_FIELD max_dp_threshold;

  } __ATTRIBUTE_PACKED__ dynamic_configuration_reg;

  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x2902 */

    /* EnableDataPath: If set, the FBC allows data words to         */
    /* pass through. This register is reset with the block's        */
    /* soft reset.                                                  */
    /* range: 0:0, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD enable_data_path;

    /* FbcHalt: If set, the FBC stops releasing new buffers to      */
    /* the RCT                                                      */
    /* range: 1:1, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD fbc_halt;

    /* MaxDpThreshold: The maximum number of dbuff pointers per     */
    /* packet minus one (example: 3'b000 is one DP)                 */
    /* range: 8:6, access type: RW, default value: 0x6              */
    SOC_PETRA_REG_FIELD max_dp_threshold;

  } __ATTRIBUTE_PACKED__ dynamic_configuration_reg_cmn;

  /* Bcn Register: Support for BCN (Backwards Congestion            */
  /* Notification)                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2903 */

     /* BcnThreshold: When the number of bytes or packets (as        */
     /* specified by BcnMode) reaches this threshold a packet is     */
     /* snooped as specified by BcnSnoopCmd. If this value is 0      */
     /* then BCN is disabled.                                        */
     /* range: 19:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bcn_threshold;

     /* BcnMode: If set then BCN mode is packet, otherwise it is     */
     /* bytes.                                                       */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bcn_mode;

     /* BcnSnoopCmd: The BCN snoop command for the selected          */
     /* packets.                                                     */
     /* range: 27:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bcn_snoop_cmd;

  } __ATTRIBUTE_PACKED__ bcn_reg;


  /* Resequencing Timeout Reset: Determines the conditions on       */
  /* which the IDR generates a resequencer set signals to the       */
  /* IRR.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2904 */

     /* ResequencingSkewMask: Masks FAP-ports 1 through 4 on         */
     /* reception of an SOP word. Ports that are not masked          */
     /* generate an SOP-received signal to the IRR.                  */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD resequencing_skew_mask;

     /* ResequencingTransferMask: Masks FAP-ports 1 through 4 on     */
     /* reception of a non-SOP word. Ports that are not masked,      */
     /* together with non-masked flow control signals, generate      */
     /* an MOP-received signal to the IRR.                           */
     /* range: 7:4, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD resequencing_transfer_mask;

     /* ResequencingMmuFcMask: Masks the MMU flow control.           */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD resequencing_mmu_fc_mask;

     /* ResequencingIrrFcMask: Masks the IRR flow control.           */
     /* range: 9:9, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD resequencing_irr_fc_mask;

  } __ATTRIBUTE_PACKED__ resequencing_timeout_reset_reg;


  /* Packet Sizes: Specifies the minimum and maximum packet         */
  /* size. Packets violating these limits are dropped.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2905 */

     /* MinPacketSize: Minimum packet size. Value must be larger     */
     /* than 32.                                                     */
     /* range: 13:0, access type: RW, default value: 0x20            */
     SOC_PETRA_REG_FIELD min_packet_size;

     /* MaxPacketSize: Maximum packet size. The actual value         */
     /* tested is one less than the configured value. Must be        */
     /* larger than 64.                                              */
     /* range: 27:14, access type: RW, default value: 0x200          */
     SOC_PETRA_REG_FIELD max_packet_size;

  } __ATTRIBUTE_PACKED__ packet_sizes_reg;


  /* Original Packet Sizes: Specifies the minimum and maximum       */
  /* packet size before ingress editing. Packets violating          */
  /* these limits are dropped.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2906 */

     /* MinOrgPacketSize: Minimum packet size before editing.        */
     /* Value must be larger than 32.                                */
     /* range: 13:0, access type: RW, default value: 0x20            */
     SOC_PETRA_REG_FIELD min_org_packet_size;

     /* MaxOrgPacketSize: Maximum packet size before editing.        */
     /* The actual value tested is one less than the configured      */
     /* value. Must be larger than 64.                               */
     /* range: 27:14, access type: RW, default value: 0x200          */
     SOC_PETRA_REG_FIELD max_org_packet_size;

  } __ATTRIBUTE_PACKED__ original_packet_sizes_reg;


  /* Rct Cpu Request Register: Using this register, the CPU         */
  /* can insert an error word into any context. This register       */
  /* is used for freeing resources used by a timed out              */
  /* context.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2907 */

     /* RctCpuRequest: When setting this bit, an RCT CPU request     */
     /* is initiated.                                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rct_cpu_request;

     /* RctCpuRequestFapPort: The FAP port (i.e. reassembly          */
     /* context) of the RCT CPU request.                             */
     /* range: 7:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rct_cpu_request_fap_port;

  } __ATTRIBUTE_PACKED__ rct_cpu_request_reg;


  /* Fbc Full Multicast Autogen Start:                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2908 */

     /* FbcFullMulticastAutogenStart: Full multicast pointers        */
     /* are generated starting with this value                       */
     /* range: 20:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fbc_full_multicast_autogen_start;

  } __ATTRIBUTE_PACKED__ fbc_full_multicast_autogen_start_reg;


  /* Fbc Full Multicast Autogen End:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2909 */

     /* FbcFullMulticastAutogenEnd: Full multicast pointers are      */
     /* generated up to this value                                   */
     /* range: 20:0, access type: RW, default value: 0x1fff          */
     SOC_PETRA_REG_FIELD fbc_full_multicast_autogen_end;

  } __ATTRIBUTE_PACKED__ fbc_full_multicast_autogen_end_reg;


  /* Fbc Mini Multicast Autogen Start:                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290a */

     /* FbcMiniMulticastAutogenStart: Mini multicast pointers        */
     /* are generated starting with this value                       */
     /* range: 20:0, access type: RW, default value: 0x2000          */
     SOC_PETRA_REG_FIELD fbc_mini_multicast_autogen_start;

  } __ATTRIBUTE_PACKED__ fbc_mini_multicast_autogen_start_reg;


  /* Fbc Mini Multicast Autogen End:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290b */

     /* FbcMiniMulticastAutogenEnd: Mini multicast pointers are      */
     /* generated up to this value                                   */
     /* range: 20:0, access type: RW, default value: 21'h11FFF       */
     SOC_PETRA_REG_FIELD fbc_mini_multicast_autogen_end;

  } __ATTRIBUTE_PACKED__ fbc_mini_multicast_autogen_end_reg;


  /* Fbc Unicast Autogen Start:                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290c */

     /* FbcUnicastAutogenStart: Unicast pointers are generated       */
     /* starting with this value                                     */
     /* range: 20:0, access type: RW, default value: 21'h12000       */
     SOC_PETRA_REG_FIELD fbc_unicast_autogen_start;

  } __ATTRIBUTE_PACKED__ fbc_unicast_autogen_start_reg;


  /* Fbc Unicast Autogen End:                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290d */

     /* FbcUnicastAutogenEnd: Unicast pointers are generated up      */
     /* to this value                                                */
     /* range: 20:0, access type: RW, default value: 21'h1FA2E4      */
     SOC_PETRA_REG_FIELD fbc_unicast_autogen_end;

  } __ATTRIBUTE_PACKED__ fbc_unicast_autogen_end_reg;


  /* Fbc Cache Configuration: Configuration for FBC unicast         */
  /* cache.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290e */

     /* FbcUnicastCacheDivider: Half of the unicast cache            */
     /* divider. This value is valid only when the FBC is in the     */
     /* no-reuse mode. Divider must be smallr than 60.               */
     /* range: 5:0, access type: RW, default value: 0x1f             */
     SOC_PETRA_REG_FIELD fbc_unicast_cache_divider;

     /* FbcMiniMulticastCacheDivider: Half of the mini multicast     */
     /* cache divider. This value is valid only when the FBC is      */
     /* in the no-reuse mode. Divider must be smallr than 60.        */
     /* range: 11:6, access type: RW, default value: 0x1f            */
     SOC_PETRA_REG_FIELD fbc_mini_multicast_cache_divider;

     /* FbcFullMulticastCacheDivider: Half of the full multicast     */
     /* cache divider. This value is valid only when the FBC is      */
     /* in the no-reuse mode. Divider must be smallr than 60.        */
     /* range: 17:12, access type: RW, default value: 0x1f           */
     SOC_PETRA_REG_FIELD fbc_full_multicast_cache_divider;

  } __ATTRIBUTE_PACKED__ fbc_cache_configuration_reg;


  /* Fbc Unicast Thresholds: Configuration for FBC unicast          */
  /* cache thresholds.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x290f */

     /* FbcInternalUnicastNewWriteTh: When number of items in        */
     /* cache is above this threshold, data may be moved from        */
     /* cache to external memory.                                    */
     /* range: 6:0, access type: RW, default value: 0x40             */
     SOC_PETRA_REG_FIELD fbc_internal_unicast_new_write_th;

     /* FbcInternalUnicastNewReadTh: When number of items in         */
     /* cache is below this threshold, data may be moved from        */
     /* external memory to cache.                                    */
     /* range: 14:8, access type: RW, default value: 0x20            */
     SOC_PETRA_REG_FIELD fbc_internal_unicast_new_read_th;

  } __ATTRIBUTE_PACKED__ fbc_unicast_thresholds_reg;


  /* Fbc Mini Multicast Thresholds: Configuration for FBC           */
  /* mini multicast cache thresholds.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2910 */

     /* FbcInternalMiniMulticastNewWriteTh: When number of items     */
     /* in cache is above this threshold, data may be moved from     */
     /* cache to external memory.                                    */
     /* range: 6:0, access type: RW, default value: 0x40             */
     SOC_PETRA_REG_FIELD fbc_internal_mini_multicast_new_write_th;

     /* FbcInternalMiniMulticastNewReadTh: When number of items      */
     /* in cache is below this threshold, data may be moved from     */
     /* external memory to cache.                                    */
     /* range: 14:8, access type: RW, default value: 0x20            */
     SOC_PETRA_REG_FIELD fbc_internal_mini_multicast_new_read_th;

  } __ATTRIBUTE_PACKED__ fbc_mini_multicast_thresholds_reg;


  /* Fbc Full Multicast Thresholds: Configuration for FBC           */
  /* full multicast cache thresholds.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2911 */

     /* FbcInternalFullMulticastNewWriteTh: When number of items     */
     /* in cache is below this threshold, data may be moved from     */
     /* external memory to cache.                                    */
     /* range: 6:0, access type: RW, default value: 0x40             */
     SOC_PETRA_REG_FIELD fbc_internal_full_multicast_new_write_th;

     /* FbcInternalFullMulticastNewReadTh: When number of items      */
     /* in cache is below this threshold, data may be moved from     */
     /* external memory to cache.                                    */
     /* range: 14:8, access type: RW, default value: 0x20            */
     SOC_PETRA_REG_FIELD fbc_internal_full_multicast_new_read_th;

  } __ATTRIBUTE_PACKED__ fbc_full_multicast_thresholds_reg;


  /* Fbc External Full Multicast Limit Low:                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2912 */

     /* FbcExternalFullMulticastLimitLow: Lower limit for full       */
     /* multicast pointers in external memory                        */
     /* range: 21:0, access type: RW, default value: 21'h1FA2E5      */
     SOC_PETRA_REG_FIELD fbc_external_full_multicast_limit_low;

  } __ATTRIBUTE_PACKED__ fbc_external_full_multicast_limit_low_reg;


  /* Fbc External Full Multicast Limit High:                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2913 */

     /* FbcExternalFullMulticastLimitHigh: Upper limit for full      */
     /* multicast pointers in external memory                        */
     /* range: 21:0, access type: RW, default value: 21'h1FA343      */
     SOC_PETRA_REG_FIELD fbc_external_full_multicast_limit_high;

  } __ATTRIBUTE_PACKED__ fbc_external_full_multicast_limit_high_reg;


  /* Fbc External Mini Multicast Limit Low:                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2914 */

     /* FbcExternalMiniMulticastLimitLow: Lower limit for mini       */
     /* multicast pointers in external memory                        */
     /* range: 21:0, access type: RW, default value: 21'h1FA344      */
     SOC_PETRA_REG_FIELD fbc_external_mini_multicast_limit_low;

  } __ATTRIBUTE_PACKED__ fbc_external_mini_multicast_limit_low_reg;


  /* Fbc External Mini Multicast Limit High:                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2915 */

     /* FbcExternalMiniMulticastLimitHigh: Upper limit for mini      */
     /* multicast pointers in external memory                        */
     /* range: 21:0, access type: RW, default value: 21'h1FA62D      */
     SOC_PETRA_REG_FIELD fbc_external_mini_multicast_limit_high;

  } __ATTRIBUTE_PACKED__ fbc_external_mini_multicast_limit_high_reg;


  /* Fbc External Unicast Limit Low:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2916 */

     /* FbcExternalUnicastLimitLow: Lower limit for unicast          */
     /* pointers in external memory.                                 */
     /* range: 21:0, access type: RW, default value: 21'h1FA62E      */
     SOC_PETRA_REG_FIELD fbc_external_unicast_limit_low;

  } __ATTRIBUTE_PACKED__ fbc_external_unicast_limit_low_reg;


  /* Fbc External Unicast Limit High:                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2917 */

     /* FbcExternalUnicastLimitHigh: Upper limit for unicast         */
     /* pointers in external memory                                  */
     /* range: 21:0, access type: RW, default value: 21'h1FFFFF      */
     SOC_PETRA_REG_FIELD fbc_external_unicast_limit_high;

  } __ATTRIBUTE_PACKED__ fbc_external_unicast_limit_high_reg;


  /* Reassembly Errors:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2977 */

     /* ReassemblyErrorMask: Masks the reassembly errors             */
     /* counted. Bits have the following meaning: 0 - minimum        */
     /* original size error 1 - minimum size error 2 - maximum       */
     /* original size error 3 - maximum size error 4 - maximum       */
     /* DP error 5 - no PCB error 6 - no PCB for SOP word error      */
     /* 7 - no DP error 8 - unexpected EOP error 9 - unexpected      */
     /* MOP error 10 - unexpected SOP error 11 - general error       */
     /* at middle or end of packet 12 - general error when idle      */
     /* range: 12:0, access type: RW, default value: 0xfff           */
     SOC_PETRA_REG_FIELD reassembly_error_mask;

     /* ReassemblyErrors: Number of reassembly errors This           */
     /* register is clear on read.                                   */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD reassembly_errors;

  } __ATTRIBUTE_PACKED__ reassembly_errors_reg;


  /* Reassembly Timeout:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2978 */

     /* ReassemblyTimeout: Timeout period for reassembly             */
     /* controller. If there is a non-idle context for more than     */
     /* the specified number of clocks, a timeout interrupt is       */
     /* raised.                                                      */
     /* range: 23:0, access type: RW, default value: 0x200           */
     SOC_PETRA_REG_FIELD reassembly_timeout;

  } __ATTRIBUTE_PACKED__ reassembly_timeout_reg;


  /* Timeout Reg:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x297c */

     /* TimeoutReg: Specifies which contexts (FAP-port) timed        */
     /* out. A timeout occurs when an EOP wasn't received for        */
     /* the specified timeout duration.                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD timeout_reg;

  } __ATTRIBUTE_PACKED__ timeout_reg_0;


  /* Timeout Reg:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x297d */

     /* TimeoutReg: Specifies which contexts (FAP-port) timed        */
     /* out. A timeout occurs when an EOP wasn't received for        */
     /* the specified timeout duration.                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD timeout_reg;

  } __ATTRIBUTE_PACKED__ timeout_reg_1;


  /* Timeout Reg:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x297e */

     /* TimeoutReg: Specifies which contexts (FAP-port) timed        */
     /* out. A timeout occurs when an EOP wasn't received for        */
     /* the specified timeout duration.                              */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD timeout_reg;

  } __ATTRIBUTE_PACKED__ timeout_reg_2;


  /* Counters Fap Ports: Defines the four fap ports for which       */
  /* counters are defined. A value of -1 indicates an invalid       */
  /* fap port.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2999 */

     /* FapPort0-FapPort3: FAP ports for which counters are defined. */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fap_port[SOC_PETRA_COUNTERS_FAP_PORTS_NOF_FLDS];
  } __ATTRIBUTE_PACKED__ counters_fap_ports_reg;


  /* Received Packets0:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x299a */

     /* ReceivedPackets0: Number of received packets for             */
     /* configured fap port 0. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_packets0;

  } __ATTRIBUTE_PACKED__ received_packets0_reg_0;


  /* Received Packets0:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x299b */

     /* ReceivedPackets0: Number of received packets for             */
     /* configured fap port 0. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_packets0;

  } __ATTRIBUTE_PACKED__ received_packets0_reg_1;


  /* Received Packets1:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x299c */

     /* ReceivedPackets1: Number of received packets for             */
     /* configured fap port 1. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_packets1;

  } __ATTRIBUTE_PACKED__ received_packets1_reg_0;


  /* Received Packets1:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x299d */

     /* ReceivedPackets1: Number of received packets for             */
     /* configured fap port 1. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_packets1;

  } __ATTRIBUTE_PACKED__ received_packets1_reg_1;


  /* Received Packets2:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x299e */

     /* ReceivedPackets2: Number of received packets for             */
     /* configured fap port 2. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_packets2;

  } __ATTRIBUTE_PACKED__ received_packets2_reg_0;


  /* Received Packets2:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x299f */

     /* ReceivedPackets2: Number of received packets for             */
     /* configured fap port 2. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_packets2;

  } __ATTRIBUTE_PACKED__ received_packets2_reg_1;


  /* Received Packets3:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a0 */

     /* ReceivedPackets3: Number of received packets for             */
     /* configured fap port 3. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_packets3;

  } __ATTRIBUTE_PACKED__ received_packets3_reg_0;


  /* Received Packets3:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a1 */

     /* ReceivedPackets3: Number of received packets for             */
     /* configured fap port 3. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_packets3;

  } __ATTRIBUTE_PACKED__ received_packets3_reg_1;


  /* Received Octets0:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a2 */

     /* ReceivedOctets0: Number of received octets for               */
     /* configured fap port 0. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_octets0;

  } __ATTRIBUTE_PACKED__ received_octets0_reg_0;


  /* Received Octets0:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a3 */

     /* ReceivedOctets0: Number of received octets for               */
     /* configured fap port 0. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_octets0;

  } __ATTRIBUTE_PACKED__ received_octets0_reg_1;


  /* Received Octets1:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a4 */

     /* ReceivedOctets1: Number of received octets for               */
     /* configured fap port 1. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_octets1;

  } __ATTRIBUTE_PACKED__ received_octets1_reg_0;


  /* Received Octets1:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a5 */

     /* ReceivedOctets1: Number of received octets for               */
     /* configured fap port 1. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_octets1;

  } __ATTRIBUTE_PACKED__ received_octets1_reg_1;


  /* Received Octets2:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a6 */

     /* ReceivedOctets2: Number of received octets for               */
     /* configured fap port 2. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_octets2;

  } __ATTRIBUTE_PACKED__ received_octets2_reg_0;


  /* Received Octets2:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a7 */

     /* ReceivedOctets2: Number of received octets for               */
     /* configured fap port 2. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_octets2;

  } __ATTRIBUTE_PACKED__ received_octets2_reg_1;


  /* Received Octets3:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a8 */

     /* ReceivedOctets3: Number of received octets for               */
     /* configured fap port 3. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_octets3;

  } __ATTRIBUTE_PACKED__ received_octets3_reg_0;


  /* Received Octets3:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29a9 */

     /* ReceivedOctets3: Number of received octets for               */
     /* configured fap port 3. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD received_octets3;

  } __ATTRIBUTE_PACKED__ received_octets3_reg_1;


  /* Discarded Packets0:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29aa */

     /* DiscardedPackets0: Number of discarded packets for           */
     /* configured fap port 0. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_packets0;

  } __ATTRIBUTE_PACKED__ discarded_packets0_reg_0;


  /* Discarded Packets0:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29ab */

     /* DiscardedPackets0: Number of discarded packets for           */
     /* configured fap port 0. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_packets0;

  } __ATTRIBUTE_PACKED__ discarded_packets0_reg_1;


  /* Discarded Packets1:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29ac */

     /* DiscardedPackets1: Number of discarded packets for           */
     /* configured fap port 1. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_packets1;

  } __ATTRIBUTE_PACKED__ discarded_packets1_reg_0;


  /* Discarded Packets1:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29ad */

     /* DiscardedPackets1: Number of discarded packets for           */
     /* configured fap port 1. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_packets1;

  } __ATTRIBUTE_PACKED__ discarded_packets1_reg_1;


  /* Discarded Packets2:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29ae */

     /* DiscardedPackets2: Number of discarded packets for           */
     /* configured fap port 2. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_packets2;

  } __ATTRIBUTE_PACKED__ discarded_packets2_reg_0;


  /* Discarded Packets2:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29af */

     /* DiscardedPackets2: Number of discarded packets for           */
     /* configured fap port 2. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_packets2;

  } __ATTRIBUTE_PACKED__ discarded_packets2_reg_1;


  /* Discarded Packets3:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29b0 */

     /* DiscardedPackets3: Number of discarded packets for           */
     /* configured fap port 3. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_packets3;

  } __ATTRIBUTE_PACKED__ discarded_packets3_reg_0;


  /* Discarded Packets3:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29b1 */

     /* DiscardedPackets3: Number of discarded packets for           */
     /* configured fap port 3. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_packets3;

  } __ATTRIBUTE_PACKED__ discarded_packets3_reg_1;


  /* Discarded Octets0:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29b2 */

     /* DiscardedOctets0: Number of discarded octets for             */
     /* configured fap port 0. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_octets0;

  } __ATTRIBUTE_PACKED__ discarded_octets0_reg_0;


  /* Discarded Octets0:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29b3 */

     /* DiscardedOctets0: Number of discarded octets for             */
     /* configured fap port 0. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_octets0;

  } __ATTRIBUTE_PACKED__ discarded_octets0_reg_1;


  /* Discarded Octets1:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29b4 */

     /* DiscardedOctets1: Number of discarded octets for             */
     /* configured fap port 1. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_octets1;

  } __ATTRIBUTE_PACKED__ discarded_octets1_reg_0;


  /* Discarded Octets1:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29b5 */

     /* DiscardedOctets1: Number of discarded octets for             */
     /* configured fap port 1. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_octets1;

  } __ATTRIBUTE_PACKED__ discarded_octets1_reg_1;


  /* Discarded Octets2:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29b6 */

     /* DiscardedOctets2: Number of discarded octets for             */
     /* configured fap port 2. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_octets2;

  } __ATTRIBUTE_PACKED__ discarded_octets2_reg_0;


  /* Discarded Octets2:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29b7 */

     /* DiscardedOctets2: Number of discarded octets for             */
     /* configured fap port 2. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_octets2;

  } __ATTRIBUTE_PACKED__ discarded_octets2_reg_1;


  /* Discarded Octets3:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29b8 */

     /* DiscardedOctets3: Number of discarded octets for             */
     /* configured fap port 3. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_octets3;

  } __ATTRIBUTE_PACKED__ discarded_octets3_reg_0;


  /* Discarded Octets3:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x29b9 */

     /* DiscardedOctets3: Number of discarded octets for             */
     /* configured fap port 3. When the 32 lsb of this register      */
     /* are read the counter msb value is sampled (to enable         */
     /* reading) but actual counting is restarted for zero. This     */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD discarded_octets3;

  } __ATTRIBUTE_PACKED__ discarded_octets3_reg_1;

} __ATTRIBUTE_PACKED__ SOC_PETRA_IDR_REGS;
/* Block definition: IRR */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in the IRR.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a00 */

     /* ErrMaxReplication: Set for an ingress multicast packet       */
     /* replicated more than a configurable value.                   */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD err_max_replication;

     /* ErrorMaxReplication: Set for an ingress multicast packet     */
     /* replicated more than a configurable value.                   */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_max_replication;

     /* OutOfSequence: Set if the chosen sequence number is          */
     /* smaller than the last sequence number. Cleared when Error     */
     /* Counters reg 0xa857 is read.                                 */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD out_of_sequence;

     /* OutOfSynchronization: Set if the difference between the      */
     /* valid sequence numbers is too big. Cleared when Error        */
     /* Counters reg 0xa857 is read                                  */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD out_of_synchronization;

     /* ErrorFreePcpEcc: If set, indicates there was an ECC          */
     /* error.                                                       */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_free_pcp_ecc;

     /* ErrorIsFreePcpEcc: If set, indicates there was an ECC        */
     /* error.                                                       */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_is_free_pcp_ecc;

     /* ErrorPcpLinkTableEcc: If set, indicates there was an ECC     */
     /* error.                                                       */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_pcp_link_table_ecc;

     /* ErrorIsPcpLinkTableEcc: If set, indicates there was an       */
     /* ECC error.                                                   */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_is_pcp_link_table_ecc;

     /* ErrorPcmEcc: If set, indicates there was an ECC error.       */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_pcm_ecc;

     /* ErrorIsPcmEcc: If set, indicates there was an ECC error.     */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_is_pcm_ecc;

     /* ErrorUcEcc: If set, indicates there was an ECC error.        */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_uc_ecc;

     /* ErrorMcEcc: If set, indicates there was an ECC error.        */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_mc_ecc;

     /* ErrorNifEcc: If set, indicates there was an ECC error.       */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_nif_ecc;

     /* ErrorGlagMappingEcc: If set, indicates there was an ECC      */
     /* error.                                                       */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_glag_mapping_ecc;

     /* ErrorIsfEcc: If set, indicates there was an ECC error.       */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_isf_ecc;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Register Mask: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a10 */

     /* ErrMaxReplicationMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD err_max_replication_mask;

     /* ErrorMaxReplicationMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_max_replication_mask;

     /* OutOfSequenceMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD out_of_sequence_mask;

     /* OutOfSynchronizationMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD out_of_synchronization_mask;

     /* ErrorFreePcpEccMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_free_pcp_ecc_mask;

     /* ErrorIsFreePcpEccMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_is_free_pcp_ecc_mask;

     /* ErrorPcpLinkTableEccMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_pcp_link_table_ecc_mask;

     /* ErrorIsPcpLinkTableEccMask: Writing 0 masks the              */
     /* corresponding interrupt source.                              */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_is_pcp_link_table_ecc_mask;

     /* ErrorPcmEccMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_pcm_ecc_mask;

     /* ErrorIsPcmEccMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_is_pcm_ecc_mask;

     /* ErrorUcEccMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_uc_ecc_mask;

     /* ErrorMcEccMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_mc_ecc_mask;

     /* ErrorNifEccMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_nif_ecc_mask;

     /* ErrorGlagMappingEccMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_glag_mapping_ecc_mask;

     /* ErrorIsfEccMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_isf_ecc_mask;

  } __ATTRIBUTE_PACKED__ interrupt_register_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a20 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a21 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a22 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_2;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a23 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_3;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a30 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a31 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a32 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_2;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a33 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_3;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a40 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a41 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0:-         */
     /* Write operation 1:- Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* Static Configuration: General static configuration             */
  /* register. The bits in this register may be changed only        */
  /* during initial configuration.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a54 */

     /* DisEcc: if set ecc is disabled for all memories except       */
     /* the Glag Mapping memory                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_ecc;

     /* DisableSnError: If set, out of sequence errors are           */
     /* ignored by the resequencer, but an interrupt is set to       */
     /* the CPU.                                                     */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD disable_sn_error;

     /* DropPrecedenceHighPriority: Mapping register from drop       */
     /* precedence to high/low multicast priority descriptors        */
     /* (One bit for each drop precedence value specifying high      */
     /* priority multicast when set).                                */
     /* range: 5:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD drop_precedence_high_priority;

     /* IdrMcDescWeight: Multicast descriptors weight for            */
     /* incoming packets from the IDR.                               */
     /* range: 10:8, access type: RW, default value: 0x2             */
     SOC_PETRA_REG_FIELD idr_mc_desc_weight;

     /* IqmIsDescWeight: Descriptor weight for packets after         */
     /* ingress shaping received from the IQM.                       */
     /* range: 13:11, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD iqm_is_desc_weight;

     /* DeqFcThresholdL: low threshold to the IPS, indicating a      */
     /* small number of free IS_PCB's left in the IRR. Note that      */
     /* the actual low threshold is multiplied by 2.                 */
     /* range: 20:14, access type: RW, default value: 0x28           */
     SOC_PETRA_REG_FIELD deq_fc_threshold_l;

     /* DeqFcThresholdH: high threshold to the IPS, indicating a     */
     /* small number of free IS_PCB's left in the IRR. Note that     */
     /* the actual high threshold is multiplied by 2.                */
     /* range: 27:21, access type: RW, default value: 0x32           */
     SOC_PETRA_REG_FIELD deq_fc_threshold_h;

     /* AddIsTrafficClass: This bit is valid for ingress shaping     */
     /* replications (from IDR to IQM). If set then the traffic      */
     /* class is added to the destination value.                     */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD add_is_traffic_class;

     /* DisGlagMappingEcc: if set ecc is disabled for the Glag       */
     /* Mapping memory                                               */
     /* range: 29:29, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD dis_glag_mapping_ecc;

  } __ATTRIBUTE_PACKED__ static_configuration_reg;


  /* Dynamic Configuration: General dynamic configuration           */
  /* registers. The bits in this register may be changed on         */
  /* the fly.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a55 */

     /* EnableDataPathIdr: If set, the IRR allows data words         */
     /* from the IDR to pass through. This register is reset         */
     /* with the block's soft reset.                                 */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_data_path_idr;

     /* EnableDataPathIqm: If set, the IRR allows data words         */
     /* from the IQM to pass through. This register is reset         */
     /* with the block's soft reset.                                 */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_data_path_iqm;

  } __ATTRIBUTE_PACKED__ dynamic_configuration_reg;


  /* Snoop Num Of Bytes Configuration Register: For each            */
  /* Snoop destination (1-15), this register determines the         */
  /* size of the packet that will be generated towards the          */
  /* destination. The possible values for SnoopSize are:2'b00       */
  /* - First 64 Bytes 2'b10 - First 192                             */
  /* Bytes2'b11 - Full packet. The value for each snoop value       */
  /* is : SnoopNumOfBytes[1+( snoop value )*2 :( snoop value        */
  /* )*2 ].                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a56 */

     /* SnoopNumOfBytes: SnoopSize                                   */
     /* range: 29:0, access type: RW, default value: 0x0             */
     /* Note! The index here is snoop_cmd_id-1,                      */
     /* since snoop_cmd_id == 0 means disable snooping               */
     SOC_PETRA_REG_FIELD snoop_num_of_bytes[SOC_PETRA_REGS_PER_SNOOP_CMD_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ snoop_num_of_bytes_configuration_reg;


  /* Resequencer Timeout Register: Timeout configuration for        */
  /* resequencer                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a57 */

     /* ResequencerSkewTimeout: The lane skew. In oc768c mode,       */
     /* when a valid SOP is received in the IDR, the                 */
     /* resequencing timer in the IRR is set to this value.          */
     /* range: 15:0, access type: RW, default value: 0x9c4           */
     SOC_PETRA_REG_FIELD resequencer_skew_timeout;

     /* ResequencerTransferTimeout: The time untill an assembled     */
     /* packet is transferred from the IDR to the IRR. In oc768c     */
     /* mode, when an indication bit from the IDR is set, the        */
     /* resequencing timer is set to this value if it is below       */
     /* it. The indication bit from the IDR is set when a valid      */
     /* MOP is received in the IDR (for fap-ports 1 through 4),      */
     /* when there is flow control from the MMU or when there is     */
     /* flow control from the IRR.                                   */
     /* range: 31:16, access type: RW, default value: 0xc4           */
     SOC_PETRA_REG_FIELD resequencer_transfer_timeout;

  } __ATTRIBUTE_PACKED__ resequencer_timeout_reg;


  /* Resequencing Port Enable:                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a58 */

     /* ResequencingPortEnable: For ports 1 through 4 specifies      */
     /* whether it is part of the resequencing mechanism.            */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD resequencing_port_enable;

  } __ATTRIBUTE_PACKED__ resequencing_port_enable_reg;


  /* Error Counters:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a59 */

     /* SnOutOfSynchronizationCnt: Counter indicating the number     */
     /* of times an Out of Synchronization event has occurred,       */
     /* where the maximum difference between the sequence            */
     /* numbers was bigger than 2^14 or 2^15 as derived from the     */
     /* BypassResquencingConfiguration register (see section         */
     /* 1.1.1.14). This counter stops at saturation and is           */
     /* cleared on read This register is clear on read.              */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD sn_out_of_synchronization_cnt;

     /* SnOutOfSequenceCnt: Counter indicating the number of         */
     /* times an Out of Synchronization event has occurred,          */
     /* where the sequence number chosen was smaller than the        */
     /* last sequence number. This counter stops at saturation       */
     /* and is cleared on read This register is clear on read.       */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD sn_out_of_sequence_cnt;

  } __ATTRIBUTE_PACKED__ error_counters_reg;


  /* Err Max Replication Mc Id Value: This register Holds the       */
  /* Multicast ID of the first packet that has more than            */
  /* configurable ingress multicast replications.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a5a */

     /* ErrMaxReplicationMcIdValue: MC ID value This register is     */
     /* clear on read.                                               */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD err_max_replication_mc_id_value;

  } __ATTRIBUTE_PACKED__ err_max_replication_mc_id_value_reg;


  /* Error Max Replication Mc Id Value: This register Holds         */
  /* the Multicast ID of the first packet that has more than        */
  /* configurable ingress multicast replications.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a5b */

     /* ErrorMaxReplicationMcIdValue: MC ID value This register      */
     /* is clear on read.                                            */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_max_replication_mc_id_value;

  } __ATTRIBUTE_PACKED__ error_max_replication_mc_id_value_reg;


  /* Max Replication Register:                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a5c */

     /* MaxReplicationRegister: This register limits the maximum     */
     /* number of ingress multicast replications for a packet.       */
     /* The maximum number of replications is either                 */
     /* MaxReplicationRegister-1 or MaxReplicationRegister-2,        */
     /* depending on link list structure.                            */
     /* range: 12:0, access type: RW, default value: 0x1000          */
     SOC_PETRA_REG_FIELD max_replication_register;

  } __ATTRIBUTE_PACKED__ max_replication_reg;


  /* Nif Port Configuration Register: The fap port to be            */
  /* stamped on packets arriving on one of the four OC768c          */
  /* ports.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a5d */

     /* NifPort: port value                                          */
     /* range: 6:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD nif_port;

  } __ATTRIBUTE_PACKED__ nif_port_configuration_reg;


  /* Resequencing Configuration: Resequencing configuration         */
  /* register                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a5e */

     /* BypassReseq: Enables a mode where some packets can           */
     /* bypass the Resequencing process. If the Bypass mode is       */
     /* set, then the sequence number range is only 15b [14:0]       */
     /* instead of 16b, and bit 15, if set, indicates that the       */
     /* packet should bypass the Resequencing process                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bypass_reseq;

     /* EnableFastResequencing: When set, the resequencer            */
     /* selects a packet with a sequence number equal to the         */
     /* last selected sequence number plus one even when not all     */
     /* queues are valid                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_fast_resequencing;

  } __ATTRIBUTE_PACKED__ resequencing_configuration_reg;


  /* Resequence Reset Configuration Register: When written          */
  /* to,the resequencing mechanism is reset.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a5f */

     /* ResequenceReset: The signal can be used by the CPU to        */
     /* reset the resequencing mechanism. The CPU sets this bit      */
     /* to trigger the reset, the device will clear it upon          */
     /* completion of reset.                                         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD resequence_reset;

  } __ATTRIBUTE_PACKED__ resequence_reset_configuration_reg;


  /* Unicast Traffic Class Mapping Register:                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a60 */

     /* UnicastTrafficClassMappingRegister: This register maps       */
     /* the traffic class (3 bits) of unicast queues to a new 3      */
     /* bits value: The value for each traffic class is :            */
     /* UnicastTrafficClassMappingRegister[( Traffic                 */
     /* Class*4)+2:( Traffic Class )*4 ].                            */
     /* range: 31:0, access type: RW, default value: 32'h76543210    */
     SOC_PETRA_REG_FIELD unicast_traffic_class_mapping_register[SOC_PETRA_REGS_PER_TC_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ unicast_traffic_class_mapping_reg;


  /* Ingress Multicast Traffic Class Mapping Register:              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a61 */

     /* IngressMulticastTrafficClassMappingRegister: This            */
     /* register maps the traffic class (3 bits) of ingress          */
     /* multicast queues to a new 3 bits value: The value for        */
     /* each traffic class is :                                      */
     /* IngressMulticastTrafficClassMappingRegister[( Traffic        */
     /* Class*4)+2:( Traffic Class )*4 ].                            */
     /* range: 31:0, access type: RW, default value: 32'h76543210    */
     SOC_PETRA_REG_FIELD ingress_mc_tc_mapping[SOC_PETRA_REGS_PER_TC_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ ingress_mc_tc_mapping_reg;


  /* Egress Or Fabric Multicast Traffic Class Mapping               */
  /* Register:                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a62 */

     /* EgressOrFabricMulticastTrafficClassMappingRegister: This     */
     /* register maps the traffic class (3 bits) of egress or        */
     /* fabric multicast queues to a new 2 bits value: The value     */
     /* for each traffic class is :                                  */
     /* EgressOrFabricMulticastTrafficClassMappingRegister[(         */
     /* Traffic Class*2)+1:( Traffic Class )*2 ].                    */
     /* range: 15:0, access type: RW, default value: 0xe4e4          */
     SOC_PETRA_REG_FIELD egr_or_fabric_mc_tc_mapping[SOC_PETRA_REGS_PER_TC_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ egress_or_fabric_mc_tc_class_mapping_reg;


  /* Egress Or Fabric Multicast Base Queue Register:                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2a63 */

     /* EgressOrFabricMulticastBaseQueueRegister: This register      */
     /* holds the base queue of fabric or egress multicast PCs       */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD egress_or_fabric_multicast_base_queue_register;

  } __ATTRIBUTE_PACKED__ egress_or_fabric_multicast_base_queue_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_IRR_REGS;
/* Block definition: IHP */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2620 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2621 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2622 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_2;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2623 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_3;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2624 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_4;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2625 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_5;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2626 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_6;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2627 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_7;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2628 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_8;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2629 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 21:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_9;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2630 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2631 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2632 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_2;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2633 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_3;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2634 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_4;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2635 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_5;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2636 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_6;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2637 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_7;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2638 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_8;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2639 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 21:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_9;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2640 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically set          */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to        */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2641 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg;


  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg;


  /* General Configuration Register: Holds general                  */
  /* configuration parameters for the IHP.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2702 */

     /* SampleDroppedOnly: If set, then the last packet through      */
     /* the IHP is sampled. Otherwise, the last packet dropped       */
     /* through the IHP is sampled.                                  */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD sample_dropped_only;

     /* LagHashCrcSelect: Selects one of 3 CRC functions for LAG     */
     /* hash calculation. Value 2'b11 is invalid.                    */
     /* range: 11:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD lag_hash_crc_select;

     /* UcFlowBaseQnumAdd: If set, then the flow ID (of an           */
     /* incoming TM unicast flow) is added to UCFlowBaseQnum.        */
     /* Otherwise it is subtracted from it.                          */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD uc_flow_base_qnum_add;

     /* UcFlowBaseQnum: The flow base queue number for packets       */
     /* with incoming unicast TM flow headers.                       */
     /* range: 27:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD uc_flow_base_qnum;

  } __ATTRIBUTE_PACKED__ general_configuration_reg;


  /* Tcam Configuration Register: General configuration             */
  /* register for the TCAM.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2703 */

     /* TcamDisable: For each TCAM bank, if set then the TCAM is     */
     /* inactive.                                                    */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tcam_disable;

     /* TcamPowerDown: The PD signal of the TCAM. Currently not      */
     /* supported.                                                   */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tcam_power_down;

  } __ATTRIBUTE_PACKED__ tcam_configuration_reg;


  /* Sync Configuration: The IHP generates a synchronization        */
  /* signal specifying whether it is ready to receive               */
  /* packets. This register is used to configure this signal.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2726 */

     /* SyncCounter: If the management machines have not             */
     /* received access for the number of clocks specified by        */
     /* this register, a bubble in the processing pipeline is        */
     /* generated by dropping one sync signal. Internal              */
     /* configuration.                                               */
     /* range: 10:1, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD sync_counter;

  } __ATTRIBUTE_PACKED__ sync_configuration_reg;


  /* Lag Hash Offset Config: LAG Hash offsets configuration         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2727 */

     /* LagHashOffset_00: Lag hash offset in bytes from the end      */
     /* of system headers. Each TM type port may specify one of      */
     /* four possible LAG hash offsets.                              */
     /* range: 4:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD lag_hash_offset_00;

     /* LagHashOffset_01: Lag hash offset in bytes from the end      */
     /* of system headers. Each TM type port may specify one of      */
     /* four possible LAG hash offsets.                              */
     /* range: 9:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD lag_hash_offset_01;

     /* LagHashOffset_10: Lag hash offset in bytes from the end      */
     /* of system headers. Each TM type port may specify one of      */
     /* four possible LAG hash offsets.                              */
     /* range: 14:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD lag_hash_offset_10;

     /* LagHashOffset_11: Lag hash offset in bytes from the end      */
     /* of system headers. Each TM type port may specify one of      */
     /* four possible LAG hash offsets.                              */
     /* range: 19:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD lag_hash_offset_11;

  } __ATTRIBUTE_PACKED__ lag_hash_offset_config_reg;


  /* Port Map Register: This register defines port                  */
  /* termination when not in oc768c mode. Port termination is       */
  /* applicable only for ports 0 to 7.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2728 */

     /* PortMapEnable: Specifies if port mapping is enabled for      */
     /* this port                                                    */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD port_map_enable;

     /* PortMapIndex: For each mapped port specifies whether         */
     /* PortMapped0 or PortMapped1 should be used.                   */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_map_index;

     /* PortMapped0: One of two possible ports to map to.            */
     /* range: 22:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD port_mapped0;

     /* PortMapped1: One of two possible ports to map to.            */
     /* range: 30:24, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD port_mapped1;

  } __ATTRIBUTE_PACKED__ port_map_reg;


  /* Ptc Custom Macro Cmd0-7: Custom macro command for packet         */
  /* type classifier                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2729 */

     /* LoadOffset: If set offset of parsed headers is stored.       */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD load_offset;

     /* ShiftB: Shift in case condition matches.                     */
     /* range: 5:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD shift_b;

     /* ShiftA: Shift in case condition doesn't match.               */
     /* range: 10:6, access type: UNDEF, default value: 0x0          */
     SOC_PETRA_REG_FIELD shift_a;

     /* CondSel: Condition select.                                   */
     /* range: 14:11, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD cond_sel;

     /* MaskRight: Number of bits to mask from right of header       */
     /* range: 19:15, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD mask_right;

     /* MaskLeft: Number of bits to mask from left of header.        */
     /* range: 24:20, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD mask_left;

     /* DwSel: Offset in byte resolution from start of header.       */
     /* range: 28:25, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD dw_sel;

  } __ATTRIBUTE_PACKED__ ptc_custom_macro_cmd_reg[SOC_PETRA_PTC_CUSTOM_MACRO_CMD_NOF_REGS];


  /* Ptc Custom Protocols:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2731 */

     /* PtcCustomProtocols: Seven 32 bit protocols for custom        */
     /* macros of packet type classifier                             */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ptc_custom_protocols;

  } __ATTRIBUTE_PACKED__ ptc_custom_protocols_reg[SOC_PETRA_PTC_CUSTOM_PROTOCOLS_NOF_REGS];


  /* Ptc Ip Protocols:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2738 */

     /* PtcIpProtocols: Seven IP (layer 3) protocols for IPv4        */
     /* and IPv6 macros of packet type classifier.                   */
     /* range: 31:0 (4 fields), access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ptc_ip_protocols[SOC_PETRA_PTC_IP_PROTOCOLS_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ ptc_ip_protocols_reg[SOC_PETRA_PTC_IP_PROTOCOLS_NOF_REGS];


  /* Ptc Ethernet Types:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x273a */

     /* PtcEthernetTypes: Seven Ethernet Types for Ethernet          */
     /* macro of packet type clssifier                               */
     /* range: 15:0,31:16 access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ptc_ethernet_types[SOC_PETRA_PTC_ETHERNET_TYPES_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ ptc_ethernet_types_reg[SOC_PETRA_PTC_ETHERNET_TYPES_NOF_REGS];


  /* Ptc Is Ethernet Type:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x273e */

     /* PtcIsEthernetType: Specifies for each of the packet type     */
     /* classifier ethernet types whether it is an Ethernet Type     */
     /* or a DSAP-SSAP value                                         */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ptc_is_ethernet_type;

  } __ATTRIBUTE_PACKED__ ptc_is_ethernet_type_reg;

  /* Ecn Config: ECN configuration register                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x276c */

     /* EcnEnable: If set then ECN mode is enabled.                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ecn_enable;

     /* EcnMapping: Maps between \{Ecn-Valid, Ecn\} to               */
     /* ECN-Capable.                                                 */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ecn_mapping;

  } __ATTRIBUTE_PACKED__ ecn_config_reg;


  /* Debug Header:                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x276d */

     /* DebugHeader: This register holds the last header through     */
     /* the IHP. This register is used for debug. When reading       */
     /* the first 32b of this register the value is locked. When     */
     /* reading DebugPortType the value is unlocked. This            */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD debug_header;

  } __ATTRIBUTE_PACKED__ debug_header_reg[SOC_PA_NOF_DEBUG_HEADER_REGS];


  /* Debug Port Type:                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2770 */

     /* DebugPortType: This register holds the last port type        */
     /* through the IHP. This register is used for debug. When       */
     /* reading the first 32b of DebugHeader the value is            */
     /* locked. When reading this register the value is              */
     /* unlocked. This register is clear on read.                    */
     /* range: 2:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD debug_port_type;

  } __ATTRIBUTE_PACKED__ debug_port_type_reg;


  /* Snoop Config Reg: Snoop configuration register                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2771 */

     /* SnoopIsMc: For each snoop action, if set, then the snoop     */
     /* destination is multicast and requires multicast dbuffs.      */
     /* range: 15:1, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD snoop_is_mc;

     /* SnoopDisable: For each snoop action, if set, then the        */
     /* snoop is disabled.                                           */
     /* range: 31:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD snoop_disable;

  } __ATTRIBUTE_PACKED__ snoop_config_reg;


  /* Acl Bank Select: Selects for each TCAM bank, at each           */
  /* cycle, the source. May be one of the following:3'b000 -        */
  /* no allocation/ **3'b001 - l2 ACL3'b010 - l3a ACL3'b011 -        */
  /* l3b ACL3'b100 - IPv4 lookup3'b101 - IPv6 lookup*3'b110         */
  /* - programmable portother - undefinednote that                  */
  /* programmable port may be selected only for cycle1              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27c8 */

     /* TcamSourceCycle0BankA: Bank source for lookup                */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tcam_source_cycle0_bank_a;

     /* TcamSourceCycle0BankB: Bank source for lookup                */
     /* range: 5:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tcam_source_cycle0_bank_b;

     /* TcamSourceCycle0BankC: Bank source for lookup                */
     /* range: 8:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tcam_source_cycle0_bank_c;

     /* TcamSourceCycle0BankD: Bank source for lookup                */
     /* range: 11:9, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tcam_source_cycle0_bank_d;

     /* TcamSourceCycle1BankA: Bank source for lookup                */
     /* range: 14:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tcam_source_cycle1_bank_a;

     /* TcamSourceCycle1BankB: Bank source for lookup                */
     /* range: 17:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tcam_source_cycle1_bank_b;

     /* TcamSourceCycle1BankC: Bank source for lookup                */
     /* range: 20:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tcam_source_cycle1_bank_c;

     /* TcamSourceCycle1BankD: Bank source for lookup                */
     /* range: 23:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tcam_source_cycle1_bank_d;

     SOC_PETRA_REG_FIELD tcam_source_cycles_banks[SOC_PETRA_REGS_TCAM_NOF_CYCLES][SOC_PETRA_REGS_TCAM_NOF_BANKS];

  } __ATTRIBUTE_PACKED__ acl_bank_select_reg;


  /* Exact Match Mask0:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27f2 */

     /* ExactMatchMask0: Mask for exact match key                    */
     /* range: 31:0, access type: RW, default value: 60'hFFFFFFFFFFFFFFF */
     SOC_PETRA_REG_FIELD exact_match_mask0;

  } __ATTRIBUTE_PACKED__ exact_match_mask0_reg_0;


  /* Exact Match Mask0:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27f3 */

     /* ExactMatchMask0: Mask for exact match key                    */
     /* range: 27:0, access type: RW, default value: 60'hFFFFFFFFFFFFFFF */
     SOC_PETRA_REG_FIELD exact_match_mask0;

  } __ATTRIBUTE_PACKED__ exact_match_mask0_reg_1;


  /* Exact Match Mask1:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27f4 */

     /* ExactMatchMask1: Mask for exact match key                    */
     /* range: 31:0, access type: RW, default value: 60'hFFFFFFFFFFFFFFF */
     SOC_PETRA_REG_FIELD exact_match_mask1;

  } __ATTRIBUTE_PACKED__ exact_match_mask1_reg_0;


  /* Exact Match Mask1:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27f5 */

     /* ExactMatchMask1: Mask for exact match key                    */
     /* range: 27:0, access type: RW, default value: 60'hFFFFFFFFFFFFFFF */
     SOC_PETRA_REG_FIELD exact_match_mask1;

  } __ATTRIBUTE_PACKED__ exact_match_mask1_reg_1;


  /* Exact Match Mask2:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27f6 */

     /* ExactMatchMask2: Mask for exact match key                    */
     /* range: 31:0, access type: RW, default value: 60'hFFFFFFFFFFFFFFF */
     SOC_PETRA_REG_FIELD exact_match_mask2;

  } __ATTRIBUTE_PACKED__ exact_match_mask2_reg_0;


  /* Exact Match Mask2:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27f7 */

     /* ExactMatchMask2: Mask for exact match key                    */
     /* range: 27:0, access type: RW, default value: 60'hFFFFFFFFFFFFFFF */
     SOC_PETRA_REG_FIELD exact_match_mask2;

  } __ATTRIBUTE_PACKED__ exact_match_mask2_reg_1;


  /* Exact Match Mask3:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27f8 */

     /* ExactMatchMask3: Mask for exact match key                    */
     /* range: 31:0, access type: RW, default value: 60'hFFFFFFFFFFFFFFF */
     SOC_PETRA_REG_FIELD exact_match_mask3;

  } __ATTRIBUTE_PACKED__ exact_match_mask3_reg_0;


  /* Exact Match Mask3:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27f9 */

     /* ExactMatchMask3: Mask for exact match key                    */
     /* range: 27:0, access type: RW, default value: 60'hFFFFFFFFFFFFFFF */
     SOC_PETRA_REG_FIELD exact_match_mask3;

  } __ATTRIBUTE_PACKED__ exact_match_mask3_reg_1;


  /* Key Generation Co SHdr Var Masks: Contains four 8-bit          */
  /* masks for the CoS header variable. Each program selects        */
  /* one of these masks.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27fa */

     /* KgnCosHdrVarMask0:                                           */
     /* range: 7:0, access type: RW, default value: 0xff             */
     SOC_PETRA_REG_FIELD kgn_cos_hdr_var_mask0;

     /* KgnCosHdrVarMask1:                                           */
     /* range: 15:8, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD kgn_cos_hdr_var_mask1;

     /* KgnCosHdrVarMask2:                                           */
     /* range: 23:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD kgn_cos_hdr_var_mask2;

     /* KgnCosHdrVarMask3:                                           */
     /* range: 31:24, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD kgn_cos_hdr_var_mask3;

  } __ATTRIBUTE_PACKED__ key_generation_co_shdr_var_masks_reg;


  /* Exact Lookup For Stat:                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27fb */

     /* ExactLookupForStat: For each key generation program          */
     /* specifies whether the exact lookup result should be used     */
     /* for statistics tag construction.                             */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD exact_lookup_for_stat;

  } __ATTRIBUTE_PACKED__ exact_lookup_for_stat_reg_0;


  /* Exact Lookup For Stat:                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27fc */

     /* ExactLookupForStat: For each key generation program          */
     /* specifies whether the exact lookup result should be used     */
     /* for statistics tag construction.                             */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD exact_lookup_for_stat;

  } __ATTRIBUTE_PACKED__ exact_lookup_for_stat_reg_1;


  /* Tcam Lookup For Stat:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27fd */

     /* TcamLookupForStat: For each key generation program           */
     /* specifies whether the tcam lookup result should be used      */
     /* for statistics tag construction.                             */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tcam_lookup_for_stat;

  } __ATTRIBUTE_PACKED__ tcam_lookup_for_stat_reg_0;


  /* Tcam Lookup For Stat:                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27fe */

     /* TcamLookupForStat: For each key generation program           */
     /* specifies whether the tcam lookup result should be used      */
     /* for statistics tag construction.                             */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tcam_lookup_for_stat;

  } __ATTRIBUTE_PACKED__ tcam_lookup_for_stat_reg_1;


  /* Default Resolved Stat Data:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x27ff */

     /* DefaultResolvedStatData: For programmable ports, when        */
     /* the lookup result should be used for statistics tag          */
     /* generation, this is the value used when lookup fails.        */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD default_resolved_stat_data;

  } __ATTRIBUTE_PACKED__ default_resolved_stat_data_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_IHP_REGS;
/* Block definition: QDR */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in the QDR.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0600 */

     /* QdrEccInt: If set, indicates that ecc error occurred in      */
     /* the QDR                                                      */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_ecc_int;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0610 */

     /* QdrEccIntMask: Writing 0 masks QDR ECC Interrupt             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_ecc_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0620 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Rd Data: Data from indirect read              */
  /* command                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0630 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command: Send indirect commands to QDR and            */
  /* receives status.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0640 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically set          */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Address for indirect command         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0641 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* Qdr Ecc Error Counter: QDR ECC error counter. This             */
  /* register counts the number of errors detected by the ECC       */
  /* mechanism.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0660 */

     /* QdrEccErrCnt: Qdr ecc error counter of all read replies      */
     /* (BD, Indirect) This register is clear on read.               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qdr_ecc_err_cnt;

     /* QdrEccErrCntOvf: Qdr ecc error counter overflow              */
     /* indication                                                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_ecc_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ qdr_ecc_error_counter_reg;


  /* Reply Threshold: Reply threshold for QDR Mux FIFOs. The        */
  /* QDR includes several FIFOs for the read replies. This          */
  /* registers sets the full FIFO threshold indication              */
  /* towards the IQM.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0661 */

     /* ReplyTh: Qdr Mux Reply FIFO threshold                        */
     /* range: 5:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD reply_th;

  } __ATTRIBUTE_PACKED__ reply_threshold_reg;


  /* Dll Update Period: Dll Update Period. The DLL requires         */
  /* to be updated periodically. This registers sets the            */
  /* duration of the update period, in core clocks, which           */
  /* should be no less than the equivalent to 8 QDR clocks.         */
  /* Setting high values in this register will harm the             */
  /* bandwidth.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0662 */

     /* DllUpdatePrd: Dll update period, measured in core            */
     /* clocks. Should be equivalent to no less than 8 QDR           */
     /* clocks.                                                      */
     /* range: 7:0, access type: RW, default value: 0x14             */
     SOC_PETRA_REG_FIELD dll_update_prd;

  } __ATTRIBUTE_PACKED__ dll_update_period_reg;


  /* Qdr Protect Disable: Disable protection on QDR. This           */
  /* register disables both ECC and parity protection on the        */
  /* QDR.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0663 */

     /* QdrProtectDis: If set, disables both ECC and parity          */
     /* protection on QDR                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_protect_dis;

  } __ATTRIBUTE_PACKED__ qdr_protect_disable_reg;


  /* Qdr Ecc Bit Correction Counter: QDR ECC bit corrections        */
  /* counter. This register counts the number of bits the QDR       */
  /* was able to correct due to ECC errors. The QDR can             */
  /* correct only 1 bit errors per data burst.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0664 */

     /* QdrEccBitCorrCnt: Qdr ecc bit corrections counter of all     */
     /* read replies (BD, Indirect) This register is clear on        */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qdr_ecc_bit_corr_cnt;

     /* QdrEccBitCorrCntOvf: Qdr ecc bit corrections counter         */
     /* overflow indication                                          */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdr_ecc_bit_corr_cnt_ovf;

  } __ATTRIBUTE_PACKED__ qdr_ecc_bit_correction_counter_reg;


  /* Qdr Bist Enable: Enables the QDR BIST (Built In Self           */
  /* Test) mechanism. This register should be enabled only          */
  /* after all QDR BIST registers are configured. This is a         */
  /* level signal, therefore the BIST infinite tests will run       */
  /* as long as it is enabled. All traffic and indirect             */
  /* access must stop before BIST is enabled.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0667 */

     /* QdrBistEn: If set, enables QDR bist. Otherwise, bist is      */
     /* disabled.                                                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_bist_en;

  } __ATTRIBUTE_PACKED__ qdr_bist_enable_reg;


  /* Bist Write Number Configuration Register: Number of            */
  /* write commands to be executed in a BIST test.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0668 */

     /* BistWriteNum: Number of write commands to execute in one     */
     /* full bist test.                                              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_write_num;

  } __ATTRIBUTE_PACKED__ bist_write_number_configuration_reg;


  /* Bist Read Number Configuration Register: Number of read        */
  /* commands to be executed in a BIST test.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0669 */

     /* BistReadNum: Number of read commands to execute in one       */
     /* full bist test.                                              */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_read_num;

  } __ATTRIBUTE_PACKED__ bist_read_number_configuration_reg;


  /* Bist Infinite Test: Execute an infinite QDR BIST test.         */
  /* The test will execute an infinite number of read and/or        */
  /* write commands as long as QDR BIST is enabled.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x066a */

     /* BistWriteInfinite: Execute an infinite number of write       */
     /* commands in the bist test. Test is stopped only by           */
     /* negating QdrBistEn.                                          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_write_infinite;

     /* BistReadInfinite: Execute an infinite number of read         */
     /* commands in the bist test. Test is stopped only by           */
     /* negating QdrBistEn.                                          */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_read_infinite;

  } __ATTRIBUTE_PACKED__ bist_infinite_test_reg;


  /* Bist Read Delay: Number of write commands to execute           */
  /* before executing read commands. Some write commands must       */
  /* be executed prior to read commands to ensure the return        */
  /* of valid data.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x066b */

     /* BistReadDelay: Number of write commands to execute           */
     /* before stating to execute read commands. Required to         */
     /* assure knowledge of returned data.                           */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_read_delay;

  } __ATTRIBUTE_PACKED__ bist_read_delay_reg;


  /* Bist Thresholds: Reply threshold for QDR BIST FIFOs. The       */
  /* QDR BIST block includes several FIFOs for write and read       */
  /* commands. This register sets the full FIFO threshold           */
  /* indication to the internal machines.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x066c */

     /* BistWrTh: Qdr Mux Bist write FIFO threshold                  */
     /* range: 3:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD bist_wr_th;

     /* BistRdTh: Qdr Mux Bist read FIFO threshold                   */
     /* range: 11:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD bist_rd_th;

  } __ATTRIBUTE_PACKED__ bist_thresholds_reg;


  /* Bist Gap: This register sets the gap between commands in       */
  /* a BIST test. It is intended to control the transactions        */
  /* bandwidth on the bus, with the default value being 100%        */
  /* bandwidth. Any gap larger than zero will reduce the            */
  /* transactions bandwidth.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x066e */

     /* BistGap: The number of commands that should be issued        */
     /* before an idle is inserted for one clock. The gap allows     */
     /* reducing commands bandwidth. Actual                          */
     /* bandwidth=BistGap/(BistGap+1) and may range from 50% to      */
     /* 100% of maximal bandwidth. BistGap=0 mean 100%               */
     /* bandwidth. The gap is identical for both read and write      */
     /* commands.                                                    */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_gap;

  } __ATTRIBUTE_PACKED__ bist_gap_reg;


  /* Bist Pattern0: The test pattern that will be used in the       */
  /* BIST test. For a simple BIST test, only 18 bits (same as       */
  /* data bus width) will be used. The used bits are bits           */
  /* 17:0. For a BIST test in bit mode, all 32 bits are             */
  /* used. This register defines Bist test Pattern, Word 0           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x066f */

     /* BistPattern: Bist test Pattern Words. First 18b are       */
     /* used for simple bist test; all 32b are used for BitMode      */
     /* test.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern;

  } __ATTRIBUTE_PACKED__ bist_pattern_regs[SOC_PETRA_QDR_NOF_PATTERN_REGS];

  /* Bist Pattern0: The test pattern that will be used in the       */
  /* BIST test. For a simple BIST test, only 18 bits (same as       */
  /* data bus width) will be used. The used bits are bits           */
  /* 17:0. For a BIST test in bit mode, all 32 bits are             */
  /* used. This register defines Bist test Pattern, Word 0           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x066f */

     /* BistPattern0: Bist test Pattern, Word 0. First 18b are       */
     /* used for simple bist test; all 32b are used for BitMode      */
     /* test.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern0;

  } __ATTRIBUTE_PACKED__ bist_pattern0_reg;


  /* Bist Pattern1: Bist test Pattern, Word1                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0670 */

     /* BistPattern1: Bist test Pattern, Word1. First 18b are        */
     /* used for simple bist test; all 32b are used for BitMode      */
     /* test.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern1;

  } __ATTRIBUTE_PACKED__ bist_pattern1_reg;


  /* Bist Pattern2: Bist test Pattern, Word 2                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0671 */

     /* BistPattern2: Bist test Pattern, Word 2. First 18b are       */
     /* used for simple bist test; all 32b are used for BitMode      */
     /* test.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern2;

  } __ATTRIBUTE_PACKED__ bist_pattern2_reg;


  /* Bist Pattern3: Bist test Pattern, Word 3                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0672 */

     /* BistPattern3: Bist test Pattern, Word 3. First 18b are       */
     /* used for simple bist test; all 32b are used for BitMode      */
     /* test.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern3;

  } __ATTRIBUTE_PACKED__ bist_pattern3_reg;


  /* Bist Pattern4: Bist test Pattern, Word 4                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0673 */

     /* BistPattern4: Bist test Pattern, Word 4. First 18b are       */
     /* used for simple bist test; all 32b are used for BitMode      */
     /* test.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern4;

  } __ATTRIBUTE_PACKED__ bist_pattern4_reg;


  /* Bist Pattern5: Bist test Pattern, Word 5                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0674 */

     /* BistPattern5: Bist test Pattern, Word 5. First 18b are       */
     /* used for simple bist test; all 32b are used for BitMode      */
     /* test.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern5;

  } __ATTRIBUTE_PACKED__ bist_pattern5_reg;


  /* Bist Pattern6: Bist test Pattern, Word 6                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0675 */

     /* BistPattern6: Bist test Pattern, Word 6. First 18b are       */
     /* used for simple bist test; all 32b are used for BitMode      */
     /* test.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern6;

  } __ATTRIBUTE_PACKED__ bist_pattern6_reg;


  /* Bist Pattern7: Bist test Pattern, Word 7                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0676 */

     /* BistPattern7: Bist test Pattern, Word 7. First 18b are       */
     /* used for simple bist test; all 32b are used for BitMode      */
     /* test.                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern7;

  } __ATTRIBUTE_PACKED__ bist_pattern7_reg;


  /* Bist Start Address: BIST test start address. This              */
  /* register configures the start address for the bist test        */
  /* write commands.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0677 */

     /* BistStartAddress: Bist test write commands start address     */
     /* in the QDR memory                                            */
     /* range: 21:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_start_address;

  } __ATTRIBUTE_PACKED__ bist_start_address_reg;


  /* Bist End Address: BIST test end address. This register         */
  /* configures the end address for the bist test read &            */
  /* write commands.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0678 */

     /* BistEndAddress: Bist test write and read commands end        */
     /* address in the QDR memory. If end address is reached,        */
     /* address is reset to the initial write or read address        */
     /* (accordingly).                                               */
     /* range: 21:0, access type: RW, default value: 22'h3ffff       */
     SOC_PETRA_REG_FIELD bist_end_address;

  } __ATTRIBUTE_PACKED__ bist_end_address_reg;


  /* Bist Offset Address: This register sets the offset of          */
  /* BIST read commands start address from the write commands       */
  /* start address.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0679 */

     /* BistOffsetAddress: Bist test read commands offset            */
     /* address. The initial read address is set to the              */
     /* StartAddress+OffsetAddress. In AddressShift mode,            */
     /* initial read address is set to                               */
     /* StartAddress<<OffsetAddress. If OffsetAddress>ReadDelay,     */
     /* then the used offset is set to read delay, to assure         */
     /* knowledge of returning data.                                 */
     /* range: 21:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_offset_address;

  } __ATTRIBUTE_PACKED__ bist_offset_address_reg;


  /* Bist Test Mode: BIST test mode register. Used to select        */
  /* the operation mode of the BIST test. Can be used to            */
  /* configure both data and address advancing mode, as well        */
  /* as a dedicated address test. When no bit is asserted, a         */
  /* simple BIST test mode is in use, reading and writing two       */
  /* 18b BistPattern words on every transaction.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x067a */

     /* BistPatternBitMode: If set, every write command one bit      */
     /* data from the BistPattern is duplicated on the entire        */
     /* data bus. For one burst of 2 commands, 2 consecutive         */
     /* bits are used. All 32b of every BistPattern word are         */
     /* used in this mode. BistPatternBitMode is ignored if          */
     /* BistAddressTest is set.                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_pattern_bit_mode;

     /* BistDataRandomMode: If set, every write command is           */
     /* random data, generated by x^31+x^28+1 polynomial. For        */
     /* one burst of two commands, 2 consecutive 26b data writes     */
     /* are done. In this mode, the BistOffsetAddress is always      */
     /* taken to be 0. BistDataRandomMode is ignored if              */
     /* BistAddressTest or BistPatternBitMode are set.               */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_data_random_mode;

     /* BistDataShiftMode: If set, every write command the data      */
     /* is shifted in cyclic manner one bit left. For one burst      */
     /* of 2 commands, 2 consecutive shifts are done. Only           */
     /* BistPattern0 word is used in this mode. Intended for         */
     /* walking one / walking zero tests. BistDataShiftMode is       */
     /* ignored if BistAddressTest or BistPatternBitMode are         */
     /* set.                                                         */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_data_shift_mode;

     /* BistAddressShiftMode: If set, every write command the        */
     /* address is shifted in cyclic manner one bit left.            */
     /* Address is reset if it exceeds EndAddress. Intended for      */
     /* walking one / walking zero tests. BistAddressShiftMode       */
     /* is ignored if AddressTest is set.                            */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_address_shift_mode;

     /* BistAddressTest: Address test mode. Overrides all other      */
     /* bist modes. Writes walking ones and zeros on the address     */
     /* bus and finds if any address bit is defective.               */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_address_test;

  } __ATTRIBUTE_PACKED__ bist_test_mode_reg;


  /* Bist Address Bits Number: This register is used to             */
  /* configure the number of address bits in the used QDR           */
  /* memory. It allows user flexibility, as not always the          */
  /* maximal QDR size will be assembled on board.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x067b */

     /* BistAddrBitNum: Number of Address bits in the assembled      */
     /* QDR. This bit is relevant for address test only.             */
     /* range: 4:0, access type: RW, default value: 0x16             */
     SOC_PETRA_REG_FIELD bist_addr_bit_num;

  } __ATTRIBUTE_PACKED__ bist_address_bits_number_reg;


  /* Bist Data Shift Mod Offset: For BIST test in data shift        */
  /* mode, when read start address is in offset from write          */
  /* start address, this register should include the number         */
  /* of bits shifted between write and read address. This           */
  /* value equals (BistOffsetAddress*2) modulus                     */
  /* QDR_bus_width. BistOffsetAddress*2 is used, as each 2          */
  /* burst QDR is used. Example: If BistOffsetAddress=30,            */
  /* BistDataShiftModOffset=(30*2)%18=6                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x067c */

     /* BistDataShiftModOffset: The number of bits that should       */
     /* be shifted in data shift test mode. This value equals        */
     /* (BistOffsetAddress*2) modulus 18                             */
     /* range: 4:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_data_shift_mod_offset;

  } __ATTRIBUTE_PACKED__ bist_data_shift_mod_offset_reg;


  /* Bist Burst Mask0: Configure the bits in a burst (2             */
  /* commands) that should be masked for errors in the BIST         */
  /* test. This register configures masked bits in the data         */
  /* burst, word 0.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x067d */

     /* BistBurstMask0: Writing 0 masks error bits in the data       */
     /* burst, word 0.                                               */
     /* range: 17:0, access type: RW, default value: 18'h3FFFF       */
     SOC_PETRA_REG_FIELD bist_burst_mask0;

  } __ATTRIBUTE_PACKED__ bist_burst_mask0_reg;


  /* Bist Burst Mask1: Masked bits in the data burst, word 1.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x067e */

     /* BistBurstMask1: Writing 0 masks error bits in the data       */
     /* burst, word 1.                                               */
     /* range: 17:0, access type: RW, default value: 18'h3FFFF       */
     SOC_PETRA_REG_FIELD bist_burst_mask1;

  } __ATTRIBUTE_PACKED__ bist_burst_mask1_reg;


  /* Bist Bit Mask: Configures the bits on the data bus that        */
  /* should be masked for errors in the BIST test.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x067f */

     /* BistBitMask: Writing 0 masks error bits in the data bus.     */
     /* range: 17:0, access type: RW, default value: 18'h3FFFF       */
     SOC_PETRA_REG_FIELD bist_bit_mask;

  } __ATTRIBUTE_PACKED__ bist_bit_mask_reg;


  /* Bist Error Burst Counter: BIST burst error counter. This       */
  /* register counts the number of erroneous burst (2               */
  /* commands) replies detected.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0680 */

     /* BistErrBurstCounter: Bist burst error counter. Counts        */
     /* the number of errors that appeared on one burst (2           */
     /* commands) reply. This register is clear on read.             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_err_burst_counter;

  } __ATTRIBUTE_PACKED__ bist_error_burst_counter_reg;


  /* Bist Error Bit Counter: BIST bit error counter. This           */
  /* register counts the number of erroneous data (18 bit)          */
  /* replies detected.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0681 */

     /* BistErrBitCounter: Bist bit error counter. Counts the        */
     /* number of errors that appeared on one 18-bit reply. This     */
     /* may increase by 1 for every reply, regardless of the         */
     /* number of different bit errors on the reply. This            */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_err_bit_counter;

  } __ATTRIBUTE_PACKED__ bist_error_bit_counter_reg;


  /* Bist Error Occurred: BIST error occurred indication bit.       */
  /* An asserted bit indicates that at least one error              */
  /* occurrs on this specific data bit. Every bit corresponds       */
  /* to a bit on the external QDR data bus.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0682 */

     /* BistErrOccurred: Bist error occurred indication per bit.     */
     /* A bit is asserted if an error has occurred on it any         */
     /* time during the test. Each bit is equivalent to a bit on     */
     /* the external QDR data bus. This register is clear on         */
     /* read.                                                        */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_err_occurred;

  } __ATTRIBUTE_PACKED__ bist_error_occurred_reg;


  /* Bist Global Error Counter: BIST global error counter.          */
  /* This register counts the number of erroneous replies           */
  /* during a test, regardless of masking.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0683 */

     /* BistGlobalErrCounter: Bist global error counter. Counts      */
     /* the total number of erroneous replies, regardless bit        */
     /* masking. This register is clear on read.                     */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_global_err_counter;

  } __ATTRIBUTE_PACKED__ bist_global_error_counter_reg;


  /* Bist Error Address: This register saves the address of         */
  /* the last erroneous burst reply.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0684 */

     /* BistErrAddress: The address of the last erroneous burst      */
     /* reply.                                                       */
     /* range: 21:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_err_address;

  } __ATTRIBUTE_PACKED__ bist_error_address_reg;


  /* Bist Error Data1: This register saves the reply data           */
  /* from the first burst of the last erroneous reply.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0685 */

     /* BistErrData1: The data of the last erroneous burst           */
     /* reply, first burst word.                                     */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_err_data1;

  } __ATTRIBUTE_PACKED__ bist_error_data1_reg;


  /* Bist Error Data2: This register saves the reply data           */
  /* from the second burst of the last erroneous reply.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0686 */

     /* BistErrData2: The data of the last erroneous burst           */
     /* reply, second burst word.                                    */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_err_data2;

  } __ATTRIBUTE_PACKED__ bist_error_data2_reg;


  /* Bist Finished: BIST test finished indication. This bit         */
  /* is asserted only for non-infinite BIST tests.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0687 */

     /* BistFinished: Bist test finished indication. Cleared         */
     /* when BistEn is reset.                                        */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_finished;

  } __ATTRIBUTE_PACKED__ bist_finished_reg;


  /* Qdr Dll Control: This register controls the QDR DLL            */
  /* on/off state. It is directly mirrored to the DLL off           */
  /* signal.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0688 */

     /* DllOffn: Writing 0 turns off QDR DLL                         */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dll_offn;

  } __ATTRIBUTE_PACKED__ qdr_dll_control_reg;


  /* Qdr Controller Reset Register: This register controls          */
  /* the QDR controller block reset.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0689 */

     /* QdrcRstN: Writing 0 puts the QDRC block into reset.          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdrc_rst_n;

  } __ATTRIBUTE_PACKED__ qdr_controller_reset_reg;


  /* Qdr Dummy Data0: QDR Controller dummy data. This data is       */
  /* used both for training sequence and for sending on the         */
  /* write interface when no data is available. This register        */
  /* contains the first datum.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068a */

     /* DummyData0: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. First datum.            */
     /* range: 17:0, access type: RW, default value: 18'h2AAAA       */
     SOC_PETRA_REG_FIELD dummy_data0;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data0_reg;


  /* Qdr Dummy Data1: QDR Controller dummy data, second datum       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068b */

     /* DummyData1: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Second datum.           */
     /* range: 17:0, access type: RW, default value: 18'h15555       */
     SOC_PETRA_REG_FIELD dummy_data1;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data1_reg;


  /* Qdr Dummy Data2: QDR Controller dummy data, third datum        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068c */

     /* DummyData2: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Third datum.            */
     /* range: 17:0, access type: RW, default value: 18'h2AAAA       */
     SOC_PETRA_REG_FIELD dummy_data2;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data2_reg;


  /* Qdr Dummy Data3: QDR Controller dummy data, forth datum        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068d */

     /* DummyData3: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Forth datum.            */
     /* range: 17:0, access type: RW, default value: 18'h15555       */
     SOC_PETRA_REG_FIELD dummy_data3;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data3_reg;


  /* Qdr Dummy Data4: QDR Controller dummy data, fifth datum        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068e */

     /* DummyData4: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Fifth datum.            */
     /* range: 17:0, access type: RW, default value: 18'h2AAAA       */
     SOC_PETRA_REG_FIELD dummy_data4;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data4_reg;


  /* Qdr Dummy Data5: QDR Controller dummy data, sixth datum        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x068f */

     /* DummyData5: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Sixth datum.            */
     /* range: 17:0, access type: RW, default value: 18'h15555       */
     SOC_PETRA_REG_FIELD dummy_data5;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data5_reg;


  /* Qdr Dummy Data6: QDR Controller dummy data, seventh            */
  /* datum                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0690 */

     /* DummyData6: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Seventh datum.          */
     /* range: 17:0, access type: RW, default value: 18'h2AAAA       */
     SOC_PETRA_REG_FIELD dummy_data6;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data6_reg;


  /* Qdr Dummy Data7: QDR Controller dummy data, eighth datum       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0691 */

     /* DummyData7: QDR Controller dummy data. This data is used     */
     /* both for training sequence and for sending on the write      */
     /* interface when no data is available. Eighth datum.           */
     /* range: 17:0, access type: RW, default value: 18'h15555       */
     SOC_PETRA_REG_FIELD dummy_data7;

  } __ATTRIBUTE_PACKED__ qdr_dummy_data7_reg;


  /* Qdr Seek Data1: QDR Controller seek data. This data is         */
  /* used both for training sequence as the locking                 */
  /* pattern. This register contains the first datum.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0692 */

     /* SeekData1: QDR Controller seek data. This data is used       */
     /* for training sequence, as the locking pattern. First         */
     /* datum.                                                       */
     /* range: 17:0, access type: RW, default value: 18'h3FFFF       */
     SOC_PETRA_REG_FIELD seek_data1;

  } __ATTRIBUTE_PACKED__ qdr_seek_data1_reg;


  /* Qdr Seek Data2: QDR Controller seek data, second datum.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0693 */

     /* SeekData2: QDR Controller seek data. This data is used       */
     /* for training sequence, as the locking pattern. Second        */
     /* datum.                                                       */
     /* range: 17:0, access type: RW, default value: 18'h3FFFF       */
     SOC_PETRA_REG_FIELD seek_data2;

  } __ATTRIBUTE_PACKED__ qdr_seek_data2_reg;


  /* Qdr Calibration Configuration Register: QDR Calibration        */
  /* Configuration. This register contains several parameters       */
  /* used for the QDR controller calibration.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0694 */

     /* PreRead: Number of dummy data reads to execute before        */
     /* reading SeekData                                             */
     /* range: 3:0, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD pre_read;

     /* PostRead: Number of dummy data reads to execute after        */
     /* reading SeekData                                             */
     /* range: 7:4, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD post_read;

     /* UseDummyData: Use DummyData set by the register.             */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD use_dummy_data;

     /* MaxSeekCnt: Maximal number of clocks to wait between         */
     /* read command issue and data reply.                           */
     /* range: 15:12, access type: RW, default value: 0xf            */
     SOC_PETRA_REG_FIELD max_seek_cnt;

     /* MaxIteration: Maximal iterations to look for SeekData        */
     /* during the training sequence. Each iteration waits           */
     /* MaxSeekCnt clocks.                                           */
     /* range: 19:16, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD max_iteration;

  } __ATTRIBUTE_PACKED__ qdr_calibration_configuration_reg;


  /* Qdr Calibration Trigger: This register contains the            */
  /* trigger for the QDR calibration sequence.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0695 */

     /* SeekTrigger: If set, triggers the QDR calibration            */
     /* sequence.                                                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD seek_trigger;

  } __ATTRIBUTE_PACKED__ qdr_calibration_trigger_reg;


  /* Qdr Calibration Bypass: QDR Calibration bypass. Allows         */
  /* to manually set the QDR controller parameters, if the          */
  /* QDR calibration fails.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0696 */

     /* SetDelay: A constant delay to use between read command       */
     /* issue and read command reply                                 */
     /* range: 3:0, access type: RW, default value: 0x5              */
     SOC_PETRA_REG_FIELD set_delay;

     /* BypassCalib: Bypass QDR controller calibration sequence      */
     /* and use SetDelay                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bypass_calib;

  } __ATTRIBUTE_PACKED__ qdr_calibration_bypass_reg;


  /* Qdr Reply Lock: QDR controller has lock indication,            */
  /* marking the completion of QDR controller calibration.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0697 */

     /* ReplyLock: If set, indicates that QDR controller has         */
     /* locked on read command reply.                                */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD reply_lock;

  } __ATTRIBUTE_PACKED__ qdr_reply_lock_reg;


  /* Qdr Reply Delay: This register contains information            */
  /* about the delay, in QDR clocks, between the time a read        */
  /* command is sent and a read reply returns.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0698 */

     /* ReplyDelay: QDR delay between Read command issue by QDRC     */
     /* and returning reply.                                         */
     /* range: 3:0, access type: RO, default value: 0x7              */
     SOC_PETRA_REG_FIELD reply_delay;

  } __ATTRIBUTE_PACKED__ qdr_reply_delay_reg;


  /* Qdr Phy Reset: Qdr Phy Reset and calibration restart           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x069a */

     /* QdioReset: Reset QDR Phy module, active low                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdio_reset;

     /* DdlInitReset: Restart Qdr Phy DDL calibration Sequence       */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddl_init_reset;

  } __ATTRIBUTE_PACKED__ qdr_phy_reset_reg;


  /* Qdr Init Status: This register includes indications of         */
  /* the status of the QDR phy initialization sequence.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x069b */

     /* Ready: Phy ready indication                                  */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ready;

     /* DdlInitDone: DDL initialization done indication              */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddl_init_done;

     SOC_PETRA_REG_FIELD dll_mstr_s;

  } __ATTRIBUTE_PACKED__ qdr_init_status_reg;

  struct
  {
    SOC_PETRA_REG_ADDR addr; /* 0x069c */
    SOC_PETRA_REG_FIELD qc_sel_vec_lsb;
  } __ATTRIBUTE_PACKED__ qdr_qc_sel_vec_lsb_reg;

  /* Qdr Training Fail:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x069d */
     SOC_PETRA_REG_FIELD qc_sel_vec_msb;

     /* Fail: If set, indicates that QDR reply failed              */
     /* range: 11:11, access type: RO, default value: 0x0           */
     SOC_PETRA_REG_FIELD fail;
  } __ATTRIBUTE_PACKED__ qdr_training_fail_reg;



  /* Output Clock Delay Select: This register controls the C        */
  /* to K clock delay select. It allows creating a phase            */
  /* between write commands and read replies to improve the         */
  /* electrical performance of the device.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a0 */

     /* CcnDelSel: Selects the delay between the Qdr write clock     */
     /* K and the read clock C.                                      */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ccn_del_sel;

  } __ATTRIBUTE_PACKED__ output_clock_control_reg;


  /* Dll Updtate Counter: The QDR DLL requires a periodic DLL       */
  /* update interval. This register sets the QDR DLL Update         */
  /* timeout counter. Note that a low value in this counter         */
  /* can harm the device bandwidth performance.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a1 */

     /* DllUpdtCnt: Number of Qdr clock cycles between each DLL      */
     /* update                                                       */
     /* range: 31:0, access type: RW, default value: 32'h200000      */
     SOC_PETRA_REG_FIELD dll_updt_cnt;

  } __ATTRIBUTE_PACKED__ dll_updtate_counter_reg;


  /* Periodic Training Counter: The QDR DLL requires a              */
  /* periodic training sequence, mainly to compensate for           */
  /* temperature-caused changes. This register sets the QDR         */
  /* training timeout counter. Note that a low value in this        */
  /* counter can harm the device bandwidth performance.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a2 */

     /* PrdTrnCnt: Number of Dll update cycles between each          */
     /* Periodic training. If DllUpdtEn is disabled, will still      */
     /* use the DllUpdCnt. The number of QDR clock cycles            */
     /* between each training sequence is DllUpdCnt*PrdTrnCnt        */
     /* range: 31:0, access type: RW, default value: 0xe000          */
     SOC_PETRA_REG_FIELD prd_trn_cnt;

  } __ATTRIBUTE_PACKED__ periodic_training_counter_reg;


  /* Periodic Enable: This register enables DLL update and          */
  /* QDR phy training sequences. If either one is not               */
  /* enabled, the internal machines will maintain their             */
  /* previous values. Note that a training sequence can be          */
  /* internally triggered by the device regardless the              */
  /* setting of this register, if a fatal phy state is              */
  /* detected.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a3 */

     /* DllUpdtEn: Enables periodic DLL update.                      */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dll_updt_en;

     /* PrdTrnEn: Enables periodic phy training                      */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD prd_trn_en;

  } __ATTRIBUTE_PACKED__ periodic_enable_reg;


  /* Qdr Cq Edge Select: Select CQ sampling edge. Different         */
  /* QDR vendor datasheets point to different edge as the           */
  /* first sampling edge for returning data - either CQ             */
  /* rising edge or CQn rising edge. This register allows           */
  /* selecting with which edge to work.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a4 */

     /* CqEdgeSel: Selects the CQ edge with the first burst of       */
     /* data. If set - CQ, otherwise - CQn.                          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cq_edge_sel;

  } __ATTRIBUTE_PACKED__ qdr_cq_edge_select_reg;


  /* Dll Control: This register controls various parameters         */
  /* of the QDR's phy DLL.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x06a5 */

     /* DllDiv2En: Divide master word by 2, if reset, divided by 4   */
     /*  by default                                                  */
     /* range: 3:3 access type: RW, default value: 0x0               */
     SOC_PETRA_REG_FIELD dll_div2_en;

     /* DllUpdateSingle: Assert this signal to allow a single        */
     /* update to the DLL (Does not have to be in override mode)     */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dll_update_single;

     SOC_PETRA_REG_FIELD dll_slave_override_en;

     /* DllReady: Dll ready indication                               */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD dll_ready;

  } __ATTRIBUTE_PACKED__ dll_control_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_QDR_REGS;
/* Block definition: IQM */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0400 */

     /* FreeBdbOvf: Free-BDB counter has overflowed                  */
     /* range: 0:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD free_bdb_ovf;

     /* FreeBdbUnf: Free-BDB counter has under flowed                */
     /* range: 1:1, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD free_bdb_unf;

     /* FullUscntOvf: Full User count overflowed. Received over      */
     /* 4K multiplications for the same DB.                          */
     /* range: 3:3, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD full_uscnt_ovf;

     /* MiniUscntOvf: Mini User count overflowed. Received over      */
     /* 4 multiplications for the same DB.                           */
     /* range: 4:4, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD mini_uscnt_ovf;

     /* range: 5:5, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD updt_fifo_ovf;

     /* range: 6:6, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD txdscr_fifo_ovf;

     /* range: 7:7, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD pd_fifo_ovf;

     /* QdrSftErr: ECC/Parity error detected in read-data            */
     /* returned from the QDR (BDB data). Note: This type of         */
     /* error could cause IQM internal data-base mismatch.           */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_sft_err;

     /* PdCdTypeBitErr: PD arrived from IRR with CD-TYPE             */
     /* (Ingress shape indication) bit which does not fit the Q      */
     /* category. CD-Type =1 and Q is not ISP or CD-Type =0 and      */
     /* Q is ISP If this interrupt asserted a packet has been        */
     /* discarded in the IQM enque pipe (no counter for this         */
     /* discard).                                                    */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD pd_cd_type_bit_err;

     /* PktEnqRsrcErr: Resource error reported on the packet         */
     /* enqueue command., Packet was rejected. IDR run out of         */
     /* buffers during packet re-assembly. Asserted when             */
     /* RjctRsrcErrPktCnt increments.                                */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_rsrc_err;

     /* PktEnqSnErr: Sequence error reported on the packet           */
     /* enqueue command. The packet was rejected. IRR had wrong      */
     /* sequence number (oc-768c re-sequencing). Asserted when       */
     /* RjctSnErrPktCnt increments.                                  */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_sn_err;

     /* PktEnqMcErr: Multicast error reported on the packet          */
     /* enqueue command. The packet was rejected. IRR did not        */
     /* have place in the multicast FIFO while receiving             */
     /* multicast packet. Asserted when RjctMcErrPktCnt              */
     /* increments.                                                  */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_mc_err;

     /* PktEnqQnvalidErr: Q not valid in the packet enqueue          */
     /* command. packet was rejected. Asserted when                  */
     /* RjctQnvalidErrPktCnt increments.                             */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_qnvalid_err;

     /* StRptOvf: A statistics report has beend discarded. This      */
     /* could happen due to a rather slow rate statistics            */
     /* interface or a high rate Statistics-Sync configuration       */
     /* (StRptSyncPrd)                                               */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD st_rpt_ovf;

     /* QrollOver: One of the packet queues Q-size rolled over       */
     /* (overflowed or underflowed). The IQM must go throug          */
     /* initialization (soft reset).                                 */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD qroll_over;

     /* VsqRollOver: One of the virtual queues Q-size (bytes or      */
     /* BDs) rolled over (overflowed or underflowed). The STE        */
     /* might have wrong decisions for packet accept/reject.         */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_roll_over;

     /* EccIntrErr: If set then one (or more) of the bits in         */
     /* EccIntrruptRegister has been set.                            */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ecc_intr_err;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Ecc Interrupt Register: This register contains the             */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0401 */

     /* PqdmdSftErr: An ECC soft error detected in dynamic PQD       */
     /* (Q descriptor) memory.                                       */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD pqdmd_sft_err;

     /* TaildscrSftErr: An ECC soft error detected in                */
     /* Tail-pointer (part of Q descriptor) memory.                  */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD taildscr_sft_err;

     /* BdbllSftErr: An ECC soft error detected in BDB link list     */
     /* memory.                                                      */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdbll_sft_err;

     /* FluscntSftErr: An ECC soft error detected in                 */
     /* full-multicast user count memory.                            */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fluscnt_sft_err;

     /* MnuscntSftErr: An ECC soft error detected in                 */
     /* mini-multicast user count memory.                            */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mnuscnt_sft_err;

     /* TxpdmSftErr: An ECC soft error detected in Tx-PD FIFOs       */
     /* memory.                                                      */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD txpdm_sft_err;

     /* TxdscrmSftErr: An ECC soft error detected in                 */
     /* Tx-Descriptor FIFOs memory.                                  */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD txdscrm_sft_err;

     /* DbffmSftErr: An ECC soft error detected in Dbuff FIFO        */
     /* memory.                                                      */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD dbffm_sft_err;

     /* DelffmSftErr: An ECC soft error detected in                  */
     /* Deleted-buffers FIFO memory.                                 */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD delffm_sft_err;

     /* VsqbQszSftErr: An ECC soft error detected in VSQb Q size     */
     /* memory.                                                      */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsqb_qsz_sft_err;

     /* VsqcQszSftErr: An ECC soft error detected in VSQc Q size     */
     /* memory.                                                      */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqc_qsz_sft_err;

     /* VsqdQszSftErr: An ECC soft error detected in VSQd Q size     */
     /* memory.                                                      */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqd_qsz_sft_err;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0410 */

     /* FreeBdbOvfMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD free_bdb_ovf_mask;

     /* FreeBdbUnfMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD free_bdb_unf_mask;

     /* FullUscntOvfMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD full_uscnt_ovf_mask;

     /* MiniUscntOvfMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mini_uscnt_ovf_mask;

     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD updt_fifo_ovf_mask;
     
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD txdscr_fifo_ovf_mask;
     
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pd_fifo_ovf_mask;

     /* QdrSftErrMask: Writing 0 masks the corresponding             */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdr_sft_err_mask;

     /* PdCdTypeBitErrMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pd_cd_type_bit_err_mask;

     /* PktEnqRsrcErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_rsrc_err_mask;

     /* PktEnqSnErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_sn_err_mask;

     /* PktEnqMcErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_mc_err_mask;

     /* PktEnqQnvalidErrMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_enq_qnvalid_err_mask;

     /* FreeBdbProtErrMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD free_bdb_prot_err_mask;

     /* StRptOvfMask: Writing 0 masks the corresponding              */
     /* interrupt source.                                            */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD st_rpt_ovf_mask;

     /* QrollOverMask: Writing 0 masks the corresponding             */
     /* interrupt source.                                            */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD qroll_over_mask;

     /* VsqRollOverMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_roll_over_mask;

     /* EccIntrErrMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ecc_intr_err_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Ecc Interrupt Register Mask: Each bit in this register         */
  /* corresponds to an interrupt source in the Ecc Interrupt        */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0411 */

     /* PqdmdSftErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pqdmd_sft_err_mask;

     /* TaildscrSftErrMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD taildscr_sft_err_mask;

     /* BdbllSftErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdbll_sft_err_mask;

     /* FluscntSftErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fluscnt_sft_err_mask;

     /* MnuscntSftErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mnuscnt_sft_err_mask;

     /* TxpdmSftErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD txpdm_sft_err_mask;

     /* TxdscrmSftErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD txdscrm_sft_err_mask;

     /* DbffmSftErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dbffm_sft_err_mask;

     /* DelffmSftErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD delffm_sft_err_mask;

     /* VsqbQszSftErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsqb_qsz_sft_err_mask;

     /* VsqcQszSftErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqc_qsz_sft_err_mask;

     /* VsqdQszSftErrMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsqd_qsz_sft_err_mask;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_register_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0420 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg;


  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0621 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0622 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_2;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0623 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_3;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0624 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_4;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0625 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 19:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_5;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0630 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0631 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0632 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_2;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0633 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_3;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0634 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_4;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0635 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 19:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_5;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0640 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets the     */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access                      */
  /* address. Defines which indirect object is accessed.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0641 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform. 0:          */
     /* Write operation 1: Read operation                            */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* ECC Configuration register: This register is used for          */
  /* configuring IQM ECC                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0660 */

     /* DisEcc: If set, disables the ECC mechanism in the block.     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_ecc;

  } __ATTRIBUTE_PACKED__ ecc_configuration_reg;


  /* Iqm Init: IQM initialization internal indications.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0680 */

     /* IqcInit: While IqcInit==1, the IQC performs its 64K          */
     /* cycles inititialization. The IQC inititialization is         */
     /* triggered when IQM-Init from ECI is set. All IQC logic       */
     /* is reset, expect for the configuration reigsters and         */
     /* static tables. Tables initialized: - BDB Link List -         */
     /* Full-Multicast User count - Mini-Multicast User count -      */
     /* PQD Dynamic (Size,Average Size, Tail, Head).                 */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD iqc_init;

     /* SteInit: If set, the STE performs its 256 cycles             */
     /* inititialization. The STE init is triggered when             */
     /* IQM-Init from ECI is set. All STE logic is reset, except     */
     /* for the configuration registers and static tables.           */
     /* Tables initialized: - VSQD Size (a,b,c,d) - VSQD Average     */
     /* (a,b,c,d)                                                    */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ste_init;

  } __ATTRIBUTE_PACKED__ iqm_init_reg;


  /* Iqm Enablers: IQM Enable bits                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0681 */

     /* EnIptCD: If set, the IQM keeps FwdAction and Drop-p from     */
     /* ENQ command in the QDR, and sends them to the IPT, once      */
     /* the packet is Dequeued. If OutLif is valid (OutLif !=0),     */
     /* this bit is ignored.                                         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD en_ipt_cd;

     /* FwdActSel: Defines the source of the FwdAction sent to       */
     /* the IPT. If set, FwdAction is taken from the Q               */
     /* descriptor Q-signature field. Otherwise, FwdAction is        */
     /* taken from the Enq command (IRR) if IPT-CD is valid          */
     /* (OutLif !=0, or EnIptCd).                                    */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fwd_act_sel;

     /* DscrdAllPkt: If set, the IQM discards all incoming           */
     /* packets.                                                     */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dscrd_all_pkt;

     /* EcnEnable: If set, then the IQM will not discard packet      */
     /* singed as ECN-capable, in case of WRED discard               */
     /* (including main Q, VSQs or system-red). In this case the     */
     /* IQM will change the DROP-P presented to the IPT (EnIptCd     */
     /* must be set also)                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ecn_enable;

  } __ATTRIBUTE_PACKED__ iqm_enablers_reg;


  /* Packet Queues Categories1: Defines Packet Queues               */
  /* Categories. IQM Queues are divided to four categories.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0682 */

     /* TopPktQCat0: Top most Q that defined in category 0           */
     /* (0->TopPktQCat0)                                             */
     /* range: 14:0, access type: RW, default value: 0x1fff          */
     SOC_PETRA_REG_FIELD top_pkt_qcat0;

     /* TopPktQCat1: Top most Q that defined in category 1           */
     /* (TopPktQCat0+1 -> TopPktQCat1)                               */
     /* range: 30:16, access type: RW, default value: 0x3fff         */
     SOC_PETRA_REG_FIELD top_pkt_qcat1;

  } __ATTRIBUTE_PACKED__ packet_queues_categories1_reg;


  /* Packet Queues Categories2: Packet Queues Categories.           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0683 */

     /* TopPktQCat2: Top most Q that defined in category 2           */
     /* (TopPktQCat1+1 -> TopPktQCat2)                               */
     /* range: 14:0, access type: RW, default value: 0x5fff          */
     SOC_PETRA_REG_FIELD top_pkt_qcat2;

  } __ATTRIBUTE_PACKED__ packet_queues_categories2_reg;


  /* General Flow Control Configuration Bdb High Priority:          */
  /* Free BDB Flow-control Set and Clear thresholds                 */
  /* High-priority indication. BDB range is 64K. Values are           */
  /* presented as floating numbers : Value= Th[7:0] <<              */
  /* Th[11:8]                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0484 */

     /* FcSetFrBdbThHp: Threshold of free BDBs to set general        */
     /* flow-control. (Flow control is set when free-bdb <           */
     /* FcSetFrBdbth). It is used for high-priority flow             */
     /* control.                                                     */
     /* range: 7:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_bdb_th_hp_mnt;
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_bdb_th_hp_exp;

     /* FcClrFrBdbThHp: Threshold of free BDBs to clear the          */
     /* general flow-control. (Flow control is Cleared when          */
     /* free-bdb > FcClrFrBdbth). It is used for high-priority       */
     /* flow control.                                                */
     /* range: 19:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_bdb_th_hp_mnt;
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_bdb_th_hp_exp;

  } __ATTRIBUTE_PACKED__ general_flow_control_configuration_bdb_high_priority_reg;


  /* General Flow Control Configuration Bdb Low Priority:           */
  /* Free BDB Fc Sets/Clears thresholds Low-priority                */
  /* indication. Values are presented in floating numbers :          */
  /* Value= Th[7:0] << Th[11:8]                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0485 */

     /* FcSetFrBdbThLp: Threshold of free BDBs to set general        */
     /* flow-control. (Flow control is set when free-bdb <           */
     /* FcSetFrBdbth). It is used for low-priority flow control.     */
     /* range: 7:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_bdb_th_lp_mnt;
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_bdb_th_lp_exp;

     /* FcClrFrBdbThLp: Threshold of free BDBs to clear the          */
     /* general flow-control. (Flow control is Cleared when          */
     /* free-bdb > FcClrFrBdbth). It is used for low-priority        */
     /* flow control.                                                */
     /* range: 19:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_bdb_th_lp_mnt;
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_bdb_th_lp_exp;


  } __ATTRIBUTE_PACKED__ general_flow_control_configuration_bdb_low_priority_reg;


  /* General Reject Configuration BDBs0 : Free BDB Set and          */
  /* Clear thresholds per drop-p (0-3). Values are presented as      */
  /* floating numbers :Value: Th[7:0] << Th[11:8]                   */

  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0486 */

     /* RjctSetFrBdbTh3: Threshold of free-BDBs to set the           */
     /* reject state (Set when free-bdb <= RjctSetFrBdbTh3).         */
     /* range: 7:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_set_fr_bdb_th_mnt;
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_set_fr_bdb_th_exp;

     /* RjctClrFrBdbTh3: Threshold of free-BDBs to clear the         */
     /* reject state (Cleared when free-bdb > RjctSetFrBdbTh3).      */
     /* range: 19:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_bdb_th_mnt;
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_bdb_th_exp;

  } __ATTRIBUTE_PACKED__ general_reject_configuration_bdbs_reg[SOC_PETRA_NOF_DROP_PRECEDENCE];


  /* General Reject Configuration BDs : Occupied BD (QDR           */
  /* entries) Set and Clear thresholds for drop-p 0-3. BDs range       */
  /* is according to QDR size. Values are presented as               */
  /* floating numbers :Value: Th[11:0] << Th[15:12]                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x048a */

     /* RjctSetOcBdTh0: Threshold of occupied-BDs to set the         */
     /* reject state (Set when occupied-bd => RjctSetOcBdTh0).       */
     /* 0xFFFF - Disables the reject assertion.                      */
     /* range: 11:0, access type: RW, default value: 0xfff           */
     SOC_PETRA_REG_FIELD rjct_set_oc_bd_th_mnt;
     /* range: 15:12 */
     SOC_PETRA_REG_FIELD rjct_set_oc_bd_th_exp;

     /* RjctClrOcBdTh0: Threshold of occupied-BDs to clear the       */
     /* reject state (Cleared when occupied-bd <                     */
     /* RjctSetFrBdbTh0).                                            */
     /* range: 27:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_oc_bd_th_mnt;
     /* range: 31:28 */
     SOC_PETRA_REG_FIELD rjct_clr_oc_bd_th_exp;

  } __ATTRIBUTE_PACKED__ general_reject_configuration_bds_reg[SOC_PETRA_NOF_DROP_PRECEDENCE];

  /* General Set Flow Control Configuration DBs High                */
  /* Priority: Free-Dbuff flow-control set thresholdsUnicast        */
  /* DBs range is according to global configuration (but not        */
  /* more than 2M). Values are presented as floating numbers :       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x048e */

     /* FcSetFrDbUcThHp: Threshold of free-Unicast-Dbuffs to set     */
     /* the flow-control state. Value: Th[6:0] << Th[10:7] 0x0 -     */
     /* Disables the reject assertion.                               */
     /* range: 6:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_db_uc_th_hp_mnt;
     /* range: 10:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_db_uc_th_hp_exp;

     /* FcSetFrDbFlmcThHp: Threshold of                              */
     /* free-Full-Multicast-Dbuffs to set the flow-control           */
     /* state. Th[7:0] << Th[10:7] 0x0 - Disables the flow            */
     /* control assertion.                                           */
     /* range: 18:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_set_fr_db_flmc_th_hp_mnt;
     /* range: 21:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_set_fr_db_flmc_th_hp_exp;

  } __ATTRIBUTE_PACKED__ general_set_flow_control_configuration_bds_high_priority_reg;


  /* General Clear Flow Control Configuration DBs High              */
  /* Priority: Free-Dbuff flow-control Clear thresholds.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x048f */

     /* FcClrFrDbUcThHp: Threshold of free-Unicast-Dbuffs to         */
     /* clear theflow-control state. Value: Th[6:0] << Th[10:7]      */
     /* 0x0 - Disables the flow-control assertion.                   */
     /* range: 6:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_uc_th_hp_mnt;
     /* range: 10:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_uc_th_hp_exp;

     /* FcClrFrDbFlmcThHp: Threshold of                              */
     /* free-Full-Multicast-Dbuffs to clear the flow-control         */
     /* state. Th[7:0] << Th[10:8] 0x0 - Disables the                */
     /* flow-control assertion.                                      */
     /* range: 18:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_flmc_th_hp_mnt;
     /* range: 21:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_flmc_th_hp_exp;

  } __ATTRIBUTE_PACKED__ general_clear_flow_control_configuration_dbs_high_priority_reg;


  /* General Set Flow Control Configuration DBs Low Priority:       */
  /* Free-Dbuff flow-control set thresholds.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0490 */

     /* FcSetFrDbUcThLp: Threshold of free-Unicast-Dbuffs to set     */
     /* the flow-control state. Value: Th[6:0] << Th[10:7] 0x0 -     */
     /* Disables the flow-control assertion.                         */
     /* range: 6:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_db_uc_th_lp_mnt;
     /* range: 10:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_set_fr_db_uc_th_lp_exp;

     /* FcSetFrDbFlmcThLp: Threshold of                              */
     /* free-Full-Multicast-Dbuffs to set the flow-control           */
     /* state. Full-multicast range is configurable (but not         */
     /* more than 8K). Th[7:0] << Th[10:8] 0x0 - Disables the        */
     /* flow-control assertion.                                      */
     /* range: 18:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_set_fr_db_flmc_th_lp_mnt;
     /* range: 21:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_set_fr_db_flmc_th_lp_exp;

  } __ATTRIBUTE_PACKED__ general_set_flow_control_configuration_dbs_low_priority_reg;


  /* General Clear Flow Control Configuration DBs Low               */
  /* Priority: Free-Dbuff flow-control Clear thresholds.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0491 */

     /* FcClrFrDbUcThLp: Threshold of free-Unicast-Dbuffs to         */
     /* clear the flow control state. Value: Th[6:0] << Th[10:7]     */
     /* 0x0 - Disables the flow-control assertion.                   */
     /* range: 6:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_uc_th_lp_mnt;
     /* range: 10:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_uc_th_lp_exp;

     /* FcClrFrDbFlmcThLp: Threshold of                              */
     /* free-Full-Multicast-Dbuffs to clear the flow-control         */
     /* state. Th[7:0] << Th[10:8] 0x0 - Disables the                */
     /* flow-control assertion.                                      */
     /* range: 18:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_flmc_th_lp_mnt;
     /* range: 21:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_clr_fr_db_flmc_th_lp_exp;

  } __ATTRIBUTE_PACKED__ general_clear_flow_control_configuration_dbs_low_priority_reg;


  /* General Reject Set Configuration DBuffs                     */
  /* Reject free-Dbuffs Set thresholds per Drop Precedence (0-3) */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0492 */

     /* RjctSetFrDbUcTh0: Threshold of free-Unicast-Dbuffs to        */
     /* set the reject state. Value: Th[6:0] << Th[10:7] 0x0 -       */
     /* Disables the reject assertion.                               */
     /* range: 6:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_uc_th_mnt;
     /* range: 10:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_uc_th_exp;

     /* RjctSetFrDbMnmcTh0: Threshold of                             */
     /* free-Mini-Multicast-Dbuffs to set the reject state.          */
     /* Value: Th[5:0] << Th[9:6] 0x0 - Disables the reject          */
     /* assertion.                                                   */
     /* range: 16:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_mnmc_th_mnt;
     /* range: 20:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_mnmc_th_exp;

     /* RjctSetFrDbFlmcTh0: Threshold of                             */
     /* free-Full-Multicast-Dbuffs to set the reject state.          */
     /* Value: Th[7:0] << Th[10:8] 0x0 - Disables the reject         */
     /* assertion.                                                   */
     /* range: 28:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_flmc_th_mnt;
     /* range: 31:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_set_fr_db_flmc_th_exp;

  } __ATTRIBUTE_PACKED__ general_reject_set_configuration_dbuffs_reg[SOC_PETRA_NOF_DROP_PRECEDENCE];


  /* General Reject Clear Configuration DBuffs0 : Reject            */
  /* free-Dbuffs Clear thresholds for Drop-p 0                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0496 */

     /* RjctClrFrDbUcTh0: Threshold of free-Unicast-Dbuffs to        */
     /* clear the reject state. Value: Th[6:0] << Th[10:7] 0x0 -     */
     /* Disables the reject assertion.                               */
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_uc_th_mnt;
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_uc_th_exp;

     /* RjctClrFrDbMnmcTh0: Threshold of                             */
     /* free-Mini-Multicast-Dbuffs to clear the reject state.        */
     /* Value: Th[5:0] << Th[9:6] 0x0 - Disables the reject          */
     /* assertion.                                                   */
     /* range: 20:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_mnmc_th_mnt;
     /* range: 20:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_mnmc_th_exp;

     /* RjctClrFrDbFlmcTh0: Threshold of                             */
     /* free-Full-Multicast-Dbuffs to clear the reject state.        */
     /* Th[7:0] << Th[10:8] 0x0 - Disables the reject assertion.     */
     /* range: 31:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_flmc_th_mnt;
     /* range: 31:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_clr_fr_db_flmc_th_exp;

  } __ATTRIBUTE_PACKED__ general_reject_clear_configuration_dbuffs_reg[SOC_PETRA_NOF_DROP_PRECEDENCE];


  /* Statistics Tag Configuration: The statistics-tag is a          */
  /* 30/32-bit information inserted by the User as part of          */
  /* the packet. The register defines the IQM functionalities        */
  /* regarding the statistics-tag.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049a */

     /* StatTagVsqMsb: The MSB of the VSQ field in the               */
     /* statistics Tag                                               */
     /* range: 4:0, access type: RW, default value: 0x7              */
     SOC_PETRA_REG_FIELD stat_tag_vsq_msb;

     /* StatTagVsqLsb: The LSB of the VSQ field in the               */
     /* statistics tag. The value in the field between the MSB        */
     /* and LSB defines a VSQ number that is used by the STE,        */
     /* when gathering statistics information. (VSQ group D)         */
     /* Note: A total of 256 VSQs are supported using the            */
     /* Stat-tag (8 bits).                                           */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD stat_tag_vsq_lsb;

     /* StatTagVsqEn: If set, then the VSQ defines a separate        */
     /* VSQ number in the STE. Otherwise, the Statistics Tag is      */
     /* just forwarded to the Statistics interface.                  */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tag_vsq_en;

     /* StatTagDeqEn: If set, the statistics Tag is kept in the      */
     /* QDR, and reported when the packet is Dequeued.               */
     /* Otherwise, the StatTagVsqEn is ignored.                      */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tag_deq_en;

     /* StatTagDroppEn: If set, then the Statistics-Tag carries      */
     /* the Drop-p[1:0] field.                                       */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tag_dropp_en;

     /* StatTagDroppLsb: Defines the bit number where the LSB        */
     /* bit of the Drop-p[1:0] exists. This is valid only if         */
     /* StatTahDroppEn is asserted.                                  */
     /* range: 24:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stat_tag_dropp_lsb;

  } __ATTRIBUTE_PACKED__ statistics_tag_configuration_reg;


  /* Statistics Report Configurations: Statistics reports           */
  /* definitions. Define the format of the statistics report        */
  /* presented on the statistics interface.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049b */

     /* StRptBill: If set, the statistics report is composed in      */
     /* billing mode: Ingress Enq and Egress (EGQ) Enq reports.      */
     /* Otherwise FAP20-compatible mode is presented: Ingress        */
     /* Enq and Ingress Deq reports.                                 */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD st_rpt_bill;

     /* StRptPcktSize: If set, selects packet-size format for        */
     /* the statistics report. Otherwise, selects Qsize format.       */
     /* Valid only for FAP20-compatible mode.                        */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD st_rpt_pckt_size;

     /* StRptMcidSptMc: If set, presents Multicast ID for            */
     /* spatial-multicast packets (instead of Qnum). Otherwise,       */
     /* spatial-multicast packets are reported with the Qnumber.     */
     /* Valid only for FAP20- compatible mode working in packet-     */
     /* size mode.                                                   */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD st_rpt_mcid_spt_mc;

     /* StRptMcidIngRep: If set, presents Multicast ID for           */
     /* Ingress-Replication multicast packets (instead of            */
     /* Qnum). Otherwise, Ingress-Replication multicast packets       */
     /* are reported with the Qnumber. Valid only for FAP20-         */
     /* compatible mode working in packet- size mode.                */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD st_rpt_mcid_ing_rep;

     /* StRptCntSnp: If set, snoop/mirror packets are also           */
     /* counted in the Copy-Count. Valid only for                    */
     /* FAP20-compatible mode. (Not valid for this version)          */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD st_rpt_cnt_snp;

     /* StRptEgrOlif: If set, outLif is presented for the Egress     */
     /* report. Otherwise, the egress Q number is presented for      */
     /* the Egress report. Valid only in billing mode.               */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD st_rpt_egr_olif;

     /* StRptSyncPrd: Statisitcs interface sync period. Defines      */
     /* the maximal period between concecutive sync patterns         */
     /* transmitted on the statistics interface (The pattern is      */
     /* defined as 3MSBs equal to 3'b111 for MSB part, and           */
     /* 3'b110 for LSB part). The period is defined as:              */
     /* (2^StRptSyncPrd) cycles (of 250Mhz). Note: this is the       */
     /* maximal period, the STE will send sync patterns whenever     */
     /* it has no report to send. Value 0 - disables sync            */
     /* patterns transmission. Valid range: 1-> 30.                  */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD st_rpt_sync_prd;

  } __ATTRIBUTE_PACKED__ statistics_report_configurations_reg;


  /* Bdb Configuration: BDB configurations                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049c */

     /* BdbSize: Defines the number of BDs (QDR buffer               */
     /* descriptor) inside a single BDB. 0: 8 BDs 1: 16 BDs 2:       */
     /* 32 BDs 3: 64 BDs                                             */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdb_size;

     /* RecycleFrBdb: Use local freed BDB from DEQ pipe as           */
     /* free-BDBs to the ENQ pipe (bypass the free-BDB link          */
     /* list) Note: this should be enabled to ensure best            */
     /* performance.                                                 */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD recycle_fr_bdb;

  } __ATTRIBUTE_PACKED__ bdb_configuration_reg;

  /* Internal Thesholds                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049d */

     /* range: 6:0, access type: RW, default value: 0x20           */
     SOC_PETRA_REG_FIELD thr_0;
     /* range: 12:8, access type: RW, default value: 0xc           */
     SOC_PETRA_REG_FIELD thr_1;
  } __ATTRIBUTE_PACKED__ intern_thresh_reg;


  /* Reject Admission: Rejects admission template sets              */
  /* selected by AddmitLogic[1:0] from Q param table. Defines       */
  /* the test accounted for the packet reject decision. Bit         */
  /* Assignment:RjctTmplt[0] - Category-VSQ testRjctTmplt[1]        */
  /* - Category&Connection-class VSQ testRjctTmplt[2] -             */
  /* Category2/3 & Class test VSQ testRjctTmplt[3] -                */
  /* Statistic TAG VSQ testPacket is accepted if:GlbTest &          */
  /* IngQ & ( (TmplA[0] | Cat) & (TmplA[1] | CTC) & (TmplA[2]       */
  /* | CCC) & (TmplA[3] |ST ) Or (TmplB[0] | Cat) & (TmplB[1]       */
  /* | CTC) & (TmplB[2] | CCC) & (TmplB[3] |ST ))                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049e */

     /* RjctTmpltaSet0: Masking bits for VSQ accept                  */
     /* tests. EVEN index- Template A                                */
     /*        ODD index - Template B                                */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rjct_tmplt_set[SOC_PETRA_NOF_RJCT_ADMIT_TMPLTS];

  } __ATTRIBUTE_PACKED__ reject_admission_reg;


  /* Free Unicast Dbuff Threshold0: System RED                      */
  /* configuration. Free Unicast Dbuff Threshold Define value        */
  /* - 0. Value is used to generate general-source-Q-size (4         */
  /* bit) for the IPS                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x049f */

     /* FrUnDbTh2: If free-Uni-dbuff between Th2 and Th1 >           */
     /* Qsize=Val2 If free-Uni-dbuff- below this threshold, then     */
     /* Qsize =Val3                                                  */
     /* range: 20:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_un_db_th;

  } __ATTRIBUTE_PACKED__ free_unicast_dbuff_threshold_reg[SOC_PETRA_NOF_DBUFFS_THS];


  /* Free Unicast Dbuff Range Values: System RED                    */
  /* configurationDefine respective source-Q-size value for         */
  /* each range of the Free-Unicast-Dbuff counter                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x04a2 */

     /* FrUnDbRngVal0-3: Source-Q-size value assigned to Range-3       */
     /* range: 15:12, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fr_un_db_rng_val[SOC_PETRA_NOF_DBUFFS_VALS];

  } __ATTRIBUTE_PACKED__ free_unicast_dbuff_range_values_reg;


  /* Free Full Multicast Dbuff Threshold0-2: System RED               */
  /* configurationFree Full-Multicast Dbuff Thresholds. Values       */
  /* used to generate general-source-Q-size (4 bit) for the         */
  /* IPS                                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x04a3 */

     /* FrFlMulDbTh2: If free-full-mult-dbuff between Th2 and        */
     /* Th1 > Qsize=Val2 If free-full-mult-dbuff below this          */
     /* threshold then Qsize = Val3                                  */
     /* range: 12:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_fl_mul_db_th;

  } __ATTRIBUTE_PACKED__ free_full_multicast_dbuff_threshold_reg[SOC_PETRA_NOF_DBUFFS_THS];


  /* Free Full Multicast Dbuff Range Values: System RED             */
  /* configurationDefine respective source-Q-size value for         */
  /* each range of the Free-Full-Multicast-Dbuff counter            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x04a6 */

     /* FrFlMlDbRngVal3: Source-Q-size value assigned to Range0-3     */
     /* range: 15:12, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fr_fl_ml_db_rng_val[SOC_PETRA_NOF_DBUFFS_VALS];

  } __ATTRIBUTE_PACKED__ free_full_multicast_dbuff_range_values_reg;


  /* Free Bdb Threshold0-2: System RED configurationFree BDB          */
  /* Threshold. Values used to generate general-source-Q-size        */
  /* (4 bit) for the IPS                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x04a8 */

     /* FrBdbTh2: If free-bdb between Th2 and Th1 > Qsize=Val2       */
     /* If free-bdb below this threshold then Qsize = Val3           */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_bdb_th;

  } __ATTRIBUTE_PACKED__ free_bdb_threshold_reg[SOC_PETRA_NOF_DBUFFS_THS];


  /* Free Bdb Range Values: System RED configurationDefine          */
  /* respective source-Q-size value for each range of the           */
  /* Free-BDBs counter                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x04aa */

     /* FrBdbRngVal3: Source-Q-size value assigned to Range0-3        */
     /* range: 15:12, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD fr_bdb_rng_val[SOC_PETRA_NOF_DBUFFS_VALS];

  } __ATTRIBUTE_PACKED__ free_bdb_range_values_reg;


  /* Programmable Counter Queue Select: Defines the Q               */
  /* selection of the programmable counters                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0700 */

     /* PrgCntQ: Matching Filter Q number                            */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD prg_cnt_q;

     /* PrgCntMsk: Matching Filter mask Filter matches if : (        */
     /* Qnum | PrgCntMsk) == (PrgCntQ | PrgCntMsk)                   */
     /* range: 31:17, access type: RW, default value: 0x7fff         */
     SOC_PETRA_REG_FIELD prg_cnt_msk;

  } __ATTRIBUTE_PACKED__ programmable_counter_queue_select_reg;


  /* Vsq Programmable Counter Select: Defines the VSQ               */
  /* selection of the programmable                                  */
  /* counters/MaxOccupancy. Counter relates to operation done        */
  /* on the VSQs that are matching the filter and the               */
  /* VsqPrgGrpSel value. Note: the filter cannot select              */
  /* monitored VSQs from different groups.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0701 */

     /* VsqPrgCntQ: Matching Filter VSQ Q number The VSQ number      */
     /* is the selected group range.                                 */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsq_prg_cnt_q;

     /* VsqPrgCntMsk: Matching Filter mask Filter matches if : (     */
     /* VSQnum | VsqPrgCntMsk) == (VsqPrgCntQ | VsqPrgCntMsk)        */
     /* range: 19:12, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD vsq_prg_cnt_msk;

     /* VsqPrgGrpSel: Defines the VSQ group that the counters        */
     /* should relate to. 0: Check group a (VSQs 0->3, Q             */
     /* category) 1: Check group b (VSQs 4->35, Q category &         */
     /* TrClss) 2: Check group c (VSQs 36->99, Q category &          */
     /* (CnClss2/3)) 3: Check group d (VSQs 100 -> 355, ST-TAG)      */
     /* range: 21:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_prg_grp_sel;

  } __ATTRIBUTE_PACKED__ vsq_programmable_counter_select_reg;


  /* Global Time Counter: Gtimer configuration                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0702 */

     /* GtPrd: Global timer period. Gtimer expires after             */
     /* TimePrd. Default value equivalent to 1[sec] @ 250[Mhz]       */
     /* range: 30:0, access type: RW, default value: 31'hEE6B280     */
     SOC_PETRA_REG_FIELD gt_prd;

     /* GtRstCntrs: If asserted then all related counters are        */
     /* cleared when GtStrtTrg is asserted.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gt_rst_cntrs;

  } __ATTRIBUTE_PACKED__ global_time_counter_reg;


  /* Global Time Counter Trigger: Gtimer trigger.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0703 */

     /* GlbCntTrg: When set, the global-counter counter starts.      */
     /* Trigger is deasserted when counter expires.                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_cnt_trg;

  } __ATTRIBUTE_PACKED__ global_time_counter_trigger_reg;


  /* Global Time Counter Configuration: Defines which               */
  /* counters count according to the global-timer.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0704 */

     /* IqcCntByGt: If set, then the IQC's counters count            */
     /* according to the GlobalTimer.                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD iqc_cnt_by_gt;

     /* IqcPrgCntByGt: If set, then the IQC's programmable           */
     /* counters count according to the GlobalTimer.                 */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD iqc_prg_cnt_by_gt;

     /* SteCntByGt: If set, then the STE counters count              */
     /* according to the GlobalTimer.                                */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ste_cnt_by_gt;

  } __ATTRIBUTE_PACKED__ global_time_counter_configuration_reg;


  /* Global Reject State: Global Reject States status.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0750 */

     /* GlbRjctBdb: Reject State VS free-BDBs Drop-p 3,2,1,0         */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_rjct_bdb;

     /* GlbRjctOcBd: Reject State VS consumed BDs (QDR entrees)      */
     /* Drop-p 3,2,1,0                                               */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_rjct_oc_bd;

     /* GlbRjctFrdbFlmc: Reject State VS free Unicast Dbuffs         */
     /* Drop-p 3,2,1,0                                               */
     /* range: 11:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD glb_rjct_frdb_flmc;

     /* GlbRjctFrdbMnmc: Reject State VS free Unicast Dbuffs         */
     /* Drop-p 3,2,1,0                                               */
     /* range: 15:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD glb_rjct_frdb_mnmc;

     /* GlbRjctFrdbUc: Reject State VS free Unicast Dbuffs           */
     /* Drop-p 3,2,1,0                                               */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD glb_rjct_frdb_uc;

  } __ATTRIBUTE_PACKED__ global_reject_state_reg;


  /* Global Flow Control State: Global Flow-Control                 */
  /* indications.                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0751 */

     /* GlbFcBdb: Global Flow-Control VS free-BDBs.                  */
     /* range: 1:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_fc_bdb;

     /* GlbFcFrdbUc: Global Flow-Control VS free Unicast Dbuffs.     */
     /* range: 3:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_fc_frdb_uc;

     /* GlbFcFrdbFlmc: Global Flow-Control VS free Full              */
     /* multicast Dbuffs.                                            */
     /* range: 5:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_fc_frdb_flmc;

  } __ATTRIBUTE_PACKED__ global_flow_control_state_reg;


  /* Global Resource Counters:                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0752 */

     /* FreeBdbCount: Number of free BDBs (buffer descriptors        */
     /* buffers). The IQM uses this counter to generate/decide       */
     /* on packet Reject and generate Flow-Control signal.           */
     /* range: 16:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD free_bdb_count;

  } __ATTRIBUTE_PACKED__ global_resource_counters_reg;


  /* Global Resource Counters BD:                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0753 */

     /* OcBdCount: Number of occupied BDs (Buffer-Descriptor or      */
     /* QDR entrees). The IQM uses this counter to                   */
     /* generate/decide on packet Reject.                            */
     /* range: 22:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD oc_bd_count;

  } __ATTRIBUTE_PACKED__ global_resource_counters_bd_reg;


  /* Free Unicast Dbuffs Counter:                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0754 */

     /* FrDbCountUc: Counts the number of free Unicast Type          */
     /* Dbuffs. The counter is managed by the IQM according to       */
     /* indication of Buffer capture/release from the IDR. The       */
     /* IQM uses this counter to generate/decide on packet           */
     /* Reject and generate Flow-Control signal.                     */
     /* range: 21:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_count_uc;

  } __ATTRIBUTE_PACKED__ free_unicast_dbuffs_counter_reg;


  /* Free Full Multicast Dbuffs Counter:                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0755 */

     /* FrDbCountFlmc: Counts the number of free Full-Multicast      */
     /* Type Dbuffs. The counter is managed by the IQM according     */
     /* to indication of Buffer capture/release from the IDR.        */
     /* The IQM uses this counter to generate/decide on packet       */
     /* Reject and generate Flow-Control signal.                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_count_flmc;

  } __ATTRIBUTE_PACKED__ free_full_multicast_dbuffs_counter_reg;


  /* Free Mini Multicast Dbuffs Counter:                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0756 */

     /* FrDbCountMnmc: Counts the number of free Mini-Multicast      */
     /* Type Dbuffs. The counter is managed by the IQM according     */
     /* to indication of Buffer capture/release from the IDR.        */
     /* The IQM uses this counter to generate/decide on packet       */
     /* Reject and generate Flow-Control signal.                     */
     /* range: 16:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_count_mnmc;

  } __ATTRIBUTE_PACKED__ free_mini_multicast_dbuffs_counter_reg;


  /* Global Resource Minimum Occupancy:                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0757 */

     /* FreeBdbMinOc: Free BDBs (buffer descriptors buffers)         */
     /* minimum occupancy indication. A low watermark that           */
     /* points to minimal level of free-BDBs. Cleared (set to        */
     /* 64K) when read. This register is clear on read.              */
     /* range: 16:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD free_bdb_min_oc;

  } __ATTRIBUTE_PACKED__ global_resource_minimum_occupancy_reg;


  /* Free Unicast Dbuffs Minimum Occupancy:                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0758 */

     /* FrDbMinOc: Free Unicast Type Dbuffs minimal occupancy        */
     /* level. Cleared (set to Number of Uni-Dbuffs) when read.      */
     /* This register is clear on read.                              */
     /* range: 21:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_min_oc;

  } __ATTRIBUTE_PACKED__ free_unicast_dbuffs_minimum_occupancy_reg;


  /* Free Full Multicast Dbuffs Minimum Occupancy:                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0759 */

     /* FrDbFlmcMinOc: Free Full-Multicast Type Dbuffs minimal       */
     /* occupancy level. Cleared (set to Number of                   */
     /* Full-Mul-Dbuffs) when read. This register is clear on        */
     /* read.                                                        */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_flmc_min_oc;

  } __ATTRIBUTE_PACKED__ free_full_multicast_dbuffs_minimum_occupancy_reg;


  /* Free Mini Multicast Dbuffs Minimum Occupancy:                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x075a */

     /* FrDbMnmcMinOc: Free Mini-Multicast Type Dbuffs minimal       */
     /* occupancy level. Cleared (set to Number of                   */
     /* Min-Mul-Dbuffs) when read. This register is clear on         */
     /* read.                                                        */
     /* range: 16:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fr_db_mnmc_min_oc;

  } __ATTRIBUTE_PACKED__ free_mini_multicast_dbuffs_minimum_occupancy_reg;


  /* Enqueue Packet Counter:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x075b */

     /* EnqPktCnt: Counts enqueued packets (does not include         */
     /* discarded packets) This register is clear on read.           */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD enq_pkt_cnt;

     /* EnqPktCntOvf: EnqPktCnt Overflow bit. When using CntByGt     */
     /* (count by gtime), the bit means "finished".                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD enq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ enqueue_packet_counter_reg;


  /* Dequeue Packet Counter:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x075c */

     /* DeqPktCnt: Counts dequeued packets (do not include           */
     /* deleted packets) This register is clear on read.             */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD deq_pkt_cnt;

     /* DeqPktCntOvf: DeqPktCnt Overflow bit When using CntByGt      */
     /* (count by gtime), the bit means "finished".                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ dequeue_packet_counter_reg;


  /* Total Discarded Packet Counter:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x075d */

     /* TotDscrdPktCnt: Counts all the packets discarded at the      */
     /* ENQ pipe. Tail Discarded. This register is clear on          */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tot_dscrd_pkt_cnt;

     /* TotDscrdPktCntOvf: TotDscrdPktCnt Overflow bit When          */
     /* using CntByGt (count by gtime), the bit means                */
     /* "finished".                                                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tot_dscrd_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ total_discarded_packet_counter_reg;


  /* Deleted Packet Counter:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x075e */

     /* DeqDeletePktCnt: Counts packets discarded in the DEQ         */
     /* process (IPS signaled Discard for the packet). Head          */
     /* Discarded. This register is clear on read.                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD deq_delete_pkt_cnt;

     /* DeqDeletePktCntOvf: DeqDeleteCnt Overflow bit When using     */
     /* CntByGt (count by gtime), the bit means "finished".          */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_delete_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ deleted_packet_counter_reg;


  /* Isp Packet Counter:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x075f */

     /* IspPktCnt: Counts ISP packets passed on IQM2IRR              */
     /* interface. Note: these packets are counted also as DEQ       */
     /* packets (DeqPktCnt) This register is clear on read.          */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD isp_pkt_cnt;

     /* IspPktCntOvf: IspPktCnt Overflow bit When using CntByGt      */
     /* (count by gtime), the bit means "finished".                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD isp_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ isp_packet_counter_reg;


  /* Queue Enqueue Packet Counter: Counts according to a            */
  /* programmable Counter                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0760 */

     /* QEnqPktCnt: Counts matched enqueued packets (does not        */
     /* include discarded packets) The counter counts according      */
     /* to Queue filtering settings (PrgCntQ,PrgCntMsk). This        */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qenq_pkt_cnt;

     /* QEnqPktCntOvf: QEnqPktCnt Overflow bit.                      */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qenq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ queue_enqueue_packet_counter_reg;


  /* Queue Dequeue Packet Counter: Counts according to              */
  /* programmable Counter                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0761 */

     /* QDeqPktCnt: Counts matched dequeued packets (does not        */
     /* include deleted packets). The counter counts according       */
     /* to Queue filtering settings (PrgCntQ,PrgCntMsk). This        */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qdeq_pkt_cnt;

     /* QDeqPktCntOvf: QDeqPktCnt Overflow bit.                      */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdeq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ queue_dequeue_packet_counter_reg;


  /* Queue Total Discarded Packet Counter: Counts according         */
  /* to programmable Counter                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0762 */

     /* QTotDscrdPktCnt: Counts matched packets discarded at ENQ     */
     /* pipe. Tail Discarded. The counter counts according to        */
     /* Queue filtering settings (PrgCntQ,PrgCntMsk). This           */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qtot_dscrd_pkt_cnt;

     /* QTotDscrdPktCntOvf: QTotDscrdPktCnt Overflow bit.            */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qtot_dscrd_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ queue_total_discarded_packet_counter_reg;


  /* Queue Deleted Packet Counter: Counts according to              */
  /* programmable Counter                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0763 */

     /* QDeqDeletePktCnt: Counts matched packets discarded in        */
     /* the DEQ process (IPS signaled Discard for the packet).       */
     /* Head Discarded. The counter counts according to Queue        */
     /* filtering settings (PrgCntQ,PrgCntMsk). This register is     */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qdeq_delete_pkt_cnt;

     /* QDeqDeletePktCntOvf: QDeqDeleteCnt Overflow bit.             */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qdeq_delete_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ queue_deleted_packet_counter_reg;


  /* Free Resource Rejected Packet Counter1: Counters for           */
  /* packet rejected due to lack of global resources.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0764 */

     /* RjctDbPktCnt: Counts packets reject in the ENQ process       */
     /* due to lack of free-Dbuffs                                   */
     /* (Unicast/Mini/Full-multicast). This register is clear on     */
     /* read.                                                        */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_db_pkt_cnt;

     /* RjctDbPktCntOvf: RjctDbPktCnt Overflow bit                   */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_db_pkt_cnt_ovf;

     /* RjctBdbPktCnt: Counts packets reject in the ENQ process      */
     /* due to lack of free-BDBs (free-bdb counter value reduced     */
     /* bellow reject thresholds). This register is clear on         */
     /* read.                                                        */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_bdb_pkt_cnt;

     /* RjctBdbPktCntOvf: RjctBdbPktCnt Overflow bit                 */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_bdb_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ free_resource_rejected_packet_counter1_reg;


  /* Free Resource Rejected Packet Counter2:                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0765 */

     /* RjctBdbProtctPktCnt: Counts packets rejected in the ENQ      */
     /* process due to panic mode protection of free-bdb             */
     /* resource. Note: This type of discard is not related to       */
     /* threholds and drop-p. This register is clear on read.        */
     /* range: 7:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rjct_bdb_protct_pkt_cnt;

     /* RjctBdbProtctPktCntOvf: RjctBdbProtctPktCnt Overflow bit     */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD rjct_bdb_protct_pkt_cnt_ovf;

     /* RjctOcBdPktCnt: Counts packets rejected in the ENQ           */
     /* process due to lack of free-BDs (QDR entrees). Note:         */
     /* Packet is discarded if OcBdCounter (occupied BDs) is         */
     /* over threshold. This register is clear on read.              */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_oc_bd_pkt_cnt;

     /* RjctOcBdPktCntOvf: RjctOcBdPktCnt Overflow bit               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_oc_bd_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ free_resource_rejected_packet_counter2_reg;


  /* Irr Error Rejected Packet Counters : These counters            */
  /* count packets that are rejected due to errors reported         */
  /* by the IRR.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0766 */

     /* RjctSnErrPktCnt: Counts packets rejected in the ENQ          */
     /* process due to sequence number error in the IRR (oc-768c     */
     /* re-sequencing). This register is clear on read.              */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_sn_err_pkt_cnt;

     /* RjctSnErrPktCntOvf: RjctSeqNumErrPktCnt Overflow bit.        */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_sn_err_pkt_cnt_ovf;

     /* RjctMcErrPktCnt: Counts packets rejected in the ENQ          */
     /* process due to multicast error in the IRR (IRR did not       */
     /* have place in the MC FIFO). This register is clear on        */
     /* read.                                                        */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_mc_err_pkt_cnt;

     /* RjctMcErrPktCntOvf: RjctBdbPktCnt Overflow bit               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_mc_err_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ irr_error_rejected_packet_counters_reg;


  /* Idr Error Reject Packet Counters : These counters count        */
  /* packets that are rejected due to errors reported by the        */
  /* IDR.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0767 */

     /* RjctRsrcErrPktCnt: Counts packets rejected in the ENQ        */
     /* process resource error signal in the PD: the IDR run out     */
     /* of Dbuffs while re-assembling the packet. Note: in this      */
     /* case the IQM reject the packet but does not release          */
     /* Dbuffs. This register is clear on read.                      */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rjct_rsrc_err_pkt_cnt;

     /* RjctRsrcErrPktCntOvf: RjctRsrcErrPktCnt Overflow bit         */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_rsrc_err_pkt_cnt_ovf;

     /* RjctQnvalidErrPktCnt: Counts packets rejected in the ENQ     */
     /* process due to Q not valid in the ENQ command. This          */
     /* register is clear on read.                                   */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_qnvalid_err_pkt_cnt;

     /* RjctQnvalidErrPktCntOvf: RjctQnvalidErrPktCnt Overflow       */
     /* bit.                                                         */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rjct_qnvalid_err_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ idr_error_reject_packet_counters_reg;


  /* Maximum Occupancy Queue Size0: Maximum Packet Queue            */
  /* occupancy                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0768 */

     /* MxOcQsz: Presents the maximum occupancy level of the         */
     /* Packet Qs. Value is in units of 16-bytes. Cleared when       */
     /* read. This register is clear on read.                        */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mx_oc_qsz;

     /* MxOcRfrsh: Maximum occupancy value refresh indication.       */
     /* Set whenever the maximum occupancy value/Qnum has been       */
     /* updated/changed. Auto-Clear.                                 */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mx_oc_rfrsh;

  } __ATTRIBUTE_PACKED__ maximum_occupancy_queue_size0_reg;


  /* Maximum Occupancy Queue Size1:                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0769 */

     /* MxOcQnum: Holds the Q number to which the maximum            */
     /* occupancy value relates. Updated when MxOcQsz is             */
     /* updated.                                                     */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mx_oc_qnum;

  } __ATTRIBUTE_PACKED__ maximum_occupancy_queue_size1_reg;


  /* Queue Maximum Occupancy Queue Size0: Queue filter              */
  /* Maximum Packet Queue occupancy                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x076a */

     /* QMxOcQsz: Presents the maximum occupancy level (Qsize)       */
     /* measured on the matching filter Q or Qs (PrgCntQ and         */
     /* PrgCntMsk). The Value is in units of 16-bytes. Cleared        */
     /* when read. This register is clear on read. This register     */
     /* is clear on read.                                            */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD qmx_oc_qsz;

     /* QMxOcRfrsh: Maximum occupancy value refresh                  */
     /* indication. Set whenever the maximum occupancy value/Qnum     */
     /* has been updated/changed. Auto-Clear.                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD qmx_oc_rfrsh;

  } __ATTRIBUTE_PACKED__ queue_maximum_occupancy_queue_size0_reg;


  /* Vsq Maximum Occupancy0: Maximum VSQ occupancy                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x076b */

     /* VsqMxOcQsz: Presents the maximum occupancy level of the      */
     /* VSQs that match the programmable counter                     */
     /* settings. Maximum occupancy is updated when either size       */
     /* in bytes or BDs exceeds the current maximum size. Value       */
     /* is in units of 16-bytes. This register is clear on read.     */
     /* This register is clear on read.                              */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsq_mx_oc_qsz;

     /* VsqMxOcRfrsh: Maximum oiccupancy value refresh               */
     /* indication. Set whenever the maximum occupancy value/Qnum     */
     /* has been updated/changed. Auto-Clear.                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_mx_oc_rfrsh;

  } __ATTRIBUTE_PACKED__ vsq_maximum_occupancy0_reg;


  /* Vsq Maximum Occupancy1:                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x076c */

     /* VsqMxOcQnum: Holds the VSQ Q number to which the maximum     */
     /* occupancy value relates. The VSQ number is ther global       */
     /* number (0->355). Updated when VsqMxOcQsz is updated.         */
     /* range: 8:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsq_mx_oc_qnum;

     /* VsqMxOcBdsz: Presents the maximum occupancy level of the     */
     /* VSQ in BDs. Cleared when VsqMxOcQsz is read.                 */
     /* range: 30:9, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsq_mx_oc_bdsz;

  } __ATTRIBUTE_PACKED__ vsq_maximum_occupancy1_reg;


  /* Vsq Enqueue Packet Counter: VSQs programmable Counter          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x076d */

     /* VsqEnqPktCnt: Counts matched VSQs enqueued packets (does     */
     /* not include discarded packets). The counter counts           */
     /* according to Queue filtering settings                        */
     /* (VsqPrgCntQ,VsqPrgCntMsk). (Each event on a VSQ number       */
     /* matched by the filter is considered). This register is       */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsq_enq_pkt_cnt;

     /* VsqEnqPktCntOvf: VsqEnqPktCnt Overflow bit.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_enq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ vsq_enqueue_packet_counter_reg;


  /* Vsq Dequeue Packet Counter: VSQs programmable Counter          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x076e */

     /* VsqDeqPktCnt: Counts matched VSQs dequeued packets (does     */
     /* not include discarded packets). The counter counts           */
     /* according to Queue filtering settings                        */
     /* (VsqPrgCntQ,VsqPrgCntMsk). This register is clear on         */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsq_deq_pkt_cnt;

     /* VsqDeqPktCntOvf: VsqDeqPktCnt Overflow bit                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD vsq_deq_pkt_cnt_ovf;

  } __ATTRIBUTE_PACKED__ vsq_dequeue_packet_counter_reg;


  /* Qdc Tag Ctrl Dbg Sel: Select CACHE line for debug              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x076f */

     /* TagCtlDbgSel: Defines the TAG control line , in the IQM      */
     /* cache, to be monitorred. Both by mirror bus, and by          */
     /* QdcTagDbg status register                                    */
     /* range: 4:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tag_ctl_dbg_sel;

  } __ATTRIBUTE_PACKED__ qdc_tag_ctrl_dbg_sel_reg;


  /* Qdc Tag Ctrl Dbg: Present the selected TAG line controls       */
  /* from the QDC                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0770 */

     /* TagDbgFree: Line is free                                     */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tag_dbg_free;

     /* TagDbgLineV: Line valid                                      */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tag_dbg_line_v;

     /* TagDbgDirty: Line Dirty                                      */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tag_dbg_dirty;

     /* TagDbgUserCnt: User count                                    */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tag_dbg_user_cnt;

     /* TagDbgRdPnd: Read pending                                    */
     /* range: 11:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tag_dbg_rd_pnd;

     /* TagDbgQnum: Q number related to this line                    */
     /* range: 26:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tag_dbg_qnum;

  } __ATTRIBUTE_PACKED__ qdc_tag_ctrl_dbg_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_IQM_REGS;
/* Block definition: IPS */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0200 */

     /* DqcqDepthOvf: If set, then total depth configured to         */
     /* DQCQs is over 2432. This interrupt is cleared only after     */
     /* DQCQ depth is fixed.                                         */
     /* range: 0:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD dqcq_depth_ovf;

     /* EmptyDqcqWrite: if set, logic tried to write to a DQCQ       */
     /* with depth 0. This interrupt is cleared when EmptyDqcqId     */
     /* is read.                                                     */
     /* range: 1:1, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD empty_dqcq_write;

     /* QueueEnteredDel: A queue entered the delete state. This      */
     /* interrupt is cleared after DelQueueNumber register is        */
     /* read.                                                        */
     /* range: 2:2, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD queue_entered_del;

     /* CreditLost: The IPS might lose credit if one of the          */
     /* following situations occur: 1) when queue DQCQ is full,      */
     /* and a credit is received that triggers a write to full       */
     /* DQCQ- the credit is dropped. 2) when a credit is to be       */
     /* returned to the SCH, but the FMS is not ready, the           */
     /* credit is lost. Interrupt is cleared after                   */
     /* LostCreditQueueNum is read.                                  */
     /* range: 3:3, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD credit_lost;

     /* CreditOverflow: A queue's credit balance overflowed.         */
     /* credit received cause the credit balance to exceed           */
     /* (32K-1) credit bytes. If this happens, the credit            */
     /* balance wil become stuck at (32K-1). Interrupt is            */
     /* cleared after CreditOverflowQueueNum is read.                */
     /* range: 4:4, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD credit_overflow;

     /* SystemPortQueueSizeExpired: A system port's queue size       */
     /* has expired (no credit was received for this system port     */
     /* in the last SystemRedAgePeriod). Interrupt is cleared        */
     /* when ExpiredSystemPortId is read.                            */
     /* range: 5:5, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD system_port_queue_size_expired;

     /* FlwidEccErr: ECC error detected in flwid table               */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD flwid_ecc_err;

     /* QtypeEccErr: ECC error detected in qtype table               */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD qtype_ecc_err;

     /* QdescEccErr: ECC error detected in qdesc table               */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdesc_ecc_err;

     /* QszEccErr: ECC error detected in qsz table                   */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD qsz_ecc_err;

     /* FsmrqctrlEccErr: ECC error detected in fsmrqctrl table       */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrqctrl_ecc_err;

     /* DqcqmemEccErr: ECC error detected in dqcqmem table           */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcqmem_ecc_err;

     /* FsmrqmemEccErr: ECC error detected in fsmrqmem table         */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrqmem_ecc_err;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0210 */

     /* DqcqDepthOvfMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dqcq_depth_ovf_mask;

     /* EmptyDqcqWriteMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD empty_dqcq_write_mask;

     /* QueueEnteredDelMask: Writing 0 masks the corresponding       */
     /* interrupt source                                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD queue_entered_del_mask;

     /* CreditLostMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD credit_lost_mask;

     /* CreditOverflowMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD credit_overflow_mask;

     /* SystemPortQueueSizeExpiredMask: Writing 0 masks the          */
     /* corresponding interrupt source                               */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD system_port_queue_size_expired_mask;

     /* FlwidEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD flwid_ecc_err_mask;

     /* QtypeEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qtype_ecc_err_mask;

     /* QdescEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qdesc_ecc_err_mask;

     /* QszEccErrMask: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qsz_ecc_err_mask;

     /* FsmrqctrlEccErrMask: Writing 0 masks the corresponding       */
     /* interrupt source                                             */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrqctrl_ecc_err_mask;

     /* DqcqmemEccErrMask: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcqmem_ecc_err_mask;

     /* FsmrqmemEccErrMask: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrqmem_ecc_err_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0220 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0221 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0230 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0231 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;


  /* Indirect Command: Mesh mode selection. 1 for mesh mode,        */
  /* 0 for fabric mode                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0240 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically set          */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address-             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0241 */

     /* IndirectCommandAddr: Indirect access address- Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0:          */
     /* Write operation. 1: Read operation.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* ECC Configuration register: This register is used for          */
  /* configuring IPS ECC                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0260 */

     /* DisEcc: If set, disables the ECC mechanism in the block.     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_ecc;

  } __ATTRIBUTE_PACKED__ ecc_configuration_reg;


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg;
  

  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg;


  /* Ips General Configurations: General configurations and         */
  /* enables of the IPS                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0300 */

     /* DiscardAllIQMMsg: If set, the IPS discards all IQM           */
     /* reports (ENQ and DEQ).                                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD discard_all_iqmmsg;

     /* DiscardAllCrdt: If set, the IPS discards all incoming        */
     /* credits from FCR. Note: auto credits can still be            */
     /* processed                                                    */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD discard_all_crdt;

     /* DisableStatusMsgGen: If set, the IPS will not generate       */
     /* status messages towards the SCH.                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD disable_status_msg_gen;

     /* DisableCreditSurplus: If set, the IPS will not return        */
     /* unused credits to the originating port scheduler. NOTE:      */
     /* only full unused credits are returned.                       */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD disable_credit_surplus;

     /* DisSingleDelDeqCmd: If set, the IPS can send more than       */
     /* one delete DEQ command to the IQM. Otherwise, the IPS        */
     /* can send only one delete DEQ command to the IQM until a      */
     /* DEQ report is received.                                      */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_single_del_deq_cmd;

     /* FmcCreditsFromSch: If set, the IPS sends the FMC credits     */
     /* generated by it to be distributed by SCH. Otherwise, the     */
     /* IPS FMC credit generator distributes the credits to the      */
     /* relevant queues. If more than one queue is assigned to a     */
     /* FMC class, this bit should be asserted.                      */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fmc_credits_from_sch;

     /* DisOffSendAfterDeq: If set, the IPS will not send OFF        */
     /* message after a DEQ report when the credit balance is        */
     /* positive (next credit will). Otherwise, the IPS may send     */
     /* OFF messages after DEQ report processing if credit           */
     /* balance is still positive.                                   */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_off_send_after_deq;

     /* SendFsmOnCredit: If set, the IPS will send a flow status     */
     /* message for every credit received. Otherwise, flow           */
     /* status messages will be sent upon CRS change.                */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD send_fsm_on_credit;

     /* SendNoChgOnCredit: This is bit is valid only when            */
     /* SendFsmOnCredit is set. If set, the IPS will send a          */
     /* NO-CHANGE flow status message for every credit (unless a     */
     /* real flow status is needed). Otherwise, flow status          */
     /* messages with queue's current CRS will be sent. This is      */
     /* useful for systems using System RED feature.                 */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD send_no_chg_on_credit;

     /* SendFsmForBiggerMaxQueueSize: If set, the IPS will send      */
     /* a flow status message when the maximum queue size            */
     /* received on an incoming credit is smaller then the           */
     /* actual queue size should be reported for this queue.         */
     /* range: 9:9, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD send_fsm_for_bigger_max_queue_size;

     /* SendFsmForMulCrossDown: If set, the Ips will send a flow     */
     /* status message when queue size crosses FsmThMul down as      */
     /* well. Otherwise, messages will only be sent when queue       */
     /* size crosses FsmThMul up. This is useful for systems         */
     /* using System RED feature.                                    */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD send_fsm_for_mul_cross_down;

     /* UpdateMaxQszFromLocal: If set, and the 4b queue size         */
     /* from the IQM is bigger the the 4b queue size received        */
     /* from the SCH, the IPS will update the IQM value to the       */
     /* maximum queue size table; otherwise the SCH value will       */
     /* always be used.                                              */
     /* range: 11:11, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD update_max_qsz_from_local;

     /* DisAutoCreditSendMsg: If set, the IPS will not send flow     */
     /* status message to the SCH after an auto credit               */
     /* processing.                                                  */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dis_auto_credit_send_msg;

     /* EnIntLpDqcqFc: if set, the internal low prioirty DQCQ        */
     /* flow control is enabled. When a HP priority queue size       */
     /* crosses IntLpDqcqFcSetTh, a flow control bit asserted        */
     /* preventing DEQ commands for low priority queues from         */
     /* being sent, until IntLpDqcqFcResetTh is crossed down by      */
     /* the asserting queue.                                         */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD en_int_lp_dqcq_fc;

     /* DisDeqCmds: if set, the IPS will not send DEQ commands.      */
     /* NOTE: this should be used for debug purposes only!           */
     /* range: 14:14, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD dis_deq_cmds;

     /* IpsCountByTimer: if set, all applicable counters will        */
     /* count when timer is active. Otherwise, counters always       */
     /* count, unless defined otherwise.                             */
     /* range: 27:27, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ips_count_by_timer;

     /* IpsInitTrigger: When IpsInit==1, the IPS performs its        */
     /* 32K cycles initialization. The IPS init is triggered by      */
     /* a signal from ECI (IPS INIT). All IPS logic is reset,        */
     /* except for the configuration registers and static            */
     /* tables. Tables initialized: - Queue descriptor table -       */
     /* Queue size table - Fsmrq Control table memory - System       */
     /* RED maximum queue size table                                 */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ips_init_trigger;

  } __ATTRIBUTE_PACKED__ ips_general_configurations_reg;


  /* Ips Credit Config: General configurations and enables of       */
  /* the IPS                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0301 */

     /* CreditValue: Credit Value in 1B resolution.                  */
     /* range: 12:0, access type: RW, default value: 0x200           */
     SOC_PETRA_REG_FIELD credit_value;

     /* Resereved: Must be set to 0.                                 */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD resereved;

  } __ATTRIBUTE_PACKED__ ips_credit_config_reg;


  /* Auto Credit Mechanism Queue Boundaries: This registers         */
  /* contains the needed configurations for the auto credit         */
  /* mechanism.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0304 */

     /* AutoCrFrstQue: The number of the first queue (in a           */
     /* continuous cyclic segment of queues) to generate an auto     */
     /* credit                                                       */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD auto_cr_frst_que;

     /* AutoCrLastQue: The number of the last queue (in a            */
     /* continuous cyclic segment of queues) to generate an auto     */
     /* credit                                                       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD auto_cr_last_que;

  } __ATTRIBUTE_PACKED__ auto_credit_mechanism_queue_boundaries_reg;


  /* Auto Credit Mechanism Rate Configuration:                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0305 */

     /* AutoCrRate: Determine the rate (in FAP core clocks) of       */
     /* generating auto credits to 1<<(AutoCrRate+3). A value of     */
     /* 0 disables the Auto generation.                              */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD auto_cr_rate;

  } __ATTRIBUTE_PACKED__ auto_credit_mechanism_rate_configuration_reg;


  /* High Priority Dqcq Depth Config1: Sets the FIFO depth          */
  /* for the DQCQs. Note: total for all DQCQs should not             */
  /* exceed 2432. In Mesh mode, we have 3 HPs and 8 LPs,            */
  /* while in Fabric mode we have 4 HPs and 3 LPs.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0306 */

     /* DelDepth: FIFO depth for Delete DQCQ                         */
     /* range: 11:0, access type: RW, default value: 0x80            */
     SOC_PETRA_REG_FIELD del_depth;

     /* IsDepth: FIFO depth for Ingress shape DQCQ                   */
     /* range: 27:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD is_depth;

  } __ATTRIBUTE_PACKED__ high_priority_dqcq_depth_config1_reg;


  /* High Priority Dqcq Depth Config2: Sets the FIFO depth          */
  /* for the DQCQs. Note: total for all DQCQs should not             */
  /* exceed 2432. In Mesh mode, we have 3 HPs and 8 LPs,            */
  /* while in Fabric mode we have 4 HPs and 3 LPs.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0307 */

     /* LowDelayDepth: FIFO depth for low delay DQCQ                 */
     /* range: 11:0, access type: RW, default value: 0x80            */
     SOC_PETRA_REG_FIELD low_delay_depth;

  } __ATTRIBUTE_PACKED__ high_priority_dqcq_depth_config2_reg;


  /* Low Priority Dqcq Depth Config1: Sets the FIFO depth for       */
  /* the DQCQs. Note: total for all DQCQs should not exceed          */
  /* 2432. In Mesh mode, we have 3 HPs and 8 LPs, while in          */
  /* Fabric mode we have 4 HPs and 3 LPs.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0308 */

     /* Dest0Depth: FIFO depth for DQCQ of destination 0 in mesh     */
     /* mode. In Clos fabric mode, this is Local route DQCQ          */
     /* range: 11:0, access type: RW, default value: 0x100           */
     SOC_PETRA_REG_FIELD dest0_depth;

     /* Dest1Depth: FIFO depth for DQCQ of destination 1 in mesh     */
     /* mode. In Clos fabric mode, this is guaranteed fabric         */
     /* multicast DQCQ.                                              */
     /* range: 27:16, access type: RW, default value: 0x100          */
     SOC_PETRA_REG_FIELD dest1_depth;

  } __ATTRIBUTE_PACKED__ low_priority_dqcq_depth_config1_reg;


  /* Low Priority Dqcq Depth Config2: Sets the FIFO depth for       */
  /* the DQCQs. Note: total for all DQCQs should not exceed          */
  /* 2432. In Mesh mode, we have 3 HPs and 8 LPs, while in          */
  /* Fabric mode we have 4 HPs and 3 LPs.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0309 */

     /* Dest2Depth: FIFO depth for DQCQ of destination 2 in mesh     */
     /* mode. In Clos fabric mode, this is best effort fabric        */
     /* multicast DQCQ.                                              */
     /* range: 11:0, access type: RW, default value: 0x100           */
     SOC_PETRA_REG_FIELD dest2_depth;

     /* Dest3Depth: FIFO depth for DQCQ of destination 3 in mesh     */
     /* mode. In Clos fabric mode, this is fabric (other             */
     /* destinations) DQCQ.                                          */
     /* range: 27:16, access type: RW, default value: 0x100          */
     SOC_PETRA_REG_FIELD dest3_depth;

  } __ATTRIBUTE_PACKED__ low_priority_dqcq_depth_config2_reg;


  /* Low Priority Dqcq Depth Config3: Sets the FIFO depth for       */
  /* the DQCQs. Note: total for all DQCQs should not exceed          */
  /* 2432. In Mesh mode, we have 3 HPs and 8 LPs, while in          */
  /* Fabric mode we have 4 HPs and 3 LPs.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030a */

     /* Dest4Depth: FIFO depth for DQCQ of destination 4 in mesh     */
     /* mode.                                                        */
     /* range: 11:0, access type: RW, default value: 0x100           */
     SOC_PETRA_REG_FIELD dest4_depth;

     /* Dest5Depth: FIFO depth for DQCQ of destination 5 in mesh     */
     /* mode.                                                        */
     /* range: 27:16, access type: RW, default value: 0x100          */
     SOC_PETRA_REG_FIELD dest5_depth;

  } __ATTRIBUTE_PACKED__ low_priority_dqcq_depth_config3_reg;


  /* Low Priority Dqcq Depth Config4: Sets the FIFO depth for       */
  /* the DQCQs. Note: total for all DQCQs should not exceed          */
  /* 2432. In Mesh mode, we have 3 HPs and 8 LPs, while in          */
  /* Fabric mode we have 4 HPs and 3 LPs.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030b */

     /* Dest6Depth: FIFO depth for DQCQ of destination 6 in mesh     */
     /* mode.                                                        */
     /* range: 11:0, access type: RW, default value: 0x100           */
     SOC_PETRA_REG_FIELD dest6_depth;

     /* Dest7Depth: FIFO depth for DQCQ of destination 7 in mesh     */
     /* mode.                                                        */
     /* range: 27:16, access type: RW, default value: `IPS_DEPTH7    */
     SOC_PETRA_REG_FIELD dest7_depth;

  } __ATTRIBUTE_PACKED__ low_priority_dqcq_depth_config4_reg;


  /* Credit Flow Control Threshold: When an Ingress Shape or        */
  /* Fabric MC DQCQ is over a configured threshold, a credit        */
  /* flow-control indication is sent to relevant credit             */
  /* generator. The flow control is released when the DQCQ is       */
  /* below the reset threshold.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030c */

     /* CrdtFcSet: When DQCQ crosses this threshold from above,      */
     /* credit flow control is set.                                  */
     /* range: 11:0, access type: RW, default value: 0x80            */
     SOC_PETRA_REG_FIELD crdt_fc_set;

     /* CrdtFcReset: When DQCQ crosses this threshold from           */
     /* below, credit flow control is reset.                         */
     /* range: 27:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD crdt_fc_reset;

  } __ATTRIBUTE_PACKED__ credit_flow_control_threshold_reg;


  /* Ipt High-Priority Flow-Control Mask: The IPT sends the         */
  /* IPS flow control per context, per high and low priority.       */
  /* The IPS has only one high priority DQCQ, so all the            */
  /* flow-control bits are ORed, and masked by this register.       */
  /* A de-asserted bit masks the relevant flow control. NOTE:        */
  /* In Clos fabric mode, only the lower two bits are used.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030d */

     /* IptFcMask: One bit per high priority context in the IPT.     */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ipt_fc_mask;

  } __ATTRIBUTE_PACKED__ ipt_high_priority_flow_control_mask_reg;


  /* Fmc Scheduler Configs: Controls the overall rate               */
  /* generated for the FMC (Fabric MultiCast) queues                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030e */

     /* FmcMaxCrRate: The FMC credit generator generates credit      */
     /* every ((FmcMaxCrRate+102) /8) clocks. Value of 0             */
     /* disables the generator.                                      */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fmc_max_cr_rate;

     /* FmcMaxBurst: The maximum number of credits the generator     */
     /* can hold.                                                    */
     /* range: 31:26, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fmc_max_burst;

  } __ATTRIBUTE_PACKED__ fmc_scheduler_configs_reg;


  /* Gfmc Shaper Configs: Controls the credit shaper for GFMC       */
  /* (Guaranteed FMC). When IPS distributes the credits, queue       */
  /* 0 is the GFMC queue (class 0).                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x030f */

     /* GfmcMaxCrRate: The maximum gap between 2 GMFC credits is     */
     /* ((GfmcMaxCrRate+102) /8) clocks. Value of 0 disables the     */
     /* shaper (credits may still be sent to GFMC according to       */
     /* strict priority over BFMC).                                  */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD gfmc_max_cr_rate;

     /* GfmcMaxBurst: The maximum number of credits the              */
     /* generator can hold when GFMC credits are not needed.         */
     /* range: 31:26, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD gfmc_max_burst;

  } __ATTRIBUTE_PACKED__ gfmc_shaper_configs_reg;


  /* Bfmc Shaper Configs: Controls the credit shaper for BFMC       */
  /* (Best-effort FMC). When IPS distributes the credits,            */
  /* queue 1-3 is are BFMC queues (class 1 is assoicated with       */
  /* queue 1 and so on).                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0310 */

     /* BfmcMaxCrRate: The maximum gap between 2 BMFC credits is     */
     /* (BfmcMaxCrRate+102) 1/8th clocks. Value of 0 disables        */
     /* the shaper (credits may still be sent to BFMC).              */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bfmc_max_cr_rate;

     /* BfmcMaxBurst: The maximum number of credits the              */
     /* generator can hold when BFMC credits are not needed.         */
     /* range: 31:26, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD bfmc_max_burst;

  } __ATTRIBUTE_PACKED__ bfmc_shaper_configs_reg;


  /* Bfmc Class Configs: Controls the distribution of credits       */
  /* between BFMC classes. Weight configurations:* Lower value       */
  /* means better priority, 1 is the highest priority.* A           */
  /* class rate is distributed according                            */
  /* to:(1/Wx)/((1/W1)+(1/W2)+(1/W3))* Value of 0 to any of         */
  /* the weight disables the relevent class from receiving          */
  /* credits.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0311 */

    /* BFMC class 2 weight for WFQ                                  */
    /* BFMC class 3 weight for WFQ                                  */
    /* BFMC class 4 weight for WFQ                                  */
    /* range: 4:0, access type: RW, default value: 0x0              */
    /* range: 12:8, access type: RW, default value: 0x0             */
    /* range: 20:16, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD bfmc_class_w[SOC_PETRA_NOF_MULTICAST_CLASSES - 1];

    /* If set, credits for BFMC are distributed according to        */
    /* WFQ; Otherwise, according to SP by class.                    */
    /* range: 31:31, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD bfmc_wfq_en;

  } __ATTRIBUTE_PACKED__ bfmc_class_configs_reg;


  /* Ingress Shape Scheduler Config: Controls the rate for          */
  /* Ingress shape credits. NOTE: Ingress Shape credit are          */
  /* distributed by the SCH.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0312 */

     /* IssMaxCrRate: The IS credit generator generates credit       */
     /* every ( (IssMaxCrRate+102) /8) clocks. Value of 0            */
     /* disables the generator.                                      */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD iss_max_cr_rate;

  } __ATTRIBUTE_PACKED__ ingress_shape_scheduler_config_reg;


  /* Credit Watchdog Queue Boundaries: Queue boundaries to be       */
  /* scanned by a credit watch dog. The watchdog scans              */
  /* between the bottom queue and top queue in cyclic manner,       */
  /* at a minimum rate.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0313 */

     /* CrWdBottomQ: Bottom queue for credit watchdog                */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cr_wd_bottom_q;

     /* CrWdTopQ: Top queue for credit watchdog                      */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cr_wd_top_q;

  } __ATTRIBUTE_PACKED__ credit_watchdog_queue_boundaries_reg;


  /* Credit Watchdog Configuration: This registers holds            */
  /* credit watchdog configurations, rate and message               */
  /* generation control. The credit watchdog has a given             */
  /* minimum scan rate between the top and bottom queues. The       */
  /* scan time can be longer if the watchdog access is              */
  /* restrained by other events. If many queues needs to be         */
  /* serviced by the credit watchdog, then it is restrained         */
  /* by it's own flow status generation limit.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0314 */

     /* CrWdMaxFlowMsgGenRate: Defines the period in clocks in       */
     /* which a token bucket is incremented. '0' disables the        */
     /* shaper mechanism, meaning the credit watchdog may send       */
     /* as many messages as it can.                                  */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cr_wd_max_flow_msg_gen_rate;

     /* CrWdMaxFlowMsgGenBurstSize: The maximum size of the          */
     /* token bucket.                                                */
     /* range: 15:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD cr_wd_max_flow_msg_gen_burst_size;

     /* CrWdMinScanCyclePeriod: The minimum number of clocks         */
     /* that must elapse between full scans, in clocks, is           */
     /* CrWDMinScanCyclePeriod * 256. Value of 0 disables the        */
     /* watchdog.                                                    */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cr_wd_min_scan_cycle_period;

     /* CrWdGenOffMsgs: If set, credit watchdog will generate        */
     /* OFF messages for queues; Otherwise, the credit watchdog      */
     /* will only generate ON (SLOW and NORM) messages.              */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cr_wd_gen_off_msgs;

  } __ATTRIBUTE_PACKED__ credit_watchdog_configuration_reg;


  /* Fsm On Message Shaper: This register controls the rate         */
  /* limit shaper for ON messages (SLOW and NORM) from the          */
  /* FSRMQ.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0315 */

     /* FsmMaxRate: The number of clocks passed between two          */
     /* consecutive ON messages. Value of '0' disables the rate      */
     /* limiting shaper.                                             */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsm_max_rate;

     /* FsmMaxBurst: The maximum number of consecutive messages      */
     /* (burst) allowed.                                             */
     /* range: 20:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fsm_max_burst;

     /* ShaperLowPri: If set, the shaper works on low priority       */
     /* FSMRQ alone; Otherwise, the shaper limits both high and      */
     /* low priority.                                                */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD shaper_low_pri;

  } __ATTRIBUTE_PACKED__ fsm_on_message_shaper_reg;


  /* Fms Parameters: Set of parameters to control the flow          */
  /* message shaper behaviour                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0316 */

     /* bypassShaper: If set, no messages will be delayed in the     */
     /* FMS.                                                         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bypass_shaper;

     /* DisableSlowDelay: If set, the FMS will not delay NORM        */
     /* after SLOW messages.                                         */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD disable_slow_delay;

     /* LocalRouteBypass: If set, local route messages will          */
     /* bypass the FMS.                                              */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD local_route_bypass;

     /* MinDly: The minimum allowable amount of FMS time clock       */
     /* units (64 core clocks, ~256ns at 250MHz clock) between       */
     /* OFF->ON and SLOW->NORM messages. Default is 8 (~2048ns).     */
     /* range: 8:4, access type: RW, default value: 0x2              */
     SOC_PETRA_REG_FIELD min_dly;

     /* TimeScale: The FMS internal clock in core clocks units.      */
     /* 00 - 64 core clocks. 01 - 128 core clocks. 10 - 192 core     */
     /* clocks. 11 - 256 core clocks.                                */
     /* range: 13:12, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD time_scale;

  } __ATTRIBUTE_PACKED__ fms_parameters_reg;


  /* System Red Aging Configuration: Configures the aging           */
  /* period for system RED maximum queue size. When the             */
  /* maximum queue size for a specific port is aged, it is          */
  /* reset to 0, and the IQM will accept all packets. A value       */
  /* of 0 disables the aging mechanism (only incoming credits       */
  /* will update the table).                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0317 */

     /* SystemRedAgePeriod: Configures the aging period in 16k       */
     /* clocks units. Default value is ~0.5 seconds.                 */
     /* range: 13:0, access type: RW, default value: 0x1e84          */
     SOC_PETRA_REG_FIELD system_red_age_period;

  } __ATTRIBUTE_PACKED__ system_red_aging_configuration_reg;


  /* Interdigitated Mode: Selects (in 1K queue regions) to          */
  /* map queue to flow in an interdigitated manner. NOTE: base       */
  /* flow for these queues should be >6144 (flows > 24K).           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0318 */

     /* InterdigitatedMode: Each bit corresponds to a 1K queue       */
     /* region. If bit n is set, queues 1024n to (1024(n+1)-1)       */
     /* are mapped according to: flow_id= SubFlowMode ?              */
     /* \{Base_flow[13:2],qnum[1:0],2'b10\} : \{base_flow[13:1],     */
     /* qnum[1], 1'b1, qnum[0]\} otherwise, queues are mapped        */
     /* according to: flow_id= SubFlowMode ?                         */
     /* \{Base_flow[13:1],qnum[1:0],1'b0\} : \{base_flow[13:0],      */
     /* qnum[1:0]\}                                                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD interdigitated_mode;

  } __ATTRIBUTE_PACKED__ interdigitated_mode_reg;


  /* Int Lp Dqcq Fc Config: Configures the relevant                 */
  /* thresholds for internal low priority DQCQ flow                 */
  /* control. Thrshold is given in 16B resolution.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0319 */

     /* IntLpDqcqFcSetTh: when crossed up and internal flow          */
     /* control is enabled, low priority DQCQ flow contorl is        */
     /* asserted.                                                    */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD int_lp_dqcq_fc_set_th;

     /* IntLpDqcqFcResetTh: when crossed down and internal flow      */
     /* control is asserted, low priority DQCQ flow contorl is       */
     /* cleared.                                                     */
     /* range: 29:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD int_lp_dqcq_fc_reset_th;

  } __ATTRIBUTE_PACKED__ int_lp_dqcq_fc_config_reg;


  /* Stored Credits Usage Configuration: The following              */
  /* register configures the usage of stored credits by the         */
  /* IPS. Stored credits are used when a new packet is               */
  /* received to a queue with credit balance bigger then the        */
  /* queue size, and the CRS is still OFF.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x031a */

     /* MulPktDeq: One bit per IPS queue type. If the relevant       */
     /* bit is set, the IPS may send up to MulPktDeqBytes on a       */
     /* DEQ command for queue using the stored credits.              */
     /* Otherwise only a single packet is allowed to be sent         */
     /* when using stored credits.                                   */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mul_pkt_deq;

     /* MulPktDeqBytes: The value, in 64B resolution, of the         */
     /* command bytes to send on a DEQ command for a queue using     */
     /* stored credits and it's queue type MulPktDeq bit is set.     */
     /* A value of 0 means only a single packet is allowed to be     */
     /* sent.                                                        */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mul_pkt_deq_bytes;

  } __ATTRIBUTE_PACKED__ stored_credits_usage_configuration_reg;


  /* Del Queue Number: Holds the queue number and last credit       */
  /* time of last queue that entered the delete state, and          */
  /* the current credit WD time.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0340 */

     /* DelQueueNum: Delete queue number. This register is clear     */
     /* on read.                                                     */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD del_queue_num;

     /* QueueLastCrTime: Last credit watch cycle a credit was        */
     /* received.                                                    */
     /* range: 20:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD queue_last_cr_time;

     /* CurrentWdTime: Current credit watch cycle.                   */
     /* range: 28:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD current_wd_time;

  } __ATTRIBUTE_PACKED__ del_queue_number_reg;


  /* Lost Credit Queue Number: Holds the queue number of the        */
  /* lost credit and queue's DQCQ ID.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0341 */

     /* LostCrQueueNum: Lost credit's queue number. This             */
     /* register is clear on read.                                   */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lost_cr_queue_num;

     /* DqcqId: The relevant DQCQ ID.                                */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_id;

     /* DqcqNrdy: DQCQ was not ready.                                */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_nrdy;

     /* FmsNrdy: FMS was not ready.                                  */
     /* range: 24:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fms_nrdy;

  } __ATTRIBUTE_PACKED__ lost_credit_queue_number_reg;


  /* Credit Overflow Queue Num: Holds the queue number of the       */
  /* queue with an overfloed credit balance.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0342 */

     /* CreditOverflowQueueNum: Holds the queue number of the        */
     /* queue with an overfloed credit balance. This register is     */
     /* clear on read.                                               */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD credit_overflow_queue_num;

  } __ATTRIBUTE_PACKED__ credit_overflow_queue_num_reg;


  /* Expired System Port Id: System physical port ID where          */
  /* the maximum queue size has expired (associated with            */
  /* interrupt 4).                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0343 */

     /* ExpiredSystemPortId: System physical port ID where the       */
     /* maximum queue size has expired (associated with              */
     /* interrupt 4). This register is clear on read.                */
     /* range: 11:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD expired_system_port_id;

  } __ATTRIBUTE_PACKED__ expired_system_port_id_reg;


  /* Empty Dqcq Id: Holds the empty (depth=0) DQCQ the logic        */
  /* tried to write to. Valid only when EmptyDqcqWrite               */
  /* interrupt is asserted.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0344 */

     /* EmptyDqcqId: Holds the empty (depth=0) DQCQ the logic        */
     /* tried to write to. Valid only when EmptyDqcqWrite            */
     /* interrupt is asserted. This register is clear on read.       */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD empty_dqcq_id;

  } __ATTRIBUTE_PACKED__ empty_dqcq_id_reg;


  /* Manual Queue Operation: Valid only when EmptyDqcqWrite         */
  /* interrupt is asserted.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0380 */

     /* ManQueueId: Queue number to perform manual operation on.     */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD man_queue_id;

     /* DeqCmdCr2send: Valid for send packet trigger. Number of      */
     /* bytes to send from the queue, in 64B units. The actual       */
     /* amount of data that will be sent is rounded up to fit a      */
     /* full packet size (of the last packet sent). Value of 0       */
     /* triggers a single packet.                                    */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_cmd_cr2send;

     /* FsValue: Valid for FsTrigger only. If FsOverride is          */
     /* asserted, then the value of the flow status sent after       */
     /* FsTrigger will be FsValue.                                   */
     /* range: 25:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_value;

     /* FsOverride: If set, the value of the flow status sent        */
     /* after FsTrigger will be FsValue. Otherwise, queue's          */
     /* current CRS will be used.                                    */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_override;

     /* DelDqcq: Valid for send packet trigger and flush             */
     /* trigger. If set, queue will be added to delete DQCQ.         */
     /* Otherwise, queue will be added to it's defined DQCQ.         */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD del_dqcq;

     /* FsTrigger: If set, a flow status message will be             */
     /* triggered for ManQueueId, with respect to flow status        */
     /* configuration. The IPS will de-assert this bit once it's     */
     /* ready for another trigger.                                   */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_trigger;

     /* GrantCredit: If set, a single credit will be given to        */
     /* ManQueueId. When the IPS is ready for another trigger,       */
     /* this bit will be negated.                                    */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD grant_credit;

     /* FlushTrigger: If set, a queue flush is triggered. If         */
     /* DelDqcq set, the queue will enter delete mode, and will      */
     /* exit only when queue emptied, or credit arived for the       */
     /* queue. Otherwise, the queue will start sending data to       */
     /* it's destination, until queue emptied or this bit is         */
     /* cleared by the user. The IPS will de-assert the bit when     */
     /* it is ready to enter another queue to flush.                 */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flush_trigger;

     /* SendPktTrigger: If set, a packet send is triggered. When     */
     /* the IPS is ready for another trigger, this bit will be       */
     /* negated.                                                     */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD send_pkt_trigger;

  } __ATTRIBUTE_PACKED__ manual_queue_operation_reg;


  /* Timer Configuration: Holds the timer configuration for         */
  /* all IPS counters.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0381 */

     /* TimeCountConfig: time period in clock periods that all       */
     /* the counters count. when using this timer, the overflow      */
     /* bit of each counter indicate the end of the time count.      */
     /* The default value is 1sec with 250Mhz core clock.            */
     /* range: 30:0, access type: RW, default value: `IPS_TIMER_CFG  */
     SOC_PETRA_REG_FIELD time_count_config;

     /* CounterReset: If set, all related counters will reset        */
     /* upon activation of timer. Otherwise, counters will           */
     /* preserve old values.                                         */
     /* range: 31:31, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD counter_reset;

  } __ATTRIBUTE_PACKED__ timer_configuration_reg;


  /* Activate Timer: Start counters that count with timer.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0382 */

     /* ActivateTimer: Start counters that count with timer.         */
     /* Once time expired, this bit will be cleared.                 */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD activate_timer;

  } __ATTRIBUTE_PACKED__ activate_timer_reg;


  /* Queue Num Filter: Filter for counters according to queue       */
  /* number.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0383 */

     /* QueueNumFilter: Queue number to filter by. All the           */
     /* applicable counter will count according to:                  */
     /* (event_q_num|QueueNumFilterMask) ==                          */
     /* (QueueNumFilter|QueueNumFilterMask)                          */
     /* range: 14:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD queue_num_filter;

     /* QueueNumFilterMask: As described above.                      */
     /* range: 30:16, access type: RW, default value: 0x7fff         */
     SOC_PETRA_REG_FIELD queue_num_filter_mask;

  } __ATTRIBUTE_PACKED__ queue_num_filter_reg;


  /* Flow Status Filter: Filter for counters according to           */
  /* flow status fields.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0384 */

     /* FsDestPortId: Destination port ID to filter by.              */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fs_dest_port_id;

     /* FsDestDevId: Destination device ID to filter by.             */
     /* range: 18:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fs_dest_dev_id;

     /* FlowStatusFilter: Flow status to filter by.                  */
     /* range: 22:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flow_status_filter;

  } __ATTRIBUTE_PACKED__ flow_status_filter_reg;


  /* Flow Status Filter Mask: Mask for flow status Filter           */
  /* fields.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0385 */

     /* FsDestPortIdMask: Destination port ID to filter by.          */
     /* range: 7:0, access type: RW, default value: 0xff             */
     SOC_PETRA_REG_FIELD fs_dest_port_id_mask;

     /* FsDestDevIdMask: Destination device ID to filter by.         */
     /* range: 18:8, access type: RW, default value: 0x7ff           */
     SOC_PETRA_REG_FIELD fs_dest_dev_id_mask;

     /* FlowStatusFilterMask: Flow status to filter by.              */
     /* range: 22:20, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD flow_status_filter_mask;

  } __ATTRIBUTE_PACKED__ flow_status_filter_mask_reg;


  /* Iqm Report Filter: Filter for counters according to IQM        */
  /* report fields.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0386 */

     /* DeqNotEnqFltr: filter by deq_not_enq bit.                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD deq_not_enq_fltr;

     /* DiscardFltr: filter by discard bit.                          */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD discard_fltr;

     /* WqupFltr: filter by wqup bit.                                */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wqup_fltr;

     /* DeqNotEnqFltrMask: mask filter by deq_not_enq bit.           */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD deq_not_enq_fltr_mask;

     /* DiscardFltrMask: mask filter by discard bit.                 */
     /* range: 5:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD discard_fltr_mask;

     /* WqupFltrMask: mask filter by wqup bit.                       */
     /* range: 6:6, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD wqup_fltr_mask;

  } __ATTRIBUTE_PACKED__ iqm_report_filter_reg;


  /* Dqcq Id Filter: Filter by DEQ command variables for DQCQ       */
  /* counters.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0387 */

     /* DqcqIdFilter: Filter by DQCQ ID.                             */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dqcq_id_filter;

     /* DqcqDestPortFilter: Filter by DEQ command destiantion        */
     /* port.                                                        */
     /* range: 11:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dqcq_dest_port_filter;

     /* DqcqDestDevFilter: Filter by DEQ command destiantion         */
     /* device.                                                      */
     /* range: 22:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_dest_dev_filter;

     /* DqcqIdFilterEn: Enable filtering by DQCQ ID.                 */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_id_filter_en;

     /* DqcqDestPortFilterEn: Enable filtering by DEQ command        */
     /* destiantion port.                                            */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_dest_port_filter_en;

     /* DqcqDestDevFilterEn: Enable filtering by DEQ command         */
     /* destiantion device.                                          */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dqcq_dest_dev_filter_en;

  } __ATTRIBUTE_PACKED__ dqcq_id_filter_reg;


  /* Fsmrq Max Occupancy: Holds the maximum occupancy in            */
  /* FSMRQ (low priority and high priority)                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a0 */

     /* LpFsmrqMaxOcc: Low-priority fsmrq maximum occupancy.         */
     /* This register is clear on read.                              */
     /* range: 10:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lp_fsmrq_max_occ;

     /* HpFsmrqMaxOcc: High-priority fsmrq maximum occupancy.        */
     /* range: 23:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD hp_fsmrq_max_occ;

  } __ATTRIBUTE_PACKED__ fsmrq_max_occupancy_reg;


  /* Dqcq Max Occupancy Hp: Holds the maximum occupancy in          */
  /* DQCQ (low priority and high priority), and the relevant        */
  /* DQCQ id                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a1 */

     /* HpDqcqMaxOcc: High-priority dqcq maximum occupancy. This     */
     /* register is clear on read.                                   */
     /* range: 11:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD hp_dqcq_max_occ;

     /* HpDqcqMaxOccId: High-priority dqcq maximum occupancy ID.     */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD hp_dqcq_max_occ_id;

  } __ATTRIBUTE_PACKED__ dqcq_max_occupancy_hp_reg;


  /* Dqcq Max Occupancy Lp: Holds the maximum occupancy in          */
  /* DQCQ (low priority and high priority), and the relevant        */
  /* DQCQ id                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a2 */

     /* LpDqcqMaxOcc: Low-priority dqcq maximum occupancy. This      */
     /* register is clear on read.                                   */
     /* range: 11:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lp_dqcq_max_occ;

     /* LpDqcqMaxOccId: Low-priority dqcq maximum occupancy ID.      */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD lp_dqcq_max_occ_id;

  } __ATTRIBUTE_PACKED__ dqcq_max_occupancy_lp_reg;


  /* Active Queue Count: Holds the number of queues with            */
  /* queue size>0                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a3 */

     /* MaxActiveQueueCount: Maximum active queue count (since       */
     /* last read). This register is clear on read.                  */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD max_active_queue_count;

     /* ActiveQueueCount: Instantaneous active queue count.          */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD active_queue_count;

  } __ATTRIBUTE_PACKED__ active_queue_count_reg;


  /* Fms Max Occupancy: Holds the maximum number of bins            */
  /* occupied in the FMS.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a4 */

     /* FmsMaxOccupancy: Last maximum value reached since last       */
     /* read. This register is clear on read.                        */
     /* range: 7:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fms_max_occupancy;

  } __ATTRIBUTE_PACKED__ fms_max_occupancy_reg;


  /* Int Lp Dqcq Fc Status: Holds the status of the internal        */
  /* low priority DQCQ flow control.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a5 */

     /* LpDqcqQueueId: The queue ID of the high priority queue       */
     /* which asserted the flow control.                             */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lp_dqcq_queue_id;

     /* LpDqcqQueueSize: The last reported queue size for the        */
     /* queue, in 16B resolution.                                    */
     /* range: 29:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD lp_dqcq_queue_size;

     /* LpDqcqFlowControl: The flow control state.                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD lp_dqcq_flow_control;

  } __ATTRIBUTE_PACKED__ int_lp_dqcq_fc_status_reg;


  /* Fsmrq Delay Counter: Holds the longest delay in clock          */
  /* units found through FSMRQ. Can test for all queues, or by       */
  /* filter. Data is reset when read, hence a new test will         */
  /* be initiated.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a6 */

     /* FsmrqDelayCounter: This register is clear on read.           */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsmrq_delay_counter;

     /* FsmrqDelayQueue: Queue to test delay for.                    */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrq_delay_queue;

     /* FsmrqDelayByQueue: If set, delay test will be for            */
     /* FsmrqDelayQueue only. Otherwise, the mechanism will test     */
     /* for queues entering FSMRQ randomly.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrq_delay_by_queue;

  } __ATTRIBUTE_PACKED__ fsmrq_delay_counter_reg;


  /* Fms Delay Counter: Holds the longest delay in clock            */
  /* units found through FMS. Can test for all queues, or by         */
  /* filter. Data is reset when read, hence a new test will         */
  /* be initiated.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a7 */

     /* FmsDelayCounter: This register is clear on read.             */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fms_delay_counter;

     /* FmsDelayQueue: Queue to test delay for.                      */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fms_delay_queue;

     /* FmsDelayByQueue: If set, delay test will be for              */
     /* FsmrqDelayQueue only. Otherwise, the mechanism will test     */
     /* for queues entering FSMRQ randomly.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fms_delay_by_queue;

  } __ATTRIBUTE_PACKED__ fms_delay_counter_reg;


  /* Credit Fabric Latency Counter: Holds the longest delay         */
  /* in clock units found between an ON message sent for            */
  /* queue, and a credit received for the queue.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a8 */

     /* CrLtncyCounter: This register is clear on read.              */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cr_ltncy_counter;

     /* CrLtncyQue: Queue to test delay for.                         */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cr_ltncy_que;

  } __ATTRIBUTE_PACKED__ credit_fabric_latency_counter_reg;


  /* Flow Control Count Select: This registers selects the          */
  /* input for the flow control counter.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03a9 */

     /* FcCountSel: 0-15: IPT context flow control 16-19: IPT        */
     /* FMC flow control 20-21: DQCQ FMC flow control 22: DQCQ       */
     /* IS flow control 23: IPS internal LP DQCQ flow control        */
     /* 24: IRR IS flow control                                      */
     /* range: 4:0, access type: RW, default value: 0x19             */
     SOC_PETRA_REG_FIELD fc_count_sel;

  } __ATTRIBUTE_PACKED__ flow_control_count_select_reg;


  /* Capture Queue Descriptor Config: This register                 */
  /* configures the capturing of a queue desciptor. Capturing        */
  /* is always done for a queue defined in the QueueNumFilter       */
  /* (without mask), and according to other configure values        */
  /* in this register. The logic capture the first queue             */
  /* descriptor after the read of the capture register.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03aa */

     /* CaptureCrs: Capture by CRS.                                  */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_crs;

     /* CaptureCrsEn: Enable capturing by CRS.                       */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_crs_en;

     /* CaptureFsmrqCtrl: Capture by FSMRQ control.                  */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_fsmrq_ctrl;

     /* CaptureFsmrqCtrlEn: Enable capturing by FSMRQ control.       */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_fsmrq_ctrl_en;

     /* CaptureInDqcq: Capture by DQCQ.                              */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_in_dqcq;

     /* CaptureInDqcqEn: Enable capturing by DQCQ.                   */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD capture_in_dqcq_en;

     /* CaptureWdDel: Capture by WdDel.                              */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD capture_wd_del;

     /* CaptureWdDelEn: Enable capturing by WdDel.                   */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD capture_wd_del_en;

     /* CaptureOnePktDeq: Capture by One-Pkt-Deq.                    */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD capture_one_pkt_deq;

     /* CaptureOnePktDeqEn: Enable capturing by One-Pkt-Deq.         */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD capture_one_pkt_deq_en;

  } __ATTRIBUTE_PACKED__ capture_queue_descriptor_config_reg;


  /* Capture Queue Descriptor: This register holds the first        */
  /* captured queue descriptor values.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b0 */

     /* CptrdCrBal: Captured credit balance This register is         */
     /* clear on read.                                               */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cptrd_cr_bal;

     /* CptrdQsz: Captured queue size                                */
     /* range: 22:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_qsz;

     /* CptrdCrs: Captured CRS                                       */
     /* range: 25:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_crs;

     /* CptrdFsmrqCtrl: Captured FSMRQ control                       */
     /* range: 27:26, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_fsmrq_ctrl;

     /* CptrdInDqcq: Captured DQCQ                                   */
     /* range: 28:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_in_dqcq;

     /* CptrdOnePktDeq: Captured One-Pkt-Deq                         */
     /* range: 29:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_one_pkt_deq;

     /* CptrdWdDel: Captured WdDel                                   */
     /* range: 30:30, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_wd_del;

     /* CptrdValid: Indicates values in this register are valid.     */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cptrd_valid;

  } __ATTRIBUTE_PACKED__ capture_queue_descriptor_reg;


  /* Max Cr Bal: This register holds the Max value of credit        */
  /* balance seen. Can be filtered by QueueNumFilter (with          */
  /* mask).                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b1 */

     /* MaxCrBal: This register holds the Max value of credit        */
     /* balance seen. Can be filtered by QueueNumFilter (with        */
     /* mask). This register is clear on read.                       */
     /* range: 15:0, access type: RO, default value: 0xffff          */
     SOC_PETRA_REG_FIELD max_cr_bal;

  } __ATTRIBUTE_PACKED__ max_cr_bal_reg;


  /* Max Fsmrq Req Queues: Holds the maximum number of queues       */
  /* in state FSMRQ request seen since last read.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b2 */

     /* MaxFsmrqReqQueues: This register is clear on read.           */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD max_fsmrq_req_queues;

     /* FsmrqReqQueues: Instantaneous fsmrq request count.           */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrq_req_queues;

  } __ATTRIBUTE_PACKED__ max_fsmrq_req_queues_reg;


  /* Max Port Queue Size: Holds the maximum port queue size         */
  /* received since last read from a defined system physical        */
  /* port id.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b3 */

     /* MaxPortQueueSize: Maximum port queue size received since     */
     /* last read from a defined system physical port id. This       */
     /* register is clear on read.                                   */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD max_port_queue_size;

     /* InsPortQueueSize: instantaneous port queue size.             */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ins_port_queue_size;

     /* MaxPortQueueSizePortId: System Physical Port ID.             */
     /* range: 27:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD max_port_queue_size_port_id;

  } __ATTRIBUTE_PACKED__ max_port_queue_size_reg;


  /* Time In Slow: This register holds the clock count the          */
  /* queue defined in QueueNumFilter (without mask) was in          */
  /* CRS==SLOW. It is advisable to use this only with timer          */
  /* active.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b4 */

     /* TimeInSlow: This register is clear on read.                  */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD time_in_slow;

     /* TimeInSlowValid: Conter valid, or counter overflowd if       */
     /* not using timer.                                             */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD time_in_slow_valid;

  } __ATTRIBUTE_PACKED__ time_in_slow_reg;


  /* Time In Norm: This register holds the clock count the          */
  /* queue defined in QueueNumFilter (without mask) was in          */
  /* CRS==NORM. It is advisable to use this only with timer          */
  /* active.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03b5 */

     /* TimeInNorm: This register is clear on read.                  */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD time_in_norm;

     /* TimeInNormValid: Conter valid, or counter overflowd if       */
     /* not using timer.                                             */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD time_in_norm_valid;

  } __ATTRIBUTE_PACKED__ time_in_norm_reg;


  /* Fcr Credit Counter: Counts credit received from FCR. This       */
  /* counter may count according to timer and queue number          */
  /* filter.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d0 */

     /* FcrCreditCounter:                                            */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fcr_credit_counter;

     /* FcrCreditCounterOverflow: Conter overflowed, or counter      */
     /* valid after timer finished This register is clear on         */
     /* read.                                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fcr_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ fcr_credit_counter_reg;


  /* Global Credit Counter: Counts credit received from all         */
  /* sources. This counter may count according to timer.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d1 */

     /* GlobalCreditCounter:                                         */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD global_credit_counter;

     /* GlobalCreditCounterOverflow: Conter overflowed, or           */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD global_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ global_credit_counter_reg;


  /* Gfmc Credit Counter: Counts credit granted to FMC queues       */
  /* under GFMC. This counter may count according to timer.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d2 */

     /* GfmcCreditCounter:                                           */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD gfmc_credit_counter;

     /* GfmcCreditCounterOverflow: Conter overflowed, or counter     */
     /* valid after timer finished This register is clear on         */
     /* read.                                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD gfmc_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ gfmc_credit_counter_reg;


  /* Bfmc1 Credit Counter: Counts credit granted to FMC             */
  /* queues under BFMC1. This counter may count according to         */
  /* timer.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d3 */

     /* Bfmc1CreditCounter:                                          */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bfmc1_credit_counter;

     /* Bfmc1CreditCounterOverflow: Conter overflowed, or            */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bfmc1_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ bfmc1_credit_counter_reg;


  /* Bfmc2 Credit Counter: Counts credit granted to FMC             */
  /* queues under BFMC2. This counter may count according to         */
  /* timer.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d4 */

     /* Bfmc2CreditCounter:                                          */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bfmc2_credit_counter;

     /* Bfmc2CreditCounterOverflow: Conter overflowed, or            */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bfmc2_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ bfmc2_credit_counter_reg;


  /* Bfmc3 Credit Counter: Counts credit granted to FMC             */
  /* queues under BFMC3. This counter may count according to         */
  /* timer.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d5 */

     /* Bfmc3CreditCounter:                                          */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD bfmc3_credit_counter;

     /* Bfmc3CreditCounterOverflow: Conter overflowed, or            */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD bfmc3_credit_counter_overflow;

  } __ATTRIBUTE_PACKED__ bfmc3_credit_counter_reg;


  /* Global Flow Status Counter: Counts all flow status             */
  /* messages sent from IPS (before FMS). This counter may           */
  /* count according to timer, queue number filter and flow         */
  /* status filter.                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d6 */

     /* GlobalFlowStatusCounter:                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD global_flow_status_counter;

     /* GlobalFlowStatusCounterOverflow: Conter overflowed, or       */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD global_flow_status_counter_overflow;

  } __ATTRIBUTE_PACKED__ global_flow_status_counter_reg;


  /* Fsmrq Flow Status Counter: Counts flow status messages         */
  /* generated by FSMRQ (before FMS). This counter may count         */
  /* according to timer, queue number filter and flow status        */
  /* filter.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d7 */

     /* FsmrqFlowStatusCounter:                                      */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsmrq_flow_status_counter;

     /* FsmrqFlowStatusCounterOverflow: Conter overflowed, or        */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmrq_flow_status_counter_overflow;

  } __ATTRIBUTE_PACKED__ fsmrq_flow_status_counter_reg;


  /* Fms Flow Status Counter: Counts flow status messages           */
  /* sent to FCT after FMS. This counter may count according         */
  /* to timer, queue number filter and flow status filter.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d8 */

     /* FmsFlowStatusCounter:                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fms_flow_status_counter;

     /* FmsFlowStatusCounterOverflow: Conter overflowed, or          */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fms_flow_status_counter_overflow;

  } __ATTRIBUTE_PACKED__ fms_flow_status_counter_reg;


  /* Global Iqm Report Counter: Counts IQM reports handled by       */
  /* main IPS logic. This counter may count according to             */
  /* timer.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03d9 */

     /* GlblIqmRprtCounter:                                          */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD glbl_iqm_rprt_counter;

     /* GlblIqmRprtCounterOverflow: Conter overflowed, or            */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD glbl_iqm_rprt_counter_overflow;

  } __ATTRIBUTE_PACKED__ global_iqm_report_counter_reg;


  /* Programmable Iqm Report Counter: Counts IQM reports            */
  /* handled by main IPS logic. This counter may count               */
  /* according to timer, queue number filer and IQM report          */
  /* filter.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03da */

     /* PrgIqmRprtCounter:                                           */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prg_iqm_rprt_counter;

     /* PrgIqmRprtCounterOverflow: Conter overflowed, or counter     */
     /* valid after timer finished This register is clear on         */
     /* read.                                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD prg_iqm_rprt_counter_overflow;

  } __ATTRIBUTE_PACKED__ programmable_iqm_report_counter_reg;


  /* Crwd Event Counter: Counts credit watchdog events              */
  /* handled by main IPS logic. This counter may count               */
  /* according to timer and queue number filer.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03db */

     /* CrwdCounter:                                                 */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crwd_counter;

     /* CrwdCounterOverflow: Conter overflowed, or counter valid     */
     /* after timer finished This register is clear on read.         */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crwd_counter_overflow;

  } __ATTRIBUTE_PACKED__ crwd_event_counter_reg;


  /* Deq Cmd Byte Counter: Counts the amount of credit              */
  /* command bytes sent to IQM, in 64B units. This counter may       */
  /* count according to timer, queue number filter and DQCQ         */
  /* filters.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03dc */

     /* DeqCmdByteCounter:                                           */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD deq_cmd_byte_counter;

     /* DeqCmdByteCounterOverflow: Conter overflowed, or counter     */
     /* valid after timer finished This register is clear on         */
     /* read.                                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_cmd_byte_counter_overflow;

  } __ATTRIBUTE_PACKED__ deq_cmd_byte_counter_reg;


  /* Deq Cmd Counter: Counts the amount of DEQ commands sent        */
  /* to the IQM. This counter may count according to timer,          */
  /* queue number filter and DQCQ filters.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03dd */

     /* DeqCmdCounter:                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD deq_cmd_counter;

     /* DeqCmdCounterOverflow: Conter overflowed, or counter         */
     /* valid after timer finished This register is clear on         */
     /* read.                                                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD deq_cmd_counter_overflow;

  } __ATTRIBUTE_PACKED__ deq_cmd_counter_reg;


  /* Masked Iqm Event Counter: Counts the number of IQM             */
  /* events masked at IPS input. This counter may count              */
  /* according to timer and queue number filter.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03de */

     /* MskdIqmEvntsCounter:                                         */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mskd_iqm_evnts_counter;

     /* MskdIqmEvntsCounterOverflow: Conter overflowed, or           */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD mskd_iqm_evnts_counter_overflow;

  } __ATTRIBUTE_PACKED__ masked_iqm_event_counter_reg;


  /* Flow Control Counter: Counts the number clocks the             */
  /* selected flow control signal was asserted. This counter         */
  /* may count according to timer and it's deidcated select.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03df */

     /* FcCount:                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fc_count;

     /* FcCountOverflow: Conter overflowed, or counter valid         */
     /* after timer finished This register is clear on read.         */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fc_count_overflow;

  } __ATTRIBUTE_PACKED__ flow_control_counter_reg;


  /* Returned Credit Counter: Counts the number of credits          */
  /* returned to the SCH. This counter may count according to        */
  /* timer and queue filter.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x03e0 */

     /* ReturnedCreditCount:                                         */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD returned_credit_count;

     /* ReturnedCreditCountOverflow: Conter overflowed, or           */
     /* counter valid after timer finished This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD returned_credit_count_overflow;

  } __ATTRIBUTE_PACKED__ returned_credit_counter_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_IPS_REGS;
/* Block definition: IPT */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in the IPT.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0800 */

     /* SopEccError: If set, then ECC error on SOP memory.           */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD sop_ecc_error;

     /* MopEccError: If set, then ECC error on MOP memory.           */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD mop_ecc_error;

     /* FdtcEccError: If set, then ECC error on FDTC memory.         */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdtc_ecc_error;

     /* EgqcEccError: If set, then ECC error on EGQC memory.         */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD egqc_ecc_error;

     /* BdqEccError: If set, then ECC error on BDQ memory.           */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdq_ecc_error;

     /* PdqEccError: If set, then ECC error on PDQ memory.           */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD pdq_ecc_error;

     /* CrcErrPkt: If set, then CRC error on packets arrived         */
     /* from MMU.                                                    */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD crc_err_pkt;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0810 */

     /* SopEccErrorMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD sop_ecc_error_mask;

     /* MopEccErrorMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mop_ecc_error_mask;

     /* FdtcEccErrorMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdtc_ecc_error_mask;

     /* EgqcEccErrorMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD egqc_ecc_error_mask;

     /* BdqEccErrorMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bdq_ecc_error_mask;

     /* PdqEccErrorMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pdq_ecc_error_mask;

     /* CrcErrPktMask: Writing 0 masks the corresponding             */
     /* interrupt source.                                            */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crc_err_pkt_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0820 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0821 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0822 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_2;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0823 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_3;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0824 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_4;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0825 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_5;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0826 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_6;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0827 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_7;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0828 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_8;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0829 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_9;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x082a */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_10;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x082b */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_11;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x082c */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_12;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x082d */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_13;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x082e */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_14;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x082f */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_15;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0830 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0831 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0832 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_2;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0833 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_3;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0834 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_4;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0835 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_5;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0836 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_6;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0837 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_7;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0838 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_8;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0839 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_9;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x083a */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_10;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x083b */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_11;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x083c */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_12;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x083d */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_13;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x083e */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_14;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x083f */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_15;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0840 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set, to 0, one       */
     /* operation is performed. The cpu can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set, to 0, then the command has no timeout.       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0841 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* Disable Ecc: Disable Ecc logic                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0842 */

     /* DisableEcc: Disable Ecc logic                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD disable_ecc;

  } __ATTRIBUTE_PACKED__ disable_ecc_reg;


  /* Data Queue EGQThreshold: EGQ TX data queue threshold.          */
  /* The IPT stores the data read from the DRAM before it is        */
  /* sent to the Egq, If the number of 64 bytes cells stored        */
  /* in the FIFO is above the threshold then flow control is        */
  /* sent to the EGQ and traffic from local route get strict        */
  /* priority in the EGQ.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0860 */

     /* DtqEgqTh: EGQ Tx Data queue threshold.                       */
     /* range: 4:0, access type: RW, default value: 0x19             */
     SOC_PETRA_REG_FIELD dtq_egq_th;

  } __ATTRIBUTE_PACKED__ data_queue_egqthreshold_reg;


  /* Gci Flag Enable Disable: Configures IPT GCI/MCI logic          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0861 */

     /* BFMC0IpsEnable: If set the flow control logic from the       */
     /* IPT GCI to the IPS is enabled.                               */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD bfmc0_ips_enable;

     /* BFMC01IpsEnable: If set the flow control logic from the      */
     /* IPT GCI to the IPS is enabled.                               */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD bfmc01_ips_enable;

     /* BFMC2IpsEnable: If set the flow control logic from the       */
     /* IPT GCI to the IPS is enabled.                               */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD bfmc2_ips_enable;

     /* GFMcIpsEnable: If set the flow control logic from the        */
     /* IPT GCI to the IPS is enabled.                               */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD gfmc_ips_enable;

     /* Lkyb1IptEnable: If set the flow control logic from the       */
     /* IPT GCI to the IPS is enabled.                               */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD lkyb1_ipt_enable;

     /* Lkyb2IptEnable: If set the flow control logic from the       */
     /* IPT GCI to the IPS is enabled.                               */
     /* range: 5:5, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD lkyb2_ipt_enable;

     /* Lkyb3IptEnable: If set the flow control logic from the       */
     /* IPT GCI to the IPS is enabled.                               */
     /* range: 6:6, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD lkyb3_ipt_enable;

     /* Lkyb4IptEnable: If set the flow control logic from the       */
     /* IPT GCI to the IPS is enabled.                               */
     /* range: 7:7, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD lkyb4_ipt_enable;

     /* Mci1IptEnable: If set the flow control logic from the        */
     /* IPT GCI to the IPS is enabled.                               */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mci1_ipt_enable;

  } __ATTRIBUTE_PACKED__ gci_flag_enable_disable_reg;


  /* GCIMCILeaky Bucket Configuration Register0: Configures         */
  /* the GCI/MCI logic                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0862 */

     /* LkyBktMaxCnt: The maximum value a leaky bucket can reach     */
     /* range: 7:0, access type: RW, default value: 0x80             */
     SOC_PETRA_REG_FIELD lky_bkt_max_cnt;

     /* LkyBktCngTh: The threshold above which a leaky bucket is     */
     /* considered congested                                         */
     /* range: 23:16, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD lky_bkt_cng_th;

     /* HoldMCIPrd: The period the IPT holds an MCI indication       */
     /* active. Setting this parameter to 0 disables this, and        */
     /* the indication comes directly from the FE.                   */
     /* range: 29:24, access type: RW, default value: 0x20           */
     SOC_PETRA_REG_FIELD hold_mciprd;

  } __ATTRIBUTE_PACKED__ gcimcileaky_bucket_configuration_0_reg;


  /* GCILeaky Bucket Configuration Register1: Configures the        */
  /* GCI/MCI logic                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0863 */

     /* LkyBktDcrRate1: The number of clocks to decrement leaky      */
     /* bucket 1. If set to 0, the leaky bucket will not             */
     /* decrement.                                                   */
     /* range: 5:0, access type: RW, default value: 0x4              */
     SOC_PETRA_REG_FIELD lky_bkt_dcr_rate1;

     /* LkyBktDcrRate2: The number of clocks to decrement leaky      */
     /* bucket 1. If set to 0, the leaky bucket will not             */
     /* decrement.                                                   */
     /* range: 13:8, access type: RW, default value: 0x2             */
     SOC_PETRA_REG_FIELD lky_bkt_dcr_rate2;

     /* LkyBktDcrRate3: The number of clocks to decrement leaky      */
     /* bucket 1. If set to 0, the leaky bucket will not             */
     /* decrement.                                                   */
     /* range: 21:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD lky_bkt_dcr_rate3;

     /* LkyBktDcrRate4: The number of clocks to decrement leaky      */
     /* bucket 1. If set to 0, the leaky bucket will not             */
     /* decrement.                                                   */
     /* range: 29:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD lky_bkt_dcr_rate4;

  } __ATTRIBUTE_PACKED__ gcileaky_bucket_configuration_1_reg;


  /* Mapping Traffic Class: Mapping 8 traffic class in soc_petra        */
  /* header to 4 traffic class in fap20b header type                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0864 */

     /* ClassTable: Traffic class mapping 8 to 4 table               */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD class_table;

  } __ATTRIBUTE_PACKED__ mapping_traffic_class_reg;


  /* Fabric Header Extended Mode: Fap20b Fabric header in           */
  /* extended mode                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0865 */

     /* Extmode: If set the fap20b is in extended mode               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD extmode;

  } __ATTRIBUTE_PACKED__ fabric_header_extended_mode_reg;


  /* CRCErr Rate Configuration Register0: Configures the CRC        */
  /* errors rate counters logic                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0866 */

     /* CRCErrRateDcr: The number of clocks to decrement the CRC     */
     /* errors rate counter.                                         */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD crcerr_rate_dcr;

     /* CRCErrRateMaxCnt: The maximum value the CRC errors           */
     /* counter can reach                                            */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crcerr_rate_max_cnt;

  } __ATTRIBUTE_PACKED__ crcerr_rate_configuration_0_reg;


  /* CRCErr Rate Configuration Register1:                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0867 */

     /* CRCErrRateCngTh: The threshold above which the IPT stops     */
     /* to transmit the packets to the fabric and the local          */
     /* path. If set to 0, the IPT never stops the traffic to        */
     /* the fabric and local path.                                   */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD crcerr_rate_cng_th;

  } __ATTRIBUTE_PACKED__ crcerr_rate_configuration_1_reg;


  /* CRCErr Weight Configuration Register0: Configures the          */
  /* CRC errors weight logic                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0868 */

     /* CRCErrWeight: Weight for packet with CRC error.              */
     /* Increment the CRC weight counter                             */
     /* range: 4:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crcerr_weight;

     /* CRCNOErrWeight: Weight for packet without CRC error.         */
     /* Deccrement the CRC weight counter                            */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crcnoerr_weight;

  } __ATTRIBUTE_PACKED__ crcerr_weight_configuration_0_reg;


  /* CRCErr Weight Configuration Register1: Configures the          */
  /* CRC errors weight logic                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0869 */

     /* CRCErrWeightMaxCnt: The maximum value the CRC errors         */
     /* weight counter can reach                                     */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD crcerr_weight_max_cnt;

     /* CRCErrWeightCngTh: The threshold above which the IPT         */
     /* stops to transmit the packets to the fabric and the          */
     /* local path. If set to 0, the IPT never stops the traffic     */
     /* to the fabric and local path.                                */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD crcerr_weight_cng_th;

  } __ATTRIBUTE_PACKED__ crcerr_weight_configuration_1_reg;


  /* Force Local Or Fabric: Force traffic to local route or         */
  /* to fabric.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x086a */

     /* ForceLocal: Force all the traffic to local route.            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_local;

     /* ForceFabric: Force all the traffic to Fabric.                */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_fabric;

  } __ATTRIBUTE_PACKED__ force_local_or_fabric_reg;


  /* DRAMBuffer Pointer Queue Threshold 0-15: DRAM buffer           */
  /* pointer queue thresholds. IPT stores the DRAM buffer           */
  /* pointers in FIFO with 16 contexts. If the number of            */
  /* Dbuff pointer stored in the context is above the               */
  /* threshold, flow control to ips is sent.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0870 */

     /* DpqTh0-15: Context number 0-15 threshold. above flow control */
     /* to IPS is sent                                               */
     /* This is High Priority context                                */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_th_hp;
     /* DpqTh0-15: Context number 0-15 threshold. above flow control */
     /* to IPS is sent                                               */
     /* This is Low Priority context                                  */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_th_lp;
  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_threshold_reg[SOC_PETRA_REGS_DBUFF_PTR_Q_THRESH_NOF_REGS];

  /* DRAMBuffer Pointer Queue Size0-1: DRAM buffer queue            */
  /* size. IPT stores the DRAM buffer pointers in FIFO with         */
  /* 16 contexts. The Dbuff pointers are stored in a shared         */
  /* memory. The number of entries per context is                   */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0880 */

     /* DpqSize0: Context number 0 Size. Number of lines in the      */
     /* shared memory ,assigned to it.                               */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size0;

     /* DpqSize1: Context number 1 Size. Number of lines in the      */
     /* shared memory ,assigned to it.                               */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size1;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size0_1_reg;


  /* DRAMBuffer Pointer Queue Size2-3: DRAM buffer queue            */
  /* size. IPT stores the DRAM buffer pointers in FIFO with         */
  /* 16 contexts. The Dbuff pointers are stored in a shared         */
  /* memory. The number of entries per context is                   */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0881 */

     /* DpqSize2: Context number 2 Size. Number of lines in the      */
     /* shared memory ,assigned to it.                               */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size2;

     /* DpqSize3: Context number 3 Size. Number of lines in the      */
     /* shared memory ,assigned to it.                               */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size3;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size2_3_reg;


  /* DRAMBuffer Pointer Queue Size4-5: DRAM buffer queue            */
  /* size. IPT stores the DRAM buffer pointers in FIFO with         */
  /* 16 contexts. The Dbuff pointers are stored in a shared         */
  /* memory. The number of entries per context is                   */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0882 */

     /* DpqSize4: Context number 4 Size. Number of lines in the      */
     /* shared memory ,assigned to it.                               */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size4;

     /* DpqSize5: Context number 5 Size. Number of lines in the      */
     /* shared memory ,assigned to it.                               */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size5;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size4_5_reg;


  /* DRAMBuffer Pointer Queue Size6-7: DRAM buffer queue            */
  /* size. IPT stores the DRAM buffer pointers in FIFO with         */
  /* 16 contexts. The Dbuff pointers are stored in a shared         */
  /* memory. The number of entries per context is                   */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0883 */

     /* DpqSize6: Context number 6 Size. Number of lines in the      */
     /* shared memory ,assigned to it.                               */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size6;

     /* DpqSize7: Context number 7 Size. Number of lines in the      */
     /* shared memory ,assigned to it.                               */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size7;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size6_7_reg;


  /* DRAMBuffer Pointer Queue Size8-9: DRAM buffer queue            */
  /* size. IPT stores the DRAM buffer pointers in FIFO with         */
  /* 16 contexts. The Dbuff pointers are stored in a shared         */
  /* memory. The number of entries per context is                   */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0884 */

     /* DpqSize8: Context number 8 Size. Number of lines in the      */
     /* shared memory ,assigned to it.                               */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size8;

     /* DpqSize9: Context number 9 Size. Number of lines in the      */
     /* shared memory ,assigned to it.                               */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size9;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size8_9_reg;


  /* DRAMBuffer Pointer Queue Size10-11: DRAM buffer queue          */
  /* size. IPT stores the DRAM buffer pointers in FIFO with         */
  /* 16 contexts. The Dbuff pointers are stored in a shared         */
  /* memory. The number of entries per context is                   */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0885 */

     /* DpqSize10: Context number 10 Size. Number of lines in        */
     /* the shared memory ,assigned to it.                           */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size10;

     /* DpqSize11: Context number 11 Size. Number of lines in        */
     /* the shared memory ,assigned to it.                           */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size11;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size10_11_reg;


  /* DRAMBuffer Pointer Queue Size12-13: DRAM buffer queue          */
  /* size. IPT stores the DRAM buffer pointers in FIFO with         */
  /* 16 contexts. The Dbuff pointers are stored in a shared         */
  /* memory. The number of entries per context is                   */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0886 */

     /* DpqSize12: Context number 12 Size. Number of lines in        */
     /* the shared memory ,assigned to it.                           */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size12;

     /* DpqSize13: Context number 13 Size. Number of lines in        */
     /* the shared memory ,assigned to it.                           */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size13;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size12_13_reg;


  /* DRAMBuffer Pointer Queue Size14-15: DRAM buffer queue          */
  /* size. IPT stores the DRAM buffer pointers in FIFO with         */
  /* 16 contexts. The Dbuff pointers are stored in a shared         */
  /* memory. The number of entries per context is                   */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0887 */

     /* DpqSize14: Context number 14 Size. Number of lines in        */
     /* the shared memory ,assigned to it.                           */
     /* range: 11:0, access type: RW, default value: 0xff            */
     SOC_PETRA_REG_FIELD dpq_size14;

     /* DpqSize15: Context number 15 Size. Number of lines in        */
     /* the shared memory ,assigned to it.                           */
     /* range: 27:16, access type: RW, default value: 0xff           */
     SOC_PETRA_REG_FIELD dpq_size15;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_size14_15_reg;


  /* DRAMBuffer Pointer Queue Start Address0-1: DRAM buffer         */
  /* queue Start. IPT stores the DRAM buffer pointers in FIFO       */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The context memory start address is             */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0890 */

     /* DpqStart0: Context number 0 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dpq_start0;

     /* DpqStart1: Context number 1 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0x100          */
     SOC_PETRA_REG_FIELD dpq_start1;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address0_1_reg;


  /* DRAMBuffer Pointer Queue Start Address2-3: DRAM buffer         */
  /* queue Start. IPT stores the DRAM buffer pointers in FIFO       */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The context memory start address is             */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0891 */

     /* DpqStart2: Context number 2 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0x200           */
     SOC_PETRA_REG_FIELD dpq_start2;

     /* DpqStart3: Context number 3 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0x300          */
     SOC_PETRA_REG_FIELD dpq_start3;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address2_3_reg;


  /* DRAMBuffer Pointer Queue Start Address4-5: DRAM buffer         */
  /* queue Start. IPT stores the DRAM buffer pointers in FIFO       */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The context memory start address is             */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0892 */

     /* DpqStart4: Context number 4 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0x400           */
     SOC_PETRA_REG_FIELD dpq_start4;

     /* DpqStart5: Context number 5 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0x500          */
     SOC_PETRA_REG_FIELD dpq_start5;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address4_5_reg;


  /* DRAMBuffer Pointer Queue Start Address6-7: DRAM buffer         */
  /* queue Start. IPT stores the DRAM buffer pointers in FIFO       */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The context memory start address is             */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0893 */

     /* DpqStart6: Context number 6 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0x600           */
     SOC_PETRA_REG_FIELD dpq_start6;

     /* DpqStart7: Context number 7 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0x700          */
     SOC_PETRA_REG_FIELD dpq_start7;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address6_7_reg;


  /* DRAMBuffer Pointer Queue Start Address8-9: DRAM buffer         */
  /* queue Start. IPT stores the DRAM buffer pointers in FIFO       */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The context memory start address is             */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0894 */

     /* DpqStart8: Context number 8 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0x800           */
     SOC_PETRA_REG_FIELD dpq_start8;

     /* DpqStart9: Context number 9 Start. The shared memory         */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0x900          */
     SOC_PETRA_REG_FIELD dpq_start9;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address8_9_reg;


  /* DRAMBuffer Pointer Queue Start Address10-11: DRAM buffer       */
  /* queue Start. IPT stores the DRAM buffer pointers in FIFO       */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The context memory start address is             */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0895 */

     /* DpqStart10: Context number 10 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0xa00           */
     SOC_PETRA_REG_FIELD dpq_start10;

     /* DpqStart11: Context number 11 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0xb00          */
     SOC_PETRA_REG_FIELD dpq_start11;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address10_11_reg;


  /* DRAMBuffer Pointer Queue Start Address12-13: DRAM buffer       */
  /* queue Start. IPT stores the DRAM buffer pointers in FIFO       */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The context memory start address is             */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0896 */

     /* DpqStart12: Context number 12 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0xc00           */
     SOC_PETRA_REG_FIELD dpq_start12;

     /* DpqStart13: Context number 13 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0xd00          */
     SOC_PETRA_REG_FIELD dpq_start13;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address12_13_reg;


  /* DRAMBuffer Pointer Queue Start Address14-15: DRAM buffer       */
  /* queue Start. IPT stores the DRAM buffer pointers in FIFO       */
  /* with 16 contexts. The Dbuff pointers are stored in a           */
  /* shared memory. The context memory start address is             */
  /* programmable.                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0897 */

     /* DpqStart14: Context number 14 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 11:0, access type: RW, default value: 0xe00           */
     SOC_PETRA_REG_FIELD dpq_start14;

     /* DpqStart15: Context number 15 Start. The shared memory       */
     /* address from above the context Dbuff pointers are stored     */
     /* range: 27:16, access type: RW, default value: 0xf00          */
     SOC_PETRA_REG_FIELD dpq_start15;

  } __ATTRIBUTE_PACKED__ drambuffer_pointer_queue_start_address14_15_reg;


  /* Transmit Data Queue Size0-7: Transmit data queue Size.         */
  /* IPT stores the data read from the DRAM before it is sent       */
  /* to the FDT, in FIFO with 7 contexts. The data stored in        */
  /* a shared memory. The context size is programmable.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0900 */

     /* DtqSize: Context number [0-7] Size. Number of lines in the   */
     /* shared memory ,assigned to it.                               */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_size[SOC_PETRA_TRANSMIT_DATA_QUEUE_NOF_FLDS];
  } __ATTRIBUTE_PACKED__ transmit_data_queue_size_reg[SOC_PETRA_TRANSMIT_DATA_QUEUE_NOF_REGS];

  /* Transmit Data Queue Start Adress0-7: Transmit data queue       */
  /* Start address. IPT stores the data read from the DRAM          */
  /* before it is sent to the FDT, in FIFO with 7 contexts.         */
  /* The data stored in a shared memory. The context memory         */
  /* start address is programmable.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0910 */

     /* DtqStart0: Context number 0-7 Start. The shared memory       */
     /* address from above the context Data cells are stored         */
     /* range: 8:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dtq_start[SOC_PETRA_TRANSMIT_DATA_QUEUE_NOF_FLDS];
  } __ATTRIBUTE_PACKED__ transmit_data_queue_start_adress_reg[SOC_PETRA_TRANSMIT_DATA_QUEUE_NOF_REGS];

  /* Transmit Data Queue Threshold0-1: Transmit data queue          */
  /* threshold. IPT stores the data read from the DRAM before       */
  /* it is sent to the FDT, If the number of 64 bytes cells         */
  /* stored in the context is above the threshold, then IPT         */
  /* shaper bandwidth is divided by two                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0920 */

     /* DtqTh0: Context number 0 threshold. above shaper             */
     /* bandwidth is divided by two                                  */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_th0;

     /* DtqTh1: Context number 1 threshold. above shaper             */
     /* bandwidth is divided by two                                  */
     /* range: 24:16, access type: RW, default value: 0x48           */
     SOC_PETRA_REG_FIELD dtq_th1;

  } __ATTRIBUTE_PACKED__ transmit_data_queue_threshold0_1_reg;


  /* Transmit Data Queue Threshold2-3: Transmit data queue          */
  /* threshold. IPT stores the data read from the DRAM before       */
  /* it is sent to the FDT, If the number of 64 bytes cells         */
  /* stored in the context is above the threshold, then IPT         */
  /* shaper bandwidth is divided by two.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0921 */

     /* DtqTh2: Context number 2 threshold. above shaper             */
     /* bandwidth is divided by two                                  */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_th2;

     /* DtqTh3: Context number 3 threshold. above shaper             */
     /* bandwidth is divided by two                                  */
     /* range: 24:16, access type: RW, default value: 0x48           */
     SOC_PETRA_REG_FIELD dtq_th3;

  } __ATTRIBUTE_PACKED__ transmit_data_queue_threshold2_3_reg;


  /* Transmit Data Queue Threshold4-5: Transmit data queue          */
  /* threshold. IPT stores the data read from the DRAM before       */
  /* it is sent to the FDT, If the number of 64 bytes cells         */
  /* stored in the context is above the threshold, then IPT         */
  /* shaper bandwidth is divided by two.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0922 */

     /* DtqTh4: Context number 4 threshold. above shaper             */
     /* bandwidth is divided by two                                  */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_th4;

     /* DtqTh5: Context number 5 threshold. above shaper             */
     /* bandwidth is divided by two                                  */
     /* range: 24:16, access type: RW, default value: 0x48           */
     SOC_PETRA_REG_FIELD dtq_th5;

  } __ATTRIBUTE_PACKED__ transmit_data_queue_threshold4_5_reg;


  /* Transmit Data Queue Threshold6: Transmit data queue            */
  /* threshold. IPT stores the data read from the DRAM before       */
  /* it is sent to the FDT, If the number of 64 bytes cells         */
  /* stored in the context is above the threshold, then IPT         */
  /* shaper bandwidth is divided by two.                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0923 */

     /* DtqTh6: Context number 6 threshold. above shaper             */
     /* bandwidth is divided by two                                  */
     /* range: 8:0, access type: RW, default value: 0x48             */
     SOC_PETRA_REG_FIELD dtq_th6;

  } __ATTRIBUTE_PACKED__ transmit_data_queue_threshold6_reg;


  /* shaper_max_credit_reg[4]: IPT schedules among the DRAM         */
  /* buffers queue, the data read requests bandwidth is             */
  /* shaped.*/
  /* addr - Shaper0-1 Max Credit - 0x0930*/
  /* addr - Shaper2-3 Max Credit - 0x0931*/
  /* addr - Shaper4-5 Max Credit - 0x0932*/
  /* addr - Shaper6-7 Max Credit - 0x0933*/
  /* Shaper0MaxCredit: Shaper0 Max burst size. both In mesh         */
  /* and fabric mode gates the request for local route.             */
  /* range: 15:0, access type: RW, default value: 0xffff            */
  /* Shaper1MaxCredit: Shaper1 Max burst size. In mesh mode       */
  /* gates the requests for context1 and in fabric mode gates     */
  /* the request for the fabric.                                  */
  /* range: 31:16, access type: RW, default value: 0xffff         */

  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2130 */
     SOC_PETRA_REG_FIELD shaper0_max_credit;
     SOC_PETRA_REG_FIELD shaper1_max_credit;

  } __ATTRIBUTE_PACKED__ shaper_max_credit_reg[SOC_PETRA_NOF_SHAPER_MAX_CREDIT_REGS];


  /* Shaper8 Max Credit: IPT schedules among the DRAM buffers       */
  /* queue, the data read requests bandwidth is shaped.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0934 */

     /* Shaper8MaxCredit: Shaper8 Max burst size. In mesh mode       */
     /* gates the total read request bandwidth from the DRAM and     */
     /* not applicable in fabric mode.                               */
     /* range: 15:0, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD shaper8_max_credit;

  } __ATTRIBUTE_PACKED__ shaper8_max_credit_reg;


  /* shaper_delay_reg[4]: IPT schedules among the DRAM buffers       */
  /* queue, the data read requests bandwidth is shaped.              */
  /* addr: Shaper0-1 Delay 0x2140 */
  /* addr: Shaper2-3 Delay 0x2141 */
  /* addr: Shaper4-5 Delay 0x2142 */
  /* addr: Shaper6-7 Delay 0x2143 */
  /* Shaper0Delay: Shaper0 time interval to add the credit.       */
  /* in two clocks cycles resolution. Both In mesh and fabric     */
  /* mode gates the request for local route.                      */
  /* range: 15:0, access type: RW, default value: 0xffff          */
  /* Shaper1Delay: Shaper1 time interval to add the credit.       */
  /* in two clocks cycles resolution. In mesh mode gates the      */
  /* requests for context1 and in fabric mode gates the           */
  /* request for the fabric.                                      */
  /* range: 31:16, access type: RW, default value: 0xffff         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0941 */

     SOC_PETRA_REG_FIELD shaper0_delay;

     SOC_PETRA_REG_FIELD shaper1_delay;

  } __ATTRIBUTE_PACKED__ shaper_delay_reg[SOC_PETRA_NOF_SHAPER_DELAY_REGS];


  /* Shaper8 Delay: IPT schedules among the DRAM buffers            */
  /* queue, the data read requests bandwidth is shaped.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0944 */

     /* Shaper8Delay: Shaper8 time interval to add the credit,       */
     /* in two clocks cycles resolution. In mesh mode gates the      */
     /* total read request bandwidth from the DRAM and not           */
     /* applicable in fabric mode.                                   */
     /* range: 15:0, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD shaper8_delay;

  } __ATTRIBUTE_PACKED__ shaper8_delay_reg;


  /*shaper_cal_reg[4]: IPT schedules among the DRAM buffers            */
  /* queue, the data read requests bandwidth is gated by            */
  /* shapers.                                                       */

   /* addr: Shaper0-1 Cal 0x2150 */
   /* addr: Shaper2-3 Cal 0x2151 */
   /* addr; Shaper4-5 Cal 0x2152 */
   /* addr: Shaper6-7 Cal  0x2153 */
   /* Shaper0Cal: Shaper0 credit to add, in bytes resolution.      */
   /* Both In mesh and fabric mode gates the request for local     */
   /* route.                                                       */
   /* range: 15:0, access type: RW, default value: 0xffff          */
   /* Shaper1Cal: Shaper1 credit to add, in bytes resolution.      */
   /* In mesh mode gates the requests for context1 and in          */
   /* fabric mode gates the request for the fabric.                */
   /* range: 31:16, access type: RW, default value: 0xffff         */


  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0951 */

     SOC_PETRA_REG_FIELD shaper0_cal;

     SOC_PETRA_REG_FIELD shaper1_cal;

  } __ATTRIBUTE_PACKED__ shaper_cal_reg[SOC_PETRA_NOF_SHAPER_CAL_REGS];


  /* Shaper8 Cal: IPT schedules among the DRAM buffers queue,       */
  /* the data read requests bandwidth is shaped.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0954 */

     /* Shaper8Cal: Shaper8 credit to add, in bytes resolution.      */
     /* In mesh mode gates the total read request bandwidth from     */
     /* the DRAM and not applicable in fabric mode.                  */
     /* range: 15:0, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD shaper8_cal;

  } __ATTRIBUTE_PACKED__ shaper8_cal_reg;


  /* wfq_weight_reg[2]: To determine priority between contexts, the */
  /* IPT executes a WDRR. Each context gets a 16-bit weight         */
  /* and the result is that the ratio of the weight determine       */
  /* the traffic transmitted from each context, when context        */
  /* is backlogged                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0960 */

     /* Wfq0Weight: Weight0. In mesh mode weight for local route     */
     /* and in fabric mode weight for high priority traffic for      */
     /* local route.                                                 */
     /* range: 5:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD wfq0_weight;

     /* Wfq1Weight: Weight1. In mesh mode weight for context1        */
     /* and in fabric mode weight for fabric high priority           */
     /* traffic.                                                     */
     /* range: 13:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD wfq1_weight;

     /* Wfq2Weight: Weight2. In mesh mode weight for context2        */
     /* and in fabric mode weight for fabric Unicast high            */
     /* priority traffic                                             */
     /* range: 21:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD wfq2_weight;

     /* Wfq3Weight: Weight3. In mesh mode weight for context3        */
     /* and in fabric mode weight for fabric multicast high          */
     /* priority traffic (GFMC)                                      */
     /* range: 29:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD wfq3_weight;

  } __ATTRIBUTE_PACKED__ wfq_weight_reg[SOC_PETRA_NOF_WFQ_REGS];


  /* Stamping Fabric Header Enable: IPT stamping the packet         */
  /* header stored in the DRAM before sending it to the             */
  /* fabric.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0970 */

     /* StampFapPort: If set, IPT stamps the Fap Port (from IQM)     */
     /* in the packet header                                         */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stamp_fap_port;

     /* StampDp: If set, IPT stamps the DP (from IQM) in the         */
     /* packet header                                                */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stamp_dp;

     /* StampFwdaction: If set, IPT stamps the Fwdaction (from       */
     /* IQM) in the packet header                                    */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stamp_fwdaction;

     /* StampOutlif: If set, IPT stamps the Outlif (from IQM) in     */
     /* the packet header                                            */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stamp_outlif;

  } __ATTRIBUTE_PACKED__ stamping_fabric_header_enable_reg;


  /* Mapping Queue Type To Snoop Packet: Snoop table, Mapping       */
  /* Q-FWD-TYPE to snooped packet                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0971 */

     /* SnoopTable: If bit I is set then packet with (Q-FWD-TYPE     */
     /* == I) is snooped packet.                                     */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD snoop_table;

  } __ATTRIBUTE_PACKED__ mapping_queue_type_to_snoop_packet_reg;


  /* Crc Error Counter: CRC Error counter.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0972 */

     /* CrcErrCnt: CRC Error counter. This register is clear on      */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crc_err_cnt;

     /* CrcErrCntOvf: If set, then indicates that the counter        */
     /* has overflowed.                                              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crc_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ crc_error_counter_reg;


  /* Msb Mirror Data Bus: The MSB mirror data bus -                 */
  /* mdata[35:18].                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0973 */

     /* MsbMdataBus: mdata[35:18]                                    */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD msb_mdata_bus;

  } __ATTRIBUTE_PACKED__ msb_mirror_data_bus_reg;


  /* Lsb Mirror Data Bus: The LSB mirror data bus -                 */
  /* mdata[17:0].                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0974 */

     /* LsbMdataBus: mdata[17:0]                                     */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lsb_mdata_bus;

  } __ATTRIBUTE_PACKED__ lsb_mirror_data_bus_reg;


  /* Check Bw To Qnum: The Qnum to check BW to, otherwise           */
  /* check total BW.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0975 */

     /* QnumToCheckBw: The Qnum to check BW to.                      */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD qnum_to_check_bw;

     /* CheckBwToQnum: If set check BW to QnumToCheckBw,             */
     /* otherwise check total BW.                                    */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD check_bw_to_qnum;

  } __ATTRIBUTE_PACKED__ check_bw_to_qnum_reg;


  /* Check Bw To Fdt Qnum: The FDT Qnum to check BW to,             */
  /* otherwise check total BW.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0976 */

     /* FdtQnumToCheckBw: The FDT Qnum to check BW to.               */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdt_qnum_to_check_bw;

     /* CheckBwToFdtQnum: If set check BW to FdtQnumToCheckBw,       */
     /* otherwise check total BW.                                    */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD check_bw_to_fdt_qnum;

  } __ATTRIBUTE_PACKED__ check_bw_to_fdt_qnum_reg;


  /* Gtimer Config: GTIMER configuration.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0977 */

     /* TimerConfig: Period of time in clocks.                       */
     /* range: 30:0, access type: RW, default value: 31'hee6b27f     */
     SOC_PETRA_REG_FIELD timer_config;

  } __ATTRIBUTE_PACKED__ gtimer_config_reg;


  /* Gtimer Config Cont: GTIMER configuration.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0978 */

     /* ClearGtimer: Clear timer.                                    */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD clear_gtimer;

     /* ActivateGtimer: Activate timer.                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD activate_gtimer;

     /* GtimerActive: If set GTIMER is active.                       */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_active;

  } __ATTRIBUTE_PACKED__ gtimer_config_cont_reg;


  /* Select Source To Count: Select the source to count.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0979 */

     /* SelectSourceToCount: 3'b000 - ENQ2PCQ packets. 3'b001 -      */
     /* ENQ2BDQ buffers. 3'b010 - DEQ packets. 3'b011 - SOP FIFO     */
     /* writings. 3'b100 - MOP FIFO writings. 3'b101 - FDTC          */
     /* control cells. 3'b110 - FDTD data cells. 3'b111 - Valid      */
     /* GCIs.                                                        */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD select_source_to_count;

  } __ATTRIBUTE_PACKED__ select_source_to_count_reg;


  /* Select Source To Sum: Select the source to sum.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0980 */

     /* SelectSourceToSum: 1'b0 - DEQ bytes. 1'b1 - FDTC bytes.      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD select_source_to_sum;

  } __ATTRIBUTE_PACKED__ select_source_to_sum_reg;
} __ATTRIBUTE_PACKED__ SOC_PETRA_IPT_REGS;
/* Block definition: MMU */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a00 */

     /* ErrorEcc: If set, indicates an ECC error.                    */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_ecc;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Ecc Interrupt Register: This register contains the             */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a01 */

     /* WafaaEccErr: If set, indicates there was an ECC error.       */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafaa_ecc_err;

     /* WafabEccErr: If set, indicates there was an ECC error.       */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafab_ecc_err;

     /* WafacEccErr: If set, indicates there was an ECC error.       */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafac_ecc_err;

     /* WafadEccErr: If set, indicates there was an ECC error.       */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafad_ecc_err;

     /* WafaeEccErr: If set, indicates there was an ECC error.       */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafae_ecc_err;

     /* WafafEccErr: If set, indicates there was an ECC error.       */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafaf_ecc_err;

     /* WafbaEccErr: If set, indicates there was an ECC error.       */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafba_ecc_err;

     /* WafbbEccErr: If set, indicates there was an ECC error.       */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbb_ecc_err;

     /* WafbcEccErr: If set, indicates there was an ECC error.       */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbc_ecc_err;

     /* WafbdEccErr: If set, indicates there was an ECC error.       */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbd_ecc_err;

     /* WafbeEccErr: If set, indicates there was an ECC error.       */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wafbe_ecc_err;

     /* WafbfEccErr: If set, indicates there was an ECC error.       */
     /* range: 11:11, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wafbf_ecc_err;

     /* RafaEccErr: If set, indicates there was an ECC error.        */
     /* range: 12:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafa_ecc_err;

     /* RafbEccErr: If set, indicates there was an ECC error.        */
     /* range: 13:13, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafb_ecc_err;

     /* RafcEccErr: If set, indicates there was an ECC error.        */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafc_ecc_err;

     /* RafdEccErr: If set, indicates there was an ECC error.        */
     /* range: 15:15, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafd_ecc_err;

     /* RafeEccErr: If set, indicates there was an ECC error.        */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafe_ecc_err;

     /* RaffEccErr: If set, indicates there was an ECC error.        */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD raff_ecc_err;

     /* WfafaEccErr: If set, indicates there was an ECC error.       */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafa_ecc_err;

     /* WfafbEccErr: If set, indicates there was an ECC error.       */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafb_ecc_err;

     /* WfafcEccErr: If set, indicates there was an ECC error.       */
     /* range: 20:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafc_ecc_err;

     /* WfafdEccErr: If set, indicates there was an ECC error.       */
     /* range: 21:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafd_ecc_err;

     /* WfafeEccErr: If set, indicates there was an ECC error.       */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafe_ecc_err;

     /* WfaffEccErr: If set, indicates there was an ECC error.       */
     /* range: 23:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfaff_ecc_err;

     /* RfafaEccErr: If set, indicates there was an ECC error.       */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafa_ecc_err;

     /* RfafbEccErr: If set, indicates there was an ECC error.       */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafb_ecc_err;

     /* RfafcEccErr: If set, indicates there was an ECC error.       */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafc_ecc_err;

     /* RfafdEccErr: If set, indicates there was an ECC error.       */
     /* range: 27:27, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafd_ecc_err;

     /* RfafeEccErr: If set, indicates there was an ECC error.       */
     /* range: 28:28, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafe_ecc_err;

     /* RfaffEccErr: If set, indicates there was an ECC error.       */
     /* range: 29:29, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfaff_ecc_err;

     /* IdfEccErr: If set, indicates there was an ECC error.         */
     /* range: 30:30, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD idf_ecc_err;

     /* FdfEccErr: If set, indicates there was an ECC error.         */
     /* range: 31:31, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdf_ecc_err;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a10 */

     /* ErrorEccMask: Writing 0 masks the corresponding              */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_ecc_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Ecc Interrupt Register Mask: Each bit in this register         */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a11 */

     /* WafaaEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafaa_ecc_err_mask;

     /* WafabEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafab_ecc_err_mask;

     /* WafacEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafac_ecc_err_mask;

     /* WafadEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafad_ecc_err_mask;

     /* WafaeEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafae_ecc_err_mask;

     /* WafafEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafaf_ecc_err_mask;

     /* WafbaEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafba_ecc_err_mask;

     /* WafbbEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbb_ecc_err_mask;

     /* WafbcEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbc_ecc_err_mask;

     /* WafbdEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wafbd_ecc_err_mask;

     /* WafbeEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wafbe_ecc_err_mask;

     /* WafbfEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wafbf_ecc_err_mask;

     /* RafaEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafa_ecc_err_mask;

     /* RafbEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafb_ecc_err_mask;

     /* RafcEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafc_ecc_err_mask;

     /* RafdEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafd_ecc_err_mask;

     /* RafeEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rafe_ecc_err_mask;

     /* RaffEccErrMask: Writing 0 masks the corresponding            */
     /* interrupt source                                             */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD raff_ecc_err_mask;

     /* WfafaEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafa_ecc_err_mask;

     /* WfafbEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafb_ecc_err_mask;

     /* WfafcEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafc_ecc_err_mask;

     /* WfafdEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafd_ecc_err_mask;

     /* WfafeEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfafe_ecc_err_mask;

     /* WfaffEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfaff_ecc_err_mask;

     /* RfafaEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafa_ecc_err_mask;

     /* RfafbEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafb_ecc_err_mask;

     /* RfafcEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafc_ecc_err_mask;

     /* RfafdEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafd_ecc_err_mask;

     /* RfafeEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfafe_ecc_err_mask;

     /* RfaffEccErrMask: Writing 0 masks the corresponding           */
     /* interrupt source                                             */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rfaff_ecc_err_mask;

     /* IdfEccErrMask: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD idf_ecc_err_mask;

     /* FdfEccErrMask: Writing 0 masks the corresponding             */
     /* interrupt source                                             */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdf_ecc_err_mask;

  } __ATTRIBUTE_PACKED__ ecc_interrupt_register_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a20 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a21 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a22 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_2;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a23 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_3;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a24 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_4;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a25 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_5;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a26 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_6;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a27 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_7;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a28 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_8;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a29 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_9;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2a */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_10;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2b */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_11;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2c */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_12;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2d */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_13;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2e */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_14;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a2f */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_15;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a30 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a31 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a32 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_2;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a33 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_3;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a34 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_4;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a35 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_5;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a36 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_6;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a37 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_7;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a38 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_8;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a39 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_9;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3a */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_10;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3b */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_11;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3c */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_12;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3d */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_13;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3e */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_14;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a3f */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_15;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a40 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically set          */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to        */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a41 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* General Configuration Register: MMU General                    */
  /* Configuration bits.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a60 */

     /* DramBankNum: The number of banks per DRAM. 0 : 4 banks.      */
     /* 1 : 8 banks                                                  */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dram_bank_num;

     /* DramNum: The number of DRAMs. 0 : 6 DRAMs. 1 : 4 DRAMs.      */
     /* 2 : 3 DRAMs. 3 : 2 DRAMs                                     */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dram_num;

     /* ScramblingBitPosition: Relevant when                         */
     /* ConsBanksAddrMapMode is set for 4/2 DRAM scenario.           */
     /* Should be set to 0 for 4 DRAMs. For 2 DRAMs should be        */
     /* set in the following manner: 0 : Buffer size up to 1024B     */
     /* 1 : Buffer size of 2048B 2,3 : Reserved                      */
     /* range: 7:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD scrambling_bit_position;

     /* DramColNum: The number of DRAM columns. 0 : 256 Columns      */
     /* 1 : 512 Columns 2 : 1024 Columns 3 : 2048 Columns 4 :        */
     /* 4096 Columns 5, 6, 7 : 8192 Columns                          */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dram_col_num;

     /* BankInterleavingMode: Relevant for working with 4 DRAMs      */
     /* only. Determines the number of bits to use for               */
     /* scrambling the address. 0 : 3 bits 1 : 4 bits 2 : 5 bits     */
     /* 3 : 6 bits 4 : 7 bits 5 : Additional mapping option for      */
     /* 5 bits 6 : Additional mapping option for 6 bits 7 :          */
     /* Reserved                                                     */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bank_interleaving_mode;

     /* InterleavingRvrseMode: Relevant for working with 4 DRAMs     */
     /* only. If this bit is set the cell_address bits will be       */
     /* reversed before the bit scrambling is done.                  */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD interleaving_rvrse_mode;

     /* ConsBanksAddrMapMode: If set, uses a mapping function        */
     /* that sends consecutive words to consecutive banks            */
     /* range: 17:17, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cons_banks_addr_map_mode;

     /* LayerPeriodicity: Relevant for working with 6 DRAMs.         */
     /* range: 19:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD layer_periodicity;

     /* ReadFifosAllowed: Configures the minimum number of Read      */
     /* FIFOs that should be active in order to allow read           */
     /* command execution. A value of 0 disables this mechanism.     */
     /* range: 23:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD read_fifos_allowed;

     /* MinReadCommands: Configurs the minimum number of             */
     /* commands to be performed even if there are not enough        */
     /* active FIFOs (to prevend deadlocks)                          */
     /* range: 31:24, access type: RW, default value: 0x20           */
     SOC_PETRA_REG_FIELD min_read_commands;

  } __ATTRIBUTE_PACKED__ general_configuration_reg;


  /* Bank Access Controller Configurations: This register           */
  /* contains general configuration bits for the Bank Access        */
  /* Controller (BAC) block.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a61 */

     /* WriteInhibitCntSat: Write Inhibit Counter Saturation         */
     /* Value - The number of consecutive READ commands each BAC     */
     /* can perform before switching to a WRITE command.             */
     /* range: 8:0, access type: RW, default value: 0x40             */
     SOC_PETRA_REG_FIELD write_inhibit_cnt_sat;

     /* AddressMapConfigGen: Determines the number of                */
     /* consecutive commands going to the same bank. This            */
     /* register affects the data written to the MMU FIFOs. The      */
     /* number of consecutive commands is                            */
     /* (2^AddressMapConfigGen)                                      */
     /* range: 14:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD address_map_config_gen;

     /* AddressMapConfigRd: Determines the number of consecutive     */
     /* commands going to the same bank. This register affects       */
     /* the data read from the MMU FIFOs. The number of              */
     /* consecutive commands is (2^AddressMapConfigRd). Writing      */
     /* a value of 0x7 to this field allows unlimited commands       */
     /* to the same bank                                             */
     /* range: 18:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD address_map_config_rd;

     /* WrCmdDistance: Determines the number of commands between     */
     /* consecutive commands to the same bank (not the same row)     */
     /* range: 23:20, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD wr_cmd_distance;

     /* AllowConsecutive16Byte: If set, allows the BAC to send       */
     /* two consecutive 16B commands to the DRC. This bit can        */
     /* only be asserted if DRAM frequency < 2 * core frequency      */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD allow_consecutive16_byte;

     /* PerBankHalfMode: If set, enables each bank to change         */
     /* halves in an independent manner                              */
     /* range: 25:25, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD per_bank_half_mode;

     /* WrPriorityMode: Determines whether write commands will       */
     /* have priority over read commands in the BAC arbiter. 0 :     */
     /* Absolute priority to write commands 1 : Priority to          */
     /* write commands only when write is congested 2 : No           */
     /* priority 3 : Reserved                                        */
     /* range: 29:28, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD wr_priority_mode;

  } __ATTRIBUTE_PACKED__ bank_access_controller_configurations_reg;


  /* Ipt Data Fifo Configuration Register: This register            */
  /* configures the MMU IDF thresholds.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a62 */

     /* IdfPktTh: Determines the number of packet descriptors        */
     /* that can be stored in the PDC IPT Descriptor FIFO.           */
     /* range: 9:0, access type: RW, default value: 0x200            */
     SOC_PETRA_REG_FIELD idf_pkt_th;

     /* IdfSizeTh: Determines the number of bytes (in units of       */
     /* 32B) that can be stored in the PDC IPT Descriptor FIFO.      */
     /* range: 30:12, access type: RW, default value: 19'h7ffff      */
     SOC_PETRA_REG_FIELD idf_size_th;

     /* IdfUseSizeTh: If asserted, IDFSizeTh is used to              */
     /* determine the number of descriptors stored in the PDC        */
     /* IPT Descriptor FIFO. Otherwise, IPTPktTh is used.            */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD idf_use_size_th;

  } __ATTRIBUTE_PACKED__ ipt_data_fifo_configuration_reg;


  /* Global Time Counter: Gtimer configuration                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a66 */

     /* GtPrd: Global timer period. Gtimer expires after             */
     /* TimePrd. Default value equivalent to 1[sec] @ 250[Mhz]       */
     /* range: 30:0, access type: RW, default value: 31'hEE6B280     */
     SOC_PETRA_REG_FIELD gt_prd;

     /* GtRstCntrs: If asserted then all related counters are        */
     /* cleared when GtStrtTrg is asserted.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gt_rst_cntrs;

  } __ATTRIBUTE_PACKED__ global_time_counter_reg;


  /* Global Time Counter Trigger: Gtimer trigger.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a67 */

     /* GlbCntTrg: When set, the global-counter counter starts.      */
     /* Trigger is deasserted when counter expires.                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD glb_cnt_trg;

  } __ATTRIBUTE_PACKED__ global_time_counter_trigger_reg;


  /* Global Time Counter Configuration: Defines which               */
  /* counters count according to the global-timer.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a68 */

     /* MmuCntByGt: If set, then the MMU's counters count            */
     /* according to the GlobalTimer.                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mmu_cnt_by_gt;

  } __ATTRIBUTE_PACKED__ global_time_counter_configuration_reg;


  /* ECC Configuration register: This register is used for          */
  /* configuring MMU ECC                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0a70 */

     /* DisEcc: If set, disables the ECC mechanism in the block.     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_ecc;

  } __ATTRIBUTE_PACKED__ ecc_configuration_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_MMU_REGS;
/* Block definition: DRC */
typedef struct
{
  uint32   nof_instances; /* 6 */
  SOC_PETRA_REG_ADDR addr;

  /* DDR Controller Triggers: This register contains the DRC        */
  /* triggers needed for the reset and init (initialization)        */
  /* sequences.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1800 */

     /* DDRRstn: Perform a soft reset to all DRAM controller         */
     /* registers other than this register. When asserted,           */
     /* depending on the value of DDRDefValn, the configuration      */
     /* registers are loaded with either a hardware default          */
     /* value or the programmed value currently in the               */
     /* registers.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddrrstn;

     /* DDRDefValn: When negated after reset, the hardware           */
     /* defaults are loaded; Otherwise, the CPU programmed           */
     /* values are loaded.                                           */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddrdef_valn;

     /* DDRInitDis: If set, the DRC does not perform the init        */
     /* sequence after reset.                                        */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddrinit_dis;

     /* DDRCkeDis: If set, the DRC performs the init sequence        */
     /* without de-asserting the CKE signal towards the DRAM.        */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddrcke_dis;

  } __ATTRIBUTE_PACKED__ ddr_controller_triggers_reg;


  /* DDR Mode Register1: (See the DRAM data sheet for more          */
  /* details). The Mode register is written twice, once with        */
  /* this value and once with a second value. This is useful        */
  /* for resetting the DLL.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1801 */

     /* ModeRegWr1: The DDR init sequence requires two separate      */
     /* writes to the MR register. The register should contain       */
     /* the value of the DRAM MR register for the first write,       */
     /* as part of the init sequence.                                */
     /* range: 31:0, access type: RW, default value: 0x153           */
     SOC_PETRA_REG_FIELD mode_reg_wr1;

  } __ATTRIBUTE_PACKED__ ddr_mode_1_reg;


  /* DDR Mode Register2: (See the DRAM data sheet for more          */
  /* details). The Mode register is written twice, once with        */
  /* this value and once with a second value. This is useful        */
  /* for resetting the DLL.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1802 */

     /* ModeRegWr2: The DDR init sequence requires two separate      */
     /* writes to the MR register. The register should contain       */
     /* the value of the DRAM MR register for the second write,      */
     /* as part of the init sequence                                 */
     /* range: 31:0, access type: RW, default value: 0x53            */
     SOC_PETRA_REG_FIELD mode_reg_wr2;

  } __ATTRIBUTE_PACKED__ ddr_mode_2_reg;


  /* DDR Extended Mode Register1: This register contains the        */
  /* value written to the EMR during the DRAM init sequence.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1803 */

     /* ExtModeWr1: The DDR init sequence requires writing to        */
     /* the EMR register. The register should contain the value      */
     /* of the DRAM EMR register for the first write as part of      */
     /* the init sequence.                                           */
     /* range: 31:0, access type: RW, default value: 0x42            */
     SOC_PETRA_REG_FIELD ext_mode_wr1;

  } __ATTRIBUTE_PACKED__ ddr_extended_mode_1_reg;


  /* AC Operating Conditions1: This register contains DRAM          */
  /* parameter configurations.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1804 */

     /* DDRtRST: Number of clocks to wait after reset (in units      */
     /* of 32 clocks). The value 0 disables the mechanism.           */
     /* range: 13:0, access type: RW, default value: 0x765           */
     SOC_PETRA_REG_FIELD ddrt_rst;

     /* DDRtDLL: Number of clocks to wait for DLL stabilization      */
     /* (in units of 256 clocks). The value 0 disables the           */
     /* mechanism.                                                   */
     /* range: 21:14, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD ddrt_dll;

     /* DDRtRC: Period between the ACTIVE to the ACTIVE/AUTO         */
     /* REFRESH commands.                                            */
     /* range: 28:22, access type: RW, default value: 0x11           */
     SOC_PETRA_REG_FIELD ddrt_rc;

  } __ATTRIBUTE_PACKED__ ac_operating_conditions1_reg;


  /* AC Operating Conditions2: This register contains DRAM          */
  /* parameter configurations.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1805 */

     /* DDRtRRD: ACTIVE bank a to ACTIVE bank b command.             */
     /* range: 3:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD ddrt_rrd;

     /* DDRtRFC: AUTO REFRESH command period - the minimal time      */
     /* between the REFRESH command and the next ACTIVE command.     */
     /* range: 11:4, access type: RW, default value: 0x13            */
     SOC_PETRA_REG_FIELD ddrt_rfc;

     /* DDRtRCDR: ACTIVE to READ delay.                              */
     /* range: 16:12, access type: RW, default value: 0x5            */
     SOC_PETRA_REG_FIELD ddrt_rcdrd;

     /* DDRtRCDW: ACTIVE to WRITE delay.                             */
     /* range: 24:20, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD ddrt_rcdwr;

  } __ATTRIBUTE_PACKED__ ac_operating_conditions2_reg;


  /* Init Sequence Register: This register controls the             */
  /* number of clocks the DRC waits before issuing command to       */
  /* the DRAM during the init sequence.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1806 */

     /* InitWaitPRD: Wait period between commands during INIT        */
     /* sequence.                                                    */
     /* range: 6:0, access type: RW, default value: 0x20             */
     SOC_PETRA_REG_FIELD init_wait_prd;

  } __ATTRIBUTE_PACKED__ init_sequence_reg;


  /* AC Operating Conditions3: In the following register, if        */
  /* working with 16B bursts, BL=2. If working with 32B             */
  /* bursts, BL=4.(See the DRAM data sheet for details and          */
  /* for the timing diagram.)                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1807 */

     /* CntRASRDPRD: Period from Active command to a Read            */
     /* command with Auto Precharge (Should be calculated as         */
     /* DDRtRAS-BL.) DDRtRAS is a DRAM parameter                     */
     /* range: 6:0, access type: RW, default value: 0x9              */
     SOC_PETRA_REG_FIELD cnt_rasrdprd;

     /* CntRASWRPRD: Period from Active command to a write           */
     /* command with Auto Precharge (Should be calculated as         */
     /* DDRtRAS-BL-DDRtWR-DDRtWL) DDRtRAS and, DDRtWR are DRAM       */
     /* parameters. DDRtWL - DRAM Write latency (for GDDR1           */
     /* DDRtWL=1).                                                   */
     /* range: 13:7, access type: RW, default value: 0x6             */
     SOC_PETRA_REG_FIELD cnt_raswrprd;

     /* CntRDAPPRD: Period from a Read command with Auto             */
     /* Precharge untill the Precharge command period is over.       */
     /* (Should be calculated as BL+DDRtRP+max(DDRtRTP,2CK).)        */
     /* DDRtRP is a DRAM parameter.                                  */
     /* range: 19:14, access type: RW, default value: 0x9            */
     SOC_PETRA_REG_FIELD cnt_rdapprd;

     /* CntWRAPPRD: Period from a Write command with Auto            */
     /* Precharge untill the Precharge command period is over.       */
     /* (Should be calculated as BL+DDRtRP+DDRtWR+DDRtWL)            */
     /* DDRtRP, and DDRtWR are DRAM parameters. DDRtWL - DRAM        */
     /* Write latency (for GDDR1 DDRtWL=1).                          */
     /* range: 25:20, access type: RW, default value: 0xd            */
     SOC_PETRA_REG_FIELD cnt_wrapprd;

  } __ATTRIBUTE_PACKED__ ac_operating_conditions3_reg;


  /* CPU Commands: Allows cpu control over the DDR command          */
  /* bus (fallback for init sequence).                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1808 */

     /* BankAddress: The value to be put on the bus towards the      */
     /* DRAM when CpuCMDVld is set.                                  */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bank_address;

     /* Address: The value to be put on the bus towards the DRAM     */
     /* when CpuCMDVld is set.                                       */
     /* range: 17:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD address;

     /* We_n: The value to be put on the bus towards the DRAM        */
     /* when CpuCMDVld is set.                                       */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD we_n;

     /* Cas_n: The value to be put on the bus towards the DRAM       */
     /* when CpuCMDVld is set.                                       */
     /* range: 21:21, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cas_n;

     /* Ras_n_or_Ref_n: The value to be put on the bus towards       */
     /* the DRAM when CpuCMDVld is set.                              */
     /* range: 22:22, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ras_n_or_ref_n;

     /* Cs_n: The value to be put on the bus towards the DRAM        */
     /* when CpuCMDVld is set.                                       */
     /* range: 23:23, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cs_n;

     /* cke: The value to be put on the bus towards the DRAM         */
     /* when CpuCMDVld is set.                                       */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD cke;

     /* Res: The value to be put on the bus towards the DRAM         */
     /* when CpuCMDVld is set.                                       */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD res;

     /* Odt: The value to be put on the bus towards the DRAM         */
     /* when CpuCMDVld is set.                                       */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD odt;

     /* ConstVal: When asserted, forces the values in the cke,       */
     /* Res, and Odt fields permanently on the pins going to the     */
     /* DRAM (with no regard to CpuCMDVld).                          */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD const_val;

     /* StopBACCmds: When asserted, causes crdt signal from drc      */
     /* to bac to be de-asserted and prevents commands coming        */
     /* from bac from being inserted into the command queue          */
     /* fifo.                                                        */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stop_baccmds;

     /* CpuCMDVld: When asserted, causes the CPU command as          */
     /* represented in bits 26:0 to be output towards the DDR.       */
     /* It is asserted for one clock only and is then                */
     /* de-asserted by the DRC.                                      */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpu_cmdvld;

  } __ATTRIBUTE_PACKED__ cpu_commands_reg;


  /* Training Sequence: Controls the DRAM training sequence.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1809 */

     /* DDRTrnSeqGenPrd: Generation rate of training sequence in     */
     /* units of AUTO REFRESH command periods. Each time, an         */
     /* AUTO REFRESH command is executed; the counter is             */
     /* incremented by one. The value 0x0 disables the               */
     /* generation of the training sequences.                        */
     /* range: 12:0, access type: RW, default value: 0x10            */
     SOC_PETRA_REG_FIELD ddrtrn_seq_gen_prd;

     /* DDRTrnSeqGenNum: The number of training sequence reads,      */
     /* continuously after reset. This burst of training             */
     /* sequences should bring the aligner into the correct          */
     /* state.                                                       */
     /* range: 21:13, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD ddrtrn_seq_gen_num;

     /* StartTrainSeq: When asserted, causes the DRC to start        */
     /* the training sequence. The DRC de-asserts this bit.          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD start_train_seq;

  } __ATTRIBUTE_PACKED__ training_sequence_reg;


  /* Training Sequence Word: Training sequence word.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x180a */

     /* DDRTrnSeq: Training sequence word - bits [31:0]             */
     /* range: 31:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddrtrn_seq;

  } __ATTRIBUTE_PACKED__ training_sequence_word_reg[SOC_PETRA_DRAM_NOF_TRAIN_SEQ_WORDS_REGS];

  /* Training Sequence Address: This register controls the          */
  /* address the DRC will use for the training sequence.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1812 */

     /* TrnSeqAdd: The address to write the training sequence        */
     /* to.                                                          */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD trn_seq_add;

     /* TrnSeqAddVal: Valid bit for the address to write the         */
     /* training sequence. If the bit is reset, the register         */
     /* TrnSeqAdd is not used (the address of the last written       */
     /* write command is used)                                       */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD trn_seq_add_val;

  } __ATTRIBUTE_PACKED__ training_sequence_address_reg;


  /* DRC General Configurations: General configurations for         */
  /* the DRAM Controller.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1813 */

     /* NumCols: Determines the number of bits used for column       */
     /* addressing according to the following table: 0 : 8           */
     /* Column bits (256 columns) 1 : 9 Column bits (512             */
     /* columns) 2 : 10 Column bits (1024 columns) 3 : 11 Column     */
     /* bits (2048 columns) 4 : 12 Column bits (4096 columns)        */
     /* 5,6,7 : Reserved                                             */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD num_cols;

     /* APBitPos: Determines the position of the Auto Precharge      */
     /* bit in the address going to the DRAM according to the        */
     /* following table: 0 : AP is placed on addr[8] 1 : AP is       */
     /* placed on addr[9] 2 : AP is placed on addr[10] 3 : AP is     */
     /* placed on addr[11] 4 : AP is placed on addr[12] 5,6,7 :      */
     /* Reserved                                                     */
     /* range: 10:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD apbit_pos;

     /* RefreshBurstSize: The number of consecutive refresh          */
     /* commands performed by the DRC. The DRC accumulates           */
     /* refresh commands until it needs to perform                   */
     /* RefreshBurstSize commands in a single burst.                 */
     /* range: 15:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD refresh_burst_size;

     /* RefreshDelayPrd: The number of clocks the DRC waits          */
     /* between stopping the BAC commands and performing the         */
     /* refresh command. This delay period is to ensure that the     */
     /* DRC command fifo is empty when refresh commands are          */
     /* performed.                                                   */
     /* range: 29:24, access type: RW, default value: 0x14           */
     SOC_PETRA_REG_FIELD refresh_delay_prd;

  } __ATTRIBUTE_PACKED__ drc_general_configurations_reg;


  /* Write Read Rates: This register controls the minimum           */
  /* period between two consecutive commands and also               */
  /* configures tFAW and tZQCS parameters.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1814 */

     /* CntWrPrd: Minimum period between two successive Write        */
     /* commands (bursts) and is calculated as CntWrPrd + (Burst     */
     /* length / 2).                                                 */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnt_wr_prd;

     /* CntRdPrd: Minimum period between two successive Read         */
     /* commands (bursts) and is calculated as CntRdPrd + (Burst     */
     /* length / 2).                                                 */
     /* range: 13:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cnt_rd_prd;

     /* DDRtFAW: No more than 4 banks may be activated in a          */
     /* rolling tFAW window.                                         */
     /* range: 22:16, access type: RW, default value: 0x11           */
     SOC_PETRA_REG_FIELD ddrt_faw;

     /* DDRtZQCS: DDR3 only. Minimum period after ZQ calibration     */
     /* in which no other DRAM command can be performed.             */
     /* range: 31:24, access type: RW, default value: 0x40           */
     SOC_PETRA_REG_FIELD ddrt_zqcs;

  } __ATTRIBUTE_PACKED__ write_read_rates_reg;


  /* DRAM Compliance Configuration Register: This register is       */
  /* used to configure the different DRAM types supported by        */
  /* the DRC.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1815 */

     /* WrLatency: Write latency parameter. This register should     */
     /* receive (write latency - 1).                                 */
     /* range: 3:0, access type: RW, default value: 0x4              */
     SOC_PETRA_REG_FIELD wr_latency;

     /* BurstSizeMode: If this bit is asserted, the DRC accesses     */
     /* the DRAM in 16B bursts. Otherwise, 32B bursts are used.      */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD burst_size_mode;

     /* DRAMType: 0 : GDDR1 1 : GDDR3 2 : DDR2 3 : DDR3 4 :          */
     /* RLDRAM                                                       */
     /* range: 10:8, access type: RW, default value: 0x2             */
     SOC_PETRA_REG_FIELD dramtype;

     /* AddrTermHalf: If this bit is asserted, the address and       */
     /* command termination are set to 1/2 of ZQ. Otherwise, the     */
     /* termination is set to ZQ.                                    */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD addr_term_half;

     /* GDDR3DummyWrite: If this bit is asserted, the DRC            */
     /* perform a dummy MRS as required by Samsungs K4J55323QF       */
     /* device as part of its initialization sequence. Other         */
     /* devices might not require such a dummy command (Relevant     */
     /* for GDDR3 only).                                             */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gddr3_dummy_write;

     /* StaticOdtEn: If this bit is asserted, the DRC will           */
     /* assert the ODT pin after loading the extended mode           */
     /* register as part of the DRAM initialization sequence         */
     /* (relevant for DDR2 only).                                    */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD static_odt_en;

     /* DDRResetPolarity: If set, the reset signal towards the       */
     /* DRAM will be active high. Default is active low.             */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ddrreset_polarity;

     /* EnableWrLvl: If set, write leveling will be enabled as       */
     /* part of the init sequence (relevant for DDR3 only).          */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD enable_wr_lvl;

     /* Enable8Banks: This bit should be asserted when working       */
     /* with an 8-bank DRAM.                                         */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD enable8_banks;

  } __ATTRIBUTE_PACKED__ dram_compliance_configuration_reg;


  /* Extended Mode WR2 Register: The DDR2 init sequence             */
  /* requires three separate writes to the EMR register. The        */
  /* register should contain the value of the DRAM EMR              */
  /* register for the second write, as part of the init             */
  /* sequence (relevant for DDR2 only).                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1816 */

     /* ExtModeWr2: EMR Data                                         */
     /* range: 31:0, access type: RW, default value: 0x42            */
     SOC_PETRA_REG_FIELD ext_mode_wr2;

  } __ATTRIBUTE_PACKED__ extended_mode_wr2_reg;


  /* DDR2 Extended Mode WR3 Register: The DDR2 init sequence        */
  /* requires three separate writes to the EMR register. The        */
  /* register should contain the value of the DRAM EMR              */
  /* register for the third write, as part of the init              */
  /* sequence (relevant for DDR2 only).                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1817 */

     /* ExtModeWr3: EMR Data                                         */
     /* range: 31:0, access type: RW, default value: 0x42            */
     SOC_PETRA_REG_FIELD ext_mode_wr3;

  } __ATTRIBUTE_PACKED__ ddr2_extended_mode_wr3_reg;


  /* DDR Extended Mode Register2: This register should              */
  /* contain the value of the DRAM EMR2 register (relevant          */
  /* for DDR2).                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1818 */

     /* EMR2: EMR Data                                               */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD emr2;

  } __ATTRIBUTE_PACKED__ ddr_extended_mode_2_reg;


  /* DDR Extended Mode Register3: This register should              */
  /* contain the value of the DRAM EMR3 register (relevant          */
  /* for DDR2).                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1819 */

     /* EMR3: EMR3 Data                                              */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD emr3;

  } __ATTRIBUTE_PACKED__ ddr_extended_mode_3_reg;


  /* AC Operating Conditions4: This register contains DRAM          */
  /* parameter configurations.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x181a */

     /* DDRtREFI: Average periodic refresh interval, in units of     */
     /* 32 clocks. The value 0 disables the auto refresh             */
     /* mechanism.                                                   */
     /* range: 12:0, access type: RW, default value: 0x4a            */
     SOC_PETRA_REG_FIELD ddrt_refi;

     /* CntWRRDPRD: Period between a Write command and a Read        */
     /* command (Should be calculated as DDRtWL+BL+DDRtWTR)          */
     /* where DDRtWTR is a DRAM parameter.                           */
     /* range: 20:16, access type: RW, default value: 0x6            */
     SOC_PETRA_REG_FIELD cnt_wrrdprd;

     /* CntRDWRPRD: Period between the end of a read burst and a     */
     /* Write command. Does not include the 4 four cycles of the     */
     /* Read burst. (Should be calculated as DDRtCAS + DDRtPCB +     */
     /* 1)                                                           */
     /* range: 28:24, access type: RW, default value: 0x6            */
     SOC_PETRA_REG_FIELD cnt_rdwrprd;

  } __ATTRIBUTE_PACKED__ ac_operating_conditions4_reg;


  /* Odt Configuration Register: ZQ Calibration and Dynamic         */
  /* ODT configurations                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x181b */

     /* DDR3ZQCalibGenPrd: Generation rate of ZQ Calibration         */
     /* commands in units of AUTO REFRESH command periods. Each      */
     /* time an AUTO REFRESH command is executed; the counter is     */
     /* incremented by one. A value 0x0 disables the generation      */
     /* of the ZQ Calibration commands. (This register is            */
     /* relevant for DDR3 only.)                                     */
     /* range: 12:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ddr3_zqcalib_gen_prd;

     /* DynOdtStartDelay: This register can be used to determine     */
     /* when the external ODT pin is asserted in relation to the     */
     /* write command. If this register receives the same value      */
     /* as WrLatency, the ODT pin will be asserted one cycle         */
     /* before the write data. If this register is set to 0, the     */
     /* ODT pin will be asserted one cycle before the Write          */
     /* command.                                                     */
     /* range: 20:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dyn_odt_start_delay;

     /* DynOdtLength: This counter determines the number of          */
     /* clocks the external ODT pin will be asserted every write     */
     /* command. A value of 0x0 will cause the ODT pin to be a       */
     /* constant 0.                                                  */
     /* range: 28:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dyn_odt_length;

  } __ATTRIBUTE_PACKED__ odt_configuration_reg;

  /* Glue Logic register                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x181f */
     SOC_PETRA_REG_FIELD glue_logic_reg;
  } __ATTRIBUTE_PACKED__ glue_logic_reg;

  /* BIST Configurations: Configures the DRAM BIST.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1820 */

     /* WriteWeight: Number of successive write commands to be       */
     /* performed in a BIST cycle. Setting WriteWeight to 0          */
     /* results in no BIST write commands. If PatternBitMode is      */
     /* set, this parameter should be set to 1.                      */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD write_weight;

     /* ReadWeight: Number of successive read commands to be         */
     /* performed in a BIST cycle. Setting ReadWeight to 0           */
     /* results in no BIST read commands. If PatternBitMode is       */
     /* set, this parameter should be set to 1.                      */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD read_weight;

     /* PatternBitMode: If set, the BIST composes the write/read     */
     /* pattern in the following manner. For each cycle, a           */
     /* different bit is selected from the BIST pattern register     */
     /* in an incremental manner. This bit is duplicated on all      */
     /* of the DRAM data bus (all DQs receive the same bit).         */
     /* This allows a controllable pattern that is 256 write         */
     /* cycles long. If this bit is reset, the pattern used is       */
     /* BistPattern.                                                 */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pattern_bit_mode;

     /* TwoAddrMode: If this is bit is set, the address used by      */
     /* the BIST always alternates between BistStartAddress and      */
     /* BistEndAddress.                                              */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD two_addr_mode;

     /* PRBSMode: If this bit is set, the PRBS will be used to       */
     /* generate the pattern towards the DRAM                        */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD prbsmode;

     /* IndWrRdAddrMode: If this bit is set, the addresses for       */
     /* write and read commands will be incremented in an            */
     /* independent manner.                                          */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ind_wr_rd_addr_mode;

     /* BistEn: Enable the BIST                                      */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD bist_en;

  } __ATTRIBUTE_PACKED__ bist_configurations_reg;


  /* BIST Number Of Actions: Configures the DRAM BIST number        */
  /* of actions.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1821 */

     /* BistNumActions: The number of actions (writes or reads)      */
     /* to be performed by the BIST. Setting this register to 0      */
     /* causes the BIST to work in infinite mode                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_num_actions;

  } __ATTRIBUTE_PACKED__ bist_number_of_actions_reg;


  /* BIST Start Address: Configures the DRAM BIST Start             */
  /* Address.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1822 */

     /* BistStartAddress: The start address used by the BIST. If     */
     /* BistStartAddress equals BistEndAddress, the BIST always      */
     /* performs write and read commands to the same address.        */
     /* Otherwise, the address will start at BistStartAddress        */
     /* and be incremented every BIST cycle. When the address        */
     /* reaches BistEndAddress, the next address will once again     */
     /* be the BistStartAddress. The address is of the format:       */
     /* \{row, column, bank\} as configured in the NumCols           */
     /* register.                                                    */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_start_address;

  } __ATTRIBUTE_PACKED__ bist_start_address_reg;


  /* BIST End Address: Configures the DRAM BIST End Address.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1823 */

     /* BistEndAddress: The start address used by the BIST. If       */
     /* BistStartAddress equals BistEndAddress, the BIST always      */
     /* performs write and read commands to the same address.        */
     /* Otherwise the address will start at BistStartAddress and     */
     /* be incremented every BIST cycle. When the address            */
     /* reaches BistEndAddress, the next address will once again     */
     /* be the BistStartAddress. The address is of the format:       */
     /* \{row, column, bank\} as configured in the NumCols           */
     /* register.                                                    */
     /* range: 25:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_end_address;

  } __ATTRIBUTE_PACKED__ bist_end_address_reg;


  /* BIST Single Bit Mask: Configures the DRAM BIST Single          */
  /* Bit Mask.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1824 */

     /* BistSingleMask: Setting bit N in BistSingleMask results      */
     /* in SingleErrCnt incrementing if an error is discovered       */
     /* in bits N, N+32, N+64 . . . N+224 after a BIST read was      */
     /* performed                                                    */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_single_mask;

  } __ATTRIBUTE_PACKED__ bist_single_bit_mask_reg;


  /* BIST Pattern Word7: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1830 */

     /* BistPattern7: BIST Pattern word 7-BistPattern[31:0]          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern;

  } __ATTRIBUTE_PACKED__ bist_pattern_words_regs[SOC_PETRA_DRAM_NOF_PATTERN_REGS];


  /* BIST Pattern Word7: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1830 */

     /* BistPattern7: BIST Pattern word 7-BistPattern[31:0]          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern7;

  } __ATTRIBUTE_PACKED__ bist_pattern_word7_reg;


  /* BIST Pattern Word6: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1831 */

     /* BistPattern6: BIST Pattern word 6-BistPattern[63:32]         */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_pattern6;

  } __ATTRIBUTE_PACKED__ bist_pattern_word6_reg;


  /* BIST Pattern Word5: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1832 */

     /* BistPattern5: BIST Pattern word 5-BistPattern[95:64]         */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_pattern5;

  } __ATTRIBUTE_PACKED__ bist_pattern_word5_reg;


  /* BIST Pattern Word4: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1833 */

     /* BistPattern4: BIST Pattern word 4-BistPattern[127:96]        */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_pattern4;

  } __ATTRIBUTE_PACKED__ bist_pattern_word4_reg;


  /* BIST Pattern Word3: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1834 */

     /* BistPattern3: BIST Pattern word 3-BistPattern[159:128]       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern3;

  } __ATTRIBUTE_PACKED__ bist_pattern_word3_reg;


  /* BIST Pattern Word2: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1835 */

     /* BistPattern2: BIST Pattern word 2-BistPattern[191:160]       */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_pattern2;

  } __ATTRIBUTE_PACKED__ bist_pattern_word2_reg;


  /* BIST Pattern Word1: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1836 */

     /* BistPattern1: BIST Pattern word 1-BistPattern[223:192]       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern1;

  } __ATTRIBUTE_PACKED__ bist_pattern_word1_reg;


  /* BIST Pattern Word0: Configures the DRAM BIST Pattern.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1837 */

     /* BistPattern0: BIST Pattern word 0-BistPattern[255:224]       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD bist_pattern0;

  } __ATTRIBUTE_PACKED__ bist_pattern_word0_reg;

  /* BIST Full Mask Word7: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x1838 */

    /* BistFullMask7: BIST Full Mask word 7-BistFullMask[31:0].     */
    /* Setting bit N in BistFullMask results in FullErrCnt          */
    /* incrementing if an error is discovered in bit N after a      */
    /* BIST read is performed                                       */
    /* range: 31:0, access type: RW, default value: 32'hffffffff    */
    SOC_PETRA_REG_FIELD bist_full_mask;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word_reg[SOC_PETRA_DRAM_NOF_PATTERN_REGS];


  /* BIST Full Mask Word7: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1838 */

     /* BistFullMask7: BIST Full Mask word 7-BistFullMask[31:0].     */
     /* Setting bit N in BistFullMask results in FullErrCnt          */
     /* incrementing if an error is discovered in bit N after a      */
     /* BIST read is performed                                       */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask7;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word7_reg;


  /* BIST Full Mask Word6: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1839 */

     /* BistFullMask6: BIST Full Mask word                           */
     /* 6-BistFullMask[63:32]. Setting bit N in BistFullMask         */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask6;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word6_reg;


  /* BIST Full Mask Word5: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183a */

     /* BistFullMask5: BIST Full Mask word                           */
     /* 5-BistFullMask[95:64]. Setting bit N in BistFullMask         */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask5;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word5_reg;


  /* BIST Full Mask Word4: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183b */

     /* BistFullMask4: BIST Full Mask word                           */
     /* 4-BistFullMask[127:96]. Setting bit N in BistFullMask        */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask4;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word4_reg;


  /* BIST Full Mask Word3: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183c */

     /* BistFullMask3: BIST Full Mask word                           */
     /* 3-BistFullMask[159:128]. Setting bit N in BistFullMask       */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask3;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word3_reg;


  /* BIST Full Mask Word2: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183d */

     /* BistFullMask2: BIST Full Mask word                           */
     /* 2-BistFullMask[191:160]. Setting bit N in BistFullMask       */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask2;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word2_reg;


  /* BIST Full Mask Word1: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183e */

     /* BistFullMask1: BIST Full Mask word                           */
     /* 1-BistFullMask[223:192]. Setting bit N in BistFullMask       */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask1;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word1_reg;


  /* BIST Full Mask Word0: Configures the DRAM BIST Full            */
  /* Mask.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x183f */

     /* BistFullMask0: BIST Full Mask word                           */
     /* 0-BistFullMask[255:224]. Setting bit N in BistFullMask       */
     /* results in FullErrCnt incrementing if an error is            */
     /* discovered in bit N after a BIST read is performed           */
     /* range: 31:0, access type: RW, default value: 32'hffffffff    */
     SOC_PETRA_REG_FIELD bist_full_mask0;

  } __ATTRIBUTE_PACKED__ bist_full_mask_word0_reg;


  /* BIST Statuses: Statuses coming from the DRAM BIST.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1840 */

     /* BistFinished: This bit is set when BIST has completed        */
     /* BistNumActions actions. The bit will never be asserted       */
     /* if working in infinite mode (BistNumActions == 0). This      */
     /* register is clear on read.                                   */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD bist_finished;

  } __ATTRIBUTE_PACKED__ bist_statuses_reg;


  /* BIST Full Mask Error Counter:                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1841 */

     /* FullErrCnt: This counter is incremented if an error is       */
     /* discovered in bit N after a BIST read command and bit N      */
     /* is not masked by BistFullMask. The counter stops at          */
     /* saturation. The counter is reset when BIST is enabled        */
     /* and after that it can be cleared by the CPU. This            */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD full_err_cnt;

  } __ATTRIBUTE_PACKED__ bist_full_mask_error_counter_reg;


  /* BIST Single Bit Mask Error Counter:                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1842 */

     /* SingleErrCnt: This counter is incremented if an error is     */
     /* discovered in bits N, N+32, N+64 . . . N+224 after a         */
     /* BIST read command and bit N is not masked by                 */
     /* BistSingleMask. The counter stops at saturation. The         */
     /* counter is reset when BIST is enabled and after that it      */
     /* can be cleared by the CPU. This register is clear on         */
     /* read.                                                        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD single_err_cnt;

  } __ATTRIBUTE_PACKED__ bist_single_bit_mask_error_counter_reg;


  /* BIST Error Occurred:                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1843 */

     /* ErrOccurred: Bit N in this register is set if an error       */
     /* occurs in bits N, N+32, N+64 . . . N+224 after a BIST        */
     /* read command. The register is reset when BIST is enabled     */
     /* and after that it can be cleared by the CPU. This            */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD err_occurred;

  } __ATTRIBUTE_PACKED__ bist_error_occurred_reg;


  /* BIST Global Error Counter:                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1844 */

     /* GlobalErrCnt: This counter is incremented if any error       */
     /* is discovered after a BIST read command. The counter         */
     /* stops at saturation. The counter is reset when BIST is       */
     /* enabled and after that it can be cleared by the CPU.         */
     /* This register is clear on read.                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD global_err_cnt;

  } __ATTRIBUTE_PACKED__ bist_global_error_counter_reg;


  /* Training Sequence Configuration Register: This register        */
  /* is used to configure the number of addresses used as           */
  /* part of the training sequence.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x1858 */

     /* TrainSeqAddrNum: Specifies the number of addresses used      */
     /* as part of the training sequence in units of 64              */
     /* addresses.                                                   */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD train_seq_addr_num;

     /* TrainSeqUsePRBS: If set, uses a PRBS pattern for the         */
     /* first part of the training sequence.                         */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD train_seq_use_prbs;

  } __ATTRIBUTE_PACKED__ training_sequence_configuration_reg;

  /* Duty Cycle:                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x18b0 */

     /* range: 1:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD dcf_a;
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dcf_p;
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dcf_disable;

  } __ATTRIBUTE_PACKED__ dcf;

} __ATTRIBUTE_PACKED__ SOC_PETRA_DRC_REGS;
/* Block definition: DPI */
typedef struct
{
  uint32   nof_instances; /* 6 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c00 */

     /* DpiErrorInt: dpi and phy training error indication           */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD dpi_error_int;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c10 */

     /* DpiErrorIntMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dpi_error_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered. Address:                          */
  /* 0x0020-0x00210x0020 is used for writing bits 31:0.0x0021       */
  /* is used for writing bits 55:32.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c20 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered. Address:                          */
  /* 0x0020-0x00210x0020 is used for writing bits 31:0.0x0021       */
  /* is used for writing bits 55:32.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c21 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 23:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation. Address: 0x0030-0x00310x0030 is used for        */
  /* writing bits 31:0.0x0031 is used for writing bits 55:32.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c30 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation. Address: 0x0030-0x00310x0030 is used for        */
  /* writing bits 31:0.0x0031 is used for writing bits 55:32.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c31 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 23:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c40 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then the last command failed on             */
     /* timeout.                                                     */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c41 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform:             */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* DPRC enable (A2 and above):                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c52 */

     /* DPRC enable. This bit is valid starting revision 2           */
     /* and above.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dprc_en;

  } __ATTRIBUTE_PACKED__ dprc_enable_reg;

  /* Dpi Init Start:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c60 */

     /* DpiInitStart: Start PHY initialization sequence.-            */
     /* Setting this bit causes the initialization sequence for      */
     /* the PHY DLL and data synchronization blocks.                 */
     /* range: :, access type: D, default value: 0x0                 */
     SOC_PETRA_REG_FIELD dpi_init_start;

  } __ATTRIBUTE_PACKED__ dpi_init_start_reg;


  /* dpi_init_reset:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c61 */

     /* dpi_init_reset: Reset DPI and PHY initialization logic       */
     /* range: :, access type: D, default value: 0x0                 */
     SOC_PETRA_REG_FIELD dpi_init_reset;

  } __ATTRIBUTE_PACKED__ dpi_init_reset_reg;


  /* dpi_init_status: DPI and PHY status register                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c62 */

     /* ready: PHY and DPI initialization done indication            */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ready;

     SOC_PETRA_REG_FIELD init_dn;

     SOC_PETRA_REG_FIELD dll_mstr_s;

  } __ATTRIBUTE_PACKED__ dpi_init_status_reg;

  /* dll_control: DLL control register                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c62 */

     /* range: 31:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD dll_control;

  } __ATTRIBUTE_PACKED__ dll_control_reg;


  /* ddl Periodic Training Register: Enable automatic               */
  /* periodic update and training of the DLL                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c64 */

     /* ddl_auto_trn_en: Enable automatic periodic training of       */
     /* the DDL                                                      */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD ddl_auto_trn_en;

  } __ATTRIBUTE_PACKED__ ddl_periodic_training_reg;


  /* ddl1_ctrl: DDL1 control Register                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c65 */

     /* PredefEn: predefined phase select override enable            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD predef_en;

     /* PredefMainPhSel: predefined 4 phase generator output         */
     /* phase selection                                              */
     /* range: 2:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD predef_main_ph_sel;

     /* PredefPh2Sel: predefined phase selection for synclk2         */
     /* clock gating                                                 */
     /* range: 4:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD predef_ph2_sel;

     /* unused4: unused                                              */
     /* range: 10:5, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD unused4;

     /* PredefDlSelHg: predefined half granularity vector            */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD predef_dl_sel_hg;

     /* PredefDlSelVec: predefined delay override count              */
     /* range: 19:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD predef_dl_sel_vec;

     /* PredefDlHcSelVec: predefined delay half cycle override       */
     /* count                                                        */
     /* range: 27:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD predef_dl_hc_sel_vec;

     /* PredefDlQcSelVec: predefined delay quarter cycle             */
     /* override count                                               */
     /* range: 31:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD predef_dl_qc_sel_vec;

  } __ATTRIBUTE_PACKED__ ddl_ctrl_reg_0[SOC_PETRA_DRAM_NOF_DLL_REGS];


  /* ddl1_ctrl: DDL1 control Register                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c66 */

     /* PredefDlQcSelVec: predefined delay quarter cycle             */
     /* override count                                               */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD predef_dl_qc_sel_vec;

     /* statPredefMode: status register to reflect predef ctrl       */
     /* required information                                         */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD stat_predef_mode;

     /* predefPhUp: predefined phase up selection                    */
     /* range: 8:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD predef_ph_up;

     /* predefPhDn: predefined phase dn selection                    */
     /* range: 12:9, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD predef_ph_dn;

     /* TqcX8StepEn: Enable X8 step on Tqc dlwalk                    */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tqc_x8_step_en;

     /* fastDlwalkInc: defines the increment for delay line walk     */
     /* 00-1, 01-2, 10-3, 11-4, can be used for saving lock time     */
     /* and for faster tracking in cases where the jitter is         */
     /* larger                                                       */
     /* range: 15:14, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD fast_dlwalk_inc;

     /* PhselMargin: predefined margin for the phase selection       */
     /* process in order to ensure safe selection counted in         */
     /* delay elements                                               */
     /* range: 17:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD phsel_margin;

     /* SelMargin: upper and lower limit margin                      */
     /* range: 19:18, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD sel_margin;

     /* TrainTrigThreshold: threshold for re-training trigger,       */
     /* can be programmed to 1/4 cycle +offset, where the offset     */
     /* can be 0,4,8,12 according to the programing of this          */
     /* field                                                        */
     /* range: 21:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD train_trig_threshold;

     /* TrainTrigEn: training trigger mode enable                    */
     /* range: 22:22, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD train_trig_en;

     /* unused7: unused                                              */
     /* range: 24:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD unused7;

     /* unused5: unused                                              */
     /* range: 27:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD unused5;

     /* PhselHcUp: phase selection selection for higher phase        */
     /* option                                                       */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD phsel_hc_up;

     /* unused6: unused                                              */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD unused6;

     /* unused1: unused                                              */
     /* range: 30:30, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD unused1;

     /* DlyMaxminMode: select maximum minimum peek detection on      */
     /* the status regsiter                                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dly_maxmin_mode;

  } __ATTRIBUTE_PACKED__ ddl_ctrl_reg_1[SOC_PETRA_DRAM_NOF_DLL_REGS];


  /* ddl1_ctrl: DDL1 control Register                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c67 */

     /* InsDlyCompThreshold: Insertion delay compensation            */
     /* threshold                                                    */
     /* range: 5:0, access type: RW, default value: 0xa              */
     SOC_PETRA_REG_FIELD ins_dly_comp_threshold;

     /* unused2: unused                                              */
     /* range: 9:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD unused2;

     /* PredefInsDlyMinVec: predefined Insertion delay               */
     /* compensation vector                                          */
     /* range: 15:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD predef_ins_dly_min_vec;

  } __ATTRIBUTE_PACKED__ ddl_ctrl_reg_2[SOC_PETRA_DRAM_NOF_DLL_REGS];

  /* ddl1_stat_lsb_reg: Dune debug internal register                        */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c71 */

    SOC_PETRA_REG_FIELD ph_sel;

    SOC_PETRA_REG_FIELD main_ph_sel;

    SOC_PETRA_REG_FIELD ph2_sel;

    SOC_PETRA_REG_FIELD dly_maxmin_mode;

    SOC_PETRA_REG_FIELD phsel_error;

    SOC_PETRA_REG_FIELD hc_sel_vec;

    SOC_PETRA_REG_FIELD sel_vec;

    SOC_PETRA_REG_FIELD sel_hg;

    SOC_PETRA_REG_FIELD qc_sel_vec_0;
  } __ATTRIBUTE_PACKED__ ddl1_stat_lsb_reg[SOC_PETRA_DRAM_NOF_DLL_REGS];

  /* ddl1_stat_msb_reg: Dune debug internal register                        */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c72 */

    SOC_PETRA_REG_FIELD qc_sel_vec_1;

    SOC_PETRA_REG_FIELD train_trigger;

    SOC_PETRA_REG_FIELD ph_up;

    SOC_PETRA_REG_FIELD phsel_hc_up;

    SOC_PETRA_REG_FIELD unused1;

    SOC_PETRA_REG_FIELD ins_dly_min_vec;
  } __ATTRIBUTE_PACKED__ ddl1_stat_msb_reg[SOC_PETRA_DRAM_NOF_DLL_REGS];


  /* Read Gap Mask:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c79 */

     SOC_PETRA_REG_FIELD read_gap_mask;

  } __ATTRIBUTE_PACKED__ read_gap_mask_reg;

  /* IoConfig: IO Configuration reister                             */

  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c7f */

    /* : octet 0 termination control                                */
    /* range: 1:1, access type: RW, default value: 0x1              */
    SOC_PETRA_REG_FIELD tximp45_oct0;

    /* : octet 0 pulldown                                           */
    /* range: 2:2, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD pd50_oct0;

    /* : octet 0 pullup                                             */
    /* range: 3:3, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD pu50_oct0;

    /* : octet 1 termination control                                */
    /* range: 5:5, access type: RW, default value: 0x1              */
    SOC_PETRA_REG_FIELD tximp45_oct1;

    /* : octet 1 pulldown                                           */
    /* range: 6:6, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD pd50_oct1;

    /* : octet 1 pullup                                             */
    /* range: 7:7, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD pu50_oct1;

    /* : octet 2 termination control                                */
    /* range: 9:9, access type: RW, default value: 0x1              */
    SOC_PETRA_REG_FIELD tximp45_oct2;

    /* : octet 2 pulldown                                           */
    /* range: 10:10, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD pd50_oct2;

    /* : octet 2 pullup                                             */
    /* range: 11:11, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD pu50_oct2;

    /* : octet 3 termination control                                */
    /* range: 13:13, access type: RW, default value: 0x1            */
    SOC_PETRA_REG_FIELD tximp45_oct3;

    /* : octet 3 pulldown                                           */
    /* range: 14:14, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD pd50_oct3;

    /* : octet 3 pullup                                             */
    /* range: 15:15, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD pu50_oct3;

    /* : control bus termination control                            */
    /* range: 17:17, access type: RW, default value: 0x1            */
    SOC_PETRA_REG_FIELD tximp45_ctrl;

    /* : control bus pulldown                                       */
    /* range: 18:18, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD pd50_ctrl;

    /* : control bus pullup                                         */
    /* range: 19:19, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD pu50_ctrl;

    /* : clock bus termination control                              */
    /* range: 21:21, access type: RW, default value: 0x1            */
    SOC_PETRA_REG_FIELD tximp45_ck;

    /* : clock bus pulldown                                         */
    /* range: 22:22, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD pd50_ck;

    /* : clock bus pullup                                           */
    /* range: 23:23, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD pu50_ck;

    /* : enable ODT vref for vref pad                               */
    /* range: 28:28, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD enodtvref;

    /* : enable output for all pads, in default and reset, the      */
    /* pads are disabled                                            */
    /* range: 31:31, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD enable_outputs;

  } __ATTRIBUTE_PACKED__ io_config_reg;

  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c80 */

     SOC_PETRA_REG_FIELD cr;

  } __ATTRIBUTE_PACKED__ io_calibration_status_reg;



  /* Io Odt Read Config: IO ODT Read configuration                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c81 */

     /* ioOdtReadRiseAloc: Read signal for IO ODT activation         */
     /* allocation, counted from the command time at DPI             */
     /* interface. Setting this field to Zero and the                */
     /* ioOdtReadFallAloc field to 5'h1f will result in ODT          */
     /* always asserted.                                             */
     /* range: 4:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD io_odt_read_rise_aloc;

     /* ioOdtReadFallAloc: Read signal for IO ODT activation         */
     /* allocation, counted from the command time at DPI             */
     /* interface. Setting this field to Zero and the                */
     /* ioOdtReadFallAloc field to 5'h1f will result in ODT          */
     /* always asserted.                                             */
     /* range: 9:5, access type: RW, default value: 0x6              */
     SOC_PETRA_REG_FIELD io_odt_read_fall_aloc;

     /* ioOdtReadRiseOfset: Read signal for IO ODT activation        */
     /* allocation, counted relative to data valid on the DPI        */
     /* loop delay, bit #14 selects up or down ofset (1 - up, 0      */
     /* -down)                                                       */
     /* range: 14:10, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD io_odt_read_rise_ofset;

     /* ioOdtReadFallOfset: Read signal for IO ODT de-activation     */
     /* allocation, counted relative to data valid on the DPI        */
     /* loop delay, bit #19 selects up or down ofset (1 - up, 0      */
     /* -down)                                                       */
     /* range: 19:15, access type: RW, default value: 0x10           */
     SOC_PETRA_REG_FIELD io_odt_read_fall_ofset;

     /* ioOdtReadOfsetEn: Read signal ofset allocation mode          */
     /* enable                                                       */
     /* range: 20:20, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD io_odt_read_ofset_en;

     /* ioOdtDisable: disable ODT signal, when set the ODT will      */
     /* not be activated                                             */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD io_odt_disable;

  } __ATTRIBUTE_PACKED__ io_odt_read_config_reg;

  /* DPI General Config                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c82 */

     /* range: 31:0, access type: RW                                */
     SOC_PETRA_REG_FIELD dpi_general_config;

  } __ATTRIBUTE_PACKED__ dpi_general_config_reg;


  /* Ddr Phy Mode: DDR PHY mode selection register                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c83 */

     /* Gddr3Mode: GDDR3 mode enable                                 */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD gddr3_mode;

     /* Ddr3Mode: ddr3 mode enable                                   */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ddr3_mode;

  } __ATTRIBUTE_PACKED__ ddr_phy_mode_reg;

  /* dpi_rnd_trp_status_reg: Dune debug internal register                */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c84 */

    SOC_PETRA_REG_FIELD rnd_trp[SOC_PETRA_DRAM_NOF_RND_TRP_FLDS];
  } __ATTRIBUTE_PACKED__ dpi_rnd_trp_status_reg;

  /* dpi_rnd_trp_diff_status_reg: Dune debug internal register                */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c85 */

    SOC_PETRA_REG_FIELD rnd_trp_diff[SOC_PETRA_DRAM_NOF_RND_TRP_DIFF_FLDS];
  } __ATTRIBUTE_PACKED__ dpi_rnd_trp_diff_status_reg;

  /* ddio_bit_align_control_reg: Dune debug internal register                */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x0c87 */

    SOC_PETRA_REG_FIELD shift_val;
  } __ATTRIBUTE_PACKED__ ddio_bit_align_control_reg[SOC_PETRA_DRAM_NOF_SHIFT_REGS];

  /* Dpi Retrain:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0c8b */

     /* DpiRetrain: Start PHY training sequence.- Setting this       */
     /* bit causes the training sequence without DLL re-init.        */
     /* range: :, access type: D, default value: 0x0                 */
     SOC_PETRA_REG_FIELD dpi_retrain;

  } __ATTRIBUTE_PACKED__ dpi_retrain_reg;

  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg;

  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_DPI_REGS;
/* Block definition: FDR */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit(A-for links 0-17 ,B-for          */
  /* links 18-35).                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e00 */

     /* FDRAdesccntoA: Discard cell counter overflow                 */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdradesccnto_a;

     /* FDRAUnExpCell: Unexpected cell error in links 0-17           */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdraun_exp_cell;

     /* IfmafoA: IFMA-FIFO-overflow. Note that if the IFM FIFO       */
     /* overflows, cells are not being overwritten.                  */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ifmafo_a;

     /* IfmbfoA: IFMB-FIFO-overflow. Note that if the IFM FIFO       */
     /* overflows, cells are not being overwritten.                  */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ifmbfo_a;

     /* CpudatacellfneA0: links 0-11 CPU-FIFO-non-Empty (this        */
     /* bit is not AC).                                              */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudatacellfne_a0;

     /* CpudatacellfneA1: Links 12-17 CPU-FIFO-non-Empty (this       */
     /* bit is not AC).                                              */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudatacellfne_a1;

     /* AltoA: One of links status went down-(registers 0x2369       */
     /* and 0x236a)                                                  */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD alto_a;

     /* FdraOutOfSync: Irrecoverable error in the FDR (links         */
     /* 17-0)                                                        */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_out_of_sync;

     /* FdraTagEccErr: ECC error occurred in the FDR descriptor      */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_tag_ecc_err;

     /* FdraFilrterDropINTA: Cells droped in the error filter of     */
     /* macra                                                        */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_filrter_drop_inta;

     /* FdraFilrterDropINTB: Cells droped in the error filter of     */
     /* macrb                                                        */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdra_filrter_drop_intb;

     /* FDRAdesccntoB: Discard cell counter overflow                 */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdradesccnto_b;

     /* FDRBUnExpCell: Unexpected cell error in links18-35           */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrbun_exp_cell;

     /* IfmafoB: IFMA-FIFO-overflow. Note that if the IFM FIFO       */
     /* overflows, cells are not being overwritten.                  */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ifmafo_b;

     /* IfmbfoB: IFMB-FIFO-overflow. Note that if the IFM FIFO       */
     /* overflows, cells are not being overwritten.                  */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ifmbfo_b;

     /* CpudatacellfneB0: Links 24-35 CPU-FIFO-non-Empty (this       */
     /* bit is not AC).                                              */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpudatacellfne_b0;

     /* CpudatacellfneB1: Links 18-23 CPU-FIFO-non-Empty (this       */
     /* bit is not AC).                                              */
     /* range: 21:21, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpudatacellfne_b1;

     /* AltoB : One of links status went down (registers 0x2369      */
     /* and 0x236a)                                                  */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD alto_b_;

     /* FdrbOutOfSync : Irrecoverable error in the FDR (links        */
     /* 35-18)                                                       */
     /* range: 23:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_out_of_sync_;

     /* FdrbTagEccErr: ECC error occurred in the FDR descriptor      */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_tag_ecc_err;

     /* FdrbFilrterDropINTA: Cells droped in the error filter of     */
     /* macra                                                        */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_filrter_drop_inta;

     /* FdrbFilrterDropINTB: Cells droped in the error filter of     */
     /* macrb                                                        */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_filrter_drop_intb;

     /* FdrOutpuOutOfSync: Irrecoverable error in the FDR output     */
     /* range: 30:30, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_outpu_out_of_sync;

     /* FdrOutTagEccErr: ECC error occurred in the FDR               */
     /* descriptor                                                   */
     /* range: 31:31, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_out_tag_ecc_err;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e10 */

     /* FDRAdesccntoAIntMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdradesccnto_aint_mask;

     /* FDRAUnExpCellIntMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdraun_exp_cell_int_mask;

     /* IfmafoAIntMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ifmafo_aint_mask;

     /* IfmbfoAIntMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD ifmbfo_aint_mask;

     /* CpudatacellfneA0IntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudatacellfne_a0_int_mask;

     /* CpudatacellfneA1IntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudatacellfne_a1_int_mask;

     /* AltoIntmask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD alto_intmask;

     /* FdraOutOfSyncIntMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_out_of_sync_int_mask;

     /* FdraTagEccErrIntMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_tag_ecc_err_int_mask;

     /* FdraFilrterDropINTAMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 9:9, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD fdra_filrter_drop_intamask;

     /* FdraFilrterDropINTBMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 10:10, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdra_filrter_drop_intbmask;

     /* FDRBdesccntoBIntMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrbdesccnto_bint_mask;

     /* FDRBUnExpCellIntMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrbun_exp_cell_int_mask;

     /* IfmafoBIntMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ifmafo_bint_mask;

     /* IfmbfoBIntmask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ifmbfo_bintmask;

     /* CpudatacellfneB0IntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpudatacellfne_b0_int_mask;

     /* CpudatacellfneB1IntMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 21:21, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpudatacellfne_b1_int_mask;

     /* AltoBIntMask: Writing 0 masks the corresponding              */
     /* interrupt source.                                            */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD alto_bint_mask;

     /* FdrbOutOfSyncIntMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 23:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_out_of_sync_int_mask;

     /* FdrbTagEccErrIntMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_tag_ecc_err_int_mask;

     /* FdrbFilrterDropINTAMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_filrter_drop_intamask;

     /* FdrbFilrterDropINTBMask: Writing 0 masks the                 */
     /* corresponding interrupt source.                              */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrb_filrter_drop_intbmask;

     /* FdrOutpuOutOfSyncIntMask: Writing 0 masks the                */
     /* corresponding interrupt source.                              */
     /* range: 30:30, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_outpu_out_of_sync_int_mask;

     /* FdrOutTagEccErrIntMask: Writing 0 masks the                  */
     /* corresponding interrupt source.                              */
     /* range: 31:31, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdr_out_tag_ecc_err_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;

  /* Fdr Enablers Register: Fdr command enabler                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e60 */

     SOC_PETRA_REG_FIELD bits_1_0;

     /* FDRMtchAct: Match-Action[1:0] 0: Count and forward 1:        */
     /* Count and discard 2: Count and Trapp 3: Count and Trapp      */
     /* and forward                                                  */
     /* range: 29:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrmtch_act;


     /* FDRMtchLogicnot: Inverts match filter logic.                 */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrmtch_logicnot;


  } __ATTRIBUTE_PACKED__ fdr_enablers_reg;


  /* Programmable Data Cell Counter0: Match filter to capture       */
  /* data cells to the cpu according to the match                   */
  /* action,Looks at bits 311:280 of the data cell.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e61 */

     /* PCMtchLb0:                                                   */
     /* Program-Counter-Match-Data-Cells-Labels0-match mask for      */
     /* bytes 0-3 of labels                                          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_lb0;

  } __ATTRIBUTE_PACKED__ programmable_data_cell_counter0_reg;


  /* Programmable Data Cell Counter1: Match filter to capture       */
  /* data cells to the cpu according to the match                   */
  /* action,Looks at bits 279:248 of the data cell.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e62 */

     /* PCMtchLb1: PC-Match-Data-Cells-Labels1[31:0]-match mask      */
     /* for bytes 4-7 of labels.                                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_lb1;

  } __ATTRIBUTE_PACKED__ programmable_data_cell_counter1_reg;


  /* Programmable Data Cell Counter Mask0: Filter                   */
  /* mask-masking for the match filter , for masking                */
  /* irrelevant bits for the filter (Looks at bits 311:280 of       */
  /* the data cell.)                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e63 */

     /* PCMtchMsk0: PC-Match-Data-Cells-Mask#0[31:0]don't care       */
     /* bits' mask for bytes 0-3.                                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_msk0;

  } __ATTRIBUTE_PACKED__ programmable_data_cell_counter_mask0_reg;


  /* Programmable Data Cell Counter Mask1: Filter                   */
  /* mask-masking for the match filter , for masking                */
  /* irrelevant bits for the filter (Looks at bits 279-248 of       */
  /* the data cell.)                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e64 */

     /* PCMtchMsk1: PC-Match-Data-Cells-Mask#0[31:0];don't care      */
     /* bits mask for bytes 4-7.                                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_msk1;

  } __ATTRIBUTE_PACKED__ programmable_data_cell_counter_mask1_reg;


  /* Link Level Flow Control: Link-level flow-control               */
  /* threshold.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e65 */

     /* LnkLvlFcTh: The threshold at which to activate link          */
     /* level flow control                                           */
     /* range: 7:0, access type: RW, default value: 0x78             */
     SOC_PETRA_REG_FIELD lnk_lvl_fc_th;

  } __ATTRIBUTE_PACKED__ link_level_flow_control_reg;


  /* Filter Match Input Link: Filter 3 -match filter to             */
  /* capture data cells to the cpu according to the match           */
  /* action. Defines the option to trap cells from input link        */
  /* or cells with a CRC error.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e66 */

     /* PcMtchLink: Input link for the match filter                  */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pc_mtch_link;

     /* PcMtchLinkOn: Enable bit for the link match                  */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pc_mtch_link_on;

     /* CrcMtchOn: Capture cells arriving with CRC errors from       */
     /* the MAC receive.                                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD crc_mtch_on;

     /* DataMtchOn: Capture only data cells that match the           */
     /* filter                                                       */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD data_mtch_on;

  } __ATTRIBUTE_PACKED__ filter_match_input_link_reg;


  /* Programmable Cells Counter: Programmable-Cells-Counter         */
  /* -count all the cells trapped by the match filter.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e68 */

     /* PrgCellCnt: Programmable-Cells-Counter This 31-bit           */
     /* counter holds the number of matched cells. The counter       */
     /* does not stop at saturation.                                 */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prg_cell_cnt;

     /* PrgCellCntO: Programmable-Cells-Counter-Overflow This        */
     /* bit is set when the counter exceeds 31 bits.                 */
     /* range: 31:31, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD prg_cell_cnt_o;

  } __ATTRIBUTE_PACKED__ programmable_cells_counter_reg;


  /* Link Up Status From Fdra: FDRA links up signals                */
  /* -indicates that the FDR report those links as active           */
  /* links.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e69 */

     /* FDRLinkUpB: Reflects the Link "up" bitmap as computed        */
     /* and used by the FDR. (Link must be "up" for cells to be      */
     /* sent through.) for links 0-17.                               */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fdrlink_up_a;

  } __ATTRIBUTE_PACKED__ link_up_status_from_fdra_reg;


  /* Link Up Status From Fdrb: FDRB links up signals                */
  /* -indicate that the FDR report those links as active            */
  /* link.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e6a */

     /* FDRLinkUpB: Reflects the Link "up" bitmap as computed        */
     /* and used by the FDR. (Link must be "up" for cells to be      */
     /* sent through.) for links 18-35.                              */
     /* range: 17:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fdrlink_up_b;

  } __ATTRIBUTE_PACKED__ link_up_status_from_fdrb_reg;


  /* FDROverflows And Fifos Statuses FDRA: Fifos overflow           */
  /* indications for links 0-17.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e6b */

     /* CPUDataCellFOA0: CPU-buffer-FIFO-overflow. Note that if      */
     /* the CPU buffer overflows, this means that the newly          */
     /* arrived cell is discarded and then the overflow flag is      */
     /* set.                                                         */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudata_cell_foa0;

     /* CPUDataCellFOA1: CPU-buffer-FIFO-overflow. Note that if      */
     /* the CPU buffer overflows, this means that the newly          */
     /* arrived cell is discarded and then the overflow flag is      */
     /* set.                                                         */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudata_cell_foa1;

     /* MaxIFMAF: Maximum-IFM-FIFO-occupancy. The maximal number     */
     /* of cells that occurred in one of the IFM FIFOs since the     */
     /* last time this register was read. The value is reset         */
     /* when read.(links 11:0)                                       */
     /* range: 9:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD max_ifmaf;

     /* MaxIFMBF: Maximum-IFM-FIFO-occupancy. The maximal number     */
     /* of cells that occurred in one of the IFM FIFOs since the     */
     /* last time this register was read. The value is reset         */
     /* when read.(links 17:12)                                      */
     /* range: 17:10, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD max_ifmbf;

     /* MaxIFMFANum: The IFM FIFO that had the maximum occupancy      */
     /* reported in the above. This register is clear on read.       */
     /* range: 21:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD max_ifmfanum;

     /* MaxIFMFBNum: The IFM FIFO that had the maximum occupancy      */
     /* reported in the above. This register is clear on read.       */
     /* range: 25:22, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD max_ifmfbnum;

  } __ATTRIBUTE_PACKED__ fdroverflows_and_fifos_statuses_fdra_reg;


  /* FDROverflows And Fifos Statuses Fdr B: Fifos overflow          */
  /* indications for links 18-35.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e6c */

     /* CPUDataCellFOB0: CPU-buffer-FIFO-overflow. Note that if      */
     /* the CPU buffer overflows, this means that the newly          */
     /* arrived cell is discarded and then the overflow flag is      */
     /* set.                                                         */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudata_cell_fob0;

     /* CPUDataCellFOB1: CPU-buffer-FIFO-overflow. Note that if      */
     /* the CPU buffer overflows, this means that the newly          */
     /* arrived cell is discarded and then the overflow flag is      */
     /* set.                                                         */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpudata_cell_fob1;

     /* MaxIFMAF: Maximum-IFM-FIFO-occupancy. The maximal number     */
     /* of cells that occurred in one of the IFM FIFOs since the     */
     /* last time this register was read. The value is reset         */
     /* when read.(links 35:24)                                      */
     /* range: 8:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD max_ifmaf;

     /* MaxIFMBF: Maximum-IFM-FIFO-occupancy. The maximal number     */
     /* of cells that occurred in one of the IFM FIFOs since the     */
     /* last time this register was read. The value is reset         */
     /* when read.(links 23:18)                                      */
     /* range: 17:10, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD max_ifmbf;

     /* MaxIFMFANum: The IFM FIFO that had the maximum occupancy      */
     /* reported in the above. This register is clear on read.       */
     /* range: 21:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD max_ifmfanum;

     /* MaxIFMFBNum: The IFM FIFO that had the maximum occupancy      */
     /* reported in the above. This register is clear on read.       */
     /* range: 25:22, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD max_ifmfbnum;

  } __ATTRIBUTE_PACKED__ fdroverflows_and_fifos_statuses_fdr_b_reg;


  /* Local Fifo Rci Level: FDR fifo rci level -sets the             */
  /* threshold per link fifo that will assert rci flow              */
  /* control to the scheduler.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e6f */

     /* RciLowLevel: Set the threshold per link fifo that assert     */
     /* rci flow control [0] to the scheduler . The value 0          */
     /* disables the fdr rci                                         */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rci_low_level;

     /* RciHighLevel: Set the threshold per link fifo that           */
     /* assert rci flow control [1] to the scheduler . The value      */
     /* 0 disables the fdr rci                                       */
     /* range: 22:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rci_high_level;

  } __ATTRIBUTE_PACKED__ local_fifo_rci_level_reg;


  /* Cpu Data Cell A: LINKS 0-11 CPU-FIFO-cells.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e70 - 0x2e79 */

     /* CPUDataCellA: CPU-FIFO-cells[311:0] from side A of FDRA      */
     /* Cells captured for the CPU are stored in a 312-bit- wide     */
     /* FIFO. The CPU read a 312-bit cell by reading ten 32-bit      */
     /* words. When reading word-9, the cell FIFO is advanced.       */
     /* CPUCellWord0= \{Data_cell[319:318],Data_cell[309:280]\}      */
     /* CPUCellWord1= \{Data_cell[279:248]\}                         */
     /* CPUCellWord9=\{Data_cell[23:8], 16'h0\}                      */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpudata_cell_a;

  } __ATTRIBUTE_PACKED__ cpu_data_cell_a_reg[SOC_PETRA_NOF_TRANSMIT_DATA_CELLS_REGISTERS];


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg;


  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg;


  /* Cpu Data Cell B: LINKS 12-17 CPU-FIFO-cells.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e80 - 0x2e89 */

     /* CPUDataCellB: CPU-FIFO-cells[311:0] from side B of FDRA      */
     /* Cells captured for the CPU are stored in a 312-bit- wide     */
     /* FIFO. The CPU read a 312-bit cell by reading ten 32-bit      */
     /* words. When reading word-9, the cell FIFO is advanced.       */
     /* CPUCellWord0= \{Data_cell[319:318],Data_cell[309:280]\}      */
     /* CPUCellWord1= \{Data_cell[279:248]\}                         */
     /* CPUCellWord9=\{Data_cell[23:8], 16'h0\}                      */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpudata_cell_b;

  } __ATTRIBUTE_PACKED__ cpu_data_cell_b_reg[SOC_PETRA_NOF_TRANSMIT_DATA_CELLS_REGISTERS];


  /* Cpu Data Cell C: LINKS 18-23 CPU-FIFO-cells.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2e90 - 0x2e99 */

     /* CPUDataCellC: CPU-FIFO-cells[311:0] from side B of FDRB      */
     /* Cells captured for the CPU are stored in a 312-bit- wide     */
     /* FIFO. The CPU read a 312-bit cell by reading ten 32-bit      */
     /* words. When reading word-9, the cell FIFO is advanced.       */
     /* CPUCellWord0= \{Data_cell[319:318],Data_cell[309:280]\}      */
     /* CPUCellWord1= \{Data_cell[279:248]\}                         */
     /* CPUCellWord9=\{Data_cell[23:8], 16'h0\}                      */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpudata_cell_c;

  } __ATTRIBUTE_PACKED__ cpu_data_cell_c_reg[SOC_PETRA_NOF_TRANSMIT_DATA_CELLS_REGISTERS];



  /* Cpu Data Cell D: LINKS 24-35 CPU-FIFO-cells                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2ea0 - 0x2ea9 */

     /* CPUDataCellD: CPU-FIFO-cells[311:0] from side A of FDRB      */
     /* Cells captured for the CPU are stored in a 312-bit- wide     */
     /* FIFO. The CPU read a 312-bit cell by reading ten 32-bit      */
     /* words. When reading word-9, the cell FIFO is advanced.       */
     /* CPUCellWord0= \{Data_cell[319:318],Data_cell[309:280]\}      */
     /* CPUCellWord1= \{Data_cell[279:248]\}                         */
     /* CPUCellWord9=\{Data_cell[23:8], 16'h0\}                      */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpudata_cell_d;

  } __ATTRIBUTE_PACKED__ cpu_data_cell_d_reg[SOC_PETRA_NOF_TRANSMIT_DATA_CELLS_REGISTERS];


  /* FDRFifo Discard Counter B: Fdr discard counter -counts         */
  /* all discarded cells.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2eb1 */

     /* FDRDescCntB: FDR-FIFO-Discard Counter The counter does       */
     /* not stop at saturation. For links 18:35 This register is     */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fdrdesc_cnt_b;

     /* FDRDescCntOB: FDR-FIFO-Discard Counter Overflow For          */
     /* links 28:35 This register is clear on read.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdrdesc_cnt_ob;

  } __ATTRIBUTE_PACKED__ fdrfifo_discard_counter_b_reg;


  /* Error Filter: Fdr error filter , enable filtering error        */
  /* cells before sending to the egq                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2eb2 */

     /* ErrorFilter: Error filter, enable filtering error on the     */
     /* packet or cell header before transmitting to the egq.        */
     /* Enable filtering cell size, header bits 319:264 and 8B       */
     /* packet Header                                                */
     /* range: 127:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_filter;

  } __ATTRIBUTE_PACKED__ error_filter_reg;


  /* Error Filter Mask: Fdr error filter Mask, masking non          */
  /* relevant bits in the filter                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2eb6 */

     /* ErrorFilterMask: Error filter , enable masking non           */
     /* relevant bits in the cell                                    */
     /* range: 127:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_filter_mask;

  } __ATTRIBUTE_PACKED__ error_filter_mask_reg;


  /* Error Filter Mask En: Fdr error filter Mask activation         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2eba */

     /* ErrorFilterMaskEn: Error filter enable                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD error_filter_mask_en;

  } __ATTRIBUTE_PACKED__ error_filter_mask_en_reg;


  /* Error Filter Cnt: Fdr error filter cell counter                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2ebb */

     /* ErrorFilterCnt: Count number of dropped cells This           */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD error_filter_cnt;

     /* ErrorFilterCntO: Counter over flow This register is          */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD error_filter_cnt_o;

  } __ATTRIBUTE_PACKED__ error_filter_cnt_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_FDR_REGS;
/* Block definition: FDT */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c00 */

     /* UnrchDestEvt: Unreachable-Destination-Event. Set when a       */
     /* packet arrives at the FDT but there is no valid link to      */
     /* forward it through. The data of the packet is written to     */
     /* the UnrchDest register. It is an interrupt source, and       */
     /* is cleared when UnrchDest is read.                           */
     /* range: 0:0, access type: RO , default value: 0x0             */
     SOC_PETRA_REG_FIELD unrch_dest_evt;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c10 */

     /* UnrchDestEvtIntMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD unrch_dest_evt_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Indirect Command Rd Data0: Data returned by an indirect        */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c30 */

     /* IndirectCommandRdData0: Indirect read data.                  */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data0;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data0_reg;


  /* Indirect Command Rd Data1: Data returned by an indirect        */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c31 */

     /* IndirectCommandRdData1: Indirect read data.                  */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data1;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data1_reg;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c40 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c41 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation.                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* Fdt Enabler Register: fdt enabler.                             */
   /* Solve the Fdt Enabler Register Errata causing bit-shift        */
  /* on read. When reading, bits 4 - 31 appear as 3 - 30.           */
  /* Bits 0 - 2 are read OK                                         */
  /* Note: it is wrong to access this register using                */
  /* soc_petra_write_fld, since it performs Read-Modify-Write.          */
  /* Instead, read the whole register register, use                 */
  /* SOC_PETRA_REGS_FDT_ENABLER_READ_ADJUST macro to adjust the value,  */
  /* modify and write                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c60 */

     /* DiscardDllPkts: If set, all packets read out of IPT are      */
     /* discarded. The default value 0x1 ensures that no messages     */
     /* are sent before the FAP's Chip-ID is written. After           */
     /* initialization, DiscAllPkts should be reset.                 */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD discard_dll_pkts;

     /* SegmentPkt: Don't touch                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD segment_pkt;

     /* DelCrcPkt: If set, the last fabric cell of packets           */
     /* detected with CRC errors when read from the DRAM will        */
     /* not be sent into the fabric. The packet size in the           */
     /* header, therefore, will not coincide with the packet         */
     /* size arriving at the egress FAP, and the packet will be      */
     /* deleted.                                                     */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD del_crc_pkt;

     /* ContextStat: Define the context number that the              */
     /* statistics counter count.                                    */
     /* range: 6:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD context_stat;

     /* UseCoexInMulticast: Enable coexist in multicast ,If set,     */
     /* all multicast ids are considered as coexisting.              */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD use_coex_in_multicast;

     /* MaskTdmBmp: Enable masking the rtp all reachable             */
     /* destination bitmap for tdm trafic .                          */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_tdm_bmp;

     /* DisLclrt: disable local rout trafic for tdm cells ,all       */
     /* tdm traffic include local traffic will go to the fabric      */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_lclrt;

     /* RandLimkEn: Enable using random mechanism of link            */
     /* selection for tdm packets                                    */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rand_limk_en;

     /* ForceAllLocal: Enable forcing all TDM trafic to the          */
     /* local interface                                              */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD force_all_local;

  } __ATTRIBUTE_PACKED__ fdt_enabler_reg;


  /* Transmitted Data Cells Counter: Counts all transmitted         */
  /* data cells.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c61 */

     /* DataCellCnt: Data-Cell-Counter. This 31-bit counter holds     */
     /* the number of data cells transmitted to the MACT (in 32B     */
     /* cell for FSC and 128B for VSC ). The counter does not         */
     /* stop at saturation. The counter is reset when read. This      */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD data_cell_cnt;

     /* DataCellCnt0: Data-Cell-Counter-Overflow. This bit is set     */
     /* when the counter exceeds 31 bits. Overflow flag is            */
     /* cleared when read. This register is clear on read.           */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD data_cell_cnt0;

  } __ATTRIBUTE_PACKED__ transmitted_data_cells_counter_reg;


  /* Unreachable Destination Discarded Cells Counter: This          */
  /* register keeps the first destination that is unreachable       */
  /* from this source FAP.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c62 */

     /* UnrchDest: Unreachable destination.                          */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD unrch_dest;

     /* UnrchDestCnt: Unreachable destination counter. This          */
     /* register is clear on read.                                   */
     /* range: 28:13, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD unrch_dest_cnt;

     /* UnrchDestCnto: Unreachable destination counter overflow.     */
     /* This register is clear on read.                              */
     /* range: 29:29, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD unrch_dest_cnto;

  } __ATTRIBUTE_PACKED__ unreachable_destination_discarded_cells_counter_reg;


  /* Context Cell Counter: Requested context cell counter.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c63 */

     /* ContextCellCnt: Count cells for selected context . The       */
     /* context number is defined in register 0x2460. This           */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD context_cell_cnt;

     /* ContextCellCnto: Context cells counter overflow. This        */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD context_cell_cnto;

  } __ATTRIBUTE_PACKED__ context_cell_counter_reg;


  /* Cpu Data Cell: Writes source routed data cell from the         */
  /* CPU (16'h0081-16'h008a).                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c81 - 0x2c8a */

     /* CPUDataCell: The data cell is written in big-endian          */
     /* format (all dont care bits are removed and the rest are      */
     /* shifted to the MSB).                                         */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpudata_cell;

  } __ATTRIBUTE_PACKED__ cpu_data_cell_reg[SOC_PETRA_NOF_TRANSMIT_DATA_CELLS_REGISTERS];

  /* Transmit Cell Output Link Number: This register contains       */
  /* the output link-number (out of 36 links) for the               */
  /* source-routed data cell.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c8b */

     /* CpuLinkNum: The output link number (0-35) for the CPU        */
     /* cell.                                                        */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_link_num;

     /* CpuCellSize: The Cell Size of the cpu cell that will be      */
     /* transmit in VCS (the relevant data is only 32B all other     */
     /* bits will set to 0 ).                                        */
     /* range: 14:8, access type: RW, default value: 0x3f            */
     SOC_PETRA_REG_FIELD cpu_cell_size;

  } __ATTRIBUTE_PACKED__ transmit_cell_output_link_number_reg;


  /* Transmit Data Cell Trigger: This register contains the         */
  /* trigger object for transmitting a source-routed data           */
  /* cell.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c8c */

     /* CpuTrg: If set Triggers a cell transmit. Is reset once        */
     /* the cell is transmitted, or when output link number is       */
     /* bigger than 35.                                              */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_trg;

  } __ATTRIBUTE_PACKED__ transmit_data_cell_trigger_reg;


  /* Coexist Dupx2 Unicast Bitmap: 128-bits bitmap. Holds one       */
  /* bit for each of the first 256 destination ids, to              */
  /* indicate if the destination is a coexist destination.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2c90 */

     /* CoexistDupx2UnicastBitmap: 128-bits bitmap. Holds one        */
     /* bit for each of the first 256 destination ids, to            */
     /* indicate if the destination is a coexist destination.        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD coexist_dupx2_unicast_bitmap;

  } __ATTRIBUTE_PACKED__ coexist_dupx2_unicast_bitmap_reg[SOC_PETRA_NOF_COEXIST_MAP_REGS];



  /* Tdm Link Mask: Tdm links mask bitmap                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2ca9 */

     /* TdmLinkMask: Bitmap for masking the all reachable             */
     /* destination bitmap from the rtp for tdm cells output         */
     /* link This register is clear on read.                         */
     /* range: 35:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_link_mask;

  } __ATTRIBUTE_PACKED__ tdm_link_mask_reg[SOC_PETRA_NOF_BIT_PER_LINK_REGS];


  /* Crc Droped Pck Cnt: Counts all crc packets with size           */
  /* less then 128B that droped in the fdt                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2cab */

     /* CrcDropedPckCnt: Crc-Droped-Packet- Counter. This 31-bit      */
     /* counter holds the number of data packets with size           */
     /* snaller then 128B with crc errorr that dropped in the fdt     */
     /* This register is clear on read.                              */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crc_droped_pck_cnt;

     /* CrcDropedPckCnt0: Crc-Droped-Packet-                         */
     /* Counter-Overflow. This bit is set when the counter            */
     /* exceeds 31 bits. Overflow flag is cleared when read. This     */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crc_droped_pck_cnt0;

  } __ATTRIBUTE_PACKED__ crc_droped_pck_cnt_reg;


  /* Tdm Cells Counter: Counts all transmitted TDM cells.           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2cac */

     /* TdmDataCellCnt: TDM-Data-Cell-Counter. This 31-bit            */
     /* counter holds the number of TDM cells transmitted to the     */
     /* MACT . The counter does not stop at saturation. The            */
     /* counter is reset when read. This register is clear on        */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_data_cell_cnt;

     /* TdmDataCellCnt0: TDM-Data-Cell-Counter-Overflow. This bit     */
     /* is set when the counter exceeds 31 bits. Overflow flag is     */
     /* cleared when read. This register is clear on read.           */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_data_cell_cnt0;

  } __ATTRIBUTE_PACKED__ tdm_cells_counter_reg;


  /* Local Tdm Cells Counter: Counts all transmitted TDM            */
  /* local cells.                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x2cad */

     /* LocalTdmDataCellCnt: Local-TDM-Data-Cell-Counter. This        */
     /* 31-bit counter holds the number of TDM cells transmitted     */
     /* to the EGQ . The counter does not stop at saturation. The      */
     /* counter is reset when read. This register is clear on        */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD local_tdm_data_cell_cnt;

     /* LocalTdmDataCellCnt0: Local                                  */
     /* -TDM-Data-Cell-Counter-Overflow. This bit is set when the     */
     /* counter exceeds 31 bits. Overflow flag is cleared when        */
     /* read. This register is clear on read.                        */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD local_tdm_data_cell_cnt0;

  } __ATTRIBUTE_PACKED__ local_tdm_cells_counter_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_FDT_REGS;
/* Block definition: FCR */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3200 */

     /* SrcDvCngLinkEv: Source device change link event One of       */
     /* the 36 link connectivity map entries has changed. Auto        */
     /* cleared when SrcDvCngLink is read. Note that after            */
     /* connecting to the fabric after system power up, this bit     */
     /* is set.                                                      */
     /* range: 0:0, access type: RC, default value: 0x1              */
     SOC_PETRA_REG_FIELD src_dv_cng_link_ev;

     /* CPUCntCellFNE: CPU-Control-FIFO not empty. The register       */
     /* presents the non-empty state of the FIFO and is cleared      */
     /* only when the last word is read from the FIFO.               */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpucnt_cell_fne;

     /* LocalRoutFsOvf: Local route flow status fifo over flow       */
     /* event ,Cleared when reading LocalRoutOvfCnt register.        */
     /* range: 2:2, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD local_rout_fs_ovf;

     /* LocalRoutrcOvf: Local route reach fifo over flow event       */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD local_routrc_ovf;

     /* ReachFifoOvf: Reachability fifo over flow event              */
     /* range: 4:4, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD reach_fifo_ovf;

     /* FlowFifoOvf: flow status fifo over flow event                */
     /* range: 5:5, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD flow_fifo_ovf;

     /* CreditFifoOvf: credit fifo over flow event                   */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD credit_fifo_ovf;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3210 */

     /* SrcDvCngLinkEvintMsk: Writing 0 masks the corresponding      */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD src_dv_cng_link_evint_msk;

     /* CPUCntCellFNEintMsk: Writing 0 masks the corresponding       */
     /* interrupt source                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpucnt_cell_fneint_msk;

     /* LocalRoutfsOvfintMsk: Writing 0 masks the corresponding      */
     /* interrupt source                                             */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD local_routfs_ovfint_msk;

     /* LocalRoutrcOvfintMsk: Writing 0 masks the corresponding      */
     /* interrupt source                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD local_routrc_ovfint_msk;

     /* ReachFifoovfintMsk: Writing 0 masks the corresponding        */
     /* interrupt source                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD reach_fifoovfint_msk;

     /* FlowFifoovfintMsk: Writing 0 masks the corresponding         */
     /* interrupt source                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD flow_fifoovfint_msk;

     /* CreditFifoovfintMsk: Writing 0 masks the corresponding       */
     /* interrupt source                                             */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD credit_fifoovfint_msk;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Gtimer Configuration register : clock timer to enable          */
  /* counting cells in specific time period.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3254 */

     /* TimeCountConfig: time period that all the counters           */
     /* count. when using this timer, the overflow bit of each       */
     /* counter indicate the end of the time count                   */
     /* range: 30:0, access type: RW, default value: 31'hee6b27f     */
     SOC_PETRA_REG_FIELD time_count_config;

     /* CounterReset: Reset all gtimers counters.                    */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD counter_reset;

  } __ATTRIBUTE_PACKED__ gtimer_configuration_reg;


  /* Activate Gtimer: Start counters that defines as gtimer.        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3255 */

     /* ActivateGtimer: Starts counters that are defined as          */
     /* gtimer.                                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD activate_gtimer;

  } __ATTRIBUTE_PACKED__ activate_gtimer_reg;


  /* FCREnablers And Filter Match Input Link: fcr command           */
  /* enabler                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3260 */

     /* DisFlSts: Discard-Queue/Flow-Status-control cells.           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_fl_sts;

     /* DisCrdFCR: Discard-Credit-Cells.                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_crd_fcr;

     /* DisSR: Discard-Source-Routed control cells.                  */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_sr;

     /* TrapAllCnt: Trap-All control cells to the CPU.               */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD trap_all_cnt;

     /* MtchAct: Match-Action for programmable filter 0: Count       */
     /* and forward 1: Count and discard 2: Count and Trap 3:        */
     /* Count, Trap and forward (Copy).                              */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mtch_act;

     /* FCRMtchLogicNot: If set, reverses the logic of the           */
     /* programmable filter.                                         */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fcrmtch_logic_not;

     /* PcMtchLink: Input link for the match filter.                 */
     /* range: 12:7, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pc_mtch_link;

     /* PcMtchLinkOn: Enable bit for the link match.                 */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pc_mtch_link_on;

     /* FcrCountByGtimer: Enables using gtimer for status            */
     /* counters.                                                    */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fcr_count_by_gtimer;

  } __ATTRIBUTE_PACKED__ fcrenablers_and_filter_match_input_link_reg;


  /* Connectivity Map Change Event Registers0: Source device        */
  /* changed 0 - holds one bit per link to indicate if the          */
  /* source connected to links changed (for links31:0)              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3261 */

     /* SrcDvCngLinkL: A bit that is asserted indicates that a       */
     /* change occurs in the corresponding connectivity map          */
     /* register (SrcDvCngLink[0]=Link0...). Interrupt source.for       */
     /* links 0 to 31 . The interrupt is cleared after reading       */
     /* SrcDvCngLinkH This register is clear on read.                */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD src_dv_cng_link_l;

  } __ATTRIBUTE_PACKED__ connectivity_map_change_event_registers0_reg;


  /* Connectivity Map Change Event Registers1: Source device        */
  /* changed 1 - holds one bits per link to indicate if the         */
  /* source connected to links changed (for links35:32)             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3262 */

     /* SrcDvCngLinkH: A bit that is asserted indicates that a       */
     /* change occurs in the corresponding connectivity map          */
     /* register (SrcDvCngLink[0]=Link0...). Interrupt source.for       */
     /* links 32 to 35 . The interrupt will be cleared after         */
     /* reading the SrcDvCngLinkH This register is clear on          */
     /* read.                                                        */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD src_dv_cng_link_h;

  } __ATTRIBUTE_PACKED__ connectivity_map_change_event_registers1_reg;


  /* Fap20b Destination Id Bitmap: This 128-bit bitmap Holds        */
  /* one bit for 128 first device ids to indicate wheter the        */
  /* source device is fap20b (1 is fap20b).                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3263 */

     /* Fap20bDestinationIdBitmap: This 128-bit bitmap Holds one     */
     /* bit for 128 first device ids to indicate wheter the          */
     /* source device is fap20b (1 is fap20b).                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fap20b_destination_id_bitmap;

  } __ATTRIBUTE_PACKED__ fap20b_destination_id_bitmap_reg[SOC_PETRA_NOF_FAP20B_MAP_REGS];


  /* Connectivity Map Registers: The connectivity table holds       */
  /* the source device that is connected to each link               */
  /* (16'h0070-16'h0093, link #1 - address 70 , link #35 -          */
  /* address 93)                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3270 */

     /* SourceDeviceID: Source Device ID of link N                   */
     /* (0=<N<=35). The unique programmable ID of the downstream      */
     /* device. (With this value one can know the device ID          */
     /* connected to this link.)                                     */
     /* range: 10:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD source_unit;

     /* SourceDeviceLevel: Source Device Level of link N.            */
     /* Indicates the source of the cell.x0x => FOP, 010 => FE3,     */
     /* X11 => FE2, 110 =>FE1                                        */
     /* range: 13:11, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD source_device_level;

     /* SourceDeviceLink: Source Device Link Number of link N        */
     /* The link number of the source device.                        */
     /* range: 19:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD source_device_link;

  } __ATTRIBUTE_PACKED__ connectivity_map_registers_reg[SOC_PETRA_FBR_NOF_LINKS];


  /* Credit Cells Counter: Credit-Cells-Counter -gtimer.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3294 */

     /* CreditCellsCounter: Credit-Cells-Counter. This register      */
     /* is clear on read.                                            */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD credit_cells_counter;

     /* CreditCellsCounterOvf: Credit Cells Counter over flow        */
     /* indication. This register is clear on read.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD credit_cells_counter_ovf;

  } __ATTRIBUTE_PACKED__ credit_cells_counter_reg;


  /* Flow Status Cells Counter: Flow Status-Cells-Counter           */
  /* -gtimer.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3295 */

     /* FsCellsCounter: Flow status-Cells-Counter. This register     */
     /* is clear on read.                                            */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fs_cells_counter;

     /* FsCellsCounterOvf: Flow status Cells Counter over flow       */
     /* indication. This register is clear on read.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_cells_counter_ovf;

  } __ATTRIBUTE_PACKED__ flow_status_cells_counter_reg;


  /* Reachability Cells Counter: Reachability-Cells-Counter -       */
  /* gtimer.                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3296 */

     /* ReachCellsCounter: Reachability-Cells-Counter. This          */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD reach_cells_counter;

     /* ReachCellsCounterOvf: Reachability Cells Counter over        */
     /* flow indication. This register is clear on read.             */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD reach_cells_counter_ovf;

  } __ATTRIBUTE_PACKED__ reachability_cells_counter_reg;


  /* Total Cells Counter: Total-Cells-Counter -gtimer.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3298 */

     /* TotalCellsCounter: Total-Cells-Counter. This register is     */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_cells_counter;

     /* TotalCellsCounterOvf: Total Cells Counter over flow          */
     /* indication. This register is clear on read.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD total_cells_counter_ovf;

  } __ATTRIBUTE_PACKED__ total_cells_counter_reg;


  /* Cell Drop Counter0: Dropped cells counter 0 -count the         */
  /* dropped credits and flow status cells.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3299 */

     /* CreditDropCount: Credit_drop_count -counts dropped cells     */
     /* according to fifo overflow. This register is clear on        */
     /* read.                                                        */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD credit_drop_count;

     /* CreditDropCountOvf: Credit drop counter overflow             */
     /* indication. This register is clear on read.                  */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD credit_drop_count_ovf;

     /* FsDropCount: Fs_drop_count -counts dropped cells             */
     /* according to fifo overflow. This register is clear on        */
     /* read.                                                        */
     /* range: 30:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_drop_count;

     /* FsDropCountOvf: Flow status drop counter overflow            */
     /* indication. This register is clear on read.                  */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD fs_drop_count_ovf;

  } __ATTRIBUTE_PACKED__ cell_drop_counter0_reg;


  /* Cell Drop Counter1: Dropped cells counter 1 -counts the        */
  /* dropped reachability cells.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x329a */

     /* ReachDropCount: Reach_drop_count -counts dropped cells       */
     /* according to fifo overflow. This register is clear on        */
     /* read.                                                        */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD reach_drop_count;

     /* ReachDropCountOvf: Reachability drop counter overflow        */
     /* indication. This register is clear on read.                  */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD reach_drop_count_ovf;

  } __ATTRIBUTE_PACKED__ cell_drop_counter1_reg;


  /* Programmable Control Cell Counter0: The following six          */
  /* registers, define a filter (compare value and mask) to         */
  /* be applied to all incoming control cells. Depending on          */
  /* the match or lack of it, an action is triggered as             */
  /* programmed. This is useful for debugging.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a1 */

     /* PCMtchCtrlLb0: PC-Match-Ctrl-Cells-Labels0 Match mask        */
     /* for bits [77:46] of cell.                                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_ctrl_lb0;

  } __ATTRIBUTE_PACKED__ programmable_control_cell_counter0_reg;


  /* Programmable Control Cell Counter1:                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a2 */

     /* PCMtchCtrlLb1: PC-Match-Ctrl-Cells-Labels1 Match mask        */
     /* for bits [45:14] of cell.                                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_ctrl_lb1;

  } __ATTRIBUTE_PACKED__ programmable_control_cell_counter1_reg;


  /* Programmable Control Cell Counter2:                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a3 */

     /* PCMtchCtrlLb2: PC-Match-Ctrl-Cells-Labels1 Match mask        */
     /* for bits [13:8] of cell.                                     */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pcmtch_ctrl_lb2;

  } __ATTRIBUTE_PACKED__ programmable_control_cell_counter2_reg;


  /* Programmable Control Cell Counter Mask0: The mask              */
  /* registers mask the Don't Care bits in the filter.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a4 */

     /* PCMtchCtrlMsk0: PC-Match-Ctrl-Cells-Mask0 Don't care         */
     /* bits mask for bits [77:46] of cell.                          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_ctrl_msk0;

  } __ATTRIBUTE_PACKED__ programmable_control_cell_counter_mask0_reg;


  /* Programmable Control Cell Counter Mask1:                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a5 */

     /* PCMtchCtrlMsk1: PC-Match-Ctrl-Cells-Mask1 Don't care         */
     /* bits mask for bits [45:14] of cell.                          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pcmtch_ctrl_msk1;

  } __ATTRIBUTE_PACKED__ programmable_control_cell_counter_mask1_reg;


  /* Programmable Control Cell Counter Mask2:                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a6 */

     /* PCMtchCtrlMsk2: PC-Match-Ctrl-Cells-Mask2 Don't care         */
     /* bits mask for bits [13:8] of cell.                           */
     /* range: 5:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pcmtch_ctrl_msk2;

  } __ATTRIBUTE_PACKED__ programmable_control_cell_counter_mask2_reg;


  /* Programmable Cells Counter: Programmable-Cells-Counter         */
  /* -gtimer.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a7 */

     /* PrgCtrlCellCnt: Programmable-Cells-Counter. This             */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prg_ctrl_cell_cnt;

     /* PrgCtrlCellCnto: Programmable-Cells-Counter overflow.        */
     /* This register is clear on read.                              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD prg_ctrl_cell_cnto;

  } __ATTRIBUTE_PACKED__ programmable_cells_counter_reg;


  /* Control Cell FIFOBuffer: CPU-Control-FIFO-cells[77:8]          */
  /* -Cells captured for the CPU are stored in a 70-bit wide        */
  /* FIFO.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32a9 */

     /* ControlCellFIFOBuffer: CPU-Control-FIFO-cells[77:8]          */
     /* -Cells captured for the CPU are stored in a 70-bit wide      */
     /* FIFO. The CPU may read a 70-bit cell by reading three        */
     /* 32-bit words. When reading word-2 the cell FIFO is           */
     /* advanced. (Word-0 contains cell[77:46], word-1 contains      */
     /* cell[45:14], and word-2 contains cell[13:8] and 26 '0'       */
     /* bits.)                                                       */
     /* range: 31:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD control_cell_fifobuffer;

  } __ATTRIBUTE_PACKED__ control_cell_fifobuffer_reg_0;


  /* Control Cell FIFOBuffer: CPU-Control-FIFO-cells[77:8]          */
  /* -Cells captured for the CPU are stored in a 70-bit wide        */
  /* FIFO.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32aa */

     /* ControlCellFIFOBuffer: CPU-Control-FIFO-cells[77:8]          */
     /* -Cells captured for the CPU are stored in a 70-bit wide      */
     /* FIFO. The CPU may read a 70-bit cell by reading three        */
     /* 32-bit words. When reading word-2 the cell FIFO is           */
     /* advanced. (Word-0 contains cell[77:46], word-1 contains      */
     /* cell[45:14], and word-2 contains cell[13:8] and 26 '0'       */
     /* bits.)                                                       */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD control_cell_fifobuffer;

  } __ATTRIBUTE_PACKED__ control_cell_fifobuffer_reg_1;


  /* Control Cell FIFOBuffer: CPU-Control-FIFO-cells[77:8]          */
  /* -Cells captured for the CPU are stored in a 70-bit wide        */
  /* FIFO.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x32ab */

     /* ControlCellFIFOBuffer: CPU-Control-FIFO-cells[77:8]          */
     /* -Cells captured for the CPU are stored in a 70-bit wide      */
     /* FIFO. The CPU may read a 70-bit cell by reading three        */
     /* 32-bit words. When reading word-2 the cell FIFO is           */
     /* advanced. (Word-0 contains cell[77:46], word-1 contains      */
     /* cell[45:14], and word-2 contains cell[13:8] and 26 '0'       */
     /* bits.)                                                       */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD control_cell_fifobuffer;

  } __ATTRIBUTE_PACKED__ control_cell_fifobuffer_reg_2;

} __ATTRIBUTE_PACKED__ SOC_PETRA_FCR_REGS;
/* Block definition: FCT */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3000 */

     /* UnrchDestEvt: Unreachable-Destination-Event. Set when a      */
     /* packet arrives at the FCT but there is no valid link to      */
     /* forward it through. The data of the packet is written to     */
     /* the UnrchDest register. This is an interrupt source, and      */
     /* is cleared when UnrchDest is read.                           */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD unrch_dest_evt;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3010 */

     /* UnrchDestEvtIntMask: Writing 0 masks the corresponding       */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD unrch_dest_evt_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Fct Enabler Register : Fct command register.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3060 */

     /* DisSts: Discards flow status control cells                   */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dis_sts;

     /* DisCrd: Discards credit control cells                        */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dis_crd;

     /* DisRch: Discards reachability control cells                  */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD dis_rch;

     /* DisLclrt: Disables or enables control cells local            */
     /* routing 0:enabled 1:disabled                                 */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_lclrt;

     /* ForceAllLocal: Enable forcing all credits and flow           */
     /* status to the local rout interface                           */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_all_local;

     /*
      * A union of dis_sts, dis_crd and dis_rch
      *  Those fields (0 - 2) are used for controll cells enable/disable
      */
     SOC_PETRA_REG_FIELD stat_credit_and_rch_ctrl;

  } __ATTRIBUTE_PACKED__ fct_enabler_reg;


  /* Cpu Transmit Cell1: TxCtrCellBuff0-transmit control            */
  /* cells buffer. The CPU writes to a buffer the cell it            */
  /* wants to transmit                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3061 */

     /* CpuCellBuff0: Transmit control cells buffer. The CPU          */
     /* writes to a buffer the cell it wants to transmit . The       */
     /* mapping of the cell is as follows:                           */
     /* TxCtrCellBuff0=\{control_cell[77:46]\}                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_cell_buff0;

  } __ATTRIBUTE_PACKED__ cpu_transmit_cell1_reg;


  /* Cpu Transmit Cell2: TxCtrCellBuff1-transmit control            */
  /* cells buffer. The CPU writes to a buffer the cell it            */
  /* wants to transmit                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3062 */

     /* CpuCellBuff1: Transmit control cells buffer. The CPU          */
     /* writes to a buffer the cell it wants to transmit . The        */
     /* mapping of the cell is as follows:                           */
     /* TxCtrCellBuff1=\{control_cell[45:14]\}                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_cell_buff1;

  } __ATTRIBUTE_PACKED__ cpu_transmit_cell2_reg;


  /* Cpu Transmit Cell3: TxCtrCellBuff2-transmit control            */
  /* cells buffer. The CPU writes to a buffer the cell it            */
  /* wants to transmit                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3063 */

     /* CpuCellBuff2: Transmit control cells buffer. The CPU          */
     /* writes to a buffer the cell it wants to transmit . The        */
     /* mapping of the cell is as follows:                           */
     /* TxCtrCellBuff2=\{control_cell[13:8],26'h0\}                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpu_cell_buff2;

  } __ATTRIBUTE_PACKED__ cpu_transmit_cell3_reg;


  /* Cpu Transmit Cell Link Number: Transmit cell output            */
  /* link:define the output link for the source-routed              */
  /* control cell written from the CPU                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3064 */

     /* CpuLinkNum: Transmit cell output link                        */
     /* range: 4:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_link_num;

  } __ATTRIBUTE_PACKED__ cpu_transmit_cell_link_number_reg;


  /* Cpu Transmit Cells Trigger : Transmit control cells            */
  /* trigger:when asserted by the CPU the cell written by the       */
  /* CPU is transmitted . The trigger is reset by the FCT           */
  /* once the cell is transmitted.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3066 */

     /* CpuTrg: Transmit control cells trigger                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_trg;

  } __ATTRIBUTE_PACKED__ cpu_transmit_cells_trigger_reg;


  /* Transmitted Control Cells Counter: Control cells               */
  /* counter:counts all the transmitted cell to the mac. The         */
  /* counter doesn't stop at saturation. The counter is              */
  /* cleared when read.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3070 */

     /* CtrlCellCnt: Control cells counter This register is          */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ctrl_cell_cnt;

     /* CtrlCellCnto: Control cells counter overflow . This bit      */
     /* is set when the counter exceed 31 bits This register is      */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ctrl_cell_cnto;

  } __ATTRIBUTE_PACKED__ transmitted_control_cells_counter_reg;


  /* Unreachable Destination : This register keeps the first        */
  /* destination that is unreacable from this source fap.           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3071 */

     /* UnrchDest: \{Cell type[2:0], destination-Id[10:0]\} of       */
     /* the unreachable (by RTP distribution table) control          */
     /* cell. Applied only toflow-status, credit or CPU              */
     /* destination-routed cells only. The register keeps its        */
     /* value until read by CPU. This register is clear on read.     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD unrch_dest;

     /* UnrchDestEvt: Unreachable destination event occurred.        */
     /* This register is clear on read.                              */
     /* range: 14:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD unrch_dest_evt;

     /* UnrchCrdtCnt: Counts every unreached credit. This            */
     /* register is clear on read.                                   */
     /* range: 30:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD unrch_crdt_cnt;

     /* UnrchCrdtCnto: Unreached credit counter overflow. This       */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD unrch_crdt_cnto;

  } __ATTRIBUTE_PACKED__ unreachable_destination_reg;


  /* Local Route Cells Counter : Control cell local route           */
  /* counter.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3072 */

     /* LocalRtCellcnt: Counts all local route cells. This           */
     /* register is clear on read.                                   */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD local_rt_cellcnt;

     /* LocalRtCellcnto: Local route counter overflow. This          */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD local_rt_cellcnto;

  } __ATTRIBUTE_PACKED__ local_route_cells_counter_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_FCT_REGS;
/* Block definition: MESH TOPOLOGY */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Mesh Topology:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3400 */

     /* StanAln: Must be set if the fabric interface is not          */
     /* connected with any other FAP                                 */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD stan_aln;

     /* InSystem: Set for fabric-less topology: Set to 0x22 for      */
     /* 2-FAPs system. Set to 0x23 for 3 or more FAPs system.        */
     /* Set to 0 if an SOC_SAND_FE200 is used.                                */
     /* range: 8:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD in_system;

     /* SyncMsgTxAdjFactor: Do not change value                      */
     /* range: 16:9, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD fld0;

     /* range: 20:17, access type: RW, default value: 0xa           */
     SOC_PETRA_REG_FIELD fld1;

     /* Must be asserted for fabric-less topology                   */
     /* range: 23:21, access type: RW, default value: 0x0           */
     SOC_PETRA_REG_FIELD reserved;

     /* MultiFAP: Must be asserted for fabric-less topology          */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD multi_fap;

     /* StanAln2: Must be set if the fabric interface is not         */
     /* connected with any other FAP                                 */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD stan_aln2;

     /* Must be asserted                                            */
     /* range: 31:31, access type: RW, default value: 0x0           */
     SOC_PETRA_REG_FIELD trig;

  } __ATTRIBUTE_PACKED__ mesh_topology_reg;


  /* mesh_config_0_reg                      */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x3402 */

    /* range: 23:16, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD conf1;

    /* range: 31:24, access type: RW, default value: 0x0              */
    SOC_PETRA_REG_FIELD conf2;

  } __ATTRIBUTE_PACKED__ mesh_config_0_reg;

  /* Init: Delay Test Cells configuration.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3403 */

     /* Init:                                                        */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD init;

     /* config1:                                                     */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD config1;

     /* config2: Must be de-asserted.                                */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD config2;

  } __ATTRIBUTE_PACKED__ init_reg;

   /* mesh_config_1_reg:                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr;  /* 0x3404 */

     /* Must be 0xD                                                 */
     SOC_PETRA_REG_FIELD mesh_config_1_reg;

  } __ATTRIBUTE_PACKED__ mesh_config_1_reg;

  /* mesh_config_2_reg:                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr;  /* 0x3405 */

     /* Must be 0xD                                                 */
     SOC_PETRA_REG_FIELD mesh_config_2_reg;

  } __ATTRIBUTE_PACKED__ mesh_config_2_reg;


  /* Fap Detect Ctrl Cells Cnt: Global-Sync Delay-Test              */
  /* Counters                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3440 */

     /* RcvCtl1: Count global sync messages processed This           */
     /* register is clear on read.                                   */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcv_ctl1;

     /* RcvCtl2: Count Delay-Test messages processed This            */
     /* register is clear on read.                                   */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcv_ctl2;

  } __ATTRIBUTE_PACKED__ fap_detect_ctrl_cells_cnt_reg;

  struct
  {
     SOC_PETRA_REG_ADDR  addr;  /* 0x3441 */

     SOC_PETRA_REG_FIELD status;

  } __ATTRIBUTE_PACKED__ mesh_status_reg;

  struct
  {
    SOC_PETRA_REG_ADDR  addr;  /* 0x3445 */

    SOC_PETRA_REG_FIELD status;

  } __ATTRIBUTE_PACKED__ mesh_status_cnt_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_MESH_TOPOLOGY_REGS;
/* Block definition: RTP */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3600 */

     /* LinkMaskChange: Link Mask Change                             */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_mask_change;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3610 */

     /* LinkMaskChange: Bit 0 - Link Mask Change Mask Bit 1 -        */
     /* not used                                                     */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD link_mask_change;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3620 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 71:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3630 */

     /* IndirectCommandRdData: Indirect read data.                   */
     /* range: 71:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3640 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3641 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed.                           */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -:        */
     /* Write operation 1 -: Read operation                          */
     /* range: 31:31, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* RTP Enable: RTP Enable Register.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3660 */

     /* RTPWP: Watchdog-Period. Specifies the maximal time that      */
     /* can pass between the arrivals of two consecutive             */
     /* reachability messages from the same input link without       */
     /* declaring the link as malfunction. This parameter's          */
     /* units are 4096 chip clocks. A value of 0 disables            */
     /* watchdog operation.                                          */
     /* range: 3:0, access type: RW, default value: 0x8              */
     SOC_PETRA_REG_FIELD rtpwp;

     /* ACLM: ACL-Mask. Masks processing of the recieived ACL        */
     /* bit. If set, the ACL arriving is not considered for link     */
     /* up calculations.                                             */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD aclm;

     /* RtpUpEn: Enables updatinges of of the reachability table     */
     /* by incoming reachability messages.                           */
     /* range: 6:6, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rtp_up_en;

     /* RtpEnMsk: Enable-Masking. If set, table data is masked       */
     /* with the link status.                                        */
     /* range: 7:7, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rtp_en_msk;

     /* RMGR: Reachability-Message-Generation-Period (in units       */
     /* of 128 chip clocks). Note that this is the generation        */
     /* rate of a single reachability message. Multiplying it by     */
     /* 36 is the period of sending one single message per           */
     /* output link (i.e., in units of 128*24=3072 chip clocks)      */
     /* and this should match the Watchdog-Period of the             */
     /* receiving device. Programming to values 4, 3, 2 or 1         */
     /* results in an undetermined operation. Programming to a       */
     /* value of 0 disables the generation of reachability           */
     /* messages. The default value 0x0 is to ensure that no         */
     /* reachability messages are sent before the FAP's Pipe-ID      */
     /* is written.                                                  */
     /* range: 12:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rmgr;

     /* EnLocalLinkReduction: If set, the link state sent to the     */
     /* scheduler, for rate adaptation, is masked by the             */
     /* accessability of the local Soc_petra ID                          */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD en_local_link_reduction;

  } __ATTRIBUTE_PACKED__ rtp_enable_reg;


  /* RTP By Pass: RTP Bypass register                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3661 */

     /* FrcLnksHigh: Force-all-links-high.                           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_lnks_high;

     /* FrcLnkNumHigh: Force-link-number-high. The entire            */
     /* traffic is routed through link number FrcLnkNum.             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_lnk_num_high;

     /* FrcLnkNum: The number of the forced link.                    */
     /* range: 7:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_lnk_num;

  } __ATTRIBUTE_PACKED__ rtp_by_pass_reg;


  /* RTP Coexist configuration register:                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3662 */

     /* RTPCoexist: Bit per serial link that determines the LSB      */
     /* of the Soc_petra-ID that the RTP transmits in the                */
     /* reachability cells. This bit should be used when the         */
     /* Soc_petra is used in a system with SOC_SAND_FAP20V. The RTP will          */
     /* transmit over link "n" a source Soc_petra-ID ==                  */
     /* \{PipeID[10:1], DestCfg[n]\} This register corresponds       */
     /* to links 0 to 35                                             */
     /* range: 35:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rtpcoexist;

  } __ATTRIBUTE_PACKED__ rtp_coexist_configuration_reg[SOC_PETRA_NOF_BIT_PER_LINK_REGS];


  /* Multicast Link Up:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3664 */

     /* MCLinkUp: Multicast link up state for links 35:0. 1 -:       */
     /* The link is up. Multicast traffic may exit on that link.     */
     /* 0 -: The link cannot transfer spatial multicast traffic.     */
     /* Note: This register and the following one are meaningful     */
     /* only if bit BypassUpdate is set in the register              */
     /* "Multicast Distribution Configuration" allowed links         */
     /* update rate . Each bit in these registers is logically       */
     /* ANDed with the corresponding links state to determine        */
     /* the validity of the link for multicast traffic.              */
     /* range: 35:0, access type: RW, default value: 0xfffffffff     */
     SOC_PETRA_REG_FIELD mclink_up;

  } __ATTRIBUTE_PACKED__ multicast_link_up_reg[SOC_PETRA_NOF_ACTIVE_MC_LINKS_REGS];


  /* Multicast Distribution Configuration register: Multicast       */
  /* distribution configuration                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3666 */

     /* MulNumTrav: The number of times the unicast distribution     */
     /* table is traversed prior to updating the                     */
     /* mc-available-links register: 0 -: The allowed multicast      */
     /* links are updated when the RTP finishes traversing the       */
     /* distribution table. 1 -: The allowed multicast links are     */
     /* updated when the RTP finishes traversing the                 */
     /* distribution table twice. 2 -: The allowed multicast         */
     /* links are updated when the RTP finishes traversing the       */
     /* distribution table three times. 3 -: The allowed             */
     /* multicast links are updated when the RTP finishes            */
     /* traversing the distribution table 4 times.                   */
     /* range: 1:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mul_num_trav;

     /* BypassUpdate: When set, the state of the links for           */
     /* multicast distribution is taken from the "Multicast Link     */
     /* Up" register. In this case, bits 1:0 of this register        */
     /* are ignored.                                                 */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bypass_update;

     /* EnableMCLUpdates: Enables updates of the multicast links     */
     /* status register.                                             */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD enable_mclupdates;

  } __ATTRIBUTE_PACKED__ multicast_distribution_configuration_reg;


  /* Maximum Base Index:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3667 */

     /* MaxBI: This number sets that maximum base index that is      */
     /* transmitted by the Soc_petra in reachability messages.           */
     /* (MaxBI+1)*32-1 is the maximal allowable Soc_petra-ID in the      */
     /* system.                                                      */
     /* range: 5:0, access type: RW, default value: 0x3f             */
     SOC_PETRA_REG_FIELD max_bi;

  } __ATTRIBUTE_PACKED__ maximum_base_index_reg;


  /* Link Active Mask:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3668 */

     /* LnkActvMsk: Bit per serial link, indicating if the link      */
     /* is considered up (available). If a link is masked, data      */
     /* is not sent through it. This is used to mask the output      */
     /* from the RTP distribution table memory. Access: Read.        */
     /* range: 35:0, access type: RO, default value: 0xfffffffff     */
     SOC_PETRA_REG_FIELD lnk_actv_msk;

  } __ATTRIBUTE_PACKED__ link_active_mask_reg[SOC_PETRA_NOF_BIT_PER_LINK_REGS];


  /* ACL Received:                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3670 */

     /* ACLRecieve: ACL received on reachability message, for        */
     /* link N. A value of 0 means that the link is down.            */
     /* range: 35:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD aclrecieve;

  } __ATTRIBUTE_PACKED__ acl_received_reg[SOC_PETRA_NOF_BIT_PER_LINK_REGS];


  /* Locally generated ACL:                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3672 */

     /* LocalACL: ACL value which is extracted from the MAC's        */
     /* leaky bucket for input link N, and sent out through          */
     /* output link N.                                               */
     /* range: 35:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD local_acl;

  } __ATTRIBUTE_PACKED__ locally_generated_acl_reg[SOC_PETRA_NOF_BIT_PER_LINK_REGS];


  /* MC Distribution map:                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3674 */

     /* MCDistribution: Returns the MC distribution map.             */
     /* range: 35:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD mcdistribution;

  } __ATTRIBUTE_PACKED__ mc_distribution_map_reg[SOC_PETRA_NOF_BIT_PER_LINK_REGS];


  /* Exclude Dest ID for MC Links 0:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3676 */

     /* DestID: Destination specified in this field is excluded      */
     /* from the construction of the mc-avail-links register.        */
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dest_id;

     /* Valid: Defines if DestID field is valid                      */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD valid;

  } __ATTRIBUTE_PACKED__ exclude_dest_id_for_mc_links_0_reg;


  /* Exclude Dest ID for MC Links 1:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3677 */

     /* DestID: Destination specified in this field is excluded      */
     /* from the construction of the mc-avail-links register.        */
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dest_id;

     /* Valid: Defines if DestID field is valid                      */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD valid;

  } __ATTRIBUTE_PACKED__ exclude_dest_id_for_mc_links_1_reg;


  /* Exclude Dest ID for MC Links 2:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3678 */

     /* DestID: Destination specified in this field is excluded      */
     /* from the construction of the mc-avail-links register.        */
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dest_id;

     /* Valid: Defines if DestID field is valid                      */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD valid;

  } __ATTRIBUTE_PACKED__ exclude_dest_id_for_mc_links_2_reg;


  /* Exclude Dest ID for MC Links 3:                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3679 */

     /* DestID: Destination specified in this field is excluded      */
     /* from the construction of the mc-avail-links register.        */
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dest_id;

     /* Valid: Defines if DestID field is valid                      */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD valid;

  } __ATTRIBUTE_PACKED__ exclude_dest_id_for_mc_links_3_reg;


  /* Allowed Links:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3680 */

     /* AllowedLinks: A bit set enables the link. A cleared bit      */
     /* will ensure no traffic is sent on that link. Cells are       */
     /* transmitted on Allowed links that are eligible for           */
     /* sending traffic (e.g. link status is up).                    */
     /* range: 35:0, access type: RW, default value: 0xfffffffff     */
     SOC_PETRA_REG_FIELD allowed_links;

  } __ATTRIBUTE_PACKED__ allowed_links_reg[SOC_PETRA_NOF_ALLOWED_LINKS_REGS];

} __ATTRIBUTE_PACKED__ SOC_PETRA_RTP_REGS;
/* Block definition: FABRIC MAC */
typedef struct
{
  uint32   nof_instances; /* 3 */
  SOC_PETRA_REG_ADDR addr;

  /* Leaky Bucket: MAC-Received-Cell Counters                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c01 */

     /* LkyBktValue: The value of the six-bit leaky bucket used      */
     /* to measure the Cell Error Rate.                              */
     /* range: 5:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD lky_bkt_value;

     /* RxGoodCellCnt: Number of Good Cells Received via a           */
     /* serial link. The value of the 12-bit counter that counts     */
     /* the number of good cells is used to decide when to add a     */
     /* token to the leaky bucket. The counter rolls over at         */
     /* saturation. The type of the cells counted is                 */
     /* configurable using the RxCntCfg field (offset 0x2Af0,        */
     /* bits 19:18)                                                  */
     /* range: 17:6, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_good_cell_cnt;

  } __ATTRIBUTE_PACKED__ leaky_bucket_reg[SOC_PETRA_NOF_PER_LINK_REGS];


  /* Transmit Cell Counters: MAC Transmit Cell Counters.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c02 */

     /* TxCellCntN: Transmitted-Cell Counter through serial          */
     /* link. The type of the cells counted is configurable          */
     /* through the TxCntCfg bit. When read, this counter is         */
     /* auto cleared. At saturation, the counter rolls over.         */
     /* range: 11:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tx_cell_cnt_n;

  } __ATTRIBUTE_PACKED__ transmit_cell_counters_reg[SOC_PETRA_NOF_PER_LINK_REGS];


  /* Loopback And Link Level Flow Control Enable Register:          */
  /* Single MAC Loopback and Link Level Flow control enable         */
  /* Register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3c03 */

     /* LclLpbkOn: Local loopback enable. This mode causes           */
     /* transmitted data from the MAC transmit end to be input       */
     /* into the MAC receive end. The loopback is executed           */
     /* inside the fabric MAC and, therefore, data is not            */
     /* transmitted through the SerDes.                              */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD lcl_lpbk_on;

     /* DoubleRateEn: If set, the MAC works at a double rate         */
     /* (6.25Gbps).                                                  */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD double_rate_en;

     /* LnkLvlFcTxEn: Enables/Disables the Tx link level flow        */
     /* control. If set, the HALT flag is the result of the          */
     /* threshold of the FIFOs. If reset, the HALT flag is           */
     /* always set to 0.                                             */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD lnk_lvl_fc_tx_en;

     /* LnkLvlFcRxEn: If set, HALT flag is extracted from            */
     /* incoming cells. If reset, the HALT flag is always set to     */
     /* 0.                                                           */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD lnk_lvl_fc_rx_en;

  } __ATTRIBUTE_PACKED__ loopback_and_link_level_flow_control_enable_reg[SOC_PETRA_NOF_PER_LINK_REGS];


  /* CRCError Counter: Single MAC CRC Error Counter.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 00x3c05 */

     /* CRCErrCnt: This counter counts CRC errors on a specific      */
     /* link. This register is clear on read.                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD crcerr_cnt;

     /* CRCErrCntOvf: This bit is set when CRC Error counter         */
     /* (CRCErrCnt) exceeds its maximum count. This register is      */
     /* clear on read.                                               */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD crcerr_cnt_ovf;

  } __ATTRIBUTE_PACKED__ crcerror_counter_reg[SOC_PETRA_NOF_PER_LINK_REGS];


  /* Interrupt Register5: This register contains the                */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cea */

     /* WrongSizeN_Int: This bit is asserted whenever the MAC N      */
     /* receives a data cell with an invalid size (not in the        */
     /* 64-128B range for Variable Sized Cells)                      */
     /* range: 23:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD wrong_size_n_int;

  } __ATTRIBUTE_PACKED__ interrupt_5_reg;


  /* Interrupt Mask Register5: Each bit in this register            */
  /* corresponds to an interrupt source in Interrupt                */
  /* Register4. The interrupt source is masked by writing 0         */
  /* to the relevant bit in this register.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3ceb */

     /* WrongSizeN_IntMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 23:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wrong_size_n_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_5_reg;


  /* Enablers Register: MAC Enablers                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cf0 */

     /* EnableSerialLink: This bit must be reset after the FAP       */
     /* ID register is written with the correct FAP ID.              */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD enable_serial_link;

     /* DelCRCErrCell: Receive MAC CRC error cell Delete. If the     */
     /* bit is set and a CRC error is detected in an incoming        */
     /* non-TDM cell, the cell is deleted. Otherwise, the CRC is     */
     /* checked and the cell is forwarded regardless of the          */
     /* check result (see RxCRCErrN).                                */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD del_crcerr_cell;

     /* DelTDMCRCErrCel: Receive MAC TDM CRC error cell RW 0         */
     /* Delete. If the bit is asserted and a CRC error is            */
     /* detected in an incoming TDM cell the cell is deleted. If     */
     /* the bit is negated, the CRC is checked and the cell is       */
     /* forwarded regardless of the check result (see                */
     /* RxCRCErrN).                                                  */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD del_tdmcrcerr_cel;

     /* DelDataCellLB: If set and the leaky bucket output is         */
     /* low, the unicast and multicast data cells are deleted.       */
     /* range: 8:8, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD del_data_cell_lb;

     /* DelFSCrCellLB: If set and the leaky bucket output is         */
     /* low, the flow status and credit control cells are            */
     /* deleted                                                      */
     /* range: 9:9, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD del_fscr_cell_lb;

     /* DelALLCellsLB: If set and the leaky bucket output is         */
     /* low, all cells are deleted                                   */
     /* range: 10:10, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD del_allcells_lb;

     /* DelWrongSizeCell: Receive MAC wrong size cell Delete. If     */
     /* the bit is set and a cell arrived that is not in the         */
     /* range of 64-128B, the cell is deleted. This                  */
     /* configuration is only valid in Variable Size Cell (VSC)      */
     /* mode.                                                        */
     /* range: 11:11, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD del_wrong_size_cell;

     /* TxCntCfg: Transmit Control and Data Counters. These bits     */
     /* control the functionality of the MAC-transmit counters       */
     /* (see TxCellCntN). 0 : The counter counts both data and       */
     /* control cells. 1 : The counter counts only control           */
     /* cells. 2 : The counter counts only data cells. 3 :           */
     /* Reserved                                                     */
     /* range: 17:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tx_cnt_cfg;

     /* RxCntCfg: Receive Control and Data Counters. These bits      */
     /* control the functionality of the MAC receive counters,       */
     /* specifying which good cells are to be counted. 0 : The       */
     /* counter counts both data and control cells. In the worst     */
     /* case only reachability messages are present. Their rate      */
     /* can be as low as one per 32*2048(=2^16) clocks. During       */
     /* this time 65K bits can arrive. I.e., BER larger than         */
     /* 10^-5 will not allow link_up with control cells. 1 : The     */
     /* counter counts only control cells 2 : The counter counts     */
     /* only data cells 3 : Reserved                                 */
     /* range: 19:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_cnt_cfg;

  } __ATTRIBUTE_PACKED__ enablers_reg;


  /* Leaky Bucket Control Register: This register configures        */
  /* the MAC leaky bucket parameters.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cf1 */

     /* BktFillRate: Bucket-Fill-Rate. Number of good cells that     */
     /* add a token to the bucket. BktFillRate [3:0] must be         */
     /* configured to be no bigger than 0xB. The number              */
     /* BktFillRate [3:0] is the exponent of 2, i.e., the number     */
     /* of good cells adding a token to the bucket is                */
     /* 2^BktFillRate [3:0].                                         */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD bkt_fill_rate;

     /* BktLinkUpTh: Bucket-Link-Up-Threshold. If the                */
     /* Bucket-Link-Up-Threshold equals 0, the links are always      */
     /* up.                                                          */
     /* range: 9:4, access type: RW, default value: 0x20             */
     SOC_PETRA_REG_FIELD bkt_link_up_th;

     /* BktLinkDnTh: Bucket-Link-Down-Threshold. If the              */
     /* Bucket-Link-Down-Threshold equals 63, the links are          */
     /* always down (unless Bucket-Link-Up-Threshold equals 0)       */
     /* range: 15:10, access type: RW, default value: 0x10           */
     SOC_PETRA_REG_FIELD bkt_link_dn_th;

     /* SigDetBktRstEna: If set, the LOS (analog detection of        */
     /* minimum signal amplitude) from the SerDes can cause the      */
     /* leaky bucket counter to reset.                               */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sig_det_bkt_rst_ena;

     /* SerLckBktRstEna: If set, the LOCK signal from the SerDes     */
     /* can cause the leaky bucket counter to reset.                 */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ser_lck_bkt_rst_ena;

     /* AlignLckBktRstEna: If set, the 8b/10b decoder and comma      */
     /* detector can cause the leaky bucket counter to reset.        */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD align_lck_bkt_rst_ena;

  } __ATTRIBUTE_PACKED__ leaky_bucket_control_reg;


  /* Control Cell Burst And TDMRegister: This register              */
  /* configures the Control Cell Mode transmitted by the MAC.       */
  /* It also configure TDM parameters.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cf2 */

     /* CntrlBurstPeriod: Configures the amount of data (in          */
     /* units of 8 bytes) between two consecutive control cell       */
     /* bursts.                                                      */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cntrl_burst_period;

     /* MaxCntrlCellBurst: Configures the maximum number of          */
     /* control cells that can be transmitted as one single          */
     /* burst with no data cells separating them. The number of      */
     /* control cells in such a burst is determined by               */
     /* (MaxCntrlCellBurst + 1). A value of MaxCntrlCellBurst ==     */
     /* 0 results in at least one data cell separating for every     */
     /* control cell transmission.                                   */
     /* range: 9:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD max_cntrl_cell_burst;

     /* TDMFragmentNumber: Configures the fragment number to be      */
     /* used to identify a TDM cell.                                 */
     /* range: 24:16, access type: RW, default value: 0x180          */
     SOC_PETRA_REG_FIELD tdmfragment_number;

  } __ATTRIBUTE_PACKED__ control_cell_burst_and_tdmreg_reg;


  /* Receive Reset Register: During initialization, this            */
  /* register has to be reset to enable MAC receive.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cf4 */

     /* FMACRxRstN: Reset link to MAC registers in the rx clock      */
     /* domain for link N.                                           */
     /* range: 11:0, access type: RW, default value: 0xfff           */
     SOC_PETRA_REG_FIELD fmacrx_rst_n[SOC_PETRA_NOF_PER_LINK_REGS];

     /* FMACTxRstN: Reset link to MAC registers in the tx clock      */
     /* domain for link N.                                           */
     /* range: 27:16, access type: RW, default value: 0xfff          */
     SOC_PETRA_REG_FIELD fmactx_rst_n[SOC_PETRA_NOF_PER_LINK_REGS];

  } __ATTRIBUTE_PACKED__ receive_reset_reg;


  /* Link Level Flow Control And Comma Configuration                */
  /* Register: MAC Link Level Flow control and Comma                */
  /* Configuration Register.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cf6 */

     /* LnkLvlAgePrd: Aging period. Note that programming it to      */
     /* 0 disables the aging counter. The aging period is            */
     /* 2^LnkLvlAgePrd.                                              */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD lnk_lvl_age_prd;

     /* LnkLvlFragNum: Fragment number indicating a link level       */
     /* flow control cell.                                           */
     /* range: 12:4, access type: RW, default value: 0x1ff           */
     SOC_PETRA_REG_FIELD lnk_lvl_frag_num;

     /* CmBrstSize: Number of consecutive commas to be               */
     /* transmitted. 0 means no commas are transmitted, if data      */
     /* is available. The number of commas to be transmitted is      */
     /* ((CmBrstSize+1)*2).                                          */
     /* range: 21:16, access type: RW, default value: 0x7            */
     SOC_PETRA_REG_FIELD cm_brst_size;

     /* CmTxPeriod: Number of cells/bytes between consecutive        */
     /* comma sequences. Configuring 0 in this register means        */
     /* that no comma sequences are generated. The number of         */
     /* cells/bytes between comma sequences is 2^CmTxPeriod. If      */
     /* CmTxByteMode is asserted, period will be calculated          */
     /* according to transmitted bytes. Otherwise, period will       */
     /* be calculated according to transmitted cells. If             */
     /* CmTxByteMode is not asserted, this register must not         */
     /* receive a value higher than 15.                              */
     /* range: 28:24, access type: RW, default value: 0x5            */
     SOC_PETRA_REG_FIELD cm_tx_period;

     /* CmTxByteMode: If CmTxByteMode is asserted, comma period      */
     /* will be calculated according to transmitted bytes.           */
     /* Otherwise, period will be calculated according to            */
     /* transmitted cells.                                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cm_tx_byte_mode;

  } __ATTRIBUTE_PACKED__ link_level_flow_control_and_comma_configuration_reg;


  /* Interrupt Register1: This register contains the                */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cf8 */

     /* RxCRCErrN_Int: Receiver CRC Error at link N. The bit is      */
     /* asserted when a CRC error cell is detected.                  */
     /* range: 11:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_crcerr_n_int;

     /* RxCGErrN_Int: Receiver Code Group Error at Link N. The       */
     /* bit is asserted when a Code-group combination (8b/10b)       */
     /* is detected.                                                 */
     /* range: 23:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_cgerr_n_int;

  } __ATTRIBUTE_PACKED__ interrupt_1_reg;


  /* Interrupt Mask Register1: Each bit in this register            */
  /* corresponds to an interrupt source in Interrupt                */
  /* Register1. The interrupt source is masked by writing 0         */
  /* to the relevant bit in this register.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cf9 */

     /* RxCRCErrN_IntMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rx_crcerr_n_int_mask;

     /* RxCGErrN_IntMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 23:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_cgerr_n_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_1_reg;


  /* Interrupt Register2: This register contains the                */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cfa */

     /* LOS_Int: Loss of Signal (LOS). The receiver of the 3.125     */
     /* Gbps SerDes has internal signal-detection circuitry.         */
     /* When 1, this indicates the presence of a weak signal         */
     /* condition (<85 mV differential) at the channels input        */
     /* line interface for AC-coupled links. The signal              */
     /* detection circuitry is intended to be an indication of       */
     /* gross signal error conditions, such as a bad connection      */
     /* or no transmitting signals. Interrupt source.                */
     /* range: 11:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD los_int;

     /* RxMisAErrN_Int: If set, a misalignment (comma code group     */
     /* error) is detected at the corresponding link N.              */
     /* range: 23:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mis_aerr_n_int;

  } __ATTRIBUTE_PACKED__ interrupt_2_reg;


  /* Interrupt Mask Register2: Each bit in this register            */
  /* corresponds to an interrupt source in Interrupt                */
  /* Register2. The interrupt source is masked by writing 0         */
  /* to the relevant bit in this register.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cfb */

     /* LOS_IntMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD los_int_mask;

     /* RxMisAErrN_IntMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 23:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_mis_aerr_n_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_2_reg;


  /* Interrupt Register3: This register contains the                */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cfc */

     /* RxDispErrN_Int: Receiver Disparity Error at Link N. The      */
     /* bit is set when a disparity error in the 8b/10b is           */
     /* detected.                                                    */
     /* range: 23:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_disp_err_n_int;

  } __ATTRIBUTE_PACKED__ interrupt_3_reg;


  /* Interrupt Mask Register3: Each bit in this register            */
  /* corresponds to an interrupt source in Interrupt                */
  /* Register3. The interrupt source is masked by writing 0         */
  /* to the relevant bit in this register.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cfd */

     /* RxDispErrN_IntMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 23:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_disp_err_n_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_3_reg;


  /* Interrupt Register4: This register contains the                */
  /* interrupt sources residing in this unit.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cfe */

     /* LnklvlAgeN_Int: This bit is asserted whenever the MAC N      */
     /* link level flow control aging mechanism is activated.        */
     /* range: 11:0, access type: RC, default value: 0x0             */
     SOC_PETRA_REG_FIELD lnklvl_age_n_int;

     /* LnklvlHaltN_Int: This bit is asserted whenever the MAC N     */
     /* receives a Halt bit in an incoming data cell.                */
     /* range: 23:12, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD lnklvl_halt_n_int;

  } __ATTRIBUTE_PACKED__ interrupt_4_reg;


  /* Interrupt Mask Register4: Each bit in this register            */
  /* corresponds to an interrupt source in Interrupt                */
  /* Register4. The interrupt source is masked by writing 0         */
  /* to the relevant bit in this register.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3cff */

     /* LnklvlAgeN_IntMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD lnklvl_age_n_int_mask;

     /* LnklvlHaltN_IntMask: Writing 0 masks the corresponding       */
     /* interrupt source.                                            */
     /* range: 23:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD lnklvl_halt_n_int_mask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_4_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_FABRIC_MAC_REGS;
/* Block definition: MSW */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4800 */

     /* SrdInterrupt: If set, indicates that an interrupt was        */
     /* created by one of the Serdes lanes.                          */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD srd_interrupt;

     /* Srd0MacroInterrupt: Serdes macro 0 interrupts                */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd0_macro_interrupt;

     /* Srd1MacroInterrupt: Serdes macro 1 interrupts                */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd1_macro_interrupt;

     /* Srd2MacroInterrupt: Serdes macro 2 interrupts                */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd2_macro_interrupt;

     /* Srd3MacroInterrupt: Serdes macro 3 interrupts                */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd3_macro_interrupt;

     /* SrdIpuInterruptGroupA: Group A Interrupt from IPU (IPU)     */
     /* range: 20:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt_group_a;

     /* SrdEpbInterruptGroupA: Group A Interrupt from EPB. If        */
     /* set, indicates that EPB FSM detected overrun error. This     */
     /* error is cause when an EPB_OP is dispatched when a           */
     /* previous EPB_OP is still executing.                          */
     /* range: 21:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt_group_a;

     /* Srd4MacroInterrupt: Serdes macro 4 interrupts                */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd4_macro_interrupt;

     /* Srd5MacroInterrupt: Serdes macro 5 interrupts                */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd5_macro_interrupt;

     /* Srd6MacroInterrupt: Serdes macro 6 interrupts                */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd6_macro_interrupt;

     /* SrdIpuInterruptGroupB: Group B Interrupt from IPU (IPU)     */
     /* range: 27:27, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt_group_b;

     /* SrdEpbInterruptGroupB: Group B Interrupt from EPB. If        */
     /* set, indicates that EPB FSM detected overrun error. This     */
     /* error is cause when an EPB_OP is dispatched when a           */
     /* previous EPB_OP is still executing.                          */
     /* range: 28:28, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt_group_b;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Srd Lane Interrupt Register: This register contains the        */
  /* interrupt sources from each of the Serdes lanes                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4801 */

     /* SrdLaneInterrupt: Interrupts from the 28 SerDes lanes.       */
     /* Bit N indicates an interrupt coming from Serdes lane N.      */
     /* range: 27:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd_lane_interrupt;

  } __ATTRIBUTE_PACKED__ srd_lane_interrupt_reg;


  /* Interrupt Mask Register: Interrupt Mask Register               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4810 */

     /* SrdInterruptMask: Writing 0 masks the corresponding          */
     /* interrupt source                                             */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD srd_interrupt_mask;

     /* Srd0MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd0_macro_interrupt_mask;

     /* Srd1MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd1_macro_interrupt_mask;

     /* Srd2MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd2_macro_interrupt_mask;

     /* Srd3MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd3_macro_interrupt_mask;

     /* SrdIpuInterruptMaskGroupA: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt_mask_group_a;

     /* SrdEpbInterruptGroupAMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt_group_amask;

     /* Srd4MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd4_macro_interrupt_mask;

     /* Srd5MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd5_macro_interrupt_mask;

     /* Srd6MacroInterruptMask: Writing 0 masks the                  */
     /* corresponding interrupt source                               */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd6_macro_interrupt_mask;

     /* SrdIpuInterruptMaskGroupB: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_ipu_interrupt_mask_group_b;

     /* SrdEpbInterruptGroupBMask: Writing 0 masks the               */
     /* corresponding interrupt source                               */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD srd_epb_interrupt_group_bmask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Srd Lane Interrupt Mask Register: SerDes Interrupt Mask        */
  /* Register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4811 */

     /* SrdLaneInterruptMask: Writing 0 masks the corresponding      */
     /* interrupt source                                             */
     /* range: 27:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd_lane_interrupt_mask;

  } __ATTRIBUTE_PACKED__ srd_lane_interrupt_mask_reg;


  /* Scif Control: This register is used for arbitration on         */
  /* the SCIF bus between its clients                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4860 */

     /* ScifEn: If set, enables the using of the SCIF interface      */
     /* for Serdes configurations                                    */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD scif_en;

     /* ScifAselEn: If set, enables the using of the SCIF ASEL       */
     /* bit to select which Serdes macro to access. Otherwise,       */
     /* the CPU configurations will be used                          */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD scif_asel_en;

     /* ScifAselReset: A soft reset for the SCIF ASEL block.         */
     /* Active high.                                                 */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD scif_asel_reset;

     /* ScifStarSel: Selects which Serdes group is being             */
     /* accessed by the SCIF. 0 : NIFA Serdes Group 1 : NIFB         */
     /* Serdes Group 2 : MAC Serdes Group A 3 : MAC Serdes Group     */
     /* B 4,5,7 : Reserved                                           */
     /* range: 6:4, access type: RW, default value: 0x6              */
     SOC_PETRA_REG_FIELD scif_star_sel;

     /* ScifMacroSel: Selects which Serdes macro is to be            */
     /* accessed inside a Serdes group by the SCIF                   */
     /* range: 11:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD scif_macro_sel;

  } __ATTRIBUTE_PACKED__ scif_control_reg;


  /* Scif Status: This register shows the current SCIF              */
  /* configuration (from the external interface)                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4861 */

     /* ScifMacroSelStatus: Shows the Macro selected using the       */
     /* external SCIF                                                */
     /* range: 2:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD scif_macro_sel_status;

     /* ScifStarSelStatus: Shows the Serdes group selected using     */
     /* the external SCIF                                            */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD scif_star_sel_status;

     /* ScifAselStatus: Shows the status of the external SCIF        */
     /* ASEL pin                                                     */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD scif_asel_status;

     /* ScifExtEnStatus: Shows the status of the external SCIF       */
     /* enable pin                                                   */
     /* range: 12:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD scif_ext_en_status;

  } __ATTRIBUTE_PACKED__ scif_status_reg;


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg;


  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg;


  /* Srd0 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4900 */

     /* Srd0Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln0_cfga_reg;


  /* Srd0 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4901 */

     /* Srd0Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln0_stat_reg;


  /* Srd0 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4902 */

     /* Srd0Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln0_ebist_reg;


  /* Srd0 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4904 */

     /* Srd0Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln1_cfga_reg;


  /* Srd0 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4905 */

     /* Srd0Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln1_stat_reg;


  /* Srd0 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4906 */

     /* Srd0Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln1_ebist_reg;


  /* Srd0 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4908 */

     /* Srd0Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln2_cfga_reg;


  /* Srd0 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4909 */

     /* Srd0Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln2_stat_reg;


  /* Srd0 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x490a */

     /* Srd0Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln2_ebist_reg;


  /* Srd0 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x490c */

     /* Srd0Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd0_ln3_cfga_reg;


  /* Srd0 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x490d */

     /* Srd0Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd0_ln3_stat_reg;


  /* Srd0 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x490e */

     /* Srd0Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd0_ln3_ebist_reg;


  /* Srd0 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4910 */

     /* Srd0CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd0_cmu_cfga_reg;


  /* Srd0 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4911 */

     /* Srd0CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd0_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd0_cmu_cfgb_reg;


  /* Srd0 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4912 */

     /* Srd0CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd0_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd0_cmu_stat_reg;


  /* Srd1 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4920 */

     /* Srd1Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln0_cfga_reg;


  /* Srd1 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4921 */

     /* Srd1Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln0_stat_reg;


  /* Srd1 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4922 */

     /* Srd1Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln0_ebist_reg;


  /* Srd1 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4924 */

     /* Srd1Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln1_cfga_reg;


  /* Srd1 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4925 */

     /* Srd1Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln1_stat_reg;


  /* Srd1 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4926 */

     /* Srd1Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln1_ebist_reg;


  /* Srd1 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4928 */

     /* Srd1Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln2_cfga_reg;


  /* Srd1 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4929 */

     /* Srd1Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln2_stat_reg;


  /* Srd1 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x492a */

     /* Srd1Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln2_ebist_reg;


  /* Srd1 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x492c */

     /* Srd1Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd1_ln3_cfga_reg;


  /* Srd1 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x492d */

     /* Srd1Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd1_ln3_stat_reg;


  /* Srd1 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x492e */

     /* Srd1Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd1_ln3_ebist_reg;


  /* Srd1 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4930 */

     /* Srd1CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd1_cmu_cfga_reg;


  /* Srd1 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4931 */

     /* Srd1CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd1_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd1_cmu_cfgb_reg;


  /* Srd1 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4932 */

     /* Srd1CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd1_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd1_cmu_stat_reg;


  /* Srd2 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4940 */

     /* Srd2Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln0_cfga_reg;


  /* Srd2 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4941 */

     /* Srd2Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln0_stat_reg;


  /* Srd2 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4942 */

     /* Srd2Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln0_ebist_reg;


  /* Srd2 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4944 */

     /* Srd2Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln1_cfga_reg;


  /* Srd2 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4945 */

     /* Srd2Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln1_stat_reg;


  /* Srd2 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4946 */

     /* Srd2Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln1_ebist_reg;


  /* Srd2 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4948 */

     /* Srd2Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln2_cfga_reg;


  /* Srd2 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4949 */

     /* Srd2Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln2_stat_reg;


  /* Srd2 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x494a */

     /* Srd2Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln2_ebist_reg;


  /* Srd2 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x494c */

     /* Srd2Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd2_ln3_cfga_reg;


  /* Srd2 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x494d */

     /* Srd2Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd2_ln3_stat_reg;


  /* Srd2 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x494e */

     /* Srd2Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd2_ln3_ebist_reg;


  /* Srd2 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4950 */

     /* Srd2CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd2_cmu_cfga_reg;


  /* Srd2 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4951 */

     /* Srd2CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd2_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd2_cmu_cfgb_reg;


  /* Srd2 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4952 */

     /* Srd2CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd2_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd2_cmu_stat_reg;


  /* Srd3 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4960 */

     /* Srd3Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln0_cfga_reg;


  /* Srd3 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4961 */

     /* Srd3Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln0_stat_reg;


  /* Srd3 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4962 */

     /* Srd3Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln0_ebist_reg;


  /* Srd3 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4964 */

     /* Srd3Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln1_cfga_reg;


  /* Srd3 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4965 */

     /* Srd3Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln1_stat_reg;


  /* Srd3 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4966 */

     /* Srd3Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln1_ebist_reg;


  /* Srd3 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4968 */

     /* Srd3Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln2_cfga_reg;


  /* Srd3 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4969 */

     /* Srd3Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln2_stat_reg;


  /* Srd3 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x496a */

     /* Srd3Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln2_ebist_reg;


  /* Srd3 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x496c */

     /* Srd3Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd3_ln3_cfga_reg;


  /* Srd3 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x496d */

     /* Srd3Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd3_ln3_stat_reg;


  /* Srd3 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x496e */

     /* Srd3Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd3_ln3_ebist_reg;


  /* Srd3 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4970 */

     /* Srd3CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd3_cmu_cfga_reg;


  /* Srd3 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4971 */

     /* Srd3CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd3_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd3_cmu_cfgb_reg;


  /* Srd3 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4972 */

     /* Srd3CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd3_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd3_cmu_stat_reg;


  /* Srda Ipu Cfg:                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4978 */

     /* SrdaIpuCfg: Configuration Register for IPU (internal         */
     /* IPU), EPB bus, and SCIF access. Shared by all SerDeses      */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_PCFG_DEFAULT */
     SOC_PETRA_REG_FIELD srda_ipu_cfg;

  } __ATTRIBUTE_PACKED__ srda_ipu_cfg_reg;


  /* Srda Epb Op:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4979 */

     /* SrdaEpbOp: EPB OP dispatch register. Writing to this         */
     /* register causes a write or read operation to be              */
     /* dispatched on the EPB bus.                                   */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_EPB_OP_DEFAULT */
     SOC_PETRA_REG_FIELD srda_epb_op;

  } __ATTRIBUTE_PACKED__ srda_epb_op_reg;


  /* Srda Epb Rd:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x497a */

     /* SrdaEpbRd: EPB OP data read register. After a read from      */
     /* the EPB bus is finished, the read data and status are        */
     /* available here.                                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srda_epb_rd;

  } __ATTRIBUTE_PACKED__ srda_epb_rd_reg;


  /* Srd4 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4980 */

     /* Srd4Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd4_ln0_cfga_reg;


  /* Srd4 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4981 */

     /* Srd4Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd4_ln0_stat_reg;


  /* Srd4 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4982 */

     /* Srd4Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd4_ln0_ebist_reg;


  /* Srd4 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4984 */

     /* Srd4Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd4_ln1_cfga_reg;


  /* Srd4 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4985 */

     /* Srd4Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd4_ln1_stat_reg;


  /* Srd4 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4986 */

     /* Srd4Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd4_ln1_ebist_reg;


  /* Srd4 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4988 */

     /* Srd4Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd4_ln2_cfga_reg;


  /* Srd4 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4989 */

     /* Srd4Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd4_ln2_stat_reg;


  /* Srd4 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x498a */

     /* Srd4Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd4_ln2_ebist_reg;


  /* Srd4 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x498c */

     /* Srd4Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd4_ln3_cfga_reg;


  /* Srd4 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x498d */

     /* Srd4Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd4_ln3_stat_reg;


  /* Srd4 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x498e */

     /* Srd4Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd4_ln3_ebist_reg;


  /* Srd4 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4990 */

     /* Srd4CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd4_cmu_cfga_reg;


  /* Srd4 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4991 */

     /* Srd4CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd4_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd4_cmu_cfgb_reg;


  /* Srd4 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4992 */

     /* Srd4CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd4_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd4_cmu_stat_reg;


  /* Srd5 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a0 */

     /* Srd5Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd5_ln0_cfga_reg;


  /* Srd5 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a1 */

     /* Srd5Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd5_ln0_stat_reg;


  /* Srd5 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a2 */

     /* Srd5Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd5_ln0_ebist_reg;


  /* Srd5 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a4 */

     /* Srd5Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd5_ln1_cfga_reg;


  /* Srd5 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a5 */

     /* Srd5Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd5_ln1_stat_reg;


  /* Srd5 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a6 */

     /* Srd5Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd5_ln1_ebist_reg;


  /* Srd5 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a8 */

     /* Srd5Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd5_ln2_cfga_reg;


  /* Srd5 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49a9 */

     /* Srd5Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd5_ln2_stat_reg;


  /* Srd5 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49aa */

     /* Srd5Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd5_ln2_ebist_reg;


  /* Srd5 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49ac */

     /* Srd5Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd5_ln3_cfga_reg;


  /* Srd5 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49ad */

     /* Srd5Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd5_ln3_stat_reg;


  /* Srd5 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49ae */

     /* Srd5Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd5_ln3_ebist_reg;


  /* Srd5 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49b0 */

     /* Srd5CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd5_cmu_cfga_reg;


  /* Srd5 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49b1 */

     /* Srd5CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd5_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd5_cmu_cfgb_reg;


  /* Srd5 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49b2 */

     /* Srd5CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd5_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd5_cmu_stat_reg;


  /* Srd6 Ln0 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c0 */

     /* Srd6Ln0Cfga: Configuration/Status/Interrupt Enable           */
     /* register for SerDes Lane 0 Rx/Tx blocks                      */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_ln0_cfga;

  } __ATTRIBUTE_PACKED__ srd6_ln0_cfga_reg;


  /* Srd6 Ln0 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c1 */

     /* Srd6Ln0Stat: SerDes Lane 0 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln0_stat;

  } __ATTRIBUTE_PACKED__ srd6_ln0_stat_reg;


  /* Srd6 Ln0 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c2 */

     /* Srd6Ln0Ebist: SerDes Lane 0 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln0_ebist;

  } __ATTRIBUTE_PACKED__ srd6_ln0_ebist_reg;


  /* Srd6 Ln1 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c4 */

     /* Srd6Ln1Cfga: SerDes Lane 1 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_ln1_cfga;

  } __ATTRIBUTE_PACKED__ srd6_ln1_cfga_reg;


  /* Srd6 Ln1 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c5 */

     /* Srd6Ln1Stat: SerDes Lane 1 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln1_stat;

  } __ATTRIBUTE_PACKED__ srd6_ln1_stat_reg;


  /* Srd6 Ln1 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c6 */

     /* Srd6Ln1Ebist: SerDes Lane 1 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln1_ebist;

  } __ATTRIBUTE_PACKED__ srd6_ln1_ebist_reg;


  /* Srd6 Ln2 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c8 */

     /* Srd6Ln2Cfga: SerDes Lane 2 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_ln2_cfga;

  } __ATTRIBUTE_PACKED__ srd6_ln2_cfga_reg;


  /* Srd6 Ln2 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49c9 */

     /* Srd6Ln2Stat: SerDes Lane 2 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln2_stat;

  } __ATTRIBUTE_PACKED__ srd6_ln2_stat_reg;


  /* Srd6 Ln2 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49ca */

     /* Srd6Ln2Ebist: SerDes Lane 2 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln2_ebist;

  } __ATTRIBUTE_PACKED__ srd6_ln2_ebist_reg;


  /* Srd6 Ln3 Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49cc */

     /* Srd6Ln3Cfga: SerDes Lane 3 Configurations                    */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_LCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_ln3_cfga;

  } __ATTRIBUTE_PACKED__ srd6_ln3_cfga_reg;


  /* Srd6 Ln3 Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49cd */

     /* Srd6Ln3Stat: SerDes Lane 3 Indications This register is      */
     /* clear on read.                                               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln3_stat;

  } __ATTRIBUTE_PACKED__ srd6_ln3_stat_reg;


  /* Srd6 Ln3 Ebist:                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49ce */

     /* Srd6Ln3Ebist: SerDes Lane 3 EBIST Indications This           */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_ln3_ebist;

  } __ATTRIBUTE_PACKED__ srd6_ln3_ebist_reg;


  /* Srd6 Cmu Cfga:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49d0 */

     /* Srd6CmuCfga: SerDes Group Common Main Configurations         */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGA_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_cmu_cfga;

  } __ATTRIBUTE_PACKED__ srd6_cmu_cfga_reg;


  /* Srd6 Cmu Cfgb:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49d1 */

     /* Srd6CmuCfgb: SerDes Group Common Secondary                   */
     /* Configurations                                               */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_CCFGB_DEFAULT */
     SOC_PETRA_REG_FIELD srd6_cmu_cfgb;

  } __ATTRIBUTE_PACKED__ srd6_cmu_cfgb_reg;


  /* Srd6 Cmu Stat:                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49d2 */

     /* Srd6CmuStat: SerDes Group Common Status register             */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srd6_cmu_stat;

  } __ATTRIBUTE_PACKED__ srd6_cmu_stat_reg;


  /* Srdb Ipu Cfg:                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49f8 */

     /* SrdbIpuCfg: Configuration Register for IPU (internal         */
     /* IPU), EPB bus, and SCIF access. Shared by all SerDeses      */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_PCFG_DEFAULT */
     SOC_PETRA_REG_FIELD srdb_ipu_cfg;

  } __ATTRIBUTE_PACKED__ srdb_ipu_cfg_reg;


  /* Srdb Epb Op:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49f9 */

     /* SrdbEpbOp: EPB OP dispatch register. Writing to this         */
     /* register causes a write or read operation to be              */
     /* dispatched on the EPB bus.                                   */
     /* range: 31:0, access type: RW, default value: `DEF_SRD_EPB_OP_DEFAULT */
     SOC_PETRA_REG_FIELD srdb_epb_op;

  } __ATTRIBUTE_PACKED__ srdb_epb_op_reg;


  /* Srdb Epb Rd:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x49fa */

     /* SrdbEpbRd: EPB OP data read register. After a read from      */
     /* the EPB bus is finished, the read data and status are        */
     /* available here.                                              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD srdb_epb_rd;

  } __ATTRIBUTE_PACKED__ srdb_epb_rd_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_MSW_REGS;
/* Block definition: EGQ */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: EGQ interrupt register                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3800 */

     /* CpuPack32BytesErr: Error in packet from CPU interface.       */
     /* Error detected during packet reassembly form the ECI.        */
     /* Cleared when error count REGXXX is read. Packet will be      */
     /* discarded.                                                   */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_pack32_bytes_err;

     /* CpuDataArrivedErr: Error in packet from CPU interface.       */
     /* CRC error detected in the arrived data from the ECI.         */
     /* Cleared when error count REGXXX is read. Packet will be      */
     /* discarded.                                                   */
     /* range: 1:1, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_data_arrived_err;

     /* PdmParErr: Parity error detected at packet descriptor        */
     /* memory. Cleared when '1' is written. If occurrs then         */
     /* soft reset is required.                                      */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD pdm_par_err;

     /* PlmParErr: Parity error detected at descriptor link          */
     /* memory. Cleared when '1' is written. If occurred then        */
     /* soft reset is required.                                      */
     /* range: 3:3, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD plm_par_err;

     /* PacketAged: Port aging timer expired and packets have        */
     /* been aged. Cleared when AgedPortId REGXXX is read.           */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD packet_aged;

     /* IntVlantableOor: Vlan table was indexed with illegal         */
     /* (>4K) index. Cleared when '1' is written. If occurrs         */
     /* then vlan table was accessed at index modulo 4K.             */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_vlantable_oor;

     /* IntDifAf: Discard FIFO is almost full                        */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_dif_af;

     /* CfcFcInt: Flow control from CFC. Refer to                    */
     /* CfcFlowControl.                                              */
     /* range: 9:9, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD cfc_fc_int;

     /* NifaFcInt: Flow control from NIFA. Refer to                  */
     /* NifaFlowControl.                                             */
     /* range: 10:10, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD nifa_fc_int;

     /* NifbFcInt: Flow control from NIFB. Refer to                  */
     /* NifbFlowControl.                                             */
     /* range: 11:11, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD nifb_fc_int;

     /* PktReasIntVec: If set then one of the interrupt bits in      */
     /* PktReasIntReg has been set                                   */
     /* range: 29:29, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_reas_int_vec;

     /* CntOvfIntVec: Overflow counter interrupt indication          */
     /* range: 30:30, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_ovf_int_vec;

     /* EccErrVec: If set then one of the bits in EccIntReg has      */
     /* been set                                                     */
     /* range: 31:31, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ecc_err_vec;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Pkt Reas Int Reg:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3801 */

     /* VscPktSizeErr: VSC packet size error.                        */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD vsc_pkt_size_err;

     /* VscMissingSopErr: VSC missing SOP error.                     */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD vsc_missing_sop_err;

     /* VscFragNumErr: VSC fragment number error.                    */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD vsc_frag_num_err;

     /* VscPktCrcErr: VSC packet CRC error.                          */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD vsc_pkt_crc_err;

     /* VscSopIntrMopErr: VSC SOP in MOP error.                      */
     /* range: 4:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD vsc_sop_intr_mop_err;

     /* VscFix129Err: VSC Fix 129 error.                             */
     /* range: 5:5, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD vsc_fix129_err;

     /* VscEopSizeErr: VSC EOP size error.                           */
     /* range: 6:6, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD vsc_eop_size_err;

     /* FscSontsErr: FSC SONTS error.                                */
     /* range: 7:7, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD fsc_sonts_err;

     /* FscPktSizeErr: FSC packet size error.                        */
     /* range: 8:8, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD fsc_pkt_size_err;

     /* FscMissingSopErr: FSC missing SOP error.                     */
     /* range: 9:9, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD fsc_missing_sop_err;

     /* FscFragNumErr: FSC fragment number error.                    */
     /* range: 10:10, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD fsc_frag_num_err;

     /* FscSopIntrMopErr: FSC SOP in MOP error.                      */
     /* range: 11:11, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD fsc_sop_intr_mop_err;

     /* FscEopSizeErr: FSC EOP size error.                           */
     /* range: 12:12, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD fsc_eop_size_err;

     /* FscSequenceErr: FSC sequence error.                          */
     /* range: 13:13, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD fsc_sequence_err;

     /* CsrPktSizeErr: CSR packet size error.                        */
     /* range: 14:14, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD csr_pkt_size_err;

     /* CsrUnexpectedEopErr: CSR unexpected EOP error.               */
     /* range: 15:15, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD csr_unexpected_eop_err;

     /* CsrMissingEopErr: CSR missing EOP error.                     */
     /* range: 16:16, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD csr_missing_eop_err;

     /* CsrSopAndEopErr: CSR SOP and EOP error.                      */
     /* range: 17:17, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD csr_sop_and_eop_err;

     /* CsrSizeParityErr: CSR size parity error.                     */
     /* range: 18:18, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD csr_size_parity_err;

     /* RejBuffSch: If set, indicates that all arriving              */
     /* scheduled packets are being rejected due to buffers          */
     /* threshold                                                    */
     /* range: 19:19, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD rej_buff_sch;

     /* RejBuffUsc: If set, indicates that all arriving              */
     /* unscheduled packets are being rejected due to buffers        */
     /* threshold                                                    */
     /* range: 20:20, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD rej_buff_usc;

     /* RejDescSch: If set, indicates that all arriving              */
     /* scheduled packets are being rejected due to descriptor       */
     /* threshold                                                    */
     /* range: 21:21, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD rej_desc_sch;

     /* RejDescUsc: If set, indicates that all arriving              */
     /* unscheduled packets are being rejected due to                */
     /* descriptors threshold                                        */
     /* range: 22:22, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD rej_desc_usc;

  } __ATTRIBUTE_PACKED__ pkt_reas_int_reg;


  /* Cnt Int Reg:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3802 */

     /* PrpSopCntOvfInt: Packet Filtering deny counter is            */
     /* overflowed. Cleared when PrpSopCnt is read. While            */
     /* overflow bit set counter continue on counting                */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD prp_sop_cnt_ovf_int;

  } __ATTRIBUTE_PACKED__ cnt_int_reg;


  /* Ecc Int Reg:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3803 */

     /* BuflinkEccErr: Buffer Link Memory                            */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD buflink_ecc_err;

     /* BuflinkEccFix: Buffer Link Memory                            */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD buflink_ecc_fix;

     /* RcntEccErr: Read counter memory                              */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD rcnt_ecc_err;

     /* RcntEccFix: Read counter memory                              */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD rcnt_ecc_fix;

     /* RrdmEccErr: RQP Descriptor context memory                    */
     /* range: 4:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD rrdm_ecc_err;

     /* RrdmEccFix: RQP Descriptor context memory                    */
     /* range: 5:5, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD rrdm_ecc_fix;

     /* RpdmEccErr: RQP Packet Reassembly Descriptor memory          */
     /* range: 6:6, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD rpdm_ecc_err;

     /* RpdmEccFix: RQP Packet Reassembly Descriptor memory          */
     /* range: 7:7, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD rpdm_ecc_fix;

  } __ATTRIBUTE_PACKED__ ecc_int_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3810 */

     /* MaskCpuPack32BytesErr:                                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_cpu_pack32_bytes_err;

     /* MaskCpuDataArrivedErr:                                       */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_cpu_data_arrived_err;

     /* MaskPdmParErr:                                               */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_pdm_par_err;

     /* MaskPlmParErr:                                               */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_plm_par_err;

     /* MaskPacketAged:                                              */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_packet_aged;

     /* MaskntVlantableOor:                                          */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD masknt_vlantable_oor;

     /* MaskIntDifAf:                                                */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_int_dif_af;

     /* MaskIntUcfifoAf:                                             */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_int_ucfifo_af;

     /* MaskPqpLbpTh:                                                */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_pqp_lbp_th;

     /* MaskCfcFcInt:                                                */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_cfc_fc_int;

     /* MaskNifaFcInt:                                               */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_nifa_fc_int;

     /* MaskNifbFcInt:                                               */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_nifb_fc_int;

     /* MaskPktReasIntVec:                                           */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_pkt_reas_int_vec;

     /* MaskCntOvfIntVec:                                            */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_cnt_ovf_int_vec;

     /* MaskEccErrVec:                                               */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_ecc_err_vec;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Pkt Reas Int Reg Mask:                                         */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x3811 */

    /* VscPktSizeErr: VSC packet size error.                        */
    /* range: 0:0, access type: UNDEF, default value: 0x0           */
    SOC_PETRA_REG_FIELD vsc_pkt_size_err_mask;

    /* VscMissingSopErr: VSC missing SOP error.                     */
    /* range: 1:1, access type: UNDEF, default value: 0x0           */
    SOC_PETRA_REG_FIELD vsc_missing_sop_err_mask;

    /* VscFragNumErr: VSC fragment number error.                    */
    /* range: 2:2, access type: UNDEF, default value: 0x0           */
    SOC_PETRA_REG_FIELD vsc_frag_num_err_mask;

    /* VscPktCrcErr: VSC packet CRC error.                          */
    /* range: 3:3, access type: UNDEF, default value: 0x0           */
    SOC_PETRA_REG_FIELD vsc_pkt_crc_err_mask;

    /* VscSopIntrMopErr: VSC SOP in MOP error.                      */
    /* range: 4:4, access type: UNDEF, default value: 0x0           */
    SOC_PETRA_REG_FIELD vsc_sop_intr_mop_err_mask;

    /* VscFix129Err: VSC Fix 129 error.                             */
    /* range: 5:5, access type: UNDEF, default value: 0x0           */
    SOC_PETRA_REG_FIELD vsc_fix129_err_mask;

    /* VscEopSizeErr: VSC EOP size error.                           */
    /* range: 6:6, access type: UNDEF, default value: 0x0           */
    SOC_PETRA_REG_FIELD vsc_eop_size_err_mask;

    /* FscSontsErr: FSC SONTS error.                                */
    /* range: 7:7, access type: UNDEF, default value: 0x0           */
    SOC_PETRA_REG_FIELD fsc_sonts_err_mask;

    /* FscPktSizeErr: FSC packet size error.                        */
    /* range: 8:8, access type: UNDEF, default value: 0x0           */
    SOC_PETRA_REG_FIELD fsc_pkt_size_err_mask;

    /* FscMissingSopErr: FSC missing SOP error.                     */
    /* range: 9:9, access type: UNDEF, default value: 0x0           */
    SOC_PETRA_REG_FIELD fsc_missing_sop_err_mask;

    /* FscFragNumErr: FSC fragment number error.                    */
    /* range: 10:10, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD fsc_frag_num_err_mask;

    /* FscSopIntrMopErr: FSC SOP in MOP error.                      */
    /* range: 11:11, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD fsc_sop_intr_mop_err_mask;

    /* FscEopSizeErr: FSC EOP size error.                           */
    /* range: 12:12, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD fsc_eop_size_err_mask;

    /* FscSequenceErr: FSC sequence error.                          */
    /* range: 13:13, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD fsc_sequence_err_mask;

    /* CsrPktSizeErr: CSR packet size error.                        */
    /* range: 14:14, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD csr_pkt_size_err_mask;

    /* CsrUnexpectedEopErr: CSR unexpected EOP error.               */
    /* range: 15:15, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD csr_unexpected_eop_err_mask;

    /* CsrMissingEopErr: CSR missing EOP error.                     */
    /* range: 16:16, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD csr_missing_eop_err_mask;

    /* CsrSopAndEopErr: CSR SOP and EOP error.                      */
    /* range: 17:17, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD csr_sop_and_eop_err_mask;

    /* CsrSizeParityErr: CSR size parity error.                     */
    /* range: 18:18, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD csr_size_parity_err_mask;

    /* RejBuffSch: If set, indicates that all arriving              */
    /* scheduled packets are being rejected due to buffers          */
    /* threshold                                                    */
    /* range: 19:19, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD rej_buff_sch_mask;

    /* RejBuffUsc: If set, indicates that all arriving              */
    /* unscheduled packets are being rejected due to buffers        */
    /* threshold                                                    */
    /* range: 20:20, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD rej_buff_usc_mask;

    /* RejDescSch: If set, indicates that all arriving              */
    /* scheduled packets are being rejected due to descriptor       */
    /* threshold                                                    */
    /* range: 21:21, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD rej_desc_sch_mask;

    /* RejDescUsc: If set, indicates that all arriving              */
    /* unscheduled packets are being rejected due to                */
    /* descriptors threshold                                        */
    /* range: 22:22, access type: UNDEF, default value: 0x0         */
    SOC_PETRA_REG_FIELD rej_desc_usc_mask;

  } __ATTRIBUTE_PACKED__ pkt_reas_int_reg_mask_reg;


  /* Cnt Int Reg Mask:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3812 */

     /* CntIntRegMask:                                               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cnt_int_reg_mask;

  } __ATTRIBUTE_PACKED__ cnt_int_reg_mask_reg;


  /* Ecc Int Reg Mask:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3813 */

     /* EccIntRegMask:                                               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD buflink_ecc_err_mask;

     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD buflink_ecc_fix_mask;
     
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcnt_ecc_err_mask;

     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcnt_ecc_fix_mask;

     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rrdm_ecc_err_mask;

     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rrdm_ecc_fix_mask;

     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rpdm_ecc_err_mask;

     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rpdm_ecc_fix_mask;

  } __ATTRIBUTE_PACKED__ ecc_int_reg_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3820 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3821 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3822 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_2;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3823 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_3;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3824 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_4;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3825 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_5;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3826 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_6;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3827 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_7;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3830 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3831 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3832 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_2;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3833 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_3;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3834 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_4;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3835 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_5;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3836 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_6;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3837 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_7;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3840 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set, to 0, one       */
     /* operation is performed. The cpu can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set, to 0, then the command has no timeout.       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3841 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg;


  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg;


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg1;


  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg1;


  /* Cpu Packet Control: CPU interface for packet transmit to       */
  /* the FAP when the CPU interface is working in                   */
  /* asynchronous (non-streaming) mode. This register               */
  /* triggers the transmission of a 32B of payload, which was       */
  /* written to the registers below.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3865 */

     /* SendPktFrag: Trigger to write a 32-byte packet fragment.     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD send_pkt_frag;

     /* StartOfPacket: Indicates the fragment contains start of      */
     /* packet                                                       */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD start_of_packet;

     /* EndOfPacket: Indicates the fragment contains end of          */
     /* packet                                                       */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD end_of_packet;

     /* PktFragErr: Indicates the fragment is error (for debug       */
     /* only)                                                        */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD pkt_frag_err;

  } __ATTRIBUTE_PACKED__ cpu_packet_control_reg;


  /* Cpu Packet Fragmentation Words: Packet Fragmentation           */
  /* words for CPU non-streaming interface                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3866 */

     /* PacketWord7: Packet fragmentation words 7 for reg #0         */
     /* down to words 0 for reg #7.                                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD packet_word;

  } __ATTRIBUTE_PACKED__ cpu_packet_fragmentation_words_reg[SOC_PETRA_CPU_PACKET_FRAGMENTATION_REGS];


  /* EGQBlock Init Status: EGQ internal memories                    */
  /* initialization status indication                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3870 */

     /* EGQBlockInit: If set, then block initialization is in        */
     /* process. This bit is cleared by the device upon              */
     /* completion of all initialization processes (approx. 4096     */
     /* clock cycles)                                                */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD egqblock_init;

  } __ATTRIBUTE_PACKED__ egqblock_init_status_reg;


  /* Ecc Corecction Disable: Ecc correction disable setting         */
  /* bits for debug purpose                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3871 */

     /* BuflinkDisEcc: If set, then disables the ECC decoder on      */
     /* BufLink memory output                                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD buflink_dis_ecc;

     /* RcntDisEcc: If set, then disables the ECC decoder on         */
     /* RCNT memory output                                           */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcnt_dis_ecc;

     /* RrdmDisEcc: If set, then disables the ECC decoder on         */
     /* RRDM memory output                                           */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rrdm_dis_ecc;

     /* RpdmDisEcc: If set, then disables the ECC decoder on         */
     /* RPDM memory output                                           */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rpdm_dis_ecc;

  } __ATTRIBUTE_PACKED__ ecc_corecction_disable_reg;


  /* Tdm Configuration: Configures the TDM port mapping.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3873 */

     /* TdmNifaEn: If set, then TDM traffic to NIF A is enabled.     */
     /* If TDM enabled it feeds NIF A from TDM A and TDM B           */
     /* queues.                                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_nifa_en;

     /* TdmNifbEn: If set, then TDM traffic to NIF B is enabled.     */
     /* If TDM enabled it feeds NIF B from TDM C and TDM D           */
     /* queues.                                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_nifb_en;

  } __ATTRIBUTE_PACKED__ tdm_configuration_reg;


  /* Maximum Fragment Number: Maximum fragment number               */
  /* supported size                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3874 */

     /* MaxFrgNum: Set the maximum supported fragment number         */
     /* size which arriving cells with higer fragment number are     */
     /* recognized as error packet stream. Defualt value are         */
     /* sutible for VSC mode. For Fix mode it depends whthere        */
     /* there is TDM mode enabled. When TDM enabled maximum          */
     /* fragment size should be 256 other wise 511 is allowed        */
     /* (nearly 16KB)                                                */
     /* range: 8:0, access type: RW, default value: 0x50             */
     SOC_PETRA_REG_FIELD max_frg_num;

  } __ATTRIBUTE_PACKED__ maximum_fragment_number_reg;


  /* Fabric Minimum Packet Size: Minimum fabric packet size         */
  /* supported                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3875 */

     /* FabricMinPktSize: Set the fabric minimum packet size         */
     /* supported.                                                   */
     /* range: 9:0, access type: RW, default value: 0x21             */
     SOC_PETRA_REG_FIELD fabric_min_pkt_size;

  } __ATTRIBUTE_PACKED__ fabric_minimum_packet_size_reg;


  /* Egq Local And Fabric Arbiter: Arbitration priority             */
  /* settings between local route and fabric route. Default         */
  /* mode (All fields clear) is Round Robin between local           */
  /* route and fabric route                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3876 */

     /* LocalVsFabricArb: Configure the arbitration scheme           */
     /* between the local route to the fabric route. according       */
     /* to the following Encoding of the 2 lsb bits: '00' -          */
     /* Round Robin '01' - Fabric route gets strict priority         */
     /* '10' - Local route gets strict priority '11' - Weighted      */
     /* round-robin arbitration between fabric route and local       */
     /* route. Arbitration ratio of 4:1 (fabric route gets high      */
     /* weight) If the MSB is set, then Local route gets strict      */
     /* priority when IPT_TX signal is set (threshold crossed        */
     /* indication from the IPT)                                     */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD local_vs_fabric_arb;

  } __ATTRIBUTE_PACKED__ egq_local_and_fabric_arbiter_reg;


  /* Reassembly Reject Threshold Enable Configuration:              */
  /* Reassembly segments rejecting enable settings                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3877 */

     /* RejSchdDescThEn: Enable discard of scheduled packets         */
     /* during Reassembly because not enough available               */
     /* descriptors                                                  */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rej_schd_desc_th_en;

     /* RejUnSchdDescThEn: Enable discard of unscheduled packets     */
     /* during Reassembly because not enough available               */
     /* descriptors.                                                 */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rej_un_schd_desc_th_en;

     /* RejSchdBuffThEn: Enable discard of scheduled packets         */
     /* during Reassembly because not enough available buffers.      */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rej_schd_buff_th_en;

     /* RejUnSchdBuffThEn: Enable discard of unscheduled packets     */
     /* during Reassembly because not enough available buffers.      */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rej_un_schd_buff_th_en;

  } __ATTRIBUTE_PACKED__ reassembly_reject_threshold_enable_configuration_reg;


  /* Schededuled Reject Buffer Threshold: Re-assembly reject        */
  /* scheduled packets due to buffer occupancy thresholds.          */
  /* Threshold defined as five bits of mantissa (MSB) and           */
  /* four bits of exponent (LSB)                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3878 */

     /* ClearReasRejSchdBuffTh: Configures the threshold of          */
     /* number of available buffers to clear the reassembly          */
     /* reject flag for scheduled packets. The flag is cleared       */
     /* when this threshold is crossed from below. Admission of      */
     /* scheduled packets for reassembly resumes                     */
     /* range: 8:0, access type: RW, default value: 0x4a             */
     SOC_PETRA_REG_FIELD clear_reas_rej_schd_buff_th;

     /* SetReasRejSchdBuffTh: Configures the threshold of number     */
     /* of available buffers to set the reassembly reject flag       */
     /* for scheduled packets. The flag is set when this             */
     /* threshold is crossed from above. When this flag is set,       */
     /* all arriving scheduled packets are rejected until the        */
     /* number of available buffers crosses the                      */
     /* ClearReasRejSchdBuffTh from below                            */
     /* range: 24:16, access type: RW, default value: 0x4a           */
     SOC_PETRA_REG_FIELD set_reas_rej_schd_buff_th;

  } __ATTRIBUTE_PACKED__ schededuled_reject_buffer_threshold_reg;


  /* Scheduled Reject Descriptor Threshold: Reassembly reject       */
  /* scheduled packets due to descriptor occupancy                  */
  /* thresholds. Threshold defined as five bits of of               */
  /* mantissa (MSB) and four bits of exponent (LSB)                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3879 */

     /* ClearReasRejSchdDescTh: Configures the threshold of          */
     /* number of available descriptors to clear the reassembly      */
     /* reject flag for scheduled packets. The flag is cleared       */
     /* when this threshold is crossed from below. Admission of      */
     /* scheduled packets for reassembly resumes                     */
     /* range: 8:0, access type: RW, default value: 0x8a             */
     SOC_PETRA_REG_FIELD clear_reas_rej_schd_desc_th;

     /* SetReasRejSchdDescTh: Configures the threshold of number     */
     /* of available descriptors to set the reassembly reject        */
     /* flag for scheduled packets. The flag is set when this        */
     /* threshold is crossed from above. When this flag is set,       */
     /* all arriving scheduled packets are rejected until the        */
     /* number of available descriptors crosses the                  */
     /* ClearReasRejSchdDescTh from below                            */
     /* range: 24:16, access type: RW, default value: 0x8a           */
     SOC_PETRA_REG_FIELD set_reas_rej_schd_desc_th;

  } __ATTRIBUTE_PACKED__ scheduled_reject_descriptor_threshold_reg;


  /* Unscheduled Reject Buffer Threshold: Reassembly reject         */
  /* unscheduled packets due to buffer occupancy thresholds.        */
  /* Threshold defined as five bits of of mantissa (MSB) and        */
  /* four bits of exponent (LSB)                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x387a */

     /* ClearReasRejUnSchdBuffTh: Configures the threshold of        */
     /* number of available buffers to clear the reassembly          */
     /* reject flag for unscheduled packets. The flag is cleared     */
     /* when this threshold is crossed from below. Admission of      */
     /* unscheduled packets for reassembly resumes                   */
     /* range: 8:0, access type: RW, default value: 0x4a             */
     SOC_PETRA_REG_FIELD clear_reas_rej_un_schd_buff_th;

     /* SetReasRejUnSchdBuffTh: Configures the threshold of          */
     /* number of available buffers to set the reassembly reject     */
     /* flag for unscheduled packets. The flag is set when this      */
     /* threshold is crossed from above. When this flag is set,      */
     /* all arriving unscheduled packets are rejected until the      */
     /* number of available buffers crosses the                      */
     /* ClearReasRejUnSchdBuffTh from below                          */
     /* range: 24:16, access type: RW, default value: 0x4a           */
     SOC_PETRA_REG_FIELD set_reas_rej_un_schd_buff_th;

  } __ATTRIBUTE_PACKED__ unscheduled_reject_buffer_threshold_reg;


  /* Unscheduled Reject Descriptor Threshold: Reassembly            */
  /* reject unscheduled packets due to descriptor occupancy         */
  /* thresholds. Threshold defined as five bits of of               */
  /* mantissa (MSB) and four bits of exponent (LSB)                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x387b */

     /* ClearReasRejUnSchdDescTh: Configures the threshold of        */
     /* number of available descriptors to clear the reassembly      */
     /* reject flag for unscheduled packets. The flag is cleared     */
     /* when this threshold is crossed from below. Admission of      */
     /* unscheduled packets for reassembly resumes                   */
     /* range: 8:0, access type: RW, default value: 0x8a             */
     SOC_PETRA_REG_FIELD clear_reas_rej_un_schd_desc_th;

     /* SetReasRejUnSchdDescTh: Configures the threshold of          */
     /* number of available descriptors to set the reassembly        */
     /* reject flag for unscheduled packets. The flag is set         */
     /* when this threshold is crossed from above. When this         */
     /* flag is set, all arriving unscheduled packets are            */
     /* rejected until the number of available descriptors           */
     /* crosses the ClearReasRejUnSchdDescTh from below              */
     /* range: 24:16, access type: RW, default value: 0x8a           */
     SOC_PETRA_REG_FIELD set_reas_rej_un_schd_desc_th;

  } __ATTRIBUTE_PACKED__ unscheduled_reject_descriptor_threshold_reg;


  /* Multicast Packet Header Shim Layer Translation: Shim           */
  /* layer translation configurable fields for multicast            */
  /* headers. Transfers FAP20 fabric headers to Soc_petra fabric        */
  /* headers. Applicable when FAP20Mode is enabled and              */
  /* Fap20FabricHdrFormat                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x387d */

     /* McOutLifMsb: Sets value of OutLif Field                      */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mc_out_lif_msb;

     /* McEpphPresent: Sets value of EPPH Present bit                */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mc_epph_present;

     /* McIngQSig: Sets value of Ingress Q field                     */
     /* range: 5:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mc_ing_qsig;

     /* McDp: Sets value of DP field                                 */
     /* range: 7:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mc_dp;

     /* McOutMirrorDisable: Sets value of Out Mirror Disable bit     */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mc_out_mirror_disable;

  } __ATTRIBUTE_PACKED__ multicast_packet_header_shim_layer_translation_reg;


  /* Shim Layer Translation Multicast Class Mapping Table:          */
  /* Shim layer multicast class mapping lookup table for            */
  /* multicast headers                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x387e */

     /* McClassMap4to8: Multicast class mapping 4 to 8 table         */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mc_class_map4to8;

  } __ATTRIBUTE_PACKED__ shim_layer_translation_multicast_class_mapping_table_reg;


  /* Unicast Packet Header Shim Layer Translation: Shim layer       */
  /* translation configurable fields for unicast header.            */
  /* Transfers FAP20 headers to Soc_petra headers                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x387f */

     /* UcEpphPresent: Sets value of EPPH Present bit                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD uc_epph_present;

     /* UcIngQSig: Sets value of Ingress Q field                     */
     /* range: 2:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD uc_ing_qsig;

     /* UcDp: Sets value of DP field                                 */
     /* range: 4:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD uc_dp;

     /* UcOutMirrorDisable: Sets value of Out Mirror Disable bit     */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD uc_out_mirror_disable;

  } __ATTRIBUTE_PACKED__ unicast_packet_header_shim_layer_translation_reg;


  /* Available Free Resources: Indicates the number of              */
  /* current available free descriptors and buffers in the          */
  /* EGQ (Out from 8K available descriptors and 4K available        */
  /* buffers)                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3881 */

     /* AvailableFreeDescriptors: The number of available free       */
     /* descriptors                                                  */
     /* range: 13:0, access type: RO, default value: 0x2000          */
     SOC_PETRA_REG_FIELD available_free_descriptors;

     /* AvailableFreeBuffers: The number of available free           */
     /* buffers                                                      */
     /* range: 28:16, access type: RO, default value: 0xfff          */
     SOC_PETRA_REG_FIELD available_free_buffers;

  } __ATTRIBUTE_PACKED__ available_free_resources_reg;

  /* Fabric Route Sop Counter: Indicates the number Sop received   */
  /* from fabric and whether there was counter overflow            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3882 */

     /* FsrSopCnt: Counts the number of Sop received from fabric and */
     /*  whether there was counter overflow. This register is clear  */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsr_sop_cnt;

     /* FsrSopCntOvf: If set, then indicates that the counter has     */
     /* overflowed. This register is clear on read.                   */
     /* range: 31:31, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD fsr_sop_cnt_ovf;

  } __ATTRIBUTE_PACKED__ fabric_route_sop_counter;

  /* Local Route Sop Counter: Indicates the number Sop received   */
  /* from local and whether there was counter overflow            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3883 */

     /* LsrSopCnt: Counts the number of Sop received from local and  */
     /*  whether there was counter overflow. This register is clear  */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lsr_sop_cnt;

     /* LsrSopCntOvf: If set, then indicates that the counter has     */
     /* overflowed. This register is clear on read.                   */
     /* range: 31:31, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD lsr_sop_cnt_ovf;

  } __ATTRIBUTE_PACKED__ local_route_sop_counter;

  /* CPU interface Sop Counter: Indicates the number Sop received   */
  /* from CPU interface and whether there was counter overflow            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3884 */

     /* CsrSopCnt: Counts the number of Sop received from CPU interface and */
     /*  whether there was counter overflow. This register is clear  */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD csr_sop_cnt;

     /* CsrSopCntOvf: If set, then indicates that the counter has     */
     /* overflowed. This register is clear on read.                   */
     /* range: 31:31, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD csr_sop_cnt_ovf;

  } __ATTRIBUTE_PACKED__ cpu_interface_sop_counter;

  /* Packet reassembly output Sop Counter: Indicates the number Sop completed   */
  /* packet reassembly without errors and whether there was counter overflow   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3885 */

     /* PrpSopCnt: Counts the number of Sop received transferred from EHP to PRP */
     /*  whether there was counter overflow. This register is clear  */
     /* on read.                                                     */
     /* range: 62:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prp_sop_cnt;

  } __ATTRIBUTE_PACKED__ packet_reassembly_sop_counter_0;

  /* Packet reassembly output Sop Counter: Indicates the number Sop completed   */
  /* packet reassembly without errors and whether there was counter overflow   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3886 */

     /* PrpSopCnt: Counts the number of Sop received transferred from EHP to PRP */
     /*  whether there was counter overflow. This register is clear  */
     /* on read.                                                     */
     /* range: 62:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prp_sop_cnt;

     /* PrpSopCntOvf: If set, then indicates that the counter has     */
     /* overflowed. This register is clear on read.                   */
     /* range: 63:63, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD prp_sop_cnt_ovf;

  } __ATTRIBUTE_PACKED__ packet_reassembly_sop_counter_1;


  /* Egress De Queue Scheme: Configure the scheme of the            */
  /* egress dequeue                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3890 */

     /* SchdQueueScheme: Select between two scheduling scheme        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD schd_queue_scheme;

  } __ATTRIBUTE_PACKED__ egress_de_queue_scheme_reg;


  /* Oc768 Unicast Multicast Weight: unicast versus multicast       */
  /* weigths used only in OC768 mode.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3892 */

     /* Oc768UnicastWeight: Unicast subqueue weight used in the      */
     /* WFQ scheduler.                                               */
     /* range: 7:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD oc768_unicast_weight;

     /* Oc768MulticastWeight: Multicast subqueue weight used in      */
     /* the WFQ scheduler.                                           */
     /* range: 15:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD oc768_multicast_weight;

  } __ATTRIBUTE_PACKED__ oc768_unicast_multicast_weight_reg;


  /* Unscheduled Resources Low Queues Thresholds For Drop           */
  /* Precedence0: Thresholds configuration of unscheduled low       */
  /* queues total consumed resources. Threshold defined as          */
  /* five bits of mantissa (MSB) and four bits of exponent          */
  /* (LSB)                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3893 */

     /* TotalUscWrds: Sets the threshold for the number of total     */
     /* consumed 32B words of multicast packets, above which         */
     /* unscheduled low queues packets of multicast DP0 are          */
     /* rejected.                                                    */
     /* range: 8:0, access type: RW, default value: 0x1ea            */
     SOC_PETRA_REG_FIELD total_usc_wrds;

     /* TotalUscPkts: Sets the threshold for the number of total     */
     /* packets above which unscheduled low queues packets of        */
     /* multicast DP0 are rejected.                                  */
     /* range: 24:16, access type: RW, default value: 0x1e8          */
     SOC_PETRA_REG_FIELD total_usc_pkts;

  } __ATTRIBUTE_PACKED__ unsched_qs_threshs_for_dp_reg_0[SOC_PETRA_REGS_NOF_EGR_Q_PRIORITIES][SOC_PETRA_NOF_DROP_PRECEDENCE];


  /* Unscheduled Resources Low Queues Thresholds For Drop           */
  /* Precedence0: Thresholds configuration of unscheduled low       */
  /* queues total consumed resources. Threshold defined as          */
  /* five bits of mantissa (MSB) and four bits of exponent          */
  /* (LSB)                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3894 */

     /* AvailUscDesc: Sets the thresholds for the number of          */
     /* available packet descriptors, below which unscheduled        */
     /* low queues packets of multicast DP0 are rejected.            */
     /* range: 8:0, access type: RW, default value: 0x1a             */
     SOC_PETRA_REG_FIELD avail_usc_desc;

     /* AvailUscBufs: Sets the threshold for the number of           */
     /* available data buffers, below which unscheduled low          */
     /* queues packets of multicast DP0 are rejected.                */
     /* range: 24:16, access type: RW, default value: 0x16           */
     SOC_PETRA_REG_FIELD avail_usc_bufs;

  } __ATTRIBUTE_PACKED__ unsched_qs_threshs_for_dp_reg_1[SOC_PETRA_REGS_NOF_EGR_Q_PRIORITIES][SOC_PETRA_NOF_DROP_PRECEDENCE];


  /* Unscheduled Resources Low Queues Thresholds For Drop           */
  /* Precedence0: Thresholds configuration of unscheduled low       */
  /* queues total consumed resources. Threshold defined as          */
  /* five bits of mantissa (MSB) and four bits of exponent          */
  /* (LSB)                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3895 */

     /* UchQueueWrdsType0: Sets the threshold for the number of      */
     /* total 32B words in unscheduled low queues of DP0 and         */
     /* type 0, above which packets to this queues are rejected.     */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD uch_queue_wrds_type0;

     /* UchQueueWrdsType1: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of DP0 and type      */
     /* 1, above which packets to this queues are rejected.          */
     /* range: 24:16, access type: RW, default value: 0x1fa          */
     SOC_PETRA_REG_FIELD uch_queue_wrds_type1;

  } __ATTRIBUTE_PACKED__ unsched_qs_threshs_for_dp_reg_2[SOC_PETRA_REGS_NOF_EGR_Q_PRIORITIES][SOC_PETRA_NOF_DROP_PRECEDENCE];


  /* Unscheduled Resources Low Queues Thresholds For Drop           */
  /* Precedence0: Thresholds configuration of unscheduled low       */
  /* queues total consumed resources. Threshold defined as          */
  /* five bits of mantissa (MSB) and four bits of exponent          */
  /* (LSB)                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3896 */

     /* UchQueueWrdsType2: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of DP0 and type      */
     /* 2, above which packets to this queues are rejected.          */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD uch_queue_wrds_type2;

     /* UchQueueWrdsType3: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of DP0 and type      */
     /* 3, above which packets to this queues are rejected.          */
     /* range: 24:16, access type: RW, default value: 0x1fa          */
     SOC_PETRA_REG_FIELD uch_queue_wrds_type3;

  } __ATTRIBUTE_PACKED__ unsched_qs_threshs_for_dp_reg_3[SOC_PETRA_REGS_NOF_EGR_Q_PRIORITIES][SOC_PETRA_NOF_DROP_PRECEDENCE];

  /* Scheduled Low Queues Resource Consumption Thresholds:          */
  /* Thresholds configuration of scheduled low queues total         */
  /* consumed resources. Threshold defined as five bits of          */
  /* mantissa (MSB) and four bits of exponent (LSB)                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38b3 */

     /* TotalSchWrds: Sets the threshold for the number of total     */
     /* consumed 32B words, above which arrived scheduled low        */
     /* queue packets are rejected.                                  */
     /* range: 8:0, access type: RW, default value: 0x1ea            */
     SOC_PETRA_REG_FIELD total_sch_wrds;

     /* TotalSchPkts: Sets the threshold for the number of total     */
     /* number of packets, above which arrived scheduled low         */
     /* queue packets are rejected.                                  */
     /* range: 24:16, access type: RW, default value: 0x1e8          */
     SOC_PETRA_REG_FIELD total_sch_pkts;

  } __ATTRIBUTE_PACKED__ sched_qs_rsc_consumption_threshs_reg_0[SOC_PETRA_REGS_NOF_EGR_Q_PRIORITIES];


  /* Scheduled Low Queues Resource Consumption Thresholds:          */
  /* Thresholds configuration of scheduled low queues total         */
  /* consumed resources. Threshold defined as five bits of          */
  /* mantissa (MSB) and four bits of exponent (LSB)                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38b4 */

     /* AvailSchDscs: Sets the threshold for the number of           */
     /* available packet descriptors, below which arrived            */
     /* scheduled low queue packets are rejected.                    */
     /* range: 8:0, access type: RW, default value: 0x57             */
     SOC_PETRA_REG_FIELD avail_sch_dscs;

     /* AvailSchBufs: Sets the threshold for the number of           */
     /* available data buffers, below which arrived scheduled        */
     /* low queue packets are rejected.                              */
     /* range: 24:16, access type: RW, default value: 0x17           */
     SOC_PETRA_REG_FIELD avail_sch_bufs;

  } __ATTRIBUTE_PACKED__ sched_qs_rsc_consumption_threshs_reg_1[SOC_PETRA_REGS_NOF_EGR_Q_PRIORITIES];


  /* Scheduled Low Queues Resource Consumption Thresholds:          */
  /* Thresholds configuration of scheduled low queues total         */
  /* consumed resources. Threshold defined as five bits of          */
  /* mantissa (MSB) and four bits of exponent (LSB)                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38b5 */

     /* SchQueueWrdsType0: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 0, above     */
     /* which packets to this queues are rejected.                   */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type0;

     /* SchQueueWrdsType1: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 1, above     */
     /* which packets to this queues are rejected.                   */
     /* range: 24:16, access type: RW, default value: 0x1fa          */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type1;

  } __ATTRIBUTE_PACKED__ sched_qs_rsc_consumption_threshs_reg_2[SOC_PETRA_REGS_NOF_EGR_Q_PRIORITIES];


  /* Scheduled Low Queues Resource Consumption Thresholds:          */
  /* Thresholds configuration of scheduled low queues total         */
  /* consumed resources. Threshold defined as five bits of          */
  /* mantissa (MSB) and four bits of exponent (LSB)                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38b6 */

     /* SchQueueWrdsType2: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 2, above     */
     /* which packets to this queues are rejected.                   */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type2;

     /* SchQueueWrdsType3: Sets the threshold for the number of      */
     /* total 32B words in scheduled low queues of type 3, above     */
     /* which packets to this queues are rejected.                   */
     /* range: 24:16, access type: RW, default value: 0x1fa          */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type3;

  } __ATTRIBUTE_PACKED__ sched_qs_rsc_consumption_threshs_reg_3[SOC_PETRA_REGS_NOF_EGR_Q_PRIORITIES];


  /* Scheduled High Queues Resource Consumption Thresholds:         */
  /* Thresholds of scheduled high queues total consumed             */
  /* resources. Threshold defined as five bits of mantissa          */
  /* (MSB) and four bits of exponent (LSB)                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38b7 */

     /* TotalSchWrds: Sets the threshold for the number of total     */
     /* consumed 32B words, above which arrived scheduled high       */
     /* queues packets are rejected.                                 */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD total_sch_wrds;

     /* TotalSchPkts: Sets the threshold for the number of total     */
     /* number of packets, above which arrived scheduled high        */
     /* queues packets are rejected.                                 */
     /* range: 24:16, access type: RW, default value: 0x1f8          */
     SOC_PETRA_REG_FIELD total_sch_pkts;

  } __ATTRIBUTE_PACKED__ scheduled_high_queues_resource_consumption_thresholds_reg_0;


  /* Scheduled High Queues Resource Consumption Thresholds:         */
  /* Thresholds of scheduled high queues total consumed             */
  /* resources. Threshold defined as five bits of mantissa          */
  /* (MSB) and four bits of exponent (LSB)                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38b8 */

     /* AvailSchDscs: Sets the threshold for the number of           */
     /* available packet descriptors, below which arrived            */
     /* scheduled high queues packets are rejected.                  */
     /* range: 8:0, access type: RW, default value: 0x1a             */
     SOC_PETRA_REG_FIELD avail_sch_dscs;

     /* AvailSchBufs: Sets the threshold for the number of           */
     /* available data buffers, below which arrived scheduled        */
     /* high queues packets are rejected.                            */
     /* range: 24:16, access type: RW, default value: 0x16           */
     SOC_PETRA_REG_FIELD avail_sch_bufs;

  } __ATTRIBUTE_PACKED__ scheduled_high_queues_resource_consumption_thresholds_reg_1;


  /* Scheduled High Queues Resource Consumption Thresholds:         */
  /* Thresholds of scheduled high queues total consumed             */
  /* resources. Threshold defined as five bits of mantissa          */
  /* (MSB) and four bits of exponent (LSB)                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38b9 */

     /* SchQueueWrdsType0: Sets the threshold for the number of      */
     /* total 32B words in scheduled high queues of type 0,          */
     /* above which packets to this queues are rejected.             */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type0;

     /* SchQueueWrdsType1: Sets the threshold for the number of      */
     /* total 32B words in scheduled high queues of type 1,          */
     /* above which packets to this queues are rejected.             */
     /* range: 24:16, access type: RW, default value: 0x1fa          */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type1;

  } __ATTRIBUTE_PACKED__ scheduled_high_queues_resource_consumption_thresholds_reg_2;


  /* Scheduled High Queues Resource Consumption Thresholds:         */
  /* Thresholds of scheduled high queues total consumed             */
  /* resources. Threshold defined as five bits of mantissa          */
  /* (MSB) and four bits of exponent (LSB)                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38ba */

     /* SchQueueWrdsType2: Sets the threshold for the number of      */
     /* total 32B words in scheduled high queues of type 2,          */
     /* above which packets to this queues are rejected.             */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type2;

     /* SchQueueWrdsType3: Sets the threshold for the number of      */
     /* total 32B words in scheduled high queues of type 3,          */
     /* above which packets to this queues are rejected.             */
     /* range: 24:16, access type: RW, default value: 0x1fa          */
     SOC_PETRA_REG_FIELD sch_queue_wrds_type3;

  } __ATTRIBUTE_PACKED__ scheduled_high_queues_resource_consumption_thresholds_reg_3;


  /* Total Resources Consumption Thresholds Configuration For       */
  /* Device Flow Control: Egress resources consumption              */
  /* thresholds configuration for device flow-control.              */
  /* Treshold defined as five bits of mantissa (MSB) and four       */
  /* bits of exponent (LSB)                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38bb */

     /* TotalDvcFcSchWrds: Sets the threshold for the number of      */
     /* total consumed 32B scheduled words, above which device       */
     /* flow-control is asserted.                                    */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD total_dvc_fc_sch_wrds;

     /* TotalDvcFcSchBufs: Sets the threshold for the number of      */
     /* total consumed scheduled data buffers above which device     */
     /* flow-control is asserted.                                    */
     /* range: 24:16, access type: RW, default value: 0x1f7          */
     SOC_PETRA_REG_FIELD total_dvc_fc_sch_bufs;

  } __ATTRIBUTE_PACKED__ total_rcs_consumption_threshs_conf_for_dev_flow_ctrl_reg_0;


  /* Total Resources Consumption Thresholds Configuration For       */
  /* Device Flow Control: Egress resources consumption              */
  /* thresholds configuration for device flow-control.              */
  /* Treshold defined as five bits of mantissa (MSB) and four       */
  /* bits of exponent (LSB)                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38bc */

     /* TotalDvcFcSchDscs: Sets the threshold for the number of      */
     /* total scheduled packet descriptors above which device        */
     /* flow-control is asserted.                                    */
     /* range: 8:0, access type: RW, default value: 0x1f8            */
     SOC_PETRA_REG_FIELD total_dvc_fc_sch_dscs;

     /* TotalDvcFcWrds: Sets the threshold for the number of         */
     /* total consumed 32B words, above which device                 */
     /* flow-control is asserted.                                    */
     /* range: 24:16, access type: RW, default value: 0x1fa          */
     SOC_PETRA_REG_FIELD total_dvc_fc_wrds;

  } __ATTRIBUTE_PACKED__ total_rcs_consumption_threshs_conf_for_dev_flow_ctrl_reg_1;


  /* Total Resources Consumption Thresholds Configuration For       */
  /* Device Flow Control: Egress resources consumption              */
  /* thresholds configuration for device flow-control.              */
  /* Treshold defined as five bits of mantissa (MSB) and four       */
  /* bits of exponent (LSB)                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38bd */

     /* TotalDvcFcBufs: Sets the thresholds of the number of         */
     /* total consumed data buffers above which device               */
     /* flow-control is asserted.                                    */
     /* range: 8:0, access type: RW, default value: 0x1f7            */
     SOC_PETRA_REG_FIELD total_dvc_fc_bufs;

     /* TotalDvcFcDscs: Sets the thresholds of the number of         */
     /* total packet descriptors above which device flow-control     */
     /* is asserted.                                                 */
     /* range: 24:16, access type: RW, default value: 0x1f8          */
     SOC_PETRA_REG_FIELD total_dvc_fc_dscs;

  } __ATTRIBUTE_PACKED__ total_rcs_consumption_threshs_conf_for_dev_flow_ctrl_reg_2;


  /* Mci0 Thresolds Configuration: Thresholds configurations        */
  /* for Mci0. Thresholds defined as five bits of mantissa          */
  /* (MSB) and four bits of exponent (LSB).                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38be */

     /* TotalUscWrds: Sets the threshold for the number of total     */
     /* consumed 32B unscheduled words, above which Mci0 is is       */
     /* asserted.                                                    */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD total_usc_wrds;

     /* TotalUscPkts: Sets the threshold for the number of total     */
     /* unscheduled packets, above which Mci0 is asserted.           */
     /* range: 24:16, access type: RW, default value: 0x1f8          */
     SOC_PETRA_REG_FIELD total_usc_pkts;

  } __ATTRIBUTE_PACKED__ mci_thresolds_configuration_reg_0[SOC_PETRA_NOF_MCI_LVLS_FOR_THRESH_CONF_REGS];


  /* Mci0 Thresolds Configuration: Thresholds configurations        */
  /* for Mci0. Thresholds defined as five bits of mantissa          */
  /* (MSB) and four bits of exponent (LSB).                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38bf */

     /* TotalUscBufs: Sets the threshold for the number of total     */
     /* consumed unscheduled data buffers above which Mci0 is        */
     /* asserted.                                                    */
     /* range: 8:0, access type: RW, default value: 0x1f7            */
     SOC_PETRA_REG_FIELD total_usc_bufs;

     /* TotalDscs: Sets the threshold for the number of total        */
     /* consumed packet descriptors above which Mci0 is              */
     /* asserted.                                                    */
     /* range: 24:16, access type: RW, default value: 0x1f8          */
     SOC_PETRA_REG_FIELD total_dscs;

  } __ATTRIBUTE_PACKED__ mci_thresolds_configuration_reg_1[SOC_PETRA_NOF_MCI_LVLS_FOR_THRESH_CONF_REGS];

  /* Channelized Ports Total Packets Flow Control Threshold:        */
  /* Thresholds configuration for toal number of packets in         */
  /* channelized ports. When the nubmer of packets for the          */
  /* channel cross the threshold a flow-control is asserted.        */
  /* Threshold defined as five bits of mantissa (MSB) and           */
  /* four bits of exponent (LSB)                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38c2 */

     /* TotalCpNPktsTh: Sets the threshold for the number of         */
     /* total packets to the channelized port index N, above         */
     /* which the channelized port flow control signal is            */
     /* asserted. The CP indexing are as follow: CP 0-3 - Nif A      */
     /* CP 4-7 - Nif B CP 8 - CPU interface CP 9 - Recycling         */
     /* interface                                                    */
     /* range: 16*N+8:16*N, N in 0..1, access type: RW,              */
     /* default value: 153'h1fa                                      */
     SOC_PETRA_REG_FIELD total_cp_npkts_th[SOC_PETRA_NOF_CH_PORTS_TOTAL_FC_THRESH_FLDS];

  } __ATTRIBUTE_PACKED__ channelized_ports_total_packets_fc_thresh_reg[SOC_PETRA_NOF_CH_PORTS_TOTAL_FC_THRESH_REGS];

  /* Channelized Ports Total Words Flow Control Threshold:          */
  /* Thresholds configuration for toal number of words in           */
  /* channelized ports. When the nubmer of words for the            */
  /* channel cross the threshold a flow-control is asserted.        */
  /* Threshold defined as five bits of mantissa (MSB) and           */
  /* four bits of exponent (LSB)                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38c7 */

     /* TotalCpNWrdsTh: Sets the threshold for the number of         */
     /* total words to the channelized port index N, above which     */
     /* the channelized port flow control signal is asserted.        */
     /* The CP indexing are as follow: CP 0-3 - Nif A CP 4-7 -       */
     /* Nif B CP 8 - CPU interface CP 9 - Recycling interface        */
     /* range: 16*N+8:16*N, N in 0..1, access type: RW,              */
     /* default value: 153'h1fa                                      */
     SOC_PETRA_REG_FIELD total_cp_nwrds_th[SOC_PETRA_NOF_CH_PORTS_TOTAL_FC_THRESH_FLDS];

  } __ATTRIBUTE_PACKED__ channelized_ports_total_words_fc_thresh_reg[SOC_PETRA_NOF_CH_PORTS_TOTAL_FC_THRESH_REGS];

  /* Scheduled Low Queues Ofp Flow Control Threshold Types:         */
  /* Flow-Control Thresholds of scheduled low queue queue           */
  /* size per queue type                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38cc */

     /* FclWrdsType0: Sets the thresholds of the number of total     */
     /* 32B words in scheduled queues of type 0 above which flow     */
     /* control to these ports is asserted.                          */
     /* range: 8:0, access type: RW, default value: 0x1fa            */
     SOC_PETRA_REG_FIELD fcl_wrds_type0;

     /* FclWrdsType1: Sets the thresholds of the number of total     */
     /* 32B words in scheduled queues of type 1 above which flow     */
     /* control to these ports is asserted.                          */
     /* range: 24:16, access type: RW, default value: 0x1fa          */
     SOC_PETRA_REG_FIELD fcl_wrds_type1;

  } __ATTRIBUTE_PACKED__ sched_qs_ofp_flow_ctrl_thresh_types_reg_0[SOC_PETRA_REGS_NOF_EGR_Q_PRIORITIES];


  /* Scheduled Per-Queue-Priority Queues Ofp Flow Control Threshold Types:         */
  /* Flow-Control Thresholds of scheduled low queue queue           */
  /* size per queue type                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38cd */

     /* FclWrdsType2: Sets the thresholds of the number of total     */
     /* 32B words in scheduled queues of type 2 above which flow     */
     /* control to these ports is asserted.                          */
     /* range: 8:0, access type: RW, default value: 0x1ea            */
     SOC_PETRA_REG_FIELD fcl_wrds_type2;

     /* FclWrdsType3: Sets the thresholds of the number of total     */
     /* 32B words in scheduled queues of type 3 above which flow     */
     /* control to these ports is asserted.                          */
     /* range: 24:16, access type: RW, default value: 0x1ea          */
     SOC_PETRA_REG_FIELD fcl_wrds_type3;

  } __ATTRIBUTE_PACKED__ sched_qs_ofp_flow_ctrl_thresh_types_reg_1[SOC_PETRA_REGS_NOF_EGR_Q_PRIORITIES];

  /* Disable Mci: Forces the MCI bits driven by the EGQ to 0,       */
  /* thus disabling egress to ingress flow control for              */
  /* Spatial Multicast traffic.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38d0 */

     /* Mci0Dis: If set, then disables MCI0 signal to the MAC        */
     /* (signal forced to '0')                                       */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mci0_dis;

     /* Mci1Dis: If set, then disables MCI1 signal to the            */
     /* MAC(signal forced to '0')                                    */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mci1_dis;

     /* ErpFcEn: If set, then disables MCI1 and use MCI1             */
     /* threshold configuration for the scheduler egress             */
     /* replication port flow control indication. Otherwisem         */
     /* egress replication port flow control indication is           */
     /* forced to ''0.                                               */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD erp_fc_en;

  } __ATTRIBUTE_PACKED__ disable_mci_reg;


  /* Ofp Threshold Type Select: Per OFP threshold type              */
  /* select. Each OFP is configured to one of four possible         */
  /* sets of thresholds that dictate which thresholds will be       */
  /* used by that port.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38d2 */

     /* QThSel: Each two bits configure the OFP port type.           */
     /* QThSel[2n+1:2n] selects the threshold set for port n.        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD qth_sel[SOC_PETRA_NOF_OFP_TH_TYPE_SEL_FLDS];

  } __ATTRIBUTE_PACKED__ ofp_threshold_type_select_reg[SOC_PETRA_NOF_OFP_TH_TYPE_SEL_REGS];


  /* Total Used Descriptor Counter: Total number of consumed        */
  /* descriptors for all packets.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38d7 */

     /* TotalDesc: Indicates the number of descriptors used for      */
     /* all packets.                                                 */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_desc;

  } __ATTRIBUTE_PACKED__ total_used_descriptor_counter_reg;


  /* Total Available Descriptor Counter: Total number of            */
  /* available descriptors for all packets.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38d8 */

     /* TotalAvailDesc: Indicates the number of available            */
     /* descriptors.                                                 */
     /* range: 13:0, access type: RO, default value: 0x2000          */
     SOC_PETRA_REG_FIELD total_avail_desc;

  } __ATTRIBUTE_PACKED__ total_available_descriptor_counter_reg;


  /* Total Scheduled Used Descriptor Counter: Total number of       */
  /* consumed descriptors for scheduled packets.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38d9 */

     /* TotalSchDesc: Indicates the number of descriptors used       */
     /* for scheduled packets                                        */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_sch_desc;

  } __ATTRIBUTE_PACKED__ total_scheduled_used_descriptor_counter_reg;


  /* Total Unscheduled Used Descriptor Counter: Total number        */
  /* of consumed descriptors for unscheduled packets.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38da */

     /* TotalUscDesc: Indicates the number of descriptors used       */
     /* for unscheduled packets                                      */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_usc_desc;

  } __ATTRIBUTE_PACKED__ total_unscheduled_used_descriptor_counter_reg;


  /* Total Used Unicast High Descriptor Counter: Total number       */
  /* of consumed descriptors for Unicast high packets.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38db */

     /* TotalDescUch: Indicates the number of descriptors used       */
     /* for Unicast high packets.                                    */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_desc_uch;

  } __ATTRIBUTE_PACKED__ total_used_unicast_high_descriptor_counter_reg;


  /* Total Used Unicast Low Descriptor Counter: Total number        */
  /* of consumed descriptors for Unicast low packets.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38dc */

     /* TotalDescUcl: Indicates the number of descriptors used       */
     /* for Unicast low packets.                                     */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_desc_ucl;

  } __ATTRIBUTE_PACKED__ total_used_unicast_low_descriptor_counter_reg;


  /* Total Used Multicast High Descriptor Counter: Total            */
  /* number of consumed descriptors for Multicast high              */
  /* packets.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38dd */

     /* TotalDescMch: Indicates the number of descriptors used       */
     /* for Multicast high packets.                                  */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_desc_mch;

  } __ATTRIBUTE_PACKED__ total_used_multicast_high_descriptor_counter_reg;


  /* Total Used Multicast Low Descriptor Counter: Total             */
  /* number of consumed descriptors for Multicast low               */
  /* packets.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38de */

     /* TotalDescMcl: Indicates the number of descriptors used       */
     /* for Multicast low packets.                                   */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_desc_mcl;

  } __ATTRIBUTE_PACKED__ total_used_multicast_low_descriptor_counter_reg;


  /* Total Scheduled Used Buffers: Total number of consumed         */
  /* buffers for scheduled packets.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38df */

     /* TotalSchBufs: Indicates the number of buffers used for       */
     /* scheduled packets                                            */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_sch_bufs;

  } __ATTRIBUTE_PACKED__ total_scheduled_used_buffers_reg;


  /* Total Unscheduled Used Buffers: Total number of consumed       */
  /* buffers for unscheduled packets.                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38e0 */

     /* TotalUscBufs: Indicates the number of buffers used for       */
     /* unscheduled packets                                          */
     /* range: 12:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_usc_bufs;

  } __ATTRIBUTE_PACKED__ total_unscheduled_used_buffers_reg;


  /* Total Scheduled Used Words: Total number of consumed           */
  /* words for scheduled packets.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38e1 */

     /* TotalSchWrds: Indicates the number of words used for         */
     /* scheduled packets                                            */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_sch_wrds;

  } __ATTRIBUTE_PACKED__ total_scheduled_used_words_reg;


  /* Total Unscheduled Used Words: Total number of consumed         */
  /* words for unscheduled packets.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38e2 */

     /* TotalUscWrds: Indicates the number of words used for         */
     /* unscheduled packets                                          */
     /* range: 14:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_usc_wrds;

  } __ATTRIBUTE_PACKED__ total_unscheduled_used_words_reg;


  /* Total Nifa Channel0 Used Packets: Total number of              */
  /* consumed packets for NIFA channel 0 packets.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38e3 */

     /* TotalNifaCh0CpPkts: Indicates the number of packets used     */
     /* for NIFA channel 0 packets                                   */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch0_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_nifa_channel0_used_packets_reg;


  /* Total Nifa Channel1 Used Packets: Total number of              */
  /* consumed packets for NIFA channel 1 packets.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38e4 */

     /* TotalNifaCh1CpPkts: Indicates the number of packets used     */
     /* for NIFA channel 1 packets                                   */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch1_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_nifa_channel1_used_packets_reg;


  /* Total Nifa Channel2 Used Packets: Total number of              */
  /* consumed packets for NIFA channel 2 packets.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38e5 */

     /* TotalNifaCh2CpPkts: Indicates the number of packets used     */
     /* for NIFA channel 2 packets                                   */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch2_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_nifa_channel2_used_packets_reg;


  /* Total Nifa Channel3 Used Packets: Total number of              */
  /* consumed packets for NIFA channel 3 packets.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38e6 */

     /* TotalNifaCh3CpPkts: Indicates the number of packets used     */
     /* for NIFA channel 3 packets                                   */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifa_ch3_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_nifa_channel3_used_packets_reg;


  /* Total Nifb Channel0 Used Packets: Total number of              */
  /* consumed packets for NIFB channel 0 packets.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38e7 */

     /* TotalNifbCh0CpPkts: Indicates the number of packets used     */
     /* for NIFB channel 0 packets                                   */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch0_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_nifb_channel0_used_packets_reg;


  /* Total Nifb Channel1 Used Packets: Total number of              */
  /* consumed packets for NIFB channel 1 packets.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38e8 */

     /* TotalNifbCh1CpPkts: Indicates the number of packets used     */
     /* for NIFB channel 1 packets                                   */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch1_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_nifb_channel1_used_packets_reg;


  /* Total Nifb Channel2 Used Packets: Total number of              */
  /* consumed packets for NIFB channel 2 packets.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38e9 */

     /* TotalNifbCh2CpPkts: Indicates the number of packets used     */
     /* for NIFB channel 2 packets                                   */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch2_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_nifb_channel2_used_packets_reg;


  /* Total Nifb Channel3 Used Packets: Total number of              */
  /* consumed packets for NIFB channel 3 packets.                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38ea */

     /* TotalNifbCh3CpPkts: Indicates the number of packets used     */
     /* for NIFB channel 3 packets                                   */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_nifb_ch3_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_nifb_channel3_used_packets_reg;


  /* Total CPUUsed Packets: Total number of consumed packets        */
  /* for CPU packets.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38eb */

     /* TotalCpuCpPkts: Indicates the number of packets used for     */
     /* CPU packets                                                  */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_cpu_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_cpuused_packets_reg;


  /* Total Recycling Used Packets: Total number of consumed         */
  /* packets for Recycling packets.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38ec */

     /* TotalRcyCpPkts: Indicates the number of packets used for     */
     /* Recycling packets                                            */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD total_rcy_cp_pkts;

  } __ATTRIBUTE_PACKED__ total_recycling_used_packets_reg;


  /* Low Bandwidth Ofp Bitmap: Low bandwidth indication per         */
  /* OFP                                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38f0 */

     /* LowBwOfp: If set, then the assosiated OFP gets low           */
     /* priority in FQP scheduling selection. Otherwise equal        */
     /* priority is implemented.                                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD low_bw_ofp;

  } __ATTRIBUTE_PACKED__ low_bandwidth_ofp_bitmap_reg_0;


  /* Low Bandwidth Ofp Bitmap: Low bandwidth indication per         */
  /* OFP                                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38f1 */

     /* LowBwOfp: If set, then the assosiated OFP gets low           */
     /* priority in FQP scheduling selection. Otherwise equal        */
     /* priority is implemented.                                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD low_bw_ofp;

  } __ATTRIBUTE_PACKED__ low_bandwidth_ofp_bitmap_reg_1;


  /* Low Bandwidth Ofp Bitmap: Low bandwidth indication per         */
  /* OFP                                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38f2 */

     /* LowBwOfp: If set, then the assosiated OFP gets low           */
     /* priority in FQP scheduling selection. Otherwise equal        */
     /* priority is implemented.                                     */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD low_bw_ofp;

  } __ATTRIBUTE_PACKED__ low_bandwidth_ofp_bitmap_reg_2;


  /* Unicast Egress Packet Header Compensation:                     */
  /* Header compensation for unicast packets. Type A selected       */
  /* when PCT. HeaderCompensationType is reset.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38f3 */

     /* HdrAdjustUcRaw: Credit discount for unicast packets       */
     /* and port type 'RAW'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD hdr_adjust_uc_raw;

     /* HdrAdjustUcCpu: Credit discount for unicast packets       */
     /* and port type 'CPU'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD hdr_adjust_uc_cpu;

     /* HdrAdjustUcEth: Credit discount for unicast packets       */
     /* and port type 'ETH'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hdr_adjust_uc_eth;

     /* HdrAdjustUcTm: Credit discount for unicast packets        */
     /* and port type 'TM'. Adjust credit for up to 32B with MSB     */
     /* as sign indication.                                          */
     /* range: 31:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hdr_adjust_uc_tm;

  } __ATTRIBUTE_PACKED__ unicast_egress_packet_header_compensation_reg[SOC_PETRA_REGS_PER_HDR_CR_DSCNT_TYPE_REGS];


  /* Multicast Egress Packet Header Compensation:                   */
  /* Header compensation for multicast packets. Type A              */
  /* selected when PCT. HeaderCompensationType is reset.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38f5 */

     /* HdrAdjustMcRaw: Credit discount for unicast packets       */
     /* and port type 'RAW'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD hdr_adjust_mc_raw;

     /* HdrAdjustMcCpu: Credit discount for unicast packets       */
     /* and port type 'CPU'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 15:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD hdr_adjust_mc_cpu;

     /* HdrAdjustMcEth: Credit discount for unicast packets       */
     /* and port type 'ETH'. Adjust credit for up to 32B with        */
     /* MSB as sign indication.                                      */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hdr_adjust_mc_eth;

     /* HdrAdjustMcTm: Credit discount for unicast packets        */
     /* and port type 'TM'. Adjust credit for up to 32B with MSB     */
     /* as sign indication.                                          */
     /* range: 31:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hdr_adjust_mc_tm;

  } __ATTRIBUTE_PACKED__ multicast_egress_packet_header_compensation_reg[SOC_PETRA_REGS_PER_HDR_CR_DSCNT_TYPE_REGS];


  /* Egress Interface No Fragmentation Mode Configuration:          */
  /* Interface fragmentation mode settings.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38f8 */

     /* NifaNoFrag: If set, then Nif A channelized port works in     */
     /* no- fragmentation mode. Each bit refers to ports 0-3         */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifa_no_frag;

     /* NifbNoFrag: If set, then Nif B channelized port works in     */
     /* no- fragmentation mode. Each bit refers to ports 0-3         */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifb_no_frag;

     /* RcyNoFrag: If set, then recycling interface works in         */
     /* no-fragmentation mode                                        */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcy_no_frag;

     /* CpuNoFrag: If set, then CPU interface works in               */
     /* no-fragmentation mode                                        */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_no_frag;

  } __ATTRIBUTE_PACKED__ egress_interface_no_fragmentation_mode_configuration_reg;


  /* Egress Aging Settings: Egress out queues aging mechanism       */
  /* settings.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38f9 */

     /* AgingEna: If set, enables the aging mechanism in the         */
     /* egress out queues                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD aging_ena;

     /* AgingFc: If set, then aging queues according to flow         */
     /* control to the OFP                                           */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD aging_fc;

     /* AgingRdQ: If set, then aging queues according to the OFP     */
     /* last access                                                  */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD aging_rd_q;

  } __ATTRIBUTE_PACKED__ egress_aging_settings_reg;


  /* Egress Aging Time Settings: Aging timer settings               */
  /* register.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x38fa */

     /* AgingTime: Sets the period for aging: '000' - 128 K          */
     /* clocks '001' - 512 K clocks '010' - 1M clocks '011' - 8      */
     /* M clock '100' - 32 M clocks '101' - 64 M clocks '110' -      */
     /* 128 M clocks '111' - 256 M clocks                            */
     /* range: 2:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD aging_time;

  } __ATTRIBUTE_PACKED__ egress_aging_time_settings_reg;


  /* Force Not Ready On All Egress OFP: Force egress out            */
  /* queues not ready.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3901 */

     /* ForceNotRdy: If set, then all egress OFP queues are set      */
     /* to be not ready to receive arrived segments                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_not_rdy;

  } __ATTRIBUTE_PACKED__ force_not_ready_on_all_egress_ofp_reg;


  /* Egress Port Priority Configuration: Configure the OFP          */
  /* egress priority. The priority is applicable only for OFP       */
  /* connected to Nif ports.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3902 */

     /* PortPriority: Each two bits set the OFP priority             */
     /* according to the following encoding: 2'b00 - High            */
     /* Priority 2'b01 - Mid Priority 2'b10,2'b11 - Low Priority     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_priority[SOC_PETRA_NOF_EGR_PORT_PRIO_CONF_FLDS];

  } __ATTRIBUTE_PACKED__ egress_port_prio_conf_reg[SOC_PETRA_NOF_EGR_PORT_PRIO_CONF_REGS];


  /* Mapping Configuration For Nif Channelized Ports: Bitmap         */
  /* of OFP mapping to Nif channelized ports.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3907 */

     /* MapNifaPort0Ch: If bit N is set, then the corresponding      */
     /* OFP is associated with the Nifa channelized port (Port 0     */
     /* in MAL A)                                                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD map_nif_port_ch;

  } __ATTRIBUTE_PACKED__ map_conf_chnif_port_reg[SOC_PETRA_NOF_MAP_CONF_CHNIF_REGS][SOC_PETRA_NOF_MAP_CONF_PER_CHNIF_REGS];


  /* Mapping Configuration For Nifa Non Channelized Ports:          */
  /* Mapping configuration for Nif A non-channelized ports.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x391f */

     /* MapNifaPortsNonCh: Defines the mapping of twelve             */
     /* non-channelized ports to Nif A. Each 8 bits represent an     */
     /* OFP index and valid bit. If the valid bit is set then        */
     /* the index represent the OFP that is mapped to the            */
     /* non-channelized port. For non-channelized port N [8N+7]      */
     /* represent the valid bit and [8N+6:8N] represent the OFP      */
     /* index                                                        */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ofp_index[SOC_PETRA_NOF_MAP_CONF_NONCH_NIF_FLDS];
     SOC_PETRA_REG_FIELD valid[SOC_PETRA_NOF_MAP_CONF_NONCH_NIF_FLDS];

  } __ATTRIBUTE_PACKED__ map_conf_nif_non_ch_ports_reg[SOC_PETRA_NOF_MAP_CONF_NONCH_NIF_REGS];


  /* Mapping Configuration For Recycling Ports: Bitmap of OFP       */
  /* mapping to recycling interface                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3925 */

     /* MapRcyPort: If bit N is set, then the corresponding OFP      */
     /* is associated with the recycling interface                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD map_rcy_port;

  } __ATTRIBUTE_PACKED__ map_conf_rcy_ports_reg[SOC_PETRA_NOF_MAP_CONF_PER_CHNIF_REGS];


  /* Mapping Configuration For Cpu Ports: Bitmap of OFP             */
  /* mapping to CPU and OLP interface.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3928 */

     /* MapCpuPort: If set, then maps the OFP to the ECI             */
     /* interface. Bit 0 - maps OFP 0 Bits 6:1 - maps OFP 78:73      */
     /* Bit 7 - maps OFP 79 OFP 0 and OFP 73 - OFP 78 are            */
     /* applicable for CPU interface, while OFP 79 is applicable     */
     /* for the OLP interface                                        */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD map_cpu_port;

  } __ATTRIBUTE_PACKED__ map_conf_cpu_ports_reg;

  /* Disable Egress OFP: Disable settings for egrees OFPs (debug).  */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x3929 - 0x392b */

    /* range: 79:0, access type: RW, default value: 0x0             */
    SOC_PETRA_REG_FIELD disable_egress_ofp;

  } __ATTRIBUTE_PACKED__ disable_egress_ofp_reg[SOC_PETRA_NOF_FAP_PORT_REGS];


  /* Fragmentation Queues Ready Words Threshold: Per OFP            */
  /* fragmentation queues threshold. If threshold crossed           */
  /* from below, then corresponding OFP fragmentation queue         */
  /* is not ready to receive arriving descriptors.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x392c */

     /* FqRdyTh: Indicates the words thresholds in the               */
     /* fragmentation egress out queues. When crossed from           */
     /* below, the appropriate queue becomes not ready to            */
     /* receive new descriptors.                                     */
     /* range: 9:0, access type: RW, default value: 0x40             */
     SOC_PETRA_REG_FIELD fq_rdy_th;

  } __ATTRIBUTE_PACKED__ fragmentation_queues_ready_words_threshold_reg;

 /* Oc768 Mask Reg: OC768 mode FAP ports masking                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3932 */

     /* Oc768Mask:                                                   */
     /* range: 3:0, access type: RW, default value: 0xf              */
     SOC_PETRA_REG_FIELD oc768_mask;

  } __ATTRIBUTE_PACKED__ oc768_mask_reg;


  /* Nifa Sgmii: If set the corresponding NIFA ports 0,1,2,3        */
  /* is Sgmii, otherwise is SPAUI                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /*  0x392f-0x3931  */

     /* NifaSgmii:                                                   */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fqempty;

  } __ATTRIBUTE_PACKED__ fragmentation_queues_empty_indication[3] ;


  /* Nifa Sgmii: If set the corresponding NIFA ports 0,1,2,3        */
  /* is Sgmii, otherwise is SPAUI                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3933 */

     /* NifaSgmii:                                                   */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifa_sgmii;

  } __ATTRIBUTE_PACKED__ nifa_sgmii_reg;


  /* Nifb Sgmii: If set the corresponding NIFB ports 0,1,2,3        */
  /* is Sgmii, otherwise is SPAUI                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3934 */

     /* NifbSgmii:                                                   */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifb_sgmii;

  } __ATTRIBUTE_PACKED__ nifb_sgmii_reg;


  /* Nifa Sgmii Ports Delay Configuration: Configures the           */
  /* minimum gap in clocks between consecutive NIFA SGMII           */
  /* port to be selected by FQP scheduler.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3935 */

     /* NifaSgmiiPortsDelay: Sets the gap between consecutive        */
     /* NIFA SGMII port to be selected by FQP scheduler. The         */
     /* port delay is five bits wide and arranged in octets.         */
     /* range: 31:0, access type: RW, default value: 128'h1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f */
     SOC_PETRA_REG_FIELD nifa_sgmii_ports_delay;

  } __ATTRIBUTE_PACKED__ nifa_sgmii_ports_delay_configuration_reg_0;


  /* Nifa Sgmii Ports Delay Configuration: Configures the           */
  /* minimum gap in clocks between consecutive NIFA SGMII           */
  /* port to be selected by FQP scheduler.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3936 */

     /* NifaSgmiiPortsDelay: Sets the gap between consecutive        */
     /* NIFA SGMII port to be selected by FQP scheduler. The         */
     /* port delay is five bits wide and arranged in octets.         */
     /* range: 31:0, access type: RW, default value: 128'h1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f */
     SOC_PETRA_REG_FIELD nifa_sgmii_ports_delay;

  } __ATTRIBUTE_PACKED__ nifa_sgmii_ports_delay_configuration_reg_1;


  /* Nifa Sgmii Ports Delay Configuration: Configures the           */
  /* minimum gap in clocks between consecutive NIFA SGMII           */
  /* port to be selected by FQP scheduler.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3937 */

     /* NifaSgmiiPortsDelay: Sets the gap between consecutive        */
     /* NIFA SGMII port to be selected by FQP scheduler. The         */
     /* port delay is five bits wide and arranged in octets.         */
     /* range: 31:0, access type: RW, default value: 128'h1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f */
     SOC_PETRA_REG_FIELD nifa_sgmii_ports_delay;

  } __ATTRIBUTE_PACKED__ nifa_sgmii_ports_delay_configuration_reg_2;


  /* Nifa Sgmii Ports Delay Configuration: Configures the           */
  /* minimum gap in clocks between consecutive NIFA SGMII           */
  /* port to be selected by FQP scheduler.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3938 */

     /* NifaSgmiiPortsDelay: Sets the gap between consecutive        */
     /* NIFA SGMII port to be selected by FQP scheduler. The         */
     /* port delay is five bits wide and arranged in octets.         */
     /* range: 31:0, access type: RW, default value: 128'h1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f */
     SOC_PETRA_REG_FIELD nifa_sgmii_ports_delay;

  } __ATTRIBUTE_PACKED__ nifa_sgmii_ports_delay_configuration_reg_3;


  /* Nifb Sgmii Ports Delay Configuration: Configures the           */
  /* minimum gap in clocks between consecutive NIFB SGMII           */
  /* port to be selected by FQP scheduler.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3939 */

     /* NifbSgmiiPortsDelay: Sets the gap between consecutive        */
     /* NIFB SGMII port to be selected by FQP scheduler. The         */
     /* port delay is five bits wide and arranged in octets.         */
     /* range: 31:0, access type: RW, default value: 128'h1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f */
     SOC_PETRA_REG_FIELD nifb_sgmii_ports_delay;

  } __ATTRIBUTE_PACKED__ nifb_sgmii_ports_delay_configuration_reg_0;


  /* Nifb Sgmii Ports Delay Configuration: Configures the           */
  /* minimum gap in clocks between consecutive NIFB SGMII           */
  /* port to be selected by FQP scheduler.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x393a */

     /* NifbSgmiiPortsDelay: Sets the gap between consecutive        */
     /* NIFB SGMII port to be selected by FQP scheduler. The         */
     /* port delay is five bits wide and arranged in octets.         */
     /* range: 31:0, access type: RW, default value: 128'h1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f */
     SOC_PETRA_REG_FIELD nifb_sgmii_ports_delay;

  } __ATTRIBUTE_PACKED__ nifb_sgmii_ports_delay_configuration_reg_1;


  /* Nifb Sgmii Ports Delay Configuration: Configures the           */
  /* minimum gap in clocks between consecutive NIFB SGMII           */
  /* port to be selected by FQP scheduler.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x393b */

     /* NifbSgmiiPortsDelay: Sets the gap between consecutive        */
     /* NIFB SGMII port to be selected by FQP scheduler. The         */
     /* port delay is five bits wide and arranged in octets.         */
     /* range: 31:0, access type: RW, default value: 128'h1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f */
     SOC_PETRA_REG_FIELD nifb_sgmii_ports_delay;

  } __ATTRIBUTE_PACKED__ nifb_sgmii_ports_delay_configuration_reg_2;


  /* Nifb Sgmii Ports Delay Configuration: Configures the           */
  /* minimum gap in clocks between consecutive NIFB SGMII           */
  /* port to be selected by FQP scheduler.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x393c */

     /* NifbSgmiiPortsDelay: Sets the gap between consecutive        */
     /* NIFB SGMII port to be selected by FQP scheduler. The         */
     /* port delay is five bits wide and arranged in octets.         */
     /* range: 31:0, access type: RW, default value: 128'h1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f */
     SOC_PETRA_REG_FIELD nifb_sgmii_ports_delay;

  } __ATTRIBUTE_PACKED__ nifb_sgmii_ports_delay_configuration_reg_3;


  /* Nifa Spaui Ports Delay Configuration: Configures the           */
  /* minimum gap in clocks between consecutive NIFA SPAUI           */
  /* port to be selected by FQP scheduler.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x393d */

     /* NifaSpauiPortsDelay: Sets the gap between consecutive        */
     /* NIFA SPAUI port to be selected by FQP scheduler. The         */
     /* port delay is five bits wide and arranged in octets.         */
     /* range: 31:0, access type: RW, default value: 32'h07070707    */
     SOC_PETRA_REG_FIELD nifa_spaui_ports_delay;

  } __ATTRIBUTE_PACKED__ nifa_spaui_ports_delay_configuration_reg;


  /* Nifb Spaui Ports Delay Configuration: Configures the           */
  /* minimum gap in clocks between consecutive NIFB SPAUI           */
  /* port to be selected by FQP scheduler.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x393e */

     /* NifbSpauiPortsDelay: Sets the gap between consecutive        */
     /* NIFB SPAUI port to be selected by FQP scheduler. The         */
     /* port delay is five bits wide and arranged in octets.         */
     /* range: 31:0, access type: RW, default value: 32'h07070707    */
     SOC_PETRA_REG_FIELD nifb_spaui_ports_delay;

  } __ATTRIBUTE_PACKED__ nifb_spaui_ports_delay_configuration_reg;


  /* Nif Sp Over Cpu Rcy: configurs whether NIF gets strict         */
  /* priority over RCY and CPU interfaces.                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x393f */

     /* NifSpOvrCpu: configurs whether NIF gets strict priority      */
     /* over CPU interface.                                          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nif_sp_ovr_cpu;

     /* NifSpOvrRcy: configurs whether NIF gets strict priority      */
     /* over RCY interface.                                          */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nif_sp_ovr_rcy;

  } __ATTRIBUTE_PACKED__ nif_sp_over_cpu_rcy_reg;


  /* Packet Aged Counter: Packet Aged counter                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3940 */

     /* PktAgedCnt: If set, then disables the deny of packets.       */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD pkt_aged_cnt;

     /* PktAgedCntOvf: If set, then indicates that the counter       */
     /* overflowed.                                                  */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD pkt_aged_cnt_ovf;

  } __ATTRIBUTE_PACKED__ packet_aged_counter_reg;


  /* Egress Replication Bitmap Group Value Configuration:           */
  /* Configure the values of Out-LIF-Group that is mapped to        */
  /* replication with bitmap.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3945 */

     /* EgressRepBitmapGroupValueBot: The lowest value of            */
     /* Out-LIF-Group that is mapped to replication with bitmap      */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD egress_rep_bitmap_group_value_bot;

     /* EgressRepBitmapGroupValueTop: The upper value of             */
     /* Out-LIF-Group that is mapped to replication with bitmap      */
     /* range: 29:16, access type: RW, default value: 0x3fff         */
     SOC_PETRA_REG_FIELD egress_rep_bitmap_group_value_top;

  } __ATTRIBUTE_PACKED__ egress_replication_bitmap_group_value_configuration_reg;


  /* Rlag2 System Port Configuration: Configures the values         */
  /* of RLAG2.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3946 */

     /* Rlag2SysPortIdBot: The bottom range of the RLAG2             */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rlag2_sys_port_id_bot;

     /* Rlag2SysPortIdTop: The top range of the RLAG2                */
     /* range: 27:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rlag2_sys_port_id_top;

  } __ATTRIBUTE_PACKED__ rlag2_system_port_configuration_reg;


  /* Rlag4 Sys Port Id: Configures the values of RLAG4.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3947 */

     /* Rlag4SysPortIdBot: The bottom range of the RLAG4             */
     /* range: 11:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rlag4_sys_port_id_bot;

     /* Rlag4SysPortIdTop: The top range of the RLAG4                */
     /* range: 27:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rlag4_sys_port_id_top;

  } __ATTRIBUTE_PACKED__ rlag4_sys_port_id_reg;


  /* Unicast To Unicast Class Lookup Table: Lookup table used       */
  /* to set the egress unicast priority upon system unicast         */
  /* packets fields \{TC(3-bits),DP(2-bits)\}.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3948 */

     /* Uc2ucClassTable: Each bit set high for high priority or      */
     /* low for low priority according to traffic-class and          */
     /* drop-precedence transformation                               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD uc2uc_class_table;

  } __ATTRIBUTE_PACKED__ unicast_to_unicast_class_lookup_table_reg;


  /* Multicast To Unicast Class Lookup Table: Lookup table          */
  /* used to set the egress unicast class priority upon             */
  /* system multicast packets fields                                */
  /* \{TC(3-bits),DP(2-bits)\}.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3949 */

     /* Mc2ucClassTable: Each bit set high for high priority or      */
     /* low for low priority according to traffic-class and          */
     /* drop-precedence transformation                               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mc2uc_class_table;

  } __ATTRIBUTE_PACKED__ multicast_to_unicast_class_lookup_table_reg;


  /* Multicast To Multicast Class Lookup Table: Lookup table        */
  /* used to set the egress multicast class priority upon           */
  /* system multicast packets fields                                */
  /* \{TC(3-bits),DP(2-bits)\}.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x394a */

     /* Mc2mcClassTable: Each bit set high for high priority or      */
     /* low for low priority according to traffic-class and          */
     /* drop-precedence transformation                               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mc2mc_class_table;

  } __ATTRIBUTE_PACKED__ multicast_to_multicast_class_lookup_table_reg;


  /* Multicast To Multicast Drop Precedence Lookup Table:           */
  /* Lookup table used to set the egress unicast drop               */
  /* precedence priority upon system multicast packets fields       */
  /* \{TC(3-bits),DP(2-bits)\}.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x394b */

     /* Mc2mcDpTable: Sets the DP Lsb to [31:0] and the DP Msb       */
     /* to [63:32]. Two bits indiates the DP of the e lookup         */
     /* table output.                                                */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mc2mc_dp_table;

  } __ATTRIBUTE_PACKED__ multicast_to_multicast_drop_precedence_lookup_table_reg[SOC_PETRA_REGS_MC_2_MCDP_TABLE_REGS];

  /* Mc Priority Lookup Table: Lookup table used to set the         */
  /* egress multicast priority upon system multicast packets        */
  /* fields \{TC(3-bits),DP(2-bits)\}.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x394d */

     /* McPriority: Each bit in the represents the lookup table      */
     /* output. If set, then incoming MC packet descriptor           */
     /* enters the high priority queue (MC1)                         */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD mc_priority;

  } __ATTRIBUTE_PACKED__ mc_priority_lookup_table_reg;


  /* Multicast Link List Max Length: Multicast Link List max        */
  /* length in entries, in order to prevent loops in the link       */
  /* list table.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x394e */

     /* LinkListMaxLength: If the MC link list length is higher      */
     /* than this value, the EHP process only the first              */
     /* LinkListMaxLength entries                                    */
     /* range: 14:0, access type: RW, default value: 0x14            */
     SOC_PETRA_REG_FIELD link_list_max_length;

     /* LinkListMaxLengthVld: enables and disbales this function     */
     /* range: 16:16, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD link_list_max_length_vld;

  } __ATTRIBUTE_PACKED__ multicast_link_list_max_length_reg;


  /* Marvel Configuration Register: Marvel configuration            */
  /* register                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x394f */

     /* MarvelMhMode: 0 - DSA Tag header type 1- Marvel MH           */
     /* header type                                                  */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD marvel_mh_mode;

     /* MarvelMidVidx: 0 - Multicast id is taken from vid bits       */
     /* 1- Multicast id is taken from the vidx bits                  */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD marvel_mid_vidx;

     /* MarvelDsaToAnalyzerIngressOfp: Map ingress analyzer          */
     /* packets to link (OFP)                                        */
     /* range: 9:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD marvel_dsa_to_analyzer_ingress_ofp;

     /* MarvelDsaToAnalyzerEgressOfp: Map Egress analyzer            */
     /* packets to link (OFP)                                        */
     /* range: 13:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD marvel_dsa_to_analyzer_egress_ofp;

     /* MarvelOtherLowPrTable: Map Traffic class (3 bits) to 1       */
     /* bit low priority queue                                       */
     /* range: 23:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD marvel_other_low_pr_table;

     /* MarvelToCpuLowPr: Map TO_CPU packets to low priority         */
     /* queue                                                        */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD marvel_to_cpu_low_pr;

     /* MarvelToAnalyzerLowPr: Map TO_ANALYZER packets to low        */
     /* priority queue                                               */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD marvel_to_analyzer_low_pr;

  } __ATTRIBUTE_PACKED__ marvel_configuration_reg;


  /* Marvel Dx Forward Low Pr Table: Map Qosprofile to 1 bit        */
  /* low priority queue                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3950 */

     /* MarvelDxForwardLowPrTable: Map Qosprofile to 1 bit low       */
     /* priority queue                                               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_dx_forward_low_pr_table;

  } __ATTRIBUTE_PACKED__ marvel_dx_forward_low_pr_table_reg_0;


  /* Marvel Dx Forward Low Pr Table: Map Qosprofile to 1 bit        */
  /* low priority queue                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3951 */

     /* MarvelDxForwardLowPrTable: Map Qosprofile to 1 bit low       */
     /* priority queue                                               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_dx_forward_low_pr_table;

  } __ATTRIBUTE_PACKED__ marvel_dx_forward_low_pr_table_reg_1;


  /* Marvel Dx Forward Low Pr Table: Map Qosprofile to 1 bit        */
  /* low priority queue                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3952 */

     /* MarvelDxForwardLowPrTable: Map Qosprofile to 1 bit low       */
     /* priority queue                                               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_dx_forward_low_pr_table;

  } __ATTRIBUTE_PACKED__ marvel_dx_forward_low_pr_table_reg_2;


  /* Marvel Dx Forward Low Pr Table: Map Qosprofile to 1 bit        */
  /* low priority queue                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3953 */

     /* MarvelDxForwardLowPrTable: Map Qosprofile to 1 bit low       */
     /* priority queue                                               */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_dx_forward_low_pr_table;

  } __ATTRIBUTE_PACKED__ marvel_dx_forward_low_pr_table_reg_3;


  /* Marvel Port Map Table Other: Map Other packets to Link         */
  /* (OFP), table index is \{device_0,target_port[5:0]\}            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3954 */

     /* MarvelPortMapTableOther: Map Other packets to Link           */
     /* (OFP), table index is \{device_0,target_port[5:0]\}          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_other;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_other_reg_0;


  /* Marvel Port Map Table Other: Map Other packets to Link         */
  /* (OFP), table index is \{device_0,target_port[5:0]\}            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3955 */

     /* MarvelPortMapTableOther: Map Other packets to Link           */
     /* (OFP), table index is \{device_0,target_port[5:0]\}          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_other;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_other_reg_1;


  /* Marvel Port Map Table Other: Map Other packets to Link         */
  /* (OFP), table index is \{device_0,target_port[5:0]\}            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3956 */

     /* MarvelPortMapTableOther: Map Other packets to Link           */
     /* (OFP), table index is \{device_0,target_port[5:0]\}          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_other;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_other_reg_2;


  /* Marvel Port Map Table Other: Map Other packets to Link         */
  /* (OFP), table index is \{device_0,target_port[5:0]\}            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3957 */

     /* MarvelPortMapTableOther: Map Other packets to Link           */
     /* (OFP), table index is \{device_0,target_port[5:0]\}          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_other;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_other_reg_3;


  /* Marvel Port Map Table Other: Map Other packets to Link         */
  /* (OFP), table index is \{device_0,target_port[5:0]\}            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3958 */

     /* MarvelPortMapTableOther: Map Other packets to Link           */
     /* (OFP), table index is \{device_0,target_port[5:0]\}          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_other;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_other_reg_4;


  /* Marvel Port Map Table Other: Map Other packets to Link         */
  /* (OFP), table index is \{device_0,target_port[5:0]\}            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3959 */

     /* MarvelPortMapTableOther: Map Other packets to Link           */
     /* (OFP), table index is \{device_0,target_port[5:0]\}          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_other;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_other_reg_5;


  /* Marvel Port Map Table Other: Map Other packets to Link         */
  /* (OFP), table index is \{device_0,target_port[5:0]\}            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x395a */

     /* MarvelPortMapTableOther: Map Other packets to Link           */
     /* (OFP), table index is \{device_0,target_port[5:0]\}          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_other;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_other_reg_6;


  /* Marvel Port Map Table Other: Map Other packets to Link         */
  /* (OFP), table index is \{device_0,target_port[5:0]\}            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x395b */

     /* MarvelPortMapTableOther: Map Other packets to Link           */
     /* (OFP), table index is \{device_0,target_port[5:0]\}          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_other;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_other_reg_7;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x395c */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_0;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x395d */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_1;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x395e */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_2;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x395f */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_3;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3960 */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_4;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3961 */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_5;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3962 */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_6;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3963 */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_7;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3964 */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_8;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3965 */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_9;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3966 */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_10;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3967 */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_11;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3968 */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_12;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3969 */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_13;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x396a */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_14;


  /* Marvel Port Map Table Cpu: Map TO_CPU packets to Link          */
  /* (OFP), table index is CPUCODE                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x396b */

     /* MarvelPortMapTableCpu: Map TO_CPU packets to Link (OFP),     */
     /* table index is CPUCODE                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD marvel_port_map_table_cpu;

  } __ATTRIBUTE_PACKED__ marvel_port_map_table_cpu_reg_15;


  /* Egress Shaper Enable Settings: Enable the operation of         */
  /* all shapers.                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x396c */

     /* SchEna: If set, then the shapers for the egress              */
     /* interfaces are enabled.                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD sch_enable;

     /* SprSetSel: If set, then the shapers set B is selected.       */
     /* Otherwise set shapers set A is selected.                     */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD spr_set_sel;

  } __ATTRIBUTE_PACKED__ egress_shaper_enable_settings_reg;


  /* Egress Shapers Credit Memory Init Status: Egress shapers       */
  /* credit memory initialization status indication                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x396d */

     /* SchInit: When set indicates on shaper credit memory          */
     /* initialization procudeure. The initialization triggered      */
     /* by enabling shaper snable register 'SchEna'. Reset by        */
     /* the device when initialization completed. When reset         */
     /* indicates that the shapers are not enabled yet, or           */
     /* initlalization completed after shapers enabled.              */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD sch_init;

  } __ATTRIBUTE_PACKED__ egress_shapers_credit_memory_init_status_reg;


  /* Egress Shaper Calendars Arbitration Cycle Length: Set          */
  /* the cycle length of the CALCAL memory.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x396e */

     /* CalCalLenA/B: This parameter specifies the length of         */
     /* calendars calendar. The calendar length is the value of      */
     /* this parameter plus 1                                        */
     /* range: 7:0, 15:8, access type: RW, default value: 0x0        */
     SOC_PETRA_REG_FIELD cal_cal_len[SOC_PETRA_NOF_INSTANCES_EGQ_CAL_SETS];
  } __ATTRIBUTE_PACKED__ egress_shaper_calendars_arbitration_cycle_length_reg;


  /* Egress Shaper Configuration AFor Nifa Channelized Port0:       */
  /* NifA channel #0 interface Shaper.                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x396f */

     /* NifCh0SprRateA: Number of bandwidth credits, in units       */
     /* of 1/256th byte, to allocate for NifA CH0 every core         */
     /* clock cycle. If core-clock runs at 250MHz, this              */
     /* corresponds to the number of 1/256th bytes to allocate       */
     /* every 4ns. For a bandwidth of 10Gbps, this register          */
     /* needs to be configured to 1280 or 0x500.                     */
     /* range: 15:0, access type: RW, default value: 0x500           */
     SOC_PETRA_REG_FIELD spr_rate;

     /* NifaCh0SprMaxBurstA: The maximum value that credit for       */
     /* NifA CH0 may have.                                           */
     /* range: 28:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD spr_max_burst;

  } __ATTRIBUTE_PACKED__ egress_shpr_conf_nif_reg[SOC_PETRA_EGR_SHPR_CONF_NIF_NOF_REGS];

  /* Egress Shaper Configuration For Nifa And Nifb Non             */
  /* Channelized Ports: NifA and NifB Non-channelized ports         */
  /* interface Shaper.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3977 */

     /* NifabNchSprRateA: Number of bandwidth credits, in units      */
     /* of 1/256th byte, to allocate for NCH every core clock        */
     /* cycle. If core-clock runs at 250MHz, this corresponds to     */
     /* the number of 1/256th bytes to allocate every 4ns. For a     */
     /* bandwidth of 10Gbps, this register needs to be               */
     /* configured to 1280 or 0x500.                                 */
     /* range: 15:0, access type: RW, default value: 0x500           */
     SOC_PETRA_REG_FIELD nifab_nch_spr_rate;

     /* NifabNchSprMaxBurstA: The maximum value that credit for      */
     /* NCH may have.                                                */
     /* range: 28:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD nifab_nch_spr_max_burst;

  } __ATTRIBUTE_PACKED__ egress_shpr_conf_for_nifa_and_nifb_non_channelized_ports_reg;


  /* Egress Shaper Configuration For Recycle Interface Ports:       */
  /* Recycling interface Shaper.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3978 */

     /* RcySprRateA: Number of bandwidth credits, in units of        */
     /* 1/256th byte, to allocate for RCY every core clock           */
     /* cycle. If core-clock runs at 250MHz, this corresponds to     */
     /* the number of 1/256th bytes to allocate every 4ns. For a     */
     /* bandwidth of 10Gbps, this register needs to be               */
     /* configured to 1280 or 0x500.                                 */
     /* range: 15:0, access type: RW, default value: 0x500           */
     SOC_PETRA_REG_FIELD rcy_spr_rate;

     /* RcySprMaxBurstA: The maximum value that credit for RCY       */
     /* may have.                                                    */
     /* range: 28:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD rcy_spr_max_burst;

  } __ATTRIBUTE_PACKED__ egress_shpr_conf_for_recycle_interface_ports_reg;


  /* Egress Shaper Configuration For Eci Ports: ECI                 */
  /* interface shaper configuration. Used for port shaping of       */
  /* CPU ports and OLP port.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3979 */

     /* CpuSprRateA: Number of bandwidth credits, in units of        */
     /* 1/256th byte, to allocate for CPU every core clock           */
     /* cycle. If core-clock runs at 250MHz, this corresponds to     */
     /* the number of 1/256th bytes to allocate every 4ns. For a     */
     /* bandwidth of 10Gbps, this register needs to be               */
     /* configured to 1280 or 0x500.                                 */
     /* range: 15:0, access type: RW, default value: 0x500           */
     SOC_PETRA_REG_FIELD cpu_spr_rate;

     /* CpuSprMaxBurstA: The maximum value that credit for CPU       */
     /* may have.                                                    */
     /* range: 28:16, access type: RW, default value: 0x80           */
     SOC_PETRA_REG_FIELD cpu_spr_max_burst;

  } __ATTRIBUTE_PACKED__ egress_shpr_conf_for_eci_ports_reg;


  /* Egress Shaper Configuration For Nif Calendars Length:          */
  /* Lengths of Shaper Calendars of the channelized Nif             */
  /* ports.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x397a */

     /* NifChSprCalLenA: This parameter specifies the length         */
     /* of shaper calendar for CH0. The calendar length is the       */
     /* value of this parameter plus 1.                              */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nif_ch_spr_cal_len[SOC_PETRA_EGR_SHPR_PER_NIF_GRP_NOF_FLDS];
  } __ATTRIBUTE_PACKED__ egress_shpr_conf_for_nif_cal_len_reg[SOC_PETRA_EGR_SHPR_PER_NIF_GRP_NOF_REGS];


  /* Egress Shaper Configuration For Other Calendars Length:        */
  /* Lengths of Shaper Calendars of the non-channelized NifA        */
  /* and NifB ports, Recycling and CPU interfaces.                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x397c */

     /* NifabNchSprCalLenA: This parameter specifies the length      */
     /* of shaper calendar for NCH. The calendar length is the       */
     /* value of this parameter plus 1.                              */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifab_nch_spr_cal_len;

     /* RcySprCalLenA: This parameter specifies the length of        */
     /* shaper calendar for RCY. The calendar length is the          */
     /* value of this parameter plus 1.                              */
     /* range: 14:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcy_spr_cal_len;

     /* CpuSprCalLenA: This parameter specifies the length of        */
     /* shaper calendar for CPU. The calendar length is the          */
     /* value of this parameter plus 1.                              */
     /* range: 22:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpu_spr_cal_len;

  } __ATTRIBUTE_PACKED__ egress_shpr_conf_for_other_calendars_length_reg;

  /* Check Bw To Ofp: The OFP to check BW to, otherwise check       */
  /* total BW.                                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x398b */

     /* OfpToCheckBw: The OFP to check BW to.                        */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ofp_to_check_bw;

     /* CheckBwToOfp: If set check BW to OfpToCheckBw, otherwise     */
     /* check total BW.                                              */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD check_bw_to_ofp;

  } __ATTRIBUTE_PACKED__ check_bw_to_ofp_reg;


  /* Gtimer Config: GTIMER configuration.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x398c */

     /* TimerConfig: Period of time in clocks.                       */
     /* range: 30:0, access type: RW, default value: 31'hee6b27f     */
     SOC_PETRA_REG_FIELD timer_config;

  } __ATTRIBUTE_PACKED__ gtimer_config_reg;


  /* Gtimer Config Cont: GTIMER configuration.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x398d */

     /* ClearGtimer: Clear timer.                                    */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD clear_gtimer;

     /* ActivateGtimer: Activate timer.                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD activate_gtimer;

     /* GtimerActive: If set GTIMER is active.                       */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_active;

  } __ATTRIBUTE_PACKED__ gtimer_config_cont_reg;


  /* Chicken Bit Register: Chicken bit register                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x398e */

     /* SegCntChickenBit:                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD seg_cnt_chicken_bit;

     /* Oc768ChickenBit:                                             */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD oc768_chicken_bit;

     /* Oc768ChickenBit1:                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD oc768_chicken_bit1;

  } __ATTRIBUTE_PACKED__ chicken_bit_reg;


} __ATTRIBUTE_PACKED__ SOC_PETRA_EGQ_REGS;
/* Block definition: EPNI */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: EPNI interrupt register                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a00 */

     /* TdmFabricStop: Indication for TDM cells from fabric          */
     /* stopped because of heavy traffic from local or Egress        */
     /* queues are over thresholds.                                  */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_fabric_stop;

     /* MirrOvfInt: If set, then mirroring FIFO in the egress        */
     /* queue has overflowed.                                        */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD mirr_ovf_int;

     /* IntOtmOutLifMode: If set, then the FTM_EXT_MODE register     */
     /* doesn't match the PCT-Out-Lif-Ext requirments.               */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD int_otm_out_lif_mode;

     /* TdmIntVec: If set then one of the bits in TdmIntReg has      */
     /* been set                                                     */
     /* range: 27:27, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_int_vec;

     /* EccErrVec: If set then one of the bits in EccIntReg has      */
     /* been set                                                     */
     /* range: 28:28, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD ecc_err_vec;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Tdm Int Reg:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a01 */

     /* TdmNifaCntOvfInt: Counter of outgoing TDM cells to Nif A     */
     /* is overflowed. Cleared when TdmNifaCnt is read. While        */
     /* overflow bit set counter continue on counting                */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD tdm_nifa_cnt_ovf_int;

     /* TdmNifbCntOvfInt: Counter of outgoing TDM cells to Nif B     */
     /* is overflowed. Cleared when TdmNifaCnt is read. While        */
     /* overflow bit set counter continue on counting                */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD tdm_nifb_cnt_ovf_int;

     /* TdmFragErrInt: If set, then indicates that TDM cell          */
     /* arrived to EGQ with non-TDM fragmentt number. Cleared        */
     /* when TdmFragErrCnt is read.                                  */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD tdm_frag_err_int;

     /* TdmOneFifoMcLossInt: If set, then indicates that             */
     /* multicast TDM cell has not passed due to bitmap bit 0        */
     /* not set. Cleared when TdmOneFifoMcCnt is read.               */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD tdm_one_fifo_mc_loss_int;

     /* TdmaLossInt: TDM cells toward destination port 0 are         */
     /* lost due to queue overflow. Cleared when TdmaLossCnt is      */
     /* read. TDM cells will be discarded.                           */
     /* range: 4:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD tdma_loss_int;

     /* TdmbLossInt: TDM cells toward destination port 1 are         */
     /* lost due to queue overflow. Cleared when TdmbLossCnt is      */
     /* read. TDM cells will be discarded.                           */
     /* range: 5:5, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD tdmb_loss_int;

     /* TdmcLossInt: TDM cells toward destination port 2 are         */
     /* lost due to queue overflow. Cleared when TdmcLossCnt is      */
     /* read. TDM cells will be discarded.                           */
     /* range: 6:6, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD tdmc_loss_int;

     /* TdmdLossInt: TDM cells toward destination port 3 are         */
     /* lost due to queue overflow. Cleared when TdmdLossCnt is      */
     /* read. TDM cells will be discarded.                           */
     /* range: 7:7, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD tdmd_loss_int;

  } __ATTRIBUTE_PACKED__ tdm_int_reg;


  /* Ecc Int Reg:                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a02 */

     /* PrdmEccErr: PNI Rcy FIFO descriptor memory                   */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD prdm_ecc_err;

     /* PrdmEccFix: PNI Rcy FIFO descriptor memory                   */
     /* range: 1:1, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD prdm_ecc_fix;

     /* MdmEccErr: PNI Mirroring FIFO descriptor memory              */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD mdm_ecc_err;

     /* MdmEccFix: PNI Mirroring FIFO descriptor memory              */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD mdm_ecc_fix;

     /* NadmEccErr: PNI Nif A FIFO Descriptor memory                 */
     /* range: 4:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD nadm_ecc_err;

     /* NadmEccFix: PNI Nif A FIFO Descriptor memory                 */
     /* range: 5:5, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD nadm_ecc_fix;

     /* NbdmEccErr: PNI Nif B FIFO Descriptor memory                 */
     /* range: 6:6, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD nbdm_ecc_err;

     /* NbdmEccFix: PNI Nif B FIFO Descriptor memory                 */
     /* range: 7:7, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD nbdm_ecc_fix;

  } __ATTRIBUTE_PACKED__ ecc_int_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a10 */

     /* MaskTdmFabricStop:                                           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_tdm_fabric_stop;

     /* MaskMirrOvf:                                                 */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_mirr_ovf;

     /* MaskIntOtmOutLifMode:                                        */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mask_int_otm_out_lif_mode;

     /* MaskTdmIntVec:                                               */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_tdm_int_vec;

     /* MaskEccErrVec:                                               */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask_ecc_err_vec;

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Tdm Int Reg Mask:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a11 */

     /* TdmIntRegMask:                                               */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdm_int_reg_mask;

  } __ATTRIBUTE_PACKED__ tdm_int_reg_mask_reg;


  /* Ecc Int Reg Mask:                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a12 */

     /* EccIntRegMask:                                               */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD prdm_ecc_err_mask;

     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD prdm_ecc_fixr_mask;

     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mdm_ecc_err_mask;

     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mdm_ecc_fix_mask;

     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nadm_ecc_err_mask;

     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nadm_ecc_fix_mask;

     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nbdm_ecc_err_mask;

     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nbdm_ecc_fix_mask;

  } __ATTRIBUTE_PACKED__ ecc_int_reg_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a20 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a21 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_1;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a22 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_2;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a23 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_3;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a24 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_4;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a25 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_5;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a26 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_6;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* will be written to the addressed object when an indirect       */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a27 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_7;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a30 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a31 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_1;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a32 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_2;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a33 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_3;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a34 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_4;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a35 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_5;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a36 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_6;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation                                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a37 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_7;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a40 */

     /* IndirectCommandTrigger: Triggers indirect access as          */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set, to 0, one       */
     /* operation is performed. The cpu can read this field to       */
     /* find the number of writes left.                              */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set, to 0, then the command has no timeout.       */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then last command failed on timeout.        */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3a41 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0 -         */
     /* Write operation 1 - Read operation                           */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* Pcmi Config: Pcmi count period                                 */
  SOC_PETRA_REGS_PCMI_CONFIG_REG_FORMAT pcmi_config_reg;


  /* Pcmi Results: Pcmi count Results                               */
  SOC_PETRA_REGS_PCMI_RESULTS_REG_FORMAT pcmi_results_reg;


  /* Sequence Number Masking Disable: Oc-768 Sequence number        */
  /* indexing mask MSB settings.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b05 */

     /* SeqnumMskDis: If set, then disables the OC-768               */
     /* MSB[15:14] masking                                           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD seqnum_msk_dis;

  } __ATTRIBUTE_PACKED__ sequence_number_masking_disable_reg;


  /* Sequence Number Masking Msb Configuration: Oc-768              */
  /* Sequence number MSB indexing settings.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b06 */

     /* SeqnumMskMsb: Set the OC-768 MSB[15:14]. Applicable when     */
     /* masking bit is enabled                                       */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD seqnum_msk_msb;

  } __ATTRIBUTE_PACKED__ sequence_number_masking_msb_configuration_reg;


  /* ECN:                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b08 */

     /* ecn_en:                                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ecn_en;

     /* ecn:                                                         */
     /* range: 2:1, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD ecn;

  } __ATTRIBUTE_PACKED__ ecn_reg;


  /* Recycling Interface Priority Settings: Configuration of        */
  /* the priority schema between the recycling queue and the        */
  /* mirroring queue on the egress recycling interface.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b09 */

     /* RcySpOrRr: If set, then recycling queue gets strict          */
     /* priority. Otherwise, round-robin scheduling between          */
     /* recycling queue and mirroting queue                          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcy_sp_or_rr;

  } __ATTRIBUTE_PACKED__ recycling_interface_priority_settings_reg;


  /* Ecc Corecction Disable: Ecc correction disable setting         */
  /* bits for debug purpose                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b0a */

     /* PrdmDisEcc: If set, then disables the ECC decoder on         */
     /* PRDM memory output                                           */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD prdm_dis_ecc;

     /* MdmDisEcc: If set, then disables the ECC decoder on MDM      */
     /* memory output                                                */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mdm_dis_ecc;

     /* NadmDisEcc: If set, then disables the ECC decoder on         */
     /* NADM memory output                                           */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nadm_dis_ecc;

     /* NbdmDisEcc: If set, then disables the ECC decoder on         */
     /* NBDM memory output                                           */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nbdm_dis_ecc;

  } __ATTRIBUTE_PACKED__ ecc_corecction_disable_reg;


  /* Nifa Ports Flow Control Threshold Configuration:               */
  /* Nifb Ports Flow Control Threshold Configuration:               */
  /* Configures the threshold values for generating early           */
  /* flow control indication for the egress packet                  */
  /* de-queuing.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b0c, 0x3b0e */

     /* NifaPerPortTh, NifaPerPortTh: Sets the threshold values for each Nif A      */
     /* ports in the Egress Nif interface. The Nif port              */
     /* threshold is four bits wide and should be set to values      */
     /* in range of 1 to 4. Other values are not allowed.            */
     /* range: 31:0, access type: RW, default value: 64'h2222222222222222 */
     /* Each MAL is 4 bits */
     SOC_PETRA_REG_FIELD nif_per_port_th[SOC_PETRA_NIF_PORTS_FC_THRESH_NOF_FLDS];

  } __ATTRIBUTE_PACKED__ nif_ports_fc_thresh_config_reg[SOC_PETRA_NIF_PORTS_FC_THRESH_NOF_REGS];

  /* Nifa Ports Flow Control Threshold Configuration:               */
  /* Nifb Ports Flow Control Threshold Configuration:               */
  /* Configures the threshold values for generating early           */
  /* flow control indication for the egress packet                  */
  /* de-queuing.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b0d, 0x3b0f */

     /* NifaPerPortTh, NifaPerPortTh: Sets the threshold values for each Nif A      */
     /* ports in the Egress Nif interface. The Nif port              */
     /* threshold is four bits wide and should be set to values      */
     /* in range of 1 to 4. Other values are not allowed.            */
     /* range: 31:0, access type: RW, default value: 64'h2222222222222222 */
     /* Each MAL is 4 bits */
     SOC_PETRA_REG_FIELD nif_per_port_const;

  } __ATTRIBUTE_PACKED__ nif_ports_fc_thresh_config_const_reg[SOC_PETRA_NIF_PORTS_FC_THRESH_NOF_REGS];

  /* Egress Interface No Fragmentation Mode Configuration:          */
  /* Interface fragmentation mode settings.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b10 */

     /* NifaNoFrag: If set, then Nif A channelized port works in     */
     /* no- fragmentation mode. Each bit refers to ports 0-3         */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifa_no_frag;

     /* NifbNoFrag: If set, then Nif B channelized port works in     */
     /* no- fragmentation mode. Each bit refers to ports 0-3         */
     /* range: 7:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nifb_no_frag;

     /* RcyNoFrag: If set, then recycling interface works in         */
     /* no-fragmentation mode                                        */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcy_no_frag;

     /* CpuNoFrag: If set, then CPU interface works in               */
     /* no-fragmentation mode                                        */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cpu_no_frag;

  } __ATTRIBUTE_PACKED__ egress_interface_no_fragmentation_mode_configuration_reg;


  /* Map Ofp To Mirr Channel: Mapping OFP to outbound               */
  /* mirroring channel                                              */
  /* Mirror channel of port n is bits 6n+5:6n                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b12 */

     /* MapOfpToMirrCha:                                             */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD map_ofp_to_mirr_cha;

  } __ATTRIBUTE_PACKED__ map_ofp_to_mirr_channel_reg[SOC_PETRA_MAP_OFP_TO_MIRR_CHANNEL_NOF_REGS];


  /* Tdm Configurations: Configures the TDM port mapping.           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b20 */

     /* OneFifoOprMode: If set, then one-FIFO mode, otherwise        */
     /* four-FIFO mode.                                              */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD one_fifo_opr_mode;

     /* DisFragErrCells: If set, then TDM cells with error in        */
     /* fragment number are discarded.                               */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dis_frag_err_cells;

  } __ATTRIBUTE_PACKED__ tdm_configurations_reg;


  /* Tdm Destination Output Port Disable Settings: TDM ports        */
  /* FIFO disable traffic settings. Applicable only in              */
  /* four-FIFO mode.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b21 */

     /* TdmaOutDis: If set, then disables TDM cells from             */
     /* destination port 0 FIFO. Otherwise traffic enabled.          */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdma_out_dis;

     /* TdmbOutDis: If set, then disables TDM cells from             */
     /* destination port 1 FIFO. Otherwise traffic enabled.          */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdmb_out_dis;

     /* TdmcOutDis: If set, then disables TDM cells from             */
     /* destination port 2 FIFO. Otherwise traffic enabled.          */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdmc_out_dis;

     /* TdmdOutDis: If set, then disables TDM cells from             */
     /* destination port 3 FIFO. Otherwise traffic enabled.          */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD tdmd_out_dis;

  } __ATTRIBUTE_PACKED__ tdm_destination_output_port_disable_settings_reg;


  /* Tdm Nifa Cell Counter: Counts the outgoing TDM cells           */
  /* toward NIF A                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b22 */

     /* TdmNifaCnt: Counter for NIF A TDM cells This register is     */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_nifa_cnt;

     /* TdmNifaCntOvf: If set, then indicates that the counter       */
     /* has overflowed. This register is clear on read.              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_nifa_cnt_ovf;

  } __ATTRIBUTE_PACKED__ tdm_nifa_cell_counter_reg;


  /* Tdm Nifb Cell Counter: Counts the outgoing TDM cells           */
  /* toward NIF A                                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b23 */

     /* TdmNifbCnt: Counter for NIF B TDM cells This register is     */
     /* clear on read.                                               */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_nifb_cnt;

     /* TdmNifbCntOvf: If set, then indicates that the counter       */
     /* has overflowed. This register is clear on read.              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_nifb_cnt_ovf;

  } __ATTRIBUTE_PACKED__ tdm_nifb_cell_counter_reg;


  /* Last Local Tdm Cell Header: Sample the last TDM header         */
  /* arrived from local interface, freeze when header error         */
  /* detected. Clear on header read.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b24 */

     /* LastLocalTdmHdr: Last TDM header from Local This             */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD last_local_tdm_hdr;

  } __ATTRIBUTE_PACKED__ last_local_tdm_cell_header_reg;


  /* Last Fabric Tdm Cell Header: Sample the last TDM header        */
  /* arrived from fabric interface, freeze when header error        */
  /* detected. Clear on header read.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b25 */

     /* LastFabricTdmHdr: Last TDM header from Local This            */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD last_fabric_tdm_hdr;

  } __ATTRIBUTE_PACKED__ last_fabric_tdm_cell_header_reg;


  /* Tdm One Fifo Mc Loss Cells Counter: Counts the lost MC         */
  /* TDM cells in one FIFO mode due to bitmap bit 0 isn't set       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b26 */

     /* TdmOneFifoMcLossCnt: Counts the lost multicast TDM cells     */
     /* when bitmap bit 0 isn't set This register is clear on        */
     /* read.                                                        */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_one_fifo_mc_loss_cnt;

     /* TdmOneFifoMcLossCntOvf: If set, then indicates that the      */
     /* counter has overflowed. This register is clear on read.      */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_one_fifo_mc_loss_cnt_ovf;

  } __ATTRIBUTE_PACKED__ tdm_one_fifo_mc_loss_cells_counter_reg;


  /* Tdm Fragment Error Cells Counter: Counts TDM cells with        */
  /* error in fragment number.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b27 */

     /* TdmFragErrCnt: Counts TDM cells with error in fragment       */
     /* number. This register is clear on read.                      */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdm_frag_err_cnt;

     /* TdmFragErrCntOvf: If set, then indicates that the            */
     /* counter has overflowed. This register is clear on read.      */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdm_frag_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ tdm_fragment_error_cells_counter_reg;


  /* Tdma Loss Cells Counter: Counts the lost TDM cells for         */
  /* destination port 0 (a) due to queue overflow                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b28 */

     /* TdmaLossCnt: Counts the lost TDM cells for destination       */
     /* port 0 (a) due to queue overflow This register is clear      */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdma_loss_cnt;

     /* TdmaLossCntOvf: If set, then indicates that the counter      */
     /* has overflowed. This register is clear on read.              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdma_loss_cnt_ovf;

  } __ATTRIBUTE_PACKED__ tdma_loss_cells_counter_reg;


  /* Tdmb Loss Cells Counter: Counts the lost TDM cells for         */
  /* destination port 1 (b) due to queue overflow                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b29 */

     /* TdmbLossCnt: Counts the lost TDM cells for destination       */
     /* port 1 (b) due to queue overflow This register is clear      */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdmb_loss_cnt;

     /* TdmbLossCntOvf: If set, then indicates that the counter      */
     /* has overflowed. This register is clear on read.              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdmb_loss_cnt_ovf;

  } __ATTRIBUTE_PACKED__ tdmb_loss_cells_counter_reg;


  /* Tdmc Loss Cells Counter: Counts the lost TDM cells for         */
  /* destination port 2 (c) due to queue overflow                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b2a */

     /* TdmcLossCnt: Counts the lost TDM cells for destination       */
     /* port 2 (c) due to queue overflow This register is clear      */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdmc_loss_cnt;

     /* TdmcLossCntOvf: If set, then indicates that the counter      */
     /* has overflowed. This register is clear on read.              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdmc_loss_cnt_ovf;

  } __ATTRIBUTE_PACKED__ tdmc_loss_cells_counter_reg;


  /* Tdmd Loss Cells Counter: Counts the lost TDM cells for         */
  /* destination port 3 (d) due to queue overflow                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b2b */

     /* TdmdLossCnt: Counts the lost TDM cells for destination       */
     /* port 3 (d) due to queue overflow This register is clear      */
     /* on read.                                                     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD tdmd_loss_cnt;

     /* TdmdLossCntOvf: If set, then indicates that the counter      */
     /* has overflowed. This register is clear on read.              */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD tdmd_loss_cnt_ovf;

  } __ATTRIBUTE_PACKED__ tdmd_loss_cells_counter_reg;


  /* Check Bw To Packet Descriptor: The packet descriptor to        */
  /* check BW to. If all descriptors are masked                     */
  /* (MaskCheckBwToPacketDescriptor) check total BW.                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b2c */

     /* OfpToCheckBw: The OFP to check BW to.                        */
     /* range: 7:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ofp_to_check_bw;

     /* FifoToCheckBw: The FIFO to check BW to.                      */
     /* range: 9:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fifo_to_check_bw;

     /* NifPortToCheckBw: The NIF port to check BW to.               */
     /* range: 15:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nif_port_to_check_bw;

     /* NifChannelToCheckBw: The NIF channel to check BW to.         */
     /* range: 21:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nif_channel_to_check_bw;

     /* OutboundMirrorToCheckBw: Check BW to outbound mirror.        */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD outbound_mirror_to_check_bw;

  } __ATTRIBUTE_PACKED__ check_bw_to_packet_descriptor_reg;


  /* Mask Check Bw To Packet Descriptor: Each bit in                */
  /* CheckBwToPacketDescriptor can be masked.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b2d */

     /* MaskOfpToCheckBw: Mask the OFP to check BW to.               */
     /* range: 7:0, access type: RW, default value: 0xff             */
     SOC_PETRA_REG_FIELD mask_ofp_to_check_bw;

     /* MaskFifoToCheckBw: Mask the FIFO to check BW to.             */
     /* range: 9:8, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD mask_fifo_to_check_bw;

     /* MaskNifPortToCheckBw: Mask the NIF port to check BW to.      */
     /* range: 15:12, access type: RW, default value: 0xf            */
     SOC_PETRA_REG_FIELD mask_nif_port_to_check_bw;

     /* MaskNifChannelToCheckBw: Mask the NIF channel to check       */
     /* BW to.                                                       */
     /* range: 21:16, access type: RW, default value: 0x3f           */
     SOC_PETRA_REG_FIELD mask_nif_channel_to_check_bw;

     /* MaskOutboundMirrorToCheckBw: Don't check BW to outbound      */
     /* mirror.                                                      */
     /* range: 24:24, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD mask_outbound_mirror_to_check_bw;

  } __ATTRIBUTE_PACKED__ mask_check_bw_to_packet_descriptor_reg;


  /* Gtimer Config: GTIMER configuration.                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b2e */

     /* TimerConfig: Period of time in clocks.                       */
     /* range: 30:0, access type: RW, default value: 31'hee6b27f     */
     SOC_PETRA_REG_FIELD timer_config;

  } __ATTRIBUTE_PACKED__ gtimer_config_reg;


  /* Gtimer Config Cont: GTIMER configuration.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x3b2f */

     /* ClearGtimer: Clear timer.                                    */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD clear_gtimer;

     /* ActivateGtimer: Activate timer.                              */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD activate_gtimer;

     /* GtimerActive: If set GTIMER is active.                       */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD gtimer_active;

  } __ATTRIBUTE_PACKED__ gtimer_config_cont_reg;


  /* Epe Packet Counter:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x43a00 */

     /* EpePacketCounter: EPE2PNI packet counter. If bit 32 is       */
     /* set, counter overflowed. If                                  */
     /* MaskCheckBwToPacketDescriptor is cleared counts              */
     /* accordingly, if all packet descriptors are masked counts     */
     /* all packets.                                                 */
     /* range: 32:0, access type: R, default value: 0x0              */
     SOC_PETRA_REG_FIELD epe_packet_counter;

  } __ATTRIBUTE_PACKED__ epe_packet_counter_reg;


  /* Epe Bytes Counter:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x53a00 */

     /* EpeBytesCounter: EPE2PNI bytes counter. If bit 46 is         */
     /* set, counter overflowed. If                                  */
     /* MaskCheckBwToPacketDescriptor is cleared counts              */
     /* accordingly, if all packet descriptors are masked counts     */
     /* all packets.                                                 */
     /* range: 31:0, access type: R, default value: 0x0              */
     SOC_PETRA_REG_FIELD epe_bytes_counter;

  } __ATTRIBUTE_PACKED__ epe_bytes_counter_reg_0;


  /* Epe Bytes Counter:                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x53a01 */

     /* EpeBytesCounter: EPE2PNI bytes counter. If bit 46 is         */
     /* set, counter overflowed. If                                  */
     /* MaskCheckBwToPacketDescriptor is cleared counts              */
     /* accordingly, if all packet descriptors are masked counts     */
     /* all packets.                                                 */
     /* range: 14:0, access type: R, default value: 0x0              */
     SOC_PETRA_REG_FIELD epe_bytes_counter;

  } __ATTRIBUTE_PACKED__ epe_bytes_counter_reg_1;

} __ATTRIBUTE_PACKED__ SOC_PETRA_EPNI_REGS;
/* Block definition: CFC */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in the CFC.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4600 */

     /* ObrxaLockErr: OOB-A/OOB-B is not locked. Did not find a      */
     /* correct framing pattern.                                     */
     /* range: 0:0, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrx_lock_err[SOC_PETRA_BLK_NOF_INSTANCES_OOB];

     /* ObrxaOutOfFrm: OOB-A/OOB-B: Out-Of-Frame error counter is    */
     /* above OutOfFrmTh.                                            */
     /* range: 2:2, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD obrx_out_of_frm[SOC_PETRA_BLK_NOF_INSTANCES_OOB];

     /* ObrxaDip2Alarm: OOB-A/OOB-B : DIP2 error counter is above    */
     /* Dip2AlarmTh                                                  */
     /* range: 4:4, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD obrx_dip2_alarm[SOC_PETRA_BLK_NOF_INSTANCES_OOB];

     /* ObrxaFrmErr: OOB-A/OOB-B : Frame error occurred. If          */
     /* asserted, then FrmErrCnt0 holds the number of errors.        */
     /* range: 6:6, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD obrx_frm_err[SOC_PETRA_BLK_NOF_INSTANCES_OOB];

     /* ObrxaDip2Err: OOB-A/OOB-B : DIP2 error detected. If          */
     /* asserted, then Dip2ErrCnt0 holds the number of errors.       */
     /* range: 8:8, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD obrx_dip2_err[SOC_PETRA_BLK_NOF_INSTANCES_OOB];

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Register: Each bit in this register             */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4610 */

     /* ObrxaLockErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrx_lock_err_mask[SOC_PETRA_BLK_NOF_INSTANCES_OOB];

     /* ObrxaOutOfFrmMask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrx_out_of_frm_mask[SOC_PETRA_BLK_NOF_INSTANCES_OOB];

     /* ObrxaDip2AlarmMask: Writing 0 masks the corresponding        */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrx_dip2_alarm_mask[SOC_PETRA_BLK_NOF_INSTANCES_OOB];

     /* ObrxaFrmErrMask: Writing 0 masks the corresponding           */
     /* interrupt source.                                            */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrx_frm_err_mask[SOC_PETRA_BLK_NOF_INSTANCES_OOB];

     /* ObrxaDip2ErrMask: Writing 0 masks the corresponding          */
     /* interrupt source.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD obrx_dip2_err_mask[SOC_PETRA_BLK_NOF_INSTANCES_OOB];

  } __ATTRIBUTE_PACKED__ interrupt_mask_reg;


  /* Indirect Command Wr Data: Indirect write data. Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4620 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Rd Data: Data for the indirect command.       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4630 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 13:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4640 */

     /* IndirectCommandTrigger: Trigger indirect access as           */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

     /* IndirectCommandTriggerOnData: If set, then writing to        */
     /* the LSBs of IndirectCommandWrData automatically sets         */
     /* IndirectCommandTrigger.                                      */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger_on_data;

     /* IndirectCommandCount: Each write command is executed         */
     /* IndirectCommandCount number of times. The address is         */
     /* advanced by one every write command. If set to 0, one        */
     /* operation is performed. The CPU can read this field to       */
     /* find out the number of writes left.                          */
     /* range: 15:2, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_count;

     /* IndirectCommandTimeout: Configures a timeout period for      */
     /* the indirect access command. Resolution is in 256            */
     /* clocks. If set to 0, then the command has no timeout.        */
     /* range: 30:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_timeout;

     /* IndirectCommandStatus: Status of last indirect access        */
     /* command. If set, then the last command failed on             */
     /* timeout.                                                     */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_status;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4641 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed                            */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0: -        */
     /* Write operation 1: - Read operation                          */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* Cfc Enablers: CFC Enable bits                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4700 */

     /* CfcEn: CFC disabled will presents no flow control,           */
     /* (present X-On) , indications to all destinations. Note:      */
     /* In this state, the CFC continues to receive and process      */
     /* the incoming flow-control indications, but does not          */
     /* present them to the destinations.                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cfc_en;

     /* NifClsHrSchEn: If set, enables the NIF 64 class-based        */
     /* FCs to be presented to the Scheduler's HRs 128->191.         */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD nif_cls_hr_sch_en;

     /* RclOfpHpEn: If set enables assertion of the                  */
     /* High-Priority FC of the recycle OFP-Hrs by the assertion     */
     /* of global resources low-priority FC. FC to the Scheduler     */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcl_ofp_hp_en;

     /* RclOfpLpEn: If set, enables assertion of the                 */
     /* Low-Priority FC of the recycle OFP-Hrs FC by the             */
     /* assertion of global resources Low- Priority FC. FC to the     */
     /* Scheduler.                                                   */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcl_ofp_lp_en;

     /* RclVsqHrEn: If set, enables FC on the aggregate HRs by       */
     /* the 32 Recycle classes VSQs (68->99). FC to the               */
     /* Scheduler.                                                   */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rcl_vsq_hr_en;

     /* OobSchEn: If set, enables FC on the 128 hierarchical HRs     */
     /* via the 128 OOB FC Scheduler-based indications. FC to the     */
     /* Scheduler.                                                   */
     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD oob_sch_en;

     /* OobEgqOfpEn: If set, enables FC of the EGQ's OFP (out        */
     /* going FAP ports) via the 80 OOB FCs( OFP-based). FC to        */
     /* the Scheduler.                                               */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD oob_egq_ofp_en;

     /* FrcLlvlEn: If set, all link-level NIF's FCs will be          */
     /* asserted when High-priority global resource FC is            */
     /* asserted. Otherwise, the NIF's link-level FC are not         */
     /* effected by the global resources FC.                         */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_llvl_en;

     /* EgqDeviceEn: If set, enables the Device FC from the EGQ      */
     /* to the Scheduler.                                            */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_device_en;

     /* EgqErpEn: If set, enables the Egress replication port FC     */
     /* from the EGQ to the Scheduler.                               */
     /* range: 9:9, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_erp_en;

     /* EgqChPortEn: If set, enables the chanelized ports FC         */
     /* from the EGQ to the Scheduler.                               */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_ch_port_en;

     /* CpuPortEn: If set, enables the chanelized CPU port FC        */
     /* from the EGQ to the Scheduler.                               */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpu_port_en;

     /* RclPortEn: If set, enables the chanelized Recycling port     */
     /* FC from the EGQ to the Scheduler.                            */
     /* range: 12:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcl_port_en;

     /* EgqOfpLpEn: If set, enables the low-priority OFP FC from     */
     /* the EGQ to the Scheduler.                                    */
     /* range: 13:13, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_ofp_lp_en;

     /* EgqOfpHpEn: If set, enables the high-priority OFP FC         */
     /* from the EGQ to the Scheduler.                               */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_ofp_hp_en;

     /* NifClbSel: Selects the source for NIF's class-based FC.      */
     /* If set, selects VSQs 100->163 (statistics-tag VSQs),         */
     /* this is the default setting. Otherwise, selects VSQs         */
     /* 36->99 (Q category 2/3 & connection-class).                  */
     /* range: 15:15, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nif_clb_sel;

     /* OobIntrfbSel: If set, then OOB interface B operates as       */
     /* status transmit. Otherwise, the interface operates as        */
     /* status receive.                                              */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_intrfb_sel;

     /* OobNifaFastLlEn: If set, enables fast link-level FC          */
     /* received from OOB and forwarded to NIFa (stops NIF Tx).      */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_nifa_fast_ll_en;

     /* OobNifbFastLlEn: If set, enables fast link-level FC          */
     /* received from OOB and forwarded to NIFb (stops NIF Tx).      */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_nifb_fast_ll_en;

     /* HglMode: If set, the CFC works in HGL mode (hipher           */
     /* G-Link). Note: this bit is internal configuration, for       */
     /* HGL/PDMC mode. The CFC ignores the global PdmcMode           */
     /* configuration.                                               */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hgl_mode;

     /* HpGlbClsOvrdEn: If set, the when receiving indication of     */
     /* global resources crossing high-priority threshold, the       */
     /* CFC will assert flow-control indication on all               */
     /* class-based indication towards the NIF. Note: this bit       */
     /* should be enabled when inbound link-level flow control       */
     /* through the NIF is not enabled.                              */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD hp_glb_cls_ovrd_en;

  } __ATTRIBUTE_PACKED__ cfc_enablers_reg;


  /* Low Priority Control0: Low-priority global to                  */
  /* Class-based mapping.                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4701 */

     /* LpGlbClsMap0: The 32 LSB part of a 64-bit bitmap that        */
     /* defines the class-based FCs presented to NIF that should     */
     /* be asserted when the Low-Priority global resource FC is      */
     /* asserted by the IQM.                                         */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD lp_glb_cls_map;

  } __ATTRIBUTE_PACKED__ low_priority_control_reg[SOC_PETRA_NOF_LOW_PRIORITY_CONTROL_REGS];

  /* Recycle Out Going Fap Port Hr Map0-2:                            */
  /* Map0 is at the highest address                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4704 */

     /* RclOfpHrMap0: Same as previous register. This register       */
     /* includes bits: 15:0 of the bitmap.                           */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcl_ofp_hr_map;

  } __ATTRIBUTE_PACKED__ recycle_out_going_fap_port_hr_map_reg[SOC_PETRA_RCY2FAP_PORT_HR_MAP_REGS];


  /* High Priority Hr Map: Recycle VSQ to HP-HR mapping.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4706 */

     /* RclHpHrMap: A 32-bit bitmap that defines if the VSQ's FC     */
     /* should assert the HP-HR flow-control towards the             */
     /* SCH. Maps the Rclofp table entries to HP.                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcl_hp_hr_map;

  } __ATTRIBUTE_PACKED__ high_priority_hr_map_reg;


  /* Low Priority Hr Map: Recycle VSQ to LP-HR mapping.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4707 */

     /* RclLpHrMap: A 32-bit bitmap that defines if the VSQ's FC     */
     /* should assert the LP-HR flow-control towards the             */
     /* SCH. Maps the Rclofp table entries to LP.                     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcl_lp_hr_map;

  } __ATTRIBUTE_PACKED__ low_priority_hr_map_reg;


  /* Rcycle Out Going Fap Port Map: Recycle VSQ to EGQ OFP          */
  /* mapping.                                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4708 */

     /* RclEgqOfpMap: A 32-bit bitmap that defines if the VSQ's      */
     /* FC should assert the flow-control towards the EGQ's OFP.     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcl_egq_ofp_map;

  } __ATTRIBUTE_PACKED__ rcycle_out_going_fap_port_map_reg;


  /* Class Based Low Priority Hr Map0: Class-based to LP-HR         */
  /* mapping (NIFa).                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4709 */

     /* ClbLpOfpMap0: A 32-bit bitmap that defines if NIF's          */
     /* class-based FC should assert the LP-HR flow-control          */
     /* towards the SCH. Maps the NifClsbOfp table entries to LP.     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD clb_lp_ofp_map0;

  } __ATTRIBUTE_PACKED__ class_based_low_priority_hr_map0_reg;


  /* Class Based Low Priority Hr Map1: Class-based to LP-HR         */
  /* mapping (NIFb).                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x470a */

     /* ClbLpOfpMap1: A 32-bit bitmap that defines if NIF's          */
     /* class-based FC should assert the LP-HR flow-control          */
     /* towards the SCH. Maps the NifClsbOfp table entries to LP.     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD clb_lp_ofp_map1;

  } __ATTRIBUTE_PACKED__ class_based_low_priority_hr_map1_reg;


  /* Class Based HIgh Priority Hr Map0: Class-based to HP-HR        */
  /* mapping (NIFa).                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x470b */

     /* ClbHpOfpMap0: A 32-bit bitmap that defines if NIF's          */
     /* class-based FC should assert the HP-HR flow-control          */
     /* towards the SCH. Maps the NifClsbOfp table entries to HP.     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD clb_hp_ofp_map0;

  } __ATTRIBUTE_PACKED__ class_based_high_priority_hr_map0_reg;


  /* Class Based HIgh Priority Hr Map1: Clb to HP-HR mapping        */
  /* (NIFb).                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x470c */

     /* ClbHpOfpMap1: A 32-bit bitmap that defines if NIF's          */
     /* class-based FC should assert the HP-HR flow-control          */
     /* towards the SCH. Maps the NifClsbOfp table entries to HP.     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD clb_hp_ofp_map1;

  } __ATTRIBUTE_PACKED__ class_based_high_priority_hr_map1_reg;


  /* Class Based Out Going Fap Port Map0: Class-based to Egq        */
  /* Ofp mapping (NIFa).                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x470d */

     /* ClbEgqOfpMap0: A 32-bit bitmap that defines if NIF's         */
     /* class-based FC should assert the EGQ's OFP flow-control      */
     /* (signals from NIFa).                                         */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD clb_egq_ofp_map;

  } __ATTRIBUTE_PACKED__ class_based_out_going_fap_port_map_reg[SOC_PETRA_NOF_CLS2FAP_PORT_MAP_REGS];

  /* Sch Hr Mask: Scheduler HR schedulers FC mask                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x470f, 0x4710, 0x4711, 0x4712 */

     /* SchHrMsk0: Masks Scheduler HR FC indications 0->31 (from     */
     /* OOB/HGL) 1 - enables FC indication 0 - mask out the FC       */
     /* indication                                                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD sch_hr_msk;

  } __ATTRIBUTE_PACKED__ sch_hr_mask_reg[SOC_PETRA_SCH_HR_MASK_NOF_REGS];

  /* Out Of Band Tx Configuration0: Out-of-band transmit            */
  /* interface settings.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4713 */

     /* TxCalLen: Status transmit (OOB) calendar length. Defines     */
     /* the number of OOB-tx channels in a single calendar.          */
     /* (Maximum calendar length : 512 channels)                     */
     /* range: 9:0, access type: RW, default value: 0x200            */
     SOC_PETRA_REG_FIELD tx_cal_len;

     /* TxCalM: Status transmit (OOB) calendar-M. The number of      */
     /* calendar repetitions within a status frame. Total status     */
     /* frame length: TxCalLen X TxCalM + 2                          */
     /* range: 15:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD tx_cal_m;

     /* OobTxEn: Out-Of-Band flow control transmit interface         */
     /* enable.                                                      */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_tx_en;

  } __ATTRIBUTE_PACKED__ out_of_band_tx_configuration0_reg;


  /* Out Of Band Tx Configuration1: Out-of-band transmit            */
  /* interface settings.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4714 */

     /* OutStatPhaseSel: Defines the Transmit Stat clock edge        */
     /* where rstat_out[1:0] ( fc-status) should change its          */
     /* value. If set, rstat_out[1:0] changes at falling edge of      */
     /* Stat-Out Clk otherwise, rstat_out[1:0] changes at rising     */
     /* edge of Stat-Out Clk.                                        */
     /* range: 1:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD out_stat_phase_sel;

  } __ATTRIBUTE_PACKED__ out_of_band_tx_configuration1_reg;


  /* Out Of Band Rx0 Configuration0: Out-Of-band receive            */
  /* interface A settings.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4715 */

     /* RxCalLen: Status receive A (OOBrx-A) calendar length.        */
     /* Defines the number of OOB-rx channels in a single            */
     /* calendar. (Maximum calendar length : 512 channels)           */
     /* range: 9:0, access type: RW, default value: 0x200            */
     SOC_PETRA_REG_FIELD rx_cal_len;

     /* RxCalM: Status receive A (OOBrx-A) calendar-M. The           */
     /* number of calendar repetitions within a status frame.        */
     /* Total status frame length: RxCalLen X RxCalM + 2             */
     /* range: 15:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_cal_m;

     /* OobRxEn: Out-Of-Band flow- control receive interface- A      */
     /* enable.                                                      */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_rx_en;

     /* OobRxLbEn: Enables leaky-bucket algorithm for measuring      */
     /* the error rate by LB1 and LB2. If set, then LB1 and LB2       */
     /* are decremented whenever DIP2GoodToBadRatio error free       */
     /* frames are received. If 0, then LB1 and LB2 are reset to     */
     /* 0 when DIP2GoodToBadRatio error free frames are              */
     /* received.                                                    */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_rx_lb_en;

     /* OofrmStsSel: If set then when OOB is in out-of-frame         */
     /* state, it presents flow-control 'on' indication to CFC       */
     /* core (2'b10). Else, then when in out-of-frame a              */
     /* flow-control 'off' is presented (2'b00).                     */
     /* range: 18:18, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD oofrm_sts_sel;

     /* InStatPhaseSel: Determine the phase selection to sample      */
     /* the incoming Stat[1:0]. If set, then Stat is sampled on       */
     /* the fc_clk rising edge. Otherwise, Stat is sampled on the     */
     /* fc_clk falling edge.                                         */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD in_stat_phase_sel;

     /* RxAsyncRstn: Asynchronous reset to the status receive        */
     /* asynch FIFO.                                                 */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_async_rstn;

  } __ATTRIBUTE_PACKED__ out_of_band_rx_configuration0_reg;


  /* Out Of Band Rx0 Threshold Configuration0: Out- of- band        */
  /* receive interface- A settings.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4716 */

     /* Dip2Good2BadRatio: Number of error-free frames received      */
     /* that, either clears, or decrements LB1 and LB2               */
     /* (According to OobRxLbEn value). A value of 0 causes any      */
     /* error-free frame to clear the leaky buckets, regardless      */
     /* of the value of OobRxLbEn.                                   */
     /* range: 7:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD dip2_good2_bad_ratio;

     /* MaxFrmPattrn: Number of consecutive framing patterns         */
     /* received on TSTAT before declaring out-of--frame state.      */
     /* range: 15:8, access type: RW, default value: 0x3             */
     SOC_PETRA_REG_FIELD max_frm_pattrn;

     /* InFrmTh: Number of consecutive error-free frames that        */
     /* places the OOB-rx status path into the in-frame state        */
     /* range: 23:16, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD in_frm_th;

     /* OutOfFrmTh: Level of LB1 that forces the OOB-rx path to      */
     /* enter out-of-frame state.                                    */
     /* range: 31:24, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD out_of_frm_th;

  } __ATTRIBUTE_PACKED__ out_of_band_rx_threshold_configuration0_reg;


  /* Out Of Band Rx0 Threshold Configuration1: Out-Of-band          */
  /* receive-interface-A settings.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4717 */

     /* Dip2AlrmTh: Level of LB2 that forces the OOB-rx path to      */
     /* declare a DIP-alarm. This state is indicated to the data     */
     /* source.                                                      */
     /* range: 7:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD dip2_alrm_th;

  } __ATTRIBUTE_PACKED__ out_of_band_rx_threshold_configuration1_reg;


  /* Out Of Band Rx1 Configuration0: Out-Of-band                    */
  /* receive-interface-B settings.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4718 */

     /* RxCalLen: Status receive A (OOBrx-b) calendar length.        */
     /* Defines the number of OOB-rx channels in a single            */
     /* calendar. (Maximum calendar length : 512 channels)           */
     /* range: 9:0, access type: RW, default value: 0x200            */
     SOC_PETRA_REG_FIELD rx_cal_len;

     /* RxCalM: Status receive A (OOBrx-B) calendar-M. The           */
     /* number of calendar repetitions within a status frame.        */
     /* Total status frame length: RxCalLen X RxCalM + 2             */
     /* range: 15:12, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD rx_cal_m;

     /* OobRxEn: Out-Of-Band flow- control receive interface- B      */
     /* enable.                                                      */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_rx_en;

     /* OobRxLbEn: Enables leaky-bucket algorithm for measuring      */
     /* the error rate by LB1 and LB2. If set, then LB1 and LB2      */
     /* are decremented whenever DIP2GoodToBadRatio error free       */
     /* frames are received. If 0, LB1 and LB2 are reset to 0        */
     /* when DIP2GoodToBadRatio error free frames are received.      */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD oob_rx_lb_en;

     /* OofrmStsSel: If set then when OOB is in out-of-frame         */
     /* state, it presents flow-control 'on' indication to CFC       */
     /* core (2'b10). Else, then when in out-of-frame a              */
     /* flow-control 'off' is presented (2'b00).                     */
     /* range: 18:18, access type: RW, default value: 0x1            */
     SOC_PETRA_REG_FIELD oofrm_sts_sel;

     /* InStatPhaseSel: Determine the phase selection to sample      */
     /* the incoming Stat[1:0]. If set, then Stat is sampled on       */
     /* the fc_clk rising edge. Otherwise, Stat is sampled on the     */
     /* fc_clk falling edge.                                         */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD in_stat_phase_sel;

     /* RxAsyncRstn: Asynchronous reset to the status receive        */
     /* asynch FIFO (RSS).                                           */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rx_async_rstn;

  } __ATTRIBUTE_PACKED__ out_of_band_rx1_configuration0_reg;


  /* Out Of Band Rx1 Threshold Configuration0: Out-Of-band          */
  /* receive-interface-B settings.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4719 */

     /* Dip2Good2BadRatio: Number of error-free frames received      */
     /* that, either clears, or decrements LB1 and LB2               */
     /* (According to OobRxLbEn value). A value of 0 causes any      */
     /* error-free frame to clear the leaky buckets, regardless      */
     /* of the value of OobRxLbEn.                                   */
     /* range: 7:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD dip2_good2_bad_ratio;

     /* MaxFrmPattrn: Number of consecutive framing pattern          */
     /* received on TSTAT before declaring outof- frame.             */
     /* range: 15:8, access type: RW, default value: 0x3             */
     SOC_PETRA_REG_FIELD max_frm_pattrn;

     /* InFrmTh: Number of consecutive error-free frames that        */
     /* places the OOB-rx status path into the in-frame state        */
     /* range: 23:16, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD in_frm_th;

     /* OutOfFrmTh: Level of LB1 that forces the OOB-rx path to      */
     /* enter out-of-frame states.                                   */
     /* range: 31:24, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD out_of_frm_th;

  } __ATTRIBUTE_PACKED__ out_of_band_rx1_threshold_configuration0_reg;


  /* Out Of Band Rx1 Threshold Configuration1: Out-Of-band          */
  /* receive-interface-B settings.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x471a */

     /* Dip2AlrmTh: Level of LB2 that forces the OOB-rx path to      */
     /* declare a DIP-alarm. This state is indicated to the data     */
     /* source.                                                      */
     /* range: 7:0, access type: RW, default value: 0x3              */
     SOC_PETRA_REG_FIELD dip2_alrm_th;

  } __ATTRIBUTE_PACKED__ out_of_band_rx1_threshold_configuration1_reg;


  /* Out Of Band Rx0 Error Counter: Out-Of-band                     */
  /* receive-interface-A status.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x471b */

     /* FrmErrCnt: Number of framing errors. Frame Error defined     */
     /* when the OOB-rx fails to synchronize on the frame's          */
     /* sync. This register is clear on read.                        */
     /* range: 6:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD frm_err_cnt;

     /* FrmErrCntOvf: FrnErrCnt overflow.                            */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD frm_err_cnt_ovf;

     /* Dip2ErrCnt: Number of Dip2 errors detected. This             */
     /* register is clear on read.                                   */
     /* range: 14:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD dip2_err_cnt;

     /* Dip2ErrCntOvf: Dip2ErrCnt overflow.                          */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD dip2_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ out_of_band_rx_error_counter_reg;


  /* Out Of Band Rx1 Error Counter: Out-Of-band                     */
  /* receive-interface-B status.                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x471c */

     /* FrmErrCnt: Number of framing errors. Frame Error defined     */
     /* when the OOB-rx fails to synchronize on the frame's          */
     /* sync. This register is clear on read.                        */
     /* range: 6:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD frm_err_cnt;

     /* FrmErrCntOvf: FrnErrCnt overflow.                            */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD frm_err_cnt_ovf;

     /* Dip2ErrCnt: Number of Dip2 errors detected. This             */
     /* register is clear on read.                                   */
     /* range: 14:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD dip2_err_cnt;

     /* Dip2ErrCntOvf: Dip2ErrCnt overflow.                          */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD dip2_err_cnt_ovf;

  } __ATTRIBUTE_PACKED__ out_of_band_rx1_error_counter_reg;


  /* Force Scheduler Flow Control0: Force -Scheduler's flow         */
  /* controls by CPU.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4750 */

     /* FrcSchDevFc: If set, forces the device flow control          */
     /* presented to the SCH.                                        */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_sch_dev_fc;

     /* FrcSchErpFc: If set, forces the ERP                          */
     /* (egress-replication-port) flow control presented to the      */
     /* SCH.                                                         */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_sch_erp_fc;

     /* FrcSchChnPortFc: Enables forcing of the eight                */
     /* channelized ports flow control presented to the SCH.         */
     /* range: 9:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD frc_sch_chn_port_fc;

     /* FrcSchCpuPortFc: Enables forcing of the CPU port flow        */
     /* control presented to the SCH.                                */
     /* range: 10:10, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD frc_sch_cpu_port_fc;

     /* FrcSchRclPortFc: Enables forcing of the Recycle port         */
     /* flow control presented to the SCH.                           */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD frc_sch_rcl_port_fc;

  } __ATTRIBUTE_PACKED__ force_scheduler_flow_control0_reg;


  /* Force Scheduler Flow Control1: Force Scheduler's flow          */
  /* controls by CPU.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4751 */

     /* FrcSchHrFc159_128: This bitmap forces general HRs            */
     /* flow-control signals presented to the EGQ. HRs: 128->159     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_sch_hr_fc159_128;

  } __ATTRIBUTE_PACKED__ force_scheduler_flow_control1_reg;


  /* Force Scheduler Flow Control2: Force Scheduler's flow          */
  /* controls by CPU.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4752 */

     /* FrcSchHrFc191_160: This bitmap forces general HRs            */
     /* flow-control signals presented to the EGQ. HRs: 160->191     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_sch_hr_fc191_160;

  } __ATTRIBUTE_PACKED__ force_scheduler_flow_control2_reg;


  /* Force Scheduler Flow Control3: Force Scheduler's flow          */
  /* controls by CPU.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4753 */

     /* FrcSchHrFc223_192: This bitmap forces general HRs            */
     /* flow-control signals presented to the EGQ. HRs: 192->223     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_sch_hr_fc223_192;

  } __ATTRIBUTE_PACKED__ force_scheduler_flow_control3_reg;


  /* Force Scheduler Flow Control4: Force Scheduler's flow          */
  /* controls by CPU.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4754 */

     /* FrcSchHrFc255_224: This bitmap forces general HRs            */
     /* flow-control signals presented to the EGQ. HRs: 224->255     */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_sch_hr_fc255_224;

  } __ATTRIBUTE_PACKED__ force_scheduler_flow_control4_reg;


  /* Force Egq Flow Control0: Forces EGQ's flow controls by         */
  /* CPU.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4755 */

     /* FrcEgqOfpFc31_0: This bitmap forces the flow-control         */
     /* signals presented to the EGQ. OFPs: 0->31                    */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_egq_ofp_fc31_0;

  } __ATTRIBUTE_PACKED__ force_egq_flow_control0_reg;


  /* Force Egq Flow Control1: Forces EGQ's flow controls by         */
  /* CPU.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4756 */

     /* FrcEgqOfpFc63_32: This bitmap forces the flow-control        */
     /* signals presented to the EGQ. OFPs: 32->63                   */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_egq_ofp_fc63_32;

  } __ATTRIBUTE_PACKED__ force_egq_flow_control1_reg;


  /* Force Egq Flow Control2: Forces EGQ's flow controls by         */
  /* CPU.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4757 */

     /* FrcEgqOfpFc79_64: This bitmap forces the flow-control        */
     /* signals presented to the EGQ. OFPs: 64->79                   */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_egq_ofp_fc79_64;

  } __ATTRIBUTE_PACKED__ force_egq_flow_control2_reg;


  /* Force Nif Link Level Flow Control: Forces NIF flow             */
  /* controls by CPU.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4758 */

     /* FrcNifLnkFc0: This bitmap forces the link-level              */
     /* flow-control signals presented to NIFa.                      */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_nif_lnk_fc0;

     /* FrcNifLnkFc1: This bitmap forces the link-level              */
     /* flow-control signals presented to NIFb.                      */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD frc_nif_lnk_fc1;

  } __ATTRIBUTE_PACKED__ force_nif_link_level_flow_control_reg;


  /* Force Nif Class Based Flow Control0: Forces NIF flow           */
  /* controls by CPU.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4759 */

     /* FrcNifClb0: This bitmap forces the class-based               */
     /* flow-control signals presented to NIFa.                      */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_nif_clb0;

  } __ATTRIBUTE_PACKED__ force_nif_class_based_flow_control0_reg;


  /* Force Nif Class Based Flow Control1: Forces NIF flow           */
  /* controls by CPU.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x475a */

     /* FrcNifClb1: This bitmap forces the class-based               */
     /* flow-control signals presented to NIFb.                      */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_nif_clb1;

  } __ATTRIBUTE_PACKED__ force_nif_class_based_flow_control1_reg;


  /* Force Nif Link Level Flow Control1: Forces fast-               */
  /* link-level flow controls presented to the NIFs, by the         */
  /* CPU.                                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x475b */

     /* FrcNifaFastLl: This bitmap forces the Link-level             */
     /* flow-control signals received by the OOB-rx and              */
     /* presented to NIFa.                                           */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD frc_nifa_fast_ll;

     /* FrcNifbFastLl: This bitmap forces the Link-level             */
     /* flow-control signals received by the OOB-rx and              */
     /* presented to NIFb.                                           */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD frc_nifb_fast_ll;

  } __ATTRIBUTE_PACKED__ force_nif_link_level_flow_control1_reg;


  /* Egq Flow Control Status0: Present the EGQ's received           */
  /* flow controls (Status)                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x475c */

     /* EgqDevFc: EGQ's Device FC status(sticky bit) This            */
     /* register is clear on read.                                   */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_dev_fc;

     /* EgqErpFc: EGQ's ERP (egress-replication-port) FC             */
     /* status(sticky bit).                                          */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_erp_fc;

     /* EgqChnPortFc: EGQ's eight channelized ports FC status        */
     /* (sticky bit).                                                */
     /* range: 9:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD egq_chn_port_fc;

     /* EgqCpuPortFc: EGQ's CPU port FC status (sticky bit).         */
     /* range: 10:10, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_cpu_port_fc;

     /* EgqRclPortFc: EGQ's Recycle port FC status (sticky bit).     */
     /* range: 11:11, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD egq_rcl_port_fc;

  } __ATTRIBUTE_PACKED__ egq_flow_control_status0_reg;


  /* Egq Flow Control Status1: Present the EGQ's received           */
  /* flow controls (Status).                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x475d */

     /* EgqOfpHpFc31_0: EGQ's High-priority OFPs 0->31 FC status     */
     /* (sticky) This register is clear on read.                     */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD egq_ofp_hp_fc31_0;

  } __ATTRIBUTE_PACKED__ egq_flow_control_status1_reg;


  /* Egq Flow Control Status2: Present the EGQ's received           */
  /* flow controls (Status).                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x475e */

     /* EgqOfpHpFc63_32: EGQ's High-priority OFP 32->63 FC           */
     /* status (sticky) This register is clear on read.              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD egq_ofp_hp_fc63_32;

  } __ATTRIBUTE_PACKED__ egq_flow_control_status2_reg;


  /* Egq Flow Control Status3: Preset the EGQ's received flow       */
  /* controls (Status).                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x475f */

     /* EgqOfpHpFc79_64: EGQ's High-priority OFP 63->79 FC           */
     /* status (sticky) This register is clear on read.              */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD egq_ofp_hp_fc79_64;

  } __ATTRIBUTE_PACKED__ egq_flow_control_status3_reg;


  /* Nif Flow Control Status0: Present the NIF's received           */
  /* flow controls (Status).                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4760 */

     /* NifIngFifoFc0: Nifa's input FIFO FC status (sticky).         */
     /* Auto-clear. This register is clear on read.                  */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD nif_ing_fifo_fc0;

     /* NifIngFifoFc1: Nifb's input FIFO FC status (sticky).         */
     /* Auto-clear.                                                  */
     /* range: 31:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD nif_ing_fifo_fc1;

  } __ATTRIBUTE_PACKED__ nif_flow_control_status0_reg;


  /* Nif Flow Control Status1: Present the NIF's received           */
  /* flow controls (Status).                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4761 */

     /* NifClbFc0: Nifa's received Class-based flow-control          */
     /* status (sticky). Auto-clear This register is clear on        */
     /* read.                                                        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD nif_clb_fc0;

  } __ATTRIBUTE_PACKED__ nif_flow_control_status1_reg;


  /* Nif Flow Control Status2: Present the NIF's received           */
  /* flow controls (Status).                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4762 */

     /* NifClbFc1: Nifb's received Class-based flow-control          */
     /* status (sticky). Auto-clear This register is clear on        */
     /* read.                                                        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD nif_clb_fc1;

  } __ATTRIBUTE_PACKED__ nif_flow_control_status2_reg;


  /* Obrx Flow Control Status0: Presents flow controls              */
  /* received on the OOB-interface.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4763 */

     /* ObrxSchbFc31_0: Scheduler-based received flow-controls       */
     /* from the Out-Of-Band interfaces. FC bins: 31:0. This         */
     /* status accumulates FCs from both OOB-RX interfaces.          */
     /* Clears when ObrxSchbFc127_96 is read.                        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrx_schb_fc31_0;

  } __ATTRIBUTE_PACKED__ obrx_flow_control_status0_reg;


  /* Obrx Flow Control Status1: Presents flow controls              */
  /* received on the OOB-interface.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4764 */

     /* ObrxSchbFc63_32: Scheduler-based received flow-controls      */
     /* from the Out-Of-Band interfaces. FC bins: 63:32. This         */
     /* status accumulates FCs from both OOB-RX interfaces.          */
     /* Clears when ObrxSchbFc127_96 is read.                        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrx_schb_fc63_32;

  } __ATTRIBUTE_PACKED__ obrx_flow_control_status1_reg;


  /* Obrx Flow Control Status2: Presents flow controls              */
  /* received on the OOB-interface.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4765 */

     /* ObrxSchbFc95_64: Scheduler-based received flow-controls      */
     /* from the Out-Of-Band interfaces. FC bins: 95:64. This        */
     /* status accumulates FCs from both OOB-RX interfaces.          */
     /* Clears when ObrxSchbFc127_96 is read.                        */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrx_schb_fc95_64;

  } __ATTRIBUTE_PACKED__ obrx_flow_control_status2_reg;


  /* Obrx Flow Control Status3: Presents flow controls              */
  /* received on the OOB-interface.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4766 */

     /* ObrxSchbFc127_96: Scheduler-based received flow-controls     */
     /* from the Out-Of-Band interfaces. FC bins: 127:96 This         */
     /* status accumulates FCs from both OOB-RX interfaces. When     */
     /* read. Clears all the ObrxSchbFc statuses. This register      */
     /* is clear on read.                                            */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrx_schb_fc127_96;

  } __ATTRIBUTE_PACKED__ obrx_flow_control_status3_reg;


  /* Obrx Flow Control Status4: Presents flow controls              */
  /* received on the OOB-interface.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4767 */

     /* ObrxOfpFc31_0: OFP-based (out going fap port) received       */
     /* flow-controls from the Out-Of-Band interfaces. FC bins:      */
     /* 31:0 This status accumulates FCs from both OOB-RX            */
     /* interfaces. Clears when ObrxOfpFc79_64 is read.              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrx_ofp_fc31_0;

  } __ATTRIBUTE_PACKED__ obrx_flow_control_status4_reg;


  /* Obrx Flow Control Status5: Presents flow controls              */
  /* received on the OOB-interface.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4768 */

     /* ObrxOfpFc63_32: OFP-based (out going fap port) received      */
     /* flow-controls from the Out-Of-Band interfaces. FC bins:      */
     /* 63:32 This status accumulates FCs from both OOB-RX           */
     /* interfaces. Clears when ObrxOfpFc79_64 is read.              */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrx_ofp_fc63_32;

  } __ATTRIBUTE_PACKED__ obrx_flow_control_status5_reg;


  /* Obrx Flow Control Status6: Presents flow controls              */
  /* received on the OOB-interface.                                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4769 */

     /* ObrxOfpFc79_64: OFP-based (out going fap port) received      */
     /* flow-controls from the Out-Of-Band interfaces. FC bins:      */
     /* 79:64 This status accumulates FCs from both OOB-RX           */
     /* interfaces. When read, clears all ObrxOfpFc statuses.        */
     /* This register is clear on read.                              */
     /* range: 15:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD obrx_ofp_fc79_64;

  } __ATTRIBUTE_PACKED__ obrx_flow_control_status6_reg;


  /* Vsqa Glb Flow Control Status: Presents flow controls           */
  /* received from the STE.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x476a */

     /* VsqaFc: STE's VSQs 0->3 received flow-controls. These        */
     /* VSQs are defined by Qs category. sticky bits. Clears         */
     /* when read. This register is clear on read.                   */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD vsqa_fc;

     /* FrBdbFcLp: IQM's free-BDB low-priority flow control.         */
     /* Clears when read.                                            */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_bdb_fc_lp;

     /* FrBdbFcHp: IQM's free-BDB high-priority flow control.        */
     /* Clears when read.                                            */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_bdb_fc_hp;

     /* FrUniDbFcLp: IQM's free-unicast dbuffs low-priority flow     */
     /* control. Clears when read.                                   */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_uni_db_fc_lp;

     /* FrUniDbFcHp: IQM's free-unicast dbuffs high-priority         */
     /* flow control. Clears when read.                              */
     /* range: 7:7, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_uni_db_fc_hp;

     /* FrFlMcDbFcLp: IQM's free-full-multicast dbuffs               */
     /* low-priority flow control. Clears when read.                 */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_fl_mc_db_fc_lp;

     /* FrFlMcDbFcHp: IQM's free-full-multicast dbuffs               */
     /* high-priority flow control. Clears when read.                */
     /* range: 9:9, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD fr_fl_mc_db_fc_hp;

  } __ATTRIBUTE_PACKED__ vsqa_glb_flow_control_status_reg;


  /* Vsqb Flow Control Status: Presents flow controls               */
  /* received from the STE.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x476b */

     /* VsqbFc: STE's VSQs 4->35 received flow-controls. These        */
     /* VSQs are defined by Qs category and traffic-class (IQM Q     */
     /* class). Sticky bits. Clears when read. This register is         */
     /* clear on read. This register is clear on read.               */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsqb_fc;

  } __ATTRIBUTE_PACKED__ vsqb_flow_control_status_reg;


  /* Vsqc Flow Control Status0: Presents flow controls              */
  /* received from the STE.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x476c */

     /* VsqcFc0: STE's VSQs 36->67 received flow-controls. These      */
     /* VSQs are defined by Qs category2 and                         */
     /* connection-class(IQM Q class). Sticky bits. Clears when        */
     /* read                                                         */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsqc_fc0;

  } __ATTRIBUTE_PACKED__ vsqc_flow_control_status0_reg;


  /* Vsqc Flow Control Status1: Presents flow controls              */
  /* received from the STE.                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x476d */

     /* VsqcFc1: STE's VSQs 68->99 received flow-controls. These      */
     /* VSQs are defined by Qs category3 and                         */
     /* connection-class(IQM Q class). Sticky bits. Clears when        */
     /* VsqcFc1 is read. This register is clear on read. This         */
     /* register is clear on read.                                   */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsqc_fc1;

  } __ATTRIBUTE_PACKED__ vsqc_flow_control_status1_reg;


  /* Vsqd Flow Control0: This register and the following            */
  /* seven present flow controls received from the STE based        */
  /* on VSQs deifned by statistics tag field.(VSQs 100->355),       */
  /* sticky bits. This reg presents VSQs 100->131. Clears when        */
  /* VsqdFc7 is read.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x476e */

     /* VsqdFc0: STE's VSQs 132->163 received flow-controls.         */
     /* Clears when VsqdFc7 is read.                                 */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsqd_fc0;

  } __ATTRIBUTE_PACKED__ vsqd_flow_control0_reg;


  /* Vsqd Flow Control1:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x476f */

     /* VsqdFc1: STE's VSQs 132->163 received flow-controls.         */
     /* Clears when VsqdFc7 is read.                                 */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsqd_fc1;

  } __ATTRIBUTE_PACKED__ vsqd_flow_control1_reg;


  /* Vsqd Flow Control2:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4770 */

     /* VsqdFc2: STE's VSQs 164->195 received flow-controls.         */
     /* Clears when VsqdFc7 is read.                                 */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsqd_fc2;

  } __ATTRIBUTE_PACKED__ vsqd_flow_control2_reg;


  /* Vsqd Flow Control3:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4771 */

     /* VsqdFc3: STE's VSQs 196->227 received flow-controls.         */
     /* Clears when VsqdFc7 is read.                                 */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsqd_fc3;

  } __ATTRIBUTE_PACKED__ vsqd_flow_control3_reg;


  /* Vsqd Flow Control4:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4772 */

     /* VsqdFc4: STE's VSQs 228->259 received flow-controls.         */
     /* Clears when VsqdFc7 is read.                                 */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsqd_fc4;

  } __ATTRIBUTE_PACKED__ vsqd_flow_control4_reg;


  /* Vsqd Flow Control5:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4773 */

     /* VsqdFc5: STE's VSQs 260->291 received flow-controls.         */
     /* Clears when VsqdFc7 is read.                                 */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsqd_fc5;

  } __ATTRIBUTE_PACKED__ vsqd_flow_control5_reg;


  /* Vsqd Flow Control6:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4774 */

     /* VsqdFc6: STE's VSQs 292->323 received flow-controls.         */
     /* Clears when VsqdFc7 is read.                                 */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsqd_fc6;

  } __ATTRIBUTE_PACKED__ vsqd_flow_control6_reg;


  /* Vsqd Flow Control7:                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4775 */

     /* VsqdFc7: STE's VSQs 324->355 received flow-controls.         */
     /* This register is clear on read. This register is clear       */
     /* on read.                                                     */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD vsqd_fc7;

  } __ATTRIBUTE_PACKED__ vsqd_flow_control7_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_CFC_REGS;
/* Block definition: SCH */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* Interrupt Register: This register contains the interrupt       */
  /* sources residing in this unit. The interrupts indicated        */
  /* by CL are cleared when writing 1 to the relevant bit           */
  /* position in this register.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4200 */

     /* SmpBadMsg: Interrupt source mirror                           */
     /* range: 0:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD smp_bad_msg;

     /* ActFlow BadParams: Interrupt source mirror.                  */
     /* range: 2:2, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD act_flow_bad_params;

     /* ShpFlow BadParams: Interrupt source mirror.                  */
     /* range: 3:3, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD shp_flow_bad_params;

     /* RestartFlowEvent: Interrupt source mirror.                   */
     /* range: 4:4, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD restart_flow_event;

     /* range: 5:5, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD smpthrow_scl_msg;

     /* SMPFullLevel1: SMP FIFO in pipe reached level1.              */
     /* range: 6:6, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpfull_level1;

     /* SMPFullLevel2: SMP FIFO in pipe reached level2.              */
     /* range: 7:7, access type: RC, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpfull_level2;

     /* FCTFIFOOvf: The fifo towards the FCT is full                 */
     /* range: 14:14, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fctfifoovf;

     /* DHDECC: ECC error in the DHD                                 */
     /* range: 16:16, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dhdecc;

     /* DCDECC: ECC error in the DCD                                 */
     /* range: 17:17, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dcdecc;

     /* FLHHRECC: ECC error in the FLHHR                             */
     /* range: 18:18, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD flhhrecc;

     /* FLTHRECC: ECC error in the FLTHR                             */
     /* range: 19:19, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD flthrecc;

     /* FLHCLECC: ECC error in the FLHCL                             */
     /* range: 20:20, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD flhclecc;

     /* FLTCLECC: ECC error in the FLTCL                             */
     /* range: 21:21, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fltclecc;

     /* FLHFQECC: ECC error in the FLHFQ                             */
     /* range: 22:22, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD flhfqecc;

     /* FLTFQECC: ECC error in the FLTFQ                             */
     /* range: 23:23, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fltfqecc;

     /* FDMSECC: ECC error in the FDMS                               */
     /* range: 24:24, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdmsecc;

     /* FDMDECC: ECC error in the FDMD                               */
     /* range: 25:25, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdmdecc;

     /* SHDSECC: ECC error in the SHDS                               */
     /* range: 26:26, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD shdsecc;

     /* SHDDECC: ECC error in the SHDD                               */
     /* range: 27:27, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD shddecc;

     /* FQMECC: ECC error in the FQM                                 */
     /* range: 28:28, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fqmecc;

     /* SFLHECC: ECC error in the SFLH                               */
     /* range: 29:29, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD sflhecc;

     /* SFLTECC: ECC error in the SFLT                               */
     /* range: 30:30, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD sfltecc;

     /* FSMECC: ECC error in the FSM                                 */
     /* range: 31:31, access type: RC, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmecc;

  } __ATTRIBUTE_PACKED__ interrupt_reg;


  /* Interrupt Mask Data: Each bit in this register                 */
  /* corresponds to an interrupt source in the Interrupt            */
  /* Register. The interrupt source is masked by writing 0 to       */
  /* the relevant bit in this register.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4210 */

     /* SmpBadMsgMask: Writing 0 masks the corresponding             */
     /* interrupt source.                                            */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD smp_bad_msg_mask;

     /* ActFlow BadParamsMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD act_flow_bad_params_mask;

     /* ShpFlow BadParamsMask: Writing 0 masks the corresponding     */
     /* interrupt source.                                            */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD shp_flow_bad_params_mask;

     /* RestartFlowEventMask: Writing 0 masks the corresponding      */
     /* interrupt source.                                            */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD restart_flow_event_mask;

     /* range: 5:5, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpthrow_scl_msg_mask;

     /* SMPFullLevel1Mask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 6:6, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpfull_level1_mask;

     /* SMPFullLevel2Mask: Writing 0 masks the corresponding         */
     /* interrupt source.                                            */
     /* range: 7:7, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpfull_level2_mask;

     /* FCTFIFOOvfMask: Writing 0 masks the corresponding            */
     /* interrupt source.                                            */
     /* range: 14:14, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fctfifoovf_mask;

     /* DHDECCMask: Writing 0 masks the corresponding interrupt      */
     /* source.                                                      */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dhdeccmask;

     /* DCDECCMask: Writing 0 masks the corresponding interrupt      */
     /* source.                                                      */
     /* range: 17:17, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dcdeccmask;

     /* FLHHRECCMask: Writing 0 masks the corresponding              */
     /* interrupt source.                                            */
     /* range: 18:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flhhreccmask;

     /* FLTHRECCMask: Writing 0 masks the corresponding              */
     /* interrupt source.                                            */
     /* range: 19:19, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flthreccmask;

     /* FLHCLECCMask: Writing 0 masks the corresponding              */
     /* interrupt source.                                            */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flhcleccmask;

     /* FLTCLECCMask: Writing 0 masks the corresponding              */
     /* interrupt source.                                            */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fltcleccmask;

     /* FLHFQECCMask: Writing 0 masks the corresponding              */
     /* interrupt source.                                            */
     /* range: 22:22, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD flhfqeccmask;

     /* FLTFQECCMask: Writing 0 masks the corresponding              */
     /* interrupt source.                                            */
     /* range: 23:23, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fltfqeccmask;

     /* FDMSECCMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdmseccmask;

     /* FDMDECCMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fdmdeccmask;

     /* SHDSECCMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 26:26, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD shdseccmask;

     /* SHDDECCMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 27:27, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD shddeccmask;

     /* FQMECCMask: Writing 0 masks the corresponding interrupt      */
     /* source.                                                      */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fqmeccmask;

     /* SFLHECCMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 29:29, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sflheccmask;

     /* SFLTECCMask: Writing 0 masks the corresponding interrupt     */
     /* source.                                                      */
     /* range: 30:30, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sflteccmask;

     /* FSMECCMask: Writing 0 masks the corresponding interrupt      */
     /* source.                                                      */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD fsmeccmask;

  } __ATTRIBUTE_PACKED__ interrupt_mask_data_reg;


  /* Indirect Command Wr Data: Indirect write data: Data that       */
  /* is written to the addressed object when an indirect            */
  /* write operation is triggered. 0x020 is used for writing        */
  /* bits 31:0.0x021 is used for writing bits 63:32.0x022 is        */
  /* used for writing bits 95:64.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4220 */

     /* IndirectCommandWrData: Indirect write data.                  */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_wr_data;

  } __ATTRIBUTE_PACKED__ indirect_command_wr_data_reg_0;


  /* Indirect Command Rd Data: Data returned by an indirect         */
  /* read operation. 0x030 is used for reading bits                 */
  /* 31:0.0x031 is used for reading bits 63:32.0x032 is used        */
  /* for reading bits 95:64.                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4230 */

     /* IndirectCommandRdData: Indirect read data                    */
     /* range: 31:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_rd_data;

  } __ATTRIBUTE_PACKED__ indirect_command_rd_data_reg_0;


  /* Indirect Command: Indirect Commands. Used to send              */
  /* indirect commands and receive their status.                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4240 */

     /* IndirectCommandTrigger: Triggers indirect access, as         */
     /* defined by the rest of the registers. The negation of        */
     /* this bit indicates that the operation has been               */
     /* completed.                                                   */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD indirect_command_trigger;

  } __ATTRIBUTE_PACKED__ indirect_command_reg;


  /* Indirect Command Address: Indirect access address.             */
  /* Defines which indirect object is accessed.                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4241 */

     /* IndirectCommandAddr: Indirect access address. Defines        */
     /* which indirect object is accessed.                           */
     /* range: 30:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD indirect_command_addr;

     /* IndirectCommandType: Type of command to perform: 0:          */
     /* D193Write operation 1: Read operation.                       */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD indirect_command_type;

  } __ATTRIBUTE_PACKED__ indirect_command_address_reg;


  /* Credit Counter: This register counts the credits that          */
  /* the scheduler generates.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4260 */

     /* CreditCnt: Counts issued credits that match the filter.      */
     /* This register is clear on read.                              */
     /* range: 30:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD credit_cnt;

     /* CreditOvf: The counter has overflowed. This register is      */
     /* clear on read.                                               */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD credit_ovf;

  } __ATTRIBUTE_PACKED__ credit_counter_reg;


  /* Scheduler Counter: This register counts internal credits       */
  /* that are sent to aggregate schedulers.                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4261 */

     /* : Counts credits issued to a scheduler that match the        */
     /* filter. This register is clear on read.                      */
     /* range: 30:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD cmlschcredit_cnt;

     /* : Indicates that the counter has overflowed. This            */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD cmlschcredit_ovf;

  } __ATTRIBUTE_PACKED__ scheduler_counter_reg;


  /* SMP Message Counter: This counter counts the messages          */
  /* received by the SMP. Configuration register 0x107.              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4266 */

     /* SMPMsgCnt: Counts the number of messages received at the     */
     /* SMP configured according to SMP counter configuration.       */
     /* This register is clear on read.                              */
     /* range: 30:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD smpmsg_cnt;

     /* SMPMsgCntOvf: Indicates that the counter has overflowed.     */
     /* This register is clear on read.                              */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpmsg_cnt_ovf;

  } __ATTRIBUTE_PACKED__ smp_message_counter_reg;


  /* Attempt to Activate Flow / Scheduler with Bad                  */
  /* Parameters: This register latches internal flow                */
  /* activation events, If the scheduler attempts to activate       */
  /* flow with bad parameters the register latches the flow         */
  /* and its parameters until the register is read.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4268 */

     /* ActFlowId: The flow Id or Scheduler that had bad             */
     /* parameters in the FDM. This register is clear on read.       */
     /* range: 15:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD act_flow_id;

     /* ActFlowCOSN Valid: The Flow or Scheduler has bad             */
     /* parameters in the FDM COS 0. This register is clear on       */
     /* read.                                                        */
     /* range: 16:16, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD act_flow_cosn_valid;

     /* ActFlowBadSch: The flow is not connected to a scheduler      */
     /* (and according the SEM, the father is not a scheduler).      */
     /* This register is clear on read.                              */
     /* range: 20:20, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD act_flow_bad_sch;

     /* ActFlow BadParams: This message is valid. This message       */
     /* is generated at the process of activating a flow. This       */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD act_flow_bad_params;

  } __ATTRIBUTE_PACKED__ attempt_to_activate_flow_scheduler_with_bad_parameters_reg;


  /* Attempt to Activate A shaper with Bad Parameters:              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4269 */

     /* ShpFlowId: The flow ID/Scheduler that had bad parameters     */
     /* in the SHD. This register is clear on read.                  */
     /* range: 15:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD shp_flow_id;

     /* ShpFlow BadParams: This message is valid. This message       */
     /* is generated while activating a flow on the shaper if        */
     /* the COS of the shaper is not valid in the SHD table -        */
     /* either overflow or zero. This register is clear on read.     */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD shp_flow_bad_params;

  } __ATTRIBUTE_PACKED__ attempt_to_activate_a_shaper_with_bad_parameters_reg;


  /* Last Flow Restart Event: This register holds the last          */
  /* flow number that was restarted. A restart flow event           */
  /* happens when certain parameters of the flow change while       */
  /* it is being installed on the scheduler. For example:           */
  /* Certain types of QoS or the scheduler it is installed          */
  /* on.                                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x426a */

     /* RestartFlowId: The flow ID/Scheduler that was restarted.     */
     /* This register is clear on read.                              */
     /* range: 15:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD restart_flow_id;

     /* RestartFlowEvent: A restart flow event has occurred.         */
     /* This register is clear on read.                              */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD restart_flow_event;

  } __ATTRIBUTE_PACKED__ last_flow_restart_event_reg;


  /* SCL - SMP Messages: This register holds the last message       */
  /* sent from the SCL to the SMP. If the bit SMPSCLMsgThrow        */
  /* is valid, then the message is kept until the register is       */
  /* read.                                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x426c */

     /* SMPSCLMsgID: The flow ID of the last message kept.           */
     /* range: 15:0, access type: R, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpsclmsg_id;

     /* SMPSCLMsgStatus: The Status of the last message kept.        */
     /* range: 17:16, access type: R, default value: 0x0             */
     SOC_PETRA_REG_FIELD smpsclmsg_status;

     /* SMPSCLMsgType: 0 - Aggregate Message 1 - Restart Message     */
     /* range: 20:20, access type: R, default value: 0x0             */
     SOC_PETRA_REG_FIELD smpsclmsg_type;

     /* SMPSCLMsgThrow: The SCL wrote a message to the SMP while     */
     /* its fifos were full. This register is clear on read.         */
     /* range: 24:24, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpsclmsg_throw;

     /* SMPSCLMsg: The SCL wrote a message to the SMP. This          */
     /* register is clear on read.                                   */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpsclmsg;

  } __ATTRIBUTE_PACKED__ scl_smp_messages_reg;

  /* DVS Credit counter Counter: Holds the DVS counter result.            */
  /* Configuration register 0x16a.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4270 */

     /* Counts issued credits that match the filter.  */
     /* This register is clear on read.                */
     /* issued at the port. This register is clear on read.          */
     /* range: 30:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD dvscreditcnt;

     /* : Count finished. This register is clear on read.            */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvscreditcntovf;

  } __ATTRIBUTE_PACKED__ dvs_credit_counter_reg;

  /* DVS Flow Control Counter: Count FC events per port             */
  /* Configuration register 0x16b.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4272 */

     /* : Counts the number of clocks that flow control was          */
     /* issued at the port. This register is clear on read.          */
     /* range: 30:0, access type: AC, default value: 0x0             */
     SOC_PETRA_REG_FIELD dvsfccnt;

     /* : Count finished. This register is clear on read.            */
     /* range: 31:31, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvsfccnt_fin;

  } __ATTRIBUTE_PACKED__ dvs_flow_control_counter_reg;


  /* DVS Link Status: Holds the number of links/RCI level           */
  /* that the scheduler sees.                                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4273 */

     /* : The number of links the DVS sees during connection         */
     /* range: 5:0, access type: R, default value: 0x0               */
     SOC_PETRA_REG_FIELD dvslink_cnt;

     /* : Current RCI level                                          */
     /* range: 10:8, access type: R, default value: 0x0              */
     SOC_PETRA_REG_FIELD dvsrci_level;

     /* : The max RCI level since last read (water mark). This       */
     /* register is clear on read.                                   */
     /* range: 14:12, access type: AC, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvsmax_rci_level;

  } __ATTRIBUTE_PACKED__ dvs_link_status_reg;


  /* Scheduler Configuration Register : Main configurations         */
  /* of the scheduler.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4301 */

     /* SubFlowEnable: Enables mapping one flow/queue (F) - to       */
     /* two sub-flows. If set and the respective bit in the          */
     /* Flow-Sub-Flow-Mapping-Table is also set, then even flow      */
     /* F is mapped to flows EVEN(F) and EVEN(F)+1.                  */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sub_flow_enable;

     /* SMPDisableFabric: If this bit is set, then the SMP stops     */
     /* processing messages coming from the fabric.                  */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpdisable_fabric;

     /* DiscardCredits: If this bit is set, the CML discards all     */
     /* credits.                                                     */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD discard_credits;

     /* VirtualFlow Enable: If this bit is set the scheduler         */
     /* treats flows that have queue 0 assigned in the FFQ as        */
     /* virtual flows and does not send them to the fabric. See      */
     /* Flow to FIP Mapping, Flow to Queue Mapping and Flow Slow     */
     /* Enable Mode.                                                 */
     /* range: 31:31, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD virtual_flow_enable;

  } __ATTRIBUTE_PACKED__ scheduler_configuration_reg;


  /* Shaper Configuration Register 1.: Main configurations of       */
  /* the shaper                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4302 */

     /* ShaperSlowRate1: The rate the shaper gives to flows in       */
     /* the Slow state. This value is interpreted like               */
     /* \{PeakRateExp, PeakRateMan\} in the SHDS table. [See the     */
     /* description and table in Shaper Descriptor Memory Static     */
     /* (SHDS)]. The shaper chooses between this value and the       */
     /* ShaperSlowRate2 if the flow is slow_enabled (see FFQ),       */
     /* based on the SlowRate2SelEven setting in the SHDS. If        */
     /* SlowRate2SelEven is set, the slow rate used for the flow     */
     /* is SlowRate2.                                                */
     /* range: 17:8, access type: RW, default value: 0x083 ~400Mbps  */
     SOC_PETRA_REG_FIELD shaper_slow_rate1;

     /* ShaperSlowRate2: See above description for                   */
     /* ShaperSlowRate1.                                             */
     /* range: 29:20, access type: RW, default value: 0x41 ~266Mbps  */
     SOC_PETRA_REG_FIELD shaper_slow_rate2;

  } __ATTRIBUTE_PACKED__ shaper_configuration_1_reg;


  /* Credit Counter Configuration Register 1: Registers 0x104       */
  /* and 0x105 configure the credit counter. The counter            */
  /* result is written to address 0x060. This register is           */
  /* only Relevant when FilterByFlow in 0x105 is set.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4304 */

     /* FilterFlow: Which flow value to match.                       */
     /* range: 15:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD filter_flow;

     /* FilterFlowMask: Mask of FilterFlow. If set the               */
     /* corresponding bit in FilterFlow must match the flow          */
     /* credit. Otherwise the corresponding bit in FilterFlow is     */
     /* Don`t care.                                                  */
     /* range: 31:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD filter_flow_mask;

  } __ATTRIBUTE_PACKED__ credit_counter_configuration_1_reg;


  /* Credit Counter Configuration Register 2: Registers 0x104       */
  /* and 0x105 configure the credit counter. The counter            */
  /* result is written to address 0x060. This register is           */
  /* only Relevant when FilterByFlow in 0x105 is set.               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4305 */

     /* FilterDestFap: Which ID to match (flow or sub flow).         */
     /* range: 10:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD filter_dest_fap;

     /* FilterByDestFap: When set, only credits to the destined      */
     /* fap are counted.                                             */
     /* range: 16:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD filter_by_dest_fap;

     /* FilterByFlow: When set, only credits to the programmed       */
     /* flow id (or sub flow id) are counted. Programmed flow id     */
     /* is set in register 0x104.                                    */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD filter_by_flow;

     /* FilterBySubFlow: When 0, matches flow ID. When set,          */
     /* matches sub flow ID (if FilterByFlow is set).                */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD filter_by_sub_flow;

     SOC_PETRA_REG_FIELD cnt_by_gtimer;

  } __ATTRIBUTE_PACKED__ credit_counter_configuration_2_reg;


  /* Credit Scheduler Counter in the CML Configuration: The         */
  /* counter counts credits that are sent from the CML to the       */
  /* STL. Counter result in 0x061                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4306 */

     /* : Which scheduler to match                                   */
     /* range: 13:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD filter_sch;

     /* : Mask of FilterSch                                          */
     /* range: 29:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD filter_sch_mask;

  } __ATTRIBUTE_PACKED__ credit_scheduler_counter_in_the_cml_configuration_reg;


  /* SMP Message Counter and Status Configuration: The              */
  /* message counter counts status message processed by the         */
  /* SMP. Counter result 0x066.   If SMPKeepBadMsg is set then       */
  /* registers 0x064 and 0x065 will hold the last bad               */
  /* message. If CntByTimer is set then registers 0x078 and          */
  /* 0x079 will hold the overall time the flow SMPCntFlow was       */
  /* in Normal/Slow state.                                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4307 */

     /* SMPCntType: Type of Message to count 0 - Fabric off 1 -      */
     /* Fabric slow 2 - Fabric fast 3 - Fabric no change 4 -         */
     /* Fabric Off with credit 7 - Fabric No Change with credit      */
     /* range: 3:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpcnt_type;

     /* SMPFilterByType: Count according to SMPCntType               */
     /* range: 4:4, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD smpfilter_by_type;

     /* SMPCntFlow/Port: Count messages received for this flow/      */
     /* port                                                         */
     /* range: 23:8, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD smpcnt_flow_port;

     /* SMPFilterByFlow/Port: Count only status messages             */
     /* concerning SMPCntFlow/Port: 0 - Do not filter by             */
     /* SMPCntFlow/Port 1 - Filter messages to FLOW                  */
     /* SMPCntFlow/Port 2 - Count all returned credits to SMP 3      */
     /* - Filter only returned credit to PORT SMPCntFlow/Port        */
     /* range: 25:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD smpfilter_by_flow_port;

  } __ATTRIBUTE_PACKED__ smp_message_counter_and_status_configuration_reg;

  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x4308 */

    SOC_PETRA_REG_FIELD gtimer_cnt;

    SOC_PETRA_REG_FIELD gtimer_clr_cnt;

  } __ATTRIBUTE_PACKED__ global_timer_configuration_reg;

  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x4309 */

    SOC_PETRA_REG_FIELD gtimer_act;

  } __ATTRIBUTE_PACKED__ global_timer_activation_reg;


  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430a */

     SOC_PETRA_REG_FIELD scl_cr_cnt_by_flow;

     SOC_PETRA_REG_FIELD scl_cr_cnt_flow;

  } __ATTRIBUTE_PACKED__ credit_cnt_cfg_agg_reg;

  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430b */

     /* range: 2:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dlm_ena;

     /* range: 13:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD dlm_bw;

  } __ATTRIBUTE_PACKED__ dlm_reg;


  /* Switch CIR EIR in dual shapers: This register defines in       */
  /* dual shapers the Class scheduler is the CIR or the EIR         */
  /* scheduler.                                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430c */

     /* SwitchCIREIR: By default (SwitchCIREIR[i] == 0) the          */
     /* FQ/HR is assigned as the CIR and the CL is assigned as       */
     /* the EIR when dual shaper is active. If SwitchCIREIR[i]       */
     /* is set then CL 256i-256i+255 with corresponding FQ 256i      */
     /* - 256i+255 or if bit 31 is set then HR 0-255 are             */
     /* switched and then the CL acts as CIR and the FQ/HR as        */
     /* EIR                                                          */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD switch_cireir;

  } __ATTRIBUTE_PACKED__ switch_cir_eir_in_dual_shapers_reg;


  /* FSF Composite Configuration: This register defines             */
  /* whether flows are comprised off odd and even sub-flows         */
  /* or only from odd or even flows.                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430d */

     /* FSFCompOddEven: Each bit i, specifies how sub-flows          */
     /* between 24k+ik and 24k+ik+1k-1 are assigned to flows. If     */
     /* FSFCompOddEven[i] == 1, the even flow is composited from     */
     /* even or odd subflows. If FSFCompOddEven[i] == 0, then        */
     /* each four sub flows are assigned to two adjacent flows.      */
     /* Flow x is composited of sub flow x and sub flow x+2.         */
     /* range: 31:0, access type: RW, default value: 0xffffffff      */
     SOC_PETRA_REG_FIELD fsfcomp_odd_even;

  } __ATTRIBUTE_PACKED__ fsf_composite_configuration_reg;


  /* Select flow to queue mapping: This register defines if         */
  /* flows are mapped to queues in interdigitated mode. In          */
  /* this mode flows 0 and 1 of each quartet are used for           */
  /* scheduler elements and not mapped to queues. Hence, the        */
  /* scheduler maps only flows 2,3 or 2 only (in case of            */
  /* composite) to the queues.                                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430e */

     /* InterDig: Bit i relates to flows 24k+1k*i                    */
     /* -24k+1k*i+1k-1. If InterDig = 0 and SubFlowMode = 0 then     */
     /* Q=\{BaseQueueNum, flow[1:0]\} If InterDig = 0 and            */
     /* SubFlowMode = 1 then Q=\{BaseQueueNum, flow[2:1]\} If        */
     /* InterDig = 1 and SubFlowMode = 0 then Q=\{BaseQueueNum,      */
     /* flow[2], flow[0]\} If InterDig = 1 and SubFlowMode = 1       */
     /* then Q=\{BaseQueueNum, flow[3:2]\}                           */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD inter_dig;

  } __ATTRIBUTE_PACKED__ select_flow_to_queue_mapping_reg;


  /* System Red Configuration: This register configures the         */
  /* system red mechanism in the scheduler                          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x430f */

     /* AgingTimerCfg : Every AgingTimerCfgx1296 ns (at 4nanosec     */
     /* clk), the aging mechanism accesses the queue size saved      */
     /* for a port. If a message is received with an updated         */
     /* queue size since the last time the aging mechanism           */
     /* accessed the port, this mechanism continues on to the        */
     /* next port. Otherwise, it changes the queue size              */
     /* according to ResetXpiredQSZ. If ResetXpiredQSZ is set,       */
     /* the mechanism resets the queue size. Otherwise it            */
     /* decrements it by one. Note: If AgingTimerCfg is set to 0     */
     /* or 1, then the aging mechanism does not decrement the        */
     /* queue size values.                                           */
     /* range: 20:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD aging_timer_cfg;

     /* ResetXpiredQSZ : See description of AgingTimerCfg            */
     /* range: 24:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD reset_xpired_qsz;

     /* AgingOnlyDecPQS: if this bit is set then only aging          */
     /* events decrements the relevant PQS entry, otherwise          */
     /* Aging and flow status messages can decrement it.             */
     /* range: 25:25, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD aging_only_dec_pqs;

     /* EnableSysRed : If this bit is set, then the system red       */
     /* mechanism is active in the scheduler; Otherwise, it is       */
     /* disabled.                                                    */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD enable_sys_red;

  } __ATTRIBUTE_PACKED__ system_red_configuration_reg;


  /* HRPort En Register 1: This register enables the root           */
  /* ports.                                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4310 */

     /* HRPortEn31_0: Enables root port for HR numbers 31 to 0.      */
     /* (Schedulers 16159:16128; flows indexes 56445:56321 in        */
     /* interval of 4, e.g. \{56445, 56441, 56437, ...,              */
     /* 56321\}).                                                    */
     /* HRPortEn63_32: Enables root port for HR numbers 63 to        */
     /* 32. (Schedulers 16191:16160; flows indexes 56573:56449       */
     /* in interval of 4, e.g. \{56573, 56569, 56565, ...,           */
     /* 56449\}).                                                    */
     /* HRPortEn81_64: Enables root port for HR numbers 81 to        */
     /* 64. (Schedulers 16209:16192; flows indexes 56642:56574       */
     /* in interval of 4.                                            */
     /* range: 31:0, access type: RW, default value: 0xffff          */
     SOC_PETRA_REG_FIELD hrport_en;

  } __ATTRIBUTE_PACKED__ hrport_en_reg[SOC_PETRA_HRPORT_EN_NOF_REGS];


  /* HR Flow Control Mask 0 1 : This register sets which            */
  /* priorities are affecte by high and low port flow               */
  /* control. Which mask to use per HR is configured in the         */
  /* SHC memory.                                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4318 */

     /* HRFCMask0: There are 5 valid masks: 1- 16'h1 (masks SP1)     */
     /* 2- 16'h3 (masks SP1 and SP2) 3- 16'h7 (masks SP1, SP2        */
     /* and SP3) 4- 16'h7fff (masks all priorities besides BE)       */
     /* 5- 16'h1ff - only for Enhanced HR or Dual HR (for Dual       */
     /* it masks SP1, SP2, SP3 and WFQ1 and for Enhanced it          */
     /* masks SP1-SP9)                                               */
     /* range: 15:0, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD hrfcmask0;

     /* HRFCMask1: See above                                         */
     /* range: 31:16, access type: RW, default value: 0x3            */
     SOC_PETRA_REG_FIELD hrfcmask1;

  } __ATTRIBUTE_PACKED__ hr_flow_control_mask_0_1_reg;


  /* HR Flow Control Mask 2 3 : This register sets which FLLs       */
  /* are affecte dy high and low port flow control. Which           */
  /* mask to use per HR is configured in the SHC memory             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4319 */

     /* HRFCMask2: See above                                         */
     /* range: 15:0, access type: RW, default value: 0x7             */
     SOC_PETRA_REG_FIELD hrfcmask2;

     /* HRFCMask3: See above                                         */
     /* range: 31:16, access type: RW, default value: 0x7fff         */
     SOC_PETRA_REG_FIELD hrfcmask3;

  } __ATTRIBUTE_PACKED__ hr_flow_control_mask_2_3_reg;


  /* Device Scheduler (DVS) Config0: This register forces a         */
  /* pause for each of the 32 NIF interfaces (one bit per           */
  /* NIF). If set then the corresponding Nif is paused.             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4320 */

     /* NIFForcePause: Stops NIFxx credits-one bit per NIF           */
     /* (xx=[31:0])                                                  */
     /* range: 31:0, access type: RW, default value: 0xffffffff      */
     SOC_PETRA_REG_FIELD nifforce_pause;

  } __ATTRIBUTE_PACKED__ dvs_config0_reg;


  /* Device Scheduler (DVS) Config1: The register forces a          */
  /* pause for CPU, RCY, ERP, OLP and Devices Pause .               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4321 */

     /* CPUForcePause: Stops CPU NIF credits                         */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD cpuforce_pause;

     /* RCYForcePause : Stops RCY NIF credits                        */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rcyforce_pause;

     /* ERPForcePause : Stops ERP NIF credits                        */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD erpforce_pause;

     /* OLPForcePause : Stops OLP NIF credits                        */
     /* range: 3:3, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD olpforce_pause;

     /* ForcePause: Stops the DVS credits                            */
     /* range: 4:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD force_pause;

  } __ATTRIBUTE_PACKED__ dvs_config1_reg;


  /* Device Scheduler (DVS) Weight Config0-3: This regsiter         */
  /* configures the WFQ weight.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4322 */

     /* WFQWeightXX: Configures the value for weight0 between        */
     /* [1-1023]. Value 0 disables the weight. (1 is the highest     */
     /* weight and 1023 is the lowest.)                              */
     /* range: 9:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD wfqweight_xx;

     /* WFQWeightXX+1: Configures the value for weight1 between      */
     /* [1-1023]. Value 0 disables the weight. (1 is the highest     */
     /* weight and 1023 is the lowest.)                              */
     /* range: 25:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD wfqweight_xx_plus_1;

  } __ATTRIBUTE_PACKED__ dvs_weight_config_reg[SOC_PETRA_NOF_DVS_WEIGHT_CONFIG_REGS];


  /* RCI Params: RCI configuration register0, if enabled then       */
  /* when generating credits the DVS takes into consideration       */
  /* the RCI level otherwise the DVS generates credits as if        */
  /* the RCI level is 0.                                            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4326 */

     /* RCIEna: Enable RCI bucket when RCI events received from      */
     /* fabric.                                                      */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD rciena;

     /* FapRCIEna: Enable RCI bucket according to the FAP RCI        */
     /* indicators.                                                  */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fap_rciena;

     /* RCIIncVal: RCI bucket increments by this value when an       */
     /* RCI bit is received.                                         */
     /* range: 10:4, access type: RW, default value: 0x10            */
     SOC_PETRA_REG_FIELD rciinc_val;

  } __ATTRIBUTE_PACKED__ rci_params_reg;


  /* RCI Decrement Values: RCI configuration register1, The         */
  /* RCIDecrement values determine the transition between the       */
  /* different RCI levels                                           */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4327 */

     /* RCIDecrement0: RCI decrements by (value*2 + 1) every I       */
     /* cell.                                                        */
     /* range: 3:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rcidecrement0;

     /* RCIDecrement1: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 7:4, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD rcidecrement1;

     /* RCIDecrement2: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 11:8, access type: RW, default value: 0x1             */
     SOC_PETRA_REG_FIELD rcidecrement2;

     /* RCIDecrement3: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 15:12, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD rcidecrement3;

     /* RCIDecrement4: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 19:16, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD rcidecrement4;

     /* RCIDecrement5: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 23:20, access type: RW, default value: 0x2            */
     SOC_PETRA_REG_FIELD rcidecrement5;

     /* RCIDecrement6: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 27:24, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD rcidecrement6;

     /* RCIDecrement7: RCI decrements by (value*2 + 1) every I       */
     /* cell                                                         */
     /* range: 31:28, access type: RW, default value: 0x4            */
     SOC_PETRA_REG_FIELD rcidecrement7;

  } __ATTRIBUTE_PACKED__ rci_decrement_values_reg;


  /* NIF[0-3],[16-19] CAL Config (Ch NIF): ChNIF                    */
  /* configuration register0: Configures the length of the          */
  /* Active and standby calendars, and the weight of ChNIF.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4330 */

     /* CalALen/CalBLen: The length of the primary calendar of ChNIFxx =     */
     /* CAL_A_Len + 1. If CAL_A_Len is 0, then the length of the     */
     /* calendar is 1.                                               */
     /* range: 9:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cal_len[SOC_PETRA_CH_NIF_CAL_LEN_NOF_FLDS];

     /* ChNIFxxWeight: Selects one of the eight configured           */
     /* weights.                                                     */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ch_nifxx_weight;

     /* DVSCalendarSelChNIFxx: Selects one of the eight              */
     /* configured weights.                                          */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvscalendar_sel_ch_nifxx;

  } __ATTRIBUTE_PACKED__ ch_nif_cal_config_reg[SOC_PETRA_NOF_CH_NIF_CAL_REGS];


  /* NIF[0-3],[16-19] Rates (Ch NIF): ChNIF configuration           */
  /* register: configures the rate of all of the OFPs related       */
  /* to the ChNIF, and the ChNIF shaper rate.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4331 */

     /* ChNIFxxSumOfPorts: This value defines the calendar           */
     /* traversal rate. Every ChNIFxxSumOfPorts/64 the next          */
     /* scheduler is visited and may be awarded a credit.            */
     /* ChNIFxxSumOfPorts and the number of the slots it             */
     /* occupies determines the number of credits given to the       */
     /* port. If ChNIFxxSumOfPorts = 0 then the ChNIFxx ports        */
     /* will not receive credits. ChNIFxxSumOfPorts cannot be        */
     /* lower then 64.                                               */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD ch_nifxx_sum_of_ports;

     /* ChNIFxxMaxCrRate: This value defines the maximal credit      */
     /* rate given to the ports on ChNIFxx (ChNIF shaper rate),      */
     /* that means that ChNIFxx will be awarded a credit every       */
     /* ChNIFxxMaxCrRate clocks. If ChNIF0MaxCrRate = 0 then no      */
     /* credits will given to the ChNIF.                             */
     /* range: 31:18, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ch_nifxx_max_cr_rate;

  } __ATTRIBUTE_PACKED__ ch_nif_reg[SOC_PETRA_NOF_CH_NIF_RATE_REGS];


  /* NIF[4-15], [20-31] Config (Port NIF): OnePortNif               */
  /* configuration register: Configures the shaper rate of          */
  /* the PortNif, its weight, and the related Port.                 */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4344 */

     /* PortNIFxxMaxCrRate: This value is the Port NIF maximum       */
     /* rate. Every PortNIF4MaxCrRate/64, the NIF can be awarded     */
     /* a credit. If PortNIF4MaxCrRate = 0, then PortNIF port        */
     /* will not receive credits. PortNIFMaxCrRate cannot be         */
     /* lower than 64.                                               */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_nifxx_max_cr_rate;

     /* NIFxxPort_id: The Port ID PortNIF mapped to.                 */
     /* range: 26:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD nifxx_port_id;

     /* PortNIFxxWeight: Selects one of the eight configured         */
     /* weights. (Weights are defined in registers 0x122-0x125)      */
     /* range: 30:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD port_nifxx_weight;

  } __ATTRIBUTE_PACKED__ port_nif_reg[SOC_PETRA_NOF_1PORT_NIF_RATE_REGS];


  /* CPU CAL Configuration Register: CPU configuration              */
  /* register0: configures the length of the Active and             */
  /* standby calendars, and the weight of CPU.                      */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4360 */

     /* CalALen/CalBLen: The length of the primary calendar of CPU =         */
     /* CAL_A_Len + 1. If CAL_A_Len is 0, then the length of the     */
     /* calendar is 1.                                               */
     /* range: 9:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cal_len[SOC_PETRA_CH_NIF_CAL_LEN_NOF_FLDS];

     /* CPUWeight: Selects one of the eight configured weights.      */
     /* (Weights are defined in registers 0x122-0x125)               */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cpuweight;

     /* DVSCalendarSelCPU: The Active calendar for the CPU           */
     /* interface                                                    */
     /* range: 28:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvscalendar_sel_cpu;

  } __ATTRIBUTE_PACKED__ cpu_cal_configuration_reg;


  /* CPU Rates0: CPU configuration register1: configures the        */
  /* rate of all of the CPU port related to CPU interface.          */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4361 */

     /* CPUSumOfPorts: This value defines the calendar traversal     */
     /* rate. Every CPUSumOfPorts/64, the next scheduler is          */
     /* visited and may be awarded a credit. CPUSumOfPorts and       */
     /* the number of the slots it occupies determine the number     */
     /* of credits given to the port. If CPUSumOfPorts = 0, then     */
     /* the CPU ports will not receive credits. CPUSumOfPorts        */
     /* cannot be lower than 64.                                     */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpusum_of_ports;

  } __ATTRIBUTE_PACKED__ cpu_rates0_reg;


  /* CPU Rate1: CPU configuration register2: Configures the         */
  /* CPU interface shaper rate.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4362 */

     /* CPUMaxCrRate: CPU interface shaper rate. Defines the         */
     /* number of clocks between credits to the CPU port. If= 0,     */
     /* then no credits will given to the CPU.                       */
     /* range: 21:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD cpumax_cr_rate;

  } __ATTRIBUTE_PACKED__ cpu_rate1_reg;


  /* RCY CAL Configuration: Recycle Interface configuration         */
  /* register0: Configures the length of the Active and             */
  /* standby calendars, and the weight of RCY interface.            */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4364 */

     /* CalALen/CalBLen: The length of the primary calendar of RCY =         */
     /* CAL_A_Len + 1. If CAL_A_Len is 0, then the length of the     */
     /* calendar is 1.                                               */
     /* range: 9:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD cal_len[SOC_PETRA_CH_NIF_CAL_LEN_NOF_FLDS];

     /* RCYWeight: Selects one of the eight configured weights.      */
     /* (Weights are defined in registers 0x122-0x125)               */
     /* range: 26:24, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD rcyweight;

     /* DVSCalendarSelRCY: The Active calendar for the RCY           */
     /* interface.                                                   */
     /* range: 28:28, access type: R, default value: 0x0             */
     SOC_PETRA_REG_FIELD dvscalendar_sel_rcy;

  } __ATTRIBUTE_PACKED__ rcy_cal_configuration_reg;


  /* RCY Rate0: RCY configuration register1: Configures the         */
  /* rate of all of the RCY ports related to RCY interface.         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4365 */

     /* RCYSumOfPorts: This value defines the calendar traversal     */
     /* rate. Every RCYSumOfPorts/64, the next scheduler is          */
     /* visited and may be awarded a credit. RCYSumOfPorts and       */
     /* the number of the slots it occupies determine the number     */
     /* of credits given to the port. If RCYSumOfPorts = 0, then     */
     /* the RCY ports will not receive credits. RCYSumOfPorts        */
     /* cannot be lower than 64.                                     */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcysum_of_ports;

  } __ATTRIBUTE_PACKED__ rcy_rate0_reg;


  /* RCY Rate1: RCY configuration register2: Configures the         */
  /* RCY interface shaper rate.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4366 */

     /* RCYMaxCrRate: RCY interface shaper rate. Defines the         */
     /* number of clocks between credits to the RCY port. If= 0,     */
     /* then no credits will given to the RCY.                       */
     /* range: 21:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD rcymax_cr_rate;

  } __ATTRIBUTE_PACKED__ rcy_rate1_reg;


  /* ERP Config: Egress Replication Port configuration              */
  /* register: Configures the shaper rate of the ERP, its           */
  /* weight, and the related Port.                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4368 */

     /* ERPMaxCrRate: This value ERP maximum rate. Every             */
     /* ERPMaxCrRate/64, the NIF can be awarded a credit. If         */
     /* ERPMaxCrRate = 0, then ERP port will not receive             */
     /* credits. ERPMaxCrRate cannot be lower than 64.               */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD erpmax_cr_rate;

     /* ERPPort_id: Mapping ERP to outgoing FAP Port.                */
     /* range: 26:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD erpport_id;

     /* ERPWeight: Selects one of the eight configured weights.      */
     /* (Weights are defined in registers 0x122-0x125)               */
     /* range: 30:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD erpweight;

  } __ATTRIBUTE_PACKED__ erp_config_reg;


  /* OLP Config: Off Load Processor configuration register:         */
  /* Configures the shaper rate of the OLP, its weight, and         */
  /* the related Port.                                              */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4369 */

     /* OLPMaxCrRate: This value the OLP maximum rate. Every         */
     /* OLPMaxCrRate/64, the NIF can be awarded a credit. If         */
     /* OLPMaxCrRate = 0, then OLP port will not receive             */
     /* credits. OLPMaxCrRate cannot be lower than 64.               */
     /* range: 17:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD olpmax_cr_rate;

     /* OLPPort_id: Mapping OLP to outgoing FAP Port.                */
     /* range: 26:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD olpport_id;

     /* OLPWeight: Selects one of the eight configured weights.      */
     /* (Weights are defined in registers 0x122-0x125)               */
     /* range: 30:28, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD olpweight;

  } __ATTRIBUTE_PACKED__ olp_config_reg;


  /* DVS Credit Counter Configuration register: The DVS             */
  /* credit counter can be configured to count credits issued       */
  /* to Port/Interface.                                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x436a */

     /* DVSFilterPort: Which Port to count credits for.              */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD dvsfilter_port;

     /* DVSFilterNIF: Which NIF to count credits for.                */
     /* range: 17:12, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dvsfilter_nif;

     /* CntByPort: If this bit is set, then the counter counts       */
     /* credit by port DVSFilterPort                                 */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_by_port;

     /* CntByNIF: If this bit is set, then the counter counts        */
     /* credit by NIF DVSFilterNIF                                   */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_by_nif;

  } __ATTRIBUTE_PACKED__ dvs_credit_counter_configuration_reg;


  /* DVS FC and RCI Counters Configuration register: Counts         */
  /* FC and RCI events. Counter result 0x4272.                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x436b */

     /* : Which Port to count the FC events for.                     */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD fccnt_port;

     /* : If set then the counter will count high FC events to       */
     /* FCCntPort port                                               */
     /* range: 20:20, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_high_fc;

     /* : If set then the counter will count low FC events to        */
     /* FCCntPort port                                               */
     /* range: 21:21, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD cnt_low_fc;

  } __ATTRIBUTE_PACKED__ dvs_fc_and_rci_counters_configuration_reg;


  /* STL Group Config0: Configures the group of the scheduler       */
  /* port-the group should be the same as in the FGM memory         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4370 */

     /* Port0Group: The group of Port0-one of the three groups       */
     /* \{0,1,2\}                                                    */
     /* range: 1:0 , access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD port_group[SOC_PETRA_NOF_STL_GROUP_CONFIG_FLDS];
  } __ATTRIBUTE_PACKED__ stl_group_config_reg[SOC_PETRA_NOF_STL_GROUP_CONFIG_REGS];



  /* SCH_Fabric_Multicast_Port_Configuration_register:              */
  /* Multicast Ports configuration register. Maps each              */
  /* multicast class to the HR.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4371 */

    struct
    {
      /* Multicast GFMC Port ID one of 80 outgoing FAP ports.     */
      /* range: 6:0,   access type: RW, default value: 0x0        */
      /* range: 14:08, access type: RW, default value: 0x0        */
      /* range: 22:16, access type: RW, default value: 0x0        */
      /* range: 30:24, access type: RW, default value: 0x0        */
      SOC_PETRA_REG_FIELD port_id;

      /* If this bit is set, then the scheduler enables the IPS   */
      /* to generate credits for the Multicast Class0 port.       */
      /* range: 07:07, access type: RW, default value: 0x0        */
      /* range: 15:15, access type: RW, default value: 0x0        */
      /* range: 23:23, access type: RW, default value: 0x0        */
      /* range: 31:31, access type: RW, default value: 0x0        */
      SOC_PETRA_REG_FIELD enable;
    } __ATTRIBUTE_PACKED__ multicast_class[SOC_PETRA_NOF_MULTICAST_CLASSES];

  } __ATTRIBUTE_PACKED__ sch_fabric_multicast_port_configuration_reg;


  /* Ingress Shaping Port Configuration: Ingress shaping            */
  /* configuration register: Defines/enables the HR for             */
  /* ingress Shaping.                                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4377 */

     /* IngressShapingPortID: Ingress Shaping Port ID-one of 80      */
     /* outgoing FAP ports                                           */
     /* range: 6:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ingress_shaping_port_id;

     /* IngressShapingEnable: If set, then the scheduler enables     */
     /* the IPS to generate credits for the ingress shaping          */
     /* port.                                                        */
     /* range: 8:8, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD ingress_shaping_enable;

  } __ATTRIBUTE_PACKED__ ingress_shaping_port_configuration_reg;

  struct
  {
      SOC_PETRA_REG_ADDR  addr;  /* 0x437a */

      /* range: 7:0, access type: RW, default value: 0xff              */
      SOC_PETRA_REG_FIELD delay;

      /* range: 12:12, access type: RW, default value: 0x0              */
      SOC_PETRA_REG_FIELD enable;

  } __ATTRIBUTE_PACKED__ smp_internal_messages;

  /* Force High FC Register 0: This register forces flow            */
  /* control to a port scheduler.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4380 */

     /* ForceHighFC31_0: Forces flow control for root port           */
     /* numbers 31 to 0. Depending on ForceFCOveride this bit        */
     /* either exlusively set flow control on the respective         */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_high_fc31_0;

  } __ATTRIBUTE_PACKED__ force_high_fc_0_reg;


  /* Force High FC Register 1: This register forces flow            */
  /* control to a port scheduler.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4381 */

     /* ForceHighFC63_32: Forces flow control for root port          */
     /* numbers 63 to 32. Depending on ForceFCOveride this bit       */
     /* either exlusively set flow control on the respective         */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_high_fc63_32;

  } __ATTRIBUTE_PACKED__ force_high_fc_1_reg;


  /* Force High FC Register 2: This register forces flow            */
  /* control to a port scheduler.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4382 */

     /* ForceHighFC81_64: Forces flow control for root port          */
     /* numbers 80 to 64. Depending on ForceFCOveride this bit       */
     /* either exlusively set flow control on the respective         */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 16:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_high_fc81_64;

  } __ATTRIBUTE_PACKED__ force_high_fc_2_reg;


  /* Force Low FC Register 0: This register forces low flow         */
  /* control to a port scheduler.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4384 */

     /* ForceLowFC31_0: Forces low flow control for root port        */
     /* numbers 31 to 0. Depending on ForceLowFCOveride this bit     */
     /* either exlusively set flow control on the respective         */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_low_fc31_0;

  } __ATTRIBUTE_PACKED__ force_low_fc_0_reg;


  /* Force Low FC Register 1: This register forces low flow         */
  /* control to a port scheduler.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4385 */

     /* ForceLowFC63_32: Forces low flow control for root port       */
     /* numbers 63 to 32. Depending on ForceLowFCOveride this        */
     /* bit either exlusively set flow control on the respective     */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_low_fc63_32;

  } __ATTRIBUTE_PACKED__ force_low_fc_1_reg;


  /* Force Low FC Register 2: This register forces low flow         */
  /* control to a port scheduler.                                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4386 */

     /* ForceLowFC81_64: Forces low flow control for root port       */
     /* numbers 80 to 64. Depending on ForceLowFCOveride this        */
     /* bit either exlusively set flow control on the respective     */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 16:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_low_fc81_64;

  } __ATTRIBUTE_PACKED__ force_low_fc_2_reg;


  /* Force Aggr FC Register 0: This register forces flow            */
  /* control to an aggregate scheduler.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4388 */

     /* ForceAggrFC159_128: Forces flow control for HR aggregate     */
     /* numbers 159 to 128. Depending on ForceAggrFCOveride this     */
     /* bit either exlusively set flow control on the respective     */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_aggr_fc159_128;

  } __ATTRIBUTE_PACKED__ force_aggr_fc_0_reg;


  /* Force Aggr FC Register 1: This register forces flow            */
  /* control to an aggregate scheduler.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4389 */

     /* ForceAggrFC191_160: Forces flow control for HR aggregate     */
     /* numbers 191 to 160. Depending on ForceAggrFCOveride this     */
     /* bit either exlusively set flow control on the respective     */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_aggr_fc191_160;

  } __ATTRIBUTE_PACKED__ force_aggr_fc_1_reg;


  /* Force Aggr FC Register 2: This register forces flow            */
  /* control to an aggregate scheduler.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x438a */

     /* ForceAggrFC223_192: Forces flow control for HR aggregate     */
     /* numbers 223 to 192. Depending on ForceAggrFCOveride this     */
     /* bit either exlusively set flow control on the respective     */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_aggr_fc223_192;

  } __ATTRIBUTE_PACKED__ force_aggr_fc_2_reg;


  /* Force Aggr FC Register 3: This register forces flow            */
  /* control to an aggregate scheduler.                             */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x438b */

     /* ForceAggrFC255_224: Forces flow control for HR aggregate     */
     /* numbers 255 to 224. Depending on ForceAggrFCOveride this     */
     /* bit either exlusively set flow control on the respective     */
     /* port (can also force negate of the flow control) or when     */
     /* set puts the port in flow control regardless of its real     */
     /* state.                                                       */
     /* range: 31:0, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD force_aggr_fc255_224;

  } __ATTRIBUTE_PACKED__ force_aggr_fc_3_reg;


  /* Force FC Configuration Register: This register forces          */
  /* flow control to an aggregate scheduler.                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x438c */

     /* ForceHighFCOverride: If this bit is set, the high flow       */
     /* control value set by the CPU in registers 0x180 - 0x183      */
     /* is the only source of flow control. Otherwise, the bits      */
     /* in registers 0x180 - 0x183 are | with the regular source     */
     /* of flow control to the ports.                                */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_high_fcoverride;

     /* ForceLowFCOverride: If this bit is set, the high flow        */
     /* control value set by the CPU in registers 0x184 - 0x186      */
     /* is the only source of flow control. Otherwise, the bits      */
     /* in registers 0x184 - 0x186 are | with the regular source     */
     /* of flow control to the ports.                                */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_low_fcoverride;

     /* ForceAggrFCEn: If this bit flow control for aggregates       */
     /* 128-255 is enabled.                                          */
     /* range: 2:2, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_aggr_fcen;

     /* ForceAggrFCOverride: If this bit is set only the flow        */
     /* control value set by the CPU in registers 0x188 - 0x18b      */
     /* is the only source of aggr flow control. Otherwise, the      */
     /* bits in registers 0x188 - 0x18b are | with the regular       */
     /* source of aggregate flow control to the ports                */
     /* range: 3:3, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD force_aggr_fcoverride;

  } __ATTRIBUTE_PACKED__ force_fc_configuration_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_SCH_REGS;

/* Block definition: SERDES */
typedef struct
{
  uint32   nof_instances; /* 4 */
  SOC_PETRA_REG_ADDR addr;

  /* srd_LN_cfga: SerDes Lane  Configurations                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0000 */

     /* LN_TxEn: Tx Clock Enable. If set, normal functionality,      */
     /* otherwise Tx clock is powered down.                          */
     /* range: 0:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD ln_tx_en;

     /* LN_TxIdle: If set, overrides Tx data with 0.                 */
     /* range: 1:1, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD ln_tx_idle;

     /* LN_TxInv: If set, inverses polarity of high speed Tx         */
     /* data (PADs).                                                 */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD ln_tx_inv;

     /* RxNearestCommaAlign: If set, comma alignment will be         */
     /* done to the nearest character (rather than to the            */
     /* nearest 20b word received from serdes). This will insert     */
     /* smaller skew (up to 10UI).                                   */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD rx_nearest_comma_align;

     /* LN_TxRate: Lane Tx rate: [00] - full rate. [01] - half       */
     /* rate. [10] - quarter rate. [11] - eighth rate.               */
     /* range: 5:4, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD ln_tx_rate;

     /* LN_RxRate: Lane Rx rate: [00] - full rate. [01] - half       */
     /* rate. [10] - quarter rate. [11] - eighth rate.               */
     /* range: 7:6, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD ln_rx_rate;

     /* LN_RxEn: Rx Clock Enable. If set, normal functionality,      */
     /* otherwise Rx clock is powered down.                          */
     /* range: 8:8, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD ln_rx_en;

     /* LN_RxIdle: If set, overrides Rx data (LDOUT[19:0]) with      */
     /* 0.                                                           */
     /* range: 9:9, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD ln_rx_idle;

     /* LN_RxInv: If set, inverses polarity of high speed Rx         */
     /* data (PADs).                                                 */
     /* range: 10:10, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_rx_inv;

     /* LN_RxAlignEnReq: If set, comma re-alignment is only          */
     /* enabled if the Rx PCS FSM explicitly enabled it.             */
     /* Otherwise, comma re-alignment is always enabled. Set to      */
     /* 1 for use by NIF.                                            */
     /* range: 11:11, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD ln_rx_align_en_req;

     /* LN_RxCommaDetMaskLSB: If set, masks comma detection by       */
     /* previously detected commas that are exactly 10b (1           */
     /* character) shifted left. Set to 1 for XAUI modes.            */
     /* range: 12:12, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_rx_comma_det_mask_lsb;

     /* LN_RxCommaDetMaskMSB: If set, mask Comma Detection by        */
     /* previously detected commas that are exactly 10b (1           */
     /* character) shifted right. Set to 1 for XAUI modes.           */
     /* range: 13:13, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_rx_comma_det_mask_msb;

     /* LN_RxPcsSyncFsmInit: If set, will reset the Rx PCS           */
     /* Synchronization FSM.                                         */
     /* range: 14:14, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_rx_pcs_sync_fsm_init;

     /* LN_ShareCfg: If set, use LN0_cfga to configure this          */
     /* lane. If set for lane 0, will source the LN0_cfga from       */
     /* another SerDes macro: source srd0_LN0_cfga from              */
     /* srd1_LN0_cfga source srd1_LN0_cfga from srd0_LN0_cfga        */
     /* source srd2_LN0_cfga from srd1_LN2_cfga source               */
     /* srd3_LN0_cfga from srd2_LN2_cfga This will allow             */
     /* simultaneous configuration of all lanes in XAUI/SPAUI        */
     /* modes, and will reduce inter-lane skew.                      */
     /* range: 15:15, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_share_cfg;

     /* LN_IntEnRxDecodeErr: If set, enables interrupt on            */
     /* detection by Rx 8B/10B decoder of code group error by        */
     /* either decoder.                                              */
     /* range: 16:16, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_int_en_rx_decode_err;

     /* LN_IntEnRxDispErr: If set, enables interrupt on              */
     /* detection by Rx 8B/10B decoder of running disparity          */
     /* error by either decoder.                                     */
     /* range: 17:17, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_int_en_rx_disp_err;

     /* LN_IntEnRxCommaRealign: If set, enables interrupt on Rx      */
     /* comma realignment.                                           */
     /* range: 18:18, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_int_en_rx_comma_realign;

     /* LN_IntEnRxSigDetChange: If set, enable interrupt on Rx       */
     /* Signal Detect status change.                                 */
     /* range: 19:19, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD ln_int_en_rx_sig_det_change;

     /* LN_IntSelRxPcsSyncFsm: Reserved (DFT).                       */
     /* range: 23:20, access type: UNDEF, default value: 0xf         */
     SOC_PETRA_REG_FIELD ln_int_sel_rx_pcs_sync_fsm;

     /* EBIST_RxEn: If set, enables the External (Dune) Rx BIST.     */
     /* range: 24:24, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ebist_rx_en;

     /* EBIST_TxEn: If set, enables the External (Dune) Tx BIST.     */
     /* range: 25:25, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ebist_tx_en;

     /* EBIST_PrbsPolSel: If set, uses PRBS7 random sequence.        */
     /* Otherwise, uses PRBS23 random sequence for BIST.             */
     /* range: 26:26, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ebist_prbs_pol_sel;

     /* EBIST_TxConstDataEn: If set, SerDes will transmit            */
     /* constant data. The 20b data is taken from the                */
     /* LN_TxConstData register (shared by all lanes).               */
     /* range: 27:27, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ebist_tx_const_data_en;

     /* EBIST_CntMode: Select which events will be counted by        */
     /* the External BIST: [00] - External Bist Errors [01] -        */
     /* reserved [10] - Rx Disparity Errors [11] - Rx Code           */
     /* Errors                                                       */
     /* range: 29:28, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ebist_cnt_mode;

     /* ExtTxDataOvrdEn: If set, SerDes will transmit 20b data       */
     /* from external source (i.e. from PDMC module). Set to 1       */
     /* when enabling the Hyper G-Link.                              */
     /* range: 30:30, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ext_tx_data_ovrd_en;

     /* TxUseExtByteToggle: If set, lane will be synced to           */
     /* external byte polarity source (even / odd position) that     */
     /* is shared by all lanes in MACROCELL (taken from lane 0).     */
     /* This is used to reduce Tx skew between XAUI lanes when       */
     /* moving 10b data from logical lanes to the SRD 20b            */
     /* physical lanes. Set to <1> for XAUI 4-lane-SR/DR or          */
     /* 6-lane-DR modes, and to <0> for SGMII or XAUI 6L-SR          */
     /* modes. This configuration exist only in NIF SerDeses.        */
     /* range: 31:31, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD tx_use_ext_byte_toggle;

  } __ATTRIBUTE_PACKED__ srd_ln_cfga_reg[SOC_PETRA_SRD_NOF_PER_QRTT_REGS][SOC_PETRA_SRD_NOF_PER_LANE_REGS];


  /* srd_ln_stat: SerDes Lane 0 Indications                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0001 */

     /* LN_RxSigDet: Stabilized lane signal detect status            */
     /* (defined by LN_RxSigDetMode and LN_RxSigDetCnt).             */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_sig_det;

     /* LN_RxSigDetChange: If set, indicates that lane signal        */
     /* detect status has changed (one or more times). This          */
     /* register is clear on read.                                   */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_sig_det_change;

     /* CMU_TxTrimming: Reserved. Tx trim sequence in progress       */
     /* (TxLLK).                                                     */
     /* range: 2:2, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cmu_tx_trimming;

     /* CMU_PLL_Rst: Reserved. Internal PLL reset sequence in        */
     /* progress (TXPORST).                                          */
     /* range: 3:3, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cmu_pll_rst;

     /* LN_RxRst: Reserved. Rx reset/trim sequence in progress       */
     /* (RXPORST).                                                   */
     /* range: 4:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_rst;

     /* LN_RxSigLost: Reserved. Lane signal-loss indication          */
     /* (LOSRX).                                                     */
     /* range: 5:5, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_sig_lost;

     /* LN_RxFreqInvld: Reserved. Lane invalid recovered             */
     /* frequency (RXFRQINVLD).                                      */
     /* range: 6:6, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_freq_invld;

     /* LN_RxSyncStat: Reserved. If set, indicates that Rx PCS       */
     /* Sync FSM has achieved synchronization. (Used by NIF          */
     /* Only.)                                                       */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_sync_stat;

     /* LN_RxPcsSyncFsmInd: Reserved (DFT). This register is         */
     /* clear on read.                                               */
     /* range: 9:9, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_pcs_sync_fsm_ind;

     /* LN_RxCodeErr: If set, Rx 8B/10B decoder detected             */
     /* decoding error in some word. This register is clear on       */
     /* read.                                                        */
     /* range: 13:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_code_err;

     /* LN_RxDispErr: If set, Rx 8B/10B decoder detected running     */
     /* disparity error in some word. This register is clear on      */
     /* read.                                                        */
     /* range: 15:14, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_disp_err;

     /* LN_RxCommaAlignEn: Reserved (DFT).                           */
     /* range: 16:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_comma_align_en;

     /* LN_RxCommaRealign: Rx comma realignment occurred. This       */
     /* register is clear on read.                                   */
     /* range: 17:17, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_comma_realign;

     /* LN_RxCommaAlignment: Reserved.                               */
     /* range: 24:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_comma_alignment;

  } __ATTRIBUTE_PACKED__ srd_ln_stat_reg[SOC_PETRA_SRD_NOF_PER_QRTT_REGS][SOC_PETRA_SRD_NOF_PER_LANE_REGS];


  /* srd_ln_EBIST: SerDes Lane 0 EBIST Indications                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0002 */

     /* EBIST_ErrCnt: Indicates the number of External BIST          */
     /* errors in received data. This register is clear on read.     */
     /* range: 30:0, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ebist_err_cnt;

     /* EBIST_Sync: If set, indicates that external BIST PRBS is     */
     /* synchronized with incoming data. This register is clear      */
     /* on read.                                                     */
     /* range: 31:31, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ebist_sync;

  } __ATTRIBUTE_PACKED__ srd_ln_ebist_reg[SOC_PETRA_SRD_NOF_PER_QRTT_REGS][SOC_PETRA_SRD_NOF_PER_LANE_REGS];


  /* srd_cmu_cfga: SerDes CMU Configurations                       */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0010 */

     /* CMU_MacroPd: Macro power down (CMU and lanes).               */
     /* range: 0:0, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD cmu_macro_pd;

     /* CMU_MacroRst: Master (async) reset for CMU and lanes.        */
     /* Does not reset register content. Hold for 8 RefClk           */
     /* cycles.                                                      */
     /* range: 1:1, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD cmu_macro_rst;

     /* CMU_StartTrim: Start the internal trim sequence. Set to      */
     /* 1 only after all internal registers are configured.          */
     /* range: 2:2, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD cmu_start_trim;

     /* CMU_TrimSelf: Trim without using the internal P8051          */
     /* (IPU).                                                       */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD cmu_trim_self;

     /* CMU_PLLN: PLL divider ratio. May be overridden by REFDIV     */
     /* register. f(VCOOUT)=f(RefClk) * 10 * (1+PLLM) /              */
     /* (1+PLLN). PLLN+1=1~5. PLLM+1=1~4.                            */
     /* range: 5:4, access type: UNDEF, default value: 0x3           */
     SOC_PETRA_REG_FIELD cmu_plln;

     /* CMU_PLLM: PLL divider ratio. May be overridden by VCODIV     */
     /* register. f(VCOOUT)=f(RefClk) * 10 * (1+PLLM) /              */
     /* (1+PLLN). PLLN+1=1~5. PLLM+1=1~4.                            */
     /* range: 8:6, access type: UNDEF, default value: 0x4           */
     SOC_PETRA_REG_FIELD cmu_pllm;

     /* LN_20b_Mode: Select Tx double rate mode (20b/cycle).         */
     /* This bit must be set (1) for MAC SerDeses. For NIF, if       */
     /* set to 1, the Tx physcal lane (PL) is mapped into two        */
     /* logical lanes (LL). Each LL receives 10b that are muxed      */
     /* into the PL (i.e. 6.25 Gbps Double-Rate modes). When set     */
     /* to 0, the NIF drives 10b each cycle using a x2 Tx clock,     */
     /* accumulation of 20b is done by the SerDes Tx channel         */
     /* (i.e. 1.25 / 3.125 Gbps Single-Rate modes). NOTE: Rx is      */
     /* always 20b. LL demuxing is done in Rx BOM. This does not     */
     /* affect the SerDes bitrate itself (LN_TxRate and              */
     /* LN_RxRate). It only affects the interface to the             */
     /* NIF/MAC. Same configuration is used for all lanes in         */
     /* macrocell.                                                   */
     /* range: 9:9, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD ln_20b_mode;

     /* LN_TxSyncFifoEn: If set, Tx data from all lanes will be      */
     /* synced to XCK[0] (from lane 0) before driven to SerDes.      */
     /* Otherwise, synchronization is done per lane, using the       */
     /* internal TxFIFO of the serdes (up to 20UI might be           */
     /* caused by this). Set to <1> for XAUI where reduced Tx        */
     /* skew is desired. Set to <0> for SGMII or 6-lanes XAUI,       */
     /* and for MSW (Fabric) interfaces.                             */
     /* range: 10:10, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_tx_sync_fifo_en;

     /* LN_TxSyncFifoRstn: If set to 0, Tx synchronizer will be      */
     /* reset. This register must be set to 1 after SRD Tx clock     */
     /* of lane 0 becomes valid. This register is relevant only      */
     /* for NIF SRDs.                                                */
     /* range: 11:11, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_tx_sync_fifo_rstn;

     /* LN_TxobPd: Lane power down.                                  */
     /* range: 15:12, access type: UNDEF, default value: 0xf         */
     SOC_PETRA_REG_FIELD ln_txob_pd;

     /* LN_RxSigDetMode: Select which indications to use for         */
     /* SigDet: [0] - SerDes SigDet indication (LOSRX). [1] -        */
     /* SerDes Rx reset in progress (RXPORST). [2] - SerDes Rx       */
     /* recovered clock not locked (RXFRQINVLD). [3] - SerDes Tx     */
     /* reset in progress (TXPORST). [4] - SerDes PLL reset in       */
     /* progress (TXLLK). [5] - Override (to 0). Select all 0 to     */
     /* always indicate SigDet.                                      */
     /* range: 21:16, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD ln_rx_sig_det_mode;

     /* LN_RxSigDetCnt: How many SigDet stable cycles are            */
     /* required.                                                    */
     /* range: 31:24, access type: UNDEF, default value: 0xa         */
     SOC_PETRA_REG_FIELD ln_rx_sig_det_cnt;

  } __ATTRIBUTE_PACKED__ srd_cmu_cfga_reg[SOC_PETRA_SRD_NOF_PER_QRTT_REGS];


  /* srd_cmu_cfgb: SerDes CMU Configurations (Con't)               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0011 */

     /* LN_TxConstData: Data used for transmitting a constant        */
     /* 20b pattern (enabled by EBIST_TxConstDataEn). Data is        */
     /* shared by all lanes.                                         */
     /* range: 19:0, access type: UNDEF, default value: 20'h00000    */
     SOC_PETRA_REG_FIELD ln_tx_const_data;

     /* CMU_MSEL_IN: Reserved. Set 20b mode. Always set to 1.        */
     /* range: 23:23, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD cmu_msel_in;

     /* LN_PcompEn: Reserved. (same for all lanes). Write as 0.      */
     /* range: 24:24, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_pcomp_en;

     /* LN_SetCtl: Reserved. (Same for all lanes). Write as 0.       */
     /* range: 27:25, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_set_ctl;

     /* LN_TxRdetEn: Reserved. (Same for all lanes). Write as 0.     */
     /* range: 28:28, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_tx_rdet_en;

     /* LN_TxBeaconEn: Reserved. (Same for all lanes). Write as      */
     /* 0.                                                           */
     /* range: 29:29, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_tx_beacon_en;

     /* LN_MacPhyPD: Reserved. (Same for all lanes). Write as 0.     */
     /* range: 31:30, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ln_mac_phy_pd;

  } __ATTRIBUTE_PACKED__ srd_cmu_cfgb_reg[SOC_PETRA_SRD_NOF_PER_QRTT_REGS];


  /* srd_cmu_stat: SerDes SMU Status                               */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0012 */

     /* CMU_TxTrimming: Tx trim sequence in progress (TxLLK).        */
     /* range: 0:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cmu_tx_trimming;

     /* CMU_PLL_Rst: Internal PLL reset sequence in progress         */
     /* (TXPORST).                                                   */
     /* range: 1:1, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD cmu_pll_rst;

     /* LN_RxRst: Lane Rx reset/trim sequence in progress            */
     /* (RXPORST).                                                   */
     /* range: 7:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD ln_rx_rst;

     /* LN_RxSigDet: Stabilized lane signal detect status            */
     /* (defined by LN_RxSigDetMode and LN_RxSigDetCnt).             */
     /* range: 11:8, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD ln_rx_sig_det;

     /* LN_RxSyncStat: Synchronization status of each lane           */
     /* (output of the Rx PCS Sync FSM). Used by NIF Only.           */
     /* range: 15:12, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_rx_sync_stat;

     /* LN_IntInd: If set, each bit indicates that corresponding     */
     /* SerDes Lane created interrupt. (For further information,     */
     /* see in ln_stat register.)                                    */
     /* range: 19:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_int_ind;

     /* CMU_SCIF_DataOut: Reserved. SCIF Data out.                   */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cmu_scif_data_out;

     /* CMU_SCIF_IntReq: Reserved. SCIF Int Req (from                */
     /* macrocell).                                                  */
     /* range: 21:21, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD cmu_scif_int_req;

     /* LN_PCG2P: Reserved. Polling Compliance indication.           */
     /* range: 27:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_pcg2_p;

     /* LN_PCG2N: Reserved. Polling Compliance indication.           */
     /* range: 31:28, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD ln_pcg2_n;

  } __ATTRIBUTE_PACKED__ srd_cmu_stat_reg[SOC_PETRA_SRD_NOF_PER_QRTT_REGS];

  /* Srd Ipu Cfg: Configuration Register for IPU (internal          */
  /* 8051), EPB bus, and SCIF access. Shared by all SerDeses        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0078 */

     /* IramRst: Master reset for the 8051 core and the SFR          */
     /* registers.                                                   */
     /* range: 0:0, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD iram_rst;

     /* Rst8051: Reset for the 8051 core (does not affect            */
     /* register contents). Should be set for 8 cycles or more.      */
     /* range: 1:1, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD rst8051;

     /* EPB_Rst: Resets all EPB interface signals.                   */
     /* range: 2:2, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD epb_rst;

     /* ExtScifRst: Reset for shift register written by SCIFASEL     */
     /* pin. Resets this shift register to broadcast value,          */
     /* where the SCIF_EN_IPU and SCIF_EN_CMU bits can be used       */
     /* to control the SCIF.                                         */
     /* range: 3:3, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD ext_scif_rst;

     /* ClkSel8051: Divide the CLK8051 by factor N: [00] - N=4       */
     /* [01] - N=2 [10] - N=1 [11] - N=8                             */
     /* range: 5:4, access type: UNDEF, default value: 0x2           */
     SOC_PETRA_REG_FIELD clk_sel8051;

     /* PD8051: Power down for the 8051 (does not affect             */
     /* register contents).                                          */
     /* range: 6:6, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD pd8051;

     /* ClkPd8051: Power down for the 8051 clock (freeze             */
     /* operation).                                                  */
     /* range: 7:7, access type: UNDEF, default value: 0x1           */
     SOC_PETRA_REG_FIELD clk_pd8051;

     /* ChanID: Reserved (write as 3'b110).                          */
     /* range: 10:8, access type: UNDEF, default value: 0x6          */
     SOC_PETRA_REG_FIELD chan_id;

     /* INT8051: Reserved (write as 0). Interrupt request for        */
     /* 8051. IPU enters ISR until de-assertion of this bit.         */
     /* range: 11:11, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD int8051;

     /* EPB_IntTimeoutEn: Reserved (write as 1).                     */
     /* range: 12:12, access type: UNDEF, default value: 0x1         */
     SOC_PETRA_REG_FIELD epb_int_timeout_en;

     /* SCIF_IpuEnOnCmuSel: Reserved (write as 0).                   */
     /* range: 13:13, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD scif_ipu_en_on_cmu_sel;

     /* IPU_ParityEn: If set, IPU (8051) will check parity when      */
     /* accessing memory.                                            */
     /* range: 16:16, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ipu_parity_en;

     /* IPU_ParityForceErr: If set, forces IPU (8051) to insert      */
     /* parity error. Testing only.                                  */
     /* range: 17:17, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ipu_parity_force_err;

     /* IPU_ParityErrIntEn: If set, interrupt will be created        */
     /* when IPU (8051) encounters parity error.                     */
     /* range: 18:18, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ipu_parity_err_int_en;

     /* IPU_INTREQ_IntEn: If set, interrupt will be created when     */
     /* IPU (8051) receives an interrupt request.                    */
     /* range: 19:19, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ipu_intreq_int_en;

     /* IPU_INTACK_IntEn: If set, interrupt will be created when     */
     /* IPU (8051) acknowledges interrupt request and enters         */
     /* ISR.                                                         */
     /* range: 20:20, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ipu_intack_int_en;

     /* IPU_8051PromLoaded: Reserved (scratch pad). Should be        */
     /* set by software after 8051 8k PROM was uploaded, and         */
     /* will remain set until chip is reset. User application        */
     /* may use this bit as indication of the PROM status.           */
     /* range: 21:21, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD ipu_8051_prom_loaded;

  } __ATTRIBUTE_PACKED__ srd_ipu_cfg_reg;


  /* Srd Epb Op: EPB OP dispatch register. Writing to this          */
  /* register causes a write or read operation to be                */
  /* dispatched on the EPB bus.                                     */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x0079 */

     /* Addr_Element: EPB element address inside selected            */
     /* channel.                                                     */
     /* range: 3:0, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD addr_element;

     /* Addr_Channel: EPB channel address select: [3-0] = Rx/Tx      */
     /* channels. [5-4] = Reserved. [6] = Reserved (8051 block).     */
     /* [7] = CMU block.                                             */
     /* range: 6:4, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD addr_channel;

     /* Addr_Global: Select all Rx/Tx channels.                      */
     /* range: 8:8, access type: UNDEF, default value: 0x0           */
     SOC_PETRA_REG_FIELD addr_global;

     /* Addr_Reg: EPB register address inside selected element.      */
     /* range: 14:9, access type: UNDEF, default value: 0x0          */
     SOC_PETRA_REG_FIELD addr_reg;

     /* Addr_IpuCs: EPB Chip Select for IPU (internal 8051).         */
     /* range: 15:15, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD addr_ipu_cs;

     /* MacroSel: EPB SerDes macro selector for CMU chip select.     */
     /* range: 17:16, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD macro_sel;

     /* MacroSelAll: EPB Select all SerDes macros (broadcast).       */
     /* range: 18:18, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD macro_sel_all;

     /* WrEn: EPB Write OP (1) or read OP (0).                       */
     /* range: 19:19, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD wr_en;

     /* IntReq: Wait for interrupt acknowledge before accessing      */
     /* the EPB.                                                     */
     /* range: 22:22, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD int_req;

     /* IntHold: Continue holding the interrupt request after        */
     /* the EPB access is complete (to speedup the next EPB          */
     /* access).                                                     */
     /* range: 23:23, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD int_hold;

     /* Data: EPB write data.                                        */
     /* range: 31:24, access type: UNDEF, default value: 0x0         */
     SOC_PETRA_REG_FIELD data;

  } __ATTRIBUTE_PACKED__ srd_epb_op_reg;


  /* Srd Epb Rd: EPB OP data read register. After a read from       */
  /* the EPB bus is finished, the read data and status are          */
  /* available here.                                                */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x007a */

     /* Addr_Element: EPB element address inside selected            */
     /* channel.                                                     */
     /* range: 3:0, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD addr_element;

     /* Addr_Channel: EPB channel address select: [3-0] = Rx/Tx      */
     /* channels. [5-4] = Reserved. [6] = Reserved (8051 block).     */
     /* [7] = CMU block.                                             */
     /* range: 6:4, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD addr_channel;

     /* Addr_Global: Select all Rx/Tx channels.                      */
     /* range: 8:8, access type: RO, default value: 0x0              */
     SOC_PETRA_REG_FIELD addr_global;

     /* Addr_Reg: EPB register address inside selected element.      */
     /* range: 14:9, access type: RO, default value: 0x0             */
     SOC_PETRA_REG_FIELD addr_reg;

     /* Addr_IpuCs: EPB Chip Select for IPU (internal 8051).         */
     /* range: 15:15, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD addr_ipu_cs;

     /* MacroSel: EPB SerDes macro selector for CMU chip select.     */
     /* range: 17:16, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD macro_sel;

     /* MacroSelAll: EPB Select all SerDes macros (broadcast).       */
     /* range: 18:18, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD macro_sel_all;

     /* WrOp: EPB indicate last OP was WRITE (1) or READ (0).        */
     /* range: 19:19, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD wr_op;

     /* Error: EPB operation (read or write) did not complete,       */
     /* is in progress or had invalid OP. User should check this     */
     /* bit to ensure last OP completed successfully. Cleared        */
     /* upon dispatch of new OP (i.e. write to SrdEpbOp              */
     /* register).                                                   */
     /* range: 20:20, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD error;

     /* Valid: EPB READ operation completed and read data is now     */
     /* valid. Cleared upon dispatch of new OP (i.e. write to        */
     /* SrdEpbOp register).                                          */
     /* range: 21:21, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD valid;

     /* IntReq: EPB indicate status of P8051 (IPU) interrupt         */
     /* request.                                                     */
     /* range: 22:22, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD int_req;

     /* IntAck: EPB indicate status of P8051 (IPU) interrupt         */
     /* acknowledge.                                                 */
     /* range: 23:23, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD int_ack;

     /* Data: EPB read data from the CMUs/P8051.                     */
     /* range: 31:24, access type: RO, default value: 0x0            */
     SOC_PETRA_REG_FIELD data;

  } __ATTRIBUTE_PACKED__ srd_epb_rd_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_SERDES_REGS;

/* Block definition: MCC */
typedef struct
{
  uint32   nof_instances; /* 1 */
  SOC_PETRA_REG_ADDR addr;

  /* SMS Register:                                                  */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e00 */

     /* range: 31:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sms;

     /* range: 31:31, access type: RW, default value: 0x0            */
     /* Writing '1' activates the command. Negated by the logic upon */
     /* completion                                                   */
     SOC_PETRA_REG_FIELD cmd_active;

  } __ATTRIBUTE_PACKED__ sms_reg;

  /* TAP Configuration Register:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e01 */

     /* range: 31:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD tap;

     /* range: 4:4, access type: RW, default value: 0x0             */
     SOC_PETRA_REG_FIELD tap_cmd;

  } __ATTRIBUTE_PACKED__ tap_config_reg;

  /* TAP Result-0 Register:                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e02 */

     /* range: 31:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD res;

  } __ATTRIBUTE_PACKED__ tap_res_0_reg;

  /* TAP Result-1 Register:                                         */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e03 */

     /* range: 31:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD res;

     /* range: 3:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD shift;

     /* range: 9:4, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD mask;

  } __ATTRIBUTE_PACKED__ tap_res_1_reg;

  /* Memory Configuration Register: This register contains          */
  /* bits for configuring the memories at powerup                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e04 */

     /* MbistMode: This bit must be asserted after chip powerup      */
     /* in order to be able to repair faulty memories. This bit      */
     /* must be de-asserted for normal operation                     */
     /* range: 0:0, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD mbist_mode;

     /* RepairMemories: This bit must be asserted after chip         */
     /* powerup. As a result, the Soc_petra will read memory repair      */
     /* information from the EFUSE and will send repair commands     */
     /* towards the memories. MbistMode configuration bit must       */
     /* be set before asserting this bit.                            */
     /* range: 1:1, access type: RW, default value: 0x0              */
     SOC_PETRA_REG_FIELD repair_memories;

     /* Dm: This enables control over virage DFT \{dm2,dm1,dm0\}     */
     /* bits                                                         */
     /* range: 18:16, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD dm;

  } __ATTRIBUTE_PACKED__ memory_configuration_reg;

  /* Ready Sms Statuses1                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e05 */

     /* ReadySms1  */
     SOC_PETRA_REG_FIELD ready_sms1 ;

  } __ATTRIBUTE_PACKED__ ready_sms_statuses1;

  /* Ready Sms Statuses2                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e06 */

     /* ReadySms2  */
     SOC_PETRA_REG_FIELD ready_sms2 ;

  } __ATTRIBUTE_PACKED__ ready_sms_statuses2;

  /* Fail Sms Statuses1                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e07 */

     /* FailSms1  */
     SOC_PETRA_REG_FIELD fail_sms1 ;

  } __ATTRIBUTE_PACKED__ fail_sms_statuses1;


  /* Fail Sms Statuses2                   */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e08 */

     /* FailSms1  */
     SOC_PETRA_REG_FIELD fail_sms2 ;

  } __ATTRIBUTE_PACKED__ fail_sms_statuses2;
  /* SFP Ready Register:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e09 */

     /* range: 0:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD sfp_ready;

  } __ATTRIBUTE_PACKED__ sfp_ready_reg;

  /* TAP General Register1:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e10 */

     /* range: 31:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gen1;

  } __ATTRIBUTE_PACKED__ tap_gen_reg_1;

  /* TAP General Register2:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e11 */

     /* range: 31:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gen2;

  } __ATTRIBUTE_PACKED__ tap_gen_reg_2;

  /* Mbist Resets: This register controls all the MBIST reset       */
  /* signals                                                        */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e0a */

     /* SmsRst: Resets all MBIST processors.                         */
     /* range: 0:0, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD sms_rst;

     /* SfpRst: Resets the SFP (Shared Fuse Processor)               */
     /* range: 1:1, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD sfp_rst;

     /* MbistReset: Resets the WRCK domain of the MBIST              */
     /* processors                                                   */
     /* range: 2:2, access type: RW, default value: 0x1              */
     SOC_PETRA_REG_FIELD mbist_reset;

  } __ATTRIBUTE_PACKED__ mbist_resets_reg;

  /* TAP TMS Value Register1:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e20 */

     /* range: 31:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gen;

  } __ATTRIBUTE_PACKED__ tap_tms_value_reg_1;

  /* TAP TMS Value Register2:                                    */
  struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0x4e21 */

     /* range: 31:0, access type: RW, default value: 0x0            */
     SOC_PETRA_REG_FIELD gen;

  } __ATTRIBUTE_PACKED__ tap_tms_value_reg_2;

  /* UDR mode:                                    */
  struct
  {
    SOC_PETRA_REG_ADDR  addr; /* 0x4e32 */

    /* range: 31:0, access type: RW, default value: 0x0            */
    SOC_PETRA_REG_FIELD gen;

  } __ATTRIBUTE_PACKED__ udr_mode_reg;

} __ATTRIBUTE_PACKED__ SOC_PETRA_MCC_REGS;
  /* Blocks definition } */


  typedef struct
  {
    SOC_PETRA_ECI_REGS eci;
    SOC_PETRA_OLP_REGS olp;
    SOC_PETRA_NIF_REGS nif;
    SOC_PETRA_NIF_MAC_LANE_REGS nif_mac_lane;
    SOC_PETRA_IRE_REGS ire;
    SOC_PETRA_IDR_REGS idr;
    SOC_PETRA_IRR_REGS irr;
    SOC_PETRA_IHP_REGS ihp;
    SOC_PETRA_IQM_REGS iqm;
    SOC_PETRA_MMU_REGS mmu;
    SOC_PETRA_QDR_REGS qdr;
    SOC_PETRA_IPS_REGS ips;
    SOC_PETRA_IPT_REGS ipt;
    SOC_PETRA_DRC_REGS drc;
    SOC_PETRA_DPI_REGS dpi;
    SOC_PETRA_FDR_REGS fdr;
    SOC_PETRA_FDT_REGS fdt;
    SOC_PETRA_FCR_REGS fcr;
    SOC_PETRA_FCT_REGS fct;
    SOC_PETRA_MESH_TOPOLOGY_REGS mesh_topology;
    SOC_PETRA_RTP_REGS rtp;
    SOC_PETRA_FABRIC_MAC_REGS fabric_mac;
    SOC_PETRA_MSW_REGS msw;
    SOC_PETRA_EGQ_REGS egq;
    SOC_PETRA_EPNI_REGS epni;
    SOC_PETRA_CFC_REGS cfc;
    SOC_PETRA_SCH_REGS sch;
    SOC_PETRA_SERDES_REGS serdes;
    SOC_PETRA_MCC_REGS mcc;
  } __ATTRIBUTE_PACKED__ SOC_PA_REGS;
#endif

  /* Invalid register called when calling a Soc_petra register without   */
  /* the compilation of its code.                                    */
typedef struct
  {
     SOC_PETRA_REG_ADDR  addr; /* 0xFFFFFFFF */

     /* Invalid device called                                         */
     SOC_PETRA_REG_FIELD invalid_device;

  } SOC_PETRA_INVALID_DEVICE_REG;

#ifdef LINK_PA_LIBRARIES
/* } */

/*************
 * GLOBALS   *
 *************/
/* { */

/* } */

/*************
 * FUNCTIONS *
 *************/
/* { */

/*****************************************************
*NAME
* soc_pa_regs_get
*TYPE:
*  PROC
*DATE:
*  08/08/2007
*FUNCTION:
*  Get a pointer to registers database.
*  The database is per chip-version.
*INPUT:
*  SOC_SAND_DIRECT:
*    SOC_SAND_OUT  SOC_PA_REGS  **soc_petra_regs - pointer to soc_petra
*                           registers database.
*  SOC_SAND_INDIRECT:
*    None.
*OUTPUT:
*  SOC_SAND_DIRECT:
*    error indication
*  SOC_SAND_INDIRECT:
*    *soc_petra_regs.
*REMARKS:
*    If the database is not initialized - error will be indicated.
*    soc_petra_is_reg_db_initialized should be called before
*    calling to this function.
*SEE ALSO:
*****************************************************/
uint32
  soc_pa_regs_get(
    SOC_SAND_OUT  SOC_PA_REGS  **soc_petra_regs
  );

/*****************************************************
*NAME
*  soc_pa_regs_init
*TYPE:
*  PROC
*DATE:
*  08/08/2007
*FUNCTION:
*  Dynamically allocates and initializes Soc_petra registers database.
*
*INPUT:
*  SOC_SAND_DIRECT:
*    None.
*  SOC_SAND_INDIRECT:
*    None.
*OUTPUT:
*  SOC_SAND_DIRECT:
*    error indication
*  SOC_SAND_INDIRECT:
*    None.
*REMARKS:
*   Calling upon already initialized registers will do nothing
*   User must make sure that this function is called after a semaphore was taken
*SEE ALSO:
*****************************************************/
uint32
  soc_pa_regs_init(void);

/************************************************************************/
/* Returns TRUE if the register is DRC register                         */
/************************************************************************/
uint8
  soc_pa_regs_is_dprc_reg(
    SOC_SAND_IN SOC_PETRA_REG_ADDR* addr
  );
#endif

typedef struct
  {
#ifdef LINK_PA_LIBRARIES
    SOC_PA_REGS *a_regs;
#endif

#ifdef LINK_PB_LIBRARIES
    SOC_PB_REGS *b_regs;
#endif

#if !(defined(LINK_PA_LIBRARIES) && defined(LINK_PB_LIBRARIES))
    SOC_PETRA_INVALID_DEVICE_REG *invalid_device_reg;
#endif
  } SOC_PETRA_REGS;


uint32
  soc_petra_regs_get(
    SOC_SAND_OUT  SOC_PETRA_REGS  **soc_petra_regs
  );

uint32
  soc_petra_regs_init(void);

#include <soc/dpp/SAND/Utils/sand_footer.h>


/* } __SOC_PETRA_CHIP_REGS_INCLUDED__*/
#endif
