Fastpath Style Guide
====================

This document describes the coding style conventions used in Fastpath. If you
add a new file to Fastpath or are editing an existing file, please format your
code according to this style. If you are the maintainer of a file that does
not follow these guidelines, please -- at your own convenience -- modify the
file(s) you maintain to bring them into conformance with this style guide.
Please note that this is a low priority task.


Declaration Order
-----------------

Here is the preferred order in which code should be laid out in a file:

 - commented program name and one-line description
 - commented author name and email address(es)
 - commented GPL boilerplate
 - commented longer description / notes for the program (if needed)
 - #includes of .h files with angle brackets (<>) around them
 - #includes of .h files with quotes ("") around them
 - #defines (if any, note the section below titled "Avoid the Preprocessor")
 - const and global variables
 - function declarations (if necessary)
 - function implementations



Whitespace and Formatting
-------------------------

This is everybody's favorite flame topic so let's get it out of the way right
up front.


Tabs vs. Spaces in Line Indentation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The preference in Fastpath is to indent lines with spaces. Do not indent lines
with tabs and do not indents lines using a mixture of tabs and spaces.
The preference for indentation width, is to use 2 (two) or 4 (four) spaces wide.
Two spaces format is the adopted one for Fastpath project.


Operator Spacing
~~~~~~~~~~~~~~~~

Put spaces between terms and operators. Example:

	Don't do this:

		for(i=0;i<num_items;i++)
		{

	Do this instead:

		for (i = 0; i < num_items; i++)
		{

	While it extends the line a bit longer, the spaced version is more
	readable. An allowable exception to this rule is the situation where
	excluding the spacing makes it more obvious that we are dealing with a
	single term (even if it is a compound term) such as:

		if (str[idx] == '/' && str[idx-1] != '\\')

	or

		if ((argc-1) - (optind+1) > 0)


Bracket Spacing
~~~~~~~~~~~~~~~

If an opening bracket starts a function, it should be on the next line with
no spacing before it. The same is applied if a bracket follows an opening
control block.
It is also acceptable the opening bracket to be on the same line with a single
space (not a tab) between it and the opening control block statement. However
that alternative is not the adopted one for Fastpath project. Use only the 
'next line' opening bracket model.

Examples:
	
	Don't do this:

		while (!done) {

		do {

	Don't do this either:

		while (!done){

		do{

	And for heaven's sake, don't do this:

		while (!done)
		  {

		do
		  {

	Do this instead:

		while (!done)
		{
		  ...
		}

		do
		{
		  ...
		}

If you have long logic statements that need to be wrapped, then uncuddling
the parenthesys to improve readability is allowed. Generally, this style makes
it easier for reader to notice that 2nd and following lines are still
inside 'if':

		if (some_really_long_checks && some_other_really_long_checks
		    && some_more_really_long_checks
		    && even_more_of_long_checks
		   )
		{
		  do_foo_now;
		}

The main rule is to always align opening and closing brackets and parenthesys,
to help readability. Although it consumes more lines, it helps locating the
code start and end section.


Cuddled Elses
~~~~~~~~~~~~~

Also, please "cuddle" your else statements by putting the else keyword on the
next line after the right bracket that closes an 'if' statement.

	Avoid this:

	if (foo)
        {
	  stmt;
	} else
	{
	  stmt;
	}

	Do this instead:

	if (foo)
        {
		stmt;
	}
	else
	{
	  stmt;
	}

To include comments before 'if' or 'else' blocks, align it with the statement.
Example:

	if (foo)
	{
	  stmts...
	}
	/* otherwise, we're just kidding ourselves, so re-frob the input */
	else
	{
	  other_stmts...
	}


Spacing around Parentheses
~~~~~~~~~~~~~~~~~~~~~~~~~~

Put a space between C keywords and left parens, but not between function names
and the left paren that starts it's parameter list (whether it is being
declared or called). Examples:

	Don't do this:

		while(foo)
		for(i = 0; i < n; i++)

	Do this instead:

		while (foo)
		for (i = 0; i < n; i++)

	But do functions like this:

		static int my_func(int foo, char bar)
		...
		baz = my_func(1, 2);

Also, don't put a space between the left paren and the first term, nor between
the last arg and the right paren.

	Don't do this:

		if ( x < 1 )
		strcmp( thisstr, thatstr )

	Do this instead:

		if (x < 1)
		strcmp(thisstr, thatstr)


Conditional #? statements
~~~~~~~~~~~~~~~~~~~~~~~~~

The conditional #if, #ifdef, #ifndef, #else, #elif and #end statements should
be written at the beginning of the line, not indented to the block level.
However, if you need to chain several conditionals inside of each other, you may
use indentation (with only 2 space characters), but always with the first
conditional at the beginning of the line.
Example:

#ifdef DEF_NAME
  #if (...)
  ...
  #else
  ...
#endif


Labels
~~~~~~

Labels should be always avoided, but for some exceptions, it can help making code
more readable. For such situations (and only those), Labels should start at the
beginning of the line, not indented to the block level (because they do not "belong"
to block scope, only to whole function).

	if (foo)
	{
	  stmt;
label:
	  stmt2;
	  stmt;
	}

(Putting label at position 1 prevents diff -p from confusing label for function
name, but it's not a policy of busybox project to enforce such a minor detail).

As final recommendation, try to use "do, while (0)" to avoid the goto statements.
Here is an example:

	do
	{
	  if (...)
	  {
	    break;
	  }
	} while (0);



Constant, Variable and Function Names
-------------------------------------

This section is about the name format and syntax that constants, variables and
functions should follow.


Constants, macros and enum types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Enums, #defines, macros, and constant variables are occasionally written in all
upper-case with words optionally separated by underscores (i.e. FIFO_TYPE, ISBLKDEV()).


Data type names
~~~~~~~~~~~~~~~

It is a good advice to give a specific pattern to data type names, to help
distinguish them from variable names. A good idea is to use the '_t' suffix:

	typedef unsigned char var_t;
	var_t var;

This way, you can reuse the data type name for the variables.


Variable and Function names
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use preferably the K&R style with names in all lower-case and underscores to separate
words (e.g., "variable_name" and "numchars" are both acceptable). Using underscores
makes variable and function names more readable because it looks like whitespace;
using lower-case is easy on the eyes.

	Frowned upon:

		hitList
		TotalChars
		szFileName
		pf_Nfol_TriState

	Preferred:

		hit_list
		total_chars
		file_name
		sensible_name

If the function/variable name tends to be long, with several required
underscores, it is acceptable to join some related words using upper-case
letters to distinguish them, instead of underscores.
However you should avoid this procedure and be faithfull to the K&K style.

Examples:
	L7_RC_t ptin_intf_phyConfig_get(...);
	L7_RC_t ptin_intf_slotPort2IntIfNum(...);

For static variables (internal), you can prefix its name with the underscore
character, to help distinguish them from the automatic or global ones.
For static functions, this does not make much sense, once the static keyword
is always used.


External Constant, Variable and Function name Syntax
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Inside projects not natively built at PT Inovacao, like Fastpath,
in order to distinguish PTin made files, functions and variables the keyword
ptin should be prefixed. An example is ptin_l2.c and ptin_intf.c files, which
deal with Layer 2 and interfaces respectively.
The same is applied to #define and enum constants, using the PTIN_ prefix
(upper case in this case).

Constant (#defines and enums), variable and function names accessible to all
libraries (external) should have names which are easily associated to its
belonging library. It is a good rule to prefix their names with the library
name. Examples are ptin_intf_init() and ptin_intf_portExt_set(...), which are
part of the ptin_intf.h library.



Notes about functions/variables/Constants usage
-----------------------------------------------

One of the problems of C language is about the mess it can introduce
if no rules are followed about global variables/constants usage, so it is
mandatory to obbey these requirements:


Constants
~~~~~~~~~

To represent a limited set of values, or integer ranges, do not use 'char' or
'int' data types. Also avoid using #define constants. Instead use enum types.
Constant names should always be upper-case.

Example:

	enum
	{
	  PTIN_VALUE0=0,
	  PTIN_VALUE1,
	  PTIN_VALUE2
	} enum_datatype_t;

#define statement should only be used to represent single constants not related
to any range of possible values.


Macros and inline functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Macros are very prone to compilation and execution errors, if you are not
carefull with parens usage. Instead, use inline functions, simply because
they provide safety, no length limitations, no formatting limitations, have an
actual return value, and under gcc they are as cheap as macros.


Global functions
~~~~~~~~~~~~~~~~

Global external functions should use well understandable names, using as
prefix the library name which it belongs. This way is easy to associate each
function to its library.

Always comment properly each function, with its purpose and input/output
parameters, following this template:

/**
 * Function description
 *  
 * @param param1 : 
 * @param param2 : 
 * 
 * @return L7_RC_t : L7_SUCCESS/L7_FAILURE
 */
L7_RC_t ptin_intf_boardtype_get(...)


Global variables
~~~~~~~~~~~~~~~~

When having to use global variables, use only at the scope of the module with
the static statement. External variables should not be used... period!
If you need to access or modify variables defined in other modules, use
external functions to do that procedure.


Automatic variables
~~~~~~~~~~~~~~~~~~~

Always as possible use automatic variables, once they exist only at the
function scope, and you can reuse variable names between different functions.

Exception to this, are big size variables like big structures or long arrays
which will deplete the available stack. In this case, you can define the
variable as static outside the function. Use a function related name, to
guarantee there is no mismatch with other global variables.


Dynamic variables
~~~~~~~~~~~~~~~~~

Never execute dynamic memory allocation at normal operation. Any memory leak
not detected, will simply drain the available memory making the application
unstable.
Dynamic allocations are only acceptable during application
startup/initialization, but if possible use static allocation. This way you
can always be sure there is enough memory to all possible situations.


Structures/Unions
~~~~~~~~~~~~~~~~~

Always there is related variables, you should use structs or unions to favour
data organization, instead of several variables independent of each other.
This is specially important for global variables inside a module, because each
one will be scope protected inside the structure.



Notes on Strings
----------------

Strings in C can get a little thorny. Here's some guidelines for dealing with
strings in Fastpath. (There is surely more that could be added to this
section.)


Testing String Equivalence
~~~~~~~~~~~~~~~~~~~~~~~~~~

There's a right way and a wrong way to test for string equivalence with
strcmp():

	The wrong way:

		if (!strcmp(string, "foo"))
		{
		  ...

	The right way:

		if (strcmp(string, "foo") == 0)
		{
		  ...

The use of the "equals" (==) operator in the latter example makes it much more
obvious that you are testing for equivalence. The former example with the
"not" (!) operator makes it look like you are testing for an error. In a more
perfect world, we would have a streq() function in the string library, but
that ain't the world we're living in.


Avoid Dangerous String Functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Unfortunately, the way C handles strings makes them prone to overruns when
certain library functions are (mis)used. The following table  offers a summary
of some of the more notorious troublemakers:

function     overflows                  preferred
-------------------------------------------------
strcpy       dest string                safe_strncpy
strncpy      may fail to 0-terminate dst safe_strncpy
strcat       dest string                strncat
gets         string it gets             fgets
getwd        buf string                 getcwd
[v]sprintf   str buffer                 [v]snprintf
realpath     path buffer                use with pathconf
[vf]scanf    its arguments              just avoid it


The above is by no means a complete list. Be careful out there.



Inline Documentation
--------------------

Emphasizing Logical Blocks
~~~~~~~~~~~~~~~~~~~~~~~~~~

Organization and readability are improved by putting extra newlines around
blocks of code that perform a single task. These are typically blocks that
begin with a C keyword, but not always.

Furthermore, you should put a single comment (not necessarily one line, just
one comment) before the block, rather than commenting each and every line.
There is an optimal amount of commenting that a program can have; you can
comment too much as well as too little.

A picture is really worth a thousand words here, the following example
illustrates how to emphasize logical blocks:

	while (line = xmalloc_fgets(fp))
	{
	  /* eat the newline, if any */
	  chomp(line);

	  /* ignore blank lines */
	  if (strlen(file_to_act_on) == 0)
	  {
	    continue;
	  }

	  /* if the search string is in this line, print it,
	   * unless we were told to be quiet */
	  if (strstr(line, search) && !be_quiet)
	  {
	    puts(line);
	  }

	  /* clean up */
	  free(line);
	}


Libraries and functions description
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

At the beginning of each .c and .h file, please add a comment section to describe
the library purpose, and other usefull information:

This is an example:

/*********************************************************************
*
* (C) Copyright PT Inovacao 2013
*
**********************************************************************
*
* @filename  ptin_intf.c
*
* @purpose   This file contains interface management functions
*
* @component ptin
*
* @comments  My comment.
*
* @create    1/01/2011
*
* @author    me
*
* @end
*
**********************************************************************/

Also at the beginning of functions, include a description with the function
purpose, the input/output parameters, and return values. This should be done
to both .c and .h files.
Slickedit has an automatic procedure, where you just have to type the
characters '/**'+Enter before the function to get a template:

/**
 * Get board type for a particular interface
 *  
 * @param in  : input parameter
 * @param out : output value (out)
 * 
 * @return int : 0 (success), -1 (failure).
 */
int foo(int in, int *out)
{
  ...
}



Miscellaneous Coding Guidelines
-------------------------------

The following are important items that don't fit into any of the above
sections.


Scope
~~~~~

If a const variable is used only in a single source file, put it in the source
file and not in a header file. Likewise, if a const variable is used in only
one function, do not make it global to the file. Instead, declare it inside
the function body. Bottom line: Make a conscious effort to limit declarations
to the smallest scope possible.

Inside .c files, all internal functions should be declared static so as to keep
the global name space clean. The only exception to this rule is the devshell
functions which can be called at command line.


Brackets Are Your Friends
~~~~~~~~~~~~~~~~~~~~~~~~~

Please use brackets on all if and else statements, even if it is only one
line. Example:

	Don't do this:

		if (foo)
			stmt1;
		stmt2
		stmt3;

	Do this instead:

		if (foo)
		{
		  stmt1;
		}
		stmt2
		stmt3;

The "bracketless" approach is error prone because someday you might add a line
like this:

		if (foo)
		  stmt1;
		  new_line();
		stmt2;
		stmt3;

And the resulting behavior of your program would totally bewilder you. (Don't
laugh, it happens to us all.) Remember folks, this is C, not Python.


Function Declarations
~~~~~~~~~~~~~~~~~~~~~

Do not use old-style function declarations that declare variable types between
the parameter list and opening bracket. Example:

	Don't do this:

		int foo(parm1, parm2)
			char parm1;
			float parm2;
		{
			....

	Do this instead:

		int foo(char parm1, float parm2)
		{
			....

The only time you would ever need to use the old declaration syntax is to
support ancient, antediluvian compilers. To our good fortune, we have access
to more modern compilers and the old declaration syntax is neither necessary
nor desired.



Avoid The Preprocessor
----------------------

At best, the preprocessor is a necessary evil, helping us account for platform
and architecture differences. Using the preprocessor unnecessarily is just
plain evil.


The Folly of #define
~~~~~~~~~~~~~~~~~~~~

Use 'const <type> var' for declaring constants.

	Don't do this:

		#define CONST 80

	Do this instead, when the variable is in a header file and will be used in
	several source files:

		enum
		{
		  CONST = 80
		};

Although enum may look ugly to some people, it is better for code size.
With "const int" compiler may fail to optimize it out and will reserve
a real storage in rodata for it! (Hopefully, newer gcc will get better
at it...).  With "define", you have slight risk of polluting namespace
(#define doesn't allow you to redefine the name in the inner scopes),
and complex "define" are evaluated each time they uesd, not once
at declarations like enums. Also, the preprocessor does _no_ type checking
whatsoever, making it much more error prone.


The Folly of Macros
~~~~~~~~~~~~~~~~~~~

Use 'static inline' instead of a macro.

	Don't do this:

		#define mini_func(param1, param2) (param1 << param2)

	Do this instead:

		static inline int mini_func(int param1, param2)
		{
		  return (param1 << param2);
		}

Static inline functions are greatly preferred over macros. They provide type
safety, have no length limitations, no formatting limitations, have an actual
return value, and under gcc they are as cheap as macros. Besides, really long
macros with backslashes at the end of each line are ugly as sin.


The Folly of #ifdef
~~~~~~~~~~~~~~~~~~~

Code cluttered with ifdefs is difficult to read and maintain. Don't do it.
Instead, put your ifdefs at the top of your .c file (or in a header), and
conditionally define 'static inline' functions, (or *maybe* macros), which are
used in the code.

	Don't do this:

		ret = my_func(bar, baz);
		if (!ret)
			return -1;
		#ifdef CONFIG_FEATURE_FUNKY
			maybe_do_funky_stuff(bar, baz);
		#endif

	Do this instead:

	(in .h header file)

		#if ENABLE_FEATURE_FUNKY
		static inline void maybe_do_funky_stuff(int bar, int baz)
		{
			/* lotsa code in here */
		}
		#else
		static inline void maybe_do_funky_stuff(int bar, int baz) {}
		#endif

	(in the .c source file)

		ret = my_func(bar, baz);
		if (!ret)
			return -1;
		maybe_do_funky_stuff(bar, baz);

The great thing about this approach is that the compiler will optimize away
the "no-op" case (the empty function) when the feature is turned off.

Note also the use of the word 'maybe' in the function name to indicate
conditional execution.

