Index: src/application/qos/diffserv/base/diffserv_cluster.c
===================================================================
--- src/application/qos/diffserv/base/diffserv_cluster.c	(revision 7370)
+++ src/application/qos/diffserv/base/diffserv_cluster.c	(revision 7371)
@@ -1,3182 +1,3182 @@
-/*********************************************************************
-*
-* (C) Copyright Broadcom Corporation 2002-2007
-*
-**********************************************************************
-*
-* @filename  diffserv_cluster.c
-*
-* @purpose   Diffserv support for clustering
-*
-* @component QoS - Diffserv
-*
-* @comments
-*
-* @create    02/28/2008
-*
-* @author    gpaussa
-*
-* @end
-*
-**********************************************************************/
-#include <string.h>
-#include "commdefs.h"
-#include "osapi.h"
-#include "osapi_support.h"
-#include "log.h"
-#include "nvstoreapi.h"
-#include "l7utils_api.h"
-#include "comm_mask.h"
-#include "avl_api.h"
-#include "clustering_commdefs.h"
-#include "clustering_api.h"
-#include "l7_diffserv_api.h"
-#include "diffserv_config.h"
-#include "diffserv_prvtmib.h"
-#include "diffserv_util.h"
-#include "diffserv_cluster.h"
-#include "usmdb_mib_diffserv_private_api.h"
-
-extern char *dsmibPrvtTableIdStr[];
-extern L7_uchar8  policyAttrIpDscpValSupported[];
-
-static L7_diffServCfg_t *dsClusterTxCfg   = L7_NULLPTR;
-static L7_diffServCfg_t *dsClusterRxCfg   = L7_NULLPTR;
-static L7_diffServCfg_t *dsClusterTmpCfg  = L7_NULLPTR;
-
-static L7_BOOL          dsClusterRxCfgMsgStarted  = L7_FALSE;               /* received Config Start IE msg, but not Config End */
-static dsClusterMsgIe_t dsClusterRxCfgIeExpected  = DS_CLUSTER_MSG_IE_NONE; /* next expected IE in a defined sequence */
-
-/* copy of data received from cluster member switch */
-static L7_BOOL  dsClusterRxInProg   = L7_FALSE; /* indicates Rx operation currently in progress */
-static L7_BOOL  dsClusterRxError    = L7_FALSE; /* indicates unrecoverable error receiving, drop remaining messages */
-
-static L7_int32 dsClusterTaskId     = L7_ERROR;
-static void     *dsClusterQueue     = L7_NULLPTR;
-static L7_BOOL  dsClusterDebug      = L7_FALSE;
-
-static L7_COMPONENT_IDS_t dsCompId  = L7_FLEX_QOS_DIFFSERV_COMPONENT_ID;
-
-static dsClusterTableParms_t dsClusterTableParms[DSMIB_TABLE_ID_TOTAL] =
-{
-  { /* none (placeholder) */
-    0, 0, 0, 0, 0, 0, 0, 0, L7_NULLPTR, L7_NULLPTR
-  },
-  { /* class table */
-    L7_DIFFSERV_CLASS_HDR_START,
-    L7_DIFFSERV_CLASS_HDR_MAX,
-    DS_CLUSTER_MSG_IE_CLASS_CONFIG_START,
-    DS_CLUSTER_MSG_IE_CLASS_CONFIG_START_SIZE,
-    DS_CLUSTER_MSG_IE_CLASS_DEF,
-    DS_CLUSTER_MSG_IE_CLASS_DEF_SIZE,
-    DS_CLUSTER_MSG_IE_CLASS_CONFIG_END,
-    DS_CLUSTER_MSG_IE_CLASS_CONFIG_END_SIZE,
-    diffServClusterConfigClassMsgAccess,
-    diffServClusterConfigClassVerify
-  },
-  { /* class rule table */
-    L7_DIFFSERV_CLASS_RULE_START,
-    L7_DIFFSERV_CLASS_RULE_MAX,
-    DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START,
-    DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START_SIZE,
-    DS_CLUSTER_MSG_IE_CLASS_RULE_DEF,
-    DS_CLUSTER_MSG_IE_CLASS_RULE_DEF_SIZE,
-    DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END,
-    DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END_SIZE,
-    diffServClusterConfigClassRuleMsgAccess,
-    diffServClusterConfigClassRuleVerify
-  },
-  { /* policy table */
-    L7_DIFFSERV_POLICY_HDR_START,
-    L7_DIFFSERV_POLICY_HDR_MAX,
-    DS_CLUSTER_MSG_IE_POLICY_CONFIG_START,
-    DS_CLUSTER_MSG_IE_POLICY_CONFIG_START_SIZE,
-    DS_CLUSTER_MSG_IE_POLICY_DEF,
-    DS_CLUSTER_MSG_IE_POLICY_DEF_SIZE,
-    DS_CLUSTER_MSG_IE_POLICY_CONFIG_END,
-    DS_CLUSTER_MSG_IE_POLICY_CONFIG_END_SIZE,
-    diffServClusterConfigPolicyMsgAccess,
-    diffServClusterConfigPolicyVerify
-  },
-  { /* policy inst table */
-    L7_DIFFSERV_POLICY_INST_START,
-    L7_DIFFSERV_POLICY_INST_MAX,
-    DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START,
-    DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START_SIZE,
-    DS_CLUSTER_MSG_IE_POLICY_INST_DEF,
-    DS_CLUSTER_MSG_IE_POLICY_INST_DEF_SIZE,
-    DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END,
-    DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END_SIZE,
-    diffServClusterConfigPolicyInstMsgAccess,
-    diffServClusterConfigPolicyInstVerify
-  },
-  { /* policy attr table */
-    L7_DIFFSERV_POLICY_ATTR_START,
-    L7_DIFFSERV_POLICY_ATTR_MAX,
-    DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START,
-    DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START_SIZE,
-    DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF,
-    DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF_SIZE,
-    DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END,
-    DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END_SIZE,
-    diffServClusterConfigPolicyAttrMsgAccess,
-    diffServClusterConfigPolicyAttrVerify
-  },
-  { /* policy perf in (not used here) */
-    0, 0, 0, 0, 0, 0, 0, 0, L7_NULLPTR, L7_NULLPTR
-  },
-  { /* policy perf out (not used here) */
-    0, 0, 0, 0, 0, 0, 0, 0, L7_NULLPTR, L7_NULLPTR
-  },
-  { /* service (not used here) */
-    0, 0, 0, 0, 0, 0, 0, 0, L7_NULLPTR, L7_NULLPTR
-  }
-};
-
-/* internal functions */
-
-static void _dsClusterPktInt32GetOrSet(L7_BOOL isSet, L7_uint32 *value,
-                                       L7_uchar8 *buffer, L7_uint32 *offset)
-{
-  if (L7_TRUE == isSet)
-  {
-    CLUSTER_PKT_INT32_SET(*value, buffer, *offset);
-  }
-  else
-  {
-    CLUSTER_PKT_INT32_GET(*value, buffer, *offset);
-  }
-}
-
-static void _dsClusterPktInt16GetOrSet(L7_BOOL isSet, L7_ushort16 *value,
-                                       L7_uchar8 *buffer, L7_uint32 *offset)
-{
-  if (L7_TRUE == isSet)
-  {
-    CLUSTER_PKT_INT16_SET(*value, buffer, *offset);
-  }
-  else
-  {
-    CLUSTER_PKT_INT16_GET(*value, buffer, *offset);
-  }
-}
-
-static void _dsClusterPktInt8GetOrSet(L7_BOOL isSet, L7_uchar8 *value,
-                                      L7_uchar8 *buffer, L7_uint32 *offset)
-{
-  if (L7_TRUE == isSet)
-  {
-    CLUSTER_PKT_INT8_SET(*value, buffer, *offset);
-  }
-  else
-  {
-    CLUSTER_PKT_INT8_GET(*value, buffer, *offset);
-  }
-}
-
-static void _dsClusterPktStringGetOrSet(L7_BOOL isSet, L7_uchar8 *str, L7_uint32 len,
-                                        L7_uchar8 *buffer, L7_uint32 *offset)
-{
-  if (L7_TRUE == isSet)
-  {
-    CLUSTER_PKT_STRING_SET(str, len, buffer, *offset);
-  }
-  else
-  {
-    CLUSTER_PKT_STRING_GET(str, len, buffer, *offset);
-  }
-}
-
-static void _dsClusterCfgStructInit(L7_diffServCfg_t *pCfg, L7_char8 *pDescrStr)
-{
-  if (L7_NULLPTR != pCfg)
-  {
-    memset(pCfg, 0, sizeof(*pCfg));
-
-    /* fill in file hdr fields */
-    if (L7_NULLPTR != pDescrStr)
-    {
-      snprintf(pCfg->cfgHdr.filename, sizeof(pCfg->cfgHdr.filename), "%s", pDescrStr);
-    }
-    pCfg->cfgHdr.version          = L7_DIFFSERV_CFG_VER_CURRENT;
-    pCfg->cfgHdr.componentID      = L7_FLEX_QOS_DIFFSERV_COMPONENT_ID;
-    pCfg->cfgHdr.type             = L7_CFG_DATA;
-    pCfg->cfgHdr.length           = (L7_uint32)L7_DIFFSERV_CFG_DATA_SIZE;
-    pCfg->cfgHdr.dataChanged      = L7_FALSE;
-    pCfg->cfgHdr.fileHdrVersion   = L7_FILE_HDR_VER_CURRENT;
-  }
-}
-
-static L7_BOOL _dsClusterConfigEntryInUseGet(dsmibTableId_t    tableID,
-                                             L7_diffServCfg_t  *pCfg,
-                                             L7_uint32         index)
-{
-  L7_BOOL inUse = L7_FALSE;
-
-  switch (tableID)
-  {
-    case DSMIB_TABLE_ID_CLASS:
-      inUse = pCfg->classHdr[index].inUse;
-      break;
-
-    case DSMIB_TABLE_ID_CLASS_RULE:
-      inUse = (0 == pCfg->classRule[index].hdrIndexRef) ? L7_FALSE : L7_TRUE;
-      break;
-
-    case DSMIB_TABLE_ID_POLICY:
-      inUse = pCfg->policyHdr[index].inUse;
-      break;
-
-    case DSMIB_TABLE_ID_POLICY_INST:
-      inUse = (0 == pCfg->policyInst[index].hdrIndexRef) ? L7_FALSE : L7_TRUE;
-      break;
-
-    case DSMIB_TABLE_ID_POLICY_ATTR:
-      inUse = (0 == pCfg->policyAttr[index].instIndexRef) ? L7_FALSE : L7_TRUE;
-      break;
-
-    default:
-      /* table ID not suppoorted here */
-      break;
-
-  } /* endswitch */
-
-  return inUse;
-}
-
-static L7_ushort16 _dsClusterIeDefinedSizeGet(L7_ushort16 elemId)
-{
-  L7_ushort16       elemSize = 0;
-
-  switch (elemId)
-  {
-    case DS_CLUSTER_MSG_IE_CONFIG_START:
-      elemSize = DS_CLUSTER_MSG_IE_CONFIG_START_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_GLOBAL_CONFIG:
-      elemSize = DS_CLUSTER_MSG_IE_GLOBAL_CONFIG_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
-      elemSize = DS_CLUSTER_MSG_IE_CLASS_CONFIG_START_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_CLASS_DEF:
-      elemSize = DS_CLUSTER_MSG_IE_CLASS_DEF_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
-      elemSize = DS_CLUSTER_MSG_IE_CLASS_CONFIG_END_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
-      elemSize = DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
-      elemSize = DS_CLUSTER_MSG_IE_CLASS_RULE_DEF_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
-      elemSize = DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
-      elemSize = DS_CLUSTER_MSG_IE_POLICY_CONFIG_START_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_DEF:
-      elemSize = DS_CLUSTER_MSG_IE_POLICY_DEF_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
-      elemSize = DS_CLUSTER_MSG_IE_POLICY_CONFIG_END_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
-      elemSize = DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
-      elemSize = DS_CLUSTER_MSG_IE_POLICY_INST_DEF_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
-      elemSize = DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
-      elemSize = DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
-      elemSize = DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
-      elemSize = DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END_SIZE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_CONFIG_END:
-      elemSize = DS_CLUSTER_MSG_IE_CONFIG_END_SIZE;
-      break;
-
-    default:
-      /* invalid element ID */
-      break;
-
-  } /* endswitch */
-
-  return elemSize;
-}
-
-static dsClusterIeGroup_t _dsClusterIeGroupTypeGet(L7_ushort16 elemId)
-{
-  dsClusterIeGroup_t    groupType = DS_CLUSTER_IE_GROUP_NONE;
-
-  switch (elemId)
-  {
-    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
-      groupType = DS_CLUSTER_IE_GROUP_START;
-      break;
-
-    case DS_CLUSTER_MSG_IE_CLASS_DEF:
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
-      groupType = DS_CLUSTER_IE_GROUP_DEF;
-      break;
-
-    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
-    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
-    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
-      groupType = DS_CLUSTER_IE_GROUP_END;
-      break;
-
-    case DS_CLUSTER_MSG_IE_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_GLOBAL_CONFIG:
-    case DS_CLUSTER_MSG_IE_CONFIG_END:
-    default:
-      groupType = DS_CLUSTER_IE_GROUP_NONE;
-      break;
-
-  } /* endswitch */
-
-  return groupType;
-}
-
-static dsmibTableId_t _dsClusterIeTableIdGet(L7_ushort16 elemId)
-{
-  dsmibTableId_t        tableID = DSMIB_TABLE_ID_NONE;
-
-  switch (elemId)
-  {
-    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_CLASS_DEF:
-    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
-      tableID = DSMIB_TABLE_ID_CLASS;
-      break;
-
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
-      tableID = DSMIB_TABLE_ID_CLASS_RULE;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_POLICY_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
-      tableID = DSMIB_TABLE_ID_POLICY;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
-      tableID = DSMIB_TABLE_ID_POLICY_INST;
-      break;
-
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
-      tableID = DSMIB_TABLE_ID_POLICY_ATTR;
-      break;
-
-    default:
-      break;
-
-  } /* endswitch */
-
-  return tableID;
-}
-
-dsmibPolicyAttrType_t _dsClusterPoliceActToEntryType(dsmibPoliceAct_t policeAct)
-{
-  dsmibPolicyAttrType_t       entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_NONE;
-
-  switch (policeAct)
-  {
-    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_DROP:
-      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_DROP;
-      break;
-
-    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_MARKCOS:
-      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COSVAL;
-      break;
-
-    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_MARKCOS_AS_COS2:
-      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COS_AS_COS2;
-      break;
-
-    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_MARKCOS2:
-      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COS2VAL;
-      break;
-
-    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_MARKDSCP:
-      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL;
-      break;
-
-    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_MARKPREC:
-      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPPRECEDENCEVAL;
-      break;
-
-    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_SEND:
-    default:
-      /* nothing specific to translate to */
-      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_NONE;
-      break;
-
-  } /* endswitch*/
-
-  return entryType;
-}
-
-/*********************************************************************
-* @purpose  Show DiffServ cluster internal variables for support/debug
-*
-* @param    void
-*
-* @returns  L7_SUCCESS
-*
-* @notes
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterDebugShow(void)
-{
-  sysapiPrintf("\nDiffServ cluster support data:\n");
-  sysapiPrintf("  dsClusterTxCfg           = %p\n",      dsClusterTxCfg);
-  sysapiPrintf("  dsClusterRxCfg           = %p\n",      dsClusterRxCfg);
-  sysapiPrintf("  dsClusterTmpCfg          = %p\n",      dsClusterTmpCfg);
-  sysapiPrintf("  dsClusterRxCfgMsgStarted = %d\n",      dsClusterRxCfgMsgStarted);
-  sysapiPrintf("  dsClusterRxCfgIeExpected = 0x%4.4x\n", dsClusterRxCfgIeExpected);
-  sysapiPrintf("  dsClusterRxInProg        = %d\n",      dsClusterRxInProg);
-  sysapiPrintf("  dsClusterRxError         = %d\n",      dsClusterRxError);
-  sysapiPrintf("  dsClusterTaskId          = 0x%x\n",    dsClusterTaskId);
-  sysapiPrintf("  dsClusterQueue           = 0x%x\n",    (L7_uint32)dsClusterQueue);
-  sysapiPrintf("  dsClusterDebug           = %d\n",      dsClusterDebug);
-  sysapiPrintf("\n");
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Perform all phase 1 initialization for clustering support
-*
-* @param    void
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterPhase1Init(void)
-{
-  L7_uint32         dataSize;
-
-  /* allocate memory to send and receive DiffServ configuration.
-   *
-   * NOTE: Must be able to receive a copy of the entire config in order
-   *       to verify it before it is applied.  Must be able to abort the
-   *       receive processing without affecting the current operational
-   *       or saved config.
-   */
-  dataSize = sizeof(L7_diffServCfg_t);
-  dsClusterTxCfg  = osapiMalloc(dsCompId, dataSize);
-  dsClusterRxCfg  = osapiMalloc(dsCompId, dataSize);
-  dsClusterTmpCfg = osapiMalloc(dsCompId, dataSize);
-  if ((L7_NULLPTR == dsClusterTxCfg) ||
-      (L7_NULLPTR == dsClusterRxCfg) ||
-      (L7_NULLPTR == dsClusterTmpCfg))
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: Unable to allocate memory for Tx, Rx and Tmp config structs (%u bytes each).\n",
-            __FUNCTION__, dataSize);
-    return L7_FAILURE;
-  }
-  memset(dsClusterTxCfg, 0, dataSize);
-  memset(dsClusterRxCfg, 0, dataSize);
-  memset(dsClusterTmpCfg, 0, dataSize);
-
-  dsClusterQueue = (void *)osapiMsgQueueCreate("dsClusterQueue",
-                                               DS_CLUSTER_QUEUE_SIZE,
-                                               DS_CLUSTER_QUEUE_SIZE * sizeof(dsClusterQueueMsg_t));
-  if (L7_NULLPTR == dsClusterQueue)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: osapiMsgQueueCreate failed.\n", __FUNCTION__);
-    return L7_FAILURE;
-  }
-
-  dsClusterTaskId = osapiTaskCreate("dsClusterTask", (void *)diffServClusterTask,
-                                    0, 0,
-                                    L7_DEFAULT_STACK_SIZE,
-                                    L7_DEFAULT_TASK_PRIORITY,
-                                    L7_DEFAULT_TASK_SLICE);
-
-  if ((L7_ERROR == dsClusterTaskId) ||
-      (osapiWaitForTaskInit(L7_QOS_DIFFSERV_CLUSTER_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS))
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: osapiTaskCreate failed.\n", __FUNCTION__);
-    return L7_FAILURE;
-  }
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Perform all phase 2 initialization for clustering support
-*
-* @param    void
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterPhase2Init(void)
-{
-  if (clusterMsgRegister(DS_CLUSTER_MSG_CONFIG,
-                         CLUSTER_MSG_DELIVERY_RELIABLE,
-                         diffServClusterMsgCallback) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: clusterMsgRegister failed.\n", __FUNCTION__);
-    return L7_FAILURE;
-  }
-
-  if (clusterConfigRegister(CLUSTER_CFG_ID(QOS_DIFFSERV),
-                            diffServClusterConfigSendCallback,
-                            diffServClusterConfigRxCallback) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: clusterConfigRegister failed.\n", __FUNCTION__);
-    return L7_FAILURE;
-  }
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Task to wait on cluster messages and events
-*
-* @param    void
-*
-* @returns  void
-*
-* @notes    Clustering requires processing messages and commands in
-*           a separate task context, a component must not block the
-*           clustering task.
-*
-* @end
-*********************************************************************/
-void diffServClusterTask(void)
-{
-  dsClusterQueueMsg_t queueMsg;
-  L7_RC_t             rc;
-
-  osapiTaskInitDone(L7_QOS_DIFFSERV_CLUSTER_TASK_SYNC);
-
-  while (L7_TRUE)
-  {
-    if (osapiMessageReceive(dsClusterQueue,
-                            (void *)&queueMsg, sizeof(dsClusterQueueMsg_t),
-                            L7_WAIT_FOREVER) == L7_SUCCESS)
-    {
-      switch (queueMsg.type)
-      {
-        case DS_CLUSTER_QUEUE_MSG_CONFIG_MSG:
-          if (L7_FALSE == dsClusterRxError)
-          {
-            diffServClusterConfigMsgProcess(&queueMsg.content.msg);
-          }
-          break;
-        case DS_CLUSTER_QUEUE_MSG_CONFIG_SEND:
-          rc = diffServClusterConfigSend(&queueMsg.content.memberID);
-          if (clusterConfigSendDone(CLUSTER_CFG_ID(QOS_DIFFSERV), rc) != L7_SUCCESS)
-          {
-            L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-                    "%s: clusterConfigSendDone failed\n", __FUNCTION__);
-          }
-          break;
-        case DS_CLUSTER_QUEUE_MSG_CONFIG_RX:
-          diffServClusterConfigRxCmdProcess(queueMsg.content.configCmd);
-          break;
-        default:
-          L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-                  "%s: received invalid message, queueMsg.type=%u\n",
-                  __FUNCTION__, queueMsg.type);
-          break;
-      }
-    }
-  }
-}
-
-/*********************************************************************
-* @purpose  Callback to handle messages received through clustering
-*
-* @param    L7_ushort16              msgType   @b{(input)} message type
-* @param    clusterMsgDeliveryMethod method    @b{(input)} delivery method
-* @param    L7_uint32                msgLength @b{(input)} message length
-* @param    L7_uchar8               *msgBuf    @b{(input)} contents of message
-*
-* @returns  void
-*
-* @notes    This function should NOT introduce significant amounts
-*           of latency (e.g. by blocking), since it will be called
-*           in the context of the clustering task.  It should
-*           copy the message and signal another task to
-*           deal with the message's reception.
-* @end
-*********************************************************************/
-void diffServClusterMsgCallback(L7_ushort16              msgType,
-                                clusterMsgDeliveryMethod method,
-                                L7_uint32                msgLength,
-                                L7_uchar8               *msgBuf)
-{
-  dsClusterQueueMsg_t queueMsg;
-
-  DIFFSERV_CLUSTER_DLOG("%s: msgType=0x%4.4X\n", __FUNCTION__, msgType);
-
-  if (msgLength > sizeof(queueMsg.content.msg.buffer))
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: Received invalid cluster message length, msgLength=%u\n",
-            __FUNCTION__, msgLength);
-    return;
-  }
-
-  memset(&queueMsg, 0, sizeof(dsClusterQueueMsg_t));
-  switch (msgType)
-  {
-    case DS_CLUSTER_MSG_CONFIG:
-      queueMsg.type = DS_CLUSTER_QUEUE_MSG_CONFIG_MSG;
-      queueMsg.content.msg.length = msgLength;
-      memcpy(queueMsg.content.msg.buffer, msgBuf, msgLength);
-      break;
-    default:
-      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-              "%s: Received invalid cluster message type, msgType=0x%4.4x\n",
-              __FUNCTION__, msgType);
-      return;
-  }
-
-  /* send message to process on diffServClusterTask */
-  if (osapiMessageSend(dsClusterQueue, (void *)&queueMsg,
-                       sizeof(dsClusterQueueMsg_t),
-                       L7_NO_WAIT, L7_MSG_PRIORITY_NORM) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: osapiMessageSend failed, queueMsg.type=%u\n",
-            __FUNCTION__, queueMsg.type);
-  }
-
-  return;
-}
-
-/*********************************************************************
-* @purpose  Callback to send configuration information to a cluster member
-*
-* @param    clusterMemberID_t *memberID @b{(input)} member to receive config
-*
-* @returns  void
-*
-* @notes
-*
-* @end
-*********************************************************************/
-void diffServClusterConfigSendCallback(clusterMemberID_t *memberID)
-{
-  dsClusterQueueMsg_t queueMsg;
-
-  DIFFSERV_CLUSTER_DLOG("ENTERING %s\n", __FUNCTION__);
-
-  if (L7_NULLPTR == memberID)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: received NULL cluster member ID\n", __FUNCTION__);
-    return;
-  }
-
-  memset(&queueMsg, 0, sizeof(dsClusterQueueMsg_t));
-  queueMsg.type = DS_CLUSTER_QUEUE_MSG_CONFIG_SEND;
-  memcpy(&queueMsg.content.memberID, memberID, sizeof(clusterMemberID_t));
-
-  /* send message to process on diffServClusterTask */
-  if (osapiMessageSend(dsClusterQueue, (void *)&queueMsg,
-                       sizeof(dsClusterQueueMsg_t),
-                       L7_NO_WAIT, L7_MSG_PRIORITY_NORM) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: osapiMessageSend failed, queueMsg.type=%u\n",
-            __FUNCTION__, queueMsg.type);
-  }
-
-  return;
-}
-
-/*********************************************************************
-* @purpose  Callback to handle received configuration events
-*
-* @param    clusterConfigCmd cmd @b{(input)} configuration command
-*
-* @returns  void
-*
-* @notes
-*
-* @end
-*********************************************************************/
-void diffServClusterConfigRxCallback(clusterConfigCmd cmd)
-{
-  dsClusterQueueMsg_t queueMsg;
-
-  DIFFSERV_CLUSTER_DLOG("%s: cmd=%u\n", __FUNCTION__, cmd);
-
-  memset(&queueMsg, 0, sizeof(dsClusterQueueMsg_t));
-  queueMsg.type = DS_CLUSTER_QUEUE_MSG_CONFIG_RX;
-  queueMsg.content.configCmd = cmd;
-
-  /* send message to process on diffServClusterTask */
-  if (osapiMessageSend(dsClusterQueue, (void *)&queueMsg,
-                       sizeof(dsClusterQueueMsg_t),
-                       L7_NO_WAIT, L7_MSG_PRIORITY_NORM) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: osapiMessageSend failed, queueMsg.type=%u\n",
-            __FUNCTION__, queueMsg.type);
-  }
-
-  return;
-}
-
-/*********************************************************************
-* @purpose  Function to process cluster config message
-*
-* @param    L7_ushort16    elemId @b{(input)} received element ID
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @comments
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigRxIeSeqCheck(L7_ushort16 elemId)
-{
-  dsClusterMsgIe_t  currIe = DS_CLUSTER_MSG_IE_NONE;
-  dsClusterMsgIe_t  nextIe = dsClusterRxCfgIeExpected;
-
-  /* check this IE versus what is expected */
-  switch (elemId)
-  {
-    /* independent or config start IEs expect IE type of 'none' */
-    case DS_CLUSTER_MSG_IE_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_GLOBAL_CONFIG:
-    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_CONFIG_END:
-      currIe = DS_CLUSTER_MSG_IE_NONE;
-      break;
-
-    /* def IEs expect to see their own IE */
-    case DS_CLUSTER_MSG_IE_CLASS_DEF:
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
-      currIe = elemId;
-      break;
-
-    /* config end IEs expect IE to be their corresponding def IE */
-    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
-      currIe = DS_CLUSTER_MSG_IE_CLASS_DEF;
-      break;
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
-      currIe = DS_CLUSTER_MSG_IE_CLASS_RULE_DEF;
-      break;
-    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
-      currIe = DS_CLUSTER_MSG_IE_POLICY_DEF;
-      break;
-    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
-      currIe = DS_CLUSTER_MSG_IE_POLICY_INST_DEF;
-      break;
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
-      currIe = DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF;
-      break;
-
-    default:
-      return L7_FAILURE;
-      /*PASSTHRU*/
-
-  } /* endswitch */
-
-  /* check if we got the expected IE */
-  if (currIe != dsClusterRxCfgIeExpected)
-  {
-    return L7_FAILURE;
-  }
-
-  /* determine next expected IE */
-  switch (elemId)
-  {
-    /* config start IEs expect next IE to be their corresponding def IE */
-    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
-      nextIe = DS_CLUSTER_MSG_IE_CLASS_DEF;
-      break;
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
-      nextIe = DS_CLUSTER_MSG_IE_CLASS_RULE_DEF;
-      break;
-    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
-      nextIe = DS_CLUSTER_MSG_IE_POLICY_DEF;
-      break;
-    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
-      nextIe = DS_CLUSTER_MSG_IE_POLICY_INST_DEF;
-      break;
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
-      nextIe = DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF;
-      break;
-
-    /* def IEs expect to see their own IE */
-    case DS_CLUSTER_MSG_IE_CLASS_DEF:
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
-      nextIe = elemId;
-      break;
-
-    /* independent or config end IEs expect next IE of 'none' */
-    case DS_CLUSTER_MSG_IE_CONFIG_START:
-    case DS_CLUSTER_MSG_IE_GLOBAL_CONFIG:
-    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
-    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
-    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
-    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
-    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
-    case DS_CLUSTER_MSG_IE_CONFIG_END:
-      nextIe = DS_CLUSTER_MSG_IE_NONE;
-      break;
-
-    default:
-      return L7_FAILURE;
-      /*PASSTHRU*/
-
-  } /* endswitch */
-
-  /* set IE to expect next */
-  dsClusterRxCfgIeExpected = nextIe;
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Function to process cluster config message
-*
-* @param    dsClusterMsg_t *msg   @b{(input)} received message
-*
-* @returns  void
-*
-* @notes
-*
-* @end
-*********************************************************************/
-void diffServClusterConfigMsgProcess(dsClusterMsg_t *msg)
-{
-  static L7_ushort16          startDefs = 0;
-  static L7_ushort16          remainDefs = 0;
-
-  clusterMsgElementHdr_t      elem;
-  L7_ushort16                 elemSize;
-  L7_uchar8                   *buffer = msg->buffer;
-  L7_uint32                   offset = 0;
-  dsClusterIeGroup_t          ieGroupType;
-  L7_uint32                   index;
-  L7_ushort16                 endDefs;
-  dsmibTableId_t              tableID;
-  dsClusterTableParms_t       *pTable = L7_NULLPTR;
-
-  DIFFSERV_CLUSTER_DLOG("ENTERING %s: message length=%u\n", __FUNCTION__, msg->length);
-
-  while (offset < msg->length)
-  {
-    CLUSTER_PKT_ELEMENT_HDR_GET(elem, msg->buffer, offset);
-
-    /*DIFFSERV_CLUSTER_DLOG("%s: received elem ID 0x%4.4x (len=%u)\n",
-                          __FUNCTION__, elem.elementId, elem.elementLen);*/
-
-    /* check for proper IE sequence order */
-    if (diffServClusterConfigRxIeSeqCheck(elem.elementId) != L7_SUCCESS)
-    {
-      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-              "%s: improper msg IE sequence detected: expected 0x%4.4x, got 0x%4.4x\n",
-              __FUNCTION__, dsClusterRxCfgIeExpected, elem.elementId);
-      /* quit processing this and further messages */
-      dsClusterRxError = L7_TRUE;
-      return;
-    }
-
-    do
-    {
-      /* NOTE: The essence of this function is to process IEs comprising the
-       *       DiffServ cluster config.  Some of these IEs are independent, but
-       *       most belong to a group of IEs -- start, zero or more def(s), end.
-       *       The processing of each of these group types is handled the same
-       *       for each DiffServ config table, so the first switch stmt handles
-       *       any unique processing, while the second switch stmt takes care
-       *       of the commonality.
-       */
-
-      /* identify this IE as a particular group type (will take action on this below) */
-      ieGroupType = _dsClusterIeGroupTypeGet(elem.elementId);
-
-      /* make sure received IE size matches its defined size */
-      elemSize = _dsClusterIeDefinedSizeGet(elem.elementId);
-      CLUSTER_PKT_ELEMENT_SIZE_CHECK(dsCompId, dsClusterDebug, elem, elemSize, offset);
-
-      /* get the table ID and entry pointer for this elem type (if applicable) */
-      tableID = _dsClusterIeTableIdGet(elem.elementId);
-      if (DSMIB_TABLE_ID_NONE != tableID)
-      {
-        pTable = &dsClusterTableParms[tableID];
-      }
-
-      switch (elem.elementId)
-      {
-        case DS_CLUSTER_MSG_IE_CONFIG_START:
-          offset += DS_CLUSTER_MSG_IE_CONFIG_START_SIZE;  /* nothing to process in buffer*/
-          dsClusterRxCfgMsgStarted = L7_TRUE;
-          break;
-
-        case DS_CLUSTER_MSG_IE_GLOBAL_CONFIG:
-          CLUSTER_PKT_INT32_GET(dsClusterRxCfg->adminMode, buffer, offset);
-          break;
-
-        case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
-        case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
-        case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
-        case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
-        case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
-          /* handled below */
-          break;
-
-        case DS_CLUSTER_MSG_IE_CLASS_DEF:
-        case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
-        case DS_CLUSTER_MSG_IE_POLICY_DEF:
-        case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
-        case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
-          /* handled below */
-          break;
-
-        case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
-        case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
-        case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
-        case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
-        case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
-          /* handled below */
-          break;
-
-        case DS_CLUSTER_MSG_IE_CONFIG_END:
-          offset += DS_CLUSTER_MSG_IE_CONFIG_END_SIZE;    /* nothing to process in buffer */
-          dsClusterRxCfgMsgStarted = L7_FALSE;
-          /* display the received config struct based on DiffServ msgLvl setting */
-          if (pDiffServInfo_g->diffServMsgLvl >= DIFFSERV_MSGLVL_LO)
-          {
-            DIFFSERV_CLUSTER_DLOG("%s: DiffServ Cluster Config RX data\n", __FUNCTION__);
-            dsmibConfigDataShow(dsClusterRxCfg);
-          }
-          break;
-
-        default:
-          DIFFSERV_CLUSTER_DLOG("%s: received unknown IE 0x%4.4x (len=%u)\n",
-                                 __FUNCTION__, elem.elementId, elem.elementLen);
-          offset += elem.elementLen;
-          break;
-
-      } /* endswitch */
-
-      /* process IE depending on whether start, def, or end of a group */
-      switch (ieGroupType)
-      {
-        case DS_CLUSTER_IE_GROUP_START:
-          CLUSTER_PKT_INT16_GET(startDefs, buffer, offset);
-          DS_CLUSTER_IE_DEF_COUNT_CHECK(remainDefs, 0);
-          if ((L7_NULLPTR != pTable) &&
-              (startDefs >= pTable->maxEnt))
-          {
-            DIFFSERV_CLUSTER_DLOG("%s: IE 0x%4.4x group start shows %u entries, "
-                                  "but max supported is %u\n",
-                                   __FUNCTION__, elem.elementId, startDefs,
-                                   pTable->maxEnt);
-            dsClusterRxError = L7_TRUE;
-            break;
-          }
-          remainDefs = startDefs;
-          break;
-
-        case DS_CLUSTER_IE_GROUP_DEF:
-          index = startDefs - remainDefs + 1;   /* all cfg table indexes are 1-based */
-          if ((L7_NULLPTR != pTable) &&
-              (L7_NULLPTR != pTable->accessFn))
-          {
-            pTable->accessFn(L7_FALSE, dsClusterRxCfg, index, buffer, &offset);
-          }
-          remainDefs--;
-          break;
-
-        case DS_CLUSTER_IE_GROUP_END:
-          CLUSTER_PKT_INT16_GET(endDefs, buffer, offset);
-          DS_CLUSTER_IE_DEF_COUNT_CHECK(remainDefs, 0);
-          DS_CLUSTER_IE_DEF_COUNT_CHECK(startDefs, endDefs);
-          startDefs = 0;
-          break;
-
-        case DS_CLUSTER_IE_GROUP_NONE:
-        default:
-          break;
-
-      } /* endswitch */
-
-    } while (0);
-
-    if (L7_TRUE == dsClusterRxError)
-    {
-      /* quit processing this and further messages */
-      DIFFSERV_CLUSTER_DLOG("%s: config receive error occurred\n", __FUNCTION__);
-      break;
-    }
-
-  } /* endwhile */
-
-  DIFFSERV_CLUSTER_DLOG("LEAVING %s: rxError=%u\n", __FUNCTION__, dsClusterRxError);
-}
-
-/*********************************************************************
-* @purpose  Sets/Gets DiffServ class config data to/from message buffer
-*
-* @param    L7_BOOL           isSet       @b{(input)} L7_TRUE (set) or L7_FALSE (get)
-* @param    L7_diffServCfg_t  *pCfgData   @b{(input)} operational config data
-* @param    L7_uint32         entryIndex  @b{(input)} config table array index
-* @param    L7_uchar8         *buffer     @b{(inout)} message buffer
-* @param    L7_uint32         *offset     @b{(inout)} current offset in buffer
-*
-* @returns  void
-*
-* @comments Works with a cached copy of current DiffServ operational config data.
-*
-* @comments Assumes caller already checked for sufficient room in msg buffer.
-*
-* @end
-*********************************************************************/
-void diffServClusterConfigClassMsgAccess(L7_BOOL           isSet,
-                                         L7_diffServCfg_t  *pCfgData,
-                                         L7_uint32         entryIndex,
-                                         L7_uchar8         *buffer,
-                                         L7_uint32         *offset)
-{
-  L7_diffServClassHdr_t       *pEntry = &pCfgData->classHdr[entryIndex];
-  L7_uchar8                   rsvd[2] = { 0 };
-  L7_uint32                   aclNum;
-  L7_ACL_TYPE_t               aclType;
-  L7_uchar8                   aclName[L7_ACL_NAME_LEN_MAX+1];
-
-  aclNum = 0;
-  aclType = L7_ACL_TYPE_NONE;
-  memset(aclName, 0, sizeof(aclName));
-
-  /* Need to send the ACL name instead of the ACL index number in the
-   * config message, since named ACL index numbers are not necessarily
-   * the same on the sending and receiving systems.
-   *
-   * An L7_ACL_TYPE_NONE represents an aclNum of 0.  In this case,
-   * the aclName is sent as an empty string ("") and is ignored by the
-   * receiver.
-   */
-  if (L7_TRUE == isSet)
-  {
-    if (0 == pEntry->mib.aclNum)
-    {
-      /* ignoring rc here, since failure to get name causes empty string to be sent
-       * (this condition is checked by receiver)
-       */
-      (void)diffServAclCommonNameStringGet(pEntry->mib.aclNum, &aclType, aclName);
-    }
-  }
-
-  /* 00-03: In-use flag */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->inUse, buffer, offset);
-  /* 04-07: Config array index of first class rule */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->chainIndex, buffer, offset);
-
-  /** Start MIB row definition **/
-
-  /* 08-11: Table row index (class index) */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.index, buffer, offset);
-  /* 12-43: Class name (includes terminating null character) */
-  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pEntry->mib.name, sizeof(pEntry->mib.name), buffer, offset);
-  /* 44-47: Class type */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.type, buffer, offset);
-  /* 48-51: Layer 3 protocol */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.l3Protocol, buffer, offset);
-  /* 52-55: ACL type (for class type ACL) */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, aclType, buffer, offset);
-  /* 56-87: ACL name (for class type ACL) -- null terminated string */
-  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, aclName, sizeof(aclName), buffer, offset);
-  /* 88-91: Next free class rule index */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.ruleIndexNextFree, buffer, offset);
-  /* 92   : Storage type */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.storageType, buffer, offset);
-  /* 93   : Row status */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.rowStatus, buffer, offset);
-
-  /** End MIB row definition **/
-
-  /* 94-95: (Reserved = 0) */
-  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, rsvd, sizeof(rsvd), buffer, offset);
-  /* 96-99: Row invalid object flags */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->rowInvalidFlags, buffer, offset);
-
-  /* Translate ACL type and name received from config message to its
-   * ACL index number on the receiving system.
-   *
-   * An L7_ACL_TYPE_NONE represents an aclNum of 0.  In this case,
-   * the aclName is sent as an empty string ("") and is ignored by the
-   * receiver.
-   *
-   * NOTE: If the name-to-index translation is unsuccessful, just set the
-   *       mib.aclNum value to 0 and keep going.  The config validation checking
-   *       will detect an error when it sees a class type 'acl' with an
-   *       aclNum of 0.
-   */
-  if (L7_FALSE == isSet)
-  {
-    if (L7_ACL_TYPE_NONE != aclType)
-    {
-      if (diffServAclCommonNameToIndex(aclType, aclName, &aclNum) != L7_SUCCESS)
-      {
-        aclNum = 0;
-      }
-    }
-    pEntry->mib.aclNum = aclNum;
-  }
-}
-
-/*********************************************************************
-* @purpose  Sets/Gets DiffServ class rule config data to/from message buffer
-*
-* @param    L7_BOOL           isSet       @b{(input)} L7_TRUE (set) or L7_FALSE (get)
-* @param    L7_diffServCfg_t  *pCfgData   @b{(input)} operational config data
-* @param    L7_uint32         entryIndex  @b{(input)} config table array index
-* @param    L7_uchar8         *buffer     @b{(inout)} message buffer
-* @param    L7_uint32         *offset     @b{(inout)} current offset in buffer
-*
-* @returns  void
-*
-* @comments Works with a cached copy of current DiffServ operational config data.
-*
-* @comments Assumes caller already checked for sufficient room in msg buffer.
-*
-* @end
-*********************************************************************/
-void diffServClusterConfigClassRuleMsgAccess(L7_BOOL           isSet,
-                                             L7_diffServCfg_t  *pCfgData,
-                                             L7_uint32         entryIndex,
-                                             L7_uchar8         *buffer,
-                                             L7_uint32         *offset)
-{
-  L7_diffServClassRule_t      *pEntry = &pCfgData->classRule[entryIndex];
-  L7_uchar8                   rsvd[1] = { 0 };
-  dsmibClassRuleData_t        *pMatch;
-  dsmibClassRuleType_t        entryType;
-
-  /* 00-03: Config array index of parent class */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->hdrIndexRef, buffer, offset);
-  /* 04-07: Config array index of next sequential class rule */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->chainIndex, buffer, offset);
-
-  /** Start MIB row definition **/
-
-  /* 08-11: Table row index (class rule index) */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.index, buffer, offset);
-  /* 12-15: Class rule entry type */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.entryType, buffer, offset);
-
-  /* set up an entry type variable for type-specific field processing */
-  entryType = pEntry->mib.entryType;
-
-  /* set ptr to mib.match fields for convenience */
-  pMatch = &pEntry->mib.match;
-
-  /* 16-19: General value (per entryType) */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_COS:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->cos, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_COS2:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->cos2, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_ETYPE:
-      DS_CLUSTER_PKT_INT16_GET_OR_SET(isSet, pMatch->etype.keyid, buffer, offset);
-      DS_CLUSTER_PKT_INT16_GET_OR_SET(isSet, pMatch->etype.value, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_EVERY:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->matchEvery, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_FLOWLBLV6:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->ipv6FlowLabel, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_IPDSCP:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->ipDscp, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_IPPRECEDENCE:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->ipPrecedence, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_IPTOS:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pMatch->ipTos.bits, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pMatch->ipTos.mask, buffer, offset);
-      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->ipTos.rsvd1,
-                                       sizeof(pMatch->ipTos.rsvd1),
-                                       buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_PROTOCOL:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->protocolNum, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_REFCLASS:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->refClassIndex, buffer, offset);
-      break;
-    default:
-      *offset += sizeof(L7_uint32);
-      break;
-  }
-  /* 20-27: IPv4 address (per entryType) */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTIP:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->dstIp.addr, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->dstIp.mask, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCIP:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->srcIp.addr, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->srcIp.mask, buffer, offset);
-      break;
-    default:
-      *offset += (2 * sizeof(L7_uint32));
-      break;
-  }
-  /* 28-47: IPv6 address (per entryType) */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTIPV6:
-      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->dstIpv6.ip6prefix.in6Addr.in6.addr8, IPV6_ADDRESS_LEN, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->dstIpv6.ip6prefix.in6PrefixLen, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCIPV6:
-      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->srcIpv6.ip6prefix.in6Addr.in6.addr8, IPV6_ADDRESS_LEN, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->srcIpv6.ip6prefix.in6PrefixLen, buffer, offset);
-      break;
-    default:
-      *offset += (IPV6_ADDRESS_LEN + sizeof(L7_uint32));
-      break;
-  }
-  /* 48-55: Numeric range (per entryType) */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTL4PORT:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->dstL4Port.start, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->dstL4Port.end, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCL4PORT:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->srcL4Port.start, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->srcL4Port.end, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_VLANID:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->vlanId.start, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->vlanId.end, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_VLANID2:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->vlanId2.start, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->vlanId2.end, buffer, offset);
-      break;
-    default:
-      *offset += (2 * sizeof(L7_uint32));
-      break;
-  }
-  /* 52-63: MAC address (per entryType) */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTMAC:
-      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->dstMac.addr, L7_MAC_ADDR_LEN, buffer, offset);
-      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->dstMac.mask, L7_MAC_ADDR_LEN, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCMAC:
-      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->srcMac.addr, L7_MAC_ADDR_LEN, buffer, offset);
-      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->srcMac.mask, L7_MAC_ADDR_LEN, buffer, offset);
-      break;
-    default:
-      *offset += (2 * L7_MAC_ADDR_LEN);
-      break;
-  }
-  /* 64   : Exclude flag */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.excludeFlag, buffer, offset);
-  /* 65   : Storage type */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.storageType, buffer, offset);
-  /* 66   : Row status */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.rowStatus, buffer, offset);
-
-  /** End MIB row definition **/
-
-  /* 67   : (Reserved = 0) */
-  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, rsvd, sizeof(rsvd), buffer, offset);
-  /* 68-71: Row invalid object flags */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->rowInvalidFlags, buffer, offset);
-  /* 72-75: ACL rule identifier origin */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->arid, buffer, offset);
-}
-
-/*********************************************************************
-* @purpose  Sets/Gets DiffServ policy config data to/from message buffer
-*
-* @param    L7_BOOL           isSet       @b{(input)} L7_TRUE (set) or L7_FALSE (get)
-* @param    L7_diffServCfg_t  *pCfgData   @b{(input)} operational config data
-* @param    L7_uint32         entryIndex  @b{(input)} config table array index
-* @param    L7_uchar8         *buffer     @b{(inout)} message buffer
-* @param    L7_uint32         *offset     @b{(inout)} current offset in buffer
-*
-* @returns  void
-*
-* @comments Works with a cached copy of current DiffServ operational config data.
-*
-* @comments Assumes caller already checked for sufficient room in msg buffer.
-*
-* @end
-*********************************************************************/
-void diffServClusterConfigPolicyMsgAccess(L7_BOOL           isSet,
-                                          L7_diffServCfg_t  *pCfgData,
-                                          L7_uint32         entryIndex,
-                                          L7_uchar8         *buffer,
-                                          L7_uint32         *offset)
-{
-  L7_diffServPolicyHdr_t      *pEntry = &pCfgData->policyHdr[entryIndex];
-  L7_uchar8                   rsvd[1] = { 0 };
-
-  /* 00-03: In-use flag */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->inUse, buffer, offset);
-  /* 04-07: Config array index of first policy instance */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->chainIndex, buffer, offset);
-
-  /** Start MIB row definition **/
-
-  /* 08-11: Table row index (policy index) */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.index, buffer, offset);
-  /* 12-43: Policy name (includes terminating null character) */
-  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pEntry->mib.name, sizeof(pEntry->mib.name), buffer, offset);
-  /* 44-47: Next free policy instance index */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.instIndexNextFree, buffer, offset);
-  /* 49   : Policy type */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.type, buffer, offset);
-  /* 49   : Storage type */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.storageType, buffer, offset);
-  /* 50   : Row status */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.rowStatus, buffer, offset);
-
-  /** End MIB row definition **/
-
-  /* 51   : (Reserved = 0) */
-  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, rsvd, sizeof(rsvd), buffer, offset);
-  /* 52-55: Row invalid object flags */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->rowInvalidFlags, buffer, offset);
-}
-
-/*********************************************************************
-* @purpose  Sets/Gets DiffServ policy instance config data to/from message buffer
-*
-* @param    L7_BOOL           isSet       @b{(input)} L7_TRUE (set) or L7_FALSE (get)
-* @param    L7_diffServCfg_t  *pCfgData   @b{(input)} operational config data
-* @param    L7_uint32         entryIndex  @b{(input)} config table array index
-* @param    L7_uchar8         *buffer     @b{(inout)} message buffer
-* @param    L7_uint32         *offset     @b{(inout)} current offset in buffer
-*
-* @returns  void
-*
-* @comments Works with a cached copy of current DiffServ operational config data.
-*
-* @comments Assumes caller already checked for sufficient room in msg buffer.
-*
-* @end
-*********************************************************************/
-void diffServClusterConfigPolicyInstMsgAccess(L7_BOOL           isSet,
-                                              L7_diffServCfg_t  *pCfgData,
-                                              L7_uint32         entryIndex,
-                                              L7_uchar8         *buffer,
-                                              L7_uint32         *offset)
-{
-  L7_diffServPolicyInst_t     *pEntry = &pCfgData->policyInst[entryIndex];
-  L7_uchar8                   rsvd[2] = { 0 };
-
-  /* 00-03: Config array index of parent policy */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->hdrIndexRef, buffer, offset);
-  /* 04-07: Config array index of first policy attribute */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->attrChainIndex, buffer, offset);
-  /* 08-11: Config array index of next sequential policy instance */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->chainIndex, buffer, offset);
-
-  /** Start MIB row definition **/
-
-  /* 12-15: Table row index (policy instance index) */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.index, buffer, offset);
-  /* 16-19: Class index */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.classIndex, buffer, offset);
-  /* 20-23: Next free policy attribute index */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.attrIndexNextFree, buffer, offset);
-  /* 24   : Storage type */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.storageType, buffer, offset);
-  /* 25   : Row status */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.rowStatus, buffer, offset);
-
-  /** End MIB row definition **/
-
-  /* 26-27: (Reserved = 0) */
-  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, rsvd, sizeof(rsvd), buffer, offset);
-  /* 28-31: Row invalid object flags */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->rowInvalidFlags, buffer, offset);
-}
-
-/*********************************************************************
-* @purpose  Sets/Gets DiffServ policy attribute config data to/from message buffer
-*
-* @param    L7_BOOL           isSet       @b{(input)} L7_TRUE (set) or L7_FALSE (get)
-* @param    L7_diffServCfg_t  *pCfgData   @b{(input)} operational config data
-* @param    L7_uint32         entryIndex  @b{(input)} config table array index
-* @param    L7_uchar8         *buffer     @b{(inout)} message buffer
-* @param    L7_uint32         *offset     @b{(inout)} current offset in buffer
-*
-* @returns  void
-*
-* @comments Works with a cached copy of current DiffServ operational config data.
-*
-* @comments Assumes caller already checked for sufficient room in msg buffer.
-*
-* @end
-*********************************************************************/
-void diffServClusterConfigPolicyAttrMsgAccess(L7_BOOL           isSet,
-                                              L7_diffServCfg_t  *pCfgData,
-                                              L7_uint32         entryIndex,
-                                              L7_uchar8         *buffer,
-                                              L7_uint32         *offset)
-{
-  L7_diffServPolicyAttr_t     *pEntry = &pCfgData->policyAttr[entryIndex];
-  dsmibPolicyAttrType_t       entryType;
-  dsmibPolicyAttrData_t       *pStmt;
-  L7_uchar8                   rsvd[2] = { 0 };
-
-  /* 00-03: Config array index of parent policy */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->instIndexRef, buffer, offset);
-  /* 04-07: Config array index of next sequential policy attribute */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->chainIndex, buffer, offset);
-
-  /** Start MIB row definition **/
-
-  /* NOTE: Some of the field accesses that follow are contingent upon the entryType.
-   *       If data is not defined for a particular entryType, its location in the
-   *       message buffer is accounted for, but is bypassed.
-   */
-
-  pStmt = &pEntry->mib.stmt;            /* set ptr to mib.stmt fields for convenience */
-
-  /* 08-11: Table row index (policy attribute index) */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.index, buffer, offset);
-  /* 12-15: Policy attribute entry type */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.entryType, buffer, offset);
-
-  /* set up an entry type variable for type-specific field processing */
-  entryType = pEntry->mib.entryType;
-
-  /* 16   : Queue Id */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_ASSIGN_QUEUE:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->assignQueue.qid, buffer, offset);
-      break;
-    default:
-      *offset += sizeof(L7_uchar8);
-      break;
-  }
-  /* 17   : Boolean flag */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_DROP:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->drop, buffer, offset);
-      break;
-    default:
-      *offset += sizeof(L7_uchar8);
-      break;
-  }
-  /* 18   : Mark value */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COSVAL:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->markCos.val, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COS2VAL:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->markCos2.val, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COS_AS_COS2:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->markCosAsCos2.val, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->markIpDscp.val, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPPRECEDENCEVAL:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->markIpPrecedence.val, buffer, offset);
-      break;
-    default:
-      *offset += sizeof(L7_uchar8);
-      break;
-  }
-  /* 19   : (Reserved = 0) */
-  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, rsvd, sizeof(rsvd[0]), buffer, offset);
-  /* 20-27: NIM config Id */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MIRROR:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->mirror.configId.type, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->mirror.configId.configSpecifier.usp.unit, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->mirror.configId.configSpecifier.usp.slot, buffer, offset);
-      DS_CLUSTER_PKT_INT16_GET_OR_SET(isSet, pStmt->mirror.configId.configSpecifier.usp.port, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_REDIRECT:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->redirect.configId.type, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->redirect.configId.configSpecifier.usp.unit, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->redirect.configId.configSpecifier.usp.slot, buffer, offset);
-      DS_CLUSTER_PKT_INT16_GET_OR_SET(isSet, pStmt->redirect.configId.configSpecifier.usp.port, buffer, offset);
-      break;
-    default:
-      *offset += (sizeof(L7_uint32) + (2 * sizeof(L7_uchar8)) + sizeof(L7_ushort16));
-      break;
-  }
-  /* 28-31: Policing C-rate
-   * 32-35: Policing C-burst
-   */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SIMPLE:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSimple.crate, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSimple.cburst, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.crate, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.cburst, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.crate, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.cburst, buffer, offset);
-      break;
-    default:
-      *offset += (2 * sizeof(L7_uint32));
-      break;
-  }
-  /* 36-39: Policing E-rate/P-rate
-   * 40-43: Policing E-burst/P-burst
-   */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.crate, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.eburst, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.prate, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.pburst, buffer, offset);
-      break;
-    default:
-      *offset += (2 * sizeof(L7_uint32));
-      break;
-  }
-  /* 44   : Policing C-action
-   * 45   : Policing C-mark
-   * 46   : Policing E-action
-   * 47   : Policing E-mark
-   * 48   : Policing N-action
-   * 49   : Policing N-mark
-   */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SIMPLE:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.conformAct, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.conformVal, buffer, offset);
-      *offset += (2 * sizeof(L7_uchar8));       /* E-action, E-mark not used */
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.nonconformAct, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.nonconformVal, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.conformAct, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.conformVal, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.exceedAct, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.exceedVal, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.nonconformAct, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.nonconformVal, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.conformAct, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.conformVal, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.exceedAct, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.exceedVal, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.nonconformAct, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.nonconformVal, buffer, offset);
-      break;
-    default:
-      *offset += (6 * sizeof(L7_uchar8));
-      break;
-  }
-  /* 50   : Policing C-color mode
-   * 51   : Policing C-color value
-   * 52-55: Policing C-color index
-   */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SIMPLE:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.colorConformMode, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.colorConformVal, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSimple.colorConformIndex, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.colorConformMode, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.colorConformVal, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.colorConformIndex, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE:
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.colorConformMode, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.colorConformVal, buffer, offset);
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.colorConformIndex, buffer, offset);
-      break;
-    default:
-      *offset += ((2 * sizeof(L7_uchar8)) + sizeof(L7_uint32));
-      break;
-  }
-  /* 56-59: Policing E-color index
-   * 60   : Policing E-color mode
-   * 61   : Policing E-color value
-   */
-  switch (entryType)
-  {
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.colorExceedIndex, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.colorExceedMode, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.colorExceedVal, buffer, offset);
-      break;
-    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE:
-      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.colorExceedIndex, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.colorExceedMode, buffer, offset);
-      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.colorExceedVal, buffer, offset);
-      break;
-    default:
-      *offset += (sizeof(L7_uint32) + (2 * sizeof(L7_uchar8)));
-      break;
-  }
-  /* 62   : Storage type */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.storageType, buffer, offset);
-  /* 63   : Row status */
-  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.rowStatus, buffer, offset);
-
-  /** End MIB row definition **/
-
-  /* 64-67: Row invalid object flags */
-  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->rowInvalidFlags, buffer, offset);
-}
-
-/*********************************************************************
-* @purpose  Function to send DiffServ global config to cluster member
-*
-* @param    L7_diffServCfg_t  *pCfgData  @b{(input)} operational config data
-* @param    clusterMemberID_t *memberID  @b{(input)} cluster member
-* @param    L7_uchar8         *buffer @b{(input/output)} message buffer
-* @param    L7_uint32         *offset @b{(input/output)} current offset in buffer
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @comments Works with a cached copy of current DiffServ operational config data.
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigGlobalSend(L7_diffServCfg_t  *pCfg,
-                                        clusterMemberID_t *memberID,
-                                        L7_uchar8         *buffer,
-                                        L7_uint32         *offset)
-{
-  L7_uint32         dataSize;
-
-  dataSize = (1 * sizeof(clusterMsgElementHdr_t)) +
-             DS_CLUSTER_MSG_IE_GLOBAL_CONFIG_SIZE;
-  if (diffServClusterConfigMsgSendCheck(dataSize, memberID, buffer, offset) != L7_SUCCESS)
-  {
-    return L7_FAILURE;
-  }
-  CLUSTER_PKT_ELEMENT_HDR_SET(DS_CLUSTER_MSG_IE_GLOBAL_CONFIG,
-                              DS_CLUSTER_MSG_IE_GLOBAL_CONFIG_SIZE,
-                              buffer, *offset);
-  CLUSTER_PKT_INT32_SET(pCfg->adminMode, buffer, *offset);
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Function to send DiffServ table config to cluster member
-*
-* @param    dsmibTableId_t    tableID     @b{(input)} DiffServ table identifier
-* @param    L7_diffServCfg_t  *pCfg       @b{(input)} operational config data
-* @param    clusterMemberID_t *memberID   @b{(input)} cluster member
-* @param    L7_uchar8         *buffer     @b{(input/output)} message buffer
-* @param    L7_uint32         *offset     @b{(input/output)} current offset in buffer
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @comments This is a generic function that handles building the common parts
-*           of the DiffServ table-based configuration in the cluster config msg.
-*           Only certain table IDs are supported.
-*
-* @comments Works with a cached copy of current DiffServ operational config data.
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigTableSend(dsmibTableId_t    tableID,
-                                       L7_diffServCfg_t  *pCfg,
-                                       clusterMemberID_t *memberID,
-                                       L7_uchar8         *buffer,
-                                       L7_uint32         *offset)
-{
-  L7_uint32                   i, dataSize;
-  L7_uint32                   startEnt, maxEnt;
-  L7_ushort16                 defType, defSize;
-  L7_ushort16                 numEnt = 0;
-  L7_uint32                   configStartOffset;
-  dsClusterTableParms_t       *pTable;
-
-  if ((tableID < DSMIB_TABLE_ID_CLASS) ||
-      (tableID > DSMIB_TABLE_ID_POLICY_ATTR))
-  {
-    return L7_FAILURE;
-  }
-
-  pTable = &dsClusterTableParms[tableID];
-  if (L7_NULLPTR == pTable->accessFn)
-  {
-    return L7_FAILURE;
-  }
-
-  startEnt = pTable->startEnt;
-  maxEnt   = pTable->maxEnt;
-
-  defType = pTable->defType;
-  defSize = pTable->defTypeSize;
-
-  /* Config Start IE */
-  dataSize = sizeof(clusterMsgElementHdr_t) + pTable->startTypeSize;
-  if (diffServClusterConfigMsgSendCheck(dataSize, memberID, buffer, offset) != L7_SUCCESS)
-  {
-    return L7_FAILURE;
-  }
-  CLUSTER_PKT_ELEMENT_HDR_SET(pTable->startType, pTable->startTypeSize,
-                              buffer, *offset);
-  /* save current offset to go back and fill in actual number of entries later */
-  configStartOffset = *offset;
-  CLUSTER_PKT_INT16_SET(numEnt, buffer, *offset);   /* sets num entries to 0 for now */
-
-
-  /* iterate through each configured entry */
-  dataSize = sizeof(clusterMsgElementHdr_t) + defSize;
-  for (i = startEnt; i < maxEnt; i++)
-  {
-    /* array entry not in use means end of the configured list */
-    if (_dsClusterConfigEntryInUseGet(tableID, pCfg, i) != L7_TRUE)
-      break;
-
-    if (diffServClusterConfigMsgSendCheck(dataSize, memberID, buffer, offset) != L7_SUCCESS)
-    {
-      return L7_FAILURE;
-    }
-    CLUSTER_PKT_ELEMENT_HDR_SET(defType, defSize, buffer, *offset);
-
-    /* invoke table-specific access function to send msg def IE for this entry */
-    pTable->accessFn(L7_TRUE, pCfg, i, buffer, offset);
-
-  } /* endfor i */
-
-  numEnt = i - startEnt;
-
-  /* fill in config start number of entries using saved buffer offset*/
-  CLUSTER_PKT_INT16_SET(numEnt, buffer, configStartOffset);
-
-  /* Config End IE */
-  dataSize = sizeof(clusterMsgElementHdr_t) + pTable->endTypeSize;
-  if (diffServClusterConfigMsgSendCheck(dataSize, memberID, buffer, offset) != L7_SUCCESS)
-  {
-    return L7_FAILURE;
-  }
-  CLUSTER_PKT_ELEMENT_HDR_SET(pTable->endType, pTable->endTypeSize, buffer, *offset);
-  CLUSTER_PKT_INT16_SET(numEnt, buffer, *offset);
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Function to send configuration to cluster member
-*
-* @param    clusterMemberID_t *memberID  @b{(input)} cluster member
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigSend(clusterMemberID_t *memberID)
-{
-  L7_RC_t               rc = L7_SUCCESS;
-  L7_char8              peerMacStr[L7_MAC_ADDR_STRING_LEN+1];
-  L7_uchar8             buffer[DS_CLUSTER_MSG_SIZE_MAX];
-  L7_uint32             offset = 0;
-  dsmibTableId_t        tableID;
-
-  if (l7utilsMacAddrHexToString(memberID->addr,
-                                sizeof(peerMacStr), peerMacStr) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: Received invalid memberID.\n", __FUNCTION__);
-    return L7_FAILURE;
-  }
-
-  DIFFSERV_CLUSTER_DLOG("%s: member ID=%s\n", __FUNCTION__, peerMacStr);
-
-  /* init cluster tx struct */
-  if (L7_NULLPTR == dsClusterTxCfg)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: Error - DiffServ cluster TX config struct not allocated.\n", __FUNCTION__);
-    return L7_FAILURE;
-  }
-  _dsClusterCfgStructInit(dsClusterTxCfg, "dsClusterTxCfg");
-
-  /* read all of the DiffServ operational config into the tx struct */
-  do
-  {
-    DIFFSERV_SEMA_TAKE(dsmibIndexSemId, L7_WAIT_FOREVER);
-    if (diffServBuildUserConfigData(L7_DIFFSERV_CFG_VER_CURRENT, dsClusterTxCfg) != L7_SUCCESS)
-    {
-      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-              "%s: Error extracting DiffServ operational config data.\n", __FUNCTION__);
-      rc = L7_FAILURE;
-      break;
-    }
-    dsClusterTxCfg->checkSum = 0;
-    dsClusterTxCfg->checkSum = nvStoreCrc32((L7_uchar8 *)dsClusterTxCfg, L7_DIFFSERV_CFG_DATA_SIZE);
-    DIFFSERV_SEMA_GIVE(dsmibIndexSemId);
-
-    /* init the msg buffer */
-    memset(buffer, 0, sizeof(buffer));
-    offset = 0;
-
-    CLUSTER_PKT_ELEMENT_HDR_SET(DS_CLUSTER_MSG_IE_CONFIG_START,
-                                DS_CLUSTER_MSG_IE_CONFIG_START_SIZE,
-                                buffer, offset);
-
-    if (diffServClusterConfigGlobalSend(dsClusterTxCfg, memberID, buffer, &offset) != L7_SUCCESS)
-    {
-      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-              "%s: Error sending DiffServ global config to peer switch %s.\n",
-              __FUNCTION__, peerMacStr);
-      rc = L7_FAILURE;
-      break;
-    }
-
-    for (tableID = DSMIB_TABLE_ID_CLASS; tableID <= DSMIB_TABLE_ID_POLICY_ATTR; tableID++)
-    {
-      if (diffServClusterConfigTableSend(tableID, dsClusterTxCfg, memberID, buffer, &offset) != L7_SUCCESS)
-      {
-        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-                "%s: Error sending DiffServ %s table config to peer switch %s.\n",
-                __FUNCTION__, dsmibPrvtTableIdStr[tableID], peerMacStr);
-        rc = L7_FAILURE;
-        break;
-      }
-    }
-
-    /* display the sent config struct based on DiffServ msgLvl setting */
-    if (pDiffServInfo_g->diffServMsgLvl >= DIFFSERV_MSGLVL_LO)
-    {
-      dsmibConfigDataShow(dsClusterTxCfg);
-    }
-
-  } while (0);
-
-  if (L7_SUCCESS != rc)
-  {
-    return L7_FAILURE;
-  }
-
-  if (diffServClusterConfigMsgSendCheck(sizeof(clusterMsgElementHdr_t) +
-                                        DS_CLUSTER_MSG_IE_CONFIG_END_SIZE,
-                                        memberID, buffer, &offset) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: Error sending DiffServ config to peer switch.\n", __FUNCTION__);
-    return L7_FAILURE;
-  }
-
-  CLUSTER_PKT_ELEMENT_HDR_SET(DS_CLUSTER_MSG_IE_CONFIG_END,
-                              DS_CLUSTER_MSG_IE_CONFIG_END_SIZE,
-                              buffer, offset);
-
-  rc = clusterMsgSend(memberID, CLUSTER_MSG_DELIVERY_RELIABLE, DS_CLUSTER_MSG_CONFIG,
-                      offset, buffer);
-
-  DIFFSERV_CLUSTER_DLOG("%s: DiffServ Cluster Config data (len=%u) sent to peer switch %s, rc=%d\n",
-                        __FUNCTION__, offset, peerMacStr, rc);
-
-  return rc;
-}
-
-/*********************************************************************
-* @purpose  Check if room in message buffer to add IE, send and clear
-*           buffer when max message size is reached.
-*
-* @param    L7_uint32          size      @b{(input)} IE size to write
-* @param    clusterMemberID_t *memberID  @b{(input)} cluster member
-* @param    L7_uchar8         *buffer    @b{(inout)} message buffer
-* @param    L7_uint32         *offset    @b{(inout)} offset in buffer
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigMsgSendCheck(L7_uint32          size,
-                                          clusterMemberID_t *memberID,
-                                          L7_uchar8         *buffer,
-                                          L7_uint32         *offset)
-{
-  if (((*offset) + size) >= DS_CLUSTER_MSG_SIZE_MAX)
-  {
-    if (clusterMsgSend(memberID, CLUSTER_MSG_DELIVERY_RELIABLE,
-                       DS_CLUSTER_MSG_CONFIG,
-                       (*offset), buffer) != L7_SUCCESS)
-    {
-      DIFFSERV_CLUSTER_DLOG("%s: clusterMsgSend() call failed\n", __FUNCTION__);
-      return L7_FAILURE;
-    }
-    memset(buffer, 0, DS_CLUSTER_MSG_SIZE_MAX);
-    (*offset) = 0;
-  }
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Verify received DiffServ class config against system
-*           defines and features
-*
-* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
-* @param    L7_uint32         entryIndex  @b{(input)} config table array index
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    This assumes data has already been validated by the sender,
-*           so we can skip basic checks, such as range checking.  However,
-*           this system may not have the same prod/plat defines or features
-*           enabled, so need to fail if we cannot apply entire configuration.
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigClassVerify(L7_diffServCfg_t *pCfgData,
-                                         L7_uint32        entryIndex)
-{
-  L7_diffServClassHdr_t       *pEntry = &pCfgData->classHdr[entryIndex];
-  L7_uint32                   i, num = 0, lim = L7_DIFFSERV_RULE_PER_CLASS_LIM;
-
-  /* make sure current number of rules per class is within supported limit
-   *
-   * NOTE: For accuracy, search the hdrIndex field in the Class Rule table
-   *       and count the number of occurrences of this class entryIndex.
-   */
-  for (i = L7_DIFFSERV_CLASS_RULE_START; i < L7_DIFFSERV_CLASS_RULE_MAX; i++)
-  {
-    if (pCfgData->classRule[i].hdrIndexRef == entryIndex)
-    {
-      num++;
-    }
-  }
-  if (num > lim)
-  {
-    DIFFSERV_CLUSTER_DLOG("%s: too many rules (%u) for class \'%s\' - max=%u\n",
-                          __FUNCTION__, num, pEntry->mib.name, lim);
-    return L7_FAILURE;
-  }
-
-  /* check feature support */
-  if (dsmibClassFeaturePresentCheck(pEntry->mib.type) != L7_SUCCESS)
-  {
-    DIFFSERV_CLUSTER_DLOG("%s: class type \'%s\' not supported\n",
-                          __FUNCTION__, dsmibClassTypeStr[pEntry->mib.type]);
-    return L7_FAILURE;
-  }
-  if (dsmibClassProtoFeaturePresentCheck(pEntry->mib.l3Protocol) != L7_SUCCESS)
-  {
-    DIFFSERV_CLUSTER_DLOG("%s: class layer3 protocol \'%s\' not supported\n",
-                          __FUNCTION__, dsmibClassL3ProtoStr[pEntry->mib.l3Protocol]);
-    return L7_FAILURE;
-  }
-
-  /* for class type 'acl', check if aclType and aclNum are valid
-   *
-   * NOTE: Can only check this general case, since DiffServ does not
-   *       attempt to keep current with the latest ACL definition.  It
-   *       is possible to delete an ACL after it was used to create a
-   *       DiffServ class from it, so cannot check whether this ACL
-   *       currently exists.
-   */
-  if (L7_USMDB_MIB_DIFFSERV_CLASS_TYPE_ACL == pEntry->mib.type)
-  {
-    if ((L7_USMDB_MIB_DIFFSERV_CLASS_ACLTYPE_NONE == pEntry->mib.aclType) ||
-        (0 == pEntry->mib.aclNum))
-    {
-      DIFFSERV_CLUSTER_DLOG("%s: class type \'acl\' aclType or aclNum invalid\n",
-                            __FUNCTION__);
-      return L7_FAILURE;
-    }
-  }
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Verify received DiffServ class rule config against
-*           system defines and features
-*
-* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
-* @param    L7_uint32         entryIndex  @b{(input)} config table array index
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    This assumes data has already been validated by the sender,
-*           so we can skip basic checks, such as range checking.  However,
-*           this system may not have the same prod/plat defines or features
-*           enabled, so need to fail if we cannot apply entire configuration.
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigClassRuleVerify(L7_diffServCfg_t *pCfgData,
-                                             L7_uint32        entryIndex)
-{
-  L7_diffServClassRule_t      *pEntry = &pCfgData->classRule[entryIndex];
-  L7_uchar8                   nullMac[L7_MAC_ADDR_LEN] = { 0 };
-  dsmibClassRuleType_t        entryType;
-  dsmibClassRuleData_t        *pMatch;
-  L7_uint32                   range1, range2;
-  L7_BOOL                     isMasked;
-
-  entryType = pEntry->mib.entryType;
-  pMatch = &pEntry->mib.match;
-
-  /* check entry type feature support */
-  if (dsmibClassRuleFeaturePresentCheck(entryType) != L7_SUCCESS)
-  {
-    DIFFSERV_CLUSTER_DLOG("%s: rule type \'%s\' not supported\n",
-                          __FUNCTION__, dsmibClassRuleTypeStr[entryType]);
-    return L7_FAILURE;
-  }
-
-  /* check exclude flag feature support */
-  if (cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_CLASS_MATCH_EXCLUDE_FEATURE_ID)
-      != L7_TRUE)
-  {
-    if (L7_USMDB_MIB_DIFFSERV_TRUTH_VALUE_TRUE == pEntry->mib.excludeFlag)
-    {
-      DIFFSERV_CLUSTER_DLOG("%s: exclude flag not supported\n", __FUNCTION__);
-      return L7_FAILURE;
-    }
-  }
-
-  /* check masking feature support */
-  if (cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_CLASS_MATCH_SUPPORTS_MASKING_FEATURE_ID)
-      != L7_TRUE)
-  {
-    isMasked = L7_FALSE;
-    switch (entryType)
-    {
-      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTIP:
-        isMasked = (0 != pEntry->mib.match.dstIp.mask)
-                    ? L7_TRUE : L7_FALSE;
-        break;
-
-      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTIPV6:
-        isMasked = (0 != pEntry->mib.match.dstIpv6.ip6prefix.in6PrefixLen)
-                    ? L7_TRUE : L7_FALSE;
-        break;
-
-      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTMAC:
-        isMasked = (0 != memcmp(pEntry->mib.match.dstMac.mask, nullMac, sizeof(nullMac)))
-                    ? L7_TRUE : L7_FALSE;
-        break;
-
-      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCIP:
-        isMasked = (0 != pEntry->mib.match.srcIp.mask)
-                    ? L7_TRUE : L7_FALSE;
-        break;
-
-      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCIPV6:
-        isMasked = (0 != pEntry->mib.match.srcIpv6.ip6prefix.in6PrefixLen)
-                    ? L7_TRUE : L7_FALSE;
-        break;
-
-      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCMAC:
-        isMasked = (0 != memcmp(pEntry->mib.match.srcMac.mask, nullMac, sizeof(nullMac)))
-                    ? L7_TRUE : L7_FALSE;
-        break;
-
-      default:
-        break;
-
-    } /* endswitch */
-    if (L7_TRUE == isMasked)
-    {
-      DIFFSERV_CLUSTER_DLOG("%s: class rule type \'%s\' masking not supported\n",
-                            __FUNCTION__, dsmibClassRuleTypeStr[entryType]);
-      return L7_FAILURE;
-    }
-
-  } /* endif masking feature check */
-
-  /* check range feature support */
-  if (cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_CLASS_MATCH_SUPPORTS_RANGES_FEATURE_ID)
-      != L7_TRUE)
-  {
-    range1 = range2 = 0;
-    switch (entryType)
-    {
-      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTL4PORT:
-        range1 = pMatch->dstL4Port.start;
-        range2 = pMatch->dstL4Port.end;
-        break;
-
-      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCL4PORT:
-        range1 = pMatch->srcL4Port.start;
-        range2 = pMatch->srcL4Port.end;
-        break;
-
-      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_VLANID:
-        range1 = pMatch->vlanId.start;
-        range2 = pMatch->vlanId.end;
-        break;
-
-      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_VLANID2:
-        range1 = pMatch->vlanId2.start;
-        range2 = pMatch->vlanId2.end;
-        break;
-
-      default:
-        break;
-
-    } /* endswitch */
-    if (range1 != range2)
-    {
-      DIFFSERV_CLUSTER_DLOG("%s: class rule type \'%s\' range not supported\n",
-                            __FUNCTION__, dsmibClassRuleTypeStr[entryType]);
-      return L7_FAILURE;
-    }
-  } /* endif range feature check */
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Verify received DiffServ policy config against
-*           system defines and features
-*
-* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
-* @param    L7_uint32         entryIndex  @b{(input)} config table array index
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    This assumes data has already been validated by the sender,
-*           so we can skip basic checks, such as range checking.  However,
-*           this system may not have the same prod/plat defines or features
-*           enabled, so need to fail if we cannot apply entire configuration.
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigPolicyVerify(L7_diffServCfg_t *pCfgData,
-                                          L7_uint32        entryIndex)
-{
-  L7_diffServPolicyHdr_t      *pEntry = &pCfgData->policyHdr[entryIndex];
-  L7_diffServPolicyInst_t     *pInstEntry;
-  L7_diffServClassHdr_t       *pClassEntry;
-  L7_diffServClassRule_t      *pRuleEntry;
-  L7_uint32                   instIndex;
-  L7_uint32                   classIndex, refClassIndex, classRuleIndex;
-  dsmibClassL3Protocol_t      savedL3Protocol, classL3Protocol;
-  L7_uint32                   num = 0, lim = L7_DIFFSERV_INST_PER_POLICY_LIM;
-
-  /* make sure current number of instances per policy is within supported limit
-   *
-   * NOTE: For accuracy, search the hdrIndex field in the Policy Inst table
-   *       and count the number of occurrences of this policy entryIndex.
-   */
-  if (diffServClusterPolicyInstCountGet(entryIndex, &num) != L7_SUCCESS)
-  {
-    DIFFSERV_CLUSTER_DLOG("%s: error obtaining instance count for policy \'%s\'\n",
-                          __FUNCTION__, pEntry->mib.name);
-    return L7_FAILURE;
-  }
-  if (num > lim)
-  {
-    DIFFSERV_CLUSTER_DLOG("%s: too many instances (%u) for policy \'%s\' - max=%u\n",
-                          __FUNCTION__, num, pEntry->mib.name, lim);
-    return L7_FAILURE;
-  }
-
-  /* check policy type feature support
-   *
-   * NOTE: There is no specific feature ID for the policy type, so check the
-   *       service interface direction support instead, since this is how the
-   *       user interface controls whether to allow certain policy types to be
-   *       created.
-   */
-  if ((cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_SERVICE_IN_SLOTPORT_FEATURE_ID)
-       != L7_TRUE) &&
-      (cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_SERVICE_IN_ALLPORTS_FEATURE_ID)
-       != L7_TRUE))
-  {
-    if (L7_USMDB_MIB_DIFFSERV_POLICY_TYPE_IN == pEntry->mib.type)
-    {
-      DIFFSERV_CLUSTER_DLOG("%s: policy type \'%s\' not supported\n",
-                            __FUNCTION__, dsmibPolicyTypeStr[pEntry->mib.type]);
-      return L7_FAILURE;
-    }
-  }
-  if ((cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_SERVICE_OUT_SLOTPORT_FEATURE_ID)
-       != L7_TRUE) &&
-      (cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_SERVICE_OUT_ALLPORTS_FEATURE_ID)
-       != L7_TRUE))
-  {
-    if (L7_USMDB_MIB_DIFFSERV_POLICY_TYPE_OUT == pEntry->mib.type)
-    {
-      DIFFSERV_CLUSTER_DLOG("%s: policy type \'%s\' not supported\n",
-                            __FUNCTION__, dsmibPolicyTypeStr[pEntry->mib.type]);
-      return L7_FAILURE;
-    }
-  }
-
-  /* check feature that restricts classes used for outbound policy instances
-   * to those containing only IP DSCP or IP Precedence match rules
-   */
-  if (L7_USMDB_MIB_DIFFSERV_POLICY_TYPE_OUT == pEntry->mib.type)
-  {
-    if (cnfgrIsFeaturePresent(dsCompId,
-                              L7_DIFFSERV_POLICY_OUT_CLASS_UNRESTRICTED_FEATURE_ID)
-        != L7_TRUE)
-    {
-      instIndex = pEntry->chainIndex;           /* first instance for this policy */
-
-      while (0 != instIndex)
-      {
-        pInstEntry = &pCfgData->policyInst[instIndex];
-
-        classIndex = pInstEntry->mib.classIndex;
-        refClassIndex = classIndex;             /* start with current class instance */
-
-        /* walk cascaded class reference chain to evaluate all match conditions for
-         * this policy instance
-         *
-         * each class can have at most one refClass rule, so can process referenced
-         * class after all rules within current class (i.e. recursion not needed)
-         */
-        while (0 != refClassIndex)
-        {
-          pClassEntry = &pCfgData->classHdr[refClassIndex];
-          classRuleIndex = pClassEntry->chainIndex;
-
-          /* this becomes nonzero again only if current class contains another ref class */
-          refClassIndex = 0;
-
-          while (0 != classRuleIndex)
-          {
-            pRuleEntry = &pCfgData->classRule[classRuleIndex];
-
-            if (L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_REFCLASS
-                == pRuleEntry->mib.entryType)
-            {
-              refClassIndex = pRuleEntry->mib.match.refClassIndex;
-            }
-            else
-            {
-              /* only IP DSCP or IP Precedence rule entry type allowed */
-              if ((L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_IPDSCP
-                   != pRuleEntry->mib.entryType) &&
-                  (L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_IPPRECEDENCE
-                   != pRuleEntry->mib.entryType))
-              {
-                /* found unsupported class rule match condition used in outbound policy */
-                DIFFSERV_CLUSTER_DLOG("%s: class rule type \'%s\' not valid "
-                                      "for outbound policy \'%s\'\n",
-                                      __FUNCTION__,
-                                      dsmibClassRuleTypeStr[pRuleEntry->mib.entryType],
-                                      pEntry->mib.name);
-                return L7_FAILURE;
-              }
-            }
-
-            classRuleIndex = pRuleEntry->chainIndex;
-
-          } /* endwhile classRuleIndex */
-
-        } /* endwhile refClassIndex */
-
-        instIndex = pInstEntry->chainIndex;     /* next instance for this policy */
-
-      } /* endwhile instIndex */
-    } /* endif feature present check */
-  } /* endif policy type out */
-
-  /* check mixed ipv4/ipv6 policy instance feature support */
-  if (cnfgrIsFeaturePresent(dsCompId,
-                            L7_DIFFSERV_POLICY_MIXED_IPV6_FEATURE_ID)
-      != L7_TRUE)
-  {
-    savedL3Protocol = L7_USMDB_MIB_DIFFSERV_CLASS_L3PROTOCOL_NONE;    /* init */
-
-    instIndex = pEntry->chainIndex;           /* first instance for this policy */
-
-    while (0 != instIndex)
-    {
-      pInstEntry = &pCfgData->policyInst[instIndex];
-
-      classIndex = pInstEntry->mib.classIndex;
-      pClassEntry = &pCfgData->classHdr[classIndex];
-      classL3Protocol = pClassEntry->mib.l3Protocol;
-
-      /* l3 protocol of all instance classes must be the same (ignoring those
-       * whose class mib.l3Protocol field is not set)
-       *
-       * no need to scan refClass chain, since all classes within a chain
-       * are guaranteed to have the same l3Protocol value
-       */
-      if (L7_USMDB_MIB_DIFFSERV_CLASS_L3PROTOCOL_NONE != classL3Protocol)
-      {
-        if (L7_USMDB_MIB_DIFFSERV_CLASS_L3PROTOCOL_NONE == savedL3Protocol)
-        {
-          savedL3Protocol = classL3Protocol;    /* cache first valid value */
-        }
-        else
-        {
-          if (classL3Protocol != savedL3Protocol)
-          {
-            /* inconsistent l3Protocol among classes comprising this policy definition */
-            DIFFSERV_CLUSTER_DLOG("%s: inconsistent l3Protocol among classes "
-                                  "comprising policy \'%s\'\n",
-                                  __FUNCTION__, pEntry->mib.name);
-            return L7_FAILURE;
-          }
-        }
-      }
-
-      instIndex = pInstEntry->chainIndex;     /* next instance for this policy */
-
-    } /* endwhile instIndex */
-
-  } /* endif feature present check */
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Verify received DiffServ policy instance config against
-*           system defines and features
-*
-* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
-* @param    L7_uint32         entryIndex  @b{(input)} config table array index
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    This assumes data has already been validated by the sender,
-*           so we can skip basic checks, such as range checking.  However,
-*           this system may not have the same prod/plat defines or features
-*           enabled, so need to fail if we cannot apply entire configuration.
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigPolicyInstVerify(L7_diffServCfg_t *pCfgData,
-                                              L7_uint32        entryIndex)
-{
-  L7_diffServPolicyInst_t     *pEntry = &pCfgData->policyInst[entryIndex];
-  L7_uint32                   i, num = 0, lim = L7_DIFFSERV_ATTR_PER_INST_LIM;
-
-  /* make sure current number of attributes per policy instance is within
-   * supported limit
-   *
-   * NOTE: For accuracy, search the instIndexRef field in the Policy Attr table
-   *       and count the number of occurrences of this policy instance
-   *       entryIndex.
-   */
-  for (i = L7_DIFFSERV_POLICY_ATTR_START; i < L7_DIFFSERV_POLICY_ATTR_MAX; i++)
-  {
-    if (pCfgData->policyAttr[i].instIndexRef == entryIndex)
-    {
-      num++;
-    }
-  }
-  if (num > lim)
-  {
-    DIFFSERV_CLUSTER_DLOG("%s: too many attributes (%u) for instance %u of policy \'%s\' - max=%u\n",
-                          __FUNCTION__, num, entryIndex,
-                          pCfgData->policyHdr[pEntry->hdrIndexRef].mib.name,
-                          lim);
-    return L7_FAILURE;
-  }
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Verify received DiffServ policy attribute config against
-*           system defines and features
-*
-* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
-* @param    L7_uint32         entryIndex  @b{(input)} config table array index
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    This assumes data has already been validated by the sender,
-*           so we can skip basic checks, such as range checking.  However,
-*           this system may not have the same prod/plat defines or features
-*           enabled, so need to fail if we cannot apply entire configuration.
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigPolicyAttrVerify(L7_diffServCfg_t *pCfgData,
-                                              L7_uint32        entryIndex)
-{
-  L7_diffServPolicyAttr_t     *pEntry = &pCfgData->policyAttr[entryIndex];
-  dsmibPolicyAttrType_t       entryType;
-  dsmibPolicyAttrData_t       *pStmt;
-  dsmibPolicyAttrType_t       type1, type2, type3;
-  L7_uchar8                   markVal1, markVal2, markVal3;
-  dsmibPoliceColor_t          colorMode1, colorMode2;
-  nimConfigID_t               *pConfigId;
-  L7_uint32                   intIfNum;
-
-  entryType = pEntry->mib.entryType;
-  pStmt = &pEntry->mib.stmt;
-
-  /* check entry type feature support */
-  if (L7_SUCCESS != dsmibPolicyAttrFeaturePresentCheck(entryType))
-  {
-    DIFFSERV_CLUSTER_DLOG("%s: policy attribute type \'%s\' not supported\n",
-                          __FUNCTION__, dsmibPolicyAttrTypeStr[entryType]);
-    return L7_FAILURE;
-  }
-
-  /* check assign queue ID within supported range */
-  if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_ASSIGN_QUEUE == entryType)
-  {
-    if ((pStmt->assignQueue.qid < L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_ASSIGN_QUEUE_MIN) ||
-        (pStmt->assignQueue.qid > L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_ASSIGN_QUEUE_MAX))
-    {
-      DIFFSERV_CLUSTER_DLOG("%s: assign queue ID (%u) out of range\n",
-                            __FUNCTION__, pStmt->assignQueue.qid);
-      return L7_FAILURE;
-    }
-  }
-
-  /* check IP DSCP mark value */
-  if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == entryType)
-  {
-    if (L7_TRUE != policyAttrIpDscpValSupported[pStmt->markIpDscp.val])
-    {
-      DIFFSERV_CLUSTER_DLOG("%s: IP DSCP mark value (%u) not supported\n",
-                            __FUNCTION__, pStmt->assignQueue.qid);
-      return L7_FAILURE;
-    }
-  }
-
-  /* check policing actions and any mark IP DSCP values
-   *
-   * convert police action to its comparable entry type and use it to
-   * check the feature support
-   */
-
-  type1 = type2 = type3 = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_NONE;
-  markVal1 = markVal2 = markVal3 = 0;
-  colorMode1 = colorMode2 = L7_USMDB_MIB_DIFFSERV_POLICE_COLOR_NONE;
-
-  if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SIMPLE == entryType)
-  {
-    type1 = _dsClusterPoliceActToEntryType(pStmt->policeSimple.conformAct);
-    type3 = _dsClusterPoliceActToEntryType(pStmt->policeSimple.nonconformAct);
-    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type1)
-    {
-      markVal1 = pStmt->policeSimple.conformVal;
-    }
-    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type3)
-    {
-      markVal3 = pStmt->policeSimple.nonconformVal;
-    }
-    colorMode1 = pStmt->policeSimple.colorConformMode;
-  }
-  else if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE == entryType)
-  {
-    type1 = _dsClusterPoliceActToEntryType(pStmt->policeSingleRate.conformAct);
-    type2 = _dsClusterPoliceActToEntryType(pStmt->policeSingleRate.exceedAct);
-    type3 = _dsClusterPoliceActToEntryType(pStmt->policeSingleRate.nonconformAct);
-    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type1)
-    {
-      markVal1 = pStmt->policeSingleRate.conformVal;
-    }
-    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type2)
-    {
-      markVal2 = pStmt->policeSingleRate.exceedVal;
-    }
-    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type3)
-    {
-      markVal3 = pStmt->policeSingleRate.nonconformVal;
-    }
-    colorMode1 = pStmt->policeSingleRate.colorConformMode;
-    colorMode2 = pStmt->policeSingleRate.colorExceedMode;
-  }
-  else if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE == entryType)
-  {
-    type1 = _dsClusterPoliceActToEntryType(pStmt->policeTwoRate.conformAct);
-    type2 = _dsClusterPoliceActToEntryType(pStmt->policeTwoRate.exceedAct);
-    type3 = _dsClusterPoliceActToEntryType(pStmt->policeTwoRate.nonconformAct);
-    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type1)
-    {
-      markVal1 = pStmt->policeTwoRate.conformVal;
-    }
-    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type2)
-    {
-      markVal2 = pStmt->policeTwoRate.exceedVal;
-    }
-    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type3)
-    {
-      markVal3 = pStmt->policeTwoRate.nonconformVal;
-    }
-    colorMode1 = pStmt->policeTwoRate.colorConformMode;
-    colorMode2 = pStmt->policeTwoRate.colorExceedMode;
-  }
-  /* check police action
-   * (default value of 'none' is accepted if DiffServ is supported)
-   */
-  if ((L7_SUCCESS != dsmibPolicyAttrFeaturePresentCheck(type1)) ||
-      (L7_SUCCESS != dsmibPolicyAttrFeaturePresentCheck(type2)) ||
-      (L7_SUCCESS != dsmibPolicyAttrFeaturePresentCheck(type3)))
-  {
-    DIFFSERV_CLUSTER_DLOG("%s: police action not supported\n",
-                          __FUNCTION__);
-    return L7_FAILURE;
-  }
-  /* check police IP DSCP mark value
-   * (default mark value of 0 is always considered supported)
-   */
-  if ((L7_TRUE != policyAttrIpDscpValSupported[markVal1]) ||
-      (L7_TRUE != policyAttrIpDscpValSupported[markVal2]) ||
-      (L7_TRUE != policyAttrIpDscpValSupported[markVal3]))
-  {
-    DIFFSERV_CLUSTER_DLOG("%s: police IP DSCP mark value not supported\n",
-                          __FUNCTION__);
-    return L7_FAILURE;
-  }
-  /* check policing color-aware support */
-  if (L7_TRUE != cnfgrIsFeaturePresent(dsCompId,
-                                       L7_DIFFSERV_POLICY_ATTR_POLICE_COLORAWARE_FEATURE_ID))
-  {
-    if ((L7_TRUE == L7_USMDB_MIB_DIFFSERV_POLICE_COLOR_MODE_IS_AWARE(colorMode1)) ||
-        (L7_TRUE == L7_USMDB_MIB_DIFFSERV_POLICE_COLOR_MODE_IS_AWARE(colorMode2)))
-    {
-      DIFFSERV_CLUSTER_DLOG("%s: police color aware mode not supported\n",
-                            __FUNCTION__);
-      return L7_FAILURE;
-    }
-  }
-
-  /* check for valid mirror/redirect intf (u/s/p) */
-  pConfigId = L7_NULLPTR;
-  if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MIRROR == entryType)
-  {
-    pConfigId = &pStmt->mirror.configId;
-  }
-  else if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_REDIRECT == entryType)
-  {
-    pConfigId = &pStmt->redirect.configId;
-  }
-  /* get intIfNum and check for valid DiffServ interface  */
-  if (L7_NULLPTR != pConfigId)
-  {
-    if ((L7_SUCCESS != nimIntIfFromConfigIDGet(pConfigId, &intIfNum)) ||
-        (L7_TRUE != diffServIsValidIntf(intIfNum)))
-    {
-      DIFFSERV_CLUSTER_DLOG("%s: mirror/redirect DiffServ interface not valid\n",
-                            __FUNCTION__);
-      return L7_FAILURE;
-    }
-  }
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Remap DiffServ service intf config from old to new policy indexes
-*
-* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    The service intf table is NOT part of the cluster config
-*           passed from sender to receiver.
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigServiceIntfRemap(L7_diffServCfg_t *pCfgData)
-{
-  L7_diffServIntfCfg_t        *pEntry;
-  L7_diffServPolicyHdr_t      *pPolicyOld, *pPolicyNew;
-  L7_diffServService_t        *pService;
-  dsmibServiceIfDir_t         dir;
-  L7_uint32                   i, j;
-  L7_uint32                   policyIndex;
-  L7_uint32                   policyIndexXlate[L7_DIFFSERV_POLICY_HDR_MAX];
-
-  /* gather current system operational config into temp config struct */
-  if (diffServBuildUserConfigData(L7_DIFFSERV_CFG_VER_CURRENT, dsClusterTmpCfg)
-      != L7_SUCCESS)
-  {
-    return L7_FAILURE;
-  }
-
-  /* copy all temp config entries into received config struct */
-  for (i = 0; i < L7_DIFFSERV_INTF_MAX_COUNT; i++)
-  {
-    memcpy(&pCfgData->diffServIntfCfg[i], &dsClusterTmpCfg->diffServIntfCfg[i],
-           sizeof(L7_diffServIntfCfg_t));
-  }
-
-  /* build a temporary policy index translation table */
-  memset(policyIndexXlate, 0, sizeof(policyIndexXlate));
-
-  for (i = L7_DIFFSERV_POLICY_HDR_START; i < L7_DIFFSERV_POLICY_HDR_MAX; i++)
-  {
-    pPolicyOld = &dsClusterTmpCfg->policyHdr[i];
-
-    if (L7_TRUE != pPolicyOld->inUse)
-    {
-      break;
-    }
-
-    for (j = L7_DIFFSERV_POLICY_HDR_START; j < L7_DIFFSERV_POLICY_HDR_MAX; j++)
-    {
-      pPolicyNew = &pCfgData->policyHdr[j];
-
-      if (L7_TRUE != pPolicyNew->inUse)
-      {
-        break;
-      }
-
-      if (0 == strncmp(pPolicyOld->mib.name, pPolicyNew->mib.name,
-                       sizeof(pPolicyOld->mib.name)))
-      {
-        /* found policy name match -- set new policy index in xlate table */
-        policyIndexXlate[pPolicyOld->mib.index] = pPolicyNew->mib.index;
-        break;
-      }
-
-    } /* endfor j*/
-
-  } /* endfor i */
-
-  /* adjust the policy index in each service {intf,direction} entry, as needed */
-  for (i = 0; i < L7_DIFFSERV_INTF_MAX_COUNT; i++)
-  {
-    pEntry = &pCfgData->diffServIntfCfg[i];
-
-    for (dir = L7_USMDB_MIB_DIFFSERV_IF_DIRECTION_IN;
-         dir <= L7_USMDB_MIB_DIFFSERV_IF_DIRECTION_OUT;
-         dir++)
-    {
-
-      if (L7_USMDB_MIB_DIFFSERV_IF_DIRECTION_IN == dir)
-      {
-        pService = &pEntry->serviceIn;
-      }
-      else
-      {
-        pService = &pEntry->serviceOut;
-      }
-
-      if (L7_TRUE == pService->inUse)
-      {
-        policyIndex = pService->mib.policyIndex;
-        if (0 != policyIndex)
-        {
-          if (0 != policyIndexXlate[policyIndex])
-          {
-            if (policyIndex != policyIndexXlate[policyIndex])
-            {
-              DIFFSERV_CLUSTER_DLOG("%s: Remapping service mib index %u, dir %u from policy index %u to %u\n",
-                                    __FUNCTION__, pService->mib.index, pService->mib.direction,
-                                    pService->mib.policyIndex, policyIndexXlate[policyIndex]);
-              pService->mib.policyIndex = policyIndexXlate[policyIndex];
-            }
-          }
-          else
-          {
-            /* this policy is no longer available -- remove from intf config */
-            L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-                    "%s: Obsolete policy index %u removed from service mib index %u, dir \'%s\'.\n",
-                    __FUNCTION__, policyIndex, pService->mib.index,
-                    (L7_USMDB_MIB_DIFFSERV_IF_DIRECTION_IN == dir) ? "in" : "out");
-            pService->mib.policyIndex = 0;
-          }
-        }
-      } /* endif inUse */
-
-    } /* endfor dir */
-
-  } /* endfor i */
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Verify received configuration against system defines and features
-*
-* @param    L7_diffServCfg_t  *pCfgData @{(input)} received DiffServ config data
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    This assumes data has already been validated by the sender,
-*           so we can skip basic checks, such as range checking.  However,
-*           this system may not have the same prod/plat defines or features
-*           enabled, so need to fail if we cannot apply entire configuration.
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterConfigVerify(L7_diffServCfg_t *pCfgData)
-{
-  L7_RC_t                     rc = L7_SUCCESS;
-  dsmibTableId_t              tableID;
-  L7_uint32                   i, startEnt, maxEnt;
-  dsClusterTableParms_t       *pTable;
-
-  DIFFSERV_CLUSTER_DLOG("ENTERING %s\n", __FUNCTION__);
-
-  /* iterate through each table ID */
-  for (tableID = DSMIB_TABLE_ID_CLASS; tableID <= DSMIB_TABLE_ID_POLICY_ATTR; tableID++)
-  {
-    pTable = &dsClusterTableParms[tableID];
-
-    startEnt = pTable->startEnt;
-    maxEnt   = pTable->maxEnt;
-
-    /* if validation fn ptr is null, assume there is nothing to check */
-    if (L7_NULLPTR == pTable->verifyFn)
-    {
-      continue;
-    }
-
-    for (i = startEnt; i < maxEnt; i++)
-    {
-      /* array entry not in use means end of the configured list */
-      if (_dsClusterConfigEntryInUseGet(tableID, pCfgData, i) != L7_TRUE)
-        break;
-
-      /* invoke table-specific validation function to check applicability of
-       * config on this system
-       */
-      rc = pTable->verifyFn(pCfgData, i);
-      if (L7_SUCCESS != rc)
-      {
-        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-                "%s: Failed verification check for received DiffServ %s table config\n",
-                __FUNCTION__, dsmibPrvtTableIdStr[tableID]);
-        break;
-      }
-
-    } /* endfor i */
-
-    /* check for errors */
-    if (L7_SUCCESS != rc)
-    {
-      break;
-    }
-
-  } /* endfor tableID */
-
-  /* create new service intf config from the existing config by mapping
-   * policy indexes from old to new via policy name lookup
-   *
-   * NOTE: Any policy index translation failures cause a log msg to be
-   *       generated and result in the removal of the non-existent policy
-   *       from the service interface, but does not result in a config failure.
-   */
-  if (diffServClusterConfigServiceIntfRemap(pCfgData) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: Error mapping DiffServ service interface config.\n",
-            __FUNCTION__, dsmibPrvtTableIdStr[tableID]);
-    rc = L7_FAILURE;
-  }
-
-  DIFFSERV_CLUSTER_DLOG("LEAVING %s (rc = %d)\n", __FUNCTION__, rc);
-
-  return rc;
-}
-
-/*********************************************************************
-* @purpose  Function to apply entire received configuration
-*
-* @param    void
-*
-* @returns  void
-*
-* @notes    This function is not allowed to fail. There is no way to
-*           abort once the configuration has been verified successfully.
-*
-* @end
-*********************************************************************/
-void diffServClusterConfigApply(void)
-{
-  L7_BOOL         needDefault = L7_FALSE;
-  L7_char8        *pMsg = L7_NULLPTR;
-
-  DIFFSERV_CLUSTER_DLOG("ENTERING %s\n", __FUNCTION__);
-
-  /* save current system operational config into temp config struct
-   * for a possible restore scenario
-   */
-  if (diffServBuildUserConfigData(L7_DIFFSERV_CFG_VER_CURRENT, dsClusterTmpCfg)
-      != L7_SUCCESS)
-  {
-    needDefault = L7_TRUE;
-  }
-
-  /* apply received config (with modified service intf info) to switch */
-  if (diffServReplace(dsClusterRxCfg) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "%s: Unexpected error applying received DiffServ config to switch.\n",
-            __FUNCTION__);
-
-    /* try restoring config to what it was */
-    if ((needDefault == L7_FALSE) &&
-        (diffServReplace(dsClusterTmpCfg) == L7_SUCCESS))
-    {
-      pMsg = "Previously existing DiffServ config successfully restored.";
-    }
-    else
-    {
-      /* restore using default config */
-      if (diffServRestore() == L7_SUCCESS)
-      {
-        pMsg = "DiffServ config has been reset to factory defaults.";
-      }
-      else
-      {
-        pMsg = "Error setting DiffServ config to factory defaults. Please reset device.";
-      }
-    }
-
-    /* log additional information regarding the outcome */
-    if (pMsg != L7_NULLPTR)
-    {
-      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-              "%s: %s\n", __FUNCTION__, pMsg);
-    }
-  }
-
-  DIFFSERV_CLUSTER_DLOG("LEAVING %s\n", __FUNCTION__);
-
-  return;
-}
-
-/*********************************************************************
-* @purpose  Function to process configuration receive commands
-*
-* @param    clusterConfigCmd  cmd  @b{(input)} cluster member
-*
-* @returns  void
-*
-* @notes
-*
-* @end
-*********************************************************************/
-void diffServClusterConfigRxCmdProcess(clusterConfigCmd cmd)
-{
-  L7_RC_t rc = L7_FAILURE;
-
-  switch (cmd)
-  {
-    case CLUSTER_CONFIG_CMD_START_TRANSFER:
-    case CLUSTER_CONFIG_CMD_ABORT:
-      if (CLUSTER_CONFIG_CMD_START_TRANSFER == cmd)
-      {
-        DIFFSERV_CLUSTER_DLOG("%s: CLUSTER START received\n", __FUNCTION__);
-      }
-      else
-      {
-        DIFFSERV_CLUSTER_DLOG("%s: CLUSTER ABORT received\n", __FUNCTION__);
-      }
-      /* initialize temporary structure to receive entire configuration from peer */
-      _dsClusterCfgStructInit(dsClusterRxCfg, "dsClusterRxCfg");
-      /* initialize variables used for debugging */
-      dsClusterRxCfgMsgStarted = L7_FALSE;
-      dsClusterRxCfgIeExpected = DS_CLUSTER_MSG_IE_NONE;
-      dsClusterRxError = L7_FALSE;
-      dsClusterRxInProg = (CLUSTER_CONFIG_CMD_START_TRANSFER == cmd) ? L7_TRUE : L7_FALSE;
-      break;
-
-    case CLUSTER_CONFIG_CMD_END_TRANSFER:
-      DIFFSERV_CLUSTER_DLOG("%s: CLUSTER END received (rxError=%u)\n",
-                            __FUNCTION__, dsClusterRxError);
-      if (L7_TRUE == dsClusterRxError)
-      {
-        rc = L7_FAILURE;
-      }
-      else
-      {
-        rc = diffServClusterConfigVerify(dsClusterRxCfg);
-        if (L7_SUCCESS != rc)
-        {
-          DIFFSERV_CLUSTER_DLOG("%s: DiffServ received config verification failed.\n", __FUNCTION__);
-          L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-                  "%s: DiffServ received config verification failed.\n", __FUNCTION__);
-        }
-      }
-      if (clusterConfigRxDone(CLUSTER_CFG_ID(QOS_DIFFSERV), rc) != L7_SUCCESS)
-      {
-        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-                "%s: clusterConfigRxDone failed.\n", __FUNCTION__);
-      }
-      if (L7_SUCCESS != rc)
-      {
-        dsClusterRxInProg = L7_FALSE;
-      }
-      DIFFSERV_CLUSTER_DLOG("%s: CLUSTER END completed (rxError=%u, rc=%u)\n",
-                            __FUNCTION__, dsClusterRxError, rc);
-      break;
-
-    case CLUSTER_CONFIG_CMD_APPLY:
-      DIFFSERV_CLUSTER_DLOG("%s: CLUSTER APPLY received\n", __FUNCTION__);
-      diffServClusterConfigApply();
-      clusterConfigRxApplyDone(CLUSTER_CFG_ID(QOS_DIFFSERV));
-      dsClusterRxInProg = L7_FALSE;
-      DIFFSERV_CLUSTER_DLOG("%s: CLUSTER APPLY completed\n", __FUNCTION__);
-      break;
-
-    default:
-      DIFFSERV_CLUSTER_DLOG("%s: CLUSTER <UNKNOWN> received (cmd=%u)\n",
-                            __FUNCTION__, cmd);
-      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-              "%s: Received unknown clusterConfigCmd=%u\n", __FUNCTION__, cmd);
-      break;
-  }
-
-  return;
-}
-
-/*********************************************************************
-* @purpose  Indicates if DiffServ cluster config receive operation currently in progress
-*
-* @param    void
-*
-* @returns  L7_TRUE
-* @returns  L7_FALSE
-*
-* @notes
-*
-* @end
-*********************************************************************/
-L7_BOOL diffServClusterIsRxInProgress(void)
-{
-  return dsClusterRxInProg;
-}
-
-/*********************************************************************
-* @purpose  Translate a config push policy name into its associated Policy Table index
-*
-* @param    stringPtr     @b{(input)}  Policy name string pointer
-* @param    pPolicyIndex  @b{(output)} Pointer to policy index value
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    Searches the received config push data for a matching
-*           policy name.
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterPolicyNameToIndex(L7_uchar8 *stringPtr,
-                                         L7_uint32 *pPolicyIndex)
-{
-  dsmibTableId_t              tableID = DSMIB_TABLE_ID_POLICY;
-  L7_diffServCfg_t            *pCfgData = dsClusterRxCfg;
-  L7_uint32                   len;
-  L7_uint32                   i, startEnt, maxEnt;
-  dsClusterTableParms_t       *pTable;
-  L7_diffServPolicyHdr_t      *pEntry;
-
-  /* check inputs */
-  if ((stringPtr == L7_NULLPTR) ||
-      (pPolicyIndex == L7_NULLPTR))
-  {
-    return L7_FAILURE;
-  }
-
-  /* check the length of the policy name string */
-  len = (L7_uint32)strlen((char *)stringPtr);
-  if ((len == 0) || (len > L7_USMDB_MIB_DIFFSERV_POLICY_NAME_MAX))
-  {
-    return L7_FAILURE;
-  }
-
-  /* config push RX data only valid while push receive operation still in progress
-   * (i.e. prior to the conclusion of the data apply)
-   */
-  if (diffServClusterIsRxInProgress() != L7_TRUE)
-  {
-    return L7_FAILURE;
-  }
-
-  pTable = &dsClusterTableParms[tableID];
-
-  startEnt = pTable->startEnt;
-  maxEnt   = pTable->maxEnt;
-
-  for (i = startEnt; i < maxEnt; i++)
-  {
-    pEntry = &pCfgData->policyHdr[i];
-
-    /* array entry not in use means end of the configured list */
-    if (pEntry->inUse != L7_TRUE)
-      break;
-
-    /* compare against name in existing row */
-    if (strcmp((char *)stringPtr, (char *)pEntry->mib.name) == 0)
-    {
-      *pPolicyIndex = pEntry->mib.index;
-      return L7_SUCCESS;
-    }
-
-  } /* endfor i */
-
-  *pPolicyIndex = 0;
-  return L7_FAILURE;
-}
-
-/*********************************************************************
-* @purpose  Get current number of instances in a config push policy definition
-*
-* @param    policyIndex   @b{(input)}  Policy index
-* @param    pCount        @b{(output)} Pointer to instance count output location
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes
-*
-* @end
-*********************************************************************/
-L7_RC_t diffServClusterPolicyInstCountGet(L7_uint32 policyIndex,
-                                          L7_uint32 *pCount)
-{
-  L7_diffServCfg_t            *pCfgData = dsClusterRxCfg;
-  L7_uint32                   instCount = 0;
-  L7_uint32                   i;
-
-  /* check inputs */
-  if (pCount == L7_NULLPTR)
-  {
-    return L7_FAILURE;
-  }
-
-  /* config push RX data only valid while push receive operation still in progress
-   * (i.e. prior to the conclusion of the data apply)
-   */
-  if (diffServClusterIsRxInProgress() != L7_TRUE)
-  {
-    return L7_FAILURE;
-  }
-
-  /* count the number of instances in this policy
-   *
-   * NOTE: For accuracy, search the hdrIndex field in the Policy Inst table
-   *       and count the number of occurrences of this policy entryIndex.
-   */
-  for (i = L7_DIFFSERV_POLICY_INST_START; i < L7_DIFFSERV_POLICY_INST_MAX; i++)
-  {
-    if (pCfgData->policyInst[i].hdrIndexRef == policyIndex)
-    {
-      instCount++;
-    }
-  }
-
-  *pCount = instCount;
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Function to enable/disable debug via devshell
-*
-* @param    L7_BOOL debug  @b{(input)} L7_TRUE/L7_FALSE
-*
-* @returns  void
-*
-* @notes
-*
-* @end
-*********************************************************************/
-void diffServClusterDebugSet(L7_BOOL debug)
-{
-  dsClusterDebug = debug;
-  return;
-}
+/*********************************************************************
+*
+* (C) Copyright Broadcom Corporation 2002-2007
+*
+**********************************************************************
+*
+* @filename  diffserv_cluster.c
+*
+* @purpose   Diffserv support for clustering
+*
+* @component QoS - Diffserv
+*
+* @comments
+*
+* @create    02/28/2008
+*
+* @author    gpaussa
+*
+* @end
+*
+**********************************************************************/
+#include <string.h>
+#include "commdefs.h"
+#include "osapi.h"
+#include "osapi_support.h"
+#include "log.h"
+#include "nvstoreapi.h"
+#include "l7utils_api.h"
+#include "comm_mask.h"
+#include "avl_api.h"
+#include "clustering_commdefs.h"
+#include "clustering_api.h"
+#include "l7_diffserv_api.h"
+#include "diffserv_config.h"
+#include "diffserv_prvtmib.h"
+#include "diffserv_util.h"
+#include "diffserv_cluster.h"
+#include "usmdb_mib_diffserv_private_api.h"
+
+extern char *dsmibPrvtTableIdStr[];
+extern L7_uchar8  policyAttrIpDscpValSupported[];
+
+static L7_diffServCfg_t *dsClusterTxCfg   = L7_NULLPTR;
+static L7_diffServCfg_t *dsClusterRxCfg   = L7_NULLPTR;
+static L7_diffServCfg_t *dsClusterTmpCfg  = L7_NULLPTR;
+
+static L7_BOOL          dsClusterRxCfgMsgStarted  = L7_FALSE;               /* received Config Start IE msg, but not Config End */
+static dsClusterMsgIe_t dsClusterRxCfgIeExpected  = DS_CLUSTER_MSG_IE_NONE; /* next expected IE in a defined sequence */
+
+/* copy of data received from cluster member switch */
+static L7_BOOL  dsClusterRxInProg   = L7_FALSE; /* indicates Rx operation currently in progress */
+static L7_BOOL  dsClusterRxError    = L7_FALSE; /* indicates unrecoverable error receiving, drop remaining messages */
+
+static L7_int32 dsClusterTaskId     = L7_ERROR;
+static void     *dsClusterQueue     = L7_NULLPTR;
+static L7_BOOL  dsClusterDebug      = L7_FALSE;
+
+static L7_COMPONENT_IDS_t dsCompId  = L7_FLEX_QOS_DIFFSERV_COMPONENT_ID;
+
+static dsClusterTableParms_t dsClusterTableParms[DSMIB_TABLE_ID_TOTAL] =
+{
+  { /* none (placeholder) */
+    0, 0, 0, 0, 0, 0, 0, 0, L7_NULLPTR, L7_NULLPTR
+  },
+  { /* class table */
+    L7_DIFFSERV_CLASS_HDR_START,
+    L7_DIFFSERV_CLASS_HDR_MAX,
+    DS_CLUSTER_MSG_IE_CLASS_CONFIG_START,
+    DS_CLUSTER_MSG_IE_CLASS_CONFIG_START_SIZE,
+    DS_CLUSTER_MSG_IE_CLASS_DEF,
+    DS_CLUSTER_MSG_IE_CLASS_DEF_SIZE,
+    DS_CLUSTER_MSG_IE_CLASS_CONFIG_END,
+    DS_CLUSTER_MSG_IE_CLASS_CONFIG_END_SIZE,
+    diffServClusterConfigClassMsgAccess,
+    diffServClusterConfigClassVerify
+  },
+  { /* class rule table */
+    L7_DIFFSERV_CLASS_RULE_START,
+    L7_DIFFSERV_CLASS_RULE_MAX,
+    DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START,
+    DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START_SIZE,
+    DS_CLUSTER_MSG_IE_CLASS_RULE_DEF,
+    DS_CLUSTER_MSG_IE_CLASS_RULE_DEF_SIZE,
+    DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END,
+    DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END_SIZE,
+    diffServClusterConfigClassRuleMsgAccess,
+    diffServClusterConfigClassRuleVerify
+  },
+  { /* policy table */
+    L7_DIFFSERV_POLICY_HDR_START,
+    L7_DIFFSERV_POLICY_HDR_MAX,
+    DS_CLUSTER_MSG_IE_POLICY_CONFIG_START,
+    DS_CLUSTER_MSG_IE_POLICY_CONFIG_START_SIZE,
+    DS_CLUSTER_MSG_IE_POLICY_DEF,
+    DS_CLUSTER_MSG_IE_POLICY_DEF_SIZE,
+    DS_CLUSTER_MSG_IE_POLICY_CONFIG_END,
+    DS_CLUSTER_MSG_IE_POLICY_CONFIG_END_SIZE,
+    diffServClusterConfigPolicyMsgAccess,
+    diffServClusterConfigPolicyVerify
+  },
+  { /* policy inst table */
+    L7_DIFFSERV_POLICY_INST_START,
+    L7_DIFFSERV_POLICY_INST_MAX,
+    DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START,
+    DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START_SIZE,
+    DS_CLUSTER_MSG_IE_POLICY_INST_DEF,
+    DS_CLUSTER_MSG_IE_POLICY_INST_DEF_SIZE,
+    DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END,
+    DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END_SIZE,
+    diffServClusterConfigPolicyInstMsgAccess,
+    diffServClusterConfigPolicyInstVerify
+  },
+  { /* policy attr table */
+    L7_DIFFSERV_POLICY_ATTR_START,
+    L7_DIFFSERV_POLICY_ATTR_MAX,
+    DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START,
+    DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START_SIZE,
+    DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF,
+    DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF_SIZE,
+    DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END,
+    DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END_SIZE,
+    diffServClusterConfigPolicyAttrMsgAccess,
+    diffServClusterConfigPolicyAttrVerify
+  },
+  { /* policy perf in (not used here) */
+    0, 0, 0, 0, 0, 0, 0, 0, L7_NULLPTR, L7_NULLPTR
+  },
+  { /* policy perf out (not used here) */
+    0, 0, 0, 0, 0, 0, 0, 0, L7_NULLPTR, L7_NULLPTR
+  },
+  { /* service (not used here) */
+    0, 0, 0, 0, 0, 0, 0, 0, L7_NULLPTR, L7_NULLPTR
+  }
+};
+
+/* internal functions */
+
+static void _dsClusterPktInt32GetOrSet(L7_BOOL isSet, L7_uint32 *value,
+                                       L7_uchar8 *buffer, L7_uint32 *offset)
+{
+  if (L7_TRUE == isSet)
+  {
+    CLUSTER_PKT_INT32_SET(*value, buffer, *offset);
+  }
+  else
+  {
+    CLUSTER_PKT_INT32_GET(*value, buffer, *offset);
+  }
+}
+
+static void _dsClusterPktInt16GetOrSet(L7_BOOL isSet, L7_ushort16 *value,
+                                       L7_uchar8 *buffer, L7_uint32 *offset)
+{
+  if (L7_TRUE == isSet)
+  {
+    CLUSTER_PKT_INT16_SET(*value, buffer, *offset);
+  }
+  else
+  {
+    CLUSTER_PKT_INT16_GET(*value, buffer, *offset);
+  }
+}
+
+static void _dsClusterPktInt8GetOrSet(L7_BOOL isSet, L7_uchar8 *value,
+                                      L7_uchar8 *buffer, L7_uint32 *offset)
+{
+  if (L7_TRUE == isSet)
+  {
+    CLUSTER_PKT_INT8_SET(*value, buffer, *offset);
+  }
+  else
+  {
+    CLUSTER_PKT_INT8_GET(*value, buffer, *offset);
+  }
+}
+
+static void _dsClusterPktStringGetOrSet(L7_BOOL isSet, L7_uchar8 *str, L7_uint32 len,
+                                        L7_uchar8 *buffer, L7_uint32 *offset)
+{
+  if (L7_TRUE == isSet)
+  {
+    CLUSTER_PKT_STRING_SET(str, len, buffer, *offset);
+  }
+  else
+  {
+    CLUSTER_PKT_STRING_GET(str, len, buffer, *offset);
+  }
+}
+
+static void _dsClusterCfgStructInit(L7_diffServCfg_t *pCfg, L7_char8 *pDescrStr)
+{
+  if (L7_NULLPTR != pCfg)
+  {
+    memset(pCfg, 0, sizeof(*pCfg));
+
+    /* fill in file hdr fields */
+    if (L7_NULLPTR != pDescrStr)
+    {
+      snprintf(pCfg->cfgHdr.filename, sizeof(pCfg->cfgHdr.filename), "%s", pDescrStr);
+    }
+    pCfg->cfgHdr.version          = L7_DIFFSERV_CFG_VER_CURRENT;
+    pCfg->cfgHdr.componentID      = L7_FLEX_QOS_DIFFSERV_COMPONENT_ID;
+    pCfg->cfgHdr.type             = L7_CFG_DATA;
+    pCfg->cfgHdr.length           = (L7_uint32)L7_DIFFSERV_CFG_DATA_SIZE;
+    pCfg->cfgHdr.dataChanged      = L7_FALSE;
+    pCfg->cfgHdr.fileHdrVersion   = L7_FILE_HDR_VER_CURRENT;
+  }
+}
+
+static L7_BOOL _dsClusterConfigEntryInUseGet(dsmibTableId_t    tableID,
+                                             L7_diffServCfg_t  *pCfg,
+                                             L7_uint32         index)
+{
+  L7_BOOL inUse = L7_FALSE;
+
+  switch (tableID)
+  {
+    case DSMIB_TABLE_ID_CLASS:
+      inUse = pCfg->classHdr[index].inUse;
+      break;
+
+    case DSMIB_TABLE_ID_CLASS_RULE:
+      inUse = (0 == pCfg->classRule[index].hdrIndexRef) ? L7_FALSE : L7_TRUE;
+      break;
+
+    case DSMIB_TABLE_ID_POLICY:
+      inUse = pCfg->policyHdr[index].inUse;
+      break;
+
+    case DSMIB_TABLE_ID_POLICY_INST:
+      inUse = (0 == pCfg->policyInst[index].hdrIndexRef) ? L7_FALSE : L7_TRUE;
+      break;
+
+    case DSMIB_TABLE_ID_POLICY_ATTR:
+      inUse = (0 == pCfg->policyAttr[index].instIndexRef) ? L7_FALSE : L7_TRUE;
+      break;
+
+    default:
+      /* table ID not suppoorted here */
+      break;
+
+  } /* endswitch */
+
+  return inUse;
+}
+
+static L7_ushort16 _dsClusterIeDefinedSizeGet(L7_ushort16 elemId)
+{
+  L7_ushort16       elemSize = 0;
+
+  switch (elemId)
+  {
+    case DS_CLUSTER_MSG_IE_CONFIG_START:
+      elemSize = DS_CLUSTER_MSG_IE_CONFIG_START_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_GLOBAL_CONFIG:
+      elemSize = DS_CLUSTER_MSG_IE_GLOBAL_CONFIG_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
+      elemSize = DS_CLUSTER_MSG_IE_CLASS_CONFIG_START_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_CLASS_DEF:
+      elemSize = DS_CLUSTER_MSG_IE_CLASS_DEF_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
+      elemSize = DS_CLUSTER_MSG_IE_CLASS_CONFIG_END_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
+      elemSize = DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
+      elemSize = DS_CLUSTER_MSG_IE_CLASS_RULE_DEF_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
+      elemSize = DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
+      elemSize = DS_CLUSTER_MSG_IE_POLICY_CONFIG_START_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_DEF:
+      elemSize = DS_CLUSTER_MSG_IE_POLICY_DEF_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
+      elemSize = DS_CLUSTER_MSG_IE_POLICY_CONFIG_END_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
+      elemSize = DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
+      elemSize = DS_CLUSTER_MSG_IE_POLICY_INST_DEF_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
+      elemSize = DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
+      elemSize = DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
+      elemSize = DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
+      elemSize = DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END_SIZE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_CONFIG_END:
+      elemSize = DS_CLUSTER_MSG_IE_CONFIG_END_SIZE;
+      break;
+
+    default:
+      /* invalid element ID */
+      break;
+
+  } /* endswitch */
+
+  return elemSize;
+}
+
+static dsClusterIeGroup_t _dsClusterIeGroupTypeGet(L7_ushort16 elemId)
+{
+  dsClusterIeGroup_t    groupType = DS_CLUSTER_IE_GROUP_NONE;
+
+  switch (elemId)
+  {
+    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
+      groupType = DS_CLUSTER_IE_GROUP_START;
+      break;
+
+    case DS_CLUSTER_MSG_IE_CLASS_DEF:
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
+      groupType = DS_CLUSTER_IE_GROUP_DEF;
+      break;
+
+    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
+    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
+    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
+      groupType = DS_CLUSTER_IE_GROUP_END;
+      break;
+
+    case DS_CLUSTER_MSG_IE_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_GLOBAL_CONFIG:
+    case DS_CLUSTER_MSG_IE_CONFIG_END:
+    default:
+      groupType = DS_CLUSTER_IE_GROUP_NONE;
+      break;
+
+  } /* endswitch */
+
+  return groupType;
+}
+
+static dsmibTableId_t _dsClusterIeTableIdGet(L7_ushort16 elemId)
+{
+  dsmibTableId_t        tableID = DSMIB_TABLE_ID_NONE;
+
+  switch (elemId)
+  {
+    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_CLASS_DEF:
+    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
+      tableID = DSMIB_TABLE_ID_CLASS;
+      break;
+
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
+      tableID = DSMIB_TABLE_ID_CLASS_RULE;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_POLICY_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
+      tableID = DSMIB_TABLE_ID_POLICY;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
+      tableID = DSMIB_TABLE_ID_POLICY_INST;
+      break;
+
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
+      tableID = DSMIB_TABLE_ID_POLICY_ATTR;
+      break;
+
+    default:
+      break;
+
+  } /* endswitch */
+
+  return tableID;
+}
+
+dsmibPolicyAttrType_t _dsClusterPoliceActToEntryType(dsmibPoliceAct_t policeAct)
+{
+  dsmibPolicyAttrType_t       entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_NONE;
+
+  switch (policeAct)
+  {
+    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_DROP:
+      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_DROP;
+      break;
+
+    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_MARKCOS:
+      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COSVAL;
+      break;
+
+    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_MARKCOS_AS_COS2:
+      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COS_AS_COS2;
+      break;
+
+    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_MARKCOS2:
+      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COS2VAL;
+      break;
+
+    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_MARKDSCP:
+      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL;
+      break;
+
+    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_MARKPREC:
+      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPPRECEDENCEVAL;
+      break;
+
+    case L7_USMDB_MIB_DIFFSERV_POLICE_ACT_SEND:
+    default:
+      /* nothing specific to translate to */
+      entryType = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_NONE;
+      break;
+
+  } /* endswitch*/
+
+  return entryType;
+}
+
+/*********************************************************************
+* @purpose  Show DiffServ cluster internal variables for support/debug
+*
+* @param    void
+*
+* @returns  L7_SUCCESS
+*
+* @notes
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterDebugShow(void)
+{
+  sysapiPrintf("\nDiffServ cluster support data:\n");
+  sysapiPrintf("  dsClusterTxCfg           = %p\n",      dsClusterTxCfg);
+  sysapiPrintf("  dsClusterRxCfg           = %p\n",      dsClusterRxCfg);
+  sysapiPrintf("  dsClusterTmpCfg          = %p\n",      dsClusterTmpCfg);
+  sysapiPrintf("  dsClusterRxCfgMsgStarted = %d\n",      dsClusterRxCfgMsgStarted);
+  sysapiPrintf("  dsClusterRxCfgIeExpected = 0x%4.4x\n", dsClusterRxCfgIeExpected);
+  sysapiPrintf("  dsClusterRxInProg        = %d\n",      dsClusterRxInProg);
+  sysapiPrintf("  dsClusterRxError         = %d\n",      dsClusterRxError);
+  sysapiPrintf("  dsClusterTaskId          = 0x%x\n",    dsClusterTaskId);
+  sysapiPrintf("  dsClusterQueue           = 0x%x\n",    (L7_uint32)dsClusterQueue);
+  sysapiPrintf("  dsClusterDebug           = %d\n",      dsClusterDebug);
+  sysapiPrintf("\n");
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Perform all phase 1 initialization for clustering support
+*
+* @param    void
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterPhase1Init(void)
+{
+  L7_uint32         dataSize;
+
+  /* allocate memory to send and receive DiffServ configuration.
+   *
+   * NOTE: Must be able to receive a copy of the entire config in order
+   *       to verify it before it is applied.  Must be able to abort the
+   *       receive processing without affecting the current operational
+   *       or saved config.
+   */
+  dataSize = sizeof(L7_diffServCfg_t);
+  dsClusterTxCfg  = osapiMalloc(dsCompId, dataSize);
+  dsClusterRxCfg  = osapiMalloc(dsCompId, dataSize);
+  dsClusterTmpCfg = osapiMalloc(dsCompId, dataSize);
+  if ((L7_NULLPTR == dsClusterTxCfg) ||
+      (L7_NULLPTR == dsClusterRxCfg) ||
+      (L7_NULLPTR == dsClusterTmpCfg))
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: Unable to allocate memory for Tx, Rx and Tmp config structs (%u bytes each).\n",
+            __FUNCTION__, dataSize);
+    return L7_FAILURE;
+  }
+  memset(dsClusterTxCfg, 0, dataSize);
+  memset(dsClusterRxCfg, 0, dataSize);
+  memset(dsClusterTmpCfg, 0, dataSize);
+
+  dsClusterQueue = (void *)osapiMsgQueueCreate("dsClusterQueue",
+                                               DS_CLUSTER_QUEUE_SIZE,
+                                               DS_CLUSTER_QUEUE_SIZE * sizeof(dsClusterQueueMsg_t));
+  if (L7_NULLPTR == dsClusterQueue)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: osapiMsgQueueCreate failed.\n", __FUNCTION__);
+    return L7_FAILURE;
+  }
+
+  dsClusterTaskId = osapiTaskCreate("dsClusterTask", (void *)diffServClusterTask,
+                                    0, 0,
+                                    L7_DEFAULT_STACK_SIZE,
+                                    L7_DEFAULT_TASK_PRIORITY,
+                                    L7_DEFAULT_TASK_SLICE);
+
+  if ((L7_ERROR == dsClusterTaskId) ||
+      (osapiWaitForTaskInit(L7_QOS_DIFFSERV_CLUSTER_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS))
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: osapiTaskCreate failed.\n", __FUNCTION__);
+    return L7_FAILURE;
+  }
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Perform all phase 2 initialization for clustering support
+*
+* @param    void
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterPhase2Init(void)
+{
+  if (clusterMsgRegister(DS_CLUSTER_MSG_CONFIG,
+                         CLUSTER_MSG_DELIVERY_RELIABLE,
+                         diffServClusterMsgCallback) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: clusterMsgRegister failed.\n", __FUNCTION__);
+    return L7_FAILURE;
+  }
+
+  if (clusterConfigRegister(CLUSTER_CFG_ID(QOS_DIFFSERV),
+                            diffServClusterConfigSendCallback,
+                            diffServClusterConfigRxCallback) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: clusterConfigRegister failed.\n", __FUNCTION__);
+    return L7_FAILURE;
+  }
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Task to wait on cluster messages and events
+*
+* @param    void
+*
+* @returns  void
+*
+* @notes    Clustering requires processing messages and commands in
+*           a separate task context, a component must not block the
+*           clustering task.
+*
+* @end
+*********************************************************************/
+void diffServClusterTask(void)
+{
+  dsClusterQueueMsg_t queueMsg;
+  L7_RC_t             rc;
+
+  osapiTaskInitDone(L7_QOS_DIFFSERV_CLUSTER_TASK_SYNC);
+
+  while (L7_TRUE)
+  {
+    if (osapiMessageReceive(dsClusterQueue,
+                            (void *)&queueMsg, sizeof(dsClusterQueueMsg_t),
+                            L7_WAIT_FOREVER) == L7_SUCCESS)
+    {
+      switch (queueMsg.type)
+      {
+        case DS_CLUSTER_QUEUE_MSG_CONFIG_MSG:
+          if (L7_FALSE == dsClusterRxError)
+          {
+            diffServClusterConfigMsgProcess(&queueMsg.content.msg);
+          }
+          break;
+        case DS_CLUSTER_QUEUE_MSG_CONFIG_SEND:
+          rc = diffServClusterConfigSend(&queueMsg.content.memberID);
+          if (clusterConfigSendDone(CLUSTER_CFG_ID(QOS_DIFFSERV), rc) != L7_SUCCESS)
+          {
+            L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+                    "%s: clusterConfigSendDone failed\n", __FUNCTION__);
+          }
+          break;
+        case DS_CLUSTER_QUEUE_MSG_CONFIG_RX:
+          diffServClusterConfigRxCmdProcess(queueMsg.content.configCmd);
+          break;
+        default:
+          L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+                  "%s: received invalid message, queueMsg.type=%u\n",
+                  __FUNCTION__, queueMsg.type);
+          break;
+      }
+    }
+  }
+}
+
+/*********************************************************************
+* @purpose  Callback to handle messages received through clustering
+*
+* @param    L7_ushort16              msgType   @b{(input)} message type
+* @param    clusterMsgDeliveryMethod method    @b{(input)} delivery method
+* @param    L7_uint32                msgLength @b{(input)} message length
+* @param    L7_uchar8               *msgBuf    @b{(input)} contents of message
+*
+* @returns  void
+*
+* @notes    This function should NOT introduce significant amounts
+*           of latency (e.g. by blocking), since it will be called
+*           in the context of the clustering task.  It should
+*           copy the message and signal another task to
+*           deal with the message's reception.
+* @end
+*********************************************************************/
+void diffServClusterMsgCallback(L7_ushort16              msgType,
+                                clusterMsgDeliveryMethod method,
+                                L7_uint32                msgLength,
+                                L7_uchar8               *msgBuf)
+{
+  dsClusterQueueMsg_t queueMsg;
+
+  DIFFSERV_CLUSTER_DLOG("%s: msgType=0x%4.4X\n", __FUNCTION__, msgType);
+
+  if (msgLength > sizeof(queueMsg.content.msg.buffer))
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: Received invalid cluster message length, msgLength=%u\n",
+            __FUNCTION__, msgLength);
+    return;
+  }
+
+  memset(&queueMsg, 0, sizeof(dsClusterQueueMsg_t));
+  switch (msgType)
+  {
+    case DS_CLUSTER_MSG_CONFIG:
+      queueMsg.type = DS_CLUSTER_QUEUE_MSG_CONFIG_MSG;
+      queueMsg.content.msg.length = msgLength;
+      memcpy(queueMsg.content.msg.buffer, msgBuf, msgLength);
+      break;
+    default:
+      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+              "%s: Received invalid cluster message type, msgType=0x%4.4x\n",
+              __FUNCTION__, msgType);
+      return;
+  }
+
+  /* send message to process on diffServClusterTask */
+  if (osapiMessageSend(dsClusterQueue, (void *)&queueMsg,
+                       sizeof(dsClusterQueueMsg_t),
+                       L7_NO_WAIT, L7_MSG_PRIORITY_NORM) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: osapiMessageSend failed, queueMsg.type=%u\n",
+            __FUNCTION__, queueMsg.type);
+  }
+
+  return;
+}
+
+/*********************************************************************
+* @purpose  Callback to send configuration information to a cluster member
+*
+* @param    clusterMemberID_t *memberID @b{(input)} member to receive config
+*
+* @returns  void
+*
+* @notes
+*
+* @end
+*********************************************************************/
+void diffServClusterConfigSendCallback(clusterMemberID_t *memberID)
+{
+  dsClusterQueueMsg_t queueMsg;
+
+  DIFFSERV_CLUSTER_DLOG("ENTERING %s\n", __FUNCTION__);
+
+  if (L7_NULLPTR == memberID)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: received NULL cluster member ID\n", __FUNCTION__);
+    return;
+  }
+
+  memset(&queueMsg, 0, sizeof(dsClusterQueueMsg_t));
+  queueMsg.type = DS_CLUSTER_QUEUE_MSG_CONFIG_SEND;
+  memcpy(&queueMsg.content.memberID, memberID, sizeof(clusterMemberID_t));
+
+  /* send message to process on diffServClusterTask */
+  if (osapiMessageSend(dsClusterQueue, (void *)&queueMsg,
+                       sizeof(dsClusterQueueMsg_t),
+                       L7_NO_WAIT, L7_MSG_PRIORITY_NORM) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: osapiMessageSend failed, queueMsg.type=%u\n",
+            __FUNCTION__, queueMsg.type);
+  }
+
+  return;
+}
+
+/*********************************************************************
+* @purpose  Callback to handle received configuration events
+*
+* @param    clusterConfigCmd cmd @b{(input)} configuration command
+*
+* @returns  void
+*
+* @notes
+*
+* @end
+*********************************************************************/
+void diffServClusterConfigRxCallback(clusterConfigCmd cmd)
+{
+  dsClusterQueueMsg_t queueMsg;
+
+  DIFFSERV_CLUSTER_DLOG("%s: cmd=%u\n", __FUNCTION__, cmd);
+
+  memset(&queueMsg, 0, sizeof(dsClusterQueueMsg_t));
+  queueMsg.type = DS_CLUSTER_QUEUE_MSG_CONFIG_RX;
+  queueMsg.content.configCmd = cmd;
+
+  /* send message to process on diffServClusterTask */
+  if (osapiMessageSend(dsClusterQueue, (void *)&queueMsg,
+                       sizeof(dsClusterQueueMsg_t),
+                       L7_NO_WAIT, L7_MSG_PRIORITY_NORM) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: osapiMessageSend failed, queueMsg.type=%u\n",
+            __FUNCTION__, queueMsg.type);
+  }
+
+  return;
+}
+
+/*********************************************************************
+* @purpose  Function to process cluster config message
+*
+* @param    L7_ushort16    elemId @b{(input)} received element ID
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @comments
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigRxIeSeqCheck(L7_ushort16 elemId)
+{
+  dsClusterMsgIe_t  currIe = DS_CLUSTER_MSG_IE_NONE;
+  dsClusterMsgIe_t  nextIe = dsClusterRxCfgIeExpected;
+
+  /* check this IE versus what is expected */
+  switch (elemId)
+  {
+    /* independent or config start IEs expect IE type of 'none' */
+    case DS_CLUSTER_MSG_IE_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_GLOBAL_CONFIG:
+    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_CONFIG_END:
+      currIe = DS_CLUSTER_MSG_IE_NONE;
+      break;
+
+    /* def IEs expect to see their own IE */
+    case DS_CLUSTER_MSG_IE_CLASS_DEF:
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
+      currIe = elemId;
+      break;
+
+    /* config end IEs expect IE to be their corresponding def IE */
+    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
+      currIe = DS_CLUSTER_MSG_IE_CLASS_DEF;
+      break;
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
+      currIe = DS_CLUSTER_MSG_IE_CLASS_RULE_DEF;
+      break;
+    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
+      currIe = DS_CLUSTER_MSG_IE_POLICY_DEF;
+      break;
+    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
+      currIe = DS_CLUSTER_MSG_IE_POLICY_INST_DEF;
+      break;
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
+      currIe = DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF;
+      break;
+
+    default:
+      return L7_FAILURE;
+      /*PASSTHRU*/
+
+  } /* endswitch */
+
+  /* check if we got the expected IE */
+  if (currIe != dsClusterRxCfgIeExpected)
+  {
+    return L7_FAILURE;
+  }
+
+  /* determine next expected IE */
+  switch (elemId)
+  {
+    /* config start IEs expect next IE to be their corresponding def IE */
+    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
+      nextIe = DS_CLUSTER_MSG_IE_CLASS_DEF;
+      break;
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
+      nextIe = DS_CLUSTER_MSG_IE_CLASS_RULE_DEF;
+      break;
+    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
+      nextIe = DS_CLUSTER_MSG_IE_POLICY_DEF;
+      break;
+    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
+      nextIe = DS_CLUSTER_MSG_IE_POLICY_INST_DEF;
+      break;
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
+      nextIe = DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF;
+      break;
+
+    /* def IEs expect to see their own IE */
+    case DS_CLUSTER_MSG_IE_CLASS_DEF:
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
+      nextIe = elemId;
+      break;
+
+    /* independent or config end IEs expect next IE of 'none' */
+    case DS_CLUSTER_MSG_IE_CONFIG_START:
+    case DS_CLUSTER_MSG_IE_GLOBAL_CONFIG:
+    case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
+    case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
+    case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
+    case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
+    case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
+    case DS_CLUSTER_MSG_IE_CONFIG_END:
+      nextIe = DS_CLUSTER_MSG_IE_NONE;
+      break;
+
+    default:
+      return L7_FAILURE;
+      /*PASSTHRU*/
+
+  } /* endswitch */
+
+  /* set IE to expect next */
+  dsClusterRxCfgIeExpected = nextIe;
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Function to process cluster config message
+*
+* @param    dsClusterMsg_t *msg   @b{(input)} received message
+*
+* @returns  void
+*
+* @notes
+*
+* @end
+*********************************************************************/
+void diffServClusterConfigMsgProcess(dsClusterMsg_t *msg)
+{
+  static L7_ushort16          startDefs = 0;
+  static L7_ushort16          remainDefs = 0;
+
+  clusterMsgElementHdr_t      elem;
+  L7_ushort16                 elemSize;
+  L7_uchar8                   *buffer = msg->buffer;
+  L7_uint32                   offset = 0;
+  dsClusterIeGroup_t          ieGroupType;
+  L7_uint32                   index;
+  L7_ushort16                 endDefs;
+  dsmibTableId_t              tableID;
+  dsClusterTableParms_t       *pTable = L7_NULLPTR;
+
+  DIFFSERV_CLUSTER_DLOG("ENTERING %s: message length=%u\n", __FUNCTION__, msg->length);
+
+  while (offset < msg->length)
+  {
+    CLUSTER_PKT_ELEMENT_HDR_GET(elem, msg->buffer, offset);
+
+    /*DIFFSERV_CLUSTER_DLOG("%s: received elem ID 0x%4.4x (len=%u)\n",
+                          __FUNCTION__, elem.elementId, elem.elementLen);*/
+
+    /* check for proper IE sequence order */
+    if (diffServClusterConfigRxIeSeqCheck(elem.elementId) != L7_SUCCESS)
+    {
+      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+              "%s: improper msg IE sequence detected: expected 0x%4.4x, got 0x%4.4x\n",
+              __FUNCTION__, dsClusterRxCfgIeExpected, elem.elementId);
+      /* quit processing this and further messages */
+      dsClusterRxError = L7_TRUE;
+      return;
+    }
+
+    do
+    {
+      /* NOTE: The essence of this function is to process IEs comprising the
+       *       DiffServ cluster config.  Some of these IEs are independent, but
+       *       most belong to a group of IEs -- start, zero or more def(s), end.
+       *       The processing of each of these group types is handled the same
+       *       for each DiffServ config table, so the first switch stmt handles
+       *       any unique processing, while the second switch stmt takes care
+       *       of the commonality.
+       */
+
+      /* identify this IE as a particular group type (will take action on this below) */
+      ieGroupType = _dsClusterIeGroupTypeGet(elem.elementId);
+
+      /* make sure received IE size matches its defined size */
+      elemSize = _dsClusterIeDefinedSizeGet(elem.elementId);
+      CLUSTER_PKT_ELEMENT_SIZE_CHECK(dsCompId, dsClusterDebug, elem, elemSize, offset);
+
+      /* get the table ID and entry pointer for this elem type (if applicable) */
+      tableID = _dsClusterIeTableIdGet(elem.elementId);
+      if (DSMIB_TABLE_ID_NONE != tableID)
+      {
+        pTable = &dsClusterTableParms[tableID];
+      }
+
+      switch (elem.elementId)
+      {
+        case DS_CLUSTER_MSG_IE_CONFIG_START:
+          offset += DS_CLUSTER_MSG_IE_CONFIG_START_SIZE;  /* nothing to process in buffer*/
+          dsClusterRxCfgMsgStarted = L7_TRUE;
+          break;
+
+        case DS_CLUSTER_MSG_IE_GLOBAL_CONFIG:
+          CLUSTER_PKT_INT32_GET(dsClusterRxCfg->adminMode, buffer, offset);
+          break;
+
+        case DS_CLUSTER_MSG_IE_CLASS_CONFIG_START:
+        case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_START:
+        case DS_CLUSTER_MSG_IE_POLICY_CONFIG_START:
+        case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_START:
+        case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_START:
+          /* handled below */
+          break;
+
+        case DS_CLUSTER_MSG_IE_CLASS_DEF:
+        case DS_CLUSTER_MSG_IE_CLASS_RULE_DEF:
+        case DS_CLUSTER_MSG_IE_POLICY_DEF:
+        case DS_CLUSTER_MSG_IE_POLICY_INST_DEF:
+        case DS_CLUSTER_MSG_IE_POLICY_ATTR_DEF:
+          /* handled below */
+          break;
+
+        case DS_CLUSTER_MSG_IE_CLASS_CONFIG_END:
+        case DS_CLUSTER_MSG_IE_CLASS_RULE_CONFIG_END:
+        case DS_CLUSTER_MSG_IE_POLICY_CONFIG_END:
+        case DS_CLUSTER_MSG_IE_POLICY_INST_CONFIG_END:
+        case DS_CLUSTER_MSG_IE_POLICY_ATTR_CONFIG_END:
+          /* handled below */
+          break;
+
+        case DS_CLUSTER_MSG_IE_CONFIG_END:
+          offset += DS_CLUSTER_MSG_IE_CONFIG_END_SIZE;    /* nothing to process in buffer */
+          dsClusterRxCfgMsgStarted = L7_FALSE;
+          /* display the received config struct based on DiffServ msgLvl setting */
+          if (pDiffServInfo_g->diffServMsgLvl >= DIFFSERV_MSGLVL_LO)
+          {
+            DIFFSERV_CLUSTER_DLOG("%s: DiffServ Cluster Config RX data\n", __FUNCTION__);
+            dsmibConfigDataShow(dsClusterRxCfg);
+          }
+          break;
+
+        default:
+          DIFFSERV_CLUSTER_DLOG("%s: received unknown IE 0x%4.4x (len=%u)\n",
+                                 __FUNCTION__, elem.elementId, elem.elementLen);
+          offset += elem.elementLen;
+          break;
+
+      } /* endswitch */
+
+      /* process IE depending on whether start, def, or end of a group */
+      switch (ieGroupType)
+      {
+        case DS_CLUSTER_IE_GROUP_START:
+          CLUSTER_PKT_INT16_GET(startDefs, buffer, offset);
+          DS_CLUSTER_IE_DEF_COUNT_CHECK(remainDefs, 0);
+          if ((L7_NULLPTR != pTable) &&
+              (startDefs >= pTable->maxEnt))
+          {
+            DIFFSERV_CLUSTER_DLOG("%s: IE 0x%4.4x group start shows %u entries, "
+                                  "but max supported is %u\n",
+                                   __FUNCTION__, elem.elementId, startDefs,
+                                   pTable->maxEnt);
+            dsClusterRxError = L7_TRUE;
+            break;
+          }
+          remainDefs = startDefs;
+          break;
+
+        case DS_CLUSTER_IE_GROUP_DEF:
+          index = startDefs - remainDefs + 1;   /* all cfg table indexes are 1-based */
+          if ((L7_NULLPTR != pTable) &&
+              (L7_NULLPTR != pTable->accessFn))
+          {
+            pTable->accessFn(L7_FALSE, dsClusterRxCfg, index, buffer, &offset);
+          }
+          remainDefs--;
+          break;
+
+        case DS_CLUSTER_IE_GROUP_END:
+          CLUSTER_PKT_INT16_GET(endDefs, buffer, offset);
+          DS_CLUSTER_IE_DEF_COUNT_CHECK(remainDefs, 0);
+          DS_CLUSTER_IE_DEF_COUNT_CHECK(startDefs, endDefs);
+          startDefs = 0;
+          break;
+
+        case DS_CLUSTER_IE_GROUP_NONE:
+        default:
+          break;
+
+      } /* endswitch */
+
+    } while (0);
+
+    if (L7_TRUE == dsClusterRxError)
+    {
+      /* quit processing this and further messages */
+      DIFFSERV_CLUSTER_DLOG("%s: config receive error occurred\n", __FUNCTION__);
+      break;
+    }
+
+  } /* endwhile */
+
+  DIFFSERV_CLUSTER_DLOG("LEAVING %s: rxError=%u\n", __FUNCTION__, dsClusterRxError);
+}
+
+/*********************************************************************
+* @purpose  Sets/Gets DiffServ class config data to/from message buffer
+*
+* @param    L7_BOOL           isSet       @b{(input)} L7_TRUE (set) or L7_FALSE (get)
+* @param    L7_diffServCfg_t  *pCfgData   @b{(input)} operational config data
+* @param    L7_uint32         entryIndex  @b{(input)} config table array index
+* @param    L7_uchar8         *buffer     @b{(inout)} message buffer
+* @param    L7_uint32         *offset     @b{(inout)} current offset in buffer
+*
+* @returns  void
+*
+* @comments Works with a cached copy of current DiffServ operational config data.
+*
+* @comments Assumes caller already checked for sufficient room in msg buffer.
+*
+* @end
+*********************************************************************/
+void diffServClusterConfigClassMsgAccess(L7_BOOL           isSet,
+                                         L7_diffServCfg_t  *pCfgData,
+                                         L7_uint32         entryIndex,
+                                         L7_uchar8         *buffer,
+                                         L7_uint32         *offset)
+{
+  L7_diffServClassHdr_t       *pEntry = &pCfgData->classHdr[entryIndex];
+  L7_uchar8                   rsvd[2] = { 0 };
+  L7_uint32                   aclNum;
+  L7_ACL_TYPE_t               aclType;
+  L7_uchar8                   aclName[L7_ACL_NAME_LEN_MAX+1];
+
+  aclNum = 0;
+  aclType = L7_ACL_TYPE_NONE;
+  memset(aclName, 0, sizeof(aclName));
+
+  /* Need to send the ACL name instead of the ACL index number in the
+   * config message, since named ACL index numbers are not necessarily
+   * the same on the sending and receiving systems.
+   *
+   * An L7_ACL_TYPE_NONE represents an aclNum of 0.  In this case,
+   * the aclName is sent as an empty string ("") and is ignored by the
+   * receiver.
+   */
+  if (L7_TRUE == isSet)
+  {
+    if (0 == pEntry->mib.aclNum)
+    {
+      /* ignoring rc here, since failure to get name causes empty string to be sent
+       * (this condition is checked by receiver)
+       */
+      (void)diffServAclCommonNameStringGet(pEntry->mib.aclNum, &aclType, aclName);
+    }
+  }
+
+  /* 00-03: In-use flag */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->inUse, buffer, offset);
+  /* 04-07: Config array index of first class rule */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->chainIndex, buffer, offset);
+
+  /** Start MIB row definition **/
+
+  /* 08-11: Table row index (class index) */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.index, buffer, offset);
+  /* 12-43: Class name (includes terminating null character) */
+  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pEntry->mib.name, sizeof(pEntry->mib.name), buffer, offset);
+  /* 44-47: Class type */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.type, buffer, offset);
+  /* 48-51: Layer 3 protocol */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.l3Protocol, buffer, offset);
+  /* 52-55: ACL type (for class type ACL) */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, aclType, buffer, offset);
+  /* 56-87: ACL name (for class type ACL) -- null terminated string */
+  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, aclName, sizeof(aclName), buffer, offset);
+  /* 88-91: Next free class rule index */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.ruleIndexNextFree, buffer, offset);
+  /* 92   : Storage type */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.storageType, buffer, offset);
+  /* 93   : Row status */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.rowStatus, buffer, offset);
+
+  /** End MIB row definition **/
+
+  /* 94-95: (Reserved = 0) */
+  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, rsvd, sizeof(rsvd), buffer, offset);
+  /* 96-99: Row invalid object flags */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->rowInvalidFlags, buffer, offset);
+
+  /* Translate ACL type and name received from config message to its
+   * ACL index number on the receiving system.
+   *
+   * An L7_ACL_TYPE_NONE represents an aclNum of 0.  In this case,
+   * the aclName is sent as an empty string ("") and is ignored by the
+   * receiver.
+   *
+   * NOTE: If the name-to-index translation is unsuccessful, just set the
+   *       mib.aclNum value to 0 and keep going.  The config validation checking
+   *       will detect an error when it sees a class type 'acl' with an
+   *       aclNum of 0.
+   */
+  if (L7_FALSE == isSet)
+  {
+    if (L7_ACL_TYPE_NONE != aclType)
+    {
+      if (diffServAclCommonNameToIndex(aclType, aclName, &aclNum) != L7_SUCCESS)
+      {
+        aclNum = 0;
+      }
+    }
+    pEntry->mib.aclNum = aclNum;
+  }
+}
+
+/*********************************************************************
+* @purpose  Sets/Gets DiffServ class rule config data to/from message buffer
+*
+* @param    L7_BOOL           isSet       @b{(input)} L7_TRUE (set) or L7_FALSE (get)
+* @param    L7_diffServCfg_t  *pCfgData   @b{(input)} operational config data
+* @param    L7_uint32         entryIndex  @b{(input)} config table array index
+* @param    L7_uchar8         *buffer     @b{(inout)} message buffer
+* @param    L7_uint32         *offset     @b{(inout)} current offset in buffer
+*
+* @returns  void
+*
+* @comments Works with a cached copy of current DiffServ operational config data.
+*
+* @comments Assumes caller already checked for sufficient room in msg buffer.
+*
+* @end
+*********************************************************************/
+void diffServClusterConfigClassRuleMsgAccess(L7_BOOL           isSet,
+                                             L7_diffServCfg_t  *pCfgData,
+                                             L7_uint32         entryIndex,
+                                             L7_uchar8         *buffer,
+                                             L7_uint32         *offset)
+{
+  L7_diffServClassRule_t      *pEntry = &pCfgData->classRule[entryIndex];
+  L7_uchar8                   rsvd[1] = { 0 };
+  dsmibClassRuleData_t        *pMatch;
+  dsmibClassRuleType_t        entryType;
+
+  /* 00-03: Config array index of parent class */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->hdrIndexRef, buffer, offset);
+  /* 04-07: Config array index of next sequential class rule */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->chainIndex, buffer, offset);
+
+  /** Start MIB row definition **/
+
+  /* 08-11: Table row index (class rule index) */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.index, buffer, offset);
+  /* 12-15: Class rule entry type */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.entryType, buffer, offset);
+
+  /* set up an entry type variable for type-specific field processing */
+  entryType = pEntry->mib.entryType;
+
+  /* set ptr to mib.match fields for convenience */
+  pMatch = &pEntry->mib.match;
+
+  /* 16-19: General value (per entryType) */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_COS:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->cos, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_COS2:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->cos2, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_ETYPE:
+      DS_CLUSTER_PKT_INT16_GET_OR_SET(isSet, pMatch->etype.keyid, buffer, offset);
+      DS_CLUSTER_PKT_INT16_GET_OR_SET(isSet, pMatch->etype.value, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_EVERY:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->matchEvery, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_FLOWLBLV6:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->ipv6FlowLabel, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_IPDSCP:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->ipDscp, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_IPPRECEDENCE:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->ipPrecedence, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_IPTOS:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pMatch->ipTos.bits, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pMatch->ipTos.mask, buffer, offset);
+      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->ipTos.rsvd1,
+                                       sizeof(pMatch->ipTos.rsvd1),
+                                       buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_PROTOCOL:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->protocolNum, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_REFCLASS:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->refClassIndex, buffer, offset);
+      break;
+    default:
+      *offset += sizeof(L7_uint32);
+      break;
+  }
+  /* 20-27: IPv4 address (per entryType) */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTIP:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->dstIp.addr, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->dstIp.mask, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCIP:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->srcIp.addr, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->srcIp.mask, buffer, offset);
+      break;
+    default:
+      *offset += (2 * sizeof(L7_uint32));
+      break;
+  }
+  /* 28-47: IPv6 address (per entryType) */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTIPV6:
+      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->dstIpv6.ip6prefix.in6Addr.in6.addr8, IPV6_ADDRESS_LEN, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->dstIpv6.ip6prefix.in6PrefixLen, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCIPV6:
+      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->srcIpv6.ip6prefix.in6Addr.in6.addr8, IPV6_ADDRESS_LEN, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->srcIpv6.ip6prefix.in6PrefixLen, buffer, offset);
+      break;
+    default:
+      *offset += (IPV6_ADDRESS_LEN + sizeof(L7_uint32));
+      break;
+  }
+  /* 48-55: Numeric range (per entryType) */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTL4PORT:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->dstL4Port.start, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->dstL4Port.end, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCL4PORT:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->srcL4Port.start, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->srcL4Port.end, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_VLANID:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->vlanId.start, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->vlanId.end, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_VLANID2:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->vlanId2.start, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pMatch->vlanId2.end, buffer, offset);
+      break;
+    default:
+      *offset += (2 * sizeof(L7_uint32));
+      break;
+  }
+  /* 52-63: MAC address (per entryType) */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTMAC:
+      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->dstMac.addr, L7_MAC_ADDR_LEN, buffer, offset);
+      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->dstMac.mask, L7_MAC_ADDR_LEN, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCMAC:
+      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->srcMac.addr, L7_MAC_ADDR_LEN, buffer, offset);
+      DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pMatch->srcMac.mask, L7_MAC_ADDR_LEN, buffer, offset);
+      break;
+    default:
+      *offset += (2 * L7_MAC_ADDR_LEN);
+      break;
+  }
+  /* 64   : Exclude flag */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.excludeFlag, buffer, offset);
+  /* 65   : Storage type */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.storageType, buffer, offset);
+  /* 66   : Row status */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.rowStatus, buffer, offset);
+
+  /** End MIB row definition **/
+
+  /* 67   : (Reserved = 0) */
+  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, rsvd, sizeof(rsvd), buffer, offset);
+  /* 68-71: Row invalid object flags */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->rowInvalidFlags, buffer, offset);
+  /* 72-75: ACL rule identifier origin */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->arid, buffer, offset);
+}
+
+/*********************************************************************
+* @purpose  Sets/Gets DiffServ policy config data to/from message buffer
+*
+* @param    L7_BOOL           isSet       @b{(input)} L7_TRUE (set) or L7_FALSE (get)
+* @param    L7_diffServCfg_t  *pCfgData   @b{(input)} operational config data
+* @param    L7_uint32         entryIndex  @b{(input)} config table array index
+* @param    L7_uchar8         *buffer     @b{(inout)} message buffer
+* @param    L7_uint32         *offset     @b{(inout)} current offset in buffer
+*
+* @returns  void
+*
+* @comments Works with a cached copy of current DiffServ operational config data.
+*
+* @comments Assumes caller already checked for sufficient room in msg buffer.
+*
+* @end
+*********************************************************************/
+void diffServClusterConfigPolicyMsgAccess(L7_BOOL           isSet,
+                                          L7_diffServCfg_t  *pCfgData,
+                                          L7_uint32         entryIndex,
+                                          L7_uchar8         *buffer,
+                                          L7_uint32         *offset)
+{
+  L7_diffServPolicyHdr_t      *pEntry = &pCfgData->policyHdr[entryIndex];
+  L7_uchar8                   rsvd[1] = { 0 };
+
+  /* 00-03: In-use flag */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->inUse, buffer, offset);
+  /* 04-07: Config array index of first policy instance */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->chainIndex, buffer, offset);
+
+  /** Start MIB row definition **/
+
+  /* 08-11: Table row index (policy index) */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.index, buffer, offset);
+  /* 12-43: Policy name (includes terminating null character) */
+  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, pEntry->mib.name, sizeof(pEntry->mib.name), buffer, offset);
+  /* 44-47: Next free policy instance index */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.instIndexNextFree, buffer, offset);
+  /* 49   : Policy type */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.type, buffer, offset);
+  /* 49   : Storage type */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.storageType, buffer, offset);
+  /* 50   : Row status */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.rowStatus, buffer, offset);
+
+  /** End MIB row definition **/
+
+  /* 51   : (Reserved = 0) */
+  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, rsvd, sizeof(rsvd), buffer, offset);
+  /* 52-55: Row invalid object flags */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->rowInvalidFlags, buffer, offset);
+}
+
+/*********************************************************************
+* @purpose  Sets/Gets DiffServ policy instance config data to/from message buffer
+*
+* @param    L7_BOOL           isSet       @b{(input)} L7_TRUE (set) or L7_FALSE (get)
+* @param    L7_diffServCfg_t  *pCfgData   @b{(input)} operational config data
+* @param    L7_uint32         entryIndex  @b{(input)} config table array index
+* @param    L7_uchar8         *buffer     @b{(inout)} message buffer
+* @param    L7_uint32         *offset     @b{(inout)} current offset in buffer
+*
+* @returns  void
+*
+* @comments Works with a cached copy of current DiffServ operational config data.
+*
+* @comments Assumes caller already checked for sufficient room in msg buffer.
+*
+* @end
+*********************************************************************/
+void diffServClusterConfigPolicyInstMsgAccess(L7_BOOL           isSet,
+                                              L7_diffServCfg_t  *pCfgData,
+                                              L7_uint32         entryIndex,
+                                              L7_uchar8         *buffer,
+                                              L7_uint32         *offset)
+{
+  L7_diffServPolicyInst_t     *pEntry = &pCfgData->policyInst[entryIndex];
+  L7_uchar8                   rsvd[2] = { 0 };
+
+  /* 00-03: Config array index of parent policy */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->hdrIndexRef, buffer, offset);
+  /* 04-07: Config array index of first policy attribute */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->attrChainIndex, buffer, offset);
+  /* 08-11: Config array index of next sequential policy instance */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->chainIndex, buffer, offset);
+
+  /** Start MIB row definition **/
+
+  /* 12-15: Table row index (policy instance index) */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.index, buffer, offset);
+  /* 16-19: Class index */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.classIndex, buffer, offset);
+  /* 20-23: Next free policy attribute index */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.attrIndexNextFree, buffer, offset);
+  /* 24   : Storage type */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.storageType, buffer, offset);
+  /* 25   : Row status */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.rowStatus, buffer, offset);
+
+  /** End MIB row definition **/
+
+  /* 26-27: (Reserved = 0) */
+  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, rsvd, sizeof(rsvd), buffer, offset);
+  /* 28-31: Row invalid object flags */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->rowInvalidFlags, buffer, offset);
+}
+
+/*********************************************************************
+* @purpose  Sets/Gets DiffServ policy attribute config data to/from message buffer
+*
+* @param    L7_BOOL           isSet       @b{(input)} L7_TRUE (set) or L7_FALSE (get)
+* @param    L7_diffServCfg_t  *pCfgData   @b{(input)} operational config data
+* @param    L7_uint32         entryIndex  @b{(input)} config table array index
+* @param    L7_uchar8         *buffer     @b{(inout)} message buffer
+* @param    L7_uint32         *offset     @b{(inout)} current offset in buffer
+*
+* @returns  void
+*
+* @comments Works with a cached copy of current DiffServ operational config data.
+*
+* @comments Assumes caller already checked for sufficient room in msg buffer.
+*
+* @end
+*********************************************************************/
+void diffServClusterConfigPolicyAttrMsgAccess(L7_BOOL           isSet,
+                                              L7_diffServCfg_t  *pCfgData,
+                                              L7_uint32         entryIndex,
+                                              L7_uchar8         *buffer,
+                                              L7_uint32         *offset)
+{
+  L7_diffServPolicyAttr_t     *pEntry = &pCfgData->policyAttr[entryIndex];
+  dsmibPolicyAttrType_t       entryType;
+  dsmibPolicyAttrData_t       *pStmt;
+  L7_uchar8                   rsvd[2] = { 0 };
+
+  /* 00-03: Config array index of parent policy */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->instIndexRef, buffer, offset);
+  /* 04-07: Config array index of next sequential policy attribute */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->chainIndex, buffer, offset);
+
+  /** Start MIB row definition **/
+
+  /* NOTE: Some of the field accesses that follow are contingent upon the entryType.
+   *       If data is not defined for a particular entryType, its location in the
+   *       message buffer is accounted for, but is bypassed.
+   */
+
+  pStmt = &pEntry->mib.stmt;            /* set ptr to mib.stmt fields for convenience */
+
+  /* 08-11: Table row index (policy attribute index) */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.index, buffer, offset);
+  /* 12-15: Policy attribute entry type */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->mib.entryType, buffer, offset);
+
+  /* set up an entry type variable for type-specific field processing */
+  entryType = pEntry->mib.entryType;
+
+  /* 16   : Queue Id */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_ASSIGN_QUEUE:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->assignQueue.qid, buffer, offset);
+      break;
+    default:
+      *offset += sizeof(L7_uchar8);
+      break;
+  }
+  /* 17   : Boolean flag */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_DROP:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->drop, buffer, offset);
+      break;
+    default:
+      *offset += sizeof(L7_uchar8);
+      break;
+  }
+  /* 18   : Mark value */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COSVAL:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->markCos.val, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COS2VAL:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->markCos2.val, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_COS_AS_COS2:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->markCosAsCos2.val, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->markIpDscp.val, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPPRECEDENCEVAL:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->markIpPrecedence.val, buffer, offset);
+      break;
+    default:
+      *offset += sizeof(L7_uchar8);
+      break;
+  }
+  /* 19   : (Reserved = 0) */
+  DS_CLUSTER_PKT_STRING_GET_OR_SET(isSet, rsvd, sizeof(rsvd[0]), buffer, offset);
+  /* 20-27: NIM config Id */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MIRROR:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->mirror.configId.type, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->mirror.configId.configSpecifier.usp.unit, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->mirror.configId.configSpecifier.usp.slot, buffer, offset);
+      DS_CLUSTER_PKT_INT16_GET_OR_SET(isSet, pStmt->mirror.configId.configSpecifier.usp.port, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_REDIRECT:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->redirect.configId.type, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->redirect.configId.configSpecifier.usp.unit, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->redirect.configId.configSpecifier.usp.slot, buffer, offset);
+      DS_CLUSTER_PKT_INT16_GET_OR_SET(isSet, pStmt->redirect.configId.configSpecifier.usp.port, buffer, offset);
+      break;
+    default:
+      *offset += (sizeof(L7_uint32) + (2 * sizeof(L7_uchar8)) + sizeof(L7_ushort16));
+      break;
+  }
+  /* 28-31: Policing C-rate
+   * 32-35: Policing C-burst
+   */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SIMPLE:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSimple.crate, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSimple.cburst, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.crate, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.cburst, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.crate, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.cburst, buffer, offset);
+      break;
+    default:
+      *offset += (2 * sizeof(L7_uint32));
+      break;
+  }
+  /* 36-39: Policing E-rate/P-rate
+   * 40-43: Policing E-burst/P-burst
+   */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.crate, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.eburst, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.prate, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.pburst, buffer, offset);
+      break;
+    default:
+      *offset += (2 * sizeof(L7_uint32));
+      break;
+  }
+  /* 44   : Policing C-action
+   * 45   : Policing C-mark
+   * 46   : Policing E-action
+   * 47   : Policing E-mark
+   * 48   : Policing N-action
+   * 49   : Policing N-mark
+   */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SIMPLE:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.conformAct, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.conformVal, buffer, offset);
+      *offset += (2 * sizeof(L7_uchar8));       /* E-action, E-mark not used */
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.nonconformAct, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.nonconformVal, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.conformAct, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.conformVal, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.exceedAct, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.exceedVal, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.nonconformAct, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.nonconformVal, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.conformAct, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.conformVal, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.exceedAct, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.exceedVal, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.nonconformAct, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.nonconformVal, buffer, offset);
+      break;
+    default:
+      *offset += (6 * sizeof(L7_uchar8));
+      break;
+  }
+  /* 50   : Policing C-color mode
+   * 51   : Policing C-color value
+   * 52-55: Policing C-color index
+   */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SIMPLE:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.colorConformMode, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSimple.colorConformVal, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSimple.colorConformIndex, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.colorConformMode, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.colorConformVal, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.colorConformIndex, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE:
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.colorConformMode, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.colorConformVal, buffer, offset);
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.colorConformIndex, buffer, offset);
+      break;
+    default:
+      *offset += ((2 * sizeof(L7_uchar8)) + sizeof(L7_uint32));
+      break;
+  }
+  /* 56-59: Policing E-color index
+   * 60   : Policing E-color mode
+   * 61   : Policing E-color value
+   */
+  switch (entryType)
+  {
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeSingleRate.colorExceedIndex, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.colorExceedMode, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeSingleRate.colorExceedVal, buffer, offset);
+      break;
+    case L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE:
+      DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pStmt->policeTwoRate.colorExceedIndex, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.colorExceedMode, buffer, offset);
+      DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pStmt->policeTwoRate.colorExceedVal, buffer, offset);
+      break;
+    default:
+      *offset += (sizeof(L7_uint32) + (2 * sizeof(L7_uchar8)));
+      break;
+  }
+  /* 62   : Storage type */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.storageType, buffer, offset);
+  /* 63   : Row status */
+  DS_CLUSTER_PKT_INT8_GET_OR_SET(isSet, pEntry->mib.rowStatus, buffer, offset);
+
+  /** End MIB row definition **/
+
+  /* 64-67: Row invalid object flags */
+  DS_CLUSTER_PKT_INT32_GET_OR_SET(isSet, pEntry->rowInvalidFlags, buffer, offset);
+}
+
+/*********************************************************************
+* @purpose  Function to send DiffServ global config to cluster member
+*
+* @param    L7_diffServCfg_t  *pCfgData  @b{(input)} operational config data
+* @param    clusterMemberID_t *memberID  @b{(input)} cluster member
+* @param    L7_uchar8         *buffer @b{(input/output)} message buffer
+* @param    L7_uint32         *offset @b{(input/output)} current offset in buffer
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @comments Works with a cached copy of current DiffServ operational config data.
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigGlobalSend(L7_diffServCfg_t  *pCfg,
+                                        clusterMemberID_t *memberID,
+                                        L7_uchar8         *buffer,
+                                        L7_uint32         *offset)
+{
+  L7_uint32         dataSize;
+
+  dataSize = (1 * sizeof(clusterMsgElementHdr_t)) +
+             DS_CLUSTER_MSG_IE_GLOBAL_CONFIG_SIZE;
+  if (diffServClusterConfigMsgSendCheck(dataSize, memberID, buffer, offset) != L7_SUCCESS)
+  {
+    return L7_FAILURE;
+  }
+  CLUSTER_PKT_ELEMENT_HDR_SET(DS_CLUSTER_MSG_IE_GLOBAL_CONFIG,
+                              DS_CLUSTER_MSG_IE_GLOBAL_CONFIG_SIZE,
+                              buffer, *offset);
+  CLUSTER_PKT_INT32_SET(pCfg->adminMode, buffer, *offset);
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Function to send DiffServ table config to cluster member
+*
+* @param    dsmibTableId_t    tableID     @b{(input)} DiffServ table identifier
+* @param    L7_diffServCfg_t  *pCfg       @b{(input)} operational config data
+* @param    clusterMemberID_t *memberID   @b{(input)} cluster member
+* @param    L7_uchar8         *buffer     @b{(input/output)} message buffer
+* @param    L7_uint32         *offset     @b{(input/output)} current offset in buffer
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @comments This is a generic function that handles building the common parts
+*           of the DiffServ table-based configuration in the cluster config msg.
+*           Only certain table IDs are supported.
+*
+* @comments Works with a cached copy of current DiffServ operational config data.
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigTableSend(dsmibTableId_t    tableID,
+                                       L7_diffServCfg_t  *pCfg,
+                                       clusterMemberID_t *memberID,
+                                       L7_uchar8         *buffer,
+                                       L7_uint32         *offset)
+{
+  L7_uint32                   i, dataSize;
+  L7_uint32                   startEnt, maxEnt;
+  L7_ushort16                 defType, defSize;
+  L7_ushort16                 numEnt = 0;
+  L7_uint32                   configStartOffset;
+  dsClusterTableParms_t       *pTable;
+
+  if ((tableID < DSMIB_TABLE_ID_CLASS) ||
+      (tableID > DSMIB_TABLE_ID_POLICY_ATTR))
+  {
+    return L7_FAILURE;
+  }
+
+  pTable = &dsClusterTableParms[tableID];
+  if (L7_NULLPTR == pTable->accessFn)
+  {
+    return L7_FAILURE;
+  }
+
+  startEnt = pTable->startEnt;
+  maxEnt   = pTable->maxEnt;
+
+  defType = pTable->defType;
+  defSize = pTable->defTypeSize;
+
+  /* Config Start IE */
+  dataSize = sizeof(clusterMsgElementHdr_t) + pTable->startTypeSize;
+  if (diffServClusterConfigMsgSendCheck(dataSize, memberID, buffer, offset) != L7_SUCCESS)
+  {
+    return L7_FAILURE;
+  }
+  CLUSTER_PKT_ELEMENT_HDR_SET(pTable->startType, pTable->startTypeSize,
+                              buffer, *offset);
+  /* save current offset to go back and fill in actual number of entries later */
+  configStartOffset = *offset;
+  CLUSTER_PKT_INT16_SET(numEnt, buffer, *offset);   /* sets num entries to 0 for now */
+
+
+  /* iterate through each configured entry */
+  dataSize = sizeof(clusterMsgElementHdr_t) + defSize;
+  for (i = startEnt; i < maxEnt; i++)
+  {
+    /* array entry not in use means end of the configured list */
+    if (_dsClusterConfigEntryInUseGet(tableID, pCfg, i) != L7_TRUE)
+      break;
+
+    if (diffServClusterConfigMsgSendCheck(dataSize, memberID, buffer, offset) != L7_SUCCESS)
+    {
+      return L7_FAILURE;
+    }
+    CLUSTER_PKT_ELEMENT_HDR_SET(defType, defSize, buffer, *offset);
+
+    /* invoke table-specific access function to send msg def IE for this entry */
+    pTable->accessFn(L7_TRUE, pCfg, i, buffer, offset);
+
+  } /* endfor i */
+
+  numEnt = i - startEnt;
+
+  /* fill in config start number of entries using saved buffer offset*/
+  CLUSTER_PKT_INT16_SET(numEnt, buffer, configStartOffset);
+
+  /* Config End IE */
+  dataSize = sizeof(clusterMsgElementHdr_t) + pTable->endTypeSize;
+  if (diffServClusterConfigMsgSendCheck(dataSize, memberID, buffer, offset) != L7_SUCCESS)
+  {
+    return L7_FAILURE;
+  }
+  CLUSTER_PKT_ELEMENT_HDR_SET(pTable->endType, pTable->endTypeSize, buffer, *offset);
+  CLUSTER_PKT_INT16_SET(numEnt, buffer, *offset);
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Function to send configuration to cluster member
+*
+* @param    clusterMemberID_t *memberID  @b{(input)} cluster member
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigSend(clusterMemberID_t *memberID)
+{
+  L7_RC_t               rc = L7_SUCCESS;
+  L7_char8              peerMacStr[L7_MAC_ADDR_STRING_LEN+1];
+  L7_uchar8             buffer[DS_CLUSTER_MSG_SIZE_MAX];
+  L7_uint32             offset = 0;
+  dsmibTableId_t        tableID;
+
+  if (l7utilsMacAddrHexToString(memberID->addr,
+                                sizeof(peerMacStr), peerMacStr) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: Received invalid memberID.\n", __FUNCTION__);
+    return L7_FAILURE;
+  }
+
+  DIFFSERV_CLUSTER_DLOG("%s: member ID=%s\n", __FUNCTION__, peerMacStr);
+
+  /* init cluster tx struct */
+  if (L7_NULLPTR == dsClusterTxCfg)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: Error - DiffServ cluster TX config struct not allocated.\n", __FUNCTION__);
+    return L7_FAILURE;
+  }
+  _dsClusterCfgStructInit(dsClusterTxCfg, "dsClusterTxCfg");
+
+  /* read all of the DiffServ operational config into the tx struct */
+  do
+  {
+    DIFFSERV_SEMA_TAKE(dsmibIndexSemId, L7_WAIT_FOREVER);
+    if (diffServBuildUserConfigData(L7_DIFFSERV_CFG_VER_CURRENT, dsClusterTxCfg) != L7_SUCCESS)
+    {
+      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+              "%s: Error extracting DiffServ operational config data.\n", __FUNCTION__);
+      rc = L7_FAILURE;
+      break;
+    }
+    dsClusterTxCfg->checkSum = 0;
+    dsClusterTxCfg->checkSum = nvStoreCrc32((L7_uchar8 *)dsClusterTxCfg, L7_DIFFSERV_CFG_DATA_SIZE);
+    DIFFSERV_SEMA_GIVE(dsmibIndexSemId);
+
+    /* init the msg buffer */
+    memset(buffer, 0, sizeof(buffer));
+    offset = 0;
+
+    CLUSTER_PKT_ELEMENT_HDR_SET(DS_CLUSTER_MSG_IE_CONFIG_START,
+                                DS_CLUSTER_MSG_IE_CONFIG_START_SIZE,
+                                buffer, offset);
+
+    if (diffServClusterConfigGlobalSend(dsClusterTxCfg, memberID, buffer, &offset) != L7_SUCCESS)
+    {
+      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+              "%s: Error sending DiffServ global config to peer switch %s.\n",
+              __FUNCTION__, peerMacStr);
+      rc = L7_FAILURE;
+      break;
+    }
+
+    for (tableID = DSMIB_TABLE_ID_CLASS; tableID <= DSMIB_TABLE_ID_POLICY_ATTR; tableID++)
+    {
+      if (diffServClusterConfigTableSend(tableID, dsClusterTxCfg, memberID, buffer, &offset) != L7_SUCCESS)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+                "%s: Error sending DiffServ %s table config to peer switch %s.\n",
+                __FUNCTION__, dsmibPrvtTableIdStr[tableID], peerMacStr);
+        rc = L7_FAILURE;
+        break;
+      }
+    }
+
+    /* display the sent config struct based on DiffServ msgLvl setting */
+    if (pDiffServInfo_g->diffServMsgLvl >= DIFFSERV_MSGLVL_LO)
+    {
+      dsmibConfigDataShow(dsClusterTxCfg);
+    }
+
+  } while (0);
+
+  if (L7_SUCCESS != rc)
+  {
+    return L7_FAILURE;
+  }
+
+  if (diffServClusterConfigMsgSendCheck(sizeof(clusterMsgElementHdr_t) +
+                                        DS_CLUSTER_MSG_IE_CONFIG_END_SIZE,
+                                        memberID, buffer, &offset) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: Error sending DiffServ config to peer switch.\n", __FUNCTION__);
+    return L7_FAILURE;
+  }
+
+  CLUSTER_PKT_ELEMENT_HDR_SET(DS_CLUSTER_MSG_IE_CONFIG_END,
+                              DS_CLUSTER_MSG_IE_CONFIG_END_SIZE,
+                              buffer, offset);
+
+  rc = clusterMsgSend(memberID, CLUSTER_MSG_DELIVERY_RELIABLE, DS_CLUSTER_MSG_CONFIG,
+                      offset, buffer);
+
+  DIFFSERV_CLUSTER_DLOG("%s: DiffServ Cluster Config data (len=%u) sent to peer switch %s, rc=%d\n",
+                        __FUNCTION__, offset, peerMacStr, rc);
+
+  return rc;
+}
+
+/*********************************************************************
+* @purpose  Check if room in message buffer to add IE, send and clear
+*           buffer when max message size is reached.
+*
+* @param    L7_uint32          size      @b{(input)} IE size to write
+* @param    clusterMemberID_t *memberID  @b{(input)} cluster member
+* @param    L7_uchar8         *buffer    @b{(inout)} message buffer
+* @param    L7_uint32         *offset    @b{(inout)} offset in buffer
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigMsgSendCheck(L7_uint32          size,
+                                          clusterMemberID_t *memberID,
+                                          L7_uchar8         *buffer,
+                                          L7_uint32         *offset)
+{
+  if (((*offset) + size) >= DS_CLUSTER_MSG_SIZE_MAX)
+  {
+    if (clusterMsgSend(memberID, CLUSTER_MSG_DELIVERY_RELIABLE,
+                       DS_CLUSTER_MSG_CONFIG,
+                       (*offset), buffer) != L7_SUCCESS)
+    {
+      DIFFSERV_CLUSTER_DLOG("%s: clusterMsgSend() call failed\n", __FUNCTION__);
+      return L7_FAILURE;
+    }
+    memset(buffer, 0, DS_CLUSTER_MSG_SIZE_MAX);
+    (*offset) = 0;
+  }
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Verify received DiffServ class config against system
+*           defines and features
+*
+* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
+* @param    L7_uint32         entryIndex  @b{(input)} config table array index
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    This assumes data has already been validated by the sender,
+*           so we can skip basic checks, such as range checking.  However,
+*           this system may not have the same prod/plat defines or features
+*           enabled, so need to fail if we cannot apply entire configuration.
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigClassVerify(L7_diffServCfg_t *pCfgData,
+                                         L7_uint32        entryIndex)
+{
+  L7_diffServClassHdr_t       *pEntry = &pCfgData->classHdr[entryIndex];
+  L7_uint32                   i, num = 0, lim = L7_DIFFSERV_RULE_PER_CLASS_LIM;
+
+  /* make sure current number of rules per class is within supported limit
+   *
+   * NOTE: For accuracy, search the hdrIndex field in the Class Rule table
+   *       and count the number of occurrences of this class entryIndex.
+   */
+  for (i = L7_DIFFSERV_CLASS_RULE_START; i < L7_DIFFSERV_CLASS_RULE_MAX; i++)
+  {
+    if (pCfgData->classRule[i].hdrIndexRef == entryIndex)
+    {
+      num++;
+    }
+  }
+  if (num > lim)
+  {
+    DIFFSERV_CLUSTER_DLOG("%s: too many rules (%u) for class \'%s\' - max=%u\n",
+                          __FUNCTION__, num, pEntry->mib.name, lim);
+    return L7_FAILURE;
+  }
+
+  /* check feature support */
+  if (dsmibClassFeaturePresentCheck(pEntry->mib.type) != L7_SUCCESS)
+  {
+    DIFFSERV_CLUSTER_DLOG("%s: class type \'%s\' not supported\n",
+                          __FUNCTION__, dsmibClassTypeStr[pEntry->mib.type]);
+    return L7_FAILURE;
+  }
+  if (dsmibClassProtoFeaturePresentCheck(pEntry->mib.l3Protocol) != L7_SUCCESS)
+  {
+    DIFFSERV_CLUSTER_DLOG("%s: class layer3 protocol \'%s\' not supported\n",
+                          __FUNCTION__, dsmibClassL3ProtoStr[pEntry->mib.l3Protocol]);
+    return L7_FAILURE;
+  }
+
+  /* for class type 'acl', check if aclType and aclNum are valid
+   *
+   * NOTE: Can only check this general case, since DiffServ does not
+   *       attempt to keep current with the latest ACL definition.  It
+   *       is possible to delete an ACL after it was used to create a
+   *       DiffServ class from it, so cannot check whether this ACL
+   *       currently exists.
+   */
+  if (L7_USMDB_MIB_DIFFSERV_CLASS_TYPE_ACL == pEntry->mib.type)
+  {
+    if ((L7_USMDB_MIB_DIFFSERV_CLASS_ACLTYPE_NONE == pEntry->mib.aclType) ||
+        (0 == pEntry->mib.aclNum))
+    {
+      DIFFSERV_CLUSTER_DLOG("%s: class type \'acl\' aclType or aclNum invalid\n",
+                            __FUNCTION__);
+      return L7_FAILURE;
+    }
+  }
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Verify received DiffServ class rule config against
+*           system defines and features
+*
+* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
+* @param    L7_uint32         entryIndex  @b{(input)} config table array index
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    This assumes data has already been validated by the sender,
+*           so we can skip basic checks, such as range checking.  However,
+*           this system may not have the same prod/plat defines or features
+*           enabled, so need to fail if we cannot apply entire configuration.
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigClassRuleVerify(L7_diffServCfg_t *pCfgData,
+                                             L7_uint32        entryIndex)
+{
+  L7_diffServClassRule_t      *pEntry = &pCfgData->classRule[entryIndex];
+  L7_uchar8                   nullMac[L7_MAC_ADDR_LEN] = { 0 };
+  dsmibClassRuleType_t        entryType;
+  dsmibClassRuleData_t        *pMatch;
+  L7_uint32                   range1, range2;
+  L7_BOOL                     isMasked;
+
+  entryType = pEntry->mib.entryType;
+  pMatch = &pEntry->mib.match;
+
+  /* check entry type feature support */
+  if (dsmibClassRuleFeaturePresentCheck(entryType) != L7_SUCCESS)
+  {
+    DIFFSERV_CLUSTER_DLOG("%s: rule type \'%s\' not supported\n",
+                          __FUNCTION__, dsmibClassRuleTypeStr[entryType]);
+    return L7_FAILURE;
+  }
+
+  /* check exclude flag feature support */
+  if (cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_CLASS_MATCH_EXCLUDE_FEATURE_ID)
+      != L7_TRUE)
+  {
+    if (L7_USMDB_MIB_DIFFSERV_TRUTH_VALUE_TRUE == pEntry->mib.excludeFlag)
+    {
+      DIFFSERV_CLUSTER_DLOG("%s: exclude flag not supported\n", __FUNCTION__);
+      return L7_FAILURE;
+    }
+  }
+
+  /* check masking feature support */
+  if (cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_CLASS_MATCH_SUPPORTS_MASKING_FEATURE_ID)
+      != L7_TRUE)
+  {
+    isMasked = L7_FALSE;
+    switch (entryType)
+    {
+      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTIP:
+        isMasked = (0 != pEntry->mib.match.dstIp.mask)
+                    ? L7_TRUE : L7_FALSE;
+        break;
+
+      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTIPV6:
+        isMasked = (0 != pEntry->mib.match.dstIpv6.ip6prefix.in6PrefixLen)
+                    ? L7_TRUE : L7_FALSE;
+        break;
+
+      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTMAC:
+        isMasked = (0 != memcmp(pEntry->mib.match.dstMac.mask, nullMac, sizeof(nullMac)))
+                    ? L7_TRUE : L7_FALSE;
+        break;
+
+      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCIP:
+        isMasked = (0 != pEntry->mib.match.srcIp.mask)
+                    ? L7_TRUE : L7_FALSE;
+        break;
+
+      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCIPV6:
+        isMasked = (0 != pEntry->mib.match.srcIpv6.ip6prefix.in6PrefixLen)
+                    ? L7_TRUE : L7_FALSE;
+        break;
+
+      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCMAC:
+        isMasked = (0 != memcmp(pEntry->mib.match.srcMac.mask, nullMac, sizeof(nullMac)))
+                    ? L7_TRUE : L7_FALSE;
+        break;
+
+      default:
+        break;
+
+    } /* endswitch */
+    if (L7_TRUE == isMasked)
+    {
+      DIFFSERV_CLUSTER_DLOG("%s: class rule type \'%s\' masking not supported\n",
+                            __FUNCTION__, dsmibClassRuleTypeStr[entryType]);
+      return L7_FAILURE;
+    }
+
+  } /* endif masking feature check */
+
+  /* check range feature support */
+  if (cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_CLASS_MATCH_SUPPORTS_RANGES_FEATURE_ID)
+      != L7_TRUE)
+  {
+    range1 = range2 = 0;
+    switch (entryType)
+    {
+      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_DSTL4PORT:
+        range1 = pMatch->dstL4Port.start;
+        range2 = pMatch->dstL4Port.end;
+        break;
+
+      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_SRCL4PORT:
+        range1 = pMatch->srcL4Port.start;
+        range2 = pMatch->srcL4Port.end;
+        break;
+
+      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_VLANID:
+        range1 = pMatch->vlanId.start;
+        range2 = pMatch->vlanId.end;
+        break;
+
+      case L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_VLANID2:
+        range1 = pMatch->vlanId2.start;
+        range2 = pMatch->vlanId2.end;
+        break;
+
+      default:
+        break;
+
+    } /* endswitch */
+    if (range1 != range2)
+    {
+      DIFFSERV_CLUSTER_DLOG("%s: class rule type \'%s\' range not supported\n",
+                            __FUNCTION__, dsmibClassRuleTypeStr[entryType]);
+      return L7_FAILURE;
+    }
+  } /* endif range feature check */
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Verify received DiffServ policy config against
+*           system defines and features
+*
+* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
+* @param    L7_uint32         entryIndex  @b{(input)} config table array index
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    This assumes data has already been validated by the sender,
+*           so we can skip basic checks, such as range checking.  However,
+*           this system may not have the same prod/plat defines or features
+*           enabled, so need to fail if we cannot apply entire configuration.
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigPolicyVerify(L7_diffServCfg_t *pCfgData,
+                                          L7_uint32        entryIndex)
+{
+  L7_diffServPolicyHdr_t      *pEntry = &pCfgData->policyHdr[entryIndex];
+  L7_diffServPolicyInst_t     *pInstEntry;
+  L7_diffServClassHdr_t       *pClassEntry;
+  L7_diffServClassRule_t      *pRuleEntry;
+  L7_uint32                   instIndex;
+  L7_uint32                   classIndex, refClassIndex, classRuleIndex;
+  dsmibClassL3Protocol_t      savedL3Protocol, classL3Protocol;
+  L7_uint32                   num = 0, lim = L7_DIFFSERV_INST_PER_POLICY_LIM;
+
+  /* make sure current number of instances per policy is within supported limit
+   *
+   * NOTE: For accuracy, search the hdrIndex field in the Policy Inst table
+   *       and count the number of occurrences of this policy entryIndex.
+   */
+  if (diffServClusterPolicyInstCountGet(entryIndex, &num) != L7_SUCCESS)
+  {
+    DIFFSERV_CLUSTER_DLOG("%s: error obtaining instance count for policy \'%s\'\n",
+                          __FUNCTION__, pEntry->mib.name);
+    return L7_FAILURE;
+  }
+  if (num > lim)
+  {
+    DIFFSERV_CLUSTER_DLOG("%s: too many instances (%u) for policy \'%s\' - max=%u\n",
+                          __FUNCTION__, num, pEntry->mib.name, lim);
+    return L7_FAILURE;
+  }
+
+  /* check policy type feature support
+   *
+   * NOTE: There is no specific feature ID for the policy type, so check the
+   *       service interface direction support instead, since this is how the
+   *       user interface controls whether to allow certain policy types to be
+   *       created.
+   */
+  if ((cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_SERVICE_IN_SLOTPORT_FEATURE_ID)
+       != L7_TRUE) &&
+      (cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_SERVICE_IN_ALLPORTS_FEATURE_ID)
+       != L7_TRUE))
+  {
+    if (L7_USMDB_MIB_DIFFSERV_POLICY_TYPE_IN == pEntry->mib.type)
+    {
+      DIFFSERV_CLUSTER_DLOG("%s: policy type \'%s\' not supported\n",
+                            __FUNCTION__, dsmibPolicyTypeStr[pEntry->mib.type]);
+      return L7_FAILURE;
+    }
+  }
+  if ((cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_SERVICE_OUT_SLOTPORT_FEATURE_ID)
+       != L7_TRUE) &&
+      (cnfgrIsFeaturePresent(dsCompId, L7_DIFFSERV_SERVICE_OUT_ALLPORTS_FEATURE_ID)
+       != L7_TRUE))
+  {
+    if (L7_USMDB_MIB_DIFFSERV_POLICY_TYPE_OUT == pEntry->mib.type)
+    {
+      DIFFSERV_CLUSTER_DLOG("%s: policy type \'%s\' not supported\n",
+                            __FUNCTION__, dsmibPolicyTypeStr[pEntry->mib.type]);
+      return L7_FAILURE;
+    }
+  }
+
+  /* check feature that restricts classes used for outbound policy instances
+   * to those containing only IP DSCP or IP Precedence match rules
+   */
+  if (L7_USMDB_MIB_DIFFSERV_POLICY_TYPE_OUT == pEntry->mib.type)
+  {
+    if (cnfgrIsFeaturePresent(dsCompId,
+                              L7_DIFFSERV_POLICY_OUT_CLASS_UNRESTRICTED_FEATURE_ID)
+        != L7_TRUE)
+    {
+      instIndex = pEntry->chainIndex;           /* first instance for this policy */
+
+      while (0 != instIndex)
+      {
+        pInstEntry = &pCfgData->policyInst[instIndex];
+
+        classIndex = pInstEntry->mib.classIndex;
+        refClassIndex = classIndex;             /* start with current class instance */
+
+        /* walk cascaded class reference chain to evaluate all match conditions for
+         * this policy instance
+         *
+         * each class can have at most one refClass rule, so can process referenced
+         * class after all rules within current class (i.e. recursion not needed)
+         */
+        while (0 != refClassIndex)
+        {
+          pClassEntry = &pCfgData->classHdr[refClassIndex];
+          classRuleIndex = pClassEntry->chainIndex;
+
+          /* this becomes nonzero again only if current class contains another ref class */
+          refClassIndex = 0;
+
+          while (0 != classRuleIndex)
+          {
+            pRuleEntry = &pCfgData->classRule[classRuleIndex];
+
+            if (L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_REFCLASS
+                == pRuleEntry->mib.entryType)
+            {
+              refClassIndex = pRuleEntry->mib.match.refClassIndex;
+            }
+            else
+            {
+              /* only IP DSCP or IP Precedence rule entry type allowed */
+              if ((L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_IPDSCP
+                   != pRuleEntry->mib.entryType) &&
+                  (L7_USMDB_MIB_DIFFSERV_CLASS_RULE_TYPE_IPPRECEDENCE
+                   != pRuleEntry->mib.entryType))
+              {
+                /* found unsupported class rule match condition used in outbound policy */
+                DIFFSERV_CLUSTER_DLOG("%s: class rule type \'%s\' not valid "
+                                      "for outbound policy \'%s\'\n",
+                                      __FUNCTION__,
+                                      dsmibClassRuleTypeStr[pRuleEntry->mib.entryType],
+                                      pEntry->mib.name);
+                return L7_FAILURE;
+              }
+            }
+
+            classRuleIndex = pRuleEntry->chainIndex;
+
+          } /* endwhile classRuleIndex */
+
+        } /* endwhile refClassIndex */
+
+        instIndex = pInstEntry->chainIndex;     /* next instance for this policy */
+
+      } /* endwhile instIndex */
+    } /* endif feature present check */
+  } /* endif policy type out */
+
+  /* check mixed ipv4/ipv6 policy instance feature support */
+  if (cnfgrIsFeaturePresent(dsCompId,
+                            L7_DIFFSERV_POLICY_MIXED_IPV6_FEATURE_ID)
+      != L7_TRUE)
+  {
+    savedL3Protocol = L7_USMDB_MIB_DIFFSERV_CLASS_L3PROTOCOL_NONE;    /* init */
+
+    instIndex = pEntry->chainIndex;           /* first instance for this policy */
+
+    while (0 != instIndex)
+    {
+      pInstEntry = &pCfgData->policyInst[instIndex];
+
+      classIndex = pInstEntry->mib.classIndex;
+      pClassEntry = &pCfgData->classHdr[classIndex];
+      classL3Protocol = pClassEntry->mib.l3Protocol;
+
+      /* l3 protocol of all instance classes must be the same (ignoring those
+       * whose class mib.l3Protocol field is not set)
+       *
+       * no need to scan refClass chain, since all classes within a chain
+       * are guaranteed to have the same l3Protocol value
+       */
+      if (L7_USMDB_MIB_DIFFSERV_CLASS_L3PROTOCOL_NONE != classL3Protocol)
+      {
+        if (L7_USMDB_MIB_DIFFSERV_CLASS_L3PROTOCOL_NONE == savedL3Protocol)
+        {
+          savedL3Protocol = classL3Protocol;    /* cache first valid value */
+        }
+        else
+        {
+          if (classL3Protocol != savedL3Protocol)
+          {
+            /* inconsistent l3Protocol among classes comprising this policy definition */
+            DIFFSERV_CLUSTER_DLOG("%s: inconsistent l3Protocol among classes "
+                                  "comprising policy \'%s\'\n",
+                                  __FUNCTION__, pEntry->mib.name);
+            return L7_FAILURE;
+          }
+        }
+      }
+
+      instIndex = pInstEntry->chainIndex;     /* next instance for this policy */
+
+    } /* endwhile instIndex */
+
+  } /* endif feature present check */
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Verify received DiffServ policy instance config against
+*           system defines and features
+*
+* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
+* @param    L7_uint32         entryIndex  @b{(input)} config table array index
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    This assumes data has already been validated by the sender,
+*           so we can skip basic checks, such as range checking.  However,
+*           this system may not have the same prod/plat defines or features
+*           enabled, so need to fail if we cannot apply entire configuration.
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigPolicyInstVerify(L7_diffServCfg_t *pCfgData,
+                                              L7_uint32        entryIndex)
+{
+  L7_diffServPolicyInst_t     *pEntry = &pCfgData->policyInst[entryIndex];
+  L7_uint32                   i, num = 0, lim = L7_DIFFSERV_ATTR_PER_INST_LIM;
+
+  /* make sure current number of attributes per policy instance is within
+   * supported limit
+   *
+   * NOTE: For accuracy, search the instIndexRef field in the Policy Attr table
+   *       and count the number of occurrences of this policy instance
+   *       entryIndex.
+   */
+  for (i = L7_DIFFSERV_POLICY_ATTR_START; i < L7_DIFFSERV_POLICY_ATTR_MAX; i++)
+  {
+    if (pCfgData->policyAttr[i].instIndexRef == entryIndex)
+    {
+      num++;
+    }
+  }
+  if (num > lim)
+  {
+    DIFFSERV_CLUSTER_DLOG("%s: too many attributes (%u) for instance %u of policy \'%s\' - max=%u\n",
+                          __FUNCTION__, num, entryIndex,
+                          pCfgData->policyHdr[pEntry->hdrIndexRef].mib.name,
+                          lim);
+    return L7_FAILURE;
+  }
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Verify received DiffServ policy attribute config against
+*           system defines and features
+*
+* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
+* @param    L7_uint32         entryIndex  @b{(input)} config table array index
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    This assumes data has already been validated by the sender,
+*           so we can skip basic checks, such as range checking.  However,
+*           this system may not have the same prod/plat defines or features
+*           enabled, so need to fail if we cannot apply entire configuration.
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigPolicyAttrVerify(L7_diffServCfg_t *pCfgData,
+                                              L7_uint32        entryIndex)
+{
+  L7_diffServPolicyAttr_t     *pEntry = &pCfgData->policyAttr[entryIndex];
+  dsmibPolicyAttrType_t       entryType;
+  dsmibPolicyAttrData_t       *pStmt;
+  dsmibPolicyAttrType_t       type1, type2, type3;
+  L7_uchar8                   markVal1, markVal2, markVal3;
+  dsmibPoliceColor_t          colorMode1, colorMode2;
+  nimConfigID_t               *pConfigId;
+  L7_uint32                   intIfNum;
+
+  entryType = pEntry->mib.entryType;
+  pStmt = &pEntry->mib.stmt;
+
+  /* check entry type feature support */
+  if (L7_SUCCESS != dsmibPolicyAttrFeaturePresentCheck(entryType))
+  {
+    DIFFSERV_CLUSTER_DLOG("%s: policy attribute type \'%s\' not supported\n",
+                          __FUNCTION__, dsmibPolicyAttrTypeStr[entryType]);
+    return L7_FAILURE;
+  }
+
+  /* check assign queue ID within supported range */
+  if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_ASSIGN_QUEUE == entryType)
+  {
+    if ((pStmt->assignQueue.qid < L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_ASSIGN_QUEUE_MIN) ||
+        (pStmt->assignQueue.qid > L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_ASSIGN_QUEUE_MAX))
+    {
+      DIFFSERV_CLUSTER_DLOG("%s: assign queue ID (%u) out of range\n",
+                            __FUNCTION__, pStmt->assignQueue.qid);
+      return L7_FAILURE;
+    }
+  }
+
+  /* check IP DSCP mark value */
+  if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == entryType)
+  {
+    if (L7_TRUE != policyAttrIpDscpValSupported[pStmt->markIpDscp.val])
+    {
+      DIFFSERV_CLUSTER_DLOG("%s: IP DSCP mark value (%u) not supported\n",
+                            __FUNCTION__, pStmt->assignQueue.qid);
+      return L7_FAILURE;
+    }
+  }
+
+  /* check policing actions and any mark IP DSCP values
+   *
+   * convert police action to its comparable entry type and use it to
+   * check the feature support
+   */
+
+  type1 = type2 = type3 = L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_NONE;
+  markVal1 = markVal2 = markVal3 = 0;
+  colorMode1 = colorMode2 = L7_USMDB_MIB_DIFFSERV_POLICE_COLOR_NONE;
+
+  if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SIMPLE == entryType)
+  {
+    type1 = _dsClusterPoliceActToEntryType(pStmt->policeSimple.conformAct);
+    type3 = _dsClusterPoliceActToEntryType(pStmt->policeSimple.nonconformAct);
+    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type1)
+    {
+      markVal1 = pStmt->policeSimple.conformVal;
+    }
+    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type3)
+    {
+      markVal3 = pStmt->policeSimple.nonconformVal;
+    }
+    colorMode1 = pStmt->policeSimple.colorConformMode;
+  }
+  else if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_SINGLERATE == entryType)
+  {
+    type1 = _dsClusterPoliceActToEntryType(pStmt->policeSingleRate.conformAct);
+    type2 = _dsClusterPoliceActToEntryType(pStmt->policeSingleRate.exceedAct);
+    type3 = _dsClusterPoliceActToEntryType(pStmt->policeSingleRate.nonconformAct);
+    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type1)
+    {
+      markVal1 = pStmt->policeSingleRate.conformVal;
+    }
+    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type2)
+    {
+      markVal2 = pStmt->policeSingleRate.exceedVal;
+    }
+    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type3)
+    {
+      markVal3 = pStmt->policeSingleRate.nonconformVal;
+    }
+    colorMode1 = pStmt->policeSingleRate.colorConformMode;
+    colorMode2 = pStmt->policeSingleRate.colorExceedMode;
+  }
+  else if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_POLICE_TWORATE == entryType)
+  {
+    type1 = _dsClusterPoliceActToEntryType(pStmt->policeTwoRate.conformAct);
+    type2 = _dsClusterPoliceActToEntryType(pStmt->policeTwoRate.exceedAct);
+    type3 = _dsClusterPoliceActToEntryType(pStmt->policeTwoRate.nonconformAct);
+    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type1)
+    {
+      markVal1 = pStmt->policeTwoRate.conformVal;
+    }
+    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type2)
+    {
+      markVal2 = pStmt->policeTwoRate.exceedVal;
+    }
+    if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MARK_IPDSCPVAL == type3)
+    {
+      markVal3 = pStmt->policeTwoRate.nonconformVal;
+    }
+    colorMode1 = pStmt->policeTwoRate.colorConformMode;
+    colorMode2 = pStmt->policeTwoRate.colorExceedMode;
+  }
+  /* check police action
+   * (default value of 'none' is accepted if DiffServ is supported)
+   */
+  if ((L7_SUCCESS != dsmibPolicyAttrFeaturePresentCheck(type1)) ||
+      (L7_SUCCESS != dsmibPolicyAttrFeaturePresentCheck(type2)) ||
+      (L7_SUCCESS != dsmibPolicyAttrFeaturePresentCheck(type3)))
+  {
+    DIFFSERV_CLUSTER_DLOG("%s: police action not supported\n",
+                          __FUNCTION__);
+    return L7_FAILURE;
+  }
+  /* check police IP DSCP mark value
+   * (default mark value of 0 is always considered supported)
+   */
+  if ((L7_TRUE != policyAttrIpDscpValSupported[markVal1]) ||
+      (L7_TRUE != policyAttrIpDscpValSupported[markVal2]) ||
+      (L7_TRUE != policyAttrIpDscpValSupported[markVal3]))
+  {
+    DIFFSERV_CLUSTER_DLOG("%s: police IP DSCP mark value not supported\n",
+                          __FUNCTION__);
+    return L7_FAILURE;
+  }
+  /* check policing color-aware support */
+  if (L7_TRUE != cnfgrIsFeaturePresent(dsCompId,
+                                       L7_DIFFSERV_POLICY_ATTR_POLICE_COLORAWARE_FEATURE_ID))
+  {
+    if ((L7_TRUE == L7_USMDB_MIB_DIFFSERV_POLICE_COLOR_MODE_IS_AWARE(colorMode1)) ||
+        (L7_TRUE == L7_USMDB_MIB_DIFFSERV_POLICE_COLOR_MODE_IS_AWARE(colorMode2)))
+    {
+      DIFFSERV_CLUSTER_DLOG("%s: police color aware mode not supported\n",
+                            __FUNCTION__);
+      return L7_FAILURE;
+    }
+  }
+
+  /* check for valid mirror/redirect intf (u/s/p) */
+  pConfigId = L7_NULLPTR;
+  if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_MIRROR == entryType)
+  {
+    pConfigId = &pStmt->mirror.configId;
+  }
+  else if (L7_USMDB_MIB_DIFFSERV_POLICY_ATTR_TYPE_REDIRECT == entryType)
+  {
+    pConfigId = &pStmt->redirect.configId;
+  }
+  /* get intIfNum and check for valid DiffServ interface  */
+  if (L7_NULLPTR != pConfigId)
+  {
+    if ((L7_SUCCESS != nimIntIfFromConfigIDGet(pConfigId, &intIfNum)) ||
+        (L7_TRUE != diffServIsValidIntf(intIfNum)))
+    {
+      DIFFSERV_CLUSTER_DLOG("%s: mirror/redirect DiffServ interface not valid\n",
+                            __FUNCTION__);
+      return L7_FAILURE;
+    }
+  }
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Remap DiffServ service intf config from old to new policy indexes
+*
+* @param    L7_diffServCfg_t  *pCfgData   @{(input)} received DiffServ config data
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    The service intf table is NOT part of the cluster config
+*           passed from sender to receiver.
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigServiceIntfRemap(L7_diffServCfg_t *pCfgData)
+{
+  L7_diffServIntfCfg_t        *pEntry;
+  L7_diffServPolicyHdr_t      *pPolicyOld, *pPolicyNew;
+  L7_diffServService_t        *pService;
+  dsmibServiceIfDir_t         dir;
+  L7_uint32                   i, j;
+  L7_uint32                   policyIndex;
+  L7_uint32                   policyIndexXlate[L7_DIFFSERV_POLICY_HDR_MAX];
+
+  /* gather current system operational config into temp config struct */
+  if (diffServBuildUserConfigData(L7_DIFFSERV_CFG_VER_CURRENT, dsClusterTmpCfg)
+      != L7_SUCCESS)
+  {
+    return L7_FAILURE;
+  }
+
+  /* copy all temp config entries into received config struct */
+  for (i = 0; i < L7_DIFFSERV_INTF_MAX_COUNT; i++)
+  {
+    memcpy(&pCfgData->diffServIntfCfg[i], &dsClusterTmpCfg->diffServIntfCfg[i],
+           sizeof(L7_diffServIntfCfg_t));
+  }
+
+  /* build a temporary policy index translation table */
+  memset(policyIndexXlate, 0, sizeof(policyIndexXlate));
+
+  for (i = L7_DIFFSERV_POLICY_HDR_START; i < L7_DIFFSERV_POLICY_HDR_MAX; i++)
+  {
+    pPolicyOld = &dsClusterTmpCfg->policyHdr[i];
+
+    if (L7_TRUE != pPolicyOld->inUse)
+    {
+      break;
+    }
+
+    for (j = L7_DIFFSERV_POLICY_HDR_START; j < L7_DIFFSERV_POLICY_HDR_MAX; j++)
+    {
+      pPolicyNew = &pCfgData->policyHdr[j];
+
+      if (L7_TRUE != pPolicyNew->inUse)
+      {
+        break;
+      }
+
+      if (0 == strncmp(pPolicyOld->mib.name, pPolicyNew->mib.name,
+                       sizeof(pPolicyOld->mib.name)))
+      {
+        /* found policy name match -- set new policy index in xlate table */
+        policyIndexXlate[pPolicyOld->mib.index] = pPolicyNew->mib.index;
+        break;
+      }
+
+    } /* endfor j*/
+
+  } /* endfor i */
+
+  /* adjust the policy index in each service {intf,direction} entry, as needed */
+  for (i = 0; i < L7_DIFFSERV_INTF_MAX_COUNT; i++)
+  {
+    pEntry = &pCfgData->diffServIntfCfg[i];
+
+    for (dir = L7_USMDB_MIB_DIFFSERV_IF_DIRECTION_IN;
+         dir <= L7_USMDB_MIB_DIFFSERV_IF_DIRECTION_OUT;
+         dir++)
+    {
+
+      if (L7_USMDB_MIB_DIFFSERV_IF_DIRECTION_IN == dir)
+      {
+        pService = &pEntry->serviceIn;
+      }
+      else
+      {
+        pService = &pEntry->serviceOut;
+      }
+
+      if (L7_TRUE == pService->inUse)
+      {
+        policyIndex = pService->mib.policyIndex;
+        if (0 != policyIndex)
+        {
+          if (0 != policyIndexXlate[policyIndex])
+          {
+            if (policyIndex != policyIndexXlate[policyIndex])
+            {
+              DIFFSERV_CLUSTER_DLOG("%s: Remapping service mib index %u, dir %u from policy index %u to %u\n",
+                                    __FUNCTION__, pService->mib.index, pService->mib.direction,
+                                    pService->mib.policyIndex, policyIndexXlate[policyIndex]);
+              pService->mib.policyIndex = policyIndexXlate[policyIndex];
+            }
+          }
+          else
+          {
+            /* this policy is no longer available -- remove from intf config */
+            L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+                    "%s: Obsolete policy index %u removed from service mib index %u, dir \'%s\'.\n",
+                    __FUNCTION__, policyIndex, pService->mib.index,
+                    (L7_USMDB_MIB_DIFFSERV_IF_DIRECTION_IN == dir) ? "in" : "out");
+            pService->mib.policyIndex = 0;
+          }
+        }
+      } /* endif inUse */
+
+    } /* endfor dir */
+
+  } /* endfor i */
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Verify received configuration against system defines and features
+*
+* @param    L7_diffServCfg_t  *pCfgData @{(input)} received DiffServ config data
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    This assumes data has already been validated by the sender,
+*           so we can skip basic checks, such as range checking.  However,
+*           this system may not have the same prod/plat defines or features
+*           enabled, so need to fail if we cannot apply entire configuration.
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterConfigVerify(L7_diffServCfg_t *pCfgData)
+{
+  L7_RC_t                     rc = L7_SUCCESS;
+  dsmibTableId_t              tableID;
+  L7_uint32                   i, startEnt, maxEnt;
+  dsClusterTableParms_t       *pTable;
+
+  DIFFSERV_CLUSTER_DLOG("ENTERING %s\n", __FUNCTION__);
+
+  /* iterate through each table ID */
+  for (tableID = DSMIB_TABLE_ID_CLASS; tableID <= DSMIB_TABLE_ID_POLICY_ATTR; tableID++)
+  {
+    pTable = &dsClusterTableParms[tableID];
+
+    startEnt = pTable->startEnt;
+    maxEnt   = pTable->maxEnt;
+
+    /* if validation fn ptr is null, assume there is nothing to check */
+    if (L7_NULLPTR == pTable->verifyFn)
+    {
+      continue;
+    }
+
+    for (i = startEnt; i < maxEnt; i++)
+    {
+      /* array entry not in use means end of the configured list */
+      if (_dsClusterConfigEntryInUseGet(tableID, pCfgData, i) != L7_TRUE)
+        break;
+
+      /* invoke table-specific validation function to check applicability of
+       * config on this system
+       */
+      rc = pTable->verifyFn(pCfgData, i);
+      if (L7_SUCCESS != rc)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+                "%s: Failed verification check for received DiffServ %s table config\n",
+                __FUNCTION__, dsmibPrvtTableIdStr[tableID]);
+        break;
+      }
+
+    } /* endfor i */
+
+    /* check for errors */
+    if (L7_SUCCESS != rc)
+    {
+      break;
+    }
+
+  } /* endfor tableID */
+
+  /* create new service intf config from the existing config by mapping
+   * policy indexes from old to new via policy name lookup
+   *
+   * NOTE: Any policy index translation failures cause a log msg to be
+   *       generated and result in the removal of the non-existent policy
+   *       from the service interface, but does not result in a config failure.
+   */
+  if (diffServClusterConfigServiceIntfRemap(pCfgData) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: Error mapping DiffServ service interface config.\n",
+            __FUNCTION__, dsmibPrvtTableIdStr[tableID]);
+    rc = L7_FAILURE;
+  }
+
+  DIFFSERV_CLUSTER_DLOG("LEAVING %s (rc = %d)\n", __FUNCTION__, rc);
+
+  return rc;
+}
+
+/*********************************************************************
+* @purpose  Function to apply entire received configuration
+*
+* @param    void
+*
+* @returns  void
+*
+* @notes    This function is not allowed to fail. There is no way to
+*           abort once the configuration has been verified successfully.
+*
+* @end
+*********************************************************************/
+void diffServClusterConfigApply(void)
+{
+  L7_BOOL         needDefault = L7_FALSE;
+  L7_char8        *pMsg = L7_NULLPTR;
+
+  DIFFSERV_CLUSTER_DLOG("ENTERING %s\n", __FUNCTION__);
+
+  /* save current system operational config into temp config struct
+   * for a possible restore scenario
+   */
+  if (diffServBuildUserConfigData(L7_DIFFSERV_CFG_VER_CURRENT, dsClusterTmpCfg)
+      != L7_SUCCESS)
+  {
+    needDefault = L7_TRUE;
+  }
+
+  /* apply received config (with modified service intf info) to switch */
+  if (diffServReplace(dsClusterRxCfg) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+            "%s: Unexpected error applying received DiffServ config to switch.\n",
+            __FUNCTION__);
+
+    /* try restoring config to what it was */
+    if ((needDefault == L7_FALSE) &&
+        (diffServReplace(dsClusterTmpCfg) == L7_SUCCESS))
+    {
+      pMsg = "Previously existing DiffServ config successfully restored.";
+    }
+    else
+    {
+      /* restore using default config */
+      if (diffServRestore() == L7_SUCCESS)
+      {
+        pMsg = "DiffServ config has been reset to factory defaults.";
+      }
+      else
+      {
+        pMsg = "Error setting DiffServ config to factory defaults. Please reset device.";
+      }
+    }
+
+    /* log additional information regarding the outcome */
+    if (pMsg != L7_NULLPTR)
+    {
+      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+              "%s: %s\n", __FUNCTION__, pMsg);
+    }
+  }
+
+  DIFFSERV_CLUSTER_DLOG("LEAVING %s\n", __FUNCTION__);
+
+  return;
+}
+
+/*********************************************************************
+* @purpose  Function to process configuration receive commands
+*
+* @param    clusterConfigCmd  cmd  @b{(input)} cluster member
+*
+* @returns  void
+*
+* @notes
+*
+* @end
+*********************************************************************/
+void diffServClusterConfigRxCmdProcess(clusterConfigCmd cmd)
+{
+  L7_RC_t rc = L7_FAILURE;
+
+  switch (cmd)
+  {
+    case CLUSTER_CONFIG_CMD_START_TRANSFER:
+    case CLUSTER_CONFIG_CMD_ABORT:
+      if (CLUSTER_CONFIG_CMD_START_TRANSFER == cmd)
+      {
+        DIFFSERV_CLUSTER_DLOG("%s: CLUSTER START received\n", __FUNCTION__);
+      }
+      else
+      {
+        DIFFSERV_CLUSTER_DLOG("%s: CLUSTER ABORT received\n", __FUNCTION__);
+      }
+      /* initialize temporary structure to receive entire configuration from peer */
+      _dsClusterCfgStructInit(dsClusterRxCfg, "dsClusterRxCfg");
+      /* initialize variables used for debugging */
+      dsClusterRxCfgMsgStarted = L7_FALSE;
+      dsClusterRxCfgIeExpected = DS_CLUSTER_MSG_IE_NONE;
+      dsClusterRxError = L7_FALSE;
+      dsClusterRxInProg = (CLUSTER_CONFIG_CMD_START_TRANSFER == cmd) ? L7_TRUE : L7_FALSE;
+      break;
+
+    case CLUSTER_CONFIG_CMD_END_TRANSFER:
+      DIFFSERV_CLUSTER_DLOG("%s: CLUSTER END received (rxError=%u)\n",
+                            __FUNCTION__, dsClusterRxError);
+      if (L7_TRUE == dsClusterRxError)
+      {
+        rc = L7_FAILURE;
+      }
+      else
+      {
+        rc = diffServClusterConfigVerify(dsClusterRxCfg);
+        if (L7_SUCCESS != rc)
+        {
+          DIFFSERV_CLUSTER_DLOG("%s: DiffServ received config verification failed.\n", __FUNCTION__);
+          L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+                  "%s: DiffServ received config verification failed.\n", __FUNCTION__);
+        }
+      }
+      if (clusterConfigRxDone(CLUSTER_CFG_ID(QOS_DIFFSERV), rc) != L7_SUCCESS)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+                "%s: clusterConfigRxDone failed.\n", __FUNCTION__);
+      }
+      if (L7_SUCCESS != rc)
+      {
+        dsClusterRxInProg = L7_FALSE;
+      }
+      DIFFSERV_CLUSTER_DLOG("%s: CLUSTER END completed (rxError=%u, rc=%u)\n",
+                            __FUNCTION__, dsClusterRxError, rc);
+      break;
+
+    case CLUSTER_CONFIG_CMD_APPLY:
+      DIFFSERV_CLUSTER_DLOG("%s: CLUSTER APPLY received\n", __FUNCTION__);
+      diffServClusterConfigApply();
+      clusterConfigRxApplyDone(CLUSTER_CFG_ID(QOS_DIFFSERV));
+      dsClusterRxInProg = L7_FALSE;
+      DIFFSERV_CLUSTER_DLOG("%s: CLUSTER APPLY completed\n", __FUNCTION__);
+      break;
+
+    default:
+      DIFFSERV_CLUSTER_DLOG("%s: CLUSTER <UNKNOWN> received (cmd=%u)\n",
+                            __FUNCTION__, cmd);
+      L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
+              "%s: Received unknown clusterConfigCmd=%u\n", __FUNCTION__, cmd);
+      break;
+  }
+
+  return;
+}
+
+/*********************************************************************
+* @purpose  Indicates if DiffServ cluster config receive operation currently in progress
+*
+* @param    void
+*
+* @returns  L7_TRUE
+* @returns  L7_FALSE
+*
+* @notes
+*
+* @end
+*********************************************************************/
+L7_BOOL diffServClusterIsRxInProgress(void)
+{
+  return dsClusterRxInProg;
+}
+
+/*********************************************************************
+* @purpose  Translate a config push policy name into its associated Policy Table index
+*
+* @param    stringPtr     @b{(input)}  Policy name string pointer
+* @param    pPolicyIndex  @b{(output)} Pointer to policy index value
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    Searches the received config push data for a matching
+*           policy name.
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterPolicyNameToIndex(L7_uchar8 *stringPtr,
+                                         L7_uint32 *pPolicyIndex)
+{
+  dsmibTableId_t              tableID = DSMIB_TABLE_ID_POLICY;
+  L7_diffServCfg_t            *pCfgData = dsClusterRxCfg;
+  L7_uint32                   len;
+  L7_uint32                   i, startEnt, maxEnt;
+  dsClusterTableParms_t       *pTable;
+  L7_diffServPolicyHdr_t      *pEntry;
+
+  /* check inputs */
+  if ((stringPtr == L7_NULLPTR) ||
+      (pPolicyIndex == L7_NULLPTR))
+  {
+    return L7_FAILURE;
+  }
+
+  /* check the length of the policy name string */
+  len = (L7_uint32)strlen((char *)stringPtr);
+  if ((len == 0) || (len > L7_USMDB_MIB_DIFFSERV_POLICY_NAME_MAX))
+  {
+    return L7_FAILURE;
+  }
+
+  /* config push RX data only valid while push receive operation still in progress
+   * (i.e. prior to the conclusion of the data apply)
+   */
+  if (diffServClusterIsRxInProgress() != L7_TRUE)
+  {
+    return L7_FAILURE;
+  }
+
+  pTable = &dsClusterTableParms[tableID];
+
+  startEnt = pTable->startEnt;
+  maxEnt   = pTable->maxEnt;
+
+  for (i = startEnt; i < maxEnt; i++)
+  {
+    pEntry = &pCfgData->policyHdr[i];
+
+    /* array entry not in use means end of the configured list */
+    if (pEntry->inUse != L7_TRUE)
+      break;
+
+    /* compare against name in existing row */
+    if (strcmp((char *)stringPtr, (char *)pEntry->mib.name) == 0)
+    {
+      *pPolicyIndex = pEntry->mib.index;
+      return L7_SUCCESS;
+    }
+
+  } /* endfor i */
+
+  *pPolicyIndex = 0;
+  return L7_FAILURE;
+}
+
+/*********************************************************************
+* @purpose  Get current number of instances in a config push policy definition
+*
+* @param    policyIndex   @b{(input)}  Policy index
+* @param    pCount        @b{(output)} Pointer to instance count output location
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes
+*
+* @end
+*********************************************************************/
+L7_RC_t diffServClusterPolicyInstCountGet(L7_uint32 policyIndex,
+                                          L7_uint32 *pCount)
+{
+  L7_diffServCfg_t            *pCfgData = dsClusterRxCfg;
+  L7_uint32                   instCount = 0;
+  L7_uint32                   i;
+
+  /* check inputs */
+  if (pCount == L7_NULLPTR)
+  {
+    return L7_FAILURE;
+  }
+
+  /* config push RX data only valid while push receive operation still in progress
+   * (i.e. prior to the conclusion of the data apply)
+   */
+  if (diffServClusterIsRxInProgress() != L7_TRUE)
+  {
+    return L7_FAILURE;
+  }
+
+  /* count the number of instances in this policy
+   *
+   * NOTE: For accuracy, search the hdrIndex field in the Policy Inst table
+   *       and count the number of occurrences of this policy entryIndex.
+   */
+  for (i = L7_DIFFSERV_POLICY_INST_START; i < L7_DIFFSERV_POLICY_INST_MAX; i++)
+  {
+    if (pCfgData->policyInst[i].hdrIndexRef == policyIndex)
+    {
+      instCount++;
+    }
+  }
+
+  *pCount = instCount;
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Function to enable/disable debug via devshell
+*
+* @param    L7_BOOL debug  @b{(input)} L7_TRUE/L7_FALSE
+*
+* @returns  void
+*
+* @notes
+*
+* @end
+*********************************************************************/
+void diffServClusterDebugSet(L7_BOOL debug)
+{
+  dsClusterDebug = debug;
+  return;
+}
Index: src/application/security/dot1x/core/dot1x_db.c
===================================================================
--- src/application/security/dot1x/core/dot1x_db.c	(revision 7370)
+++ src/application/security/dot1x/core/dot1x_db.c	(revision 7371)
@@ -1,1154 +1,1154 @@
-/*********************************************************************
-*
-* (C) Copyright Broadcom Corporation 2003-2007
-*
-**********************************************************************
-* @filename  dot1x_db.c
-*
-* @purpose   dot1x data store file
-*
-* @component dot1x
-*
-* @comments  none
-*
-* @create    10/11/2007
-*
-* @author    PKB
-*
-* @end
-*             
-**********************************************************************/
-
-#include "dot1x_include.h"
-#include "avl_api.h"
-
-
-/* Global parameters */
-static avlTree_t                dot1xLogicalPortTreeDb;
-static avlTreeTables_t          *dot1xLogicalPortTreeHeap=L7_NULLPTR;
-static dot1xLogicalPortInfo_t   *dot1xLogicalPortDataHeap=L7_NULLPTR;
-
-static dot1xAuthHistoryLogTableDb_t dot1xAuthHistoryLogDb;
-
-static L7_uint32 dot1xAuthHistEntryIndexIntfCount[L7_MAX_PORT_COUNT] = {0};
-static L7_uint32 dot1xAuthHistEntryIndexCount = 0;
-static L7_uint32 dot1xAuthHistCurrentEntryIndex = 0;
-
-static L7_RC_t dot1xAuthHistoryLogCreateEntryIndex(L7_uint32 *entryIndex);
-
-
-/*********************************************************************
-* @purpose  Initialize Logical Port Info Database
-*
-* @param    nodeCount    @b{(input)} The number of nodes to be created. 
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments none
-*       
-* @end
-*********************************************************************/
-L7_RC_t dot1xLogicalPortInfoDBInit(L7_uint32 nodeCount)
-{
-  /* Allocate the Heap structures */
-  dot1xLogicalPortTreeHeap = (avlTreeTables_t *)osapiMalloc(L7_DOT1X_COMPONENT_ID,
-                                                            nodeCount * sizeof(avlTreeTables_t));
-
-  dot1xLogicalPortDataHeap  = (dot1xLogicalPortInfo_t *)osapiMalloc(L7_DOT1X_COMPONENT_ID,
-                                                                    nodeCount * sizeof(dot1xLogicalPortInfo_t));
-
-  /* validate the pointers*/
-  if ((dot1xLogicalPortTreeHeap == L7_NULLPTR) ||(dot1xLogicalPortDataHeap == L7_NULLPTR))
-  {
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
-        "dot1xLogicalPortInfoDBInit: Error allocating data for dot1x DB Tree."
-        " Error allocating memory for the Dot1x database. Possible cause Insufficient memory.");
-    return L7_FAILURE;
-  }
-
-  /* AVL Tree creations - dot1xLogicalPortTreeDb*/
-  avlCreateAvlTree(&(dot1xLogicalPortTreeDb),  dot1xLogicalPortTreeHeap,
-                   dot1xLogicalPortDataHeap, nodeCount,
-                   sizeof(dot1xLogicalPortInfo_t), 0x10,
-                   sizeof(L7_uint32));
-  return L7_SUCCESS;
-}
-
-
-/*********************************************************************
-* @purpose  DeInitialize Logical Port Info Database
-*
-* @param    none
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-L7_RC_t dot1xLogicalPortInfoDBDeInit(void)
-{
-  /* Destroy the AVL Tree */
-  if(dot1xLogicalPortTreeDb.semId != L7_NULLPTR)
-  {
-    avlDeleteAvlTree(&dot1xLogicalPortTreeDb);
-  }
-
-  /* Give up the memory */
-  if (dot1xLogicalPortTreeHeap != L7_NULLPTR)
-  {
-    osapiFree(L7_DOT1X_COMPONENT_ID, dot1xLogicalPortTreeHeap);
-    dot1xLogicalPortTreeHeap = L7_NULLPTR;
-  }
-    
-  if (dot1xLogicalPortDataHeap != L7_NULLPTR)
-  {
-    osapiFree(L7_DOT1X_COMPONENT_ID, dot1xLogicalPortDataHeap);
-    dot1xLogicalPortDataHeap = L7_NULLPTR;
-  }
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  To Take lock for the Logical Port Info Node
-*
-* @param    None
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments This lock needs to be taken only the API functions not running in 
-*           the dot1x threads context.
-*       
-* @end
-*********************************************************************/
-L7_RC_t dot1xLogicalPortInfoTakeLock(void)
-{
-  return osapiSemaTake(dot1xLogicalPortTreeDb.semId, L7_WAIT_FOREVER);
-}
-
-/*********************************************************************
-* @purpose  To Giveup lock for the Logical Port Info Node
-*
-* @param    None
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments This lock needs to be taken only the API functions not running in 
-*           the dot1x threads context.
-*       
-* @end
-*********************************************************************/
-L7_RC_t dot1xLogicalPortInfoGiveLock(void)
-{
-  return osapiSemaGive(dot1xLogicalPortTreeDb.semId);
-}
-
-
-/*********************************************************************
-* @purpose  To allocate a Logical Port Info Node
-*
-* @param    intIfNum  @b{(input)} The internal interface for which this 
-*                                 logical interface is being created
-*
-* @returns  Logical Internal Interface Number
-*
-* @comments none
-*       
-* @end
-*********************************************************************/
-dot1xLogicalPortInfo_t *dot1xLogicalPortInfoAlloc(L7_uint32 intIfNum)
-{
-  L7_uint32               lIntIfNum;
-  dot1xLogicalPortInfo_t  newNode,*retNode,*tmpNode;
-  L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
-
-  /* iterate through the Logical interfaces to assign a empty slot to the new node.*/
-  for (lIntIfNum = DOT1X_LOGICAL_PORT_START(intIfNum);
-      lIntIfNum < DOT1X_LOGICAL_PORT_END(intIfNum); lIntIfNum++)
-  {
-    tmpNode = dot1xLogicalPortInfoGet(lIntIfNum);
-    if (tmpNode == L7_NULLPTR)
-    {
-      /* found one - use it */
-      memset(&newNode,0,sizeof(dot1xLogicalPortInfo_t));
-      newNode.logicalPortNumber = lIntIfNum;
-      newNode.physPort = intIfNum;
-
-      /* add the node to the tree */
-      osapiSemaTake(dot1xLogicalPortTreeDb.semId, L7_WAIT_FOREVER);
-      retNode  = avlInsertEntry(&dot1xLogicalPortTreeDb,&newNode);
-      osapiSemaGive(dot1xLogicalPortTreeDb.semId);
-      if (retNode == &newNode)
-      {
-        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1X_COMPONENT_ID,
-                "%s:%d Error Adding the node to the Dot1x Tree for phyintf %s \n",
-                __FUNCTION__,__FILE__,ifName);
-        return L7_NULLPTR;
-      }
-      return dot1xLogicalPortInfoGet(lIntIfNum);
-    }
-    else if(tmpNode->inUse == L7_FALSE)
-    {
-      return tmpNode;
-    }
-  }
-  L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
-      "%s:%d Error allocating node for phyintf %s as it reached maximum limit per port."
-      " Could not allocate memory for client as maximum number of clients  allowed per port"
-      " has been reached.", __FUNCTION__,__FILE__,ifName);
-  return L7_NULLPTR;
-}
-
-/*********************************************************************
-* @purpose  To Deallocate a Logical Port Info Node
-*
-* @param    intIfNum  @b{(input)} The internal interface for which this 
-*                                 logical interface is being destroyed
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments none
-*       
-* @end
-*********************************************************************/
-L7_RC_t dot1xLogicalPortInfoDeAlloc(dot1xLogicalPortInfo_t *node)
-{
-  if(node != L7_NULLPTR)
-  {
-    node->inUse = L7_FALSE;
-    if(node->logicalPortNumber != DOT1X_LOGICAL_PORT_START(node->physPort))
-    {
-      osapiSemaTake(dot1xLogicalPortTreeDb.semId, L7_WAIT_FOREVER);
-      avlDeleteEntry(&dot1xLogicalPortTreeDb,node);
-      osapiSemaGive(dot1xLogicalPortTreeDb.semId);
-      return L7_SUCCESS;
-    }
-  }
-  return L7_FAILURE;
-}
-
-/*********************************************************************
-* @purpose  To Get a Logical Port Info Node
-*
-* @param    lIntIfNum  @b{(input)} The logical internal interface number
-*
-* @returns  Logical Internal Interface node
-*
-* @comments none
-*       
-* @end
-*********************************************************************/
-dot1xLogicalPortInfo_t *dot1xLogicalPortInfoGet(L7_uint32 lIntIfNum)
-{
-  L7_uint32 key = lIntIfNum;
-  dot1xLogicalPortInfo_t  *entry = L7_NULLPTR;
-  entry = (dot1xLogicalPortInfo_t *)avlSearchLVL7(&dot1xLogicalPortTreeDb,&key,AVL_EXACT);
-  return entry;
-}
-
-/*********************************************************************
-* @purpose  To Get Next Logical Port Info Node
-*
-* @param    lIntIfNum  @b{(input)} The logical internal interface number
-*
-* @returns  Logical Internal Interface node
-*
-* @comments none
-*       
-* @end
-*********************************************************************/
-dot1xLogicalPortInfo_t *dot1xLogicalPortInfoGetNext(L7_uint32 lIntIfNum)
-{
-  L7_uint32 key = lIntIfNum;
-  dot1xLogicalPortInfo_t  *entry = L7_NULLPTR;
-  entry = (dot1xLogicalPortInfo_t *)avlSearchLVL7(&dot1xLogicalPortTreeDb,&key,AVL_NEXT);
-  return entry;
-}
-
-
-
-/*********************************************************************
-* @purpose  To get physical port's logical interfaces 
-*
-* @param    intIfNum  @b{(input)} The internal interface 
-* @param    lIntIfNum  @b{(input/output)} The logical internal interface number
-*
-* @returns  Logical Internal Interface node
-*
-* @comments For the first iteration start with zero.
-*       
-* @end
-*********************************************************************/
-dot1xLogicalPortInfo_t *dot1xPhysicalPortInfoNodeGet(L7_uint32 intIfNum)
-{
-  L7_uint32 lIntIfNum;
-  lIntIfNum = DOT1X_LOGICAL_PORT_START(intIfNum);
-  return dot1xLogicalPortInfoGet(lIntIfNum);
-}
-
-/*********************************************************************
-* @purpose  To get First logical interfaces for a physical interface
-*
-* @param    intIfNum  @b{(input)} The internal interface 
-* @param    lIntIfNum  @b{(input/output)} The logical internal interface number
-*
-* @returns  Logical Internal Interface node
-*
-* @comments For the first iteration start with zero.
-*       
-* @end
-*********************************************************************/
-dot1xLogicalPortInfo_t *dot1xLogicalPortInfoFirstGet(L7_uint32 intIfNum,
-                                                    L7_uint32 *lIntIfNum)
-{
-  dot1xLogicalPortInfo_t *node;
-  L7_uint32 maxintf = DOT1X_LOGICAL_PORT_END(intIfNum);
-
-  *lIntIfNum = DOT1X_LOGICAL_PORT_START(intIfNum);
-  while((node=dot1xLogicalPortInfoGet(*lIntIfNum))==L7_NULLPTR &&
-        *lIntIfNum < maxintf)
-  {
-    *lIntIfNum = *lIntIfNum + 1;
-  }
-  return node;
-}
-
-/*********************************************************************
-* @purpose  To iterate all the logical interfaces of a physical interface
-*
-* @param    intIfNum  @b{(input)} The internal interface 
-* @param    lIntIfNum  @b{(input/output)} The logical internal interface number
-*
-* @returns  Logical Internal Interface node
-*
-* @comments For the first iteration start with zero.
-*       
-* @end
-*********************************************************************/
-dot1xLogicalPortInfo_t *dot1xLogicalPortInfoGetNextNode(L7_uint32 intIfNum,
-                                                        L7_uint32 *lIntIfNum)
-{
-  dot1xLogicalPortInfo_t *node;
-  if(*lIntIfNum == DOT1X_LOGICAL_PORT_ITERATE)
-  {
-    return dot1xLogicalPortInfoFirstGet(intIfNum,lIntIfNum);
-  }
-  node = dot1xLogicalPortInfoGetNext(*lIntIfNum);
-  if(node)
-  {
-    if(node->logicalPortNumber < DOT1X_LOGICAL_PORT_END(intIfNum))
-    {
-      *lIntIfNum = node->logicalPortNumber;
-      return node;
-    }
-  }
-  return L7_NULLPTR;
-}
-
-
-/*********************************************************************
-* @purpose  Debug Info of the Logical Port DB
-*
-* @param    None
-*
-* @returns  None
-*
-* @comments none
-*       
-* @end
-*********************************************************************/
-void dot1xDebugLogicalPortInfo(void)
-{
-  if(dot1xLogicalPortTreeHeap != L7_NULLPTR)
-  {
-    SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
-                  "The Dot1x Logical Port Info has %d Nodes\n",
-    dot1xLogicalPortTreeDb.count);
-  }
-}
-
-/*********************************************************************
- * * @purpose  Dot1x Auth History Log Db initializations
- * *
- * * @param    None
- * *
- * * @returns  L7_SUCCESS - Initialization complete
- * *           L7_FAILURE - Initilaization failed because of
- * *                        insufficient system resources
- * *
- * * @notes
- * *
- * * @end
- * *********************************************************************/
-L7_RC_t dot1xAuthHistoryLogDbInit(void)
-{
-  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb;
-  
-  pHistoryLogDb = &dot1xAuthHistoryLogDb;
-
-  /* Create Heap for AVL tree */
-  pHistoryLogDb->dot1xAuthHistoryTreeHeap = (avlTreeTables_t *)osapiMalloc(L7_DOT1X_COMPONENT_ID,
-                                             L7_DOT1X_AUTHENTICATION_MAX_EVENTS *
-                                             sizeof(avlTreeTables_t));
-  pHistoryLogDb->dot1xAuthHistoryDataHeap  = (dot1xAuthHistoryLogInfo_t *)osapiMalloc(L7_DOT1X_COMPONENT_ID,
-                                              L7_DOT1X_AUTHENTICATION_MAX_EVENTS *
-                                              sizeof(dot1xAuthHistoryLogInfo_t));
-
-  if ((pHistoryLogDb->dot1xAuthHistoryTreeHeap == L7_NULLPTR) ||
-      (pHistoryLogDb->dot1xAuthHistoryDataHeap == L7_NULLPTR)
-     )
-  {
-    L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1X_COMPONENT_ID,
-      "Error allocating data for Dot1x Auth History Log AVL Tree \n");
-    return L7_FAILURE;
-  }
-
-  /* AVL Tree creations */
-  avlCreateAvlTree(&(pHistoryLogDb->dot1xAuthHistoryAvlTree), pHistoryLogDb->dot1xAuthHistoryTreeHeap,
-                   pHistoryLogDb->dot1xAuthHistoryDataHeap, L7_DOT1X_AUTHENTICATION_MAX_EVENTS,
-                   sizeof(dot1xAuthHistoryLogInfo_t), 0x10,
-                   sizeof(dot1xAuthHistoryLogInfoKey_t));
-
-  /* Initialize History Log Entry Index Array */
-  memset(dot1xAuthHistEntryIndexIntfCount, 0x00, L7_MAX_PORT_COUNT);
-
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
- * * @purpose  Dot1x Auth History Log Db De-initializations
- * *
- * * @param    None
- * *
- * * @returns  void
- * *
- * * @notes
- * *
- * * @end
- * *********************************************************************/
-void dot1xAuthHistoryLogDbDeInit(void)
-{
-  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb;
-  
-  pHistoryLogDb = &dot1xAuthHistoryLogDb;
- 
-  /* Destroy the AVL Tree */
-  if (pHistoryLogDb->dot1xAuthHistoryTreeHeap != L7_NULLPTR)
-  {
-    osapiFree(L7_DOT1X_COMPONENT_ID, pHistoryLogDb->dot1xAuthHistoryTreeHeap);
-    pHistoryLogDb->dot1xAuthHistoryTreeHeap = L7_NULLPTR;
-  }
-
-  if (pHistoryLogDb->dot1xAuthHistoryDataHeap != L7_NULLPTR)
-  {
-    osapiFree(L7_DOT1X_COMPONENT_ID, pHistoryLogDb->dot1xAuthHistoryDataHeap);
-    pHistoryLogDb->dot1xAuthHistoryDataHeap = L7_NULLPTR;
-  }
- 
-  if (pHistoryLogDb->dot1xAuthHistoryAvlTree.semId != L7_NULLPTR)
-  {
-    avlDeleteAvlTree(&pHistoryLogDb->dot1xAuthHistoryAvlTree);	    
-  }	  
-
-
-  /* Reset History Log Entry Index Array */
-  memset(dot1xAuthHistEntryIndexIntfCount, 0x00, L7_MAX_PORT_COUNT);
-}
-
-
-/*********************************************************************
- * * @purpose  To Take lock for the History Log Info Node
- * *
- * * @param    None
- * *
- * * @returns  L7_SUCCESS or L7_FAILURE
- * *
- * * @comments This lock needs to be taken only the API functions not running in
- * *           the dot1x threads context.
- * *
- * * @end
- * *********************************************************************/
-L7_RC_t dot1xAuthHistoryLogInfoTakeLock(void)
-{
-  return osapiSemaTake(dot1xAuthHistoryLogDb.dot1xAuthHistoryAvlTree.semId, L7_WAIT_FOREVER);
-}
-
-/*********************************************************************
- * * @purpose  To Giveup lock for the History Log Info Node
- * *
- * * @param    None
- * *
- * * @returns  L7_SUCCESS or L7_FAILURE
- * *
- * * @comments This lock needs to be taken only the API functions not running in
- * *           the dot1x threads context.
- * *
- * * @end
- * *********************************************************************/
-L7_RC_t dot1xAuthHistoryLogInfoGiveLock(void)
-{
-  return osapiSemaGive(dot1xAuthHistoryLogDb.dot1xAuthHistoryAvlTree.semId);
-}
-
-/*********************************************************************
- * * @purpose  To allocate a History Log Info Node
- * *
- * * @param    intIfNum  @b{(input)} The Physical interface for which 
- * *                                 the histroy log node is being created
- * *           entryIndex @b{(input)} The entryIndex for which the history
- * *                                  log node is being created.
- * *
- * * @returns  Reference to History Log Node
- * *
- * * @comments none
- * *
- * * @end
- * *********************************************************************/
-dot1xAuthHistoryLogInfo_t *dot1xAuthHistoryLogInfoAlloc(L7_uint32 intIfNum,
-		                                        L7_uint32 entryIndex)
-{
-  dot1xAuthHistoryLogInfo_t    newNode,
-                               *pData=L7_NULLPTR,
-                               *pEntry=L7_NULLPTR;
-
-  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb=L7_NULLPTR;
-
-  pHistoryLogDb = &dot1xAuthHistoryLogDb;
-
-  pEntry = dot1xAuthHistoryLogInfoGet(intIfNum, entryIndex);
-  if(pEntry == L7_NULLPTR) 
-  {
-    memset(&newNode, 0x00, sizeof(dot1xAuthHistoryLogInfo_t));
-    newNode.dot1xAuthHistoryLogInfoKey.intIfNum = intIfNum;
-    newNode.dot1xAuthHistoryLogInfoKey.entryIndex = entryIndex;
-
-    pData = avlInsertEntry(&pHistoryLogDb->dot1xAuthHistoryAvlTree, &newNode);
-
-    if (pData == L7_NULLPTR)
-    {
-      /*entry was added into the avl tree*/
-      if ((pData = dot1xAuthHistoryLogInfoGet(intIfNum, entryIndex))  == L7_NULLPTR)
-      {
-        L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
-         "Failed to find recently added entry to the Dot1x History Log Tree for PhyIntf:[%d]\n\r",intIfNum);
-        return L7_NULLPTR;
-      }
-      return pData;
-    }
-
-    if (pData == &newNode)
-    {
-      L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
-        "Failed to allocate Dot1x History Log node for intf[%d] and entryIndex[%d] as it reached the maximum limit!\n\r",
-				intIfNum, entryIndex);
-      return L7_NULLPTR;
-    }
-  }
-  else
-  {
-    return pEntry;
-  }
-
-  return L7_NULLPTR;
-}
-
-/*********************************************************************
- * * @purpose  To Deallocate a History Log Info Node
- * *
- * * @param    node @b{(input)} Reference to the History Log Info node
- * *
- * * @returns  L7_SUCCESS or L7_FAILURE
- * *
- * * @comments none
- * *
- * * @end
- * *********************************************************************/
-L7_RC_t dot1xAuthHistoryLogInfoDeAlloc(dot1xAuthHistoryLogInfo_t *node)
-{
-  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb;
-  pHistoryLogDb = &dot1xAuthHistoryLogDb;
-  dot1xAuthHistoryLogInfo_t *pData=L7_NULLPTR;
-  L7_RC_t rc = L7_FAILURE;
-
-  if(node != L7_NULLPTR)
-  {
-    pData = avlDeleteEntry(&pHistoryLogDb->dot1xAuthHistoryAvlTree, node);
-    if (pData == L7_NULL)
-    {
-      /* Entry does not exist */
-      rc = L7_FAILURE;
-    }
-    else if (pData == node)
-    {
-      /* Entry deleted */
-      rc = L7_SUCCESS;
-    }
-  }
-  return rc;
-}
-
-
-/*********************************************************************
- * * @purpose  Create new EntryIndex 
- * *
- * * @param    entryIndex  @b{(output)} EntryIndex
- * *
- * * @returns  L7_SUCCESS - On Success
- * *           L7_FAILURE - if the given pointer is NULL
- * *
- * * @notes
- * *
- * * @end
- * *********************************************************************/
-static L7_RC_t dot1xAuthHistoryLogCreateEntryIndex(L7_uint32 *pEntryIndex)
-{
-  if(pEntryIndex == L7_NULLPTR)
-  {
-    return L7_FAILURE;
-  }
-  dot1xAuthHistCurrentEntryIndex += 1;
-  *pEntryIndex = dot1xAuthHistCurrentEntryIndex;
-  return L7_SUCCESS; 
-}
-
-
-/*********************************************************************
- * * @purpose  Insert dot1x auth event to history log database
- * *
- * * @param    intIfNum        @b{(input)} Interface Number
- * * @param    pHistoryLogInfo @b{(input)} Reference to the History Log Information
- * *
- * * @returns  L7_SUCCESS
- * * @returns  L7_FAILURE
- * *
- * * @notes none
- * *
- * * @end
- * *
- * *********************************************************************/
-L7_RC_t dot1xAuthHistoryLogEntryAdd(L7_uint32 intIfNum, 
-                                    dot1xAuthHistoryLogInfo_t *pHistoryLogInfo)
-{
-  L7_uint32                     entryIndex=0;
-  dot1xAuthHistoryLogInfo_t     historyLogEntry;
-  dot1xAuthHistoryLogInfo_t     *pData = L7_NULLPTR;
-  dot1xAuthHistoryLogTableDb_t  *pHistoryLogDb;
- 
-
-  memset(&historyLogEntry, 0x00, sizeof(dot1xAuthHistoryLogInfo_t));
-
-  /* Validate the given interface */
-  if (dot1xIsValidIntf(intIfNum) != L7_TRUE)
-  {
-    return L7_FAILURE;
-  }
-
-  if (pHistoryLogInfo == L7_NULLPTR)
-  {
-    return L7_FAILURE;
-  }
-
-  pHistoryLogDb = &dot1xAuthHistoryLogDb;
-
-  /* Check for the Max Entries limitation */
-  if(dot1xAuthHistEntryIndexCount >= L7_DOT1X_AUTHENTICATION_MAX_EVENTS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
-        "Dot1x History Log Table Exceeds Maximum Entries %d\n\r", dot1xAuthHistEntryIndexCount);
-    /* Flush All entries */
-    dot1xAuthHistoryLogPurgeAll();
-  }
-  
-  /* Get the new valid entryIndex */
-  dot1xAuthHistoryLogCreateEntryIndex(&entryIndex);
-  
-  /* Check If the entryIndex reachs its max limit (2^maxBits - 1) */ 
-  if(entryIndex >= DOT1X_UNSIGNED_INTERGER_MAX_LIMIT)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
-       "Dot1x History Log Table EntryIndex[%u] reaches Maximum data type limit\n\r", entryIndex);
-    /* Flush All entries */
-    dot1xAuthHistoryLogPurgeAll();
-    dot1xAuthHistCurrentEntryIndex = 0;
-    dot1xAuthHistoryLogCreateEntryIndex(&entryIndex);
-  }
-
-  /* Check for the Max Entries limitation per interface */
-  if(dot1xAuthHistEntryIndexIntfCount[intIfNum] >= L7_DOT1X_AUTHENTICATION_MAX_INTF_EVENTS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
-     "Dot1x History Log Table Exceeds Maximum Interface[%d] Entries %d\n\r", intIfNum, dot1xAuthHistEntryIndexIntfCount[intIfNum]);
-    /* Flush All entries for an interface */
-    dot1xAuthHistoryLogInterfacePurge(intIfNum);
-  }
-   
-  dot1xAuthHistoryLogInfoTakeLock();
-
-  memcpy(&historyLogEntry, pHistoryLogInfo, sizeof(dot1xAuthHistoryLogInfo_t));
-  historyLogEntry.dot1xAuthHistoryLogInfoKey.intIfNum = intIfNum;
-  historyLogEntry.dot1xAuthHistoryLogInfoKey.entryIndex = entryIndex;
-
-  pData = dot1xAuthHistoryLogInfoAlloc(intIfNum, entryIndex);
-  if (pData != L7_NULLPTR)
-  {
-    memcpy(pData, &historyLogEntry, sizeof(dot1xAuthHistoryLogInfo_t));
-
-    dot1xAuthHistEntryIndexCount++;
-    dot1xAuthHistEntryIndexIntfCount[intIfNum]++;
-    dot1xAuthHistoryLogInfoGiveLock();
-    return L7_SUCCESS;
-  }
-  dot1xAuthHistoryLogInfoGiveLock();
-
-  return L7_FAILURE;
-}
-
-/*********************************************************************
- * * @purpose  Remove dot1x auth event entry from history log database
- * *
- * * @param    intIfNum        @b{(input)} Interface Number
- * * @param    entryIndex      @b{(input)} EntryIndex
- * *
- * * @returns  L7_SUCCESS
- * * @returns  L7_FAILURE
- * *
- * * @notes none
- * *
- * * @end
- * *********************************************************************/
-L7_RC_t dot1xAuthHistoryLogEntryDelete(L7_uint32 intIfNum, L7_uint32 entryIndex)
-{
-  dot1xAuthHistoryLogInfo_t    *pData=L7_NULLPTR;
-  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb;
-
-
-  pHistoryLogDb = &dot1xAuthHistoryLogDb;
-
-  /* Validate the given interface */
-  if (dot1xIsValidIntf(intIfNum) != L7_TRUE)
-  {
-    return L7_FAILURE;
-  }
-
-  pData = dot1xAuthHistoryLogEntryFind(intIfNum, entryIndex, L7_MATCH_EXACT);
-  if(pData == L7_NULLPTR)
-  {
-    return L7_FAILURE;
-  }
-  
-  if(dot1xAuthHistoryLogInfoDeAlloc(pData) == L7_SUCCESS)
-  {
-    /* Entry deleted */
-    if(dot1xAuthHistEntryIndexCount == 0)
-    {
-      L7_LOG_ERROR("History Log Entry Delete Invoked with Entry Index Count as NULL!\n\r");
-    }
-    else
-    {
-      dot1xAuthHistEntryIndexCount--;
-    }
-
-    if(dot1xAuthHistEntryIndexIntfCount[intIfNum] == 0)
-    {
-      L7_LOG_ERROR("History Log Entry Delete Invoked with Interface Entry Index Count as NULL!\n\r");
-    }
-    else
-    {
-      dot1xAuthHistEntryIndexIntfCount[intIfNum]--;
-    }
-    return L7_SUCCESS; 
-  }
-
-  return L7_FAILURE;
-}
-
-/*********************************************************************
- * * @purpose  Finds a dot1x Auth History Log entry 
- * * 
- * * @param    intIfNum   @b{(input)} Interface Number
- * * @param    entryIndex @b{(input)} Entry Index
- * * @param    flag       @b{(input)} Flag type for search
- * *                                L7_MATCH_EXACT   - Exact match
- * *                                L7_MATCH_GETNEXT - Next entry greater
- * *                                                   than this one
- * *
- * * @returns  null pointer on failure
- * * @returns  Auth History Log entry pointer on success
- * *
- * * @notes    none
- * *
- * * @end
- * *********************************************************************/
-dot1xAuthHistoryLogInfo_t *dot1xAuthHistoryLogEntryFind(L7_uint32 intIfNum,
-                                                        L7_uint32 entryIndex,
-                                                        L7_uint32 flag)
-{
-  dot1xAuthHistoryLogInfo_t    *pHistoryLogEntry=L7_NULLPTR;
-  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb;
-  dot1xAuthHistoryLogInfoKey_t  key;
-
-  pHistoryLogDb = &dot1xAuthHistoryLogDb;
-  memset((void *)&key, 0x00, sizeof(dot1xAuthHistoryLogInfoKey_t));
-
-  key.intIfNum   = intIfNum;
-  key.entryIndex = entryIndex;
-  
-  pHistoryLogEntry = avlSearchLVL7(&pHistoryLogDb->dot1xAuthHistoryAvlTree, &key, flag);
-  if (pHistoryLogEntry == L7_NULLPTR)
-  {
-    return L7_NULLPTR;
-  }
-  else
-  {
-    return pHistoryLogEntry;
-  }
-}
-
-/******************************************************************************
- * * @purpose  To Get the history log info node
- * *
- * * @param    intIfNum   @b{(input)} Physical Interface Number
- * * @param    entryIndex @b{(input)} EntryIndex
- * *
- * * @returns  reference to history log info node
- * * @returns  L7_NULLPTR  if there are no entries
- * *
- * * @notes  
- * *
- * * @end
- * ******************************************************************************/
-dot1xAuthHistoryLogInfo_t *dot1xAuthHistoryLogInfoGet(L7_uint32 intIfNum, 
-                                                      L7_uint32 entryIndex)
-{
-  dot1xAuthHistoryLogInfo_t *pEntry = L7_NULLPTR;
-
-  pEntry = dot1xAuthHistoryLogEntryFind(intIfNum, entryIndex, AVL_EXACT);
-  return pEntry;  
-}
-
-/******************************************************************************
-* @purpose  Gets the next History Log interface Index
-*
-* @param    intIfNum   @b{(input/output)} Physical Interface Number
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE  If there are no entries
-*
-* @notes  
-*
-* @end
-******************************************************************************/
-L7_RC_t dot1xAuthHistoryLogInterfaceNextGet(L7_uint32 *intIfNum)
-{
-  dot1xAuthHistoryLogInfo_t *pHistoryLogEntry = L7_NULLPTR;
-  L7_uint32 ifIndex=0,entryIndex=0;
-
-  ifIndex = *intIfNum; 
-  
-  do
-  { 
-    pHistoryLogEntry = dot1xAuthHistoryLogEntryFind(ifIndex, entryIndex, L7_MATCH_GETNEXT);
-    if(pHistoryLogEntry != L7_NULLPTR)
-    {
-      ifIndex = pHistoryLogEntry->dot1xAuthHistoryLogInfoKey.intIfNum;
-      entryIndex = pHistoryLogEntry->dot1xAuthHistoryLogInfoKey.entryIndex;
-    }
-  }while((pHistoryLogEntry != L7_NULLPTR) && (ifIndex == *intIfNum));
-
-  if(pHistoryLogEntry == L7_NULLPTR)
-  {
-    return L7_FAILURE;
-  }
-  *intIfNum = ifIndex;
-  return L7_SUCCESS;
-}
-
-
-/******************************************************************************
-* @purpose  Gets the next History Log entry indexs
-*
-* @param    intIfNum   @b{(input/output)} Physical Interface Number
-* @param    entryIndex @b{(input/output)} EntryIndex
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE  If there are no entries
-*
-* @notes  
-*
-* @end
-******************************************************************************/
-L7_RC_t dot1xAuthHistoryLogEntryIndexNextGet(L7_uint32 *intIfNum, 
-                                             L7_uint32 *entryIndex)
-{
-  dot1xAuthHistoryLogInfo_t *pHistoryLogEntry = L7_NULLPTR;
-  
-  pHistoryLogEntry = dot1xAuthHistoryLogEntryFind(*intIfNum, *entryIndex, L7_MATCH_GETNEXT);
-  if (pHistoryLogEntry != L7_NULLPTR)
-  {
-    *intIfNum = pHistoryLogEntry->dot1xAuthHistoryLogInfoKey.intIfNum;
-    *entryIndex = pHistoryLogEntry->dot1xAuthHistoryLogInfoKey.entryIndex;
-    return L7_SUCCESS;
-  }
-  *intIfNum=0;
-  *entryIndex=0;	
-  return L7_FAILURE;
-}
-
-/******************************************************************************
- * * @purpose  To Get the next history log eventId for a interface
- * *
- * * @param    intIfNum   @b{(input)} Physical Interface Number
- * * @param    entryIndex @b{(input/output)} EntryIndex
- * *
- * * @returns  L7_SUCCESSS 
- * * @returns  L7_FAILURE
- * *
- * * @notes  
- * *
- * * @end
- * ******************************************************************************/
-L7_RC_t dot1xAuthHistoryLogInfoNextEntryIndexGet(L7_uint32 intIfNum, 
-                                                 L7_uint32 *entryIndex)
-{
-  L7_uint32 ifIndex=0, index=0;
-
-  ifIndex = intIfNum;
-  index = *entryIndex;
-  while(dot1xAuthHistoryLogEntryIndexNextGet(&ifIndex, &index) == L7_SUCCESS)
-  {
-    if(intIfNum == ifIndex)
-    {
-      *entryIndex = index;
-      return L7_SUCCESS;
-    }
-    return L7_FAILURE;
-  }
-
-  return L7_FAILURE;
-}
-
-/******************************************************************************
- * * @purpose  Retrieve the total number of entries allocated in the History
- * *           Log table
- * *
- * * @param    count @b{(output)} Total number of EntryIndexs 
- * *
- * * @returns  void
- * *
- * * @notes  
- * *
- * * @end
- * ******************************************************************************/
-void dot1xAuthHistoryLogTotalNumEntriesGet(L7_uint32 *count)
-{
-  if(count != L7_NULLPTR)
-  {
-    *count = dot1xAuthHistEntryIndexCount;
-  }
-}
-
-/******************************************************************************
- * * @purpose  Retrieve the total number of entries per interface allocated in 
- * *           the History Log table
- * *
- * * @param    intIfNum   @b{(output)} Physical Interface Number
- * * @param    count @b{(output)} Total number of EntryIndexs 
- * *
- * * @returns  void
- * *
- * * @notes  
- * *
- * * @end
- * ******************************************************************************/
-void dot1xAuthHistoryLogIntfTotalNumEntriesGet(L7_uint32 intIfNum, L7_uint32 *count)
-{
-  if(count != L7_NULLPTR)
-  {
-    *count = dot1xAuthHistEntryIndexIntfCount[intIfNum];
-  }
-}
-
-
-/*********************************************************************
-* @purpose  To Get Number of Monitor Mode clients Authenticated
-*
-* @param    count @b{(output)} Count
-*
-* @returns  L7_SUCCESS/L7_FAILURE
-*
-* @comments none
-*       
-* @end
-*********************************************************************/
-L7_RC_t dot1xAuthMonitorModeClientsNumGet(L7_uint32 *count)
-{
-  L7_uint32 lIntIfNum=0;
-  dot1xLogicalPortInfo_t  *entry = L7_NULLPTR;
-
-  *count = 0;
-
-  do
-  {
-    entry = dot1xLogicalPortInfoGetNext(lIntIfNum);
-    if(entry != L7_NULLPTR)
-    {
-      if((entry->apmState == APM_AUTHENTICATED) &&
-         (entry->isMonitorModeClient == L7_TRUE))
-      {
-        *count += 1;
-      } 
-      lIntIfNum = entry->logicalPortNumber;
-    }
-  }while(entry != L7_NULLPTR); 
-   
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  To Get Number of Dot1x clients Authenticated
-*
-* @param    count @b{(output)} Count
-*
-* @returns  L7_SUCCESS/L7_FAILURE
-*
-* @comments none
-*       
-* @end
-*********************************************************************/
-L7_RC_t dot1xAuthNonMonitorModeClientsNumGet(L7_uint32 *count)
-{
-  L7_uint32 lIntIfNum=0;
-  dot1xLogicalPortInfo_t  *entry = L7_NULLPTR;
-
-  *count = 0;
-
-  do
-  {
-    entry = dot1xLogicalPortInfoGetNext(lIntIfNum);
-    if(entry != L7_NULLPTR)
-    {
-      if((entry->apmState == APM_AUTHENTICATED) && 
-         (entry->isMonitorModeClient == L7_FALSE) &&
-         (dot1xPortInfo[entry->physPort].portControlMode != L7_DOT1X_PORT_FORCE_AUTHORIZED))
-      {
-        *count += 1;
-      } 
-      lIntIfNum = entry->logicalPortNumber;
-    }
-  }while(entry != L7_NULLPTR); 
-   
-  return L7_SUCCESS;
-}
-
-
-/*************************************** STUB FUNCTIONs ***************************/
-L7_RC_t dot1xStubAuthHistoryInfoLog(L7_uint32 intIfNum, L7_uint32 ifCount)
-{
-  L7_uchar8 macAddr[6]={0};
-  L7_uint32 i,ifCt,count;
-  L7_uint32 ifIndex;
-  L7_uint32 macCt = 0;
-
-  if(intIfNum == 0)
-  {
-    count = L7_MAX_PORT_COUNT;
-  }
-  else
-  {
-    count = 1;
-  }
-  for(i=1; i <= count; i++)
-  {
-    for(ifCt=1; ifCt <= ifCount; ifCt++)
-    {
-      macCt += 1;
-      if(macAddr[5] < 0xFF)
-      {
-        macAddr[5] = macCt;
-      } 
-      else if(macAddr[4] < 0xFF)
-      {
-        macAddr[4] = macCt;
-      } 
-      else if(macAddr[3] < 0xFF)
-      {
-        macAddr[3] = macCt;
-      } 
-      else if(macAddr[2] < 0xFF)
-      {
-        macAddr[2] = macCt;
-      } 
-      else if(macAddr[1] < 0xFF)
-      {
-        macAddr[1] = macCt;
-      } 
-      else if(macAddr[0] < 0xFF)
-      {
-        macAddr[0] = macCt;
-      } 
-
-      if(intIfNum == 0)
-        ifIndex = i;
-      else
-        ifIndex = intIfNum;
-
-      dot1xStubAuthHistoryInfoLogDebug(ifIndex, 1, macAddr, 1, 1, 1);    
-    }
-  }
-
-  return L7_SUCCESS;
-} 
-
-L7_RC_t dot1xStubAuthHistoryInfoLogDebug(L7_uint32 iface, L7_uint32 vlanId, 
-                                     L7_uchar8 *macAddr, L7_uint32 accessStatus,
-                                     L7_uint32 authStatus, L7_uint32 reasonCode)
-{
-  dot1xLogicalPortInfo_t logicalPortInfo;
-  
-  memset(&logicalPortInfo, 0, sizeof(logicalPortInfo));
-  logicalPortInfo.physPort = iface;
-  logicalPortInfo.logicalPortStatus = authStatus;
-#if 0  
-  sscanf(macAddrStr, "%u:%u:%u:%u:%u:%u", &macAddr[0],&macAddr[1],&macAddr[2],&macAddr[3],&macAddr[4],&macAddr[5]);
-#endif
-  memcpy(logicalPortInfo.suppMacAddr.addr, macAddr, 6);
-   
-  dot1xAuthHistoryInfoLog(L7_NULL, L7_NULL, reasonCode, accessStatus, &logicalPortInfo);
-  return L7_SUCCESS;
-}
-
-
-L7_RC_t dot1xAuthenticationHistoryStats()
-{
-  L7_uint32 ct,ct1;
-
-  sysapiPrintf("Total number of entries in the history table......... %d\n\r",dot1xAuthHistEntryIndexCount);
-  sysapiPrintf("Maximum history Table Size........................... %d\n\r",L7_DOT1X_AUTHENTICATION_MAX_EVENTS);
-  sysapiPrintf("Maximum number of histroy entries per interface...... %d\n\r",L7_DOT1X_AUTHENTICATION_MAX_INTF_EVENTS);
-  dot1xMonitorModeNumClientsGet(&ct);
-  dot1xNonMonitorModeNumClientsGet(&ct1);
-  sysapiPrintf("Number of successful authentications................. %d\n\r",ct+ct1);  
-  sysapiPrintf("Number of clients authenticated using Monitor Mode... %d\n\r",ct);  
-  sysapiPrintf("Number of failing clients authentications............ %d\n\r",ct);
- 
-  return L7_SUCCESS; 
-}
-
-L7_RC_t dot1xAuthHistoryEntryIndexArrStat()
-{
-  L7_uint32 ifIndex=0;
-  L7_BOOL firstTime=0;
-
-  while(dot1xAuthHistoryLogIfIndexNextGet(&ifIndex) == L7_SUCCESS)
-  {
-    if(firstTime == 0)
-    {
-      sysapiPrintf("Interface    EntryIndex\n\r");
-      sysapiPrintf("---------    ----------\n\r");
-      firstTime = 1;
-    }
-    sysapiPrintf("%-13d%d\n\r",ifIndex,dot1xAuthHistEntryIndexIntfCount[ifIndex]);
-  }
-  return L7_SUCCESS;
-}
+/*********************************************************************
+*
+* (C) Copyright Broadcom Corporation 2003-2007
+*
+**********************************************************************
+* @filename  dot1x_db.c
+*
+* @purpose   dot1x data store file
+*
+* @component dot1x
+*
+* @comments  none
+*
+* @create    10/11/2007
+*
+* @author    PKB
+*
+* @end
+*             
+**********************************************************************/
+
+#include "dot1x_include.h"
+#include "avl_api.h"
+
+
+/* Global parameters */
+static avlTree_t                dot1xLogicalPortTreeDb;
+static avlTreeTables_t          *dot1xLogicalPortTreeHeap=L7_NULLPTR;
+static dot1xLogicalPortInfo_t   *dot1xLogicalPortDataHeap=L7_NULLPTR;
+
+static dot1xAuthHistoryLogTableDb_t dot1xAuthHistoryLogDb;
+
+static L7_uint32 dot1xAuthHistEntryIndexIntfCount[L7_MAX_PORT_COUNT] = {0};
+static L7_uint32 dot1xAuthHistEntryIndexCount = 0;
+static L7_uint32 dot1xAuthHistCurrentEntryIndex = 0;
+
+static L7_RC_t dot1xAuthHistoryLogCreateEntryIndex(L7_uint32 *entryIndex);
+
+
+/*********************************************************************
+* @purpose  Initialize Logical Port Info Database
+*
+* @param    nodeCount    @b{(input)} The number of nodes to be created. 
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments none
+*       
+* @end
+*********************************************************************/
+L7_RC_t dot1xLogicalPortInfoDBInit(L7_uint32 nodeCount)
+{
+  /* Allocate the Heap structures */
+  dot1xLogicalPortTreeHeap = (avlTreeTables_t *)osapiMalloc(L7_DOT1X_COMPONENT_ID,
+                                                            nodeCount * sizeof(avlTreeTables_t));
+
+  dot1xLogicalPortDataHeap  = (dot1xLogicalPortInfo_t *)osapiMalloc(L7_DOT1X_COMPONENT_ID,
+                                                                    nodeCount * sizeof(dot1xLogicalPortInfo_t));
+
+  /* validate the pointers*/
+  if ((dot1xLogicalPortTreeHeap == L7_NULLPTR) ||(dot1xLogicalPortDataHeap == L7_NULLPTR))
+  {
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
+        "dot1xLogicalPortInfoDBInit: Error allocating data for dot1x DB Tree."
+        " Error allocating memory for the Dot1x database. Possible cause Insufficient memory.");
+    return L7_FAILURE;
+  }
+
+  /* AVL Tree creations - dot1xLogicalPortTreeDb*/
+  avlCreateAvlTree(&(dot1xLogicalPortTreeDb),  dot1xLogicalPortTreeHeap,
+                   dot1xLogicalPortDataHeap, nodeCount,
+                   sizeof(dot1xLogicalPortInfo_t), 0x10,
+                   sizeof(L7_uint32));
+  return L7_SUCCESS;
+}
+
+
+/*********************************************************************
+* @purpose  DeInitialize Logical Port Info Database
+*
+* @param    none
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+L7_RC_t dot1xLogicalPortInfoDBDeInit(void)
+{
+  /* Destroy the AVL Tree */
+  if(dot1xLogicalPortTreeDb.semId != L7_NULLPTR)
+  {
+    avlDeleteAvlTree(&dot1xLogicalPortTreeDb);
+  }
+
+  /* Give up the memory */
+  if (dot1xLogicalPortTreeHeap != L7_NULLPTR)
+  {
+    osapiFree(L7_DOT1X_COMPONENT_ID, dot1xLogicalPortTreeHeap);
+    dot1xLogicalPortTreeHeap = L7_NULLPTR;
+  }
+    
+  if (dot1xLogicalPortDataHeap != L7_NULLPTR)
+  {
+    osapiFree(L7_DOT1X_COMPONENT_ID, dot1xLogicalPortDataHeap);
+    dot1xLogicalPortDataHeap = L7_NULLPTR;
+  }
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  To Take lock for the Logical Port Info Node
+*
+* @param    None
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments This lock needs to be taken only the API functions not running in 
+*           the dot1x threads context.
+*       
+* @end
+*********************************************************************/
+L7_RC_t dot1xLogicalPortInfoTakeLock(void)
+{
+  return osapiSemaTake(dot1xLogicalPortTreeDb.semId, L7_WAIT_FOREVER);
+}
+
+/*********************************************************************
+* @purpose  To Giveup lock for the Logical Port Info Node
+*
+* @param    None
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments This lock needs to be taken only the API functions not running in 
+*           the dot1x threads context.
+*       
+* @end
+*********************************************************************/
+L7_RC_t dot1xLogicalPortInfoGiveLock(void)
+{
+  return osapiSemaGive(dot1xLogicalPortTreeDb.semId);
+}
+
+
+/*********************************************************************
+* @purpose  To allocate a Logical Port Info Node
+*
+* @param    intIfNum  @b{(input)} The internal interface for which this 
+*                                 logical interface is being created
+*
+* @returns  Logical Internal Interface Number
+*
+* @comments none
+*       
+* @end
+*********************************************************************/
+dot1xLogicalPortInfo_t *dot1xLogicalPortInfoAlloc(L7_uint32 intIfNum)
+{
+  L7_uint32               lIntIfNum;
+  dot1xLogicalPortInfo_t  newNode,*retNode,*tmpNode;
+  L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
+  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
+
+  /* iterate through the Logical interfaces to assign a empty slot to the new node.*/
+  for (lIntIfNum = DOT1X_LOGICAL_PORT_START(intIfNum);
+      lIntIfNum < DOT1X_LOGICAL_PORT_END(intIfNum); lIntIfNum++)
+  {
+    tmpNode = dot1xLogicalPortInfoGet(lIntIfNum);
+    if (tmpNode == L7_NULLPTR)
+    {
+      /* found one - use it */
+      memset(&newNode,0,sizeof(dot1xLogicalPortInfo_t));
+      newNode.logicalPortNumber = lIntIfNum;
+      newNode.physPort = intIfNum;
+
+      /* add the node to the tree */
+      osapiSemaTake(dot1xLogicalPortTreeDb.semId, L7_WAIT_FOREVER);
+      retNode  = avlInsertEntry(&dot1xLogicalPortTreeDb,&newNode);
+      osapiSemaGive(dot1xLogicalPortTreeDb.semId);
+      if (retNode == &newNode)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1X_COMPONENT_ID,
+                "%s:%d Error Adding the node to the Dot1x Tree for phyintf %s \n",
+                __FUNCTION__,__FILE__,ifName);
+        return L7_NULLPTR;
+      }
+      return dot1xLogicalPortInfoGet(lIntIfNum);
+    }
+    else if(tmpNode->inUse == L7_FALSE)
+    {
+      return tmpNode;
+    }
+  }
+  L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
+      "%s:%d Error allocating node for phyintf %s as it reached maximum limit per port."
+      " Could not allocate memory for client as maximum number of clients  allowed per port"
+      " has been reached.", __FUNCTION__,__FILE__,ifName);
+  return L7_NULLPTR;
+}
+
+/*********************************************************************
+* @purpose  To Deallocate a Logical Port Info Node
+*
+* @param    intIfNum  @b{(input)} The internal interface for which this 
+*                                 logical interface is being destroyed
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments none
+*       
+* @end
+*********************************************************************/
+L7_RC_t dot1xLogicalPortInfoDeAlloc(dot1xLogicalPortInfo_t *node)
+{
+  if(node != L7_NULLPTR)
+  {
+    node->inUse = L7_FALSE;
+    if(node->logicalPortNumber != DOT1X_LOGICAL_PORT_START(node->physPort))
+    {
+      osapiSemaTake(dot1xLogicalPortTreeDb.semId, L7_WAIT_FOREVER);
+      avlDeleteEntry(&dot1xLogicalPortTreeDb,node);
+      osapiSemaGive(dot1xLogicalPortTreeDb.semId);
+      return L7_SUCCESS;
+    }
+  }
+  return L7_FAILURE;
+}
+
+/*********************************************************************
+* @purpose  To Get a Logical Port Info Node
+*
+* @param    lIntIfNum  @b{(input)} The logical internal interface number
+*
+* @returns  Logical Internal Interface node
+*
+* @comments none
+*       
+* @end
+*********************************************************************/
+dot1xLogicalPortInfo_t *dot1xLogicalPortInfoGet(L7_uint32 lIntIfNum)
+{
+  L7_uint32 key = lIntIfNum;
+  dot1xLogicalPortInfo_t  *entry = L7_NULLPTR;
+  entry = (dot1xLogicalPortInfo_t *)avlSearchLVL7(&dot1xLogicalPortTreeDb,&key,AVL_EXACT);
+  return entry;
+}
+
+/*********************************************************************
+* @purpose  To Get Next Logical Port Info Node
+*
+* @param    lIntIfNum  @b{(input)} The logical internal interface number
+*
+* @returns  Logical Internal Interface node
+*
+* @comments none
+*       
+* @end
+*********************************************************************/
+dot1xLogicalPortInfo_t *dot1xLogicalPortInfoGetNext(L7_uint32 lIntIfNum)
+{
+  L7_uint32 key = lIntIfNum;
+  dot1xLogicalPortInfo_t  *entry = L7_NULLPTR;
+  entry = (dot1xLogicalPortInfo_t *)avlSearchLVL7(&dot1xLogicalPortTreeDb,&key,AVL_NEXT);
+  return entry;
+}
+
+
+
+/*********************************************************************
+* @purpose  To get physical port's logical interfaces 
+*
+* @param    intIfNum  @b{(input)} The internal interface 
+* @param    lIntIfNum  @b{(input/output)} The logical internal interface number
+*
+* @returns  Logical Internal Interface node
+*
+* @comments For the first iteration start with zero.
+*       
+* @end
+*********************************************************************/
+dot1xLogicalPortInfo_t *dot1xPhysicalPortInfoNodeGet(L7_uint32 intIfNum)
+{
+  L7_uint32 lIntIfNum;
+  lIntIfNum = DOT1X_LOGICAL_PORT_START(intIfNum);
+  return dot1xLogicalPortInfoGet(lIntIfNum);
+}
+
+/*********************************************************************
+* @purpose  To get First logical interfaces for a physical interface
+*
+* @param    intIfNum  @b{(input)} The internal interface 
+* @param    lIntIfNum  @b{(input/output)} The logical internal interface number
+*
+* @returns  Logical Internal Interface node
+*
+* @comments For the first iteration start with zero.
+*       
+* @end
+*********************************************************************/
+dot1xLogicalPortInfo_t *dot1xLogicalPortInfoFirstGet(L7_uint32 intIfNum,
+                                                    L7_uint32 *lIntIfNum)
+{
+  dot1xLogicalPortInfo_t *node;
+  L7_uint32 maxintf = DOT1X_LOGICAL_PORT_END(intIfNum);
+
+  *lIntIfNum = DOT1X_LOGICAL_PORT_START(intIfNum);
+  while((node=dot1xLogicalPortInfoGet(*lIntIfNum))==L7_NULLPTR &&
+        *lIntIfNum < maxintf)
+  {
+    *lIntIfNum = *lIntIfNum + 1;
+  }
+  return node;
+}
+
+/*********************************************************************
+* @purpose  To iterate all the logical interfaces of a physical interface
+*
+* @param    intIfNum  @b{(input)} The internal interface 
+* @param    lIntIfNum  @b{(input/output)} The logical internal interface number
+*
+* @returns  Logical Internal Interface node
+*
+* @comments For the first iteration start with zero.
+*       
+* @end
+*********************************************************************/
+dot1xLogicalPortInfo_t *dot1xLogicalPortInfoGetNextNode(L7_uint32 intIfNum,
+                                                        L7_uint32 *lIntIfNum)
+{
+  dot1xLogicalPortInfo_t *node;
+  if(*lIntIfNum == DOT1X_LOGICAL_PORT_ITERATE)
+  {
+    return dot1xLogicalPortInfoFirstGet(intIfNum,lIntIfNum);
+  }
+  node = dot1xLogicalPortInfoGetNext(*lIntIfNum);
+  if(node)
+  {
+    if(node->logicalPortNumber < DOT1X_LOGICAL_PORT_END(intIfNum))
+    {
+      *lIntIfNum = node->logicalPortNumber;
+      return node;
+    }
+  }
+  return L7_NULLPTR;
+}
+
+
+/*********************************************************************
+* @purpose  Debug Info of the Logical Port DB
+*
+* @param    None
+*
+* @returns  None
+*
+* @comments none
+*       
+* @end
+*********************************************************************/
+void dot1xDebugLogicalPortInfo(void)
+{
+  if(dot1xLogicalPortTreeHeap != L7_NULLPTR)
+  {
+    SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
+                  "The Dot1x Logical Port Info has %d Nodes\n",
+    dot1xLogicalPortTreeDb.count);
+  }
+}
+
+/*********************************************************************
+ * * @purpose  Dot1x Auth History Log Db initializations
+ * *
+ * * @param    None
+ * *
+ * * @returns  L7_SUCCESS - Initialization complete
+ * *           L7_FAILURE - Initilaization failed because of
+ * *                        insufficient system resources
+ * *
+ * * @notes
+ * *
+ * * @end
+ * *********************************************************************/
+L7_RC_t dot1xAuthHistoryLogDbInit(void)
+{
+  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb;
+  
+  pHistoryLogDb = &dot1xAuthHistoryLogDb;
+
+  /* Create Heap for AVL tree */
+  pHistoryLogDb->dot1xAuthHistoryTreeHeap = (avlTreeTables_t *)osapiMalloc(L7_DOT1X_COMPONENT_ID,
+                                             L7_DOT1X_AUTHENTICATION_MAX_EVENTS *
+                                             sizeof(avlTreeTables_t));
+  pHistoryLogDb->dot1xAuthHistoryDataHeap  = (dot1xAuthHistoryLogInfo_t *)osapiMalloc(L7_DOT1X_COMPONENT_ID,
+                                              L7_DOT1X_AUTHENTICATION_MAX_EVENTS *
+                                              sizeof(dot1xAuthHistoryLogInfo_t));
+
+  if ((pHistoryLogDb->dot1xAuthHistoryTreeHeap == L7_NULLPTR) ||
+      (pHistoryLogDb->dot1xAuthHistoryDataHeap == L7_NULLPTR)
+     )
+  {
+    L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1X_COMPONENT_ID,
+      "Error allocating data for Dot1x Auth History Log AVL Tree \n");
+    return L7_FAILURE;
+  }
+
+  /* AVL Tree creations */
+  avlCreateAvlTree(&(pHistoryLogDb->dot1xAuthHistoryAvlTree), pHistoryLogDb->dot1xAuthHistoryTreeHeap,
+                   pHistoryLogDb->dot1xAuthHistoryDataHeap, L7_DOT1X_AUTHENTICATION_MAX_EVENTS,
+                   sizeof(dot1xAuthHistoryLogInfo_t), 0x10,
+                   sizeof(dot1xAuthHistoryLogInfoKey_t));
+
+  /* Initialize History Log Entry Index Array */
+  memset(dot1xAuthHistEntryIndexIntfCount, 0x00, L7_MAX_PORT_COUNT);
+
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+ * * @purpose  Dot1x Auth History Log Db De-initializations
+ * *
+ * * @param    None
+ * *
+ * * @returns  void
+ * *
+ * * @notes
+ * *
+ * * @end
+ * *********************************************************************/
+void dot1xAuthHistoryLogDbDeInit(void)
+{
+  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb;
+  
+  pHistoryLogDb = &dot1xAuthHistoryLogDb;
+ 
+  /* Destroy the AVL Tree */
+  if (pHistoryLogDb->dot1xAuthHistoryTreeHeap != L7_NULLPTR)
+  {
+    osapiFree(L7_DOT1X_COMPONENT_ID, pHistoryLogDb->dot1xAuthHistoryTreeHeap);
+    pHistoryLogDb->dot1xAuthHistoryTreeHeap = L7_NULLPTR;
+  }
+
+  if (pHistoryLogDb->dot1xAuthHistoryDataHeap != L7_NULLPTR)
+  {
+    osapiFree(L7_DOT1X_COMPONENT_ID, pHistoryLogDb->dot1xAuthHistoryDataHeap);
+    pHistoryLogDb->dot1xAuthHistoryDataHeap = L7_NULLPTR;
+  }
+ 
+  if (pHistoryLogDb->dot1xAuthHistoryAvlTree.semId != L7_NULLPTR)
+  {
+    avlDeleteAvlTree(&pHistoryLogDb->dot1xAuthHistoryAvlTree);	    
+  }	  
+
+
+  /* Reset History Log Entry Index Array */
+  memset(dot1xAuthHistEntryIndexIntfCount, 0x00, L7_MAX_PORT_COUNT);
+}
+
+
+/*********************************************************************
+ * * @purpose  To Take lock for the History Log Info Node
+ * *
+ * * @param    None
+ * *
+ * * @returns  L7_SUCCESS or L7_FAILURE
+ * *
+ * * @comments This lock needs to be taken only the API functions not running in
+ * *           the dot1x threads context.
+ * *
+ * * @end
+ * *********************************************************************/
+L7_RC_t dot1xAuthHistoryLogInfoTakeLock(void)
+{
+  return osapiSemaTake(dot1xAuthHistoryLogDb.dot1xAuthHistoryAvlTree.semId, L7_WAIT_FOREVER);
+}
+
+/*********************************************************************
+ * * @purpose  To Giveup lock for the History Log Info Node
+ * *
+ * * @param    None
+ * *
+ * * @returns  L7_SUCCESS or L7_FAILURE
+ * *
+ * * @comments This lock needs to be taken only the API functions not running in
+ * *           the dot1x threads context.
+ * *
+ * * @end
+ * *********************************************************************/
+L7_RC_t dot1xAuthHistoryLogInfoGiveLock(void)
+{
+  return osapiSemaGive(dot1xAuthHistoryLogDb.dot1xAuthHistoryAvlTree.semId);
+}
+
+/*********************************************************************
+ * * @purpose  To allocate a History Log Info Node
+ * *
+ * * @param    intIfNum  @b{(input)} The Physical interface for which 
+ * *                                 the histroy log node is being created
+ * *           entryIndex @b{(input)} The entryIndex for which the history
+ * *                                  log node is being created.
+ * *
+ * * @returns  Reference to History Log Node
+ * *
+ * * @comments none
+ * *
+ * * @end
+ * *********************************************************************/
+dot1xAuthHistoryLogInfo_t *dot1xAuthHistoryLogInfoAlloc(L7_uint32 intIfNum,
+		                                        L7_uint32 entryIndex)
+{
+  dot1xAuthHistoryLogInfo_t    newNode,
+                               *pData=L7_NULLPTR,
+                               *pEntry=L7_NULLPTR;
+
+  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb=L7_NULLPTR;
+
+  pHistoryLogDb = &dot1xAuthHistoryLogDb;
+
+  pEntry = dot1xAuthHistoryLogInfoGet(intIfNum, entryIndex);
+  if(pEntry == L7_NULLPTR) 
+  {
+    memset(&newNode, 0x00, sizeof(dot1xAuthHistoryLogInfo_t));
+    newNode.dot1xAuthHistoryLogInfoKey.intIfNum = intIfNum;
+    newNode.dot1xAuthHistoryLogInfoKey.entryIndex = entryIndex;
+
+    pData = avlInsertEntry(&pHistoryLogDb->dot1xAuthHistoryAvlTree, &newNode);
+
+    if (pData == L7_NULLPTR)
+    {
+      /*entry was added into the avl tree*/
+      if ((pData = dot1xAuthHistoryLogInfoGet(intIfNum, entryIndex))  == L7_NULLPTR)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
+         "Failed to find recently added entry to the Dot1x History Log Tree for PhyIntf:[%d]\n\r",intIfNum);
+        return L7_NULLPTR;
+      }
+      return pData;
+    }
+
+    if (pData == &newNode)
+    {
+      L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
+        "Failed to allocate Dot1x History Log node for intf[%d] and entryIndex[%d] as it reached the maximum limit!\n\r",
+				intIfNum, entryIndex);
+      return L7_NULLPTR;
+    }
+  }
+  else
+  {
+    return pEntry;
+  }
+
+  return L7_NULLPTR;
+}
+
+/*********************************************************************
+ * * @purpose  To Deallocate a History Log Info Node
+ * *
+ * * @param    node @b{(input)} Reference to the History Log Info node
+ * *
+ * * @returns  L7_SUCCESS or L7_FAILURE
+ * *
+ * * @comments none
+ * *
+ * * @end
+ * *********************************************************************/
+L7_RC_t dot1xAuthHistoryLogInfoDeAlloc(dot1xAuthHistoryLogInfo_t *node)
+{
+  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb;
+  pHistoryLogDb = &dot1xAuthHistoryLogDb;
+  dot1xAuthHistoryLogInfo_t *pData=L7_NULLPTR;
+  L7_RC_t rc = L7_FAILURE;
+
+  if(node != L7_NULLPTR)
+  {
+    pData = avlDeleteEntry(&pHistoryLogDb->dot1xAuthHistoryAvlTree, node);
+    if (pData == L7_NULL)
+    {
+      /* Entry does not exist */
+      rc = L7_FAILURE;
+    }
+    else if (pData == node)
+    {
+      /* Entry deleted */
+      rc = L7_SUCCESS;
+    }
+  }
+  return rc;
+}
+
+
+/*********************************************************************
+ * * @purpose  Create new EntryIndex 
+ * *
+ * * @param    entryIndex  @b{(output)} EntryIndex
+ * *
+ * * @returns  L7_SUCCESS - On Success
+ * *           L7_FAILURE - if the given pointer is NULL
+ * *
+ * * @notes
+ * *
+ * * @end
+ * *********************************************************************/
+static L7_RC_t dot1xAuthHistoryLogCreateEntryIndex(L7_uint32 *pEntryIndex)
+{
+  if(pEntryIndex == L7_NULLPTR)
+  {
+    return L7_FAILURE;
+  }
+  dot1xAuthHistCurrentEntryIndex += 1;
+  *pEntryIndex = dot1xAuthHistCurrentEntryIndex;
+  return L7_SUCCESS; 
+}
+
+
+/*********************************************************************
+ * * @purpose  Insert dot1x auth event to history log database
+ * *
+ * * @param    intIfNum        @b{(input)} Interface Number
+ * * @param    pHistoryLogInfo @b{(input)} Reference to the History Log Information
+ * *
+ * * @returns  L7_SUCCESS
+ * * @returns  L7_FAILURE
+ * *
+ * * @notes none
+ * *
+ * * @end
+ * *
+ * *********************************************************************/
+L7_RC_t dot1xAuthHistoryLogEntryAdd(L7_uint32 intIfNum, 
+                                    dot1xAuthHistoryLogInfo_t *pHistoryLogInfo)
+{
+  L7_uint32                     entryIndex=0;
+  dot1xAuthHistoryLogInfo_t     historyLogEntry;
+  dot1xAuthHistoryLogInfo_t     *pData = L7_NULLPTR;
+  dot1xAuthHistoryLogTableDb_t  *pHistoryLogDb;
+ 
+
+  memset(&historyLogEntry, 0x00, sizeof(dot1xAuthHistoryLogInfo_t));
+
+  /* Validate the given interface */
+  if (dot1xIsValidIntf(intIfNum) != L7_TRUE)
+  {
+    return L7_FAILURE;
+  }
+
+  if (pHistoryLogInfo == L7_NULLPTR)
+  {
+    return L7_FAILURE;
+  }
+
+  pHistoryLogDb = &dot1xAuthHistoryLogDb;
+
+  /* Check for the Max Entries limitation */
+  if(dot1xAuthHistEntryIndexCount >= L7_DOT1X_AUTHENTICATION_MAX_EVENTS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
+        "Dot1x History Log Table Exceeds Maximum Entries %d\n\r", dot1xAuthHistEntryIndexCount);
+    /* Flush All entries */
+    dot1xAuthHistoryLogPurgeAll();
+  }
+  
+  /* Get the new valid entryIndex */
+  dot1xAuthHistoryLogCreateEntryIndex(&entryIndex);
+  
+  /* Check If the entryIndex reachs its max limit (2^maxBits - 1) */ 
+  if(entryIndex >= DOT1X_UNSIGNED_INTERGER_MAX_LIMIT)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
+       "Dot1x History Log Table EntryIndex[%u] reaches Maximum data type limit\n\r", entryIndex);
+    /* Flush All entries */
+    dot1xAuthHistoryLogPurgeAll();
+    dot1xAuthHistCurrentEntryIndex = 0;
+    dot1xAuthHistoryLogCreateEntryIndex(&entryIndex);
+  }
+
+  /* Check for the Max Entries limitation per interface */
+  if(dot1xAuthHistEntryIndexIntfCount[intIfNum] >= L7_DOT1X_AUTHENTICATION_MAX_INTF_EVENTS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
+     "Dot1x History Log Table Exceeds Maximum Interface[%d] Entries %d\n\r", intIfNum, dot1xAuthHistEntryIndexIntfCount[intIfNum]);
+    /* Flush All entries for an interface */
+    dot1xAuthHistoryLogInterfacePurge(intIfNum);
+  }
+   
+  dot1xAuthHistoryLogInfoTakeLock();
+
+  memcpy(&historyLogEntry, pHistoryLogInfo, sizeof(dot1xAuthHistoryLogInfo_t));
+  historyLogEntry.dot1xAuthHistoryLogInfoKey.intIfNum = intIfNum;
+  historyLogEntry.dot1xAuthHistoryLogInfoKey.entryIndex = entryIndex;
+
+  pData = dot1xAuthHistoryLogInfoAlloc(intIfNum, entryIndex);
+  if (pData != L7_NULLPTR)
+  {
+    memcpy(pData, &historyLogEntry, sizeof(dot1xAuthHistoryLogInfo_t));
+
+    dot1xAuthHistEntryIndexCount++;
+    dot1xAuthHistEntryIndexIntfCount[intIfNum]++;
+    dot1xAuthHistoryLogInfoGiveLock();
+    return L7_SUCCESS;
+  }
+  dot1xAuthHistoryLogInfoGiveLock();
+
+  return L7_FAILURE;
+}
+
+/*********************************************************************
+ * * @purpose  Remove dot1x auth event entry from history log database
+ * *
+ * * @param    intIfNum        @b{(input)} Interface Number
+ * * @param    entryIndex      @b{(input)} EntryIndex
+ * *
+ * * @returns  L7_SUCCESS
+ * * @returns  L7_FAILURE
+ * *
+ * * @notes none
+ * *
+ * * @end
+ * *********************************************************************/
+L7_RC_t dot1xAuthHistoryLogEntryDelete(L7_uint32 intIfNum, L7_uint32 entryIndex)
+{
+  dot1xAuthHistoryLogInfo_t    *pData=L7_NULLPTR;
+  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb;
+
+
+  pHistoryLogDb = &dot1xAuthHistoryLogDb;
+
+  /* Validate the given interface */
+  if (dot1xIsValidIntf(intIfNum) != L7_TRUE)
+  {
+    return L7_FAILURE;
+  }
+
+  pData = dot1xAuthHistoryLogEntryFind(intIfNum, entryIndex, L7_MATCH_EXACT);
+  if(pData == L7_NULLPTR)
+  {
+    return L7_FAILURE;
+  }
+  
+  if(dot1xAuthHistoryLogInfoDeAlloc(pData) == L7_SUCCESS)
+  {
+    /* Entry deleted */
+    if(dot1xAuthHistEntryIndexCount == 0)
+    {
+      L7_LOG_ERROR("History Log Entry Delete Invoked with Entry Index Count as NULL!\n\r");
+    }
+    else
+    {
+      dot1xAuthHistEntryIndexCount--;
+    }
+
+    if(dot1xAuthHistEntryIndexIntfCount[intIfNum] == 0)
+    {
+      L7_LOG_ERROR("History Log Entry Delete Invoked with Interface Entry Index Count as NULL!\n\r");
+    }
+    else
+    {
+      dot1xAuthHistEntryIndexIntfCount[intIfNum]--;
+    }
+    return L7_SUCCESS; 
+  }
+
+  return L7_FAILURE;
+}
+
+/*********************************************************************
+ * * @purpose  Finds a dot1x Auth History Log entry 
+ * * 
+ * * @param    intIfNum   @b{(input)} Interface Number
+ * * @param    entryIndex @b{(input)} Entry Index
+ * * @param    flag       @b{(input)} Flag type for search
+ * *                                L7_MATCH_EXACT   - Exact match
+ * *                                L7_MATCH_GETNEXT - Next entry greater
+ * *                                                   than this one
+ * *
+ * * @returns  null pointer on failure
+ * * @returns  Auth History Log entry pointer on success
+ * *
+ * * @notes    none
+ * *
+ * * @end
+ * *********************************************************************/
+dot1xAuthHistoryLogInfo_t *dot1xAuthHistoryLogEntryFind(L7_uint32 intIfNum,
+                                                        L7_uint32 entryIndex,
+                                                        L7_uint32 flag)
+{
+  dot1xAuthHistoryLogInfo_t    *pHistoryLogEntry=L7_NULLPTR;
+  dot1xAuthHistoryLogTableDb_t *pHistoryLogDb;
+  dot1xAuthHistoryLogInfoKey_t  key;
+
+  pHistoryLogDb = &dot1xAuthHistoryLogDb;
+  memset((void *)&key, 0x00, sizeof(dot1xAuthHistoryLogInfoKey_t));
+
+  key.intIfNum   = intIfNum;
+  key.entryIndex = entryIndex;
+  
+  pHistoryLogEntry = avlSearchLVL7(&pHistoryLogDb->dot1xAuthHistoryAvlTree, &key, flag);
+  if (pHistoryLogEntry == L7_NULLPTR)
+  {
+    return L7_NULLPTR;
+  }
+  else
+  {
+    return pHistoryLogEntry;
+  }
+}
+
+/******************************************************************************
+ * * @purpose  To Get the history log info node
+ * *
+ * * @param    intIfNum   @b{(input)} Physical Interface Number
+ * * @param    entryIndex @b{(input)} EntryIndex
+ * *
+ * * @returns  reference to history log info node
+ * * @returns  L7_NULLPTR  if there are no entries
+ * *
+ * * @notes  
+ * *
+ * * @end
+ * ******************************************************************************/
+dot1xAuthHistoryLogInfo_t *dot1xAuthHistoryLogInfoGet(L7_uint32 intIfNum, 
+                                                      L7_uint32 entryIndex)
+{
+  dot1xAuthHistoryLogInfo_t *pEntry = L7_NULLPTR;
+
+  pEntry = dot1xAuthHistoryLogEntryFind(intIfNum, entryIndex, AVL_EXACT);
+  return pEntry;  
+}
+
+/******************************************************************************
+* @purpose  Gets the next History Log interface Index
+*
+* @param    intIfNum   @b{(input/output)} Physical Interface Number
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE  If there are no entries
+*
+* @notes  
+*
+* @end
+******************************************************************************/
+L7_RC_t dot1xAuthHistoryLogInterfaceNextGet(L7_uint32 *intIfNum)
+{
+  dot1xAuthHistoryLogInfo_t *pHistoryLogEntry = L7_NULLPTR;
+  L7_uint32 ifIndex=0,entryIndex=0;
+
+  ifIndex = *intIfNum; 
+  
+  do
+  { 
+    pHistoryLogEntry = dot1xAuthHistoryLogEntryFind(ifIndex, entryIndex, L7_MATCH_GETNEXT);
+    if(pHistoryLogEntry != L7_NULLPTR)
+    {
+      ifIndex = pHistoryLogEntry->dot1xAuthHistoryLogInfoKey.intIfNum;
+      entryIndex = pHistoryLogEntry->dot1xAuthHistoryLogInfoKey.entryIndex;
+    }
+  }while((pHistoryLogEntry != L7_NULLPTR) && (ifIndex == *intIfNum));
+
+  if(pHistoryLogEntry == L7_NULLPTR)
+  {
+    return L7_FAILURE;
+  }
+  *intIfNum = ifIndex;
+  return L7_SUCCESS;
+}
+
+
+/******************************************************************************
+* @purpose  Gets the next History Log entry indexs
+*
+* @param    intIfNum   @b{(input/output)} Physical Interface Number
+* @param    entryIndex @b{(input/output)} EntryIndex
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE  If there are no entries
+*
+* @notes  
+*
+* @end
+******************************************************************************/
+L7_RC_t dot1xAuthHistoryLogEntryIndexNextGet(L7_uint32 *intIfNum, 
+                                             L7_uint32 *entryIndex)
+{
+  dot1xAuthHistoryLogInfo_t *pHistoryLogEntry = L7_NULLPTR;
+  
+  pHistoryLogEntry = dot1xAuthHistoryLogEntryFind(*intIfNum, *entryIndex, L7_MATCH_GETNEXT);
+  if (pHistoryLogEntry != L7_NULLPTR)
+  {
+    *intIfNum = pHistoryLogEntry->dot1xAuthHistoryLogInfoKey.intIfNum;
+    *entryIndex = pHistoryLogEntry->dot1xAuthHistoryLogInfoKey.entryIndex;
+    return L7_SUCCESS;
+  }
+  *intIfNum=0;
+  *entryIndex=0;	
+  return L7_FAILURE;
+}
+
+/******************************************************************************
+ * * @purpose  To Get the next history log eventId for a interface
+ * *
+ * * @param    intIfNum   @b{(input)} Physical Interface Number
+ * * @param    entryIndex @b{(input/output)} EntryIndex
+ * *
+ * * @returns  L7_SUCCESSS 
+ * * @returns  L7_FAILURE
+ * *
+ * * @notes  
+ * *
+ * * @end
+ * ******************************************************************************/
+L7_RC_t dot1xAuthHistoryLogInfoNextEntryIndexGet(L7_uint32 intIfNum, 
+                                                 L7_uint32 *entryIndex)
+{
+  L7_uint32 ifIndex=0, index=0;
+
+  ifIndex = intIfNum;
+  index = *entryIndex;
+  while(dot1xAuthHistoryLogEntryIndexNextGet(&ifIndex, &index) == L7_SUCCESS)
+  {
+    if(intIfNum == ifIndex)
+    {
+      *entryIndex = index;
+      return L7_SUCCESS;
+    }
+    return L7_FAILURE;
+  }
+
+  return L7_FAILURE;
+}
+
+/******************************************************************************
+ * * @purpose  Retrieve the total number of entries allocated in the History
+ * *           Log table
+ * *
+ * * @param    count @b{(output)} Total number of EntryIndexs 
+ * *
+ * * @returns  void
+ * *
+ * * @notes  
+ * *
+ * * @end
+ * ******************************************************************************/
+void dot1xAuthHistoryLogTotalNumEntriesGet(L7_uint32 *count)
+{
+  if(count != L7_NULLPTR)
+  {
+    *count = dot1xAuthHistEntryIndexCount;
+  }
+}
+
+/******************************************************************************
+ * * @purpose  Retrieve the total number of entries per interface allocated in 
+ * *           the History Log table
+ * *
+ * * @param    intIfNum   @b{(output)} Physical Interface Number
+ * * @param    count @b{(output)} Total number of EntryIndexs 
+ * *
+ * * @returns  void
+ * *
+ * * @notes  
+ * *
+ * * @end
+ * ******************************************************************************/
+void dot1xAuthHistoryLogIntfTotalNumEntriesGet(L7_uint32 intIfNum, L7_uint32 *count)
+{
+  if(count != L7_NULLPTR)
+  {
+    *count = dot1xAuthHistEntryIndexIntfCount[intIfNum];
+  }
+}
+
+
+/*********************************************************************
+* @purpose  To Get Number of Monitor Mode clients Authenticated
+*
+* @param    count @b{(output)} Count
+*
+* @returns  L7_SUCCESS/L7_FAILURE
+*
+* @comments none
+*       
+* @end
+*********************************************************************/
+L7_RC_t dot1xAuthMonitorModeClientsNumGet(L7_uint32 *count)
+{
+  L7_uint32 lIntIfNum=0;
+  dot1xLogicalPortInfo_t  *entry = L7_NULLPTR;
+
+  *count = 0;
+
+  do
+  {
+    entry = dot1xLogicalPortInfoGetNext(lIntIfNum);
+    if(entry != L7_NULLPTR)
+    {
+      if((entry->apmState == APM_AUTHENTICATED) &&
+         (entry->isMonitorModeClient == L7_TRUE))
+      {
+        *count += 1;
+      } 
+      lIntIfNum = entry->logicalPortNumber;
+    }
+  }while(entry != L7_NULLPTR); 
+   
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  To Get Number of Dot1x clients Authenticated
+*
+* @param    count @b{(output)} Count
+*
+* @returns  L7_SUCCESS/L7_FAILURE
+*
+* @comments none
+*       
+* @end
+*********************************************************************/
+L7_RC_t dot1xAuthNonMonitorModeClientsNumGet(L7_uint32 *count)
+{
+  L7_uint32 lIntIfNum=0;
+  dot1xLogicalPortInfo_t  *entry = L7_NULLPTR;
+
+  *count = 0;
+
+  do
+  {
+    entry = dot1xLogicalPortInfoGetNext(lIntIfNum);
+    if(entry != L7_NULLPTR)
+    {
+      if((entry->apmState == APM_AUTHENTICATED) && 
+         (entry->isMonitorModeClient == L7_FALSE) &&
+         (dot1xPortInfo[entry->physPort].portControlMode != L7_DOT1X_PORT_FORCE_AUTHORIZED))
+      {
+        *count += 1;
+      } 
+      lIntIfNum = entry->logicalPortNumber;
+    }
+  }while(entry != L7_NULLPTR); 
+   
+  return L7_SUCCESS;
+}
+
+
+/*************************************** STUB FUNCTIONs ***************************/
+L7_RC_t dot1xStubAuthHistoryInfoLog(L7_uint32 intIfNum, L7_uint32 ifCount)
+{
+  L7_uchar8 macAddr[6]={0};
+  L7_uint32 i,ifCt,count;
+  L7_uint32 ifIndex;
+  L7_uint32 macCt = 0;
+
+  if(intIfNum == 0)
+  {
+    count = L7_MAX_PORT_COUNT;
+  }
+  else
+  {
+    count = 1;
+  }
+  for(i=1; i <= count; i++)
+  {
+    for(ifCt=1; ifCt <= ifCount; ifCt++)
+    {
+      macCt += 1;
+      if(macAddr[5] < 0xFF)
+      {
+        macAddr[5] = macCt;
+      } 
+      else if(macAddr[4] < 0xFF)
+      {
+        macAddr[4] = macCt;
+      } 
+      else if(macAddr[3] < 0xFF)
+      {
+        macAddr[3] = macCt;
+      } 
+      else if(macAddr[2] < 0xFF)
+      {
+        macAddr[2] = macCt;
+      } 
+      else if(macAddr[1] < 0xFF)
+      {
+        macAddr[1] = macCt;
+      } 
+      else if(macAddr[0] < 0xFF)
+      {
+        macAddr[0] = macCt;
+      } 
+
+      if(intIfNum == 0)
+        ifIndex = i;
+      else
+        ifIndex = intIfNum;
+
+      dot1xStubAuthHistoryInfoLogDebug(ifIndex, 1, macAddr, 1, 1, 1);    
+    }
+  }
+
+  return L7_SUCCESS;
+} 
+
+L7_RC_t dot1xStubAuthHistoryInfoLogDebug(L7_uint32 iface, L7_uint32 vlanId, 
+                                     L7_uchar8 *macAddr, L7_uint32 accessStatus,
+                                     L7_uint32 authStatus, L7_uint32 reasonCode)
+{
+  dot1xLogicalPortInfo_t logicalPortInfo;
+  
+  memset(&logicalPortInfo, 0, sizeof(logicalPortInfo));
+  logicalPortInfo.physPort = iface;
+  logicalPortInfo.logicalPortStatus = authStatus;
+#if 0  
+  sscanf(macAddrStr, "%u:%u:%u:%u:%u:%u", &macAddr[0],&macAddr[1],&macAddr[2],&macAddr[3],&macAddr[4],&macAddr[5]);
+#endif
+  memcpy(logicalPortInfo.suppMacAddr.addr, macAddr, 6);
+   
+  dot1xAuthHistoryInfoLog(L7_NULL, L7_NULL, reasonCode, accessStatus, &logicalPortInfo);
+  return L7_SUCCESS;
+}
+
+
+L7_RC_t dot1xAuthenticationHistoryStats()
+{
+  L7_uint32 ct,ct1;
+
+  sysapiPrintf("Total number of entries in the history table......... %d\n\r",dot1xAuthHistEntryIndexCount);
+  sysapiPrintf("Maximum history Table Size........................... %d\n\r",L7_DOT1X_AUTHENTICATION_MAX_EVENTS);
+  sysapiPrintf("Maximum number of histroy entries per interface...... %d\n\r",L7_DOT1X_AUTHENTICATION_MAX_INTF_EVENTS);
+  dot1xMonitorModeNumClientsGet(&ct);
+  dot1xNonMonitorModeNumClientsGet(&ct1);
+  sysapiPrintf("Number of successful authentications................. %d\n\r",ct+ct1);  
+  sysapiPrintf("Number of clients authenticated using Monitor Mode... %d\n\r",ct);  
+  sysapiPrintf("Number of failing clients authentications............ %d\n\r",ct);
+ 
+  return L7_SUCCESS; 
+}
+
+L7_RC_t dot1xAuthHistoryEntryIndexArrStat()
+{
+  L7_uint32 ifIndex=0;
+  L7_BOOL firstTime=0;
+
+  while(dot1xAuthHistoryLogIfIndexNextGet(&ifIndex) == L7_SUCCESS)
+  {
+    if(firstTime == 0)
+    {
+      sysapiPrintf("Interface    EntryIndex\n\r");
+      sysapiPrintf("---------    ----------\n\r");
+      firstTime = 1;
+    }
+    sysapiPrintf("%-13d%d\n\r",ifIndex,dot1xAuthHistEntryIndexIntfCount[ifIndex]);
+  }
+  return L7_SUCCESS;
+}
Index: src/application/base/dot1ab/core/lldp_rdb.c
===================================================================
--- src/application/base/dot1ab/core/lldp_rdb.c	(revision 7370)
+++ src/application/base/dot1ab/core/lldp_rdb.c	(revision 7371)
@@ -1,670 +1,670 @@
-/*********************************************************************
-*
-* (C) Copyright Broadcom Corporation 2003-2007
-*
-**********************************************************************
-*
-* @filename lldp_rdb.c
-*
-* @purpose To Handle the remote database for lldp
-*
-* @component
-*
-* @comments
-*
-* @create 10/22/2007
-*
-* @author PKB
-* @end
-*
-**********************************************************************/
-
-#include "lldp.h"
-#include "lldp_util.h"
-#include "lldp_debug.h"
-#include "avl_api.h"
-#include "l7sll_api.h"
-#include "buff_api.h"
-
-/* Global parameters */
-static avlTree_t                lldpRemDbTree;
-static avlTreeTables_t          *lldpRemDbTreeHeap=L7_NULLPTR;
-static lldpRemDataEntry_t       *lldpRemDbDataHeap=L7_NULLPTR;
-
-static L7_sll_t                 lldpRemDbIndexList;
-static L7_uint32                lldpRemDBIndexBufferPoolId=0;
-static L7_uint32                lldpRemIndex   = 0;
-
-/* extern declarations */
-extern L7_uint32            lldpMgmtAddrPoolId;
-extern L7_uint32            lldpUnknownTLVPoolId;
-extern L7_uint32            lldpOrgDefInfoPoolId;
-
-
-/* structure for the index */
-typedef struct lldpRemDBIndexNode_s
-{
-  struct L7_sll_member_s *next;
-  L7_uint32    timestamp;
-  L7_uint32    intIntfNum;
-  L7_uint32    remIndex;
-  lldpRemDataEntry_t  *remDataNode;
-}lldpRemDBIndexNode_t;
-
-/*********************************************************************
-*
-* @purpose  To compare the two keys given based on the inputs.
-*
-* @param    data1  @b{(input)}The pointer to the first key.
-* @param    data2  @b{(input)}The pointer to the second key.
-* @param    keyLen @b{(input)}The length of the key to be compared.
-*
-* @returns  Less than 0, if node1 < node 2.
-* @returns  Zero, if node1 == node2
-* @returns  More than 0, if node1 > node2.
-*
-* @notes    Key Length is ignored for this comparison.
-*
-* @end
-*
-*********************************************************************/
-static
-L7_int32 lldpRemDbIndexListCompare(void *data1,
-                         void *data2,
-                         L7_uint32 keyLen)
-{
-  lldpRemDBIndexNode_t *pEntry1, *pEntry2;
-
-  if(data1 == L7_NULLPTR || data2 == L7_NULLPTR)
-    return 1;
-
-  pEntry1 = (lldpRemDBIndexNode_t *)data1;
-  pEntry2 = (lldpRemDBIndexNode_t *)data2;
-
-  if(pEntry1->timestamp == pEntry2->timestamp)
-  {
-    if(pEntry1->intIntfNum == pEntry2->intIntfNum)
-    {
-      if(pEntry1->remIndex == pEntry2->remIndex)
-      {
-        return 0;
-      }
-      else
-      {
-        return (pEntry1->remIndex - pEntry2->remIndex);
-      }
-    }
-    else
-    {
-      return (pEntry1->intIntfNum - pEntry2->intIntfNum);
-    }
-  }
-  else
-  {
-    return (pEntry1->timestamp - pEntry2->timestamp);
-  }
-}
-
-/*********************************************************************
-* @purpose  Compare keys for the AVL tree. Key consists of
-*           struct lldpRemDataKey_s
-*
-* @param    a     Pointer to first key
-* @param    b     Pointer to second key
-* @param    len   Length of the key
-*
-* @returns  0     if keys are equal
-* @returns  1     if a > b
-* @returns  -1    if a < b
-*
-* @notes    none
-*
-* @end
-*********************************************************************/
-int lldpRemDbEntryCompare(const void *a, const void *b, size_t len)
-{
-  lldpRemDataKey_t  key1, key2;
-  L7_uint32         i;
-  L7_BOOL           cid1IsZero = L7_TRUE, cid2IsZero = L7_TRUE;
-
-  if (len != sizeof(lldpRemDataKey_t))
-  {
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
-            "Invalid key length in lldpRemDbEntryCompare\n");
-    L7_assert(1);                     /* need to know about this */
-    return -1;
-  }
-
-  key1 = *((lldpRemDataKey_t *) a);
-  key2 = *((lldpRemDataKey_t *) b);
-
-  if (key1.chassisIdLength != key2.chassisIdLength)
-  {
-      return memcmp(a, b, len);
-  }
-
-  if (memcmp(&key1.chassisId[0], &key2.chassisId[0], LLDP_TLV_CHASSIS_ID_NTWK_ADDR_FAM_SIZE) != 0)
-  {
-      return memcmp(a, b, len);
-  }
-
-  for (i = LLDP_TLV_CHASSIS_ID_NTWK_ADDR_FAM_SIZE; i < key1.chassisIdLength; i++)
-  {
-    if (key1.chassisId[i] != 0)
-    {
-      cid1IsZero = L7_FALSE;
-    }
-
-    if (key2.chassisId[i] != 0)
-    {
-      cid2IsZero = L7_FALSE;
-    }
-  }
-
-  if (cid1IsZero == cid2IsZero)
-  {
-      return memcmp(a, b, len);
-  }
-
-  if (cid1IsZero == L7_TRUE)
-  {
-      memcpy(&key1.chassisId[0], &key2.chassisId[0], key1.chassisIdLength);
-  }
-  else
-  {
-      memcpy(&key2.chassisId[0], &key1.chassisId[0], key2.chassisIdLength);
-  }
-
-  return memcmp(&key1, &key2, len);
-}
-
-/*********************************************************************
-* @purpose  Initialize Remote entity Database
-*
-* @param    nodeCount    @b{(input)} The number of nodes to be created.
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-L7_RC_t lldpRemoteDBInit(L7_uint32 nodeCount)
-{
-  /* Allocate the Heap structures */
-  lldpRemDbTreeHeap = (avlTreeTables_t *)osapiMalloc(L7_LLDP_COMPONENT_ID,
-                                                     nodeCount * sizeof(avlTreeTables_t));
-
-  lldpRemDbDataHeap  = (lldpRemDataEntry_t *)osapiMalloc(L7_LLDP_COMPONENT_ID,
-                                                         nodeCount * sizeof(lldpRemDataEntry_t));
-
-  /* validate the pointers*/
-  if ((lldpRemDbTreeHeap == L7_NULLPTR) ||(lldpRemDbDataHeap == L7_NULLPTR))
-  {
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
-            "%s: Error allocating data for lldp remote DB Tree \n",__FUNCTION__);
-    return L7_FAILURE;
-  }
-
-  /* AVL Tree creations - dot1xLogicalPortTreeDb*/
-  avlCreateAvlTree(&(lldpRemDbTree),  lldpRemDbTreeHeap,
-                   lldpRemDbDataHeap, nodeCount,
-                   sizeof(lldpRemDataEntry_t), 0x10,
-                   sizeof(lldpRemDataKey_t));
-
-  (void)avlSetAvlTreeComparator(&lldpRemDbTree, lldpRemDbEntryCompare);
-
-   /* Buffer pool for the index data */
-  if (bufferPoolInit(nodeCount,sizeof(lldpRemDBIndexNode_t) , "lldp remote index Bufs",
-                     &(lldpRemDBIndexBufferPoolId)) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
-            "%s: Error allocating buffers\n",__FUNCTION__);
-    return L7_FAILURE;
-  }
-
-  /* Create linked list for group membership timers for this snoop entry */
-  if (SLLCreate(L7_LLDP_COMPONENT_ID, L7_SLL_ASCEND_ORDER,
-               (3*sizeof(L7_uint32)), lldpRemDbIndexListCompare, L7_NULL,
-               &(lldpRemDbIndexList)) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
-            "%s: Failed to lldp remote index linked list \n",__FUNCTION__);
-    return L7_FAILURE;
-  }
-
-  return L7_SUCCESS;
-}
-
-
-/*********************************************************************
-* @purpose  DeInitialize Remote entity Database
-*
-* @param    none
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-L7_RC_t lldpRemoteDBDeInit(void)
-{
-  /* Destroy the AVL Tree */
-  if(lldpRemDbTree.semId != L7_NULLPTR)
-  {
-    avlDeleteAvlTree(&lldpRemDbTree);
-  }
-
-  /* Give up the memory */
-  if (lldpRemDbTreeHeap != L7_NULLPTR)
-  {
-    osapiFree(L7_LLDP_COMPONENT_ID, lldpRemDbTreeHeap);
-    lldpRemDbTreeHeap = L7_NULLPTR;
-  }
-
-  if (lldpRemDbDataHeap != L7_NULLPTR)
-  {
-    osapiFree(L7_LLDP_COMPONENT_ID, lldpRemDbDataHeap);
-    lldpRemDbDataHeap = L7_NULLPTR;
-  }
-
-  if(lldpRemDBIndexBufferPoolId != 0)
-  {
-    bufferPoolDelete(lldpRemDBIndexBufferPoolId);
-    lldpRemDBIndexBufferPoolId = 0;
-  }
-
-  SLLDestroy(L7_LLDP_COMPONENT_ID, &lldpRemDbIndexList);
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  Clear Remote entity Database
-*
-* @param    none
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-L7_RC_t lldpRemoteDBClear(void)
-{
-  lldpRemDataKey_t key;
-  lldpRemDataEntry_t *remEntry;
-
-  memset(&key,0,sizeof(lldpRemDataKey_t));
-  while((remEntry=lldpRemDataEntryGetNext(&key))!=L7_NULLPTR)
-  {
-    lldpRemEntryDelete(remEntry);
-  }
-  return L7_SUCCESS;
-}
-/*********************************************************************
-* @purpose  To Get a llpd remote Info Node
-*
-* @param    key  @b{(input)} The key to the remote Info Node
-*
-* @returns  remote Info Node
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-lldpRemDataEntry_t *lldpRemDataEntryGet(lldpRemDataKey_t *key)
-{
-  lldpRemDataEntry_t  *entry = L7_NULLPTR;
-  entry = (lldpRemDataEntry_t *)avlSearchLVL7(&lldpRemDbTree,key,AVL_EXACT);
-  return entry;
-}
-
-/*********************************************************************
-* @purpose  To Get Next llpd remote Info Node
-*
-* @param    key  @b{(input)} The key to the remote Info Node
-*
-* @returns  remote Info Node
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-lldpRemDataEntry_t *lldpRemDataEntryGetNext(lldpRemDataKey_t *key)
-{
-  lldpRemDataEntry_t  *entry = L7_NULLPTR;
-  entry = (lldpRemDataEntry_t *)avlSearchLVL7(&lldpRemDbTree,key,AVL_NEXT);
-  return entry;
-}
-
-/*********************************************************************
-* @purpose  To Get the next neighbor from the remote database
-*
-* @param    intIfNum  @b{(input)} The internal interface
-* @param    prevEntry @b{(input)} The previous remote Info Node
-*
-* @returns  remote Info Node
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-lldpRemDataEntry_t *lldpRemDataNeighborGetNext(L7_uint32 intIfNum, lldpRemDataEntry_t *prevEntry)
-{
-  lldpRemDataKey_t    key;
-  lldpRemDataEntry_t  *entry = L7_NULLPTR;
-
-  if(prevEntry == L7_NULLPTR)
-  {
-    memset(&key,0,sizeof(lldpRemDataKey_t));
-    key.intIntfNum = intIfNum;
-  }
-  else
-  {
-    memcpy(&key,prevEntry,sizeof(lldpRemDataKey_t));
-  }
-  entry = (lldpRemDataEntry_t *)avlSearchLVL7(&lldpRemDbTree,&key,AVL_NEXT);
-  if(entry != L7_NULLPTR && entry->intIntfNum == intIfNum)
-  {
-    return entry;
-  }
-  return L7_NULLPTR;
-}
-
-/*********************************************************************
-* @purpose  To Get the next neighbor from the remote database
-*
-* @param    intIfNum  @b{(input)} The internal interface
-*
-* @returns  L7_TRUE/L7_FALSE
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-L7_BOOL lldpRemDataNeighborIsLast(L7_uint32 intIfNum)
-{
-  if(lldpRemDataNeighborGetNext(intIfNum,L7_NULLPTR)!=L7_NULLPTR)
-  {
-    return L7_FALSE;
-  }
-  else
-  {
-    return L7_TRUE;
-  }
-}
-
-/*********************************************************************
-* @purpose  Process a interface down event to update the remote db
-*
-* @param    intIfNum  @b{(input)} The internal interface
-* @param    flag      @b{(input)} To do remote Device remove check
-*
-* @returns  none
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-L7_RC_t  lldpRemDataInterfaceDelete(L7_uint32 intIfNum,L7_BOOL flag)
-{
-  lldpRemDataEntry_t *currEntry;
-  L7_RC_t   rc = L7_FAILURE;
-  while((currEntry=lldpRemDataNeighborGetNext(intIfNum,L7_NULLPTR))!=L7_NULLPTR)
-  {
-    if(flag == L7_TRUE)
-    {
-      LLDP_TRACE(LLDP_DEBUG_MED, "intf %d down, check for device removal", intIfNum);
-      lldpMedRemDeviceRemoveCheck(currEntry);
-    }
-    lldpRemEntryDelete(currEntry);
-    rc = L7_SUCCESS;
-  }
-  return rc;
-}
-
-/*********************************************************************
-* @purpose  Clear a remote data entry and return any allocated buffers
-*
-* @param    lldpRemDataEntry_t *entry  @b((input)) remote data entry
-*
-* @returns  void
-*
-* @notes    This does not clear the timer
-*
-* @end
-*********************************************************************/
-void lldpRemEntryDelete(lldpRemDataEntry_t *entry)
-{
-  L7_uchar8 *p = L7_NULLPTR;
-  L7_uchar8 *next = L7_NULLPTR;
-  lldpRemDBIndexNode_t  *indexNode;
-
-  if(entry == L7_NULLPTR)
-  {
-    return;
-  }
-
-  /* return any allocated buffers to buffer pools */
-  p = (L7_uchar8 *)entry->mgmtAddrList;
-  while (p != L7_NULLPTR)
-  {
-    next = (L7_uchar8 *)((lldpMgmtAddrEntry_t *)p)->next;
-    bufferPoolFree(lldpMgmtAddrPoolId, p);
-    p = next;
-  }
-
-  p = (L7_uchar8 *)entry->orgDefInfoList;
-  while (p != L7_NULLPTR)
-  {
-    next = (L7_uchar8 *)((lldpOrgDefInfoEntry_t *)p)->next;
-    bufferPoolFree(lldpOrgDefInfoPoolId, p);
-    p = next;
-  }
-
-  p = (L7_uchar8 *)entry->unknownTLVList;
-  while (p != L7_NULLPTR)
-  {
-    next = (L7_uchar8 *)((lldpUnknownTLVEntry_t *)p)->next;
-    bufferPoolFree(lldpUnknownTLVPoolId, p);
-    p = next;
-  }
-
-  if(entry->rxTTL != 0)
-  {
-   /* lldpTimerDelete();*/
-  }
-
-  /* clear the index  */
-  indexNode = entry->remDBIndex;
-  if(indexNode != L7_NULLPTR)
-  {
-    /* remove it from the list */
-    SLLRemove(&lldpRemDbIndexList,(L7_sll_member_t*)indexNode);
-    /* free the buffer */
-    bufferPoolFree(lldpRemDBIndexBufferPoolId,(L7_uchar8*)indexNode);
-    /* free the avl tree node */
-    avlDeleteEntry(&lldpRemDbTree,entry);
-  }
-  return;
-}
-
-/*********************************************************************
-* @purpose  Add a remote data entry and return the new entry
-*
-* @param    lldpRemDataEntry_t *entry  @b((input)) remote data entry
-*
-* @returns  remote data entry
-*
-* @notes
-*
-* @end
-*********************************************************************/
-lldpRemDataEntry_t *lldpRemEntryAdd(lldpRemDataEntry_t *entry)
-{
-  lldpRemDataEntry_t *currEntry;
-  lldpRemDBIndexNode_t  *indexNode;
-  L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-  nimGetIntfName(entry->intIntfNum, L7_SYSNAME, ifName);
-
-  currEntry = avlInsertEntry(&lldpRemDbTree,entry);
-  if (currEntry == entry)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
-            "%s:%d Error Adding the node to the Remote Tree for intf %s \n",
-            __FUNCTION__,__FILE__,ifName);
-    return L7_NULLPTR;
-  }
-  currEntry = lldpRemDataEntryGet((lldpRemDataKey_t*)entry);
-  if (currEntry == L7_NULLPTR)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
-            "%s:%d Error Retrieving the node from the Remote Tree for intf %s \n",
-            __FUNCTION__,__FILE__,ifName);
-    return L7_NULLPTR;
-  }
-  /* allocate the index list */
-  if (bufferPoolAllocate(lldpRemDBIndexBufferPoolId,
-                         (L7_uchar8 **)&indexNode) != L7_SUCCESS)
-  {
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
-            "%s:%d Error allocating the node to the remote index for intf %s \n",
-            __FUNCTION__,__FILE__,ifName);
-    lldpRemEntryDelete(currEntry);
-    avlDeleteEntry(&lldpRemDbTree,currEntry);
-    return L7_NULLPTR;
-  }
-
-  indexNode->timestamp = currEntry->timestamp = osapiUpTimeRaw();
-  indexNode->intIntfNum = currEntry->intIntfNum;
-  if(lldpRemIndex == 0xFFFFFFFF)
-  {
-    lldpRemIndex = 1;
-  }
-  else
-  {
-      lldpRemIndex++;
-  }
-  currEntry->remIndex = indexNode->remIndex = lldpRemIndex;
-
-  if (SLLAdd(&lldpRemDbIndexList, (L7_sll_member_t *)indexNode)!= L7_SUCCESS)
-  {
-    /* Free the previously allocated bufferpool */
-    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
-            "%s: Failed to add the node to the remote node list\n",__FUNCTION__);
-    bufferPoolFree(lldpRemDBIndexBufferPoolId,(L7_uchar8*)indexNode);
-    lldpRemEntryDelete(currEntry);
-    if(lldpRemIndex > 0)
-    {
-      lldpRemIndex--;
-    }
-    avlDeleteEntry(&lldpRemDbTree,currEntry);
-    return L7_NULLPTR;
-  }
-
-  currEntry->remDBIndex = indexNode;
-  indexNode->remDataNode = currEntry;
-  return currEntry;
-}
-
-/*********************************************************************
-* @purpose  To Get a llpd remote Info Node via timeStamp Index
-*
-* @param    L7_uint32 timestamp @b((input))  remote data timestamp
-* @param    L7_uint32 intIfNum   @b((input))   internal interface number
-* @param    L7_uint32 remIndex  @b((input))  remote data index
-*
-* @returns  remote Info Node
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-lldpRemDataEntry_t *lldpRemDataEntryTimestampIndexGet(L7_uint32 timestamp,
-                                                      L7_uint32 intIfNum,
-                                                      L7_uint32 remIndex)
-{
-  lldpRemDBIndexNode_t  searchNode,*pEntry;
-
-  memset(&searchNode,0,sizeof(lldpRemDBIndexNode_t));
-  searchNode.timestamp = timestamp;
-  searchNode.intIntfNum = intIfNum;
-  searchNode.remIndex = remIndex;
-
-  if ((pEntry = (lldpRemDBIndexNode_t *)SLLFind(&lldpRemDbIndexList,
-                                         (void *)&searchNode))== L7_NULLPTR)
-  {
-    return L7_NULLPTR;
-  }
-  return pEntry->remDataNode;
-}
-
-/*********************************************************************
-* @purpose  To Get Next llpd remote Info Node via timeStamp Index
-*
-* @param    L7_uint32 timestamp @b((output))  remote data timestamp
-* @param    L7_uint32 intIfNum   @b((output))   internal interface number
-* @param    L7_uint32 remIndex  @b((output))  remote data index
-*
-* @returns  L7_SUCCESS/L7_FAILURE
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-L7_RC_t lldpRemDataEntryTimestampIndexGetNext(L7_uint32 *timestamp,
-                                              L7_uint32 *intIfNum,
-                                              L7_uint32 *remIndex)
-{
-  lldpRemDBIndexNode_t  searchNode,*pEntry;
-
-  memset(&searchNode,0,sizeof(lldpRemDBIndexNode_t));
-  searchNode.timestamp = *timestamp;
-  searchNode.intIntfNum = *intIfNum;
-  searchNode.remIndex = *remIndex;
-
-  if ((pEntry = (lldpRemDBIndexNode_t *)SLLFindNext(&lldpRemDbIndexList,
-                                         (void *)&searchNode))== L7_NULLPTR)
-  {
-    return L7_FAILURE;
-  }
-  *timestamp = pEntry->timestamp;
-  *intIfNum = pEntry->intIntfNum;
-  *remIndex = pEntry->remIndex;
-  return L7_SUCCESS;
-}
-
-/*************************************************************************************
-* @purpose  To check if a Remote Device exists on this interface with the same SMAC
-*
-* @param    L7_uint32 intIfNum   @b((input))   internal interface number
-* @param    L7_uchar8 * srcMac   @b((intput))  source MAC
-*
-* @returns  lldpRemDataEntry_t If exists else L7_NULLPTR
-*
-* @comments none
-*
-* @end
-*****************************************************************************************/
-lldpRemDataEntry_t *lldpRemDataEntryMacCheck(L7_uint32 intIfNum, L7_uchar8 *srcMac)
-{
-  lldpRemDataEntry_t *remEntry,*prevEntry=L7_NULLPTR;
-
-  /*Check the MAC of the device on this interface.
-    If it exists, return the pointer to the entry, otherwise return NULL.
-   */
-  while((remEntry = lldpRemDataNeighborGetNext(intIfNum,prevEntry)) != L7_NULLPTR)
-  {
-    if(memcmp(remEntry->srcMac,srcMac,L7_MAC_ADDR_LEN) != 0)
-    {
-      prevEntry = remEntry;
-    }
-    else
-    {
-      break;
-    }
-  }
-  return remEntry;
-}
-
+/*********************************************************************
+*
+* (C) Copyright Broadcom Corporation 2003-2007
+*
+**********************************************************************
+*
+* @filename lldp_rdb.c
+*
+* @purpose To Handle the remote database for lldp
+*
+* @component
+*
+* @comments
+*
+* @create 10/22/2007
+*
+* @author PKB
+* @end
+*
+**********************************************************************/
+
+#include "lldp.h"
+#include "lldp_util.h"
+#include "lldp_debug.h"
+#include "avl_api.h"
+#include "l7sll_api.h"
+#include "buff_api.h"
+
+/* Global parameters */
+static avlTree_t                lldpRemDbTree;
+static avlTreeTables_t          *lldpRemDbTreeHeap=L7_NULLPTR;
+static lldpRemDataEntry_t       *lldpRemDbDataHeap=L7_NULLPTR;
+
+static L7_sll_t                 lldpRemDbIndexList;
+static L7_uint32                lldpRemDBIndexBufferPoolId=0;
+static L7_uint32                lldpRemIndex   = 0;
+
+/* extern declarations */
+extern L7_uint32            lldpMgmtAddrPoolId;
+extern L7_uint32            lldpUnknownTLVPoolId;
+extern L7_uint32            lldpOrgDefInfoPoolId;
+
+
+/* structure for the index */
+typedef struct lldpRemDBIndexNode_s
+{
+  struct L7_sll_member_s *next;
+  L7_uint32    timestamp;
+  L7_uint32    intIntfNum;
+  L7_uint32    remIndex;
+  lldpRemDataEntry_t  *remDataNode;
+}lldpRemDBIndexNode_t;
+
+/*********************************************************************
+*
+* @purpose  To compare the two keys given based on the inputs.
+*
+* @param    data1  @b{(input)}The pointer to the first key.
+* @param    data2  @b{(input)}The pointer to the second key.
+* @param    keyLen @b{(input)}The length of the key to be compared.
+*
+* @returns  Less than 0, if node1 < node 2.
+* @returns  Zero, if node1 == node2
+* @returns  More than 0, if node1 > node2.
+*
+* @notes    Key Length is ignored for this comparison.
+*
+* @end
+*
+*********************************************************************/
+static
+L7_int32 lldpRemDbIndexListCompare(void *data1,
+                         void *data2,
+                         L7_uint32 keyLen)
+{
+  lldpRemDBIndexNode_t *pEntry1, *pEntry2;
+
+  if(data1 == L7_NULLPTR || data2 == L7_NULLPTR)
+    return 1;
+
+  pEntry1 = (lldpRemDBIndexNode_t *)data1;
+  pEntry2 = (lldpRemDBIndexNode_t *)data2;
+
+  if(pEntry1->timestamp == pEntry2->timestamp)
+  {
+    if(pEntry1->intIntfNum == pEntry2->intIntfNum)
+    {
+      if(pEntry1->remIndex == pEntry2->remIndex)
+      {
+        return 0;
+      }
+      else
+      {
+        return (pEntry1->remIndex - pEntry2->remIndex);
+      }
+    }
+    else
+    {
+      return (pEntry1->intIntfNum - pEntry2->intIntfNum);
+    }
+  }
+  else
+  {
+    return (pEntry1->timestamp - pEntry2->timestamp);
+  }
+}
+
+/*********************************************************************
+* @purpose  Compare keys for the AVL tree. Key consists of
+*           struct lldpRemDataKey_s
+*
+* @param    a     Pointer to first key
+* @param    b     Pointer to second key
+* @param    len   Length of the key
+*
+* @returns  0     if keys are equal
+* @returns  1     if a > b
+* @returns  -1    if a < b
+*
+* @notes    none
+*
+* @end
+*********************************************************************/
+int lldpRemDbEntryCompare(const void *a, const void *b, size_t len)
+{
+  lldpRemDataKey_t  key1, key2;
+  L7_uint32         i;
+  L7_BOOL           cid1IsZero = L7_TRUE, cid2IsZero = L7_TRUE;
+
+  if (len != sizeof(lldpRemDataKey_t))
+  {
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
+            "Invalid key length in lldpRemDbEntryCompare\n");
+    L7_assert(1);                     /* need to know about this */
+    return -1;
+  }
+
+  key1 = *((lldpRemDataKey_t *) a);
+  key2 = *((lldpRemDataKey_t *) b);
+
+  if (key1.chassisIdLength != key2.chassisIdLength)
+  {
+      return memcmp(a, b, len);
+  }
+
+  if (memcmp(&key1.chassisId[0], &key2.chassisId[0], LLDP_TLV_CHASSIS_ID_NTWK_ADDR_FAM_SIZE) != 0)
+  {
+      return memcmp(a, b, len);
+  }
+
+  for (i = LLDP_TLV_CHASSIS_ID_NTWK_ADDR_FAM_SIZE; i < key1.chassisIdLength; i++)
+  {
+    if (key1.chassisId[i] != 0)
+    {
+      cid1IsZero = L7_FALSE;
+    }
+
+    if (key2.chassisId[i] != 0)
+    {
+      cid2IsZero = L7_FALSE;
+    }
+  }
+
+  if (cid1IsZero == cid2IsZero)
+  {
+      return memcmp(a, b, len);
+  }
+
+  if (cid1IsZero == L7_TRUE)
+  {
+      memcpy(&key1.chassisId[0], &key2.chassisId[0], key1.chassisIdLength);
+  }
+  else
+  {
+      memcpy(&key2.chassisId[0], &key1.chassisId[0], key2.chassisIdLength);
+  }
+
+  return memcmp(&key1, &key2, len);
+}
+
+/*********************************************************************
+* @purpose  Initialize Remote entity Database
+*
+* @param    nodeCount    @b{(input)} The number of nodes to be created.
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+L7_RC_t lldpRemoteDBInit(L7_uint32 nodeCount)
+{
+  /* Allocate the Heap structures */
+  lldpRemDbTreeHeap = (avlTreeTables_t *)osapiMalloc(L7_LLDP_COMPONENT_ID,
+                                                     nodeCount * sizeof(avlTreeTables_t));
+
+  lldpRemDbDataHeap  = (lldpRemDataEntry_t *)osapiMalloc(L7_LLDP_COMPONENT_ID,
+                                                         nodeCount * sizeof(lldpRemDataEntry_t));
+
+  /* validate the pointers*/
+  if ((lldpRemDbTreeHeap == L7_NULLPTR) ||(lldpRemDbDataHeap == L7_NULLPTR))
+  {
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
+            "%s: Error allocating data for lldp remote DB Tree \n",__FUNCTION__);
+    return L7_FAILURE;
+  }
+
+  /* AVL Tree creations - dot1xLogicalPortTreeDb*/
+  avlCreateAvlTree(&(lldpRemDbTree),  lldpRemDbTreeHeap,
+                   lldpRemDbDataHeap, nodeCount,
+                   sizeof(lldpRemDataEntry_t), 0x10,
+                   sizeof(lldpRemDataKey_t));
+
+  (void)avlSetAvlTreeComparator(&lldpRemDbTree, lldpRemDbEntryCompare);
+
+   /* Buffer pool for the index data */
+  if (bufferPoolInit(nodeCount,sizeof(lldpRemDBIndexNode_t) , "lldp remote index Bufs",
+                     &(lldpRemDBIndexBufferPoolId)) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
+            "%s: Error allocating buffers\n",__FUNCTION__);
+    return L7_FAILURE;
+  }
+
+  /* Create linked list for group membership timers for this snoop entry */
+  if (SLLCreate(L7_LLDP_COMPONENT_ID, L7_SLL_ASCEND_ORDER,
+               (3*sizeof(L7_uint32)), lldpRemDbIndexListCompare, L7_NULL,
+               &(lldpRemDbIndexList)) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
+            "%s: Failed to lldp remote index linked list \n",__FUNCTION__);
+    return L7_FAILURE;
+  }
+
+  return L7_SUCCESS;
+}
+
+
+/*********************************************************************
+* @purpose  DeInitialize Remote entity Database
+*
+* @param    none
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+L7_RC_t lldpRemoteDBDeInit(void)
+{
+  /* Destroy the AVL Tree */
+  if(lldpRemDbTree.semId != L7_NULLPTR)
+  {
+    avlDeleteAvlTree(&lldpRemDbTree);
+  }
+
+  /* Give up the memory */
+  if (lldpRemDbTreeHeap != L7_NULLPTR)
+  {
+    osapiFree(L7_LLDP_COMPONENT_ID, lldpRemDbTreeHeap);
+    lldpRemDbTreeHeap = L7_NULLPTR;
+  }
+
+  if (lldpRemDbDataHeap != L7_NULLPTR)
+  {
+    osapiFree(L7_LLDP_COMPONENT_ID, lldpRemDbDataHeap);
+    lldpRemDbDataHeap = L7_NULLPTR;
+  }
+
+  if(lldpRemDBIndexBufferPoolId != 0)
+  {
+    bufferPoolDelete(lldpRemDBIndexBufferPoolId);
+    lldpRemDBIndexBufferPoolId = 0;
+  }
+
+  SLLDestroy(L7_LLDP_COMPONENT_ID, &lldpRemDbIndexList);
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  Clear Remote entity Database
+*
+* @param    none
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+L7_RC_t lldpRemoteDBClear(void)
+{
+  lldpRemDataKey_t key;
+  lldpRemDataEntry_t *remEntry;
+
+  memset(&key,0,sizeof(lldpRemDataKey_t));
+  while((remEntry=lldpRemDataEntryGetNext(&key))!=L7_NULLPTR)
+  {
+    lldpRemEntryDelete(remEntry);
+  }
+  return L7_SUCCESS;
+}
+/*********************************************************************
+* @purpose  To Get a llpd remote Info Node
+*
+* @param    key  @b{(input)} The key to the remote Info Node
+*
+* @returns  remote Info Node
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+lldpRemDataEntry_t *lldpRemDataEntryGet(lldpRemDataKey_t *key)
+{
+  lldpRemDataEntry_t  *entry = L7_NULLPTR;
+  entry = (lldpRemDataEntry_t *)avlSearchLVL7(&lldpRemDbTree,key,AVL_EXACT);
+  return entry;
+}
+
+/*********************************************************************
+* @purpose  To Get Next llpd remote Info Node
+*
+* @param    key  @b{(input)} The key to the remote Info Node
+*
+* @returns  remote Info Node
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+lldpRemDataEntry_t *lldpRemDataEntryGetNext(lldpRemDataKey_t *key)
+{
+  lldpRemDataEntry_t  *entry = L7_NULLPTR;
+  entry = (lldpRemDataEntry_t *)avlSearchLVL7(&lldpRemDbTree,key,AVL_NEXT);
+  return entry;
+}
+
+/*********************************************************************
+* @purpose  To Get the next neighbor from the remote database
+*
+* @param    intIfNum  @b{(input)} The internal interface
+* @param    prevEntry @b{(input)} The previous remote Info Node
+*
+* @returns  remote Info Node
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+lldpRemDataEntry_t *lldpRemDataNeighborGetNext(L7_uint32 intIfNum, lldpRemDataEntry_t *prevEntry)
+{
+  lldpRemDataKey_t    key;
+  lldpRemDataEntry_t  *entry = L7_NULLPTR;
+
+  if(prevEntry == L7_NULLPTR)
+  {
+    memset(&key,0,sizeof(lldpRemDataKey_t));
+    key.intIntfNum = intIfNum;
+  }
+  else
+  {
+    memcpy(&key,prevEntry,sizeof(lldpRemDataKey_t));
+  }
+  entry = (lldpRemDataEntry_t *)avlSearchLVL7(&lldpRemDbTree,&key,AVL_NEXT);
+  if(entry != L7_NULLPTR && entry->intIntfNum == intIfNum)
+  {
+    return entry;
+  }
+  return L7_NULLPTR;
+}
+
+/*********************************************************************
+* @purpose  To Get the next neighbor from the remote database
+*
+* @param    intIfNum  @b{(input)} The internal interface
+*
+* @returns  L7_TRUE/L7_FALSE
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+L7_BOOL lldpRemDataNeighborIsLast(L7_uint32 intIfNum)
+{
+  if(lldpRemDataNeighborGetNext(intIfNum,L7_NULLPTR)!=L7_NULLPTR)
+  {
+    return L7_FALSE;
+  }
+  else
+  {
+    return L7_TRUE;
+  }
+}
+
+/*********************************************************************
+* @purpose  Process a interface down event to update the remote db
+*
+* @param    intIfNum  @b{(input)} The internal interface
+* @param    flag      @b{(input)} To do remote Device remove check
+*
+* @returns  none
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+L7_RC_t  lldpRemDataInterfaceDelete(L7_uint32 intIfNum,L7_BOOL flag)
+{
+  lldpRemDataEntry_t *currEntry;
+  L7_RC_t   rc = L7_FAILURE;
+  while((currEntry=lldpRemDataNeighborGetNext(intIfNum,L7_NULLPTR))!=L7_NULLPTR)
+  {
+    if(flag == L7_TRUE)
+    {
+      LLDP_TRACE(LLDP_DEBUG_MED, "intf %d down, check for device removal", intIfNum);
+      lldpMedRemDeviceRemoveCheck(currEntry);
+    }
+    lldpRemEntryDelete(currEntry);
+    rc = L7_SUCCESS;
+  }
+  return rc;
+}
+
+/*********************************************************************
+* @purpose  Clear a remote data entry and return any allocated buffers
+*
+* @param    lldpRemDataEntry_t *entry  @b((input)) remote data entry
+*
+* @returns  void
+*
+* @notes    This does not clear the timer
+*
+* @end
+*********************************************************************/
+void lldpRemEntryDelete(lldpRemDataEntry_t *entry)
+{
+  L7_uchar8 *p = L7_NULLPTR;
+  L7_uchar8 *next = L7_NULLPTR;
+  lldpRemDBIndexNode_t  *indexNode;
+
+  if(entry == L7_NULLPTR)
+  {
+    return;
+  }
+
+  /* return any allocated buffers to buffer pools */
+  p = (L7_uchar8 *)entry->mgmtAddrList;
+  while (p != L7_NULLPTR)
+  {
+    next = (L7_uchar8 *)((lldpMgmtAddrEntry_t *)p)->next;
+    bufferPoolFree(lldpMgmtAddrPoolId, p);
+    p = next;
+  }
+
+  p = (L7_uchar8 *)entry->orgDefInfoList;
+  while (p != L7_NULLPTR)
+  {
+    next = (L7_uchar8 *)((lldpOrgDefInfoEntry_t *)p)->next;
+    bufferPoolFree(lldpOrgDefInfoPoolId, p);
+    p = next;
+  }
+
+  p = (L7_uchar8 *)entry->unknownTLVList;
+  while (p != L7_NULLPTR)
+  {
+    next = (L7_uchar8 *)((lldpUnknownTLVEntry_t *)p)->next;
+    bufferPoolFree(lldpUnknownTLVPoolId, p);
+    p = next;
+  }
+
+  if(entry->rxTTL != 0)
+  {
+   /* lldpTimerDelete();*/
+  }
+
+  /* clear the index  */
+  indexNode = entry->remDBIndex;
+  if(indexNode != L7_NULLPTR)
+  {
+    /* remove it from the list */
+    SLLRemove(&lldpRemDbIndexList,(L7_sll_member_t*)indexNode);
+    /* free the buffer */
+    bufferPoolFree(lldpRemDBIndexBufferPoolId,(L7_uchar8*)indexNode);
+    /* free the avl tree node */
+    avlDeleteEntry(&lldpRemDbTree,entry);
+  }
+  return;
+}
+
+/*********************************************************************
+* @purpose  Add a remote data entry and return the new entry
+*
+* @param    lldpRemDataEntry_t *entry  @b((input)) remote data entry
+*
+* @returns  remote data entry
+*
+* @notes
+*
+* @end
+*********************************************************************/
+lldpRemDataEntry_t *lldpRemEntryAdd(lldpRemDataEntry_t *entry)
+{
+  lldpRemDataEntry_t *currEntry;
+  lldpRemDBIndexNode_t  *indexNode;
+  L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
+  nimGetIntfName(entry->intIntfNum, L7_SYSNAME, ifName);
+
+  currEntry = avlInsertEntry(&lldpRemDbTree,entry);
+  if (currEntry == entry)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
+            "%s:%d Error Adding the node to the Remote Tree for intf %s \n",
+            __FUNCTION__,__FILE__,ifName);
+    return L7_NULLPTR;
+  }
+  currEntry = lldpRemDataEntryGet((lldpRemDataKey_t*)entry);
+  if (currEntry == L7_NULLPTR)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
+            "%s:%d Error Retrieving the node from the Remote Tree for intf %s \n",
+            __FUNCTION__,__FILE__,ifName);
+    return L7_NULLPTR;
+  }
+  /* allocate the index list */
+  if (bufferPoolAllocate(lldpRemDBIndexBufferPoolId,
+                         (L7_uchar8 **)&indexNode) != L7_SUCCESS)
+  {
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
+            "%s:%d Error allocating the node to the remote index for intf %s \n",
+            __FUNCTION__,__FILE__,ifName);
+    lldpRemEntryDelete(currEntry);
+    avlDeleteEntry(&lldpRemDbTree,currEntry);
+    return L7_NULLPTR;
+  }
+
+  indexNode->timestamp = currEntry->timestamp = osapiUpTimeRaw();
+  indexNode->intIntfNum = currEntry->intIntfNum;
+  if(lldpRemIndex == 0xFFFFFFFF)
+  {
+    lldpRemIndex = 1;
+  }
+  else
+  {
+      lldpRemIndex++;
+  }
+  currEntry->remIndex = indexNode->remIndex = lldpRemIndex;
+
+  if (SLLAdd(&lldpRemDbIndexList, (L7_sll_member_t *)indexNode)!= L7_SUCCESS)
+  {
+    /* Free the previously allocated bufferpool */
+    L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
+            "%s: Failed to add the node to the remote node list\n",__FUNCTION__);
+    bufferPoolFree(lldpRemDBIndexBufferPoolId,(L7_uchar8*)indexNode);
+    lldpRemEntryDelete(currEntry);
+    if(lldpRemIndex > 0)
+    {
+      lldpRemIndex--;
+    }
+    avlDeleteEntry(&lldpRemDbTree,currEntry);
+    return L7_NULLPTR;
+  }
+
+  currEntry->remDBIndex = indexNode;
+  indexNode->remDataNode = currEntry;
+  return currEntry;
+}
+
+/*********************************************************************
+* @purpose  To Get a llpd remote Info Node via timeStamp Index
+*
+* @param    L7_uint32 timestamp @b((input))  remote data timestamp
+* @param    L7_uint32 intIfNum   @b((input))   internal interface number
+* @param    L7_uint32 remIndex  @b((input))  remote data index
+*
+* @returns  remote Info Node
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+lldpRemDataEntry_t *lldpRemDataEntryTimestampIndexGet(L7_uint32 timestamp,
+                                                      L7_uint32 intIfNum,
+                                                      L7_uint32 remIndex)
+{
+  lldpRemDBIndexNode_t  searchNode,*pEntry;
+
+  memset(&searchNode,0,sizeof(lldpRemDBIndexNode_t));
+  searchNode.timestamp = timestamp;
+  searchNode.intIntfNum = intIfNum;
+  searchNode.remIndex = remIndex;
+
+  if ((pEntry = (lldpRemDBIndexNode_t *)SLLFind(&lldpRemDbIndexList,
+                                         (void *)&searchNode))== L7_NULLPTR)
+  {
+    return L7_NULLPTR;
+  }
+  return pEntry->remDataNode;
+}
+
+/*********************************************************************
+* @purpose  To Get Next llpd remote Info Node via timeStamp Index
+*
+* @param    L7_uint32 timestamp @b((output))  remote data timestamp
+* @param    L7_uint32 intIfNum   @b((output))   internal interface number
+* @param    L7_uint32 remIndex  @b((output))  remote data index
+*
+* @returns  L7_SUCCESS/L7_FAILURE
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+L7_RC_t lldpRemDataEntryTimestampIndexGetNext(L7_uint32 *timestamp,
+                                              L7_uint32 *intIfNum,
+                                              L7_uint32 *remIndex)
+{
+  lldpRemDBIndexNode_t  searchNode,*pEntry;
+
+  memset(&searchNode,0,sizeof(lldpRemDBIndexNode_t));
+  searchNode.timestamp = *timestamp;
+  searchNode.intIntfNum = *intIfNum;
+  searchNode.remIndex = *remIndex;
+
+  if ((pEntry = (lldpRemDBIndexNode_t *)SLLFindNext(&lldpRemDbIndexList,
+                                         (void *)&searchNode))== L7_NULLPTR)
+  {
+    return L7_FAILURE;
+  }
+  *timestamp = pEntry->timestamp;
+  *intIfNum = pEntry->intIntfNum;
+  *remIndex = pEntry->remIndex;
+  return L7_SUCCESS;
+}
+
+/*************************************************************************************
+* @purpose  To check if a Remote Device exists on this interface with the same SMAC
+*
+* @param    L7_uint32 intIfNum   @b((input))   internal interface number
+* @param    L7_uchar8 * srcMac   @b((intput))  source MAC
+*
+* @returns  lldpRemDataEntry_t If exists else L7_NULLPTR
+*
+* @comments none
+*
+* @end
+*****************************************************************************************/
+lldpRemDataEntry_t *lldpRemDataEntryMacCheck(L7_uint32 intIfNum, L7_uchar8 *srcMac)
+{
+  lldpRemDataEntry_t *remEntry,*prevEntry=L7_NULLPTR;
+
+  /*Check the MAC of the device on this interface.
+    If it exists, return the pointer to the entry, otherwise return NULL.
+   */
+  while((remEntry = lldpRemDataNeighborGetNext(intIfNum,prevEntry)) != L7_NULLPTR)
+  {
+    if(memcmp(remEntry->srcMac,srcMac,L7_MAC_ADDR_LEN) != 0)
+    {
+      prevEntry = remEntry;
+    }
+    else
+    {
+      break;
+    }
+  }
+  return remEntry;
+}
+
Index: src/application/ptin/base/ptin_msghandler.c
===================================================================
--- src/application/ptin/base/ptin_msghandler.c	(revision 7370)
+++ src/application/ptin/base/ptin_msghandler.c	(revision 7371)
@@ -1,6078 +1,6078 @@
-/**
- * CHMessageHandler.c 
- *  
- * Created on: 
- * Author: 
- *  
- * Modified on 2011/06/14 
- * By: Alexandre Santos (alexandre-r-santos@ptinovacao.pt) 
- * Notes: major code refactoring
- *  
- */
-
-#include "ptin_include.h"
-#include "ptin_msg.h"
-#include "tty_ptin.h"
-#include "sirerrors.h"
-#include "ptin_control.h"
-#include "ptin_mgmd_api.h"
-#include "ptin_debug.h"//Added by MMelo to use ptin_timer routines
-#include "ipc.h"
-#include <ptin_prot_oam_eth.h>
-#include <ptin_intf.h>
-extern L7_RC_t ptin_ptp_fpga_entry(ptin_dtl_search_ptp_t *e, DAPI_CMD_GET_SET_t operation);
-extern L7_RC_t ptin_oam_fpga_entry(ptin_dtl_search_oam_t *e, DAPI_CMD_GET_SET_t operation);
-
-/* Message processing time measuring */
-
-#define CCMSG_ID_MIN  0x9000
-#define CCMSG_ID_MAX  0x91FF
-
-typedef struct
-{
-  uint32 number_of_calls;
-  uint32 total_runtime;
-  uint32 last_runtime;
-  uint32 min_runtime;
-  uint32 max_runtime;
-  uint32 average_runtime;
-} struct_runtime_t;
-
-static struct_runtime_t msg_runtime[CCMSG_ID_MAX-CCMSG_ID_MIN+1];
-
-static void CHMessage_runtime_meter_update(L7_uint msg_id, L7_uint32 time_delta);
-
-#define MSG_N_ELEMS(size)   (inbuffer->infoDim / (size))
-
-#define SETIPC_INFODIM(size) { \
-  outbuffer->infoDim = size;  \
-}
-
-/* Macro to set ACK OK on output message */
-#define SETIPCACKOK(outbuffer) { \
-  outbuffer->flags = IPCLIB_FLAGS_ACK; \
-  outbuffer->infoDim = sizeof(L7_uint32); \
-  *((L7_uint32 *) outbuffer->info) = ENDIAN_SWAP32(0);   \
-}
-#define SETIPCNACK(outbuffer, res) { \
-  outbuffer->flags = IPCLIB_FLAGS_NACK; \
-  outbuffer->infoDim = sizeof(unsigned int); \
-  *(unsigned int*)outbuffer->info = ENDIAN_SWAP32((unsigned int) res); \
-}
-
-
-/* Macro to check infoDim consistency */
-#define CHECK_INFO_SIZE_ATLEAST(msg_st) {             \
-  if (inbuffer->infoDim < sizeof(msg_st)) {  \
-    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting at least %u bytes; Received %u bytes!", sizeof(msg_st), inbuffer->infoDim);\
-    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); \
-    SetIPCNACK(outbuffer, res);               \
-    break;                                    \
-  }                                           \
-}
-
-/* Macro to check infoDim consistency */
-#define CHECK_INFO_SIZE(msg_st) {             \
-  if (inbuffer->infoDim != sizeof(msg_st)) {  \
-    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting %u bytes; Received %u bytes!", sizeof(msg_st), inbuffer->infoDim);\
-    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); \
-    SetIPCNACK(outbuffer, res);               \
-    break;                                    \
-  }                                           \
-}
-
-/* Macro to check infoDim consistency (including modulo match) */
-#define CHECK_INFO_SIZE_MOD(msg_st) {             \
-  if ( ((inbuffer->infoDim % sizeof(msg_st)) != 0)) {  \
-    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting multiple of %u bytes; Received %u bytes", sizeof(msg_st), inbuffer->infoDim);\
-    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); \
-    SetIPCNACK(outbuffer, res);               \
-    break;                                    \
-  }                                           \
-}
-
-/* Macro to check infoDim consistency */
-#define CHECK_INFO_SIZE_ATLEAST_ABS(size_bytes) {             \
-  if (inbuffer->infoDim < size_bytes) {  \
-    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting at least %u bytes; Received %u bytes!", size_bytes, inbuffer->infoDim);\
-    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); \
-    SetIPCNACK(outbuffer, res);               \
-    break;                                    \
-  }                                           \
-}
-
-/* Macro to check infoDim consistency */
-#define CHECK_INFO_SIZE_ABS(size_bytes) {             \
-  if (inbuffer->infoDim != size_bytes) {  \
-    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting %u bytes; Received %u bytes!", size_bytes, inbuffer->infoDim);\
-    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); \
-    SetIPCNACK(outbuffer, res);               \
-    break;                                    \
-  }                                           \
-}
-
-
-static L7_uint16 SIRerror_get(L7_RC_t error_code)
-{
-  switch ((int) error_code)
-  {
-    case L7_FAILURE:
-    case L7_ERROR:
-      return ERROR_CODE_INVALIDPARAM;
-
-    case L7_REQUEST_DENIED:
-      return ERROR_CODE_USED;
-
-    case L7_NOT_IMPLEMENTED_YET:
-      return ERROR_CODE_NOTIMPLEMENTED;
-
-    case L7_NOT_EXIST:
-      return ERROR_CODE_NOSUCHNAME;
-
-    case L7_TABLE_IS_FULL:
-    case L7_NO_RESOURCES:
-      return ERROR_CODE_FULLTABLE;
-
-    case L7_NOT_SUPPORTED:
-      return ERROR_CODE_NOTSUPPORTED;
-
-    case L7_DEPENDENCY_NOT_MET:
-      return ERROR_CODE_FP_EVC_UNKNOWN;
-    case L7_ADDR_INUSE:
-      return ERROR_COUNTER_USED;
-    case L7_NO_VALUE:
-      return ERROR_NO_MORE_VLAN_AVAILABLE;
-  }
-
-  // Default error
-  return ERROR_CODE_INVALIDPARAM;
-}
-
-
-
-#ifdef __802_1x__
-static void seterror(ipc_msg *outbuffer, const L7_ulong32 severity, const L7_ulong32 error) {
-    outbuffer->flags   = IPCLIB_FLAGS_NACK;
-    outbuffer->infoDim = sizeof(int);
-    *(int *)outbuffer->info = ENDIAN_SWAP32(SIR_ERROR(ERROR_FAMILY_HARDWARE,severity,error));
-}
-
-
-
-
-//Function for generic message reading/writing n STRUCT_SIZE structs*************************************************
-//Uses the particular method for reading/writing each struct, "msg_generic_wrd_1struc"*******************************
-static int msg_generic_wrd(int (*msg_generic_wrd_1struct)(ipc_msg *inbuffer, ipc_msg *outbuffer, L7_ulong32 i), ipc_msg *inbuffer, ipc_msg *outbuffer, L7_ulong32 STRUCT_SIZE_IN, L7_ulong32 STRUCT_SIZE_OUT)
-{
-  L7_ushort16 i,n;
-
-  PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: 0x%04X", inbuffer->msgId);
-
-  //CHECK_INFO_SIZE_MOD(msg_ptin_pcs_prbs);
-  if ((inbuffer->infoDim > IPCLIB_MAX_MSGSIZE) || (inbuffer->infoDim % STRUCT_SIZE_IN) !=0)
-  {
-    seterror(outbuffer, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); //seterror(outbuffer, ERROR_SEVERITY_DEBUG, HW_INVALID_MSG_SIZE);
-    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting multiple of %u bytes; Received %u bytes", STRUCT_SIZE_IN, inbuffer->infoDim);
-    return(0);
-  }
-
-  outbuffer->flags = IPCLIB_FLAGS_ACK;
-
-  n = MSG_N_ELEMS(STRUCT_SIZE_IN);
-
-  if (STRUCT_SIZE_IN>=STRUCT_SIZE_OUT)  //0..n-1
-  {
-    for (i=0;    i<n;    i++)
-    {
-     if ((*msg_generic_wrd_1struct)((void*)inbuffer, (void*)outbuffer, i)) {
-       outbuffer->flags = IPCLIB_FLAGS_NACK;
-       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error WRDing data");
-     }
-    }
-  }
-  else
-  {
-    if (n*STRUCT_SIZE_OUT>IPCLIB_MAX_MSGSIZE)
-    {
-     seterror(outbuffer, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE);   //seterror(outbuffer, ERROR_SEVERITY_DEBUG, HW_INVALID_OUTPUT_MSG_SIZE);
-     return(0);
-    }
-    for (i=n;  i;  i--) //i=n-1..0
-    {
-      if ((*msg_generic_wrd_1struct)((void*)inbuffer, (void*)outbuffer, i-1)) {
-          outbuffer->flags = IPCLIB_FLAGS_NACK;
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error WRDing data");
-      }
-    }
-  }
-
-  SETIPC_INFODIM(n * STRUCT_SIZE_OUT);
-  PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message processed: response with %d bytes", outbuffer->infoDim);
-  return(0);
-}//msg_generic_wrd
-#endif //__802_1x__
-
-
-
-
-
-
-
-
-
-
-
-int ipc_msg_bytes_debug_enable(int disable0_enable1_read2) {
-static int enable=0;
-
- switch (disable0_enable1_read2) {
- case 0:
- case 1: enable=disable0_enable1_read2; break;
- }
-
- return enable;
-}
-
-
-
-
-
-
-
-
-
-
-/**
- * Message handler for the PTin Module.
- * 
- * @param inbuffer Input IPC message
- * @param outbuffer Output IPC message
- * 
- * @return int Error code (SIR_ERROR list)
- */
-int CHMessageHandler (ipc_msg *inbuffer, ipc_msg *outbuffer)
-{
-  L7_uint32 msgId, infoDim;
-  int ret = IPC_OK, res = S_OK;
-  L7_RC_t rc = L7_SUCCESS;
-  L7_uint64 time_start, time_end;
-  L7_uint32 time_delta;
-
-  if (inbuffer == NULL)
-  {
-    PT_LOG_WARN(LOG_CTX_MSGHANDLER, "NULL message received!");
-    return SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_EMPTYMSG);
-  }
-
-  /* Get initial time (in microseconds) */
-  time_start = osapiTimeMicrosecondsGet();
-
-  /* Prepare message header */
-  SwapIPCHeader(inbuffer, outbuffer);
-
-  msgId   = inbuffer->msgId;
-  infoDim = inbuffer->infoDim;
-
-  /* Commands allowed to be run, even if switchdrvr is busy */
-  /* If reached here, means PTin module is loaded and ready to process messages */
-  switch (msgId)
-  {
-    /************************************************************************** 
-     * Application Utils Processing
-     **************************************************************************/
-
-    /* If message is a ping, reply with PTin loading state, which can signal crash errors too */
-    case CCMSG_APPLICATION_IS_ALIVE:
-    {
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APPLICATION_IS_ALIVE (0x%04X)", msgId);
-
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "PTin state: %d", ptin_state);
-      *((L7_uint32 *) outbuffer->info) = ENDIAN_SWAP32((L7_uint32) ptin_state);
-      SETIPC_INFODIM(sizeof(L7_uint32));
-
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER,
-                  "Message processed: response with %d bytes", ENDIAN_SWAP32(outbuffer->infoDim));
-      return IPC_OK;
-    }
-
-    /* CCMSG_APP_FW_STATE_SET ************************************************/
-    case CCMSG_APP_FW_STATE_SET:
-    {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APP_FW_STATE_SET (0x%04X)", msgId);
-
-        if (infoDim == 0)
-        {
-          res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE);
-          SetIPCNACK(outbuffer, res);
-          return IPC_OK;
-        }
-        /* Validate state */
-        if (inbuffer->info[0] >= PTIN_STATE_LAST)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Invalid state: %u", inbuffer->info[0]);
-          res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-          SetIPCNACK(outbuffer, res);
-          return IPC_OK;
-        }
-        /* Set new state */
-        ptin_state = inbuffer->info[0];
-        SETIPCACKOK(outbuffer);
-
-        return IPC_OK;  /* CCMSG_APP_FW_STATE_SET */
-    }
-
-    /* CCMSG_APP_CHANGE_STDOUT ************************************************/
-    case CCMSG_APP_CHANGE_STDOUT:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APP_CHANGE_STDOUT (0x%04X)", msgId);
-      PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "Redirecting stdout...");
-
-      /* Validate message data */
-      if (infoDim == 0)
-      {
-        res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE);
-        SetIPCNACK(outbuffer, res);
-        return IPC_OK;
-      }
-
-      /* Apply change */
-      ptin_PitHandler((char *) &inbuffer->info[0]);
-
-      SETIPCACKOK(outbuffer);
-
-      PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "...Stdout redirected to here :-)");
-      return IPC_OK;  /* CCMSG_APP_CHANGE_STDOUT */
-    }
-
-    case CCMSG_APP_LOGGER_OUTPUT:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APP_LOGGER_OUTPUT (0x%04X)", msgId);
-
-      L7_uint8 output;
-      char *filename;
-
-      /* If infodim is null, use stdout */
-      if (infoDim == 0)
-      {
-        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "Redirecting logger output (0) to \"%s\"...", LOG_OUTPUT_FILE_DEFAULT);
-        logger_redirect(LOG_OUTPUT_FILE, LOG_OUTPUT_FILE_DEFAULT);
-        ptin_mgmd_logredirect(MGMD_LOG_FILE, LOG_OUTPUT_FILE_DEFAULT);
-        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "...Logger output (0) redirected to \"%s\" :-)", LOG_OUTPUT_FILE_DEFAULT);
-      }
-      /* Otherwise, use the specified filename */
-      else if (infoDim == 1 || inbuffer->info[1] == '\0')
-      {
-        output = LOG_OUTPUT_FILE + inbuffer->info[0];
-
-        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "Redirecting logger output (%u) to \"%s\"...", output, LOG_OUTPUT_FILE_DEFAULT);
-        logger_redirect(output, LOG_OUTPUT_FILE_DEFAULT);
-        if (output == LOG_OUTPUT_FILE)
-        {
-          ptin_mgmd_logredirect(MGMD_LOG_FILE, LOG_OUTPUT_FILE_DEFAULT); 
-        }
-        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "...Logger output (%u) redirected to \"%s\" :-)", output, LOG_OUTPUT_FILE_DEFAULT);
-      }
-      else
-      {
-        output = LOG_OUTPUT_FILE + inbuffer->info[0];
-        filename = (char *) &inbuffer->info[1];
-
-        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "Redirecting logger output (%u) to \"%s\"...", output, filename);
-        logger_redirect(output, filename);
-        if (output == LOG_OUTPUT_FILE)
-        {
-          ptin_mgmd_logredirect(MGMD_LOG_FILE, filename);
-        }
-        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "...Logger output (%u) redirected to \"%s\" :-)", output, filename);
-      }
-      SETIPCACKOK(outbuffer);
-      return IPC_OK;  /* CCMSG_APP_CHANGE_STDOUT */
-    }
-
-    /* CCMSG_APP_SHELL_CMD_RUN ************************************************/
-    case CCMSG_APP_SHELL_CMD_RUN:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APP_SHELL_CMD_RUN (0x%04X)", msgId);
-
-      if (infoDim == 0)
-      {
-        res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE);
-        SetIPCNACK(outbuffer, res);
-        return IPC_OK;
-      }
-      if (ptin_msg_ShellCommand_run((L7_char8 *) &inbuffer->info[0]) != L7_SUCCESS)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error on ptin_msg_ShellCommand_run()");
-        res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        return IPC_OK;
-      }
-      SETIPCACKOK(outbuffer);
-      return IPC_OK;  /* CCMSG_APP_SHELL_CMD_RUN */
-    }
-
-    /* CCMSG_ETH_PHY_ACTIVITY_GET ************************************************/
-    case CCMSG_ETH_PHY_ACTIVITY_GET:
-    {
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_ACTIVITY_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HWEthPhyActivity_t);
-
-      msg_HWEthPhyActivity_t *pin  = (msg_HWEthPhyActivity_t *) inbuffer->info;
-      msg_HWEthPhyActivity_t *pout = (msg_HWEthPhyActivity_t *) outbuffer->info;
-
-      /* Reference structure */
-      memcpy(pout, pin, sizeof(msg_HWEthPhyActivity_t));
-
-      if (ptin_msg_PhyActivity_get(pout) != L7_SUCCESS)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port activity (slot=%u/%u)", ENDIAN_SWAP8(pin->intf.slot), ENDIAN_SWAP8(pin->intf.port));
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        return IPC_OK;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_HWEthPhyActivity_t));
-      return IPC_OK;  /* CCMSG_ETH_PHY_ACTIVITY_GET */
-    }
-
-    /* CCMSG_BOARD_SHOW *******************************************************/
-    case CCMSG_BOARD_SHOW:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_BOARD_SHOW (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(0);
-
-      msg_FWFastpathInfo *fpInfo;
-      fpInfo = (msg_FWFastpathInfo *) outbuffer->info;
-
-      /* Get values */
-      ptin_msg_FPInfo_get(fpInfo);  /* returns always success */
-
-      /* Copy slot id information if available! */
-      if (infoDim >= 1)
-        outbuffer->info[0] = inbuffer->info[0];
-
-      SETIPC_INFODIM(sizeof(msg_FWFastpathInfo));
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER,
-                  "Message processed: response with %d bytes (present=%d)", outbuffer->infoDim, ENDIAN_SWAP32(fpInfo->BoardPresent));
-
-      return IPC_OK;  /* CCMSG_BOARD_SHOW */
-    }
-
-    /* CCMSG_HW_INTF_INFO_GET ****************************************************/
-    case CCMSG_HW_INTF_INFO_GET:
-    {
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_HW_INTF_INFO_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_ATLEAST(L7_uint32);
-      msg_HwIntfInfo_t *ptr;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwIntfInfo_t));
-      ptr = (msg_HwIntfInfo_t *) outbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_intfInfo_get(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error interface status");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        return IPC_OK;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_HwIntfInfo_t));
-      return IPC_OK;
-    }
-    /* CCMSG_HW_INTF_STATUS */
-    case CCMSG_HW_INTF_STATUS:
-    {
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_HW_INTF_STATUS (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_ATLEAST(msg_HwIntfStatus_t);
-
-      /* Execute command */
-      rc = ptin_msg_intfLinkStatus(inbuffer);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error interface status");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        return IPC_NO_REPLY;
-      }
-
-      SETIPCACKOK(outbuffer);
-      return IPC_NO_REPLY;
-    }
-
-    /* CCMSG_APPLICATION_RESOURCES *********************************************/
-    case CCMSG_APPLICATION_RESOURCES:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APPLICATION_RESOURCES (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_ptin_policy_resources);
-
-      /* Copy inbuffer to outbuffer */
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_ptin_policy_resources));
-
-      msg_ptin_policy_resources *resources;
-      resources = (msg_ptin_policy_resources *) outbuffer->info;
-
-      /* Get values */
-      if ( L7_SUCCESS != (rc=ptin_msg_hw_resources_get(resources)) )
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while consulting hardware resources");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        return IPC_OK;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_ptin_policy_resources));
-      return IPC_OK;  /* CCMSG_APPLICATION_RESOURCES */
-    }
-  }
-
-  /* If switchdrvr is busy, return FP_BUSY code error */
-  if (ptin_state == PTIN_STATE_BUSY)
-  {
-    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_FP_BUSY);
-    SetIPCNACK(outbuffer, res);
-    PT_LOG_WARN(LOG_CTX_MSGHANDLER, "IPC message cannot be processed! PTin state = %d (msgId=0x%x) -> error 0x%08x", ptin_state, msgId, res);
-    return IPC_OK;
-  }
-  /* PTin module is still loading or crashed ? */
-  else if (ptin_state != PTIN_STATE_READY)
-  {
-    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_NOTALLOWED);
-    SetIPCNACK(outbuffer, res);
-    PT_LOG_WARN(LOG_CTX_MSGHANDLER, "IPC message cannot be processed! PTin state = %d (msgId=0x%x) -> error 0x%08x", ptin_state, msgId, res);
-    return IPC_OK;
-  }
-
-  if (ipc_msg_bytes_debug_enable(2))
-  {
-    L7_uint i;
-
-    if (inbuffer == NULL)
-    {
-        PT_LOG_WARN(LOG_CTX_MSGHANDLER, "NULL message received!");
-        return SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_EMPTYMSG);
-    }
-    printf("\n\rmsgId=0x%04x inbuffer->infoDim=%u:", inbuffer->msgId, inbuffer->infoDim);
-    for(i=0; i<inbuffer->infoDim; i++)
-    {
-      if ((i % 32) == 0)
-      {
-        printf("\r\n%04x:", i);
-      }
-      printf(" %02x", inbuffer->info[i]);
-    }
-    printf("\n\r");
-  }
-
-  /* If reached here, means PTin module is loaded and ready to process messages */
-  switch (msgId)
-  {
-    /************************************************************************** 
-     * Control processing
-     **************************************************************************/
-
-    /* Uplink protection command *********************************************/
-    case CHMSG_ETH_UPLINK_COMMAND:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_ETH_UPLINK_COMMAND (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_uplinkProtCmd);
-
-      msg_uplinkProtCmd *ptr = (msg_uplinkProtCmd *) inbuffer->info;
-      L7_int n = MSG_N_ELEMS(sizeof(msg_uplinkProtCmd));
-
-      ret = IPC_NO_REPLY;
-
-      rc = ptin_msg_uplink_protection_cmd(ptr, n);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error processing command");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-      break;
-    }
-
-  #if (PTIN_BOARD_IS_MATRIX)
-    case CCMSG_ETH_LACP_MATRIXES_SYNC2:
-    {
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_MATRIXES_SYNC2 (0x%04X)", msgId);
-
-      rx_dot3ad_matrix_sync2_t(inbuffer->info, infoDim);
-
-      SETIPC_INFODIM(1);
-      break;
-    }
-  #endif
-
-    /* Sync MGMD open ports between different cards/interfaces*/
-    case CCMSG_MGMD_PORT_SYNC:
-    {
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MGMD_PORT_SYNC (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwMgmdPortSync);
-
-      msg_HwMgmdPortSync *ptr;
-      ptr = (msg_HwMgmdPortSync *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwMgmdPortSync));
-
-      /* Execute command */
-      rc = ptin_msg_mgmd_sync_ports(ptr);
-      SETIPC_INFODIM(1);
-      break;
-    }
-
-    /************************************************************************** 
-     * Misc Processing
-     **************************************************************************/
-
-    /* CCMSG_ALARMS_RESET *****************************************************/
-    case CCMSG_ALARMS_RESET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ALARMS_RESET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwGenReq_t);
-
-      /* Execute command */
-      ptin_msg_alarms_reset();
-
-#ifdef __Y1731_802_1ag_OAM_ETH__
-      {
-       unsigned short i;
-       u16 mep_id, rmep_id, prt;
-       u64 vid;
-       T_MEG_ID meg;
-
-       for (i=0; i<N_MEPs; i++) {
-        switch (MEP_is_CC_LOC_or_RDI(i, &oam, &mep_id, &rmep_id, &meg, &prt, &vid)) {
-        //case 0:
-        //   ethsrv_oam_register_RDI_END((L7_uint8 *)&meg, mep_id, rmep_id, prt, vid); //ethsrv_oam_register(ME_RDI_END, rmep_id, &meg, mep_id, prt, vid);
-        //   ethsrv_oam_connection_restored((L7_uint8 *)&meg, mep_id, rmep_id, prt, vid); //ethsrv_oam_register(ME_CONNECTION_UP, rmep_id, &meg, mep_id, prt, vid);
-        //   break;
-        case 1:  ethsrv_oam_register_connection_loss((L7_uint8 *)&meg, mep_id, rmep_id, prt, vid); break; //ethsrv_oam_register(ME_CONNECTION_LOSS, rmep_id, &meg, mep_id, prt, vid); break;
-        case 2:  ethsrv_oam_register_receiving_RDI((L7_uint8 *)&meg, mep_id, rmep_id, prt, vid); break; //ethsrv_oam_register(ME_RDI, rmep_id, &meg, mep_id, prt, vid); break;
-        }//switch
-       }//for
-      }
-#endif
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ALARMS_RESET */
-    }
-
-    /* CCMSG_DEFAULTS_RESET ***************************************************/
-    case CCMSG_DEFAULTS_RESET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_DEFAULTS_RESET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwGenReq_t);
-      #if 0
-      msg_HwGenReq_t *config;
-      config = (msg_HwGenReq_t *) inbuffer->info;
-      ptin_msg_defaults_reset(config->param);
-      SETIPCACKOK(outbuffer);
-      #else
-      /* Execute command */      
-      ptin_msg_task_process(msgId, (void*)(inbuffer->info), infoDim, 3000);
-      SETIPCACKOK(outbuffer);
-      #endif
-
-      break;  /* CCMSG_DEFAULTS_RESET */
-    }
-
-    /* CCMSG_MULTICAST_MACHINE_RESET *******************************************/
-    case CCMSG_MULTICAST_MACHINE_RESET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MULTICAST_MACHINE_RESET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwGenReq_t);
-
-      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
-
-      /* Reset multicast machine */
-      rc = ptin_msg_multicast_reset(ptr);
-
-      /* Error? */
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-      /* Success */
-      SETIPCACKOK(outbuffer);
-      break;  /* CCMSG_DEFAULTS_RESET */
-    }
-
-    /* CCMSG_TYPEB_PROT_SWITCH *******************************************/
-    case CCMSG_TYPEB_PROT_SWITCH_NOTIFY:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_TYPEB_PROT_SWITCH_NOTIFY (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwTypeBProtSwitchNotify_t);
-
-      msg_HwTypeBProtSwitchNotify_t *ptr = (msg_HwTypeBProtSwitchNotify_t *) &inbuffer->info[0];
-
-      /* TYPE B Protection Switching */
-      rc = ptin_msg_typeBprotIntfSwitchNotify(ptr);
-
-      /* Error? */
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-      /* Success */
-      SETIPCACKOK(outbuffer);
-      break;  /* CCMSG_DEFAULTS_RESET */
-    }
-
-    case CCMSG_TYPEB_PROT_INTF_CONFIG:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_TYPEB_PROT_INTF_CONFIG (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwTypeBProtIntfConfig_t);
-
-      msg_HwTypeBProtIntfConfig_t *ptr = (msg_HwTypeBProtIntfConfig_t *) &inbuffer->info[0];
-
-      /* TYPE B Protection Switching */
-      rc = ptin_msg_typeBprotIntfConfig(ptr);
-
-      /* Error? */
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-      /* Success */
-      SETIPCACKOK(outbuffer);
-      break;  /* CCMSG_DEFAULTS_RESET */
-    }
-
-    case CCMSG_TYPEB_PROT_SWITCH:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_TYPEB_PROT_SWITCH (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwTypeBprot_t);
-
-      msg_HwTypeBprot_t *ptr = (msg_HwTypeBprot_t *) &inbuffer->info[0];
-
-      /* TYPE B Protection Switching */
-      rc = ptin_msg_typeBprotSwitch(ptr);
-
-      /* Error? */
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-      /* Success */
-      SETIPCACKOK(outbuffer);
-      break;  /* CCMSG_DEFAULTS_RESET */
-    }
-
-    case CCMSG_HW_BOARD_ACTION:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_HW_BOARD_ACTION (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwGenReq_t);
-
-      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
-
-      /* Hwardware procedure */
-      rc = ptin_msg_board_action(ptr);
-
-      /* Error? */
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-      /* Success */
-      SETIPCACKOK(outbuffer);
-      break;  /* CCMSG_HW_BOARD_ACTION */
-    }
-
-    case CCMSG_HW_LINK_ACTION:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_HW_LINK_ACTION (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwGenReq_t);
-
-      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
-
-      /* Hwardware procedure */
-      rc = ptin_msg_link_action(ptr);
-
-      /* Error? */
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-      /* Success */
-      SETIPCACKOK(outbuffer);
-      break;  /* CCMSG_HW_LINK_ACTION */
-    }
-
-    case CHMSG_UPLINKPROT_INFO:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_INFO (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_ATLEAST_ABS(sizeof(unsigned char) + sizeof(msg_HwEthInterface_t));
-
-      /* Execute command */
-      rc = ptin_msg_uplink_prot_info_get(inbuffer, outbuffer);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading info");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        return IPC_OK;
-      }
-
-      return IPC_OK;
-    }
-
-    case CHMSG_UPLINKPROT_SHOW:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_SHOW (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_ATLEAST_ABS(sizeof(unsigned char) + sizeof(unsigned short));
-
-      /* Execute command */
-      rc = ptin_msg_uplink_prot_config_get(inbuffer, outbuffer);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading status");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        return IPC_OK;
-      }
-
-      return IPC_OK;
-    }
-    break; /* CHMSG_UPLINKPROT_SHOW */
-
-    /* CHMSG_UPLINKPROT_STATE */
-    case CHMSG_UPLINKPROT_STATE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_STATE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_ATLEAST_ABS(sizeof(unsigned char) + sizeof(unsigned short));
-
-      /* Execute command */
-      rc = ptin_msg_uplink_prot_state(inbuffer, outbuffer);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading state");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        return IPC_OK;
-      }
-      return IPC_OK;
-    }
-    break; /* CHMSG_UPLINKPROT_STATE */
-
-    case CHMSG_UPLINKPROT_STATUS:
-    case CHMSG_UPLINKPROT_STATUSNEXT:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_STATUS (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_ATLEAST_ABS(sizeof(unsigned char) + sizeof(unsigned short));
-
-      /* Execute command */
-      rc = ptin_msg_uplink_prot_status(inbuffer, outbuffer);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading status");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        return IPC_OK;
-      }
-
-      return IPC_OK;
-    }
-    break; /* CHMSG_UPLINKPROT_STATUS */
-
-    /* Uplink protection applied to LAG interfaces */
-    case CHMSG_UPLINKPROT_CREATE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_CREATE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HWuplinkProtConf);
-
-      /* Hwardware procedure */
-      rc = ptin_msg_uplink_prot_create(inbuffer, outbuffer);
-
-      /* Error? */
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-      /* Success */
-      SETIPCACKOK(outbuffer);
-    }
-    break;  /*CHMSG_UPLINKPROT_CREATE*/
-
-    case CHMSG_UPLINKPROT_CONFIG:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_CONFIG (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HWuplinkProtConf);
-
-      /* Hwardware procedure */
-      rc = ptin_msg_uplink_prot_config(inbuffer, outbuffer);
-
-      /* Error? */
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-      /* Success */
-      SETIPCACKOK(outbuffer);
-    }
-    break; /* CHMSG_UPLINKPROT_CONFIG */
-
-    case CHMSG_UPLINKPROT_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_ATLEAST_ABS(sizeof(unsigned char) + sizeof(unsigned short));
-
-      /* Hwardware procedure */
-      rc = ptin_msg_uplink_prot_remove(inbuffer, outbuffer);
-
-      /* Error? */
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-      /* Success */
-      SETIPCACKOK(outbuffer);
-    }
-    break; /* CHMSG_UPLINKPROT_REMOVE */
-
-    case CHMSG_UPLINKPROT_COMMAND:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_COMMAND (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HWuplinkProtCommand);
-
-      /* Hwardware procedure */
-      rc = ptin_msg_uplink_prot_command(inbuffer, outbuffer);
-
-      /* Error? */
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-      /* Success */
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /************************************************************************** 
-     * SLOT MODE CONFIGURATION
-     **************************************************************************/
-
-    case CCMSG_SLOT_MAP_MODE_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SLOT_MAP_MODE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_ATLEAST(L7_uint32);
-      msg_slotModeCfg_t *ptr;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_slotModeCfg_t));
-      ptr = (msg_slotModeCfg_t *) outbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_slotMode_get(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading slot map");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_slotModeCfg_t));
-    }
-    break;
-
-    case CCMSG_SLOT_MAP_MODE_VALIDATE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SLOT_MAP_MODE_VALIDATE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_slotModeCfg_t);
-
-      msg_slotModeCfg_t *ptr = (msg_slotModeCfg_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_slotMode_validate(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    case CCMSG_SLOT_MAP_MODE_APPLY:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SLOT_MAP_MODE_APPLY (0x%04X)", msgId);
-
-      //CHECK_INFO_SIZE_MOD(msg_slotModeCfg_t);
-
-      //msg_slotModeCfg_t *ptr = (msg_slotModeCfg_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_slotMode_apply();
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    case CCMSG_SWITCH_TEMPERATURE_GET:
-    {
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SWITCH_TEMPERATURE_GET (0x%04X)", msgId);
-
-      msg_ptin_temperature_monitor_t *ptr;
-
-      ptr = (msg_ptin_temperature_monitor_t *) outbuffer->info;
-      memset(ptr, 0x00, sizeof(msg_ptin_temperature_monitor_t));
-
-      /* Execute command */
-      rc = ptin_msg_switch_temperature_get(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading temperature");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_ptin_temperature_monitor_t));
-    }
-    break;
-
-    /************************************************************************** 
-     * PHY CONFIG Processing
-     **************************************************************************/
-
-    case CCMSG_ETH_OLTD_HW_CONFIG:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_OLTD_HW_CONFIG (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_OLTDHWConfig_t);
-
-      /* Execute command */
-      rc = ptin_msg_oltd_hw_config(inbuffer, outbuffer);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    case CCMSG_ETH_PHY_STATUS_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_STATUS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_ATLEAST(L7_uint32);
-
-      msg_HWEthPhyStatus_t *pin     = (msg_HWEthPhyStatus_t *) inbuffer->info;
-
-      #if (PTIN_SYSTEM_N_PONS > 0 || PTIN_SYSTEM_N_ETH > 0)
-      L7_uint i;
-      msg_HWEthPhyStatus_t *pout    = (msg_HWEthPhyStatus_t *) outbuffer->info;
-
-      /* Output info read */
-      PT_LOG_DEBUG(LOG_CTX_MSG, "Requesting...");
-      PT_LOG_DEBUG(LOG_CTX_MSG, " SlotId    = %u", ENDIAN_SWAP8(pin->SlotId));
-      PT_LOG_DEBUG(LOG_CTX_MSG, " BoardType = %u", ENDIAN_SWAP8(pin->BoardType));
-      PT_LOG_DEBUG(LOG_CTX_MSG, " PortId    = %u", ENDIAN_SWAP8(pin->Port));
-
-      /* Single port ? */
-      if (ENDIAN_SWAP8(pin->Port) < max(PTIN_SYSTEM_N_PONS, PTIN_SYSTEM_N_ETH))
-      {
-        memcpy(pout, pin, sizeof(msg_HWEthPhyStatus_t));
-
-        if (ptin_msg_PhyStatus_get(pout) != L7_SUCCESS)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port status (port# %u)", ENDIAN_SWAP8(pin->Port));
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPC_INFODIM(sizeof(msg_HWEthPhyStatus_t));
-      }
-      /* Swipe all ports */
-      else
-      {
-        for (i = 0; i < PTIN_SYSTEM_N_ETH; i++)
-        {
-          memcpy(&pout[i], pin, sizeof(msg_HWEthPhyStatus_t));
-          pout[i].Port = ENDIAN_SWAP8(i);
-
-          if (ptin_msg_PhyStatus_get(&pout[i]) != L7_SUCCESS)
-            break;
-        }
-
-        /* Error? */
-        if (i < PTIN_SYSTEM_N_ETH)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port Status (port# %u)", ENDIAN_SWAP8(pin->Port));
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPC_INFODIM(sizeof(msg_HWEthPhyStatus_t) * i);
-      }
-      #else
-      PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port Status (port# %u)", ENDIAN_SWAP8(pin->Port));
-      res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-      SetIPCNACK(outbuffer, res);
-      break;
-      #endif
-
-
-      break;  /* CCMSG_ETH_PHY_STATUS_GET */
-    }
-
-    /* CCMSG_ETH_PHY_CONFIG_SET ***********************************************/
-    case CCMSG_ETH_PHY_CONFIG_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_CONFIG_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HWEthPhyConf_t);
-
-      L7_uint i, n;
-      msg_HWEthPhyConf_t *pi = (msg_HWEthPhyConf_t *) &inbuffer->info[0];
-
-      /* Validate info size */
-      if ( (infoDim < sizeof(msg_HWEthPhyConf_t)) || ((infoDim % sizeof(msg_HWEthPhyConf_t)) != 0) )
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! (%u)", infoDim);
-        res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      n = MSG_N_ELEMS(sizeof(msg_HWEthPhyConf_t));
-      if (n > PTIN_SYSTEM_N_PORTS)
-        n = PTIN_SYSTEM_N_PORTS;
-
-      /* Apply config */
-      for (i = 0; i < n; i++)
-        if (L7_SUCCESS != ptin_msg_PhyConfig_set(&pi[i]))
-          break;
-
-      if (i != n)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting ports configuration (port# %u)", i);
-        res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_PHY_CONFIG_SET */
-    }
-
-
-    /* CCMSG_ETH_PHY_CONFIG_GET ***********************************************/
-    case CCMSG_ETH_PHY_CONFIG_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_CONFIG_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwGenReq_t);
-
-      L7_uint i;
-      msg_HwGenReq_t     *req  = (msg_HwGenReq_t *) &inbuffer->info[0];
-      msg_HWEthPhyConf_t *pout = (msg_HWEthPhyConf_t *) &outbuffer->info[0];
-      msg_HWEthPhyConf_t  pin[1];
-
-      /* Reference structure */
-      memset(pin,0x00,sizeof(msg_HWEthPhyConf_t));
-      pin->SlotId = req->slot_id;
-      pin->Port   = req->generic_id;
-      pin->Mask   = ENDIAN_SWAP16(0xffff);
-
-      /* Single port ? */
-      if (pin->Port < PTIN_SYSTEM_N_PORTS)
-      {
-        memcpy(pout, pin, sizeof(msg_HWEthPhyConf_t));
-
-        if (ptin_msg_PhyConfig_get(pout) != L7_SUCCESS)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port configuration (port# %u)", ENDIAN_SWAP8(pin->Port));
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPC_INFODIM(sizeof(msg_HWEthPhyConf_t));
-      }
-      /* Swipe all ports */
-      else
-      {
-        for (i = 0; i < PTIN_SYSTEM_N_PORTS; i++)
-        {
-          memcpy(&pout[i], pin, sizeof(msg_HWEthPhyConf_t));
-          pout[i].Port = ENDIAN_SWAP8(i);
-
-          if (ptin_msg_PhyConfig_get(&pout[i]) != L7_SUCCESS)
-            break;
-        }
-
-        /* Error? */
-        if (i != PTIN_SYSTEM_N_PORTS)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port configuration (port# %u)", ENDIAN_SWAP8(pin->Port));
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPC_INFODIM(sizeof(msg_HWEthPhyConf_t) * i);
-      }
-
-
-      break;  /* CCMSG_ETH_PHY_CONFIG_GET */
-    }
-
-
-    /* CCMSG_ETH_PHY_STATE_GET ************************************************/
-    case CCMSG_ETH_PHY_STATE_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_STATE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwGenReq_t);
-
-      L7_uint i;
-      msg_HwGenReq_t      *request = (msg_HwGenReq_t *) inbuffer->info;
-      msg_HWEthPhyState_t *pout    = (msg_HWEthPhyState_t *) outbuffer->info;
-      msg_HWEthPhyState_t  pin[1];
-
-      /* Reference structure */
-      memset(pin,0x00,sizeof(msg_HWEthPhyState_t));
-      pin->SlotId = request->slot_id;
-      pin->Port   = request->generic_id;
-      pin->Mask   = ENDIAN_SWAP16(0xffff);
-
-      /* Single port ? */
-      if (ENDIAN_SWAP8(pin->Port) < PTIN_SYSTEM_N_PORTS)
-      {
-        memcpy(pout, pin, sizeof(msg_HWEthPhyState_t));
-
-        if (ptin_msg_PhyState_get(pout) != L7_SUCCESS)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port state (port# %u)", ENDIAN_SWAP8(pin->Port));
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPC_INFODIM(sizeof(msg_HWEthPhyState_t));
-      }
-      /* Swipe all ports */
-      else
-      {
-        for (i = 0; i < PTIN_SYSTEM_N_PORTS; i++)
-        {
-          memcpy(&pout[i], pin, sizeof(msg_HWEthPhyState_t));
-          pout[i].Port = ENDIAN_SWAP8(i);
-
-          if (ptin_msg_PhyState_get(&pout[i]) != L7_SUCCESS)
-            break;
-        }
-
-        /* Error? */
-        if (i != PTIN_SYSTEM_N_PORTS)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port state (port# %u)", ENDIAN_SWAP8(pin->Port));
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPC_INFODIM(sizeof(msg_HWEthPhyState_t) * i);
-      }
-
-
-      break;  /* CCMSG_ETH_PHY_STATE_GET */
-    }
-
-    /************************************************************************** 
-     * PHY COUNTERS Processing
-     **************************************************************************/
-
-    /* CCMSG_ETH_PHY_COUNTERS_GET *********************************************/
-    case CCMSG_ETH_PHY_COUNTERS_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_COUNTERS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HwGenReq_t);
-
-      msg_HwGenReq_t                    *request;
-      msg_HWEthRFC2819_PortStatistics_t *portStats;
-      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_HwGenReq_t));
-
-      request   = (msg_HwGenReq_t *) inbuffer->info;
-      portStats = (msg_HWEthRFC2819_PortStatistics_t *) outbuffer->info;
-
-      /* Get values */
-      if (L7_SUCCESS != ptin_msg_PhyCounters_read(request, portStats, nElems))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting counters (port# %u)", ENDIAN_SWAP8(portStats->Port));
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_HWEthRFC2819_PortStatistics_t)*nElems);
-      break;  /* CCMSG_ETH_PHY_COUNTERS_GET */
-    }
-
-
-    /* CCMSG_ETH_PHY_COUNTERS_CLEAR *******************************************/
-    case CCMSG_ETH_PHY_COUNTERS_CLEAR:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_COUNTERS_CLEAR (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HWEthRFC2819_PortStatistics_t);
-
-      msg_HWEthRFC2819_PortStatistics_t *portStats;
-      portStats = (msg_HWEthRFC2819_PortStatistics_t *) inbuffer->info;
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_PhyCounters_clear(portStats))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing counters (port# %u)", ENDIAN_SWAP8(portStats->Port));
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);      
-      break; /* CCMSG_ETH_PHY_COUNTERS_CLEAR */
-    }
-
-    /************************************************************************** 
-     * Port Type Settings
-     **************************************************************************/
-
-    /* Set Port type (MEF extension) configuration */
-    case CCMSG_ETH_PORT_EXT_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_EXT_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HWPortExt_t);
-
-      msg_HWPortExt_t *ptr = (msg_HWPortExt_t *) inbuffer->info;
-      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_HWPortExt_t));
-
-      /* Execute command */
-      rc = ptin_msg_portExt_set(ptr, nElems);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Get Port type (MEF extension) configuration */
-    case CCMSG_ETH_PORT_EXT_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_TYPE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HWPortExt_t);
-
-      msg_HWPortExt_t *ptr;
-      L7_uint          nElems;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HWPortExt_t));
-      ptr = (msg_HWPortExt_t *) outbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_portExt_get(ptr,&nElems);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_HWPortExt_t) * nElems);
-    }
-    break;
-
-    /* Set MAC address */
-    case CCMSG_ETH_PORT_MAC_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_MAC_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HWPortMac_t);
-
-      msg_HWPortMac_t *ptr = (msg_HWPortMac_t *) inbuffer->info;
-      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_HWPortMac_t));
-
-      /* Execute command */
-      rc = ptin_msg_portMAC_set(ptr, nElems);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Get MAC address */
-    case CCMSG_ETH_PORT_MAC_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_MAC_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HWPortMac_t);
-
-      msg_HWPortMac_t *ptr;
-      L7_uint          nElems;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HWPortMac_t));
-      ptr = (msg_HWPortMac_t *) outbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_portMAC_get(ptr, &nElems);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_HWPortMac_t) * nElems);
-    }
-    break;
-
-    /************************************************************************** 
-     * QoS Processing
-     **************************************************************************/
-
-    /* Get CoS configuration */
-    case CCMSG_ETH_PORT_COS_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_QoSConfiguration_t);
-
-      msg_QoSConfiguration_t *ptr;
-      ptr = (msg_QoSConfiguration_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_QoSConfiguration_t));
-
-      /* Execute command */
-      rc = ptin_msg_CoS_get(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_QoSConfiguration_t));
-    }
-    break;
-
-    /* Set new CoS configuration */
-    case CCMSG_ETH_PORT_COS_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_QoSConfiguration_t);
-
-      msg_QoSConfiguration_t *ptr;
-      ptr = (msg_QoSConfiguration_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_CoS_set(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Get CoS configuration */
-    case CCMSG_ETH_PORT_COS2_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS2_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_QoSConfiguration2_t);
-
-      msg_QoSConfiguration2_t *ptr;
-      ptr = (msg_QoSConfiguration2_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_QoSConfiguration2_t));
-
-      /* Execute command */
-      rc = ptin_msg_CoS2_get(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_QoSConfiguration2_t));
-    }
-    break;
-
-    /* Set new CoS configuration */
-    case CCMSG_ETH_PORT_COS2_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS2_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_QoSConfiguration2_t);
-
-      msg_QoSConfiguration2_t *ptr;
-      ptr = (msg_QoSConfiguration2_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_CoS2_set(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Get CoS configuration */
-    case CCMSG_ETH_PORT_COS3_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS3_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_QoSConfiguration3_t);
-
-      msg_QoSConfiguration3_t *ptr;
-      ptr = (msg_QoSConfiguration3_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_QoSConfiguration3_t));
-
-      /* Execute command */
-      rc = ptin_msg_CoS3_get(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_QoSConfiguration3_t));
-    }
-    break;
-
-    /* Set new CoS configuration */
-    case CCMSG_ETH_PORT_COS3_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS3_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_QoSConfiguration3_t);
-
-      msg_QoSConfiguration3_t *ptr;
-      ptr = (msg_QoSConfiguration3_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_CoS3_set(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /************************************************************************** 
-     * LAGs Processing
-     **************************************************************************/
-
-    /* CCMSG_ETH_LACP_LAG_GET *************************************************/
-    case CCMSG_ETH_LACP_LAG_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_LACPLagInfo_t);
-
-      msg_LACPLagInfo_t *request = (msg_LACPLagInfo_t *) inbuffer->info;
-      msg_LACPLagInfo_t *lagInfo = (msg_LACPLagInfo_t *) outbuffer->info;
-      L7_uint            nElems;
-
-      memcpy(lagInfo, request, sizeof(msg_LACPLagInfo_t));
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_Lag_get(lagInfo, &nElems))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting LAGs info");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_LACPLagInfo_t) * nElems);
-
-      break;  /* CCMSG_ETH_LACP_LAG_GET */
-    }
-
-
-    /* CCMSG_ETH_LACP_LAG_ADD *************************************************/
-    case CCMSG_ETH_LACP_LAG_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_LACPLagInfo_t);
-
-      msg_LACPLagInfo_t *lagInfo;
-      lagInfo = (msg_LACPLagInfo_t *) inbuffer->info;
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_Lag_create(lagInfo))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while creating a LAG");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_LACP_LAG_ADD */
-    }
-
-
-    /* CCMSG_ETH_LACP_LAG_REMOVE **********************************************/
-    case CCMSG_ETH_LACP_LAG_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_LACPLagInfo_t);
-
-      msg_LACPLagInfo_t *lagInfo;
-      lagInfo = (msg_LACPLagInfo_t *) inbuffer->info;
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_Lag_destroy(lagInfo))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while destroying a LAG");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-      break;  /* CCMSG_ETH_LACP_LAG_REMOVE */
-    }
-
-
-    /* CCMSG_ETH_LACP_LAG_STATUS_GET ******************************************/
-    case CCMSG_ETH_LACP_LAG_STATUS_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_STATUS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_LACPLagStatus_t);
-
-      msg_LACPLagStatus_t *request   = (msg_LACPLagStatus_t *) inbuffer->info;
-      msg_LACPLagStatus_t *lagStatus = (msg_LACPLagStatus_t *) outbuffer->info;
-      L7_uint              nElems=0;
-
-      memcpy(lagStatus, request, sizeof(msg_LACPLagStatus_t));
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_LagStatus_get(lagStatus, &nElems))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting LAGs status");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_LACPLagStatus_t) * nElems);
-      break;  /* CCMSG_ETH_LACP_LAG_STATUS_GET */
-    }
-
-
-    /* CCMSG_ETH_LACP_ADMINSTATE_SET ******************************************/
-    case CCMSG_ETH_LACP_ADMINSTATE_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_ADMINSTATE_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_LACPAdminState_t);
-
-      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_LACPAdminState_t));
-      msg_LACPAdminState_t *lagAdminState = (msg_LACPAdminState_t *) inbuffer->info;
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_LACPAdminState_set(lagAdminState, nElems))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting LACP admin state");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_LACP_ADMINSTATE_SET */
-    }
-
-
-    /* CCMSG_ETH_LACP_ADMINSTATE_GET ******************************************/
-    case CCMSG_ETH_LACP_ADMINSTATE_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_ADMINSTATE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_LACPAdminState_t);
-
-      L7_uint nElems;
-      msg_LACPAdminState_t *request       = (msg_LACPAdminState_t *) inbuffer->info;
-      msg_LACPAdminState_t *lagAdminState = (msg_LACPAdminState_t *) outbuffer->info;
-
-      memcpy(lagAdminState, request, sizeof(msg_LACPAdminState_t));
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_LACPAdminState_get(lagAdminState, &nElems))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting LACP admin state");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_LACPAdminState_t) * nElems);
-      break;  /* CCMSG_ETH_LACP_ADMINSTATE_GET */
-    }
-
-
-    /* CCMSG_ETH_LACP_STATS_GET ***********************************************/
-    case CCMSG_ETH_LACP_STATS_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_STATS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_LACPStats_t);
-
-      L7_uint nElems;
-      msg_LACPStats_t  *request = (msg_LACPStats_t *) inbuffer->info;
-      msg_LACPStats_t *lagStats = (msg_LACPStats_t *) outbuffer->info;
-
-      /* Note: the index field provides the LAG nr (if out of range, all LAGs are returned) */
-      memcpy(lagStats, request, sizeof(msg_LACPStats_t));
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_LACPStats_get(lagStats, &nElems))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting LACP stats");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_LACPStats_t) * nElems);
-      break;  /* CCMSG_ETH_LACP_STATS_GET */
-    }
-
-
-    /* CCMSG_ETH_LACP_STATS_CLEAR *********************************************/
-    case CCMSG_ETH_LACP_STATS_CLEAR:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_STATS_CLEAR (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_LACPStats_t);
-
-      msg_LACPStats_t *lagStats;
-      lagStats = (msg_LACPStats_t *) inbuffer->info;
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_LACPStats_clear(lagStats))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing LACP stats");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_LACP_STATS_CLEAR */
-    }
-
-    /************************************************************************** 
-     * L2 Table Processing
-     **************************************************************************/
-
-    /* L2 Aging get */
-    case CCMSG_ETH_SWITCH_CONFIG_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_SWITCH_CONFIG_GET (0x%04X)", msgId);
-      CHECK_INFO_SIZE(msg_switch_config_t);
-
-      msg_switch_config_t *switch_config = (msg_switch_config_t *) &outbuffer->info[0];
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_switch_config_t));
-
-      /* Execute command */
-      rc = ptin_msg_l2_switch_config_get(switch_config);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting config");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_HwEthMef10Evc_t));
-    }
-    break;
-
-    /* L2 Aging set */
-    case CCMSG_ETH_SWITCH_CONFIG_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_SWITCH_CONFIG_SET (0x%04X)", msgId);
-      CHECK_INFO_SIZE(msg_switch_config_t);
-
-      msg_switch_config_t *switch_config = (msg_switch_config_t *) &inbuffer->info[0];
-
-      /* Execute command */
-      rc = ptin_msg_l2_switch_config_set(switch_config);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Get L2 table */
-    case CCMSG_ETH_MAC_TABLE_SHOW:
-    case CCMSG_ETH_MAC_TABLE_SHOW2:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_MAC_TABLE_SHOW (0x%04X)", msgId);
-      CHECK_INFO_SIZE(msg_switch_mac_intro_t);
-
-      msg_switch_mac_table_t *mac_table = (msg_switch_mac_table_t *) outbuffer->info;
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_switch_mac_intro_t));
-
-      /* Execute command */
-      rc = ptin_msg_l2_macTable_get(mac_table, ((CCMSG_ETH_MAC_TABLE_SHOW == msgId) ? 1 : 2));
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting MAC list");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_switch_mac_table_t));
-    }
-    break;
-
-    /* Remove an entry of the L2 table */
-    case CCMSG_ETH_MAC_ENTRY_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_MAC_ENTRY_REMOVE (0x%04X)", msgId);
-      CHECK_INFO_SIZE(msg_switch_mac_table_entry_t);
-
-      msg_switch_mac_table_entry_t *mac_table = (msg_switch_mac_table_entry_t *) inbuffer->info;
-      L7_uint32 n = MSG_N_ELEMS(sizeof(msg_switch_mac_table_entry_t));
-
-      /* Execute command */
-      rc = ptin_msg_l2_macTable_remove(mac_table, n);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing MAC");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Add an entry to the L2 table */
-    case CCMSG_ETH_MAC_ENTRY_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_MAC_ENTRY_ADD (0x%04X)", msgId);
-      CHECK_INFO_SIZE(msg_switch_mac_table_entry_t);
-
-      msg_switch_mac_table_entry_t *mac_table = (msg_switch_mac_table_entry_t *) inbuffer->info;
-      L7_uint32 n = MSG_N_ELEMS(sizeof(msg_switch_mac_table_entry_t));
-
-      /* Execute command */
-      rc = ptin_msg_l2_macTable_add(mac_table, n);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding MAC");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /************************************************************************** 
-     * Dynamic ARP Inspection
-     **************************************************************************/
-    /* Dynamic ARP Inspection */
-    case CCMSG_ETH_DAI_GLOBAL_CONFIG:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_GLOBAL_CONFIG (0x%04X)", msgId);
-      CHECK_INFO_SIZE(msg_dai_global_settings_t);
-
-      msg_dai_global_settings_t *config = (msg_dai_global_settings_t *) &inbuffer->info[0];
-
-      /* Execute command */
-      rc = ptin_msg_dai_global_config(config);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    case CCMSG_ETH_DAI_INTF_CONFIG:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_INTF_CONFIG (0x%04X)", msgId);
-      CHECK_INFO_SIZE_MOD(msg_dai_intf_settings_t);
-
-      msg_dai_intf_settings_t *config = (msg_dai_intf_settings_t *) &inbuffer->info[0];
-      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_dai_intf_settings_t));
-
-      /* Execute command */
-      rc = ptin_msg_dai_intf_config(config, nElems);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    case CCMSG_ETH_DAI_VLAN_CONFIG:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_VLAN_CONFIG (0x%04X)", msgId);
-      CHECK_INFO_SIZE_MOD(msg_dai_vlan_settings_t);
-
-      msg_dai_vlan_settings_t *config = (msg_dai_vlan_settings_t *) &inbuffer->info[0];
-      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_dai_vlan_settings_t));
-
-      /* Execute command */
-      rc = ptin_msg_dai_vlan_config(config, nElems);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    case CCMSG_ETH_DAI_STATISTICS:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_STATISTICS (0x%04X)", msgId);
-      CHECK_INFO_SIZE_MOD(msg_dai_statistics_t);
-
-      /* Copy input to output */
-      memcpy(outbuffer->info, inbuffer->info, infoDim);
-
-      msg_dai_statistics_t *stats = (msg_dai_statistics_t *) &outbuffer->info[0];
-      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_dai_statistics_t));
-
-      /* Execute command */
-      rc = ptin_msg_dai_stats_get(stats, nElems);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_dai_statistics_t)*nElems);
-    }
-    break;
-
-    /************************************************************************** 
-     * EVCs Processing
-     **************************************************************************/
-
-    /* CCMSG_ETH_EVC_GET ******************************************************/
-    case CCMSG_ETH_EVC_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_GET (0x%04X)", msgId);
-  
-      CHECK_INFO_SIZE(msg_HwEthMef10Evc_t);
-
-      msg_HwEthMef10Evc_t *evcConf;
-      evcConf = (msg_HwEthMef10Evc_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwEthMef10Evc_t));
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_EVC_get(evcConf))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting EVC# %u config", ENDIAN_SWAP32(evcConf->id));
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_HwEthMef10Evc_t));
-      break;  /* CCMSG_ETH_EVC_GET */
-    }
-
-
-    /* CCMSG_ETH_EVC_ADD ******************************************************/
-    case CCMSG_ETH_EVC_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_ATLEAST(msg_HwEthMef10Evc_t);
-
-      /* Execute command */
-      rc = ptin_msg_EVC_create(inbuffer, outbuffer);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while creating EVC");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_ADD */
-    }
-
-    /* CCMSG_ETH_EVC_REMOVE ***************************************************/
-    case CCMSG_ETH_EVC_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HwEthMef10EvcRemove_t);
-
-      msg_HwEthMef10EvcRemove_t *evcConf = (msg_HwEthMef10EvcRemove_t *) inbuffer->info;
-      L7_uint16 n_structs = MSG_N_ELEMS(sizeof(msg_HwEthMef10EvcRemove_t));
-
-      /* Execute command */
-      rc = ptin_msg_EVC_delete(evcConf, n_structs);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while deleting EVCs");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_REMOVE */
-    }
-
-    /* CCMSG_ETH_EVC_PORT_ADD ******************************************************/
-    case CCMSG_ETH_EVC_PORT_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_PORT_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HWevcPort_t);
-
-      msg_HWevcPort_t *evcPort = (msg_HWevcPort_t *) inbuffer->info;
-      L7_uint16        n_size  = MSG_N_ELEMS(sizeof(msg_HWevcPort_t));
-
-      /* Execute command */
-      rc = ptin_msg_evc_port(evcPort, n_size, PTIN_MSG_OPER_ADD);
-
-      if (L7_SUCCESS != rc)
-      {       
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding port to EVC [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_PORT_ADD */
-    }
-
-    /* CCMSG_ETH_EVC_PORT_REMOVE ***************************************************/
-    case CCMSG_ETH_EVC_PORT_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_PORT_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HWevcPort_t);
-
-      msg_HWevcPort_t *evcPort = (msg_HWevcPort_t *) inbuffer->info;
-      L7_uint16        n_size  = MSG_N_ELEMS(sizeof(msg_HWevcPort_t));
-
-      /* Execute command */
-      rc = ptin_msg_evc_port(evcPort, n_size, PTIN_MSG_OPER_REMOVE);
-
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding port to EVC [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_PORT_REMOVE */
-    }
-
-    /* CCMSG_ETH_EVC_OPTIONS_SET *************************************************/
-    case CCMSG_ETH_EVC_OPTIONS_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_OPTIONS_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HwEthMef10EvcOptions_t);
-
-      /* Execute command */
-      rc = ptin_msg_evc_config(inbuffer, outbuffer);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while reconfiguring EVC");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_ADD */
-    }
-
-    case CCMSG_ETH_EVC_QOS_SET:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_QOS_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_evc_qos_t);
-
-      /* Execute command */
-      rc = ptin_msg_evc_qos_set(inbuffer, outbuffer);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while configuring QoS");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_QOS_SET */
-
-    /* CCMSG_ETH_EVC_BRIDGE_ADD ***********************************************/
-    case CCMSG_ETH_EVC_BRIDGE_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_BRIDGE_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthEvcBridge_t);
-
-      msg_HwEthEvcBridge_t *evcBridge;
-      evcBridge = (msg_HwEthEvcBridge_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_EVCBridge_add(evcBridge);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding a bridge to EVC# %u", ENDIAN_SWAP32(evcBridge->evcId));
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_BRIDGE_ADD */
-    }
-
-
-    /* CCMSG_ETH_EVC_BRIDGE_REMOVE ********************************************/
-    case CCMSG_ETH_EVC_BRIDGE_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_BRIDGE_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthEvcBridge_t);
-
-      msg_HwEthEvcBridge_t *evcBridge;
-      evcBridge = (msg_HwEthEvcBridge_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_EVCBridge_remove(evcBridge);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing a bridge to EVC# %u", ENDIAN_SWAP32(evcBridge->evcId));
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_BRIDGE_REMOVE */
-    }
-
-    /* CCMSG_ETH_EVC_FLOW_ADD ***********************************************/
-    case CCMSG_ETH_EVC_FLOW_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOW_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthEvcFlow_t);
-
-      msg_HwEthEvcFlow_t *evcFlow;
-      evcFlow = (msg_HwEthEvcFlow_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_EVCFlow_add(evcFlow);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding a flow to eEVC# %u", ENDIAN_SWAP32(evcFlow->evcId));
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_FLOW_ADD */
-    }
-
-    /* CCMSG_ETH_EVC_FLOW_REMOVE ********************************************/
-    case CCMSG_ETH_EVC_FLOW_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOW_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthEvcFlow_t);
-
-      msg_HwEthEvcFlow_t *evcFlow;
-      evcFlow = (msg_HwEthEvcFlow_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_EVCFlow_remove(evcFlow);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing a flow from eEVC# %u", ENDIAN_SWAP32(evcFlow->evcId));
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_BRIDGE_REMOVE */
-    }
-
-    /* Add vlan to be flooded */
-    case CCMSG_ETH_EVC_FLOOD_VLAN_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOOD_VLAN_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HwEthEvcFloodVlan_t);
-
-      msg_HwEthEvcFloodVlan_t *evcFlood;
-      L7_uint32 n_clients;
-
-      evcFlood  = (msg_HwEthEvcFloodVlan_t *) inbuffer->info;
-      n_clients = MSG_N_ELEMS(sizeof(msg_HwEthEvcFloodVlan_t));
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_EvcFloodVlan_add(evcFlood, n_clients))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding a flood vlan to EVC# %u", ENDIAN_SWAP32(evcFlood->evcId));
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_FLOOD_VLAN_ADD */
-    }
-
-    /* Remove vlan to be flooded */
-    case CCMSG_ETH_EVC_FLOOD_VLAN_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOOD_VLAN_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HwEthEvcFloodVlan_t);
-
-      msg_HwEthEvcFloodVlan_t *evcFlood;
-      L7_uint32 n_clients;
-
-      evcFlood  = (msg_HwEthEvcFloodVlan_t *) inbuffer->info;
-      n_clients = MSG_N_ELEMS(sizeof(msg_HwEthEvcFloodVlan_t));
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_EvcFloodVlan_remove(evcFlood, n_clients))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing a flood vlan to EVC# %u", ENDIAN_SWAP32(evcFlood->evcId));
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_FLOOD_VLAN_ADD */
-    }
-
-    /************************************************************************** 
-     * EVCs Counters config
-     **************************************************************************/
-
-    /* CCMSG_ETH_EVC_COUNTERS_GET *********************************************/
-    case CCMSG_ETH_EVC_COUNTERS_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_COUNTERS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_evcStats_t);
-
-      msg_evcStats_t *evcstat_in, *evcstat_out;
-      evcstat_in  = (msg_evcStats_t *) inbuffer->info;
-      evcstat_out = (msg_evcStats_t *) outbuffer->info;
-
-      memcpy(evcstat_out, evcstat_in, sizeof(msg_evcStats_t));
-
-      /* Execute command */
-      rc = ptin_msg_evcStats_get(evcstat_out);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while reading EVC stats");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_evcStats_t));
-      break;  /* CCMSG_ETH_EVC_COUNTERS_GET */
-    }
-
-
-    /* CCMSG_ETH_EVC_COUNTERS_ADD *********************************************/
-    case CCMSG_ETH_EVC_COUNTERS_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_COUNTERS_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_evcStats_t);
-
-      msg_evcStats_t *evc_stat;
-      evc_stat = (msg_evcStats_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_evcStats_set(evc_stat);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding EVC stats");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_COUNTERS_ADD */
-    }
-
-    /* CCMSG_ETH_EVC_COUNTERS_REMOVE ******************************************/
-    case CCMSG_ETH_EVC_COUNTERS_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_COUNTERS_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_evcStats_t);
-
-      msg_evcStats_t *evc_stat;
-      evc_stat = (msg_evcStats_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_evcStats_delete(evc_stat);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing EVC stats");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_EVC_COUNTERS_REMOVE */
-    }
-
-
-    /************************************************************************** 
-     * Bandwidth profiles Config
-     **************************************************************************/
-
-    /* CCMSG_ETH_BW_PROFILE_GET ***********************************************/
-    case CCMSG_ETH_BW_PROFILE_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_BW_PROFILE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthBwProfile_t);
-
-      msg_HwEthBwProfile_t *bwProfile_in, *bwProfile_out;
-      bwProfile_in  = (msg_HwEthBwProfile_t *) inbuffer->info;
-      bwProfile_out = (msg_HwEthBwProfile_t *) outbuffer->info;
-
-      memcpy(bwProfile_out,bwProfile_in,sizeof(msg_HwEthBwProfile_t));
-
-      /* Execute command */
-      rc = ptin_msg_bwProfile_get(bwProfile_out);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting BW profile");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_HwEthBwProfile_t));
-      break;  /* CCMSG_ETH_BW_PROFILE_GET */
-    }
-
-
-    /* CCMSG_ETH_BW_PROFILE_SET ***********************************************/
-    case CCMSG_ETH_BW_PROFILE_SET:
-    case CCMSG_ETH_BW_PROFILE_SET_II:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_BW_PROFILE_SET (0x%04X)", msgId);
-
-      if (CCMSG_ETH_BW_PROFILE_SET == msgId) CHECK_INFO_SIZE(msg_HwEthBwProfile_t)
-      else                                   CHECK_INFO_SIZE(msg_HwEthBwProfile_II_t)
-
-      msg_HwEthBwProfile_t *bwProfile;
-      bwProfile = (msg_HwEthBwProfile_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_bwProfile_set(bwProfile, msgId);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting BW profile");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_BW_PROFILE_SET */
-    }
-
-
-    /* CCMSG_ETH_BW_PROFILE_DELETE ********************************************/
-    case CCMSG_ETH_BW_PROFILE_DELETE:
-    case CCMSG_ETH_BW_PROFILE_DELETE_II:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_BW_PROFILE_DELETE (0x%04X)", msgId);
-
-      if (CCMSG_ETH_BW_PROFILE_DELETE == msgId) CHECK_INFO_SIZE(msg_HwEthBwProfile_t)
-      else                                      CHECK_INFO_SIZE(msg_HwEthBwProfile_II_t)
-
-      msg_HwEthBwProfile_t *bwProfile;
-      bwProfile = (msg_HwEthBwProfile_t *) inbuffer->info;
-
-      rc = ptin_msg_bwProfile_delete(bwProfile, msgId);
-
-      /* Execute command */
-      if ( L7_SUCCESS != rc )
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing BW profile");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_BW_PROFILE_DELETE */
-    }
-
-    /* CCMSG_ETH_STORM_CONTROL_GET ***********************************************/
-    case CCMSG_ETH_STORM_CONTROL_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthStormControl_t);
-
-      msg_HwEthStormControl_t *stormControl_in, *stormControl_out;
-      stormControl_in  = (msg_HwEthStormControl_t *) inbuffer->info;
-      stormControl_out = (msg_HwEthStormControl_t *) outbuffer->info;
-
-      memcpy(stormControl_out, stormControl_in, sizeof(msg_HwEthStormControl_t));
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_stormControl_get(stormControl_out))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting Storm Control profile");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_HwEthStormControl_t));
-      break;  /* CCMSG_ETH_STORM_CONTROL_GET */
-    }
-
-    /* CCMSG_ETH_STORM_CONTROL_SET ***********************************************/
-    case CCMSG_ETH_STORM_CONTROL_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthStormControl_t);
-
-      msg_HwEthStormControl_t *stormControl;
-      stormControl = (msg_HwEthStormControl_t *) inbuffer->info;
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_stormControl_set(stormControl))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting Storm Control profile");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_STORM_CONTROL_SET */
-    }
-
-    /* CCMSG_ETH_STORM_CONTROL_RESET *********************************************/
-    case CCMSG_ETH_STORM_CONTROL_RESET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_RESET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthStormControl_t);
-
-      msg_HwEthStormControl_t *stormControl;
-      stormControl = (msg_HwEthStormControl_t *) inbuffer->info;
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_stormControl_reset(stormControl))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while resetting Storm Control profile");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_STORM_CONTROL_RESET */
-    }
-
-    /* CCMSG_ETH_STORM_CONTROL_CLEAR ********************************************/
-    case CCMSG_ETH_STORM_CONTROL_CLEAR:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_CLEAR (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthStormControl_t);
-
-      msg_HwEthStormControl_t *stormControl;
-      stormControl = (msg_HwEthStormControl_t *) inbuffer->info;
-
-      rc = ptin_msg_stormControl_clear(stormControl);
-
-      /* Execute command */
-      if ( L7_SUCCESS != rc )
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing Storm Control profile");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_BW_PROFILE_DELETE */
-    }
-
-    /* CCMSG_ETH_STORMCONTROL2_GET ***********************************************/
-    case CCMSG_ETH_STORMCONTROL2_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORMCONTROL2_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthStormControl2_t);
-
-      msg_HwEthStormControl2_t *stormControl_in, *stormControl_out;
-      stormControl_in  = (msg_HwEthStormControl2_t *) inbuffer->info;
-      stormControl_out = (msg_HwEthStormControl2_t *) outbuffer->info;
-
-      memcpy(stormControl_out, stormControl_in, sizeof(msg_HwEthStormControl2_t));
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_stormControl2_get(stormControl_out))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting StormControl2 profile");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_HwEthStormControl2_t));
-      break;  /* CCMSG_ETH_STORMCONTROL2_GET */
-    }
-
-    /* CCMSG_ETH_STORMCONTROL2_SET ***********************************************/
-    case CCMSG_ETH_STORMCONTROL2_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORMCONTROL2_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthStormControl2_t);
-
-      msg_HwEthStormControl2_t *stormControl;
-      stormControl = (msg_HwEthStormControl2_t *) inbuffer->info;
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_stormControl2_set(stormControl))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting StormControl2 profile");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_STORMCONTROL2_SET */
-    }
-
-    /************************************************************************** 
-     * inBand Config
-     **************************************************************************/
-
-    /* CCMSG_ETH_NTW_CONNECTIVITY_GET *****************************************/
-    case CCMSG_ETH_NTW_CONNECTIVITY_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_NTW_CONNECTIVITY_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_NtwConnectivity_t);
-
-      msg_NtwConnectivity_t *ntwConn;
-      ntwConn = (msg_NtwConnectivity_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_NtwConnectivity_t));
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_ntw_connectivity_get(ntwConn))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting Network Connectivity config");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_NtwConnectivity_t));
-      break;  /* CCMSG_ETH_NTW_CONNECTIVITY_GET */
-    }
-
-    /* CCMSG_ETH_NTW_CONNECTIVITY_SET *****************************************/
-    case CCMSG_ETH_NTW_CONNECTIVITY_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_NTW_CONNECTIVITY_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_NtwConnectivity_t);
-
-      msg_NtwConnectivity_t *ntwConn;
-      ntwConn = (msg_NtwConnectivity_t *) inbuffer->info;
-
-      /* Execute command */
-      if (L7_SUCCESS != ptin_msg_ntw_connectivity_set(ntwConn))
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting Network Connectivity config");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_NTW_CONNECTIVITY_SET */
-    }
-
-    /************************************************************************** 
-     * DHCP Relay Agent
-     **************************************************************************/
-
-    /* Reconfigure Global DHCP EVC ****************************/
-    case CCMSG_ETH_DHCP_EVC_RECONF:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_EVC_RECONF (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_DhcpEvcReconf_t);
-
-      msg_DhcpEvcReconf_t *ptr;
-      ptr = (msg_DhcpEvcReconf_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_DhcpEvcReconf_t));
-
-      /* Execute command */
-      rc = ptin_msg_DHCP_evc_reconf(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_DhcpEvcReconf_t));
-    }
-    break;
-
-    /* Configure DHCP circuit-id global components ****************************/
-    case CCMSG_ETH_DHCP_EVC_CIRCUITID_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_EVC_CIRCUITID_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_AccessNodeCircuitId_t);
-
-      msg_AccessNodeCircuitId_t *ptr;
-      ptr = (msg_AccessNodeCircuitId_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_AccessNodeCircuitId_t));
-
-      /* Execute command */
-      rc = ptin_msg_DHCP_circuitid_set(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_AccessNodeCircuitId_t));
-    }
-    break;
-
-    /* Get DHCP profile data **************************************************/
-    case CCMSG_ETH_DHCP_EVC_CIRCUITID_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_AccessNodeCircuitId_t);
-
-      msg_AccessNodeCircuitId_t *ptr;
-      ptr = (msg_AccessNodeCircuitId_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_AccessNodeCircuitId_t));
-
-      /* Execute command */
-      rc = ptin_msg_DHCP_circuitid_get(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_AccessNodeCircuitId_t));
-    }
-    break;
-
-    /* Get DHCP profile data **************************************************/
-    case CCMSG_ETH_DHCP_PROFILE_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwEthernetDhcpOpt82Profile_t);
-
-      msg_HwEthernetDhcpOpt82Profile_t *ptr;
-      ptr = (msg_HwEthernetDhcpOpt82Profile_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwEthernetDhcpOpt82Profile_t));
-
-      /* Execute command */
-      rc = ptin_msg_DHCP_profile_get(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_HwEthernetDhcpOpt82Profile_t));
-    }
-    break;
-
-    /* Add a new DHCP profile **************************************************/
-    case CCMSG_ETH_DHCP_PROFILE_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HwEthernetDhcpOpt82Profile_t);
-
-      msg_HwEthernetDhcpOpt82Profile_t *ptr;
-      ptr = (msg_HwEthernetDhcpOpt82Profile_t *) inbuffer->info;
-      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_HwEthernetDhcpOpt82Profile_t));
-
-      /* Execute command */
-      rc = ptin_msg_DHCP_profile_add(ptr, n_clients);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Remove a DHCP profile ****************************************************/
-    case CCMSG_ETH_DHCP_PROFILE_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HwEthernetDhcpOpt82Profile_t);
-
-      msg_HwEthernetDhcpOpt82Profile_t *ptr;
-      ptr = (msg_HwEthernetDhcpOpt82Profile_t *) inbuffer->info;
-      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_HwEthernetDhcpOpt82Profile_t));
-
-      rc = ptin_msg_DHCP_profile_remove(ptr, n_clients);
-
-      /* Execute command */
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Get client DHCP statistics */
-    case CCMSG_ETH_DHCP_CLIENT_STATS_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_CLIENT_STATS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
-
-      msg_DhcpClientStatistics_t *ptr;
-      ptr = (msg_DhcpClientStatistics_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_DhcpClientStatistics_t));
-
-      /* Execute command */
-      rc = ptin_msg_DHCP_clientStats_get(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_DhcpClientStatistics_t));
-    }
-    break;
-
-    /* Clear client DHCP statistics */
-    case CCMSG_ETH_DHCP_CLIENT_STATS_CLEAR:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_CLIENT_STATS_CLEAR (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
-
-      msg_DhcpClientStatistics_t *ptr;
-      ptr = (msg_DhcpClientStatistics_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_DHCP_clientStats_clear(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Get interface DHCP statistics */
-    case CCMSG_ETH_DHCP_INTF_STATS_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_INTF_STATS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
-
-      msg_DhcpClientStatistics_t *ptr;
-      ptr = (msg_DhcpClientStatistics_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_DhcpClientStatistics_t));
-
-      /* Execute command */
-      rc = ptin_msg_DHCP_intfStats_get(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting statistics");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_DhcpClientStatistics_t));
-    }
-    break;
-
-    /* Clear interface DHCP statistics */
-    case CCMSG_ETH_DHCP_INTF_STATS_CLEAR:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_INTF_STATS_CLEAR (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
-
-      msg_DhcpClientStatistics_t *ptr;
-      ptr = (msg_DhcpClientStatistics_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_DHCP_intfStats_clear(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Get DHCP Bind Table */
-    case CCMSG_ETH_DHCP_BIND_TABLE_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_BIND_TABLE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_DHCP_bind_table_request_t);
-
-      msg_DHCP_bind_table_request_t *pin;
-      msg_DHCPv4v6_bind_table_t     *pout;
-      pin  = (msg_DHCP_bind_table_request_t*) inbuffer->info;
-      pout = (msg_DHCPv4v6_bind_table_t *) outbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_DHCPv4v6_bindTable_get(pin, pout);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_DHCPv4v6_bind_table_t));
-    }
-    break;
-
-    /* Remove a DHCP Bind Table entry */
-    case CCMSG_ETH_DHCP_BIND_TABLE_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_BIND_TABLE_CLEAR (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_DHCP_bind_table_entry_t);
-
-      msg_DHCP_bind_table_entry_t *bind_table;
-      bind_table = (msg_DHCP_bind_table_entry_t *) inbuffer->info;
-      L7_uint32 n = MSG_N_ELEMS(sizeof(msg_DHCP_bind_table_entry_t));
-
-      /* Execute command */
-      rc = ptin_msg_DHCP_bindTable_remove(bind_table, n);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-    /************************************************************************** 
-    *                     IP Source Guard
-    **************************************************************************/
-   
-    case CCMSG_ETH_IPSG_ENABLE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IPSG_ENABLE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_IPSG_set_t);
-
-      msg_IPSG_set_t *ptr;
-      ptr = (msg_IPSG_set_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_ipsg_verify_source_set(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while configuring IP Source Guard");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break; 
-    }
-    case CCMSG_ETH_IPSG_STATIC_ENTRY:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IPSG_VERIFY_SOURCE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_IPSG_static_entry_t);
-
-      L7_uint16 n_msg;
-      msg_IPSG_static_entry_t *ptr;
-      ptr = (msg_IPSG_static_entry_t *) inbuffer->info;
-      n_msg = MSG_N_ELEMS(sizeof(msg_IPSG_static_entry_t));
-
-      /* Execute command */
-      rc = ptin_msg_ipsg_static_entry_set(ptr, n_msg);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while configuring an IP Source Guard Static Entry");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break; 
-    }
-
-    /************************************************************************** 
-     * IGMP Admission Control Config
-     **************************************************************************/
-
-    /* CCMSG_ETH_IGMP_ADMISSION_CONTROL ***********************************************/
-    case CCMSG_ETH_IGMP_ADMISSION_CONTROL:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_ADMISSION_CONTROL (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_IgmpAdmissionControl_t);
-
-      msg_IgmpAdmissionControl_t *igmpAdmissionControl;
-      igmpAdmissionControl = (msg_IgmpAdmissionControl_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpAdmissionControl_t));
-
-      /* Execute command */
-      rc = ptin_msg_igmp_admission_control_set(igmpAdmissionControl);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting Igmp Admission Control Config");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_IGMP_PROXY_SET */
-    }
-
-    /************************************************************************** 
-     * IGMP Proxy Config
-     **************************************************************************/
-
-    /* CCMSG_ETH_IGMP_PROXY_SET ***********************************************/
-    case CCMSG_ETH_IGMP_PROXY_SET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_PROXY_SET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_IgmpProxyCfg_t);
-
-      msg_IgmpProxyCfg_t *igmpProxy;
-      igmpProxy = (msg_IgmpProxyCfg_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpProxyCfg_t));
-
-      /* Execute command */
-      rc = ptin_msg_igmp_proxy_set(igmpProxy);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting IGMP Proxy config");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_IGMP_PROXY_SET */
-    }
-
-
-    /* CCMSG_ETH_IGMP_PROXY_GET ***********************************************/
-    case CCMSG_ETH_IGMP_PROXY_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_PROXY_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_IgmpProxyCfg_t);
-
-      msg_IgmpProxyCfg_t *igmpProxy;
-      igmpProxy = (msg_IgmpProxyCfg_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_igmp_proxy_get(igmpProxy);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting IGMP proxy configuration");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_IGMP_PROXY_GET */
-    }
-
-
-    /* CCMSG_ETH_IGMP_ENTRY_ADD ***********************************************/
-    case CCMSG_ETH_IGMP_ENTRY_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_ENTRY_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_IgmpMultcastUnicastLink_t);
-
-      msg_IgmpMultcastUnicastLink_t *igmpEntry;
-      igmpEntry = (msg_IgmpMultcastUnicastLink_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_igmp_instance_add(igmpEntry);
-
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding an IGMP entry [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_IGMP_ENTRY_ADD */
-    }
-
-    /* CCMSG_ETH_IGMP_ENTRY_REMOVE ********************************************/
-    case CCMSG_ETH_IGMP_ENTRY_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_ENTRY_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_IgmpMultcastUnicastLink_t);
-
-      msg_IgmpMultcastUnicastLink_t *igmpEntry;
-      igmpEntry = (msg_IgmpMultcastUnicastLink_t *) inbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_igmp_instance_remove(igmpEntry);
-
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing an IGMP entry [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_IGMP_ENTRY_REMOVE */
-    }
-
-    /* CCMSG_ETH_IGMP_CLIENT_ADD **********************************************/
-    case CCMSG_ETH_IGMP_CLIENT_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_IgmpClient_t);
-
-      msg_IgmpClient_t *igmpClient;
-      igmpClient = (msg_IgmpClient_t *) inbuffer->info;
-      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClient_t));
-
-      /* Execute command */
-      rc = ptin_msg_igmp_client_add(igmpClient, n_clients);
-
-      if (L7_SUCCESS != rc)
-      {       
-       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding an IGMP client [res:0x%x]", res);
-       SetIPCNACK(outbuffer, res);
-       break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_IGMP_CLIENT_ADD */
-    }
-
-    /* CCMSG_ETH_IGMP_CLIENT_REMOVE *******************************************/
-    case CCMSG_ETH_IGMP_CLIENT_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_IgmpClient_t);
-
-      msg_IgmpClient_t *igmpClient;
-      igmpClient = (msg_IgmpClient_t *) inbuffer->info;
-      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClient_t));
-
-      rc = ptin_msg_igmp_client_delete(igmpClient, n_clients);
-
-      /* Execute command */
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing IGMP client [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_IGMP_CLIENT_REMOVE */
-    }
-
-    /* CCMSG_ETH_IGMP_CLIENT_STATS_GET ****************************************/
-    case CCMSG_ETH_IGMP_CLIENT_STATS_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_STATS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
-
-      msg_IgmpClientStatistics_t *igmpClientStats;
-      igmpClientStats = (msg_IgmpClientStatistics_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpClientStatistics_t));
-
-      /* Execute command */
-      rc = ptin_msg_IGMP_clientStats_get(igmpClientStats);
-
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting IGMP client statistics [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_IgmpClientStatistics_t));
-
-      break;  /* CCMSG_ETH_IGMP_CLIENT_STATS_GET */
-    }
-
-
-    /* CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR **************************************/
-    case CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
-
-      msg_IgmpClientStatistics_t *igmpClient;
-      igmpClient = (msg_IgmpClientStatistics_t *) inbuffer->info;
-      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClientStatistics_t));
-
-      /* Execute command */
-      rc = ptin_msg_IGMP_clientStats_clear(igmpClient, n_clients);
-
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing IGMP client statistics [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-      break;  /* CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR */
-    }
-
-    /* CCMSG_ETH_IGMP_INTF_STATS_GET ******************************************/
-    case CCMSG_ETH_IGMP_INTF_STATS_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_INTF_STATS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
-
-      msg_IgmpClientStatistics_t *igmpPortStats;
-      igmpPortStats = (msg_IgmpClientStatistics_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpClientStatistics_t));
-
-      /* Execute command */
-      rc = ptin_msg_IGMP_intfStats_get(igmpPortStats);
-
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting IGMP port statistics [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_IgmpClientStatistics_t));
-      break;  /* CCMSG_ETH_IGMP_INTF_STATS_GET */
-    }
-
-
-    /* CCMSG_ETH_IGMP_INTF_STATS_CLEAR ****************************************/
-    case CCMSG_ETH_IGMP_INTF_STATS_CLEAR:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_INTF_STATS_CLEAR (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
-
-      msg_IgmpClientStatistics_t *igmpIntf;
-      igmpIntf = (msg_IgmpClientStatistics_t *) inbuffer->info;
-      L7_uint32 n_ports = MSG_N_ELEMS(sizeof(msg_IgmpClientStatistics_t));
-
-      /* Execute command */
-      rc = ptin_msg_IGMP_intfStats_clear(igmpIntf, n_ports);
-
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing IGMP client statistics [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_ETH_IGMP_INTF_STATS_CLEAR */
-    }
-
-    case CCMSG_ETH_IGMP_CHANNEL_ASSOC_GET:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_MCAssocChannel_t);
-
-      msg_MCAssocChannel_t *ptr;
-      L7_uint16             n=0;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_MCAssocChannel_t));
-      ptr = (msg_MCAssocChannel_t *) outbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_IGMP_ChannelAssoc_get(ptr, &n);
-
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting MC channels [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_MCAssocChannel_t) * n);
-    }
-    break;
-
-    case CCMSG_ETH_IGMP_CHANNEL_ASSOC_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_MCAssocChannel_t);
-
-      msg_MCAssocChannel_t *ptr;
-      L7_uint16             n;
-
-      ptr = (msg_MCAssocChannel_t *) inbuffer->info;
-      n = MSG_N_ELEMS(sizeof(msg_MCAssocChannel_t));
-
-      /* Execute command */
-      rc  = ptin_msg_group_list_add(ptr, n, L7_FALSE);
-
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error adding MC channels [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    case CCMSG_ETH_IGMP_CHANNEL_ASSOC_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_MCAssocChannel_t);
-
-      msg_MCAssocChannel_t *ptr;
-      L7_uint16             n;
-
-      ptr = (msg_MCAssocChannel_t *) inbuffer->info;
-      n = MSG_N_ELEMS(sizeof(msg_MCAssocChannel_t));
-
-      /* Execute command */
-      rc  = ptin_msg_group_list_remove(ptr, n, L7_FALSE);
-
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error removing MC channels [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    case CCMSG_ETH_IGMP_CHANNEL_BULK_DELETE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_REMALL (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_MCAssocChannel_t);
-
-      msg_MCAssocChannel_t *ptr;
-      L7_uint16             n;
-
-      ptr = (msg_MCAssocChannel_t *) inbuffer->info;
-      n = MSG_N_ELEMS(sizeof(msg_MCAssocChannel_t));
-
-      /* Execute command */
-      rc  = ptin_msg_IGMP_ChannelAssoc_remove_all(ptr, n);
-
-      if (L7_SUCCESS != rc)
-      {        
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error removing MC channels [res:0x%x]", res);
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Add static multicast channel */
-    case CCMSG_ETH_IGMP_STATIC_GROUP_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_STATIC_GROUP_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_MCStaticChannel_t);
-
-      msg_MCStaticChannel_t *ptr;
-      L7_uint16             n;
-
-      ptr = (msg_MCStaticChannel_t *) inbuffer->info;
-      n = MSG_N_ELEMS(sizeof(msg_MCStaticChannel_t));
-
-      /* Execute command */
-      rc  = ptin_msg_static_channel_add(ptr, n);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Remove static multicast channel */
-    case CCMSG_ETH_IGMP_STATIC_GROUP_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_STATIC_GROUP_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_MCStaticChannel_t);
-
-      msg_MCStaticChannel_t *ptr;
-      L7_uint16             n;
-
-      ptr = (msg_MCStaticChannel_t *) inbuffer->info;
-      n = MSG_N_ELEMS(sizeof(msg_MCStaticChannel_t));
-
-      /* Execute command */
-      rc = ptin_msg_static_channel_remove(ptr, n);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Get list of multicast channels */
-    case CCMSG_ETH_IGMP_GROUPS_GET:
-    {      
-      msg_MCActiveChannelsRequest_t *inputPtr;
-      msg_MCActiveChannelsReply_t   *outputPtr;
-      L7_uint16                     numberOfChannels;
-
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_GROUPS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_MCActiveChannelsRequest_t);
-
-      inputPtr         = (msg_MCActiveChannelsRequest_t *) inbuffer->info;
-      outputPtr        = (msg_MCActiveChannelsReply_t *)   outbuffer->info;
-      numberOfChannels =  IPCLIB_MAX_MSGSIZE/sizeof(msg_MCActiveChannelsReply_t); //IPC buffer size / struct size
-
-      /* Execute command */
-      ptin_timer_start(40,"CCMSG_ETH_IGMP_GROUPS_GET");
-      rc = ptin_msg_IGMP_channelList_get(inputPtr, outputPtr, &numberOfChannels);
-      ptin_timer_stop(40);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      outbuffer->infoDim = numberOfChannels * sizeof(msg_MCActiveChannelsReply_t);       
-    }
-    break;
-
-    /* Get list of clients watching a multicast channel */
-    case CCMSG_ETH_IGMP_CLIENT_GROUPS_GET:
-    {      
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER,
-                  "Message received: CCMSG_ETH_IGMP_CLIENT_GROUPS_GET (0x%04X) msgSize:%u bytes", msgId, infoDim);
-
-      #if 1//To be changed to 0
-      CHECK_INFO_SIZE_ATLEAST(msg_MCActiveChannelClientsRequest_t);
-      #else
-      CHECK_INFO_SIZE(msg_MCActiveChannelClientsRequest_t);
-      #endif
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_MCActiveChannelClientsRequest_t));
-
-      msg_MCActiveChannelClientsResponse_t *ptr;
-      ptr = (msg_MCActiveChannelClientsResponse_t *) outbuffer->info;
-
-      /* Execute command */
-      ptin_timer_start(41,"CCMSG_ETH_IGMP_CLIENT_GROUPS_GET");
-      rc = ptin_msg_IGMP_clientList_get(ptr);
-      ptin_timer_stop(41);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_MCActiveChannelClientsResponse_t));
-    }
-    break;
-
-    /* Remove static multicast channel */
-    case CCMSG_ETH_IGMP_STATIC_GROUP_REMALL:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_STATIC_GROUP_REMALL (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_MCStaticChannel_t);
-
-      msg_MCStaticChannel_t *ptr;
-      L7_uint16             n;
-
-      ptr = (msg_MCStaticChannel_t *) inbuffer->info;
-      n = MSG_N_ELEMS(sizeof(msg_MCStaticChannel_t));
-
-      /* Execute command */
-      rc = ptin_msg_igmp_static_channel_remove_all(ptr, n);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-    
-    /* Request Snoop Sync between different cards/interfaces*/
-    case CCMSG_MGMD_SNOOP_SYNC_REQUEST:
-    {      
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MGMD_SNOOP_SYNC_REQUEST (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_SnoopSyncRequest_t);
-         
-      /* Execute command */
-      ptin_timer_start(42,"CCMSG_MGMD_SNOOP_SYNC_REQUEST");
-      rc = ptin_msg_snoop_sync_request((msg_SnoopSyncRequest_t *) inbuffer->info);
-      ptin_timer_stop(42);
-      if (L7_SUCCESS != rc)
-      {
-        SETIPCACKOK(outbuffer);
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Request Snoop Sync between different cards/interfaces*/
-    case CCMSG_MGMD_SNOOP_SYNC_REPLY:
-    {          
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MGMD_SNOOP_SYNC_REPLY (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_SnoopSyncReply_t);
-
-      /* Execute command */
-      ptin_timer_start(43,"CCMSG_MGMD_SNOOP_SYNC_REPLY");
-      rc = ptin_msg_snoop_sync_reply((msg_SnoopSyncReply_t *) inbuffer->info, MSG_N_ELEMS(sizeof(msg_SnoopSyncReply_t)));
-      ptin_timer_stop(43);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-      
-    }
-    break;
-
-    /***************************************************** 
-     * Routing messages
-     ****************************************************/
-    /* CCMSG_ROUTING_INTF_CREATE ****************************************/
-    case CCMSG_ROUTING_INTF_CREATE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_INTF_CREATE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingIntf);
-
-      msg_RoutingIntf *data;
-      data = (msg_RoutingIntf *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingIntf));
-
-      /* Execute command */
-      rc = ptin_msg_routing_intf_create(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingIntf));
-      break;
-    }
-
-    /* CCMSG_ROUTING_INTF_MODIFY ****************************************/
-    case CCMSG_ROUTING_INTF_MODIFY:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_INTF_MODIFY (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingIntf);
-
-      msg_RoutingIntf *data;
-      data = (msg_RoutingIntf *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingIntf));
-
-      /* Execute command */
-      rc = ptin_msg_routing_intf_modify(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingIntf));
-      break;
-    }
-
-    /* CCMSG_ROUTING_INTF_REMOVE ****************************************/
-    case CCMSG_ROUTING_INTF_REMOVE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_INTF_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingIntf);
-
-      msg_RoutingIntf *data;
-      data = (msg_RoutingIntf *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingIntf));
-
-      /* Execute command */
-      rc = ptin_msg_routing_intf_remove(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingIntf));
-      break;
-    }
-
-    /* CCMSG_ROUTING_ARPTABLE_GET ****************************************/
-    case CCMSG_ROUTING_ARPTABLE_GET:
-    {
-      msg_RoutingArpTableRequest  *inputPtr;
-      msg_RoutingArpTableResponse *outputPtr;
-      L7_uint32                   readEntries;
-
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_ARPTABLE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingArpTableRequest);
-
-      inputPtr   = (msg_RoutingArpTableRequest *)  inbuffer->info;
-      outputPtr  = (msg_RoutingArpTableResponse *) outbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_routing_arptable_get(inputPtr, outputPtr, &readEntries);
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      outbuffer->infoDim = readEntries * sizeof(msg_RoutingArpTableResponse);
-         
-      break;    
-    }
-
-    /* CCMSG_ROUTING_ARPENTRY_PURGE ****************************************/
-    case CCMSG_ROUTING_ARPENTRY_PURGE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_ARPENTRY_PURGE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingArpEntryPurge);
-
-      msg_RoutingArpEntryPurge *data;
-      data = (msg_RoutingArpEntryPurge *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingArpEntryPurge));
-
-      /* Execute command */
-      rc = ptin_msg_routing_arpentry_purge(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingArpEntryPurge));
-      break;
-    }
-
-    /* CCMSG_ROUTING_ROUTETABLE_GET ****************************************/
-    case CCMSG_ROUTING_ROUTETABLE_GET:
-    {
-      msg_RoutingRouteTableRequest  *inputPtr;
-      msg_RoutingRouteTableResponse *outputPtr;
-      L7_uint32                      maxEntries;
-      L7_uint32                      readEntries;
-
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_ROUTETABLE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingRouteTableRequest);
-
-      inputPtr   = (msg_RoutingRouteTableRequest *)  inbuffer->info;
-      outputPtr  = (msg_RoutingRouteTableResponse *) outbuffer->info;
-      maxEntries = IPCLIB_MAX_MSGSIZE/sizeof(msg_RoutingRouteTableResponse); //IPC buffer size / struct size
-
-      /* Execute command */
-      rc = ptin_msg_routing_routetable_get(inputPtr, outputPtr, maxEntries, &readEntries);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      outbuffer->infoDim = readEntries * sizeof(msg_RoutingRouteTableResponse);
-         
-      break;    
-    }
-
-    /* CCMSG_ROUTING_STATICROUTE_ADD ****************************************/
-    case CCMSG_ROUTING_STATICROUTE_ADD:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_STATICROUTE_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingStaticRoute);
-
-      msg_RoutingStaticRoute *data;
-      data = (msg_RoutingStaticRoute *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingStaticRoute));
-
-      /* Execute command */
-      rc = ptin_msg_routing_staticroute_add(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingStaticRoute));
-      break;
-    }
-
-    /* CCMSG_ROUTING_STATICROUTE_DELETE ****************************************/
-    case CCMSG_ROUTING_STATICROUTE_DELETE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_STATICROUTE_DELETE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingStaticRoute);
-
-      msg_RoutingStaticRoute *data;
-      data = (msg_RoutingStaticRoute *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingStaticRoute));
-
-      /* Execute command */
-      rc = ptin_msg_routing_staticroute_delete(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingStaticRoute));
-      break;
-    }
-
-    /* CCMSG_ROUTING_PINGSESSION_CREATE ****************************************/
-    case CCMSG_ROUTING_PINGSESSION_CREATE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_PINGSESSION_CREATE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingPingSessionCreate);
-
-      msg_RoutingPingSessionCreate *data;
-      data = (msg_RoutingPingSessionCreate *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingPingSessionCreate));
-
-      /* Execute command */
-      rc = ptin_msg_routing_pingsession_create(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingPingSessionCreate));
-      break;
-    }
-
-    /* CCMSG_ROUTING_PINGSESSION_QUERY ****************************************/
-    case CCMSG_ROUTING_PINGSESSION_QUERY:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_PINGSESSION_QUERY (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingPingSessionQuery);
-
-      msg_RoutingPingSessionQuery *data;
-      data = (msg_RoutingPingSessionQuery *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingPingSessionQuery));
-
-      /* Execute command */
-      rc = ptin_msg_routing_pingsession_query(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingPingSessionQuery));
-      break;
-    }
-
-    /* CCMSG_ROUTING_PINGSESSION_FREE ****************************************/
-    case CCMSG_ROUTING_PINGSESSION_FREE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_PINGSESSION_FREE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingPingSessionFree);
-
-      msg_RoutingPingSessionFree *data;
-      data = (msg_RoutingPingSessionFree *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingPingSessionFree));
-
-      /* Execute command */
-      rc = ptin_msg_routing_pingsession_free(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingPingSessionFree));
-      break;
-    }
-
-    /* CCMSG_ROUTING_TRACERTSESSION_CREATE ****************************************/
-    case CCMSG_ROUTING_TRACERTSESSION_CREATE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_TRACERTSESSION_CREATE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingTracertSessionCreate);
-
-      msg_RoutingTracertSessionCreate *data;
-      data = (msg_RoutingTracertSessionCreate *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingTracertSessionCreate));
-
-      /* Execute command */
-      rc = ptin_msg_routing_tracertsession_create(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingTracertSessionCreate));
-      break;
-    }
-
-    /* CCMSG_ROUTING_TRACERTSESSION_QUERY ****************************************/
-    case CCMSG_ROUTING_TRACERTSESSION_QUERY:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_TRACERTSESSION_QUERY (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingTracertSessionQuery);
-
-      msg_RoutingTracertSessionQuery *data;
-      data = (msg_RoutingTracertSessionQuery *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingTracertSessionQuery));
-
-      /* Execute command */
-      rc = ptin_msg_routing_tracertsession_query(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingTracertSessionQuery));
-      break;
-    }
-
-    /* CCMSG_ROUTING_TRACERTSESSION_GETHOPS ****************************************/
-    case CCMSG_ROUTING_TRACERTSESSION_GETHOPS:
-    {
-      msg_RoutingTracertSessionHopsRequest  *inputPtr;
-      msg_RoutingTracertSessionHopsResponse *outputPtr;
-      L7_uint32                              maxEntries;
-      L7_uint32                              readEntries;
-
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_TRACERTSESSION_GETHOPS (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_RoutingTracertSessionHopsRequest);
-
-      inputPtr   = (msg_RoutingTracertSessionHopsRequest *)  inbuffer->info;
-      outputPtr  = (msg_RoutingTracertSessionHopsResponse *) outbuffer->info;
-      maxEntries = IPCLIB_MAX_MSGSIZE/sizeof(msg_RoutingTracertSessionHopsResponse); //IPC buffer size / struct size
-
-      /* Execute command */
-      rc = ptin_msg_routing_tracertsession_gethops(inputPtr, outputPtr, maxEntries, &readEntries);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      outbuffer->infoDim = readEntries * sizeof(msg_RoutingTracertSessionHopsResponse);
-         
-      break;    
-    }
-
-    /* CCMSG_ROUTING_TRACERTSESSION_FREE ****************************************/
-    case CCMSG_ROUTING_TRACERTSESSION_FREE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_TRACERTSESSION_FREE (0x%04X)", CCMSG_ROUTING_TRACERTSESSION_FREE);
-
-      CHECK_INFO_SIZE(msg_RoutingTracertSessionFree);
-
-      msg_RoutingTracertSessionFree *data;
-      data = (msg_RoutingTracertSessionFree *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingTracertSessionFree));
-
-      /* Execute command */
-      rc = ptin_msg_routing_tracertsession_free(data);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_RoutingTracertSessionFree));
-      break;
-    }
-
-        /* Set PRBS mode */
-    case CCMSG_ETH_PCS_PRBS_ENABLE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PCS_PRBS_ENABLE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_ptin_pcs_prbs);
-
-      msg_ptin_pcs_prbs *ptr;
-      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_pcs_prbs));
-
-      ptr = (msg_ptin_pcs_prbs *) inbuffer->info;
-
-      /* Execute command */
-      rc  = ptin_msg_pcs_prbs_enable(ptr,n);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Get PRBS status */
-    case CCMSG_ETH_PCS_PRBS_STATUS:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PCS_PRBS_STATUS (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_ptin_pcs_prbs);
-
-      msg_ptin_pcs_prbs *ptr;
-      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_pcs_prbs));
-
-      ptr = (msg_ptin_pcs_prbs *) outbuffer->info;
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_ptin_pcs_prbs)*n);
-
-      /* Execute command */
-      rc = ptin_msg_pcs_prbs_status(ptr,n);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_ptin_pcs_prbs) * n);
-    }
-    break;
-
-    /* Set PRBS mode */
-    case CCMSG_ETH_PRBS_ENABLE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PRBS_ENABLE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_ptin_prbs_enable);
-
-      msg_ptin_prbs_enable *ptr;
-      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_prbs_enable));
-
-      ptr = (msg_ptin_prbs_enable *) inbuffer->info;
-
-      /* Execute command */
-      rc  = ptin_msg_prbs_enable(ptr,n);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /* Get PRBS status */
-    case CCMSG_ETH_PRBS_STATUS:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PRBS_STATUS (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_ptin_prbs_request);
-
-      msg_ptin_prbs_request *ptr_in;
-      msg_ptin_prbs_status  *ptr_out;
-      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_prbs_request));
-
-      ptr_in  = (msg_ptin_prbs_request *) inbuffer->info;
-      ptr_out = (msg_ptin_prbs_status  *) outbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_prbs_status(ptr_in, ptr_out, &n);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_ptin_prbs_status) * n);
-    }
-    break;
-
-
-    /************************************************************************** 
-     * OAM MEPs Configuration
-     **************************************************************************/
-#ifdef __Y1731_802_1ag_OAM_ETH__
-    case CCMSG_WR_MEP:
-    case CCMSG_FLUSH_MEP:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_WR_MEP/CCMSG_FLUSH_MEP (0x%04X)", msgId);
-    
-      CHECK_INFO_SIZE_MOD(msg_bd_mep_t);
-
-      rc = ptin_msg_wr_MEP(inbuffer, outbuffer, 0);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-    
-      break;
-    case CCMSG_RM_MEP:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_RM_MEP (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_bd_mep_t);
-
-      rc = ptin_msg_del_MEP(inbuffer, outbuffer, 0);
-
-      if (L7_SUCCESS != rc) {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;
-    case CCMSG_WR_RMEP:
-    case CCMSG_FLUSH_RMEP:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_WR_RMEP/CCMSG_FLUSH_RMEP (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_bd_rmep_t);
-
-      rc = ptin_msg_wr_RMEP(inbuffer, outbuffer, 0);
-
-      if (L7_SUCCESS != rc) {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;
-    case CCMSG_RM_RMEP:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_RM_RMEP (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_bd_rmep_t);
-
-      rc = ptin_msg_del_RMEP(inbuffer, outbuffer, 0);
-
-      if (L7_SUCCESS != rc) {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;
-    case CCMSG_DUMP_MEPs:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_DUMP_MEPs (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_generic_prefix_t);
-
-      rc = ptin_msg_dump_MEPs(inbuffer, outbuffer);
-      if (L7_SUCCESS != rc) {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-
-      break;
-
-    case CCMSG_DUMP_MEs:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_DUMP_MEs (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_bd_me_t);
-
-      rc = ptin_msg_dump_MEs(inbuffer, outbuffer);
-
-      if (L7_SUCCESS != rc) {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-
-      break;
-
-    case CCMSG_DUMP_LUT_MEPs:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_DUMP_LUT_MEPs (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_generic_prefix_t);
-
-      rc = ptin_msg_dump_LUT_MEPs(inbuffer, outbuffer);
-
-      if (L7_SUCCESS != rc) {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-
-      break;
-
-    case CCMSG_WR_MIP:
-    case CCMSG_RM_MIP:
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER,
-                    CCMSG_WR_MIP==msgId? "Message received: CCMSG_WR_MIP (0x%04X)"
-                                       : "Message received: CCMSG_RM_MIP (0x%04X)", msgId);
-
-        CHECK_INFO_SIZE_MOD(msg_bd_mip_t);
-
-        if (CCMSG_WR_MIP==msgId)    rc = ptin_msg_wr_MIP(inbuffer, outbuffer, 0);
-        else                        rc = ptin_msg_del_MIP(inbuffer, outbuffer, 0);
-
-        if (L7_SUCCESS != rc) {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPCACKOK(outbuffer);
-        break;
-
-
-    case CCMSG_WR_MEP_LM:
-    case CCMSG_RM_MEP_LM:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER,
-                  CCMSG_WR_MEP_LM == msgId? "Message received: CCMSG_WR_MEP_LM (0x%04X)":
-                                            "Message received: CCMSG_RM_MEP_LM (0x%04X)", msgId);
-    
-      CHECK_INFO_SIZE(msg_bd_mep_lm_t);
-    
-#if MNGMT_DIFFERENT_ENDIANNESS
-      {
-       msg_bd_mep_lm_t *p;
-
-       p = (msg_bd_mep_lm_t*)inbuffer->info;
-
-       p->idx = ENDIAN_SWAP32(p->idx);
-       p->port = ENDIAN_SWAP32(p->port);
-      }
-#endif
-
-      if (CCMSG_RM_MEP_LM == msgId) {
-          rc = del_mep_lm(((msg_bd_mep_lm_t*)inbuffer->info)->idx, &oam)? L7_FAILURE: L7_SUCCESS;
-      }
-      else {
-       msg_bd_mep_lm_t *p;
-       
-       p = (msg_bd_mep_lm_t*)inbuffer->info;
-
-       if (0==p->type) rc = L7_NOT_SUPPORTED;
-       else {
-        T_MEP_LM mep_lm;
-
-        mep_lm.CCMs0_LMMR1 =    p->type;
-        mep_lm.period =         p->lmmPeriod;
-    
-        switch (wr_mep_lm(p->idx, &mep_lm, &oam)) {
-        case 0: rc = L7_SUCCESS; break;
-        case 1: rc = L7_NOT_EXIST; break;
-        default: rc = L7_ERROR; break;
-        }//switch
-       }
-      }
-    
-      if (L7_SUCCESS != rc) {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;
-
-    case CCMSG_RD_MEP_LM:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_RD_MEP_LM (0x%04X)", msgId);
-  
-      CHECK_INFO_SIZE(msg_generic_prefix_t);
-  
-      {
-        msg_generic_prefix_t *pi;
-        msg_frame_loss_t *po;
-        u16 i_mep;
-        u8  instance;
-  
-        pi = (msg_generic_prefix_t*)inbuffer->info;
-
-#if MNGMT_DIFFERENT_ENDIANNESS
-        pi->index = ENDIAN_SWAP64(pi->index);
-#endif
-
-        i_mep = pi->index;
-        instance = pi->index>>16;
-
-        po = (msg_frame_loss_t*)outbuffer->info;
-        SETIPC_INFODIM(sizeof(msg_frame_loss_t));
-        po->err_code = 0;
-
-        if (i_mep>=N_MEPs) rc = L7_NOT_EXIST;
-        else
-        switch (instance) {
-        case 0:
-            LM_medium(&oam.db[i_mep].lm, &po->NEnumerator, &po->NEdenominator, &po->FEnumerator, &po->FEdenominator);
-            rc = L7_SUCCESS;
-            break;
-        case 1:
-            LM_last_period(&oam.db[i_mep].lm, &po->NEnumerator, &po->NEdenominator, &po->FEnumerator, &po->FEdenominator);
-            rc = L7_SUCCESS;
-            break;
-        default: rc = L7_ERROR; break;
-        }//switch
-  
-        if (L7_SUCCESS != rc) {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-#if MNGMT_DIFFERENT_ENDIANNESS
-        else {
-            po->err_code = ENDIAN_SWAP32(po->err_code);
-            po->NEnumerator = ENDIAN_SWAP64(po->NEnumerator);
-            po->NEdenominator = ENDIAN_SWAP64(po->NEdenominator);
-            po->FEnumerator = ENDIAN_SWAP64(po->FEnumerator);
-            po->FEdenominator = ENDIAN_SWAP64(po->FEdenominator);
-        }
-#endif
-      }
-  
-      break;
-
-    case CHMSG_CCM_MEP_FRAMELOSS:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_CCM_MEP_FRAMELOSS (0x%04X)", msgId); 
-      {
-        MSG_FRAMELOSS_status *pi;
-        MSG_FRAMELOSS_status *po;
-        u16 i_mep;
-  
-        if (infoDim < offsetof(MSG_FRAMELOSS_status, idx)+sizeof(pi->idx)) {
-            SetIPCNACK(outbuffer, SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE));
-            break;
-        }
-        //CHECK_INFO_SIZE(MSG_FRAMELOSS_status);
-
-
-        pi = (MSG_FRAMELOSS_status*)inbuffer->info;
-#if MNGMT_DIFFERENT_ENDIANNESS
-        pi->idx = ENDIAN_SWAP32(pi->idx);
-        //pi->port = ENDIAN_SWAP32(pi->port);
-#endif
-        i_mep = pi->idx;
-
-        po = (MSG_FRAMELOSS_status*)outbuffer->info;
-        SETIPC_INFODIM(sizeof(MSG_FRAMELOSS_status));
-
-        if (i_mep>=N_MEPs) rc = L7_NOT_EXIST;
-        else {
-            //LM_medium(&oam.db[i_mep].lm, &po->Delta_LM_rx_i, &po->Delta_LM_tx_i, &po->Delta_LM_rx_e, &po->Delta_LM_tx_e);
-            LM_last_period(&oam.db[i_mep].lm, &po->Delta_LM_rx_i, &po->Delta_LM_tx_i, &po->Delta_LM_rx_e, &po->Delta_LM_tx_e);
-            po->Delta_LM_rx_i = diff_LM_counters(po->Delta_LM_tx_i, po->Delta_LM_rx_i);
-            po->Delta_LM_rx_e = diff_LM_counters(po->Delta_LM_tx_e, po->Delta_LM_rx_e);
-            rc = L7_SUCCESS;
-        }
-
-        if (L7_SUCCESS != rc) {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-#if MNGMT_DIFFERENT_ENDIANNESS
-        else {
-            //po->idx = ENDIAN_SWAP32(pi->idx); //ENDIAN_SWAP32(po->idx);
-            //po->port = ENDIAN_SWAP32(po->port);
-            po->mask = ENDIAN_SWAP32(po->mask);
-            po->Delta_LM_tx_e = ENDIAN_SWAP64(po->Delta_LM_tx_e);
-            po->Delta_LM_rx_e = ENDIAN_SWAP64(po->Delta_LM_rx_e);
-            po->Delta_LM_tx_i = ENDIAN_SWAP64(po->Delta_LM_tx_i);
-            po->Delta_LM_rx_i = ENDIAN_SWAP64(po->Delta_LM_rx_i);
-        }
-#endif
-      }
-  
-      break;
-
-
-    case CCMSG_WR_MEP_DM:
-    case CCMSG_RM_MEP_DM:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER,
-                  CCMSG_WR_MEP_DM == msgId? "Message received: CCMSG_WR_MEP_DM (0x%04X)":
-                                            "Message received: CCMSG_RM_MEP_DM (0x%04X)", msgId);
-      CHECK_INFO_SIZE(msg_bd_mep_dm_t);
-
-      if (CCMSG_RM_MEP_DM == msgId) {
-          rc = del_mep_dm(((msg_bd_mep_dm_t*)inbuffer->info)->idx, &oam)? L7_FAILURE: L7_SUCCESS;
-      }
-      else {
-       msg_bd_mep_dm_t *p;
-
-       p = (msg_bd_mep_dm_t*)inbuffer->info;
-
-       if (0==p->packet_number) rc = L7_NOT_EXIST;
-       else {
-        T_MEP_DM mep_dm;
-
-        mep_dm.n_frames =          p->packet_number;
-        mep_dm.period =            p->period;
-        mep_dm.oam_datagrm_len =   p->packet_size;
-//        mep_dm.dmmCosColor =         p->dmmCosColor;
-
-        switch (wr_mep_dm(p->idx, &mep_dm, &oam)) {
-			case 0: rc = L7_SUCCESS; break;
-			case 1: rc = L7_NOT_EXIST; break;
-			default: rc = L7_ERROR; break;
-        }//switch
-       }
-      }
-
-      if (L7_SUCCESS != rc) {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;
-
-    case CHMSG_CCM_MEP_FRAMEDELAY:
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_CCM_MEP_FRAMEDELAY (0x%04X)", msgId);
-      {
-        MSG_FRAMEDELAY_status *pi;
-        MSG_FRAMEDELAY_status *po;
-        u16 i_mep;
-
-        if (infoDim < offsetof(MSG_FRAMEDELAY_status, idx)+sizeof(pi->idx)) {
-            SetIPCNACK(outbuffer, SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE));
-            break;
-        }
-        //CHECK_INFO_SIZE(MSG_FRAMEDELAY_status);
-
-
-        pi = (MSG_FRAMEDELAY_status*)inbuffer->info;
-        i_mep = pi->idx;
-
-        po = (MSG_FRAMEDELAY_status*)outbuffer->info;
-        SETIPC_INFODIM(sizeof(MSG_FRAMEDELAY_status));
-
-        if (i_mep>=N_MEPs) rc = L7_NOT_EXIST;
-        else {
-
-//            DM_2way_frame_delay(&oam.db[i_mep].dm, &oam.db[i_mep].dm);
-        	//????
-            po->DM_Max           = oam.db[i_mep].dm.fd_max;
-            po->DM_Min           = oam.db[i_mep].dm.fd_min;
-            po->DM_Total         = oam.db[i_mep].dm.fd_sum;
-            po->DM_packet_number = oam.db[i_mep].dm.n_frames;
-            rc = L7_SUCCESS;
-        }
-      }
-
-      if (L7_SUCCESS != rc) {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-
-      break;
-
-
-#endif //__Y1731_802_1ag_OAM_ETH__
-
-    /************************************************************************** 
-    * ERPS Configuration
-    **************************************************************************/
-
-    case CCMSG_ERPS_SET:
-      {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_SET (0x%04X)", msgId);
-    
-      CHECK_INFO_SIZE_MOD(msg_erps_t);
-
-      msg_erps_t *ptr;
-      ptr = (msg_erps_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_t));
-
-      /* Execute command */
-      rc = ptin_msg_erps_set(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-      }
-      break;
-
-    case CCMSG_ERPS_DEL:
-      {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_DEL (0x%04X)", msgId);
-    
-      CHECK_INFO_SIZE_MOD(msg_erps_t);
-
-      msg_erps_t *ptr;
-      ptr = (msg_erps_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_t));
-
-      /* Execute command */
-      rc = ptin_msg_erps_del(ptr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-      }
-      break;
-
-    case CCMSG_ERPS_CONF:
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_CONF (0x%04X)", msgId);
-      
-        CHECK_INFO_SIZE_MOD(msg_erps_t);
-
-        msg_erps_t *ptr;
-        ptr = (msg_erps_t *) outbuffer->info;
-
-        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_t));
-
-        /* Execute command */
-        rc = ptin_msg_erps_config(ptr);
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPCACKOK(outbuffer);        
-      }
-      break;
-
-    case CCMSG_ERPS_STATUS:
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_STATUS (0x%04X)", msgId);
-      
-        CHECK_INFO_SIZE_MOD(msg_erps_status_t);
-
-        msg_erps_status_t *ptr;
-        ptr = (msg_erps_status_t *) outbuffer->info;
-
-        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_status_t));
-
-        /* Execute command */
-        rc = ptin_msg_erps_status(ptr);
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPC_INFODIM(sizeof(msg_erps_status_t));
-      }
-      break;
-
-    case CCMSG_ERPS_STATUS_NEXT:
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_STATUS_NEXT (0x%04X)", msgId);
-      
-        CHECK_INFO_SIZE_MOD(msg_erps_status_t);
-
-        msg_erps_status_t *ptr;
-        L7_int            n;
-
-        ptr = (msg_erps_status_t *) outbuffer->info;
-
-        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_status_t));
-
-        /* Execute command */
-        rc = ptin_msg_erps_status_next(ptr, &n);
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPC_INFODIM(sizeof(msg_erps_status_t) * n);
-      }
-      break;
-
-    case CCMSG_ERPS_OPERATOR_CMD:
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_OPERATOR_CMD (0x%04X)", msgId);
-      
-        CHECK_INFO_SIZE_MOD(msg_erps_cmd_t);
-
-        msg_erps_cmd_t *ptr;
-
-        ptr = (msg_erps_cmd_t *) outbuffer->info;
-
-        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_cmd_t));
-
-        /* Execute command */
-        rc = ptin_msg_erps_cmd(ptr);
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPCACKOK(outbuffer);        
-      }
-      break;
-
-    case CCMSG_ERPS_SYNC:
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_SYNC (0x%04X)", msgId);
-      
-        CHECK_INFO_SIZE_MOD(msg_erps_cmd_t);
-
-        msg_erps_cmd_t *ptr;
-
-        ptr = (msg_erps_cmd_t *) outbuffer->info;
-
-        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_cmd_t));
-
-        /* Execute command */
-        rc = ptin_msg_erps_cmd(ptr);
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPCACKOK(outbuffer);
-      }
-      break;
-
-
-    /************************************************************************** 
-    * ACL Configuration
-    **************************************************************************/
-
-    case CCMSG_ACL_RULE_ADD:
-    case CCMSG_ACL_RULE_DEL:
-      {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ACL_RULE_ADD/DEL (0x%04X)", msgId);
-    
-      #if 0
-      if (inbuffer->info[1] == ACL_TYPE_MAC)
-      {
-        CHECK_INFO_SIZE_MOD(msg_mac_acl_t);
-        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_mac_acl_t));
-      }
-      else if ( (inbuffer->info[1] == ACL_TYPE_IP_STANDARD) || (inbuffer->info[1] == ACL_TYPE_IP_EXTENDED) || (inbuffer->info[1] == ACL_TYPE_IP_NAMED) )
-      {
-        CHECK_INFO_SIZE_MOD(msg_ip_acl_t);
-        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_ip_acl_t)); 
-      }
-      else if (inbuffer->info[1] == ACL_TYPE_IPv6_EXTENDED)
-      {
-        CHECK_INFO_SIZE_MOD(msg_ipv6_acl_t);
-        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_ipv6_acl_t)); 
-      }
-      #endif
-
-      /* Execute command */
-      rc = ptin_msg_acl_rule_config((void *) inbuffer->info, msgId, infoDim);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-      }
-      break;
-
-    case CCMSG_ACL_APPLY:
-    case CCMSG_ACL_UNAPPLY:
-      {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ACL_APPLY/UNAPPLY (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_apply_acl_t);
-
-      /* Execute command */
-      rc = ptin_msg_acl_enable((msg_apply_acl_t *) inbuffer->info, msgId, MSG_N_ELEMS(sizeof(msg_apply_acl_t)));
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPCACKOK(outbuffer);
-      }
-      break;
-
-
-    case CCMSG_PORTMIRROR_SESSION_ADD:
-    case CCMSG_PORTMIRROR_SESSION_REMOVE:
-    case CCMSG_PORTMIRROR_PORT_ADD:
-    case CCMSG_PORTMIRROR_PORT_REMOVE:
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_PORTMIRROR (0x%04X)", msgId);
-
-        CHECK_INFO_SIZE_MOD(msg_port_mirror_t);
-
-        /* Execute command */
-        rc = ptin_msg_mirror(inbuffer, outbuffer);
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPCACKOK(outbuffer);
-      }
-      break;
-
-  #if (PTIN_BOARD_IS_MATRIX || PTIN_BOARD_IS_STANDALONE || (PTIN_BOARD == PTIN_BOARD_TA48GE))
-    case CCMSG_PTP_LNX_NET_IF_SET:
-      #if (PTIN_BOARD == PTIN_BOARD_OLT1T0)
-      if (!KERNEL_NODE_IS("OLT1T0-AC")) {
-        PT_LOG_WARN(LOG_CTX_MSGHANDLER, "Message not supported!"); 
-        SetIPCNACK (outbuffer, SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_WARNING, ERROR_CODE_NOSUCHMSG)); 
-      
-        rc = L7_FAILURE; 
-        break; 
-      }
-      #endif
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_PTP_LNX_NET_IF_SET (0x%04X)", msgId);
-
-        CHECK_INFO_SIZE_MOD(T_MSG_PTP_LNX_NET_IF_SET);
-
-        rc=ptin_msg_PTP_lnx_net_if_set(inbuffer, outbuffer);
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, rc);
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPCACKOK(outbuffer);
-      }
-      break;
-  #endif
-      
-    case CHMSG_RFC2819_MONITORING_GET_ONE_REG:
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_GET (0x%04X)", msgId);
-
-        CHECK_INFO_SIZE_MOD(msg_rfc2819_monitoring_t);
-
-        msg_rfc2819_monitoring_t *in_ptr;
-        msg_rfc2819_buffer_t *ptr;
-
-        ptr = (msg_rfc2819_buffer_t *) outbuffer->info;
-        in_ptr = (msg_rfc2819_monitoring_t *) inbuffer->info;
-
-        ENDIAN_SWAP32_MOD(in_ptr->n);
-        /* Execute command */
-        rc = ptin_msg_get_next_qualRFC2819(in_ptr->n, ptr);
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPC_INFODIM(sizeof(msg_rfc2819_buffer_t));
-      }
-      break;
-
-
-
-    case CHMSG_RFC2819_MONITORING_CONFIG:      
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_CONFIG (0x%04X)", msgId);
-
-        CHECK_INFO_SIZE_MOD(msg_rfc2819_admin_t);
-
-        msg_rfc2819_admin_t *ptr;
-
-        ptr = (msg_rfc2819_admin_t *)inbuffer->info;
-
-        /* Execute command */
-        rc = ptin_msg_config_rfc2819_monitoring(ptr);
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPCACKOK(outbuffer);
-      }
-     break;
-
-    case CHMSG_RFC2819_MONITORING_GET:
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_GET (0x%04X)", msgId);
-  
-        CHECK_INFO_SIZE_MOD(msg_rfc2819_monitoring_t);
-  
-        msg_rfc2819_buffer_t      *ptr;
-        msg_rfc2819_monitoring_t  *ptr_in;
-        L7_int                n;
-  
-        ptr     = (msg_rfc2819_buffer_t  *) outbuffer->info;
-        ptr_in  = (msg_rfc2819_monitoring_t * )inbuffer->info;
-
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "SlotID %d ", ptr_in->SlotId);
-        ENDIAN_SWAP32_MOD(ptr_in->n);
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "n %d ", ptr_in->n);
-                 
-        /* Execute command */
-        rc = ptin_msg_get_next_qualRFC2819_inv(ptr_in->n, ptr, &n);
-  
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-  
-        SETIPC_INFODIM(sizeof(msg_rfc2819_buffer_t) * n);
-      }
-      break;
-
-    case CHMSG_RFC2819_MONITORING_CLEAR:
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_CLEAR (0x%04X)", msgId);
-  
-        CHECK_INFO_SIZE_MOD(msg_rfc2819_monitoring_t);
-
-        msg_rfc2819_monitoring_t  *ptr_in;
-        msg_rfc2819_monitoring_t  *ptr_out;
-        ptr_in   = (msg_rfc2819_monitoring_t * )inbuffer->info;
-        ptr_out  = (msg_rfc2819_monitoring_t * )outbuffer->info;
-
-        /* Execute command */
-        ENDIAN_SWAP32_MOD(ptr_in->n);
-        rc = ptin_msg_clear_rfc2819_monitoring_buffer(ptr_in->n);
-  
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPCACKOK(outbuffer);
-      }
-      break;
-
-
-    case CHMSG_RFC2819_MONITORING_SHOW_CONF:
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_SHOW_CONF (0x%04X)", msgId);
-
-        L7_int Port;
-        L7_uint8 Admin;        
-        L7_uint32 *resp;        
-        CHECK_INFO_SIZE_MOD(L7_int);
-
-        Port = *((L7_uint32 *)inbuffer->info);
-        resp = (L7_uint32 *)outbuffer->info;
-
-        /* Execute command */
-        rc = ptin_msg_get_rfc2819_probe_config(Port, &Admin);
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        if (Admin==0) {
-          *resp = (Port & 0xFFFF);
-        }
-        else {
-          *resp = 0x80000000 | (Port & 0xFFFF);
-        }
-
-        SETIPC_INFODIM(sizeof(L7_uint32));
-      }
-      break;
-
-    case CHMSG_RFC2819_MONITORING_BUFF_STATUS:
-      {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_BUFF_STATUS (0x%04X)", msgId);
-
-        msg_rfc2819_buffer_status_t *status;
-        L7_int buffer_type;
-
-        status = (msg_rfc2819_buffer_status_t *) outbuffer->info;
-
-        CHECK_INFO_SIZE_MOD(L7_int);
-
-        buffer_type = *((L7_int *)inbuffer->info);
-
-        /* Execute command */
-        rc = ptin_msg_rfc2819_buffer_status(buffer_type, status);
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPC_INFODIM(sizeof(msg_rfc2819_buffer_status_t));
-      }
-      break;
-
-#ifdef __802_1x__
-    case CCMSG_WR_802_1X_ADMINMODE:
-    case CCMSG_WR_802_1X_TRACE:
-    case CCMSG_WR_802_1X_VLANASSGNMODE:
-    case CCMSG_WR_802_1X_MONMODE:
-    case CCMSG_WR_802_1X_DYNVLANMODE:
-      msg_generic_wrd(msg_wr_802_1x_Genrc, inbuffer, outbuffer, sizeof(msg_802_1x_Genrc), sizeof(msg_802_1x_Genrc));
-      break;
-
-    case CCMSG_WR_802_1X_ADMINCONTROLLEDDIRECTIONS:
-    case CCMSG_WR_802_1X_PORTCONTROLMODE:
-    case CCMSG_WR_802_1X_QUIETPERIOD:
-    case CCMSG_WR_802_1X_TXPERIOD:
-    case CCMSG_WR_802_1X_SUPPTIMEOUT:
-    case CCMSG_WR_802_1X_SERVERTIMEOUT:
-    case CCMSG_WR_802_1X_MAXREQ:
-    case CCMSG_WR_802_1X_REAUTHPERIOD:
-    case CCMSG_WR_802_1X_KEYTXENABLED:
-    case CCMSG_WR_802_1X_GUESTVLANID:
-    case CCMSG_WR_802_1X_GUSTVLANPERIOD:
-    case CCMSG_WR_802_1X_MAXUSERS:
-    case CCMSG_WR_802_1X_UNAUTHENTICATEDVLAN:
-      msg_generic_wrd(msg_wr_802_1x_Genrc2, inbuffer, outbuffer, sizeof(msg_802_1x_Genrc2), sizeof(msg_generic_prefix_t));
-      break;
-
-    case CCMSG_WR_802_1X_AUTHSERV:
-      msg_generic_wrd(msg_wr_802_1x_AuthServ, inbuffer, outbuffer, sizeof(msg_802_1x_AuthServ), sizeof(msg_generic_prefix_t));
-      break;
-#endif //__802_1x__
-
-/*****************************************Multicast Package Feature********************************************************/
-    /*Multicast Packages Add*/
-    case CCMSG_IGMP_PACKAGES_ADD:
-    {        
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGES_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_igmp_package_t);
-
-      msg_igmp_package_t *msgPtr;
-      msgPtr = (msg_igmp_package_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_igmp_package_t));
-
-      /* Execute command */
-      rc = ptin_msg_igmp_packages_add(msgPtr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_igmp_package_t));
-      break;/*Multicast Packages Add*/
-    }
-
-    /*Multicast Packages Remove*/
-    case CCMSG_IGMP_PACKAGES_REMOVE:
-    {        
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGES_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_igmp_package_t);
-
-      msg_igmp_package_t *msgPtr;
-      msgPtr = (msg_igmp_package_t *) outbuffer->info;
-
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_igmp_package_t));
-
-      /* Execute command */
-      rc = ptin_msg_igmp_packages_remove(msgPtr);
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      SETIPC_INFODIM(sizeof(msg_igmp_package_t));
-      break; /* CCMSG_IGMP_PACKAGES_REMOVE */
-    }
-
-    /*Multicast Package Channels Add*/
-    case CCMSG_IGMP_PACKAGE_CHANNELS_ADD:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGE_CHANNELS_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_igmp_package_channels_t);
-
-      msg_igmp_package_channels_t *msgPtr;
-      msgPtr = (msg_igmp_package_channels_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_package_channels_t));
-
-      /* Execute command */
-      rc = ptin_msg_igmp_package_channels_add(msgPtr, noOfMessages);
-
-      if (L7_SUCCESS != rc)
-      {       
-       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
-       SetIPCNACK(outbuffer, res);
-       break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_IGMP_PACKAGE_CHANNELS_ADD */
-    }
-
-    /*Multicast Package Channels Remove*/
-    case CCMSG_IGMP_PACKAGE_CHANNELS_REMOVE:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGE_CHANNELS_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_igmp_package_channels_t);
-
-      msg_igmp_package_channels_t *msgPtr;
-      msgPtr = (msg_igmp_package_channels_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_package_channels_t));
-
-      /* Execute command */
-      rc = ptin_msg_igmp_package_channels_remove(msgPtr, noOfMessages);
-
-      if (L7_SUCCESS != rc)
-      {       
-       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
-       SetIPCNACK(outbuffer, res);
-       break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_IGMP_PACKAGE_CHANNELS_REMOVE */
-    }
-
-    /*Igmp Unicast Client Packages Add*/
-    case CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_ADD:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_igmp_unicast_client_packages_t);
-
-      msg_igmp_unicast_client_packages_t *msgPtr;
-      msgPtr = (msg_igmp_unicast_client_packages_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_unicast_client_packages_t));
-
-      /* Execute command */      
-      rc = ptin_msg_igmp_unicast_client_packages_add(msgPtr, noOfMessages);
-      
-      if (L7_SUCCESS != rc)
-      {       
-       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
-       SetIPCNACK(outbuffer, res);
-       break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_ADD */
-    }
-
-    /*Igmp Unicast Client Packages Remove*/
-    case CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_igmp_unicast_client_packages_t);
-
-      msg_igmp_unicast_client_packages_t *msgPtr;
-      msgPtr = (msg_igmp_unicast_client_packages_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_unicast_client_packages_t));
-      
-      /* Execute command */      
-      rc = ptin_msg_igmp_unicast_client_packages_remove(msgPtr, noOfMessages);
-
-      if (L7_SUCCESS != rc)
-      {       
-       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing Channels from a Package [res:0x%x]", res);
-       SetIPCNACK(outbuffer, res);
-       break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
-    }
-
-    /*Igmp Macbridge Client Packages Add*/
-    case CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_ADD:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_igmp_macbridge_client_packages_t);
-
-      msg_igmp_macbridge_client_packages_t *msgPtr;
-      msgPtr = (msg_igmp_macbridge_client_packages_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_macbridge_client_packages_t));
-
-      /* Execute command */      
-      rc = ptin_msg_igmp_macbridge_client_packages_add(msgPtr, noOfMessages);
-
-      if (L7_SUCCESS != rc)
-      {       
-       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
-       SetIPCNACK(outbuffer, res);
-       break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
-    }
-
-    /*Igmp Macbridge Client Packages Remove*/
-    case CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_REMOVE:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_igmp_macbridge_client_packages_t);
-
-      msg_igmp_macbridge_client_packages_t *msgPtr;
-      msgPtr = (msg_igmp_macbridge_client_packages_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_macbridge_client_packages_t));
-
-      /* Execute command */
-      rc = ptin_msg_igmp_macbridge_client_packages_remove(msgPtr, noOfMessages);
-
-      if (L7_SUCCESS != rc)
-      {       
-       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing Channels from Package [res:0x%x]", res);
-       SetIPCNACK(outbuffer, res);
-       break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
-    }
-
-    /*Multicast Service Add*/
-    case CCMSG_MULTICAST_SERVICE_ADD:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MULTICAST_SERVICE_ADD (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_multicast_service_t);
-
-      msg_multicast_service_t *msgPtr;
-      msgPtr = (msg_multicast_service_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_multicast_service_t));
-
-      /* Execute command */
-      rc = ptin_msg_igmp_multicast_service_add(msgPtr, noOfMessages);
-
-      if (L7_SUCCESS != rc)
-      {       
-       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
-       SetIPCNACK(outbuffer, res);
-       break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
-    }
-
-    /*Multicast Service Remove*/
-    case CCMSG_MULTICAST_SERVICE_REMOVE:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MULTICAST_SERVICE_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_multicast_service_t);
-
-      msg_multicast_service_t *msgPtr;
-      msgPtr = (msg_multicast_service_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_multicast_service_t));
-
-      /* Execute command */
-      rc = ptin_msg_igmp_multicast_service_remove(msgPtr, noOfMessages);
-
-      if (L7_SUCCESS != rc)
-      {       
-       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
-       SetIPCNACK(outbuffer, res);
-       break;
-      }
-
-      SETIPCACKOK(outbuffer);
-
-      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
-    }
-/************************************End Multicast Package Feature********************************************************/
-#if (PTIN_BOARD == PTIN_BOARD_AG16GA)
-
-    case CCMSG_AGENT_TRAP_CONFIGURE:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_AGENT_TRAP_CONFIGURE (0x%04X)", inbuffer->msgId);
-
-      CHECK_INFO_SIZE(msg_agent_trap_conf_t);
-
-      msg_agent_trap_conf_t *ptr;
-        
-      ptr = (msg_agent_trap_conf_t *) outbuffer->info;
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_agent_trap_conf_t));
-
-      ptin_msg_configure_trap(ptr->vlan, ptr->port_id, ptr->protocol, ptr->admin);
-
-      /* Execute command */
-
-      if (L7_SUCCESS != rc)
-      {
-         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-         SetIPCNACK(outbuffer, res);
-         break;
-      }
-
-        outbuffer->infoDim = sizeof(msg_agent_trap_conf_t);
-        break;
-    }
-#endif
-    /************************************************************************** 
-    * MAC Limiting Configuration
-    **************************************************************************/
-
-    case CCMSG_L2_MACLIMIT_CONFIG:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_L2_MACLIMIT_CONFIG (0x%04X)", msgId); 
-      CHECK_INFO_SIZE(msg_l2_maclimit_config_t);
-
-      msg_l2_maclimit_config_t *ptr;
-    
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_l2_maclimit_config_t));
-      ptr = (msg_l2_maclimit_config_t *) outbuffer->info;
-
-      /* Execute command */
-      rc = ptin_msg_l2_maclimit_config(ptr);  
-    
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      //SETIPC_INFODIM(sizeof(msg_l2_maclimit_config_t));
-      SETIPCACKOK(outbuffer);
-    }
-    break;
-
-    /************************************************************************** 
-    * MAC Limiting Status
-    **************************************************************************/
-
-    case CCMSG_L2_MACLIMIT_STATUS:
-    {
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_L2_MACLIMIT_STATUS (0x%04X)", msgId);
-     CHECK_INFO_SIZE(msg_l2_maclimit_status_t);
-
-     msg_l2_maclimit_status_t *ptr;
-
-     ptr = (msg_l2_maclimit_status_t *) outbuffer->info;
-     memcpy(&outbuffer->info, &inbuffer->info, sizeof(msg_l2_maclimit_status_t));
-
-     /* Execute command */
-     rc = ptin_msg_l2_maclimit_status(ptr);  
-
-     if (L7_SUCCESS != rc)
-     {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-     }
-
-      SETIPC_INFODIM(sizeof(msg_l2_maclimit_status_t));
-
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status Response");
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," slotId       = %u",      ptr->slotId);
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," interface    = %u/%u",   ptr->intf.intf_type, ptr->intf.intf_id);
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," MacLearned   = %u",      ptr->number_mac_learned);
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status       = %u",      ptr->status);
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Mask         = %u",      ptr->mask);      
-    }
-    break;
-
-    /* Signalling the end of a Equipment Flush Configuration*/
-    case CCMSG_PROTECTION_MATRIX_FLUSH_CONFIGURATION_END:
-    {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MATRIX_FLUSH_CONFIGURATION_END (0x%04X)", msgId);
-
-      #if 0
-      /*Sending Ack*/  
-      SETIPCACKOK(outbuffer);      
-
-      /* Execute command */
-      ptin_msg_protection_matrix_configuration_flush_end();      
-      #else
-      /* Execute command */
-      ptin_msg_task_process(msgId, (void*)(inbuffer->info), infoDim, 3000);
-
-      /*Sending Ack*/  
-      SETIPCACKOK(outbuffer);   
-      #endif
-      break;
-    }
-
-  #if (PTIN_BOARD_IS_STANDALONE)
-    case CCMSG_PTP_FPGA:
-      #if (PTIN_BOARD == PTIN_BOARD_OLT1T0)
-      if (!KERNEL_NODE_IS("OLT1T0-AC")) {
-        PT_LOG_WARN(LOG_CTX_MSGHANDLER, "Message not supported!");
-        SetIPCNACK (outbuffer, SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_WARNING, ERROR_CODE_NOSUCHMSG));
-
-        rc = L7_FAILURE;
-        break;
-      }
-      #endif
-      {
-        T_MSG_PTP_FPGA *p;
-        ptin_dtl_search_ptp_t e;
-        L7_uint32 ptin_port;
-        ptin_intf_t ptin_intf;
-
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_PTP_FPGA (0x%04X)", msgId); 
-        CHECK_INFO_SIZE(T_MSG_PTP_FPGA);   //CHECK_INFO_MOD(T_MSG_PTP_FPGA);
-
-        do {
-          p= (T_MSG_PTP_FPGA *) inbuffer->info;
-          ptin_intf.intf_id=     p->intf.intf_id;
-          ptin_intf.intf_type=   p->intf.intf_type;
-          rc = ptin_intf_ptintf2port(&ptin_intf, &ptin_port);
-          //ptin_intf_ptintf2intIfNum(&p->intf, &intIfNum);
-          if (L7_SUCCESS != rc) break;
-      
-          e.key.prt= ptin_port;
-          e.key.vid= p->vid;
-          //e.vid_prt=
-          e.vid_os=  p->vid_os;
-          e.encap=   p->encap;
-          memcpy(&e.ntw, &p->ntw, sizeof(e.ntw));
-          rc = ptin_ptp_fpga_entry(&e, 0==p->add0_del1? DAPI_CMD_SET:DAPI_CMD_CLEAR);
-        } while (0);
-
-        if (L7_SUCCESS != rc) {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          //res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, rc);
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        SETIPCACKOK(outbuffer);
-        break;
-      }
-
-    case CCMSG_OAM_FPGA:
-      #if (PTIN_BOARD == PTIN_BOARD_OLT1T0)
-      if (!KERNEL_NODE_IS("OLT1T0-AC")) {
-              PT_LOG_WARN(LOG_CTX_MSGHANDLER, "Message not supported!");
-              SetIPCNACK (outbuffer, SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_WARNING, ERROR_CODE_NOSUCHMSG));
-
-              rc = L7_FAILURE;
-              break;
-      }
-      #endif
-      {
-        T_MSG_OAM_FPGA *p;
-        ptin_dtl_search_oam_t e;
-        //L7_uint32 ptin_port;
-        //ptin_intf_t ptin_intf;
-
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_OAM_FPGA (0x%04X)", msgId); 
-        CHECK_INFO_SIZE(T_MSG_OAM_FPGA);   //CHECK_INFO_MOD(T_MSG_OAM_FPGA);
-
-        do {
-           p= (T_MSG_OAM_FPGA *) inbuffer->info;
-           //ptin_intf.intf_id=     p->bd.prt;
-           //ptin_intf.intf_type=   0;    //Physical
-           //rc = ptin_intf_ptintf2port(&ptin_intf, &ptin_port);
-           ////ptin_intf_ptintf2intIfNum(&p->intf, &intIfNum);
-           //if (L7_SUCCESS != rc) break;
-
-           e.key.prt= p->bd.prt;//ptin_port;
-           e.key.vid= p->bd.vid;
-           //e.vid_prt=
-           e.lvl= p->bd.level;
-           rc = ptin_oam_fpga_entry(&e, EMPTY_T_MEP(p->bd)? DAPI_CMD_CLEAR: DAPI_CMD_SET);
-        } while (0);
-
-        if (L7_SUCCESS != rc) {
-         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-         //res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, rc);
-         SetIPCNACK(outbuffer, res);
-         break;
-        }
-
-        SETIPCACKOK(outbuffer);
-        break;
-      }
-
-  #endif // PTIN_BOARD_IS_STANDALONE
-#ifdef NGPON2_SUPPORTED
-    case CCMSG_NGPON2_ADD_GROUP:
-    {
-     
-       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_NGPON2_ADD_GROUP (0x%04X)", inbuffer->msgId);
-
-       CHECK_INFO_SIZE(ptin_NGPON2group_t);
-
-       ptin_NGPON2group_t *ptr;
-
-       ptr = (ptin_NGPON2group_t *) outbuffer->info;
-
-       memcpy(&outbuffer->info, &inbuffer->info, sizeof(ptin_NGPON2group_t));
-
-       ENDIAN_SWAP8_MOD(ptr->GroupId);
-       ENDIAN_SWAP32_MOD(ptr->mask);
-       ENDIAN_SWAP8_MOD(ptr->numIntf);
-       ENDIAN_SWAP8_MOD(ptr->slotId);
-
-       /* Execute command */
-       rc = ptin_msg_NGPON2_add_group(ptr);  
-       if (L7_SUCCESS != rc)
-       {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-       }
-
-        outbuffer->infoDim = sizeof(ptin_NGPON2group_t);
-
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status Response");
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," slotId       = %u",      ptr->slotId);
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," GroupId      = %u",      ptr->GroupId);
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," NumIntf      = %u",      ptr->numIntf);
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Mask         = %u",      ptr->mask);    
-
-              /* Execute command */
-        rc = ptin_msg_NGPON2_add_group_port(ptr);  
-
-        if (L7_SUCCESS != rc)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
-
-        outbuffer->infoDim = sizeof(ptin_NGPON2group_t);
-
-        L7_uint16 i = 0;
-        
-        while ( i < ptr->numIntf )
-        {
-          PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Port added with group");
-          PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Type         = %u",      ptr->NGPON2Port[i].type);
-          PT_LOG_TRACE(LOG_CTX_MSGHANDLER," ID           = %u",      ptr->NGPON2Port[i].id);   
-
-          i++;
-        }
-
-
-        
-    }
-    break;
-
-    case CCMSG_NGPON2_REM_GROUP:
-    {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_NGPON2_REM_GROUP (0x%04X)", inbuffer->msgId);
-        CHECK_INFO_SIZE(ptin_NGPON2group_t);
-
-        ptin_NGPON2group_t *ptr;
-
-        ptr = (ptin_NGPON2group_t *) outbuffer->info;
-        memcpy(&outbuffer->info, &inbuffer->info, sizeof(ptin_NGPON2group_t));
-
-        ENDIAN_SWAP8_MOD(ptr->GroupId);
-        ENDIAN_SWAP32_MOD(ptr->mask);
-        ENDIAN_SWAP8_MOD(ptr->numIntf);
-        ENDIAN_SWAP8_MOD(ptr->slotId);
-
-        /* Execute command */
-        rc = ptin_msg_NGPON2_rem_group(ptr); 
-
-        if (L7_SUCCESS != rc)
-        {
-           PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-           res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-           SetIPCNACK(outbuffer, res);
-           break;
-        }
-
-         outbuffer->infoDim = sizeof(ptin_NGPON2group_t);
-
-         PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status Response");
-         PT_LOG_TRACE(LOG_CTX_MSGHANDLER," slotId       = %u",      ptr->slotId);
-         PT_LOG_TRACE(LOG_CTX_MSGHANDLER," GroupId      = %u",      ptr->GroupId);
-         PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status       = %u",      ptr->numIntf);
-         PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Mask         = %u",      ptr->mask);      
-
-    }
-    break;
-
-    case CCMSG_NGPON2_ADD_GROUP_PORT:
-    {
-
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_NGPON2_ADD_GROUP_PORT (0x%04X)", inbuffer->msgId);
-      CHECK_INFO_SIZE(ptin_NGPON2group_t);
-
-      ptin_NGPON2group_t *ptr;
-
-      ptr = (ptin_NGPON2group_t *) outbuffer->info;
-      memcpy(&outbuffer->info, &inbuffer->info, sizeof(ptin_NGPON2group_t));
-
-      /* Execute command */
-      rc = ptin_msg_NGPON2_add_group_port(ptr);  
-
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
-
-      outbuffer->infoDim = sizeof(ptin_NGPON2group_t);
-
-      L7_uint16 i = 0;
-      
-      while ( i < ptr->numIntf )
-      {
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status Response");
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," slotId       = %u",      ptr->NGPON2Port[i].slot);
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Type         = %u",      ptr->NGPON2Port[i].type);
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," ID           = %u",      ptr->NGPON2Port[i].id);   
-
-        i++;
-      }  
-    }
-    break;
-
-    case CCMSG_NGPON2_REM_GROUP_PORT:
-    {
-
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_NGPON2_REM_GROUP_PORT (0x%04X)", inbuffer->msgId);
-      CHECK_INFO_SIZE(ptin_NGPON2group_t);
-
-      ptin_NGPON2group_t *ptr;
-        
-      ptr = (ptin_NGPON2group_t *) outbuffer->info;
-      memcpy(&outbuffer->info, &inbuffer->info, sizeof(ptin_NGPON2group_t));
-
-      /* Execute command */
-      rc = ptin_msg_NGPON2_rem_group_port(ptr);  
-
-      if (L7_SUCCESS != rc)
-      {
-         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-         SetIPCNACK(outbuffer, res);
-         break;
-      }
-
-      outbuffer->infoDim = sizeof(ptin_NGPON2group_t);
-
-      L7_uint16 i = 0;
-      
-      while ( i < ptr->numIntf )
-      {
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status Response");
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," slotId       = %u",      ptr->NGPON2Port[i].slot);
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Type         = %u",      ptr->NGPON2Port[i].type);
-        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," ID           = %u",      ptr->NGPON2Port[i].id);   
-
-        i++;
-      }
-    }
-    break;
-#endif
-    default:
-    {
-      PT_LOG_WARN(LOG_CTX_MSGHANDLER, "Message received: UNKNOWN! (0x%04X)\n", msgId);
-      PT_LOG_WARN(LOG_CTX_MSGHANDLER,
-                  "The received message is not supported!");
-      SetIPCNACK (outbuffer, SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_WARNING, ERROR_CODE_NOSUCHMSG));
-
-      rc = L7_FAILURE;
-      break;
-    }
-
-  }
-
-  #if 0
-  /* Save slot id parameter */
-  if (infoDim >= 1 &&
-      inbuffer->info[0]!=(L7_uint8)-1 &&
-      ptin_board_slotId!=inbuffer->info[0])
-  {
-    ptin_board_slotId = inbuffer->info[0];
-  }
-  #endif
-
-  /* Save final time */
-  time_end = osapiTimeMicrosecondsGet();
-  time_delta = time_end - time_start;
-
-  
-  if( msgId == CCMSG_ETH_PHY_ACTIVITY_GET || 
-      msgId == CCMSG_HW_INTF_INFO_GET     ||
-      msgId == CCMSG_ETH_PHY_COUNTERS_GET ||
-      msgId == CCMSG_SWITCH_TEMPERATURE_GET ||
-#if (PTIN_BOARD_IS_MATRIX)
-      msgId == CCMSG_ETH_LACP_MATRIXES_SYNC2 || 
-#endif
-      msgId == CCMSG_MGMD_PORT_SYNC || 
-      msgId == CCMSG_APPLICATION_RESOURCES)
-  {
-    PT_LOG_TRACE(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %lu usec [response:%u (bytes) rc=%u res=0x%08x]", msgId, outbuffer->infoDim, time_delta, rc, res);
-  }
-  else
-  {
-    PT_LOG_INFO(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %lu usec  [response:%u (bytes) rc=%u res=0x%08x]", msgId, outbuffer->infoDim, time_delta, rc, res);
-  }
-
-  /* Message Runtime Meter */
-  /* Only for successfull messages */
-  if (rc==L7_SUCCESS)
-  {
-    CHMessage_runtime_meter_update(msgId, time_delta);
-  }
-
-  return ret;
-}
-
-
-/**
- * Update message runtime meter
- * 
- * @param msg_id : message id
- * @param time_delta : time taken to process message
- */
-static void CHMessage_runtime_meter_update(L7_uint msg_id, L7_uint32 time_delta)
-{
-  struct_runtime_t *msg_runtime_ptr;
-
-  if (msg_id<CCMSG_ID_MIN && msg_id>CCMSG_ID_MAX)
-  {
-    return;
-  }
-
-  msg_runtime_ptr = &msg_runtime[msg_id-CCMSG_ID_MIN];
-
-  /* If overflow, reset all data */
-  if ( (msg_runtime_ptr->number_of_calls==(L7_uint32)-1) ||
-       (msg_runtime_ptr->total_runtime + time_delta < msg_runtime_ptr->total_runtime) )
-  {
-    CHMessage_runtime_meter_init(msg_id);
-  }
-
-  /* Update database */
-  msg_runtime_ptr->number_of_calls++;
-  msg_runtime_ptr->last_runtime    = time_delta;
-  msg_runtime_ptr->total_runtime  += time_delta;
-  if ( (msg_runtime_ptr->number_of_calls)==1 || time_delta<(msg_runtime_ptr->min_runtime) )
-    msg_runtime_ptr->min_runtime = time_delta;
-  if ( time_delta > msg_runtime_ptr->max_runtime )
-    msg_runtime_ptr->max_runtime = time_delta;
-  msg_runtime_ptr->average_runtime = msg_runtime_ptr->total_runtime/msg_runtime_ptr->number_of_calls;
-}
-
-/**
- * Initializes message runtime meter 
- *  
- * @param msg_id : message id 
- */
-void CHMessage_runtime_meter_init(L7_uint msg_id)
-{
-  if (msg_id<CCMSG_ID_MIN || msg_id>CCMSG_ID_MAX)
-  {
-    memset(msg_runtime,0x00,sizeof(msg_runtime));
-  }
-  else
-  {
-    memset(&msg_runtime[msg_id-CCMSG_ID_MIN],0x00,sizeof(struct_runtime_t));
-  }
-}
-
-/**
- * Prints meter information
- */
-void CHMessage_runtime_meter_print(void)
-{
-  L7_uint i;
-
-  printf(" --------------------------------------------------------------------------------------------------------- \r\n");
-  printf("| Message id |   #Calls   | Total runtime |  Last runtime |  Min. runtime |  Max. runtime | Avrg. runtime |\r\n");
-  printf("|------------|------------|---------------|---------------|---------------|---------------|---------------|\r\n");
-
-  for (i=0; i<CCMSG_ID_MAX-CCMSG_ID_MIN+1; i++)
-  {
-    if (msg_runtime[i].number_of_calls==0)  continue;
-
-    printf("|   0x%04X   | %10u | %10u us | %10u us | %10u us | %10u us | %10u us |\r\n",
-           i+CCMSG_ID_MIN,
-           msg_runtime[i].number_of_calls,
-           msg_runtime[i].total_runtime,
-           msg_runtime[i].last_runtime,
-           msg_runtime[i].min_runtime,
-           msg_runtime[i].max_runtime,
-           msg_runtime[i].average_runtime);
-  }
-
-  printf(" --------------------------------------------------------------------------------------------------------- \r\n");
-
-  fflush(stdout);
-}
-
+/**
+ * CHMessageHandler.c 
+ *  
+ * Created on: 
+ * Author: 
+ *  
+ * Modified on 2011/06/14 
+ * By: Alexandre Santos (alexandre-r-santos@ptinovacao.pt) 
+ * Notes: major code refactoring
+ *  
+ */
+
+#include "ptin_include.h"
+#include "ptin_msg.h"
+#include "tty_ptin.h"
+#include "sirerrors.h"
+#include "ptin_control.h"
+#include "ptin_mgmd_api.h"
+#include "ptin_debug.h"//Added by MMelo to use ptin_timer routines
+#include "ipc.h"
+#include <ptin_prot_oam_eth.h>
+#include <ptin_intf.h>
+extern L7_RC_t ptin_ptp_fpga_entry(ptin_dtl_search_ptp_t *e, DAPI_CMD_GET_SET_t operation);
+extern L7_RC_t ptin_oam_fpga_entry(ptin_dtl_search_oam_t *e, DAPI_CMD_GET_SET_t operation);
+
+/* Message processing time measuring */
+
+#define CCMSG_ID_MIN  0x9000
+#define CCMSG_ID_MAX  0x91FF
+
+typedef struct
+{
+  uint32 number_of_calls;
+  uint32 total_runtime;
+  uint32 last_runtime;
+  uint32 min_runtime;
+  uint32 max_runtime;
+  uint32 average_runtime;
+} struct_runtime_t;
+
+static struct_runtime_t msg_runtime[CCMSG_ID_MAX-CCMSG_ID_MIN+1];
+
+static void CHMessage_runtime_meter_update(L7_uint msg_id, L7_uint32 time_delta);
+
+#define MSG_N_ELEMS(size)   (inbuffer->infoDim / (size))
+
+#define SETIPC_INFODIM(size) { \
+  outbuffer->infoDim = size;  \
+}
+
+/* Macro to set ACK OK on output message */
+#define SETIPCACKOK(outbuffer) { \
+  outbuffer->flags = IPCLIB_FLAGS_ACK; \
+  outbuffer->infoDim = sizeof(L7_uint32); \
+  *((L7_uint32 *) outbuffer->info) = ENDIAN_SWAP32(0);   \
+}
+#define SETIPCNACK(outbuffer, res) { \
+  outbuffer->flags = IPCLIB_FLAGS_NACK; \
+  outbuffer->infoDim = sizeof(unsigned int); \
+  *(unsigned int*)outbuffer->info = ENDIAN_SWAP32((unsigned int) res); \
+}
+
+
+/* Macro to check infoDim consistency */
+#define CHECK_INFO_SIZE_ATLEAST(msg_st) {             \
+  if (inbuffer->infoDim < sizeof(msg_st)) {  \
+    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting at least %u bytes; Received %u bytes!", sizeof(msg_st), inbuffer->infoDim);\
+    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); \
+    SetIPCNACK(outbuffer, res);               \
+    break;                                    \
+  }                                           \
+}
+
+/* Macro to check infoDim consistency */
+#define CHECK_INFO_SIZE(msg_st) {             \
+  if (inbuffer->infoDim != sizeof(msg_st)) {  \
+    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting %u bytes; Received %u bytes!", sizeof(msg_st), inbuffer->infoDim);\
+    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); \
+    SetIPCNACK(outbuffer, res);               \
+    break;                                    \
+  }                                           \
+}
+
+/* Macro to check infoDim consistency (including modulo match) */
+#define CHECK_INFO_SIZE_MOD(msg_st) {             \
+  if ( ((inbuffer->infoDim % sizeof(msg_st)) != 0)) {  \
+    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting multiple of %u bytes; Received %u bytes", sizeof(msg_st), inbuffer->infoDim);\
+    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); \
+    SetIPCNACK(outbuffer, res);               \
+    break;                                    \
+  }                                           \
+}
+
+/* Macro to check infoDim consistency */
+#define CHECK_INFO_SIZE_ATLEAST_ABS(size_bytes) {             \
+  if (inbuffer->infoDim < size_bytes) {  \
+    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting at least %u bytes; Received %u bytes!", size_bytes, inbuffer->infoDim);\
+    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); \
+    SetIPCNACK(outbuffer, res);               \
+    break;                                    \
+  }                                           \
+}
+
+/* Macro to check infoDim consistency */
+#define CHECK_INFO_SIZE_ABS(size_bytes) {             \
+  if (inbuffer->infoDim != size_bytes) {  \
+    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting %u bytes; Received %u bytes!", size_bytes, inbuffer->infoDim);\
+    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); \
+    SetIPCNACK(outbuffer, res);               \
+    break;                                    \
+  }                                           \
+}
+
+
+static L7_uint16 SIRerror_get(L7_RC_t error_code)
+{
+  switch ((int) error_code)
+  {
+    case L7_FAILURE:
+    case L7_ERROR:
+      return ERROR_CODE_INVALIDPARAM;
+
+    case L7_REQUEST_DENIED:
+      return ERROR_CODE_USED;
+
+    case L7_NOT_IMPLEMENTED_YET:
+      return ERROR_CODE_NOTIMPLEMENTED;
+
+    case L7_NOT_EXIST:
+      return ERROR_CODE_NOSUCHNAME;
+
+    case L7_TABLE_IS_FULL:
+    case L7_NO_RESOURCES:
+      return ERROR_CODE_FULLTABLE;
+
+    case L7_NOT_SUPPORTED:
+      return ERROR_CODE_NOTSUPPORTED;
+
+    case L7_DEPENDENCY_NOT_MET:
+      return ERROR_CODE_FP_EVC_UNKNOWN;
+    case L7_ADDR_INUSE:
+      return ERROR_COUNTER_USED;
+    case L7_NO_VALUE:
+      return ERROR_NO_MORE_VLAN_AVAILABLE;
+  }
+
+  // Default error
+  return ERROR_CODE_INVALIDPARAM;
+}
+
+
+
+#ifdef __802_1x__
+static void seterror(ipc_msg *outbuffer, const L7_ulong32 severity, const L7_ulong32 error) {
+    outbuffer->flags   = IPCLIB_FLAGS_NACK;
+    outbuffer->infoDim = sizeof(int);
+    *(int *)outbuffer->info = ENDIAN_SWAP32(SIR_ERROR(ERROR_FAMILY_HARDWARE,severity,error));
+}
+
+
+
+
+//Function for generic message reading/writing n STRUCT_SIZE structs*************************************************
+//Uses the particular method for reading/writing each struct, "msg_generic_wrd_1struc"*******************************
+static int msg_generic_wrd(int (*msg_generic_wrd_1struct)(ipc_msg *inbuffer, ipc_msg *outbuffer, L7_ulong32 i), ipc_msg *inbuffer, ipc_msg *outbuffer, L7_ulong32 STRUCT_SIZE_IN, L7_ulong32 STRUCT_SIZE_OUT)
+{
+  L7_ushort16 i,n;
+
+  PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: 0x%04X", inbuffer->msgId);
+
+  //CHECK_INFO_SIZE_MOD(msg_ptin_pcs_prbs);
+  if ((inbuffer->infoDim > IPCLIB_MAX_MSGSIZE) || (inbuffer->infoDim % STRUCT_SIZE_IN) !=0)
+  {
+    seterror(outbuffer, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE); //seterror(outbuffer, ERROR_SEVERITY_DEBUG, HW_INVALID_MSG_SIZE);
+    PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! Expecting multiple of %u bytes; Received %u bytes", STRUCT_SIZE_IN, inbuffer->infoDim);
+    return(0);
+  }
+
+  outbuffer->flags = IPCLIB_FLAGS_ACK;
+
+  n = MSG_N_ELEMS(STRUCT_SIZE_IN);
+
+  if (STRUCT_SIZE_IN>=STRUCT_SIZE_OUT)  //0..n-1
+  {
+    for (i=0;    i<n;    i++)
+    {
+     if ((*msg_generic_wrd_1struct)((void*)inbuffer, (void*)outbuffer, i)) {
+       outbuffer->flags = IPCLIB_FLAGS_NACK;
+       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error WRDing data");
+     }
+    }
+  }
+  else
+  {
+    if (n*STRUCT_SIZE_OUT>IPCLIB_MAX_MSGSIZE)
+    {
+     seterror(outbuffer, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE);   //seterror(outbuffer, ERROR_SEVERITY_DEBUG, HW_INVALID_OUTPUT_MSG_SIZE);
+     return(0);
+    }
+    for (i=n;  i;  i--) //i=n-1..0
+    {
+      if ((*msg_generic_wrd_1struct)((void*)inbuffer, (void*)outbuffer, i-1)) {
+          outbuffer->flags = IPCLIB_FLAGS_NACK;
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error WRDing data");
+      }
+    }
+  }
+
+  SETIPC_INFODIM(n * STRUCT_SIZE_OUT);
+  PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message processed: response with %d bytes", outbuffer->infoDim);
+  return(0);
+}//msg_generic_wrd
+#endif //__802_1x__
+
+
+
+
+
+
+
+
+
+
+
+int ipc_msg_bytes_debug_enable(int disable0_enable1_read2) {
+static int enable=0;
+
+ switch (disable0_enable1_read2) {
+ case 0:
+ case 1: enable=disable0_enable1_read2; break;
+ }
+
+ return enable;
+}
+
+
+
+
+
+
+
+
+
+
+/**
+ * Message handler for the PTin Module.
+ * 
+ * @param inbuffer Input IPC message
+ * @param outbuffer Output IPC message
+ * 
+ * @return int Error code (SIR_ERROR list)
+ */
+int CHMessageHandler (ipc_msg *inbuffer, ipc_msg *outbuffer)
+{
+  L7_uint32 msgId, infoDim;
+  int ret = IPC_OK, res = S_OK;
+  L7_RC_t rc = L7_SUCCESS;
+  L7_uint64 time_start, time_end;
+  L7_uint32 time_delta;
+
+  if (inbuffer == NULL)
+  {
+    PT_LOG_WARN(LOG_CTX_MSGHANDLER, "NULL message received!");
+    return SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_EMPTYMSG);
+  }
+
+  /* Get initial time (in microseconds) */
+  time_start = osapiTimeMicrosecondsGet();
+
+  /* Prepare message header */
+  SwapIPCHeader(inbuffer, outbuffer);
+
+  msgId   = inbuffer->msgId;
+  infoDim = inbuffer->infoDim;
+
+  /* Commands allowed to be run, even if switchdrvr is busy */
+  /* If reached here, means PTin module is loaded and ready to process messages */
+  switch (msgId)
+  {
+    /************************************************************************** 
+     * Application Utils Processing
+     **************************************************************************/
+
+    /* If message is a ping, reply with PTin loading state, which can signal crash errors too */
+    case CCMSG_APPLICATION_IS_ALIVE:
+    {
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APPLICATION_IS_ALIVE (0x%04X)", msgId);
+
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "PTin state: %d", ptin_state);
+      *((L7_uint32 *) outbuffer->info) = ENDIAN_SWAP32((L7_uint32) ptin_state);
+      SETIPC_INFODIM(sizeof(L7_uint32));
+
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER,
+                  "Message processed: response with %d bytes", ENDIAN_SWAP32(outbuffer->infoDim));
+      return IPC_OK;
+    }
+
+    /* CCMSG_APP_FW_STATE_SET ************************************************/
+    case CCMSG_APP_FW_STATE_SET:
+    {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APP_FW_STATE_SET (0x%04X)", msgId);
+
+        if (infoDim == 0)
+        {
+          res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE);
+          SetIPCNACK(outbuffer, res);
+          return IPC_OK;
+        }
+        /* Validate state */
+        if (inbuffer->info[0] >= PTIN_STATE_LAST)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Invalid state: %u", inbuffer->info[0]);
+          res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+          SetIPCNACK(outbuffer, res);
+          return IPC_OK;
+        }
+        /* Set new state */
+        ptin_state = inbuffer->info[0];
+        SETIPCACKOK(outbuffer);
+
+        return IPC_OK;  /* CCMSG_APP_FW_STATE_SET */
+    }
+
+    /* CCMSG_APP_CHANGE_STDOUT ************************************************/
+    case CCMSG_APP_CHANGE_STDOUT:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APP_CHANGE_STDOUT (0x%04X)", msgId);
+      PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "Redirecting stdout...");
+
+      /* Validate message data */
+      if (infoDim == 0)
+      {
+        res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE);
+        SetIPCNACK(outbuffer, res);
+        return IPC_OK;
+      }
+
+      /* Apply change */
+      ptin_PitHandler((char *) &inbuffer->info[0]);
+
+      SETIPCACKOK(outbuffer);
+
+      PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "...Stdout redirected to here :-)");
+      return IPC_OK;  /* CCMSG_APP_CHANGE_STDOUT */
+    }
+
+    case CCMSG_APP_LOGGER_OUTPUT:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APP_LOGGER_OUTPUT (0x%04X)", msgId);
+
+      L7_uint8 output;
+      char *filename;
+
+      /* If infodim is null, use stdout */
+      if (infoDim == 0)
+      {
+        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "Redirecting logger output (0) to \"%s\"...", LOG_OUTPUT_FILE_DEFAULT);
+        logger_redirect(LOG_OUTPUT_FILE, LOG_OUTPUT_FILE_DEFAULT);
+        ptin_mgmd_logredirect(MGMD_LOG_FILE, LOG_OUTPUT_FILE_DEFAULT);
+        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "...Logger output (0) redirected to \"%s\" :-)", LOG_OUTPUT_FILE_DEFAULT);
+      }
+      /* Otherwise, use the specified filename */
+      else if (infoDim == 1 || inbuffer->info[1] == '\0')
+      {
+        output = LOG_OUTPUT_FILE + inbuffer->info[0];
+
+        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "Redirecting logger output (%u) to \"%s\"...", output, LOG_OUTPUT_FILE_DEFAULT);
+        logger_redirect(output, LOG_OUTPUT_FILE_DEFAULT);
+        if (output == LOG_OUTPUT_FILE)
+        {
+          ptin_mgmd_logredirect(MGMD_LOG_FILE, LOG_OUTPUT_FILE_DEFAULT); 
+        }
+        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "...Logger output (%u) redirected to \"%s\" :-)", output, LOG_OUTPUT_FILE_DEFAULT);
+      }
+      else
+      {
+        output = LOG_OUTPUT_FILE + inbuffer->info[0];
+        filename = (char *) &inbuffer->info[1];
+
+        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "Redirecting logger output (%u) to \"%s\"...", output, filename);
+        logger_redirect(output, filename);
+        if (output == LOG_OUTPUT_FILE)
+        {
+          ptin_mgmd_logredirect(MGMD_LOG_FILE, filename);
+        }
+        PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "...Logger output (%u) redirected to \"%s\" :-)", output, filename);
+      }
+      SETIPCACKOK(outbuffer);
+      return IPC_OK;  /* CCMSG_APP_CHANGE_STDOUT */
+    }
+
+    /* CCMSG_APP_SHELL_CMD_RUN ************************************************/
+    case CCMSG_APP_SHELL_CMD_RUN:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APP_SHELL_CMD_RUN (0x%04X)", msgId);
+
+      if (infoDim == 0)
+      {
+        res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE);
+        SetIPCNACK(outbuffer, res);
+        return IPC_OK;
+      }
+      if (ptin_msg_ShellCommand_run((L7_char8 *) &inbuffer->info[0]) != L7_SUCCESS)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error on ptin_msg_ShellCommand_run()");
+        res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        return IPC_OK;
+      }
+      SETIPCACKOK(outbuffer);
+      return IPC_OK;  /* CCMSG_APP_SHELL_CMD_RUN */
+    }
+
+    /* CCMSG_ETH_PHY_ACTIVITY_GET ************************************************/
+    case CCMSG_ETH_PHY_ACTIVITY_GET:
+    {
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_ACTIVITY_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HWEthPhyActivity_t);
+
+      msg_HWEthPhyActivity_t *pin  = (msg_HWEthPhyActivity_t *) inbuffer->info;
+      msg_HWEthPhyActivity_t *pout = (msg_HWEthPhyActivity_t *) outbuffer->info;
+
+      /* Reference structure */
+      memcpy(pout, pin, sizeof(msg_HWEthPhyActivity_t));
+
+      if (ptin_msg_PhyActivity_get(pout) != L7_SUCCESS)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port activity (slot=%u/%u)", ENDIAN_SWAP8(pin->intf.slot), ENDIAN_SWAP8(pin->intf.port));
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        return IPC_OK;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_HWEthPhyActivity_t));
+      return IPC_OK;  /* CCMSG_ETH_PHY_ACTIVITY_GET */
+    }
+
+    /* CCMSG_BOARD_SHOW *******************************************************/
+    case CCMSG_BOARD_SHOW:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_BOARD_SHOW (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(0);
+
+      msg_FWFastpathInfo *fpInfo;
+      fpInfo = (msg_FWFastpathInfo *) outbuffer->info;
+
+      /* Get values */
+      ptin_msg_FPInfo_get(fpInfo);  /* returns always success */
+
+      /* Copy slot id information if available! */
+      if (infoDim >= 1)
+        outbuffer->info[0] = inbuffer->info[0];
+
+      SETIPC_INFODIM(sizeof(msg_FWFastpathInfo));
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER,
+                  "Message processed: response with %d bytes (present=%d)", outbuffer->infoDim, ENDIAN_SWAP32(fpInfo->BoardPresent));
+
+      return IPC_OK;  /* CCMSG_BOARD_SHOW */
+    }
+
+    /* CCMSG_HW_INTF_INFO_GET ****************************************************/
+    case CCMSG_HW_INTF_INFO_GET:
+    {
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_HW_INTF_INFO_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_ATLEAST(L7_uint32);
+      msg_HwIntfInfo_t *ptr;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwIntfInfo_t));
+      ptr = (msg_HwIntfInfo_t *) outbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_intfInfo_get(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error interface status");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        return IPC_OK;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_HwIntfInfo_t));
+      return IPC_OK;
+    }
+    /* CCMSG_HW_INTF_STATUS */
+    case CCMSG_HW_INTF_STATUS:
+    {
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_HW_INTF_STATUS (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_ATLEAST(msg_HwIntfStatus_t);
+
+      /* Execute command */
+      rc = ptin_msg_intfLinkStatus(inbuffer);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error interface status");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        return IPC_NO_REPLY;
+      }
+
+      SETIPCACKOK(outbuffer);
+      return IPC_NO_REPLY;
+    }
+
+    /* CCMSG_APPLICATION_RESOURCES *********************************************/
+    case CCMSG_APPLICATION_RESOURCES:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APPLICATION_RESOURCES (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_ptin_policy_resources);
+
+      /* Copy inbuffer to outbuffer */
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_ptin_policy_resources));
+
+      msg_ptin_policy_resources *resources;
+      resources = (msg_ptin_policy_resources *) outbuffer->info;
+
+      /* Get values */
+      if ( L7_SUCCESS != (rc=ptin_msg_hw_resources_get(resources)) )
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while consulting hardware resources");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        return IPC_OK;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_ptin_policy_resources));
+      return IPC_OK;  /* CCMSG_APPLICATION_RESOURCES */
+    }
+  }
+
+  /* If switchdrvr is busy, return FP_BUSY code error */
+  if (ptin_state == PTIN_STATE_BUSY)
+  {
+    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_FP_BUSY);
+    SetIPCNACK(outbuffer, res);
+    PT_LOG_WARN(LOG_CTX_MSGHANDLER, "IPC message cannot be processed! PTin state = %d (msgId=0x%x) -> error 0x%08x", ptin_state, msgId, res);
+    return IPC_OK;
+  }
+  /* PTin module is still loading or crashed ? */
+  else if (ptin_state != PTIN_STATE_READY)
+  {
+    res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_NOTALLOWED);
+    SetIPCNACK(outbuffer, res);
+    PT_LOG_WARN(LOG_CTX_MSGHANDLER, "IPC message cannot be processed! PTin state = %d (msgId=0x%x) -> error 0x%08x", ptin_state, msgId, res);
+    return IPC_OK;
+  }
+
+  if (ipc_msg_bytes_debug_enable(2))
+  {
+    L7_uint i;
+
+    if (inbuffer == NULL)
+    {
+        PT_LOG_WARN(LOG_CTX_MSGHANDLER, "NULL message received!");
+        return SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_EMPTYMSG);
+    }
+    printf("\n\rmsgId=0x%04x inbuffer->infoDim=%u:", inbuffer->msgId, inbuffer->infoDim);
+    for(i=0; i<inbuffer->infoDim; i++)
+    {
+      if ((i % 32) == 0)
+      {
+        printf("\r\n%04x:", i);
+      }
+      printf(" %02x", inbuffer->info[i]);
+    }
+    printf("\n\r");
+  }
+
+  /* If reached here, means PTin module is loaded and ready to process messages */
+  switch (msgId)
+  {
+    /************************************************************************** 
+     * Control processing
+     **************************************************************************/
+
+    /* Uplink protection command *********************************************/
+    case CHMSG_ETH_UPLINK_COMMAND:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_ETH_UPLINK_COMMAND (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_uplinkProtCmd);
+
+      msg_uplinkProtCmd *ptr = (msg_uplinkProtCmd *) inbuffer->info;
+      L7_int n = MSG_N_ELEMS(sizeof(msg_uplinkProtCmd));
+
+      ret = IPC_NO_REPLY;
+
+      rc = ptin_msg_uplink_protection_cmd(ptr, n);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error processing command");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+      break;
+    }
+
+  #if (PTIN_BOARD_IS_MATRIX)
+    case CCMSG_ETH_LACP_MATRIXES_SYNC2:
+    {
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_MATRIXES_SYNC2 (0x%04X)", msgId);
+
+      rx_dot3ad_matrix_sync2_t(inbuffer->info, infoDim);
+
+      SETIPC_INFODIM(1);
+      break;
+    }
+  #endif
+
+    /* Sync MGMD open ports between different cards/interfaces*/
+    case CCMSG_MGMD_PORT_SYNC:
+    {
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MGMD_PORT_SYNC (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwMgmdPortSync);
+
+      msg_HwMgmdPortSync *ptr;
+      ptr = (msg_HwMgmdPortSync *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwMgmdPortSync));
+
+      /* Execute command */
+      rc = ptin_msg_mgmd_sync_ports(ptr);
+      SETIPC_INFODIM(1);
+      break;
+    }
+
+    /************************************************************************** 
+     * Misc Processing
+     **************************************************************************/
+
+    /* CCMSG_ALARMS_RESET *****************************************************/
+    case CCMSG_ALARMS_RESET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ALARMS_RESET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwGenReq_t);
+
+      /* Execute command */
+      ptin_msg_alarms_reset();
+
+#ifdef __Y1731_802_1ag_OAM_ETH__
+      {
+       unsigned short i;
+       u16 mep_id, rmep_id, prt;
+       u64 vid;
+       T_MEG_ID meg;
+
+       for (i=0; i<N_MEPs; i++) {
+        switch (MEP_is_CC_LOC_or_RDI(i, &oam, &mep_id, &rmep_id, &meg, &prt, &vid)) {
+        //case 0:
+        //   ethsrv_oam_register_RDI_END((L7_uint8 *)&meg, mep_id, rmep_id, prt, vid); //ethsrv_oam_register(ME_RDI_END, rmep_id, &meg, mep_id, prt, vid);
+        //   ethsrv_oam_connection_restored((L7_uint8 *)&meg, mep_id, rmep_id, prt, vid); //ethsrv_oam_register(ME_CONNECTION_UP, rmep_id, &meg, mep_id, prt, vid);
+        //   break;
+        case 1:  ethsrv_oam_register_connection_loss((L7_uint8 *)&meg, mep_id, rmep_id, prt, vid); break; //ethsrv_oam_register(ME_CONNECTION_LOSS, rmep_id, &meg, mep_id, prt, vid); break;
+        case 2:  ethsrv_oam_register_receiving_RDI((L7_uint8 *)&meg, mep_id, rmep_id, prt, vid); break; //ethsrv_oam_register(ME_RDI, rmep_id, &meg, mep_id, prt, vid); break;
+        }//switch
+       }//for
+      }
+#endif
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ALARMS_RESET */
+    }
+
+    /* CCMSG_DEFAULTS_RESET ***************************************************/
+    case CCMSG_DEFAULTS_RESET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_DEFAULTS_RESET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwGenReq_t);
+      #if 0
+      msg_HwGenReq_t *config;
+      config = (msg_HwGenReq_t *) inbuffer->info;
+      ptin_msg_defaults_reset(config->param);
+      SETIPCACKOK(outbuffer);
+      #else
+      /* Execute command */      
+      ptin_msg_task_process(msgId, (void*)(inbuffer->info), infoDim, 3000);
+      SETIPCACKOK(outbuffer);
+      #endif
+
+      break;  /* CCMSG_DEFAULTS_RESET */
+    }
+
+    /* CCMSG_MULTICAST_MACHINE_RESET *******************************************/
+    case CCMSG_MULTICAST_MACHINE_RESET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MULTICAST_MACHINE_RESET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwGenReq_t);
+
+      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
+
+      /* Reset multicast machine */
+      rc = ptin_msg_multicast_reset(ptr);
+
+      /* Error? */
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+      /* Success */
+      SETIPCACKOK(outbuffer);
+      break;  /* CCMSG_DEFAULTS_RESET */
+    }
+
+    /* CCMSG_TYPEB_PROT_SWITCH *******************************************/
+    case CCMSG_TYPEB_PROT_SWITCH_NOTIFY:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_TYPEB_PROT_SWITCH_NOTIFY (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwTypeBProtSwitchNotify_t);
+
+      msg_HwTypeBProtSwitchNotify_t *ptr = (msg_HwTypeBProtSwitchNotify_t *) &inbuffer->info[0];
+
+      /* TYPE B Protection Switching */
+      rc = ptin_msg_typeBprotIntfSwitchNotify(ptr);
+
+      /* Error? */
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+      /* Success */
+      SETIPCACKOK(outbuffer);
+      break;  /* CCMSG_DEFAULTS_RESET */
+    }
+
+    case CCMSG_TYPEB_PROT_INTF_CONFIG:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_TYPEB_PROT_INTF_CONFIG (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwTypeBProtIntfConfig_t);
+
+      msg_HwTypeBProtIntfConfig_t *ptr = (msg_HwTypeBProtIntfConfig_t *) &inbuffer->info[0];
+
+      /* TYPE B Protection Switching */
+      rc = ptin_msg_typeBprotIntfConfig(ptr);
+
+      /* Error? */
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+      /* Success */
+      SETIPCACKOK(outbuffer);
+      break;  /* CCMSG_DEFAULTS_RESET */
+    }
+
+    case CCMSG_TYPEB_PROT_SWITCH:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_TYPEB_PROT_SWITCH (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwTypeBprot_t);
+
+      msg_HwTypeBprot_t *ptr = (msg_HwTypeBprot_t *) &inbuffer->info[0];
+
+      /* TYPE B Protection Switching */
+      rc = ptin_msg_typeBprotSwitch(ptr);
+
+      /* Error? */
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+      /* Success */
+      SETIPCACKOK(outbuffer);
+      break;  /* CCMSG_DEFAULTS_RESET */
+    }
+
+    case CCMSG_HW_BOARD_ACTION:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_HW_BOARD_ACTION (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwGenReq_t);
+
+      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
+
+      /* Hwardware procedure */
+      rc = ptin_msg_board_action(ptr);
+
+      /* Error? */
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+      /* Success */
+      SETIPCACKOK(outbuffer);
+      break;  /* CCMSG_HW_BOARD_ACTION */
+    }
+
+    case CCMSG_HW_LINK_ACTION:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_HW_LINK_ACTION (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwGenReq_t);
+
+      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
+
+      /* Hwardware procedure */
+      rc = ptin_msg_link_action(ptr);
+
+      /* Error? */
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+      /* Success */
+      SETIPCACKOK(outbuffer);
+      break;  /* CCMSG_HW_LINK_ACTION */
+    }
+
+    case CHMSG_UPLINKPROT_INFO:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_INFO (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_ATLEAST_ABS(sizeof(unsigned char) + sizeof(msg_HwEthInterface_t));
+
+      /* Execute command */
+      rc = ptin_msg_uplink_prot_info_get(inbuffer, outbuffer);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading info");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        return IPC_OK;
+      }
+
+      return IPC_OK;
+    }
+
+    case CHMSG_UPLINKPROT_SHOW:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_SHOW (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_ATLEAST_ABS(sizeof(unsigned char) + sizeof(unsigned short));
+
+      /* Execute command */
+      rc = ptin_msg_uplink_prot_config_get(inbuffer, outbuffer);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading status");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        return IPC_OK;
+      }
+
+      return IPC_OK;
+    }
+    break; /* CHMSG_UPLINKPROT_SHOW */
+
+    /* CHMSG_UPLINKPROT_STATE */
+    case CHMSG_UPLINKPROT_STATE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_STATE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_ATLEAST_ABS(sizeof(unsigned char) + sizeof(unsigned short));
+
+      /* Execute command */
+      rc = ptin_msg_uplink_prot_state(inbuffer, outbuffer);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading state");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        return IPC_OK;
+      }
+      return IPC_OK;
+    }
+    break; /* CHMSG_UPLINKPROT_STATE */
+
+    case CHMSG_UPLINKPROT_STATUS:
+    case CHMSG_UPLINKPROT_STATUSNEXT:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_STATUS (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_ATLEAST_ABS(sizeof(unsigned char) + sizeof(unsigned short));
+
+      /* Execute command */
+      rc = ptin_msg_uplink_prot_status(inbuffer, outbuffer);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading status");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        return IPC_OK;
+      }
+
+      return IPC_OK;
+    }
+    break; /* CHMSG_UPLINKPROT_STATUS */
+
+    /* Uplink protection applied to LAG interfaces */
+    case CHMSG_UPLINKPROT_CREATE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_CREATE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HWuplinkProtConf);
+
+      /* Hwardware procedure */
+      rc = ptin_msg_uplink_prot_create(inbuffer, outbuffer);
+
+      /* Error? */
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+      /* Success */
+      SETIPCACKOK(outbuffer);
+    }
+    break;  /*CHMSG_UPLINKPROT_CREATE*/
+
+    case CHMSG_UPLINKPROT_CONFIG:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_CONFIG (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HWuplinkProtConf);
+
+      /* Hwardware procedure */
+      rc = ptin_msg_uplink_prot_config(inbuffer, outbuffer);
+
+      /* Error? */
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+      /* Success */
+      SETIPCACKOK(outbuffer);
+    }
+    break; /* CHMSG_UPLINKPROT_CONFIG */
+
+    case CHMSG_UPLINKPROT_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_ATLEAST_ABS(sizeof(unsigned char) + sizeof(unsigned short));
+
+      /* Hwardware procedure */
+      rc = ptin_msg_uplink_prot_remove(inbuffer, outbuffer);
+
+      /* Error? */
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+      /* Success */
+      SETIPCACKOK(outbuffer);
+    }
+    break; /* CHMSG_UPLINKPROT_REMOVE */
+
+    case CHMSG_UPLINKPROT_COMMAND:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_UPLINKPROT_COMMAND (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HWuplinkProtCommand);
+
+      /* Hwardware procedure */
+      rc = ptin_msg_uplink_prot_command(inbuffer, outbuffer);
+
+      /* Error? */
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+      /* Success */
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /************************************************************************** 
+     * SLOT MODE CONFIGURATION
+     **************************************************************************/
+
+    case CCMSG_SLOT_MAP_MODE_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SLOT_MAP_MODE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_ATLEAST(L7_uint32);
+      msg_slotModeCfg_t *ptr;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_slotModeCfg_t));
+      ptr = (msg_slotModeCfg_t *) outbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_slotMode_get(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading slot map");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_slotModeCfg_t));
+    }
+    break;
+
+    case CCMSG_SLOT_MAP_MODE_VALIDATE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SLOT_MAP_MODE_VALIDATE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_slotModeCfg_t);
+
+      msg_slotModeCfg_t *ptr = (msg_slotModeCfg_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_slotMode_validate(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    case CCMSG_SLOT_MAP_MODE_APPLY:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SLOT_MAP_MODE_APPLY (0x%04X)", msgId);
+
+      //CHECK_INFO_SIZE_MOD(msg_slotModeCfg_t);
+
+      //msg_slotModeCfg_t *ptr = (msg_slotModeCfg_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_slotMode_apply();
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    case CCMSG_SWITCH_TEMPERATURE_GET:
+    {
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SWITCH_TEMPERATURE_GET (0x%04X)", msgId);
+
+      msg_ptin_temperature_monitor_t *ptr;
+
+      ptr = (msg_ptin_temperature_monitor_t *) outbuffer->info;
+      memset(ptr, 0x00, sizeof(msg_ptin_temperature_monitor_t));
+
+      /* Execute command */
+      rc = ptin_msg_switch_temperature_get(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading temperature");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_ptin_temperature_monitor_t));
+    }
+    break;
+
+    /************************************************************************** 
+     * PHY CONFIG Processing
+     **************************************************************************/
+
+    case CCMSG_ETH_OLTD_HW_CONFIG:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_OLTD_HW_CONFIG (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_OLTDHWConfig_t);
+
+      /* Execute command */
+      rc = ptin_msg_oltd_hw_config(inbuffer, outbuffer);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    case CCMSG_ETH_PHY_STATUS_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_STATUS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_ATLEAST(L7_uint32);
+
+      msg_HWEthPhyStatus_t *pin     = (msg_HWEthPhyStatus_t *) inbuffer->info;
+
+      #if (PTIN_SYSTEM_N_PONS > 0 || PTIN_SYSTEM_N_ETH > 0)
+      L7_uint i;
+      msg_HWEthPhyStatus_t *pout    = (msg_HWEthPhyStatus_t *) outbuffer->info;
+
+      /* Output info read */
+      PT_LOG_DEBUG(LOG_CTX_MSG, "Requesting...");
+      PT_LOG_DEBUG(LOG_CTX_MSG, " SlotId    = %u", ENDIAN_SWAP8(pin->SlotId));
+      PT_LOG_DEBUG(LOG_CTX_MSG, " BoardType = %u", ENDIAN_SWAP8(pin->BoardType));
+      PT_LOG_DEBUG(LOG_CTX_MSG, " PortId    = %u", ENDIAN_SWAP8(pin->Port));
+
+      /* Single port ? */
+      if (ENDIAN_SWAP8(pin->Port) < max(PTIN_SYSTEM_N_PONS, PTIN_SYSTEM_N_ETH))
+      {
+        memcpy(pout, pin, sizeof(msg_HWEthPhyStatus_t));
+
+        if (ptin_msg_PhyStatus_get(pout) != L7_SUCCESS)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port status (port# %u)", ENDIAN_SWAP8(pin->Port));
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPC_INFODIM(sizeof(msg_HWEthPhyStatus_t));
+      }
+      /* Swipe all ports */
+      else
+      {
+        for (i = 0; i < PTIN_SYSTEM_N_ETH; i++)
+        {
+          memcpy(&pout[i], pin, sizeof(msg_HWEthPhyStatus_t));
+          pout[i].Port = ENDIAN_SWAP8(i);
+
+          if (ptin_msg_PhyStatus_get(&pout[i]) != L7_SUCCESS)
+            break;
+        }
+
+        /* Error? */
+        if (i < PTIN_SYSTEM_N_ETH)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port Status (port# %u)", ENDIAN_SWAP8(pin->Port));
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPC_INFODIM(sizeof(msg_HWEthPhyStatus_t) * i);
+      }
+      #else
+      PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port Status (port# %u)", ENDIAN_SWAP8(pin->Port));
+      res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+      SetIPCNACK(outbuffer, res);
+      break;
+      #endif
+
+
+      break;  /* CCMSG_ETH_PHY_STATUS_GET */
+    }
+
+    /* CCMSG_ETH_PHY_CONFIG_SET ***********************************************/
+    case CCMSG_ETH_PHY_CONFIG_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_CONFIG_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HWEthPhyConf_t);
+
+      L7_uint i, n;
+      msg_HWEthPhyConf_t *pi = (msg_HWEthPhyConf_t *) &inbuffer->info[0];
+
+      /* Validate info size */
+      if ( (infoDim < sizeof(msg_HWEthPhyConf_t)) || ((infoDim % sizeof(msg_HWEthPhyConf_t)) != 0) )
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! (%u)", infoDim);
+        res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      n = MSG_N_ELEMS(sizeof(msg_HWEthPhyConf_t));
+      if (n > PTIN_SYSTEM_N_PORTS)
+        n = PTIN_SYSTEM_N_PORTS;
+
+      /* Apply config */
+      for (i = 0; i < n; i++)
+        if (L7_SUCCESS != ptin_msg_PhyConfig_set(&pi[i]))
+          break;
+
+      if (i != n)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting ports configuration (port# %u)", i);
+        res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_PHY_CONFIG_SET */
+    }
+
+
+    /* CCMSG_ETH_PHY_CONFIG_GET ***********************************************/
+    case CCMSG_ETH_PHY_CONFIG_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_CONFIG_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwGenReq_t);
+
+      L7_uint i;
+      msg_HwGenReq_t     *req  = (msg_HwGenReq_t *) &inbuffer->info[0];
+      msg_HWEthPhyConf_t *pout = (msg_HWEthPhyConf_t *) &outbuffer->info[0];
+      msg_HWEthPhyConf_t  pin[1];
+
+      /* Reference structure */
+      memset(pin,0x00,sizeof(msg_HWEthPhyConf_t));
+      pin->SlotId = req->slot_id;
+      pin->Port   = req->generic_id;
+      pin->Mask   = ENDIAN_SWAP16(0xffff);
+
+      /* Single port ? */
+      if (pin->Port < PTIN_SYSTEM_N_PORTS)
+      {
+        memcpy(pout, pin, sizeof(msg_HWEthPhyConf_t));
+
+        if (ptin_msg_PhyConfig_get(pout) != L7_SUCCESS)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port configuration (port# %u)", ENDIAN_SWAP8(pin->Port));
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPC_INFODIM(sizeof(msg_HWEthPhyConf_t));
+      }
+      /* Swipe all ports */
+      else
+      {
+        for (i = 0; i < PTIN_SYSTEM_N_PORTS; i++)
+        {
+          memcpy(&pout[i], pin, sizeof(msg_HWEthPhyConf_t));
+          pout[i].Port = ENDIAN_SWAP8(i);
+
+          if (ptin_msg_PhyConfig_get(&pout[i]) != L7_SUCCESS)
+            break;
+        }
+
+        /* Error? */
+        if (i != PTIN_SYSTEM_N_PORTS)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port configuration (port# %u)", ENDIAN_SWAP8(pin->Port));
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPC_INFODIM(sizeof(msg_HWEthPhyConf_t) * i);
+      }
+
+
+      break;  /* CCMSG_ETH_PHY_CONFIG_GET */
+    }
+
+
+    /* CCMSG_ETH_PHY_STATE_GET ************************************************/
+    case CCMSG_ETH_PHY_STATE_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_STATE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwGenReq_t);
+
+      L7_uint i;
+      msg_HwGenReq_t      *request = (msg_HwGenReq_t *) inbuffer->info;
+      msg_HWEthPhyState_t *pout    = (msg_HWEthPhyState_t *) outbuffer->info;
+      msg_HWEthPhyState_t  pin[1];
+
+      /* Reference structure */
+      memset(pin,0x00,sizeof(msg_HWEthPhyState_t));
+      pin->SlotId = request->slot_id;
+      pin->Port   = request->generic_id;
+      pin->Mask   = ENDIAN_SWAP16(0xffff);
+
+      /* Single port ? */
+      if (ENDIAN_SWAP8(pin->Port) < PTIN_SYSTEM_N_PORTS)
+      {
+        memcpy(pout, pin, sizeof(msg_HWEthPhyState_t));
+
+        if (ptin_msg_PhyState_get(pout) != L7_SUCCESS)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port state (port# %u)", ENDIAN_SWAP8(pin->Port));
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPC_INFODIM(sizeof(msg_HWEthPhyState_t));
+      }
+      /* Swipe all ports */
+      else
+      {
+        for (i = 0; i < PTIN_SYSTEM_N_PORTS; i++)
+        {
+          memcpy(&pout[i], pin, sizeof(msg_HWEthPhyState_t));
+          pout[i].Port = ENDIAN_SWAP8(i);
+
+          if (ptin_msg_PhyState_get(&pout[i]) != L7_SUCCESS)
+            break;
+        }
+
+        /* Error? */
+        if (i != PTIN_SYSTEM_N_PORTS)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port state (port# %u)", ENDIAN_SWAP8(pin->Port));
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPC_INFODIM(sizeof(msg_HWEthPhyState_t) * i);
+      }
+
+
+      break;  /* CCMSG_ETH_PHY_STATE_GET */
+    }
+
+    /************************************************************************** 
+     * PHY COUNTERS Processing
+     **************************************************************************/
+
+    /* CCMSG_ETH_PHY_COUNTERS_GET *********************************************/
+    case CCMSG_ETH_PHY_COUNTERS_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_COUNTERS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HwGenReq_t);
+
+      msg_HwGenReq_t                    *request;
+      msg_HWEthRFC2819_PortStatistics_t *portStats;
+      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_HwGenReq_t));
+
+      request   = (msg_HwGenReq_t *) inbuffer->info;
+      portStats = (msg_HWEthRFC2819_PortStatistics_t *) outbuffer->info;
+
+      /* Get values */
+      if (L7_SUCCESS != ptin_msg_PhyCounters_read(request, portStats, nElems))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting counters (port# %u)", ENDIAN_SWAP8(portStats->Port));
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_HWEthRFC2819_PortStatistics_t)*nElems);
+      break;  /* CCMSG_ETH_PHY_COUNTERS_GET */
+    }
+
+
+    /* CCMSG_ETH_PHY_COUNTERS_CLEAR *******************************************/
+    case CCMSG_ETH_PHY_COUNTERS_CLEAR:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_COUNTERS_CLEAR (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HWEthRFC2819_PortStatistics_t);
+
+      msg_HWEthRFC2819_PortStatistics_t *portStats;
+      portStats = (msg_HWEthRFC2819_PortStatistics_t *) inbuffer->info;
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_PhyCounters_clear(portStats))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing counters (port# %u)", ENDIAN_SWAP8(portStats->Port));
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);      
+      break; /* CCMSG_ETH_PHY_COUNTERS_CLEAR */
+    }
+
+    /************************************************************************** 
+     * Port Type Settings
+     **************************************************************************/
+
+    /* Set Port type (MEF extension) configuration */
+    case CCMSG_ETH_PORT_EXT_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_EXT_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HWPortExt_t);
+
+      msg_HWPortExt_t *ptr = (msg_HWPortExt_t *) inbuffer->info;
+      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_HWPortExt_t));
+
+      /* Execute command */
+      rc = ptin_msg_portExt_set(ptr, nElems);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Get Port type (MEF extension) configuration */
+    case CCMSG_ETH_PORT_EXT_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_TYPE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HWPortExt_t);
+
+      msg_HWPortExt_t *ptr;
+      L7_uint          nElems;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HWPortExt_t));
+      ptr = (msg_HWPortExt_t *) outbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_portExt_get(ptr,&nElems);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_HWPortExt_t) * nElems);
+    }
+    break;
+
+    /* Set MAC address */
+    case CCMSG_ETH_PORT_MAC_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_MAC_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HWPortMac_t);
+
+      msg_HWPortMac_t *ptr = (msg_HWPortMac_t *) inbuffer->info;
+      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_HWPortMac_t));
+
+      /* Execute command */
+      rc = ptin_msg_portMAC_set(ptr, nElems);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Get MAC address */
+    case CCMSG_ETH_PORT_MAC_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_MAC_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HWPortMac_t);
+
+      msg_HWPortMac_t *ptr;
+      L7_uint          nElems;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HWPortMac_t));
+      ptr = (msg_HWPortMac_t *) outbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_portMAC_get(ptr, &nElems);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error reading data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_HWPortMac_t) * nElems);
+    }
+    break;
+
+    /************************************************************************** 
+     * QoS Processing
+     **************************************************************************/
+
+    /* Get CoS configuration */
+    case CCMSG_ETH_PORT_COS_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_QoSConfiguration_t);
+
+      msg_QoSConfiguration_t *ptr;
+      ptr = (msg_QoSConfiguration_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_QoSConfiguration_t));
+
+      /* Execute command */
+      rc = ptin_msg_CoS_get(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_QoSConfiguration_t));
+    }
+    break;
+
+    /* Set new CoS configuration */
+    case CCMSG_ETH_PORT_COS_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_QoSConfiguration_t);
+
+      msg_QoSConfiguration_t *ptr;
+      ptr = (msg_QoSConfiguration_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_CoS_set(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Get CoS configuration */
+    case CCMSG_ETH_PORT_COS2_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS2_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_QoSConfiguration2_t);
+
+      msg_QoSConfiguration2_t *ptr;
+      ptr = (msg_QoSConfiguration2_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_QoSConfiguration2_t));
+
+      /* Execute command */
+      rc = ptin_msg_CoS2_get(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_QoSConfiguration2_t));
+    }
+    break;
+
+    /* Set new CoS configuration */
+    case CCMSG_ETH_PORT_COS2_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS2_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_QoSConfiguration2_t);
+
+      msg_QoSConfiguration2_t *ptr;
+      ptr = (msg_QoSConfiguration2_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_CoS2_set(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Get CoS configuration */
+    case CCMSG_ETH_PORT_COS3_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS3_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_QoSConfiguration3_t);
+
+      msg_QoSConfiguration3_t *ptr;
+      ptr = (msg_QoSConfiguration3_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_QoSConfiguration3_t));
+
+      /* Execute command */
+      rc = ptin_msg_CoS3_get(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_QoSConfiguration3_t));
+    }
+    break;
+
+    /* Set new CoS configuration */
+    case CCMSG_ETH_PORT_COS3_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS3_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_QoSConfiguration3_t);
+
+      msg_QoSConfiguration3_t *ptr;
+      ptr = (msg_QoSConfiguration3_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_CoS3_set(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /************************************************************************** 
+     * LAGs Processing
+     **************************************************************************/
+
+    /* CCMSG_ETH_LACP_LAG_GET *************************************************/
+    case CCMSG_ETH_LACP_LAG_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_LACPLagInfo_t);
+
+      msg_LACPLagInfo_t *request = (msg_LACPLagInfo_t *) inbuffer->info;
+      msg_LACPLagInfo_t *lagInfo = (msg_LACPLagInfo_t *) outbuffer->info;
+      L7_uint            nElems;
+
+      memcpy(lagInfo, request, sizeof(msg_LACPLagInfo_t));
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_Lag_get(lagInfo, &nElems))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting LAGs info");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_LACPLagInfo_t) * nElems);
+
+      break;  /* CCMSG_ETH_LACP_LAG_GET */
+    }
+
+
+    /* CCMSG_ETH_LACP_LAG_ADD *************************************************/
+    case CCMSG_ETH_LACP_LAG_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_LACPLagInfo_t);
+
+      msg_LACPLagInfo_t *lagInfo;
+      lagInfo = (msg_LACPLagInfo_t *) inbuffer->info;
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_Lag_create(lagInfo))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while creating a LAG");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_LACP_LAG_ADD */
+    }
+
+
+    /* CCMSG_ETH_LACP_LAG_REMOVE **********************************************/
+    case CCMSG_ETH_LACP_LAG_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_LACPLagInfo_t);
+
+      msg_LACPLagInfo_t *lagInfo;
+      lagInfo = (msg_LACPLagInfo_t *) inbuffer->info;
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_Lag_destroy(lagInfo))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while destroying a LAG");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+      break;  /* CCMSG_ETH_LACP_LAG_REMOVE */
+    }
+
+
+    /* CCMSG_ETH_LACP_LAG_STATUS_GET ******************************************/
+    case CCMSG_ETH_LACP_LAG_STATUS_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_STATUS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_LACPLagStatus_t);
+
+      msg_LACPLagStatus_t *request   = (msg_LACPLagStatus_t *) inbuffer->info;
+      msg_LACPLagStatus_t *lagStatus = (msg_LACPLagStatus_t *) outbuffer->info;
+      L7_uint              nElems=0;
+
+      memcpy(lagStatus, request, sizeof(msg_LACPLagStatus_t));
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_LagStatus_get(lagStatus, &nElems))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting LAGs status");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_LACPLagStatus_t) * nElems);
+      break;  /* CCMSG_ETH_LACP_LAG_STATUS_GET */
+    }
+
+
+    /* CCMSG_ETH_LACP_ADMINSTATE_SET ******************************************/
+    case CCMSG_ETH_LACP_ADMINSTATE_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_ADMINSTATE_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_LACPAdminState_t);
+
+      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_LACPAdminState_t));
+      msg_LACPAdminState_t *lagAdminState = (msg_LACPAdminState_t *) inbuffer->info;
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_LACPAdminState_set(lagAdminState, nElems))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting LACP admin state");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_LACP_ADMINSTATE_SET */
+    }
+
+
+    /* CCMSG_ETH_LACP_ADMINSTATE_GET ******************************************/
+    case CCMSG_ETH_LACP_ADMINSTATE_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_ADMINSTATE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_LACPAdminState_t);
+
+      L7_uint nElems;
+      msg_LACPAdminState_t *request       = (msg_LACPAdminState_t *) inbuffer->info;
+      msg_LACPAdminState_t *lagAdminState = (msg_LACPAdminState_t *) outbuffer->info;
+
+      memcpy(lagAdminState, request, sizeof(msg_LACPAdminState_t));
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_LACPAdminState_get(lagAdminState, &nElems))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting LACP admin state");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_LACPAdminState_t) * nElems);
+      break;  /* CCMSG_ETH_LACP_ADMINSTATE_GET */
+    }
+
+
+    /* CCMSG_ETH_LACP_STATS_GET ***********************************************/
+    case CCMSG_ETH_LACP_STATS_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_STATS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_LACPStats_t);
+
+      L7_uint nElems;
+      msg_LACPStats_t  *request = (msg_LACPStats_t *) inbuffer->info;
+      msg_LACPStats_t *lagStats = (msg_LACPStats_t *) outbuffer->info;
+
+      /* Note: the index field provides the LAG nr (if out of range, all LAGs are returned) */
+      memcpy(lagStats, request, sizeof(msg_LACPStats_t));
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_LACPStats_get(lagStats, &nElems))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting LACP stats");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_LACPStats_t) * nElems);
+      break;  /* CCMSG_ETH_LACP_STATS_GET */
+    }
+
+
+    /* CCMSG_ETH_LACP_STATS_CLEAR *********************************************/
+    case CCMSG_ETH_LACP_STATS_CLEAR:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_STATS_CLEAR (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_LACPStats_t);
+
+      msg_LACPStats_t *lagStats;
+      lagStats = (msg_LACPStats_t *) inbuffer->info;
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_LACPStats_clear(lagStats))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing LACP stats");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_LACP_STATS_CLEAR */
+    }
+
+    /************************************************************************** 
+     * L2 Table Processing
+     **************************************************************************/
+
+    /* L2 Aging get */
+    case CCMSG_ETH_SWITCH_CONFIG_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_SWITCH_CONFIG_GET (0x%04X)", msgId);
+      CHECK_INFO_SIZE(msg_switch_config_t);
+
+      msg_switch_config_t *switch_config = (msg_switch_config_t *) &outbuffer->info[0];
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_switch_config_t));
+
+      /* Execute command */
+      rc = ptin_msg_l2_switch_config_get(switch_config);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting config");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_HwEthMef10Evc_t));
+    }
+    break;
+
+    /* L2 Aging set */
+    case CCMSG_ETH_SWITCH_CONFIG_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_SWITCH_CONFIG_SET (0x%04X)", msgId);
+      CHECK_INFO_SIZE(msg_switch_config_t);
+
+      msg_switch_config_t *switch_config = (msg_switch_config_t *) &inbuffer->info[0];
+
+      /* Execute command */
+      rc = ptin_msg_l2_switch_config_set(switch_config);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Get L2 table */
+    case CCMSG_ETH_MAC_TABLE_SHOW:
+    case CCMSG_ETH_MAC_TABLE_SHOW2:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_MAC_TABLE_SHOW (0x%04X)", msgId);
+      CHECK_INFO_SIZE(msg_switch_mac_intro_t);
+
+      msg_switch_mac_table_t *mac_table = (msg_switch_mac_table_t *) outbuffer->info;
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_switch_mac_intro_t));
+
+      /* Execute command */
+      rc = ptin_msg_l2_macTable_get(mac_table, ((CCMSG_ETH_MAC_TABLE_SHOW == msgId) ? 1 : 2));
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting MAC list");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_switch_mac_table_t));
+    }
+    break;
+
+    /* Remove an entry of the L2 table */
+    case CCMSG_ETH_MAC_ENTRY_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_MAC_ENTRY_REMOVE (0x%04X)", msgId);
+      CHECK_INFO_SIZE(msg_switch_mac_table_entry_t);
+
+      msg_switch_mac_table_entry_t *mac_table = (msg_switch_mac_table_entry_t *) inbuffer->info;
+      L7_uint32 n = MSG_N_ELEMS(sizeof(msg_switch_mac_table_entry_t));
+
+      /* Execute command */
+      rc = ptin_msg_l2_macTable_remove(mac_table, n);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing MAC");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Add an entry to the L2 table */
+    case CCMSG_ETH_MAC_ENTRY_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_MAC_ENTRY_ADD (0x%04X)", msgId);
+      CHECK_INFO_SIZE(msg_switch_mac_table_entry_t);
+
+      msg_switch_mac_table_entry_t *mac_table = (msg_switch_mac_table_entry_t *) inbuffer->info;
+      L7_uint32 n = MSG_N_ELEMS(sizeof(msg_switch_mac_table_entry_t));
+
+      /* Execute command */
+      rc = ptin_msg_l2_macTable_add(mac_table, n);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding MAC");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /************************************************************************** 
+     * Dynamic ARP Inspection
+     **************************************************************************/
+    /* Dynamic ARP Inspection */
+    case CCMSG_ETH_DAI_GLOBAL_CONFIG:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_GLOBAL_CONFIG (0x%04X)", msgId);
+      CHECK_INFO_SIZE(msg_dai_global_settings_t);
+
+      msg_dai_global_settings_t *config = (msg_dai_global_settings_t *) &inbuffer->info[0];
+
+      /* Execute command */
+      rc = ptin_msg_dai_global_config(config);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    case CCMSG_ETH_DAI_INTF_CONFIG:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_INTF_CONFIG (0x%04X)", msgId);
+      CHECK_INFO_SIZE_MOD(msg_dai_intf_settings_t);
+
+      msg_dai_intf_settings_t *config = (msg_dai_intf_settings_t *) &inbuffer->info[0];
+      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_dai_intf_settings_t));
+
+      /* Execute command */
+      rc = ptin_msg_dai_intf_config(config, nElems);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    case CCMSG_ETH_DAI_VLAN_CONFIG:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_VLAN_CONFIG (0x%04X)", msgId);
+      CHECK_INFO_SIZE_MOD(msg_dai_vlan_settings_t);
+
+      msg_dai_vlan_settings_t *config = (msg_dai_vlan_settings_t *) &inbuffer->info[0];
+      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_dai_vlan_settings_t));
+
+      /* Execute command */
+      rc = ptin_msg_dai_vlan_config(config, nElems);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    case CCMSG_ETH_DAI_STATISTICS:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_STATISTICS (0x%04X)", msgId);
+      CHECK_INFO_SIZE_MOD(msg_dai_statistics_t);
+
+      /* Copy input to output */
+      memcpy(outbuffer->info, inbuffer->info, infoDim);
+
+      msg_dai_statistics_t *stats = (msg_dai_statistics_t *) &outbuffer->info[0];
+      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_dai_statistics_t));
+
+      /* Execute command */
+      rc = ptin_msg_dai_stats_get(stats, nElems);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_dai_statistics_t)*nElems);
+    }
+    break;
+
+    /************************************************************************** 
+     * EVCs Processing
+     **************************************************************************/
+
+    /* CCMSG_ETH_EVC_GET ******************************************************/
+    case CCMSG_ETH_EVC_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_GET (0x%04X)", msgId);
+  
+      CHECK_INFO_SIZE(msg_HwEthMef10Evc_t);
+
+      msg_HwEthMef10Evc_t *evcConf;
+      evcConf = (msg_HwEthMef10Evc_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwEthMef10Evc_t));
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_EVC_get(evcConf))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting EVC# %u config", ENDIAN_SWAP32(evcConf->id));
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_HwEthMef10Evc_t));
+      break;  /* CCMSG_ETH_EVC_GET */
+    }
+
+
+    /* CCMSG_ETH_EVC_ADD ******************************************************/
+    case CCMSG_ETH_EVC_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_ATLEAST(msg_HwEthMef10Evc_t);
+
+      /* Execute command */
+      rc = ptin_msg_EVC_create(inbuffer, outbuffer);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while creating EVC");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_ADD */
+    }
+
+    /* CCMSG_ETH_EVC_REMOVE ***************************************************/
+    case CCMSG_ETH_EVC_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HwEthMef10EvcRemove_t);
+
+      msg_HwEthMef10EvcRemove_t *evcConf = (msg_HwEthMef10EvcRemove_t *) inbuffer->info;
+      L7_uint16 n_structs = MSG_N_ELEMS(sizeof(msg_HwEthMef10EvcRemove_t));
+
+      /* Execute command */
+      rc = ptin_msg_EVC_delete(evcConf, n_structs);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while deleting EVCs");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_REMOVE */
+    }
+
+    /* CCMSG_ETH_EVC_PORT_ADD ******************************************************/
+    case CCMSG_ETH_EVC_PORT_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_PORT_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HWevcPort_t);
+
+      msg_HWevcPort_t *evcPort = (msg_HWevcPort_t *) inbuffer->info;
+      L7_uint16        n_size  = MSG_N_ELEMS(sizeof(msg_HWevcPort_t));
+
+      /* Execute command */
+      rc = ptin_msg_evc_port(evcPort, n_size, PTIN_MSG_OPER_ADD);
+
+      if (L7_SUCCESS != rc)
+      {       
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding port to EVC [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_PORT_ADD */
+    }
+
+    /* CCMSG_ETH_EVC_PORT_REMOVE ***************************************************/
+    case CCMSG_ETH_EVC_PORT_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_PORT_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HWevcPort_t);
+
+      msg_HWevcPort_t *evcPort = (msg_HWevcPort_t *) inbuffer->info;
+      L7_uint16        n_size  = MSG_N_ELEMS(sizeof(msg_HWevcPort_t));
+
+      /* Execute command */
+      rc = ptin_msg_evc_port(evcPort, n_size, PTIN_MSG_OPER_REMOVE);
+
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding port to EVC [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_PORT_REMOVE */
+    }
+
+    /* CCMSG_ETH_EVC_OPTIONS_SET *************************************************/
+    case CCMSG_ETH_EVC_OPTIONS_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_OPTIONS_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HwEthMef10EvcOptions_t);
+
+      /* Execute command */
+      rc = ptin_msg_evc_config(inbuffer, outbuffer);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while reconfiguring EVC");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_ADD */
+    }
+
+    case CCMSG_ETH_EVC_QOS_SET:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_QOS_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_evc_qos_t);
+
+      /* Execute command */
+      rc = ptin_msg_evc_qos_set(inbuffer, outbuffer);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while configuring QoS");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_QOS_SET */
+
+    /* CCMSG_ETH_EVC_BRIDGE_ADD ***********************************************/
+    case CCMSG_ETH_EVC_BRIDGE_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_BRIDGE_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthEvcBridge_t);
+
+      msg_HwEthEvcBridge_t *evcBridge;
+      evcBridge = (msg_HwEthEvcBridge_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_EVCBridge_add(evcBridge);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding a bridge to EVC# %u", ENDIAN_SWAP32(evcBridge->evcId));
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_BRIDGE_ADD */
+    }
+
+
+    /* CCMSG_ETH_EVC_BRIDGE_REMOVE ********************************************/
+    case CCMSG_ETH_EVC_BRIDGE_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_BRIDGE_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthEvcBridge_t);
+
+      msg_HwEthEvcBridge_t *evcBridge;
+      evcBridge = (msg_HwEthEvcBridge_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_EVCBridge_remove(evcBridge);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing a bridge to EVC# %u", ENDIAN_SWAP32(evcBridge->evcId));
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_BRIDGE_REMOVE */
+    }
+
+    /* CCMSG_ETH_EVC_FLOW_ADD ***********************************************/
+    case CCMSG_ETH_EVC_FLOW_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOW_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthEvcFlow_t);
+
+      msg_HwEthEvcFlow_t *evcFlow;
+      evcFlow = (msg_HwEthEvcFlow_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_EVCFlow_add(evcFlow);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding a flow to eEVC# %u", ENDIAN_SWAP32(evcFlow->evcId));
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_FLOW_ADD */
+    }
+
+    /* CCMSG_ETH_EVC_FLOW_REMOVE ********************************************/
+    case CCMSG_ETH_EVC_FLOW_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOW_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthEvcFlow_t);
+
+      msg_HwEthEvcFlow_t *evcFlow;
+      evcFlow = (msg_HwEthEvcFlow_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_EVCFlow_remove(evcFlow);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing a flow from eEVC# %u", ENDIAN_SWAP32(evcFlow->evcId));
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_BRIDGE_REMOVE */
+    }
+
+    /* Add vlan to be flooded */
+    case CCMSG_ETH_EVC_FLOOD_VLAN_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOOD_VLAN_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HwEthEvcFloodVlan_t);
+
+      msg_HwEthEvcFloodVlan_t *evcFlood;
+      L7_uint32 n_clients;
+
+      evcFlood  = (msg_HwEthEvcFloodVlan_t *) inbuffer->info;
+      n_clients = MSG_N_ELEMS(sizeof(msg_HwEthEvcFloodVlan_t));
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_EvcFloodVlan_add(evcFlood, n_clients))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding a flood vlan to EVC# %u", ENDIAN_SWAP32(evcFlood->evcId));
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_FLOOD_VLAN_ADD */
+    }
+
+    /* Remove vlan to be flooded */
+    case CCMSG_ETH_EVC_FLOOD_VLAN_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOOD_VLAN_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HwEthEvcFloodVlan_t);
+
+      msg_HwEthEvcFloodVlan_t *evcFlood;
+      L7_uint32 n_clients;
+
+      evcFlood  = (msg_HwEthEvcFloodVlan_t *) inbuffer->info;
+      n_clients = MSG_N_ELEMS(sizeof(msg_HwEthEvcFloodVlan_t));
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_EvcFloodVlan_remove(evcFlood, n_clients))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing a flood vlan to EVC# %u", ENDIAN_SWAP32(evcFlood->evcId));
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_FLOOD_VLAN_ADD */
+    }
+
+    /************************************************************************** 
+     * EVCs Counters config
+     **************************************************************************/
+
+    /* CCMSG_ETH_EVC_COUNTERS_GET *********************************************/
+    case CCMSG_ETH_EVC_COUNTERS_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_COUNTERS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_evcStats_t);
+
+      msg_evcStats_t *evcstat_in, *evcstat_out;
+      evcstat_in  = (msg_evcStats_t *) inbuffer->info;
+      evcstat_out = (msg_evcStats_t *) outbuffer->info;
+
+      memcpy(evcstat_out, evcstat_in, sizeof(msg_evcStats_t));
+
+      /* Execute command */
+      rc = ptin_msg_evcStats_get(evcstat_out);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while reading EVC stats");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_evcStats_t));
+      break;  /* CCMSG_ETH_EVC_COUNTERS_GET */
+    }
+
+
+    /* CCMSG_ETH_EVC_COUNTERS_ADD *********************************************/
+    case CCMSG_ETH_EVC_COUNTERS_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_COUNTERS_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_evcStats_t);
+
+      msg_evcStats_t *evc_stat;
+      evc_stat = (msg_evcStats_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_evcStats_set(evc_stat);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding EVC stats");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_COUNTERS_ADD */
+    }
+
+    /* CCMSG_ETH_EVC_COUNTERS_REMOVE ******************************************/
+    case CCMSG_ETH_EVC_COUNTERS_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_COUNTERS_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_evcStats_t);
+
+      msg_evcStats_t *evc_stat;
+      evc_stat = (msg_evcStats_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_evcStats_delete(evc_stat);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing EVC stats");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_EVC_COUNTERS_REMOVE */
+    }
+
+
+    /************************************************************************** 
+     * Bandwidth profiles Config
+     **************************************************************************/
+
+    /* CCMSG_ETH_BW_PROFILE_GET ***********************************************/
+    case CCMSG_ETH_BW_PROFILE_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_BW_PROFILE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthBwProfile_t);
+
+      msg_HwEthBwProfile_t *bwProfile_in, *bwProfile_out;
+      bwProfile_in  = (msg_HwEthBwProfile_t *) inbuffer->info;
+      bwProfile_out = (msg_HwEthBwProfile_t *) outbuffer->info;
+
+      memcpy(bwProfile_out,bwProfile_in,sizeof(msg_HwEthBwProfile_t));
+
+      /* Execute command */
+      rc = ptin_msg_bwProfile_get(bwProfile_out);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting BW profile");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_HwEthBwProfile_t));
+      break;  /* CCMSG_ETH_BW_PROFILE_GET */
+    }
+
+
+    /* CCMSG_ETH_BW_PROFILE_SET ***********************************************/
+    case CCMSG_ETH_BW_PROFILE_SET:
+    case CCMSG_ETH_BW_PROFILE_SET_II:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_BW_PROFILE_SET (0x%04X)", msgId);
+
+      if (CCMSG_ETH_BW_PROFILE_SET == msgId) CHECK_INFO_SIZE(msg_HwEthBwProfile_t)
+      else                                   CHECK_INFO_SIZE(msg_HwEthBwProfile_II_t)
+
+      msg_HwEthBwProfile_t *bwProfile;
+      bwProfile = (msg_HwEthBwProfile_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_bwProfile_set(bwProfile, msgId);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting BW profile");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_BW_PROFILE_SET */
+    }
+
+
+    /* CCMSG_ETH_BW_PROFILE_DELETE ********************************************/
+    case CCMSG_ETH_BW_PROFILE_DELETE:
+    case CCMSG_ETH_BW_PROFILE_DELETE_II:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_BW_PROFILE_DELETE (0x%04X)", msgId);
+
+      if (CCMSG_ETH_BW_PROFILE_DELETE == msgId) CHECK_INFO_SIZE(msg_HwEthBwProfile_t)
+      else                                      CHECK_INFO_SIZE(msg_HwEthBwProfile_II_t)
+
+      msg_HwEthBwProfile_t *bwProfile;
+      bwProfile = (msg_HwEthBwProfile_t *) inbuffer->info;
+
+      rc = ptin_msg_bwProfile_delete(bwProfile, msgId);
+
+      /* Execute command */
+      if ( L7_SUCCESS != rc )
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing BW profile");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_BW_PROFILE_DELETE */
+    }
+
+    /* CCMSG_ETH_STORM_CONTROL_GET ***********************************************/
+    case CCMSG_ETH_STORM_CONTROL_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthStormControl_t);
+
+      msg_HwEthStormControl_t *stormControl_in, *stormControl_out;
+      stormControl_in  = (msg_HwEthStormControl_t *) inbuffer->info;
+      stormControl_out = (msg_HwEthStormControl_t *) outbuffer->info;
+
+      memcpy(stormControl_out, stormControl_in, sizeof(msg_HwEthStormControl_t));
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_stormControl_get(stormControl_out))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting Storm Control profile");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_HwEthStormControl_t));
+      break;  /* CCMSG_ETH_STORM_CONTROL_GET */
+    }
+
+    /* CCMSG_ETH_STORM_CONTROL_SET ***********************************************/
+    case CCMSG_ETH_STORM_CONTROL_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthStormControl_t);
+
+      msg_HwEthStormControl_t *stormControl;
+      stormControl = (msg_HwEthStormControl_t *) inbuffer->info;
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_stormControl_set(stormControl))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting Storm Control profile");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_STORM_CONTROL_SET */
+    }
+
+    /* CCMSG_ETH_STORM_CONTROL_RESET *********************************************/
+    case CCMSG_ETH_STORM_CONTROL_RESET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_RESET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthStormControl_t);
+
+      msg_HwEthStormControl_t *stormControl;
+      stormControl = (msg_HwEthStormControl_t *) inbuffer->info;
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_stormControl_reset(stormControl))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while resetting Storm Control profile");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_STORM_CONTROL_RESET */
+    }
+
+    /* CCMSG_ETH_STORM_CONTROL_CLEAR ********************************************/
+    case CCMSG_ETH_STORM_CONTROL_CLEAR:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_CLEAR (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthStormControl_t);
+
+      msg_HwEthStormControl_t *stormControl;
+      stormControl = (msg_HwEthStormControl_t *) inbuffer->info;
+
+      rc = ptin_msg_stormControl_clear(stormControl);
+
+      /* Execute command */
+      if ( L7_SUCCESS != rc )
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing Storm Control profile");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_BW_PROFILE_DELETE */
+    }
+
+    /* CCMSG_ETH_STORMCONTROL2_GET ***********************************************/
+    case CCMSG_ETH_STORMCONTROL2_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORMCONTROL2_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthStormControl2_t);
+
+      msg_HwEthStormControl2_t *stormControl_in, *stormControl_out;
+      stormControl_in  = (msg_HwEthStormControl2_t *) inbuffer->info;
+      stormControl_out = (msg_HwEthStormControl2_t *) outbuffer->info;
+
+      memcpy(stormControl_out, stormControl_in, sizeof(msg_HwEthStormControl2_t));
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_stormControl2_get(stormControl_out))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting StormControl2 profile");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_HwEthStormControl2_t));
+      break;  /* CCMSG_ETH_STORMCONTROL2_GET */
+    }
+
+    /* CCMSG_ETH_STORMCONTROL2_SET ***********************************************/
+    case CCMSG_ETH_STORMCONTROL2_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORMCONTROL2_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthStormControl2_t);
+
+      msg_HwEthStormControl2_t *stormControl;
+      stormControl = (msg_HwEthStormControl2_t *) inbuffer->info;
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_stormControl2_set(stormControl))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting StormControl2 profile");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_STORMCONTROL2_SET */
+    }
+
+    /************************************************************************** 
+     * inBand Config
+     **************************************************************************/
+
+    /* CCMSG_ETH_NTW_CONNECTIVITY_GET *****************************************/
+    case CCMSG_ETH_NTW_CONNECTIVITY_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_NTW_CONNECTIVITY_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_NtwConnectivity_t);
+
+      msg_NtwConnectivity_t *ntwConn;
+      ntwConn = (msg_NtwConnectivity_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_NtwConnectivity_t));
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_ntw_connectivity_get(ntwConn))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting Network Connectivity config");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_NtwConnectivity_t));
+      break;  /* CCMSG_ETH_NTW_CONNECTIVITY_GET */
+    }
+
+    /* CCMSG_ETH_NTW_CONNECTIVITY_SET *****************************************/
+    case CCMSG_ETH_NTW_CONNECTIVITY_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_NTW_CONNECTIVITY_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_NtwConnectivity_t);
+
+      msg_NtwConnectivity_t *ntwConn;
+      ntwConn = (msg_NtwConnectivity_t *) inbuffer->info;
+
+      /* Execute command */
+      if (L7_SUCCESS != ptin_msg_ntw_connectivity_set(ntwConn))
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting Network Connectivity config");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_NTW_CONNECTIVITY_SET */
+    }
+
+    /************************************************************************** 
+     * DHCP Relay Agent
+     **************************************************************************/
+
+    /* Reconfigure Global DHCP EVC ****************************/
+    case CCMSG_ETH_DHCP_EVC_RECONF:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_EVC_RECONF (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_DhcpEvcReconf_t);
+
+      msg_DhcpEvcReconf_t *ptr;
+      ptr = (msg_DhcpEvcReconf_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_DhcpEvcReconf_t));
+
+      /* Execute command */
+      rc = ptin_msg_DHCP_evc_reconf(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_DhcpEvcReconf_t));
+    }
+    break;
+
+    /* Configure DHCP circuit-id global components ****************************/
+    case CCMSG_ETH_DHCP_EVC_CIRCUITID_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_EVC_CIRCUITID_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_AccessNodeCircuitId_t);
+
+      msg_AccessNodeCircuitId_t *ptr;
+      ptr = (msg_AccessNodeCircuitId_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_AccessNodeCircuitId_t));
+
+      /* Execute command */
+      rc = ptin_msg_DHCP_circuitid_set(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_AccessNodeCircuitId_t));
+    }
+    break;
+
+    /* Get DHCP profile data **************************************************/
+    case CCMSG_ETH_DHCP_EVC_CIRCUITID_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_AccessNodeCircuitId_t);
+
+      msg_AccessNodeCircuitId_t *ptr;
+      ptr = (msg_AccessNodeCircuitId_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_AccessNodeCircuitId_t));
+
+      /* Execute command */
+      rc = ptin_msg_DHCP_circuitid_get(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_AccessNodeCircuitId_t));
+    }
+    break;
+
+    /* Get DHCP profile data **************************************************/
+    case CCMSG_ETH_DHCP_PROFILE_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwEthernetDhcpOpt82Profile_t);
+
+      msg_HwEthernetDhcpOpt82Profile_t *ptr;
+      ptr = (msg_HwEthernetDhcpOpt82Profile_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwEthernetDhcpOpt82Profile_t));
+
+      /* Execute command */
+      rc = ptin_msg_DHCP_profile_get(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_HwEthernetDhcpOpt82Profile_t));
+    }
+    break;
+
+    /* Add a new DHCP profile **************************************************/
+    case CCMSG_ETH_DHCP_PROFILE_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HwEthernetDhcpOpt82Profile_t);
+
+      msg_HwEthernetDhcpOpt82Profile_t *ptr;
+      ptr = (msg_HwEthernetDhcpOpt82Profile_t *) inbuffer->info;
+      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_HwEthernetDhcpOpt82Profile_t));
+
+      /* Execute command */
+      rc = ptin_msg_DHCP_profile_add(ptr, n_clients);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Remove a DHCP profile ****************************************************/
+    case CCMSG_ETH_DHCP_PROFILE_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HwEthernetDhcpOpt82Profile_t);
+
+      msg_HwEthernetDhcpOpt82Profile_t *ptr;
+      ptr = (msg_HwEthernetDhcpOpt82Profile_t *) inbuffer->info;
+      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_HwEthernetDhcpOpt82Profile_t));
+
+      rc = ptin_msg_DHCP_profile_remove(ptr, n_clients);
+
+      /* Execute command */
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Get client DHCP statistics */
+    case CCMSG_ETH_DHCP_CLIENT_STATS_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_CLIENT_STATS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
+
+      msg_DhcpClientStatistics_t *ptr;
+      ptr = (msg_DhcpClientStatistics_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_DhcpClientStatistics_t));
+
+      /* Execute command */
+      rc = ptin_msg_DHCP_clientStats_get(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_DhcpClientStatistics_t));
+    }
+    break;
+
+    /* Clear client DHCP statistics */
+    case CCMSG_ETH_DHCP_CLIENT_STATS_CLEAR:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_CLIENT_STATS_CLEAR (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
+
+      msg_DhcpClientStatistics_t *ptr;
+      ptr = (msg_DhcpClientStatistics_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_DHCP_clientStats_clear(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Get interface DHCP statistics */
+    case CCMSG_ETH_DHCP_INTF_STATS_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_INTF_STATS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
+
+      msg_DhcpClientStatistics_t *ptr;
+      ptr = (msg_DhcpClientStatistics_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_DhcpClientStatistics_t));
+
+      /* Execute command */
+      rc = ptin_msg_DHCP_intfStats_get(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting statistics");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_DhcpClientStatistics_t));
+    }
+    break;
+
+    /* Clear interface DHCP statistics */
+    case CCMSG_ETH_DHCP_INTF_STATS_CLEAR:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_INTF_STATS_CLEAR (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
+
+      msg_DhcpClientStatistics_t *ptr;
+      ptr = (msg_DhcpClientStatistics_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_DHCP_intfStats_clear(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Get DHCP Bind Table */
+    case CCMSG_ETH_DHCP_BIND_TABLE_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_BIND_TABLE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_DHCP_bind_table_request_t);
+
+      msg_DHCP_bind_table_request_t *pin;
+      msg_DHCPv4v6_bind_table_t     *pout;
+      pin  = (msg_DHCP_bind_table_request_t*) inbuffer->info;
+      pout = (msg_DHCPv4v6_bind_table_t *) outbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_DHCPv4v6_bindTable_get(pin, pout);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_DHCPv4v6_bind_table_t));
+    }
+    break;
+
+    /* Remove a DHCP Bind Table entry */
+    case CCMSG_ETH_DHCP_BIND_TABLE_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_BIND_TABLE_CLEAR (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_DHCP_bind_table_entry_t);
+
+      msg_DHCP_bind_table_entry_t *bind_table;
+      bind_table = (msg_DHCP_bind_table_entry_t *) inbuffer->info;
+      L7_uint32 n = MSG_N_ELEMS(sizeof(msg_DHCP_bind_table_entry_t));
+
+      /* Execute command */
+      rc = ptin_msg_DHCP_bindTable_remove(bind_table, n);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+    /************************************************************************** 
+    *                     IP Source Guard
+    **************************************************************************/
+   
+    case CCMSG_ETH_IPSG_ENABLE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IPSG_ENABLE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_IPSG_set_t);
+
+      msg_IPSG_set_t *ptr;
+      ptr = (msg_IPSG_set_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_ipsg_verify_source_set(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while configuring IP Source Guard");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break; 
+    }
+    case CCMSG_ETH_IPSG_STATIC_ENTRY:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IPSG_VERIFY_SOURCE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_IPSG_static_entry_t);
+
+      L7_uint16 n_msg;
+      msg_IPSG_static_entry_t *ptr;
+      ptr = (msg_IPSG_static_entry_t *) inbuffer->info;
+      n_msg = MSG_N_ELEMS(sizeof(msg_IPSG_static_entry_t));
+
+      /* Execute command */
+      rc = ptin_msg_ipsg_static_entry_set(ptr, n_msg);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while configuring an IP Source Guard Static Entry");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break; 
+    }
+
+    /************************************************************************** 
+     * IGMP Admission Control Config
+     **************************************************************************/
+
+    /* CCMSG_ETH_IGMP_ADMISSION_CONTROL ***********************************************/
+    case CCMSG_ETH_IGMP_ADMISSION_CONTROL:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_ADMISSION_CONTROL (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_IgmpAdmissionControl_t);
+
+      msg_IgmpAdmissionControl_t *igmpAdmissionControl;
+      igmpAdmissionControl = (msg_IgmpAdmissionControl_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpAdmissionControl_t));
+
+      /* Execute command */
+      rc = ptin_msg_igmp_admission_control_set(igmpAdmissionControl);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting Igmp Admission Control Config");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_IGMP_PROXY_SET */
+    }
+
+    /************************************************************************** 
+     * IGMP Proxy Config
+     **************************************************************************/
+
+    /* CCMSG_ETH_IGMP_PROXY_SET ***********************************************/
+    case CCMSG_ETH_IGMP_PROXY_SET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_PROXY_SET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_IgmpProxyCfg_t);
+
+      msg_IgmpProxyCfg_t *igmpProxy;
+      igmpProxy = (msg_IgmpProxyCfg_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpProxyCfg_t));
+
+      /* Execute command */
+      rc = ptin_msg_igmp_proxy_set(igmpProxy);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting IGMP Proxy config");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_IGMP_PROXY_SET */
+    }
+
+
+    /* CCMSG_ETH_IGMP_PROXY_GET ***********************************************/
+    case CCMSG_ETH_IGMP_PROXY_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_PROXY_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_IgmpProxyCfg_t);
+
+      msg_IgmpProxyCfg_t *igmpProxy;
+      igmpProxy = (msg_IgmpProxyCfg_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_igmp_proxy_get(igmpProxy);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting IGMP proxy configuration");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_IGMP_PROXY_GET */
+    }
+
+
+    /* CCMSG_ETH_IGMP_ENTRY_ADD ***********************************************/
+    case CCMSG_ETH_IGMP_ENTRY_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_ENTRY_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_IgmpMultcastUnicastLink_t);
+
+      msg_IgmpMultcastUnicastLink_t *igmpEntry;
+      igmpEntry = (msg_IgmpMultcastUnicastLink_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_igmp_instance_add(igmpEntry);
+
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding an IGMP entry [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_IGMP_ENTRY_ADD */
+    }
+
+    /* CCMSG_ETH_IGMP_ENTRY_REMOVE ********************************************/
+    case CCMSG_ETH_IGMP_ENTRY_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_ENTRY_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_IgmpMultcastUnicastLink_t);
+
+      msg_IgmpMultcastUnicastLink_t *igmpEntry;
+      igmpEntry = (msg_IgmpMultcastUnicastLink_t *) inbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_igmp_instance_remove(igmpEntry);
+
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing an IGMP entry [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_IGMP_ENTRY_REMOVE */
+    }
+
+    /* CCMSG_ETH_IGMP_CLIENT_ADD **********************************************/
+    case CCMSG_ETH_IGMP_CLIENT_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_IgmpClient_t);
+
+      msg_IgmpClient_t *igmpClient;
+      igmpClient = (msg_IgmpClient_t *) inbuffer->info;
+      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClient_t));
+
+      /* Execute command */
+      rc = ptin_msg_igmp_client_add(igmpClient, n_clients);
+
+      if (L7_SUCCESS != rc)
+      {       
+       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding an IGMP client [res:0x%x]", res);
+       SetIPCNACK(outbuffer, res);
+       break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_IGMP_CLIENT_ADD */
+    }
+
+    /* CCMSG_ETH_IGMP_CLIENT_REMOVE *******************************************/
+    case CCMSG_ETH_IGMP_CLIENT_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_IgmpClient_t);
+
+      msg_IgmpClient_t *igmpClient;
+      igmpClient = (msg_IgmpClient_t *) inbuffer->info;
+      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClient_t));
+
+      rc = ptin_msg_igmp_client_delete(igmpClient, n_clients);
+
+      /* Execute command */
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing IGMP client [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_IGMP_CLIENT_REMOVE */
+    }
+
+    /* CCMSG_ETH_IGMP_CLIENT_STATS_GET ****************************************/
+    case CCMSG_ETH_IGMP_CLIENT_STATS_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_STATS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
+
+      msg_IgmpClientStatistics_t *igmpClientStats;
+      igmpClientStats = (msg_IgmpClientStatistics_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpClientStatistics_t));
+
+      /* Execute command */
+      rc = ptin_msg_IGMP_clientStats_get(igmpClientStats);
+
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting IGMP client statistics [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_IgmpClientStatistics_t));
+
+      break;  /* CCMSG_ETH_IGMP_CLIENT_STATS_GET */
+    }
+
+
+    /* CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR **************************************/
+    case CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
+
+      msg_IgmpClientStatistics_t *igmpClient;
+      igmpClient = (msg_IgmpClientStatistics_t *) inbuffer->info;
+      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClientStatistics_t));
+
+      /* Execute command */
+      rc = ptin_msg_IGMP_clientStats_clear(igmpClient, n_clients);
+
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing IGMP client statistics [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+      break;  /* CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR */
+    }
+
+    /* CCMSG_ETH_IGMP_INTF_STATS_GET ******************************************/
+    case CCMSG_ETH_IGMP_INTF_STATS_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_INTF_STATS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
+
+      msg_IgmpClientStatistics_t *igmpPortStats;
+      igmpPortStats = (msg_IgmpClientStatistics_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpClientStatistics_t));
+
+      /* Execute command */
+      rc = ptin_msg_IGMP_intfStats_get(igmpPortStats);
+
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting IGMP port statistics [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_IgmpClientStatistics_t));
+      break;  /* CCMSG_ETH_IGMP_INTF_STATS_GET */
+    }
+
+
+    /* CCMSG_ETH_IGMP_INTF_STATS_CLEAR ****************************************/
+    case CCMSG_ETH_IGMP_INTF_STATS_CLEAR:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_INTF_STATS_CLEAR (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
+
+      msg_IgmpClientStatistics_t *igmpIntf;
+      igmpIntf = (msg_IgmpClientStatistics_t *) inbuffer->info;
+      L7_uint32 n_ports = MSG_N_ELEMS(sizeof(msg_IgmpClientStatistics_t));
+
+      /* Execute command */
+      rc = ptin_msg_IGMP_intfStats_clear(igmpIntf, n_ports);
+
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing IGMP client statistics [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_ETH_IGMP_INTF_STATS_CLEAR */
+    }
+
+    case CCMSG_ETH_IGMP_CHANNEL_ASSOC_GET:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_MCAssocChannel_t);
+
+      msg_MCAssocChannel_t *ptr;
+      L7_uint16             n=0;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_MCAssocChannel_t));
+      ptr = (msg_MCAssocChannel_t *) outbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_IGMP_ChannelAssoc_get(ptr, &n);
+
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting MC channels [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_MCAssocChannel_t) * n);
+    }
+    break;
+
+    case CCMSG_ETH_IGMP_CHANNEL_ASSOC_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_MCAssocChannel_t);
+
+      msg_MCAssocChannel_t *ptr;
+      L7_uint16             n;
+
+      ptr = (msg_MCAssocChannel_t *) inbuffer->info;
+      n = MSG_N_ELEMS(sizeof(msg_MCAssocChannel_t));
+
+      /* Execute command */
+      rc  = ptin_msg_group_list_add(ptr, n, L7_FALSE);
+
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error adding MC channels [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    case CCMSG_ETH_IGMP_CHANNEL_ASSOC_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_MCAssocChannel_t);
+
+      msg_MCAssocChannel_t *ptr;
+      L7_uint16             n;
+
+      ptr = (msg_MCAssocChannel_t *) inbuffer->info;
+      n = MSG_N_ELEMS(sizeof(msg_MCAssocChannel_t));
+
+      /* Execute command */
+      rc  = ptin_msg_group_list_remove(ptr, n, L7_FALSE);
+
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error removing MC channels [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    case CCMSG_ETH_IGMP_CHANNEL_BULK_DELETE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_REMALL (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_MCAssocChannel_t);
+
+      msg_MCAssocChannel_t *ptr;
+      L7_uint16             n;
+
+      ptr = (msg_MCAssocChannel_t *) inbuffer->info;
+      n = MSG_N_ELEMS(sizeof(msg_MCAssocChannel_t));
+
+      /* Execute command */
+      rc  = ptin_msg_IGMP_ChannelAssoc_remove_all(ptr, n);
+
+      if (L7_SUCCESS != rc)
+      {        
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error removing MC channels [res:0x%x]", res);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Add static multicast channel */
+    case CCMSG_ETH_IGMP_STATIC_GROUP_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_STATIC_GROUP_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_MCStaticChannel_t);
+
+      msg_MCStaticChannel_t *ptr;
+      L7_uint16             n;
+
+      ptr = (msg_MCStaticChannel_t *) inbuffer->info;
+      n = MSG_N_ELEMS(sizeof(msg_MCStaticChannel_t));
+
+      /* Execute command */
+      rc  = ptin_msg_static_channel_add(ptr, n);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Remove static multicast channel */
+    case CCMSG_ETH_IGMP_STATIC_GROUP_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_STATIC_GROUP_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_MCStaticChannel_t);
+
+      msg_MCStaticChannel_t *ptr;
+      L7_uint16             n;
+
+      ptr = (msg_MCStaticChannel_t *) inbuffer->info;
+      n = MSG_N_ELEMS(sizeof(msg_MCStaticChannel_t));
+
+      /* Execute command */
+      rc = ptin_msg_static_channel_remove(ptr, n);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Get list of multicast channels */
+    case CCMSG_ETH_IGMP_GROUPS_GET:
+    {      
+      msg_MCActiveChannelsRequest_t *inputPtr;
+      msg_MCActiveChannelsReply_t   *outputPtr;
+      L7_uint16                     numberOfChannels;
+
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_GROUPS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_MCActiveChannelsRequest_t);
+
+      inputPtr         = (msg_MCActiveChannelsRequest_t *) inbuffer->info;
+      outputPtr        = (msg_MCActiveChannelsReply_t *)   outbuffer->info;
+      numberOfChannels =  IPCLIB_MAX_MSGSIZE/sizeof(msg_MCActiveChannelsReply_t); //IPC buffer size / struct size
+
+      /* Execute command */
+      ptin_timer_start(40,"CCMSG_ETH_IGMP_GROUPS_GET");
+      rc = ptin_msg_IGMP_channelList_get(inputPtr, outputPtr, &numberOfChannels);
+      ptin_timer_stop(40);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      outbuffer->infoDim = numberOfChannels * sizeof(msg_MCActiveChannelsReply_t);       
+    }
+    break;
+
+    /* Get list of clients watching a multicast channel */
+    case CCMSG_ETH_IGMP_CLIENT_GROUPS_GET:
+    {      
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER,
+                  "Message received: CCMSG_ETH_IGMP_CLIENT_GROUPS_GET (0x%04X) msgSize:%u bytes", msgId, infoDim);
+
+      #if 1//To be changed to 0
+      CHECK_INFO_SIZE_ATLEAST(msg_MCActiveChannelClientsRequest_t);
+      #else
+      CHECK_INFO_SIZE(msg_MCActiveChannelClientsRequest_t);
+      #endif
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_MCActiveChannelClientsRequest_t));
+
+      msg_MCActiveChannelClientsResponse_t *ptr;
+      ptr = (msg_MCActiveChannelClientsResponse_t *) outbuffer->info;
+
+      /* Execute command */
+      ptin_timer_start(41,"CCMSG_ETH_IGMP_CLIENT_GROUPS_GET");
+      rc = ptin_msg_IGMP_clientList_get(ptr);
+      ptin_timer_stop(41);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_MCActiveChannelClientsResponse_t));
+    }
+    break;
+
+    /* Remove static multicast channel */
+    case CCMSG_ETH_IGMP_STATIC_GROUP_REMALL:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_STATIC_GROUP_REMALL (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_MCStaticChannel_t);
+
+      msg_MCStaticChannel_t *ptr;
+      L7_uint16             n;
+
+      ptr = (msg_MCStaticChannel_t *) inbuffer->info;
+      n = MSG_N_ELEMS(sizeof(msg_MCStaticChannel_t));
+
+      /* Execute command */
+      rc = ptin_msg_igmp_static_channel_remove_all(ptr, n);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+    
+    /* Request Snoop Sync between different cards/interfaces*/
+    case CCMSG_MGMD_SNOOP_SYNC_REQUEST:
+    {      
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MGMD_SNOOP_SYNC_REQUEST (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_SnoopSyncRequest_t);
+         
+      /* Execute command */
+      ptin_timer_start(42,"CCMSG_MGMD_SNOOP_SYNC_REQUEST");
+      rc = ptin_msg_snoop_sync_request((msg_SnoopSyncRequest_t *) inbuffer->info);
+      ptin_timer_stop(42);
+      if (L7_SUCCESS != rc)
+      {
+        SETIPCACKOK(outbuffer);
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Request Snoop Sync between different cards/interfaces*/
+    case CCMSG_MGMD_SNOOP_SYNC_REPLY:
+    {          
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MGMD_SNOOP_SYNC_REPLY (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_SnoopSyncReply_t);
+
+      /* Execute command */
+      ptin_timer_start(43,"CCMSG_MGMD_SNOOP_SYNC_REPLY");
+      rc = ptin_msg_snoop_sync_reply((msg_SnoopSyncReply_t *) inbuffer->info, MSG_N_ELEMS(sizeof(msg_SnoopSyncReply_t)));
+      ptin_timer_stop(43);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+      
+    }
+    break;
+
+    /***************************************************** 
+     * Routing messages
+     ****************************************************/
+    /* CCMSG_ROUTING_INTF_CREATE ****************************************/
+    case CCMSG_ROUTING_INTF_CREATE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_INTF_CREATE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingIntf);
+
+      msg_RoutingIntf *data;
+      data = (msg_RoutingIntf *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingIntf));
+
+      /* Execute command */
+      rc = ptin_msg_routing_intf_create(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingIntf));
+      break;
+    }
+
+    /* CCMSG_ROUTING_INTF_MODIFY ****************************************/
+    case CCMSG_ROUTING_INTF_MODIFY:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_INTF_MODIFY (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingIntf);
+
+      msg_RoutingIntf *data;
+      data = (msg_RoutingIntf *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingIntf));
+
+      /* Execute command */
+      rc = ptin_msg_routing_intf_modify(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingIntf));
+      break;
+    }
+
+    /* CCMSG_ROUTING_INTF_REMOVE ****************************************/
+    case CCMSG_ROUTING_INTF_REMOVE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_INTF_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingIntf);
+
+      msg_RoutingIntf *data;
+      data = (msg_RoutingIntf *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingIntf));
+
+      /* Execute command */
+      rc = ptin_msg_routing_intf_remove(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingIntf));
+      break;
+    }
+
+    /* CCMSG_ROUTING_ARPTABLE_GET ****************************************/
+    case CCMSG_ROUTING_ARPTABLE_GET:
+    {
+      msg_RoutingArpTableRequest  *inputPtr;
+      msg_RoutingArpTableResponse *outputPtr;
+      L7_uint32                   readEntries;
+
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_ARPTABLE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingArpTableRequest);
+
+      inputPtr   = (msg_RoutingArpTableRequest *)  inbuffer->info;
+      outputPtr  = (msg_RoutingArpTableResponse *) outbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_routing_arptable_get(inputPtr, outputPtr, &readEntries);
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      outbuffer->infoDim = readEntries * sizeof(msg_RoutingArpTableResponse);
+         
+      break;    
+    }
+
+    /* CCMSG_ROUTING_ARPENTRY_PURGE ****************************************/
+    case CCMSG_ROUTING_ARPENTRY_PURGE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_ARPENTRY_PURGE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingArpEntryPurge);
+
+      msg_RoutingArpEntryPurge *data;
+      data = (msg_RoutingArpEntryPurge *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingArpEntryPurge));
+
+      /* Execute command */
+      rc = ptin_msg_routing_arpentry_purge(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingArpEntryPurge));
+      break;
+    }
+
+    /* CCMSG_ROUTING_ROUTETABLE_GET ****************************************/
+    case CCMSG_ROUTING_ROUTETABLE_GET:
+    {
+      msg_RoutingRouteTableRequest  *inputPtr;
+      msg_RoutingRouteTableResponse *outputPtr;
+      L7_uint32                      maxEntries;
+      L7_uint32                      readEntries;
+
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_ROUTETABLE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingRouteTableRequest);
+
+      inputPtr   = (msg_RoutingRouteTableRequest *)  inbuffer->info;
+      outputPtr  = (msg_RoutingRouteTableResponse *) outbuffer->info;
+      maxEntries = IPCLIB_MAX_MSGSIZE/sizeof(msg_RoutingRouteTableResponse); //IPC buffer size / struct size
+
+      /* Execute command */
+      rc = ptin_msg_routing_routetable_get(inputPtr, outputPtr, maxEntries, &readEntries);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      outbuffer->infoDim = readEntries * sizeof(msg_RoutingRouteTableResponse);
+         
+      break;    
+    }
+
+    /* CCMSG_ROUTING_STATICROUTE_ADD ****************************************/
+    case CCMSG_ROUTING_STATICROUTE_ADD:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_STATICROUTE_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingStaticRoute);
+
+      msg_RoutingStaticRoute *data;
+      data = (msg_RoutingStaticRoute *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingStaticRoute));
+
+      /* Execute command */
+      rc = ptin_msg_routing_staticroute_add(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingStaticRoute));
+      break;
+    }
+
+    /* CCMSG_ROUTING_STATICROUTE_DELETE ****************************************/
+    case CCMSG_ROUTING_STATICROUTE_DELETE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_STATICROUTE_DELETE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingStaticRoute);
+
+      msg_RoutingStaticRoute *data;
+      data = (msg_RoutingStaticRoute *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingStaticRoute));
+
+      /* Execute command */
+      rc = ptin_msg_routing_staticroute_delete(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingStaticRoute));
+      break;
+    }
+
+    /* CCMSG_ROUTING_PINGSESSION_CREATE ****************************************/
+    case CCMSG_ROUTING_PINGSESSION_CREATE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_PINGSESSION_CREATE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingPingSessionCreate);
+
+      msg_RoutingPingSessionCreate *data;
+      data = (msg_RoutingPingSessionCreate *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingPingSessionCreate));
+
+      /* Execute command */
+      rc = ptin_msg_routing_pingsession_create(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingPingSessionCreate));
+      break;
+    }
+
+    /* CCMSG_ROUTING_PINGSESSION_QUERY ****************************************/
+    case CCMSG_ROUTING_PINGSESSION_QUERY:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_PINGSESSION_QUERY (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingPingSessionQuery);
+
+      msg_RoutingPingSessionQuery *data;
+      data = (msg_RoutingPingSessionQuery *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingPingSessionQuery));
+
+      /* Execute command */
+      rc = ptin_msg_routing_pingsession_query(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingPingSessionQuery));
+      break;
+    }
+
+    /* CCMSG_ROUTING_PINGSESSION_FREE ****************************************/
+    case CCMSG_ROUTING_PINGSESSION_FREE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_PINGSESSION_FREE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingPingSessionFree);
+
+      msg_RoutingPingSessionFree *data;
+      data = (msg_RoutingPingSessionFree *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingPingSessionFree));
+
+      /* Execute command */
+      rc = ptin_msg_routing_pingsession_free(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingPingSessionFree));
+      break;
+    }
+
+    /* CCMSG_ROUTING_TRACERTSESSION_CREATE ****************************************/
+    case CCMSG_ROUTING_TRACERTSESSION_CREATE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_TRACERTSESSION_CREATE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingTracertSessionCreate);
+
+      msg_RoutingTracertSessionCreate *data;
+      data = (msg_RoutingTracertSessionCreate *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingTracertSessionCreate));
+
+      /* Execute command */
+      rc = ptin_msg_routing_tracertsession_create(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingTracertSessionCreate));
+      break;
+    }
+
+    /* CCMSG_ROUTING_TRACERTSESSION_QUERY ****************************************/
+    case CCMSG_ROUTING_TRACERTSESSION_QUERY:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_TRACERTSESSION_QUERY (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingTracertSessionQuery);
+
+      msg_RoutingTracertSessionQuery *data;
+      data = (msg_RoutingTracertSessionQuery *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingTracertSessionQuery));
+
+      /* Execute command */
+      rc = ptin_msg_routing_tracertsession_query(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingTracertSessionQuery));
+      break;
+    }
+
+    /* CCMSG_ROUTING_TRACERTSESSION_GETHOPS ****************************************/
+    case CCMSG_ROUTING_TRACERTSESSION_GETHOPS:
+    {
+      msg_RoutingTracertSessionHopsRequest  *inputPtr;
+      msg_RoutingTracertSessionHopsResponse *outputPtr;
+      L7_uint32                              maxEntries;
+      L7_uint32                              readEntries;
+
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_TRACERTSESSION_GETHOPS (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_RoutingTracertSessionHopsRequest);
+
+      inputPtr   = (msg_RoutingTracertSessionHopsRequest *)  inbuffer->info;
+      outputPtr  = (msg_RoutingTracertSessionHopsResponse *) outbuffer->info;
+      maxEntries = IPCLIB_MAX_MSGSIZE/sizeof(msg_RoutingTracertSessionHopsResponse); //IPC buffer size / struct size
+
+      /* Execute command */
+      rc = ptin_msg_routing_tracertsession_gethops(inputPtr, outputPtr, maxEntries, &readEntries);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      outbuffer->infoDim = readEntries * sizeof(msg_RoutingTracertSessionHopsResponse);
+         
+      break;    
+    }
+
+    /* CCMSG_ROUTING_TRACERTSESSION_FREE ****************************************/
+    case CCMSG_ROUTING_TRACERTSESSION_FREE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_TRACERTSESSION_FREE (0x%04X)", CCMSG_ROUTING_TRACERTSESSION_FREE);
+
+      CHECK_INFO_SIZE(msg_RoutingTracertSessionFree);
+
+      msg_RoutingTracertSessionFree *data;
+      data = (msg_RoutingTracertSessionFree *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingTracertSessionFree));
+
+      /* Execute command */
+      rc = ptin_msg_routing_tracertsession_free(data);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_RoutingTracertSessionFree));
+      break;
+    }
+
+        /* Set PRBS mode */
+    case CCMSG_ETH_PCS_PRBS_ENABLE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PCS_PRBS_ENABLE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_ptin_pcs_prbs);
+
+      msg_ptin_pcs_prbs *ptr;
+      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_pcs_prbs));
+
+      ptr = (msg_ptin_pcs_prbs *) inbuffer->info;
+
+      /* Execute command */
+      rc  = ptin_msg_pcs_prbs_enable(ptr,n);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Get PRBS status */
+    case CCMSG_ETH_PCS_PRBS_STATUS:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PCS_PRBS_STATUS (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_ptin_pcs_prbs);
+
+      msg_ptin_pcs_prbs *ptr;
+      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_pcs_prbs));
+
+      ptr = (msg_ptin_pcs_prbs *) outbuffer->info;
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_ptin_pcs_prbs)*n);
+
+      /* Execute command */
+      rc = ptin_msg_pcs_prbs_status(ptr,n);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_ptin_pcs_prbs) * n);
+    }
+    break;
+
+    /* Set PRBS mode */
+    case CCMSG_ETH_PRBS_ENABLE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PRBS_ENABLE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_ptin_prbs_enable);
+
+      msg_ptin_prbs_enable *ptr;
+      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_prbs_enable));
+
+      ptr = (msg_ptin_prbs_enable *) inbuffer->info;
+
+      /* Execute command */
+      rc  = ptin_msg_prbs_enable(ptr,n);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /* Get PRBS status */
+    case CCMSG_ETH_PRBS_STATUS:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PRBS_STATUS (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_ptin_prbs_request);
+
+      msg_ptin_prbs_request *ptr_in;
+      msg_ptin_prbs_status  *ptr_out;
+      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_prbs_request));
+
+      ptr_in  = (msg_ptin_prbs_request *) inbuffer->info;
+      ptr_out = (msg_ptin_prbs_status  *) outbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_prbs_status(ptr_in, ptr_out, &n);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error getting data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_ptin_prbs_status) * n);
+    }
+    break;
+
+
+    /************************************************************************** 
+     * OAM MEPs Configuration
+     **************************************************************************/
+#ifdef __Y1731_802_1ag_OAM_ETH__
+    case CCMSG_WR_MEP:
+    case CCMSG_FLUSH_MEP:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_WR_MEP/CCMSG_FLUSH_MEP (0x%04X)", msgId);
+    
+      CHECK_INFO_SIZE_MOD(msg_bd_mep_t);
+
+      rc = ptin_msg_wr_MEP(inbuffer, outbuffer, 0);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+    
+      break;
+    case CCMSG_RM_MEP:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_RM_MEP (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_bd_mep_t);
+
+      rc = ptin_msg_del_MEP(inbuffer, outbuffer, 0);
+
+      if (L7_SUCCESS != rc) {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;
+    case CCMSG_WR_RMEP:
+    case CCMSG_FLUSH_RMEP:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_WR_RMEP/CCMSG_FLUSH_RMEP (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_bd_rmep_t);
+
+      rc = ptin_msg_wr_RMEP(inbuffer, outbuffer, 0);
+
+      if (L7_SUCCESS != rc) {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;
+    case CCMSG_RM_RMEP:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_RM_RMEP (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_bd_rmep_t);
+
+      rc = ptin_msg_del_RMEP(inbuffer, outbuffer, 0);
+
+      if (L7_SUCCESS != rc) {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;
+    case CCMSG_DUMP_MEPs:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_DUMP_MEPs (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_generic_prefix_t);
+
+      rc = ptin_msg_dump_MEPs(inbuffer, outbuffer);
+      if (L7_SUCCESS != rc) {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+
+      break;
+
+    case CCMSG_DUMP_MEs:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_DUMP_MEs (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_bd_me_t);
+
+      rc = ptin_msg_dump_MEs(inbuffer, outbuffer);
+
+      if (L7_SUCCESS != rc) {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+
+      break;
+
+    case CCMSG_DUMP_LUT_MEPs:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_DUMP_LUT_MEPs (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_generic_prefix_t);
+
+      rc = ptin_msg_dump_LUT_MEPs(inbuffer, outbuffer);
+
+      if (L7_SUCCESS != rc) {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+
+      break;
+
+    case CCMSG_WR_MIP:
+    case CCMSG_RM_MIP:
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER,
+                    CCMSG_WR_MIP==msgId? "Message received: CCMSG_WR_MIP (0x%04X)"
+                                       : "Message received: CCMSG_RM_MIP (0x%04X)", msgId);
+
+        CHECK_INFO_SIZE_MOD(msg_bd_mip_t);
+
+        if (CCMSG_WR_MIP==msgId)    rc = ptin_msg_wr_MIP(inbuffer, outbuffer, 0);
+        else                        rc = ptin_msg_del_MIP(inbuffer, outbuffer, 0);
+
+        if (L7_SUCCESS != rc) {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPCACKOK(outbuffer);
+        break;
+
+
+    case CCMSG_WR_MEP_LM:
+    case CCMSG_RM_MEP_LM:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER,
+                  CCMSG_WR_MEP_LM == msgId? "Message received: CCMSG_WR_MEP_LM (0x%04X)":
+                                            "Message received: CCMSG_RM_MEP_LM (0x%04X)", msgId);
+    
+      CHECK_INFO_SIZE(msg_bd_mep_lm_t);
+    
+#if MNGMT_DIFFERENT_ENDIANNESS
+      {
+       msg_bd_mep_lm_t *p;
+
+       p = (msg_bd_mep_lm_t*)inbuffer->info;
+
+       p->idx = ENDIAN_SWAP32(p->idx);
+       p->port = ENDIAN_SWAP32(p->port);
+      }
+#endif
+
+      if (CCMSG_RM_MEP_LM == msgId) {
+          rc = del_mep_lm(((msg_bd_mep_lm_t*)inbuffer->info)->idx, &oam)? L7_FAILURE: L7_SUCCESS;
+      }
+      else {
+       msg_bd_mep_lm_t *p;
+       
+       p = (msg_bd_mep_lm_t*)inbuffer->info;
+
+       if (0==p->type) rc = L7_NOT_SUPPORTED;
+       else {
+        T_MEP_LM mep_lm;
+
+        mep_lm.CCMs0_LMMR1 =    p->type;
+        mep_lm.period =         p->lmmPeriod;
+    
+        switch (wr_mep_lm(p->idx, &mep_lm, &oam)) {
+        case 0: rc = L7_SUCCESS; break;
+        case 1: rc = L7_NOT_EXIST; break;
+        default: rc = L7_ERROR; break;
+        }//switch
+       }
+      }
+    
+      if (L7_SUCCESS != rc) {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;
+
+    case CCMSG_RD_MEP_LM:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_RD_MEP_LM (0x%04X)", msgId);
+  
+      CHECK_INFO_SIZE(msg_generic_prefix_t);
+  
+      {
+        msg_generic_prefix_t *pi;
+        msg_frame_loss_t *po;
+        u16 i_mep;
+        u8  instance;
+  
+        pi = (msg_generic_prefix_t*)inbuffer->info;
+
+#if MNGMT_DIFFERENT_ENDIANNESS
+        pi->index = ENDIAN_SWAP64(pi->index);
+#endif
+
+        i_mep = pi->index;
+        instance = pi->index>>16;
+
+        po = (msg_frame_loss_t*)outbuffer->info;
+        SETIPC_INFODIM(sizeof(msg_frame_loss_t));
+        po->err_code = 0;
+
+        if (i_mep>=N_MEPs) rc = L7_NOT_EXIST;
+        else
+        switch (instance) {
+        case 0:
+            LM_medium(&oam.db[i_mep].lm, &po->NEnumerator, &po->NEdenominator, &po->FEnumerator, &po->FEdenominator);
+            rc = L7_SUCCESS;
+            break;
+        case 1:
+            LM_last_period(&oam.db[i_mep].lm, &po->NEnumerator, &po->NEdenominator, &po->FEnumerator, &po->FEdenominator);
+            rc = L7_SUCCESS;
+            break;
+        default: rc = L7_ERROR; break;
+        }//switch
+  
+        if (L7_SUCCESS != rc) {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+#if MNGMT_DIFFERENT_ENDIANNESS
+        else {
+            po->err_code = ENDIAN_SWAP32(po->err_code);
+            po->NEnumerator = ENDIAN_SWAP64(po->NEnumerator);
+            po->NEdenominator = ENDIAN_SWAP64(po->NEdenominator);
+            po->FEnumerator = ENDIAN_SWAP64(po->FEnumerator);
+            po->FEdenominator = ENDIAN_SWAP64(po->FEdenominator);
+        }
+#endif
+      }
+  
+      break;
+
+    case CHMSG_CCM_MEP_FRAMELOSS:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_CCM_MEP_FRAMELOSS (0x%04X)", msgId); 
+      {
+        MSG_FRAMELOSS_status *pi;
+        MSG_FRAMELOSS_status *po;
+        u16 i_mep;
+  
+        if (infoDim < offsetof(MSG_FRAMELOSS_status, idx)+sizeof(pi->idx)) {
+            SetIPCNACK(outbuffer, SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE));
+            break;
+        }
+        //CHECK_INFO_SIZE(MSG_FRAMELOSS_status);
+
+
+        pi = (MSG_FRAMELOSS_status*)inbuffer->info;
+#if MNGMT_DIFFERENT_ENDIANNESS
+        pi->idx = ENDIAN_SWAP32(pi->idx);
+        //pi->port = ENDIAN_SWAP32(pi->port);
+#endif
+        i_mep = pi->idx;
+
+        po = (MSG_FRAMELOSS_status*)outbuffer->info;
+        SETIPC_INFODIM(sizeof(MSG_FRAMELOSS_status));
+
+        if (i_mep>=N_MEPs) rc = L7_NOT_EXIST;
+        else {
+            //LM_medium(&oam.db[i_mep].lm, &po->Delta_LM_rx_i, &po->Delta_LM_tx_i, &po->Delta_LM_rx_e, &po->Delta_LM_tx_e);
+            LM_last_period(&oam.db[i_mep].lm, &po->Delta_LM_rx_i, &po->Delta_LM_tx_i, &po->Delta_LM_rx_e, &po->Delta_LM_tx_e);
+            po->Delta_LM_rx_i = diff_LM_counters(po->Delta_LM_tx_i, po->Delta_LM_rx_i);
+            po->Delta_LM_rx_e = diff_LM_counters(po->Delta_LM_tx_e, po->Delta_LM_rx_e);
+            rc = L7_SUCCESS;
+        }
+
+        if (L7_SUCCESS != rc) {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+#if MNGMT_DIFFERENT_ENDIANNESS
+        else {
+            //po->idx = ENDIAN_SWAP32(pi->idx); //ENDIAN_SWAP32(po->idx);
+            //po->port = ENDIAN_SWAP32(po->port);
+            po->mask = ENDIAN_SWAP32(po->mask);
+            po->Delta_LM_tx_e = ENDIAN_SWAP64(po->Delta_LM_tx_e);
+            po->Delta_LM_rx_e = ENDIAN_SWAP64(po->Delta_LM_rx_e);
+            po->Delta_LM_tx_i = ENDIAN_SWAP64(po->Delta_LM_tx_i);
+            po->Delta_LM_rx_i = ENDIAN_SWAP64(po->Delta_LM_rx_i);
+        }
+#endif
+      }
+  
+      break;
+
+
+    case CCMSG_WR_MEP_DM:
+    case CCMSG_RM_MEP_DM:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER,
+                  CCMSG_WR_MEP_DM == msgId? "Message received: CCMSG_WR_MEP_DM (0x%04X)":
+                                            "Message received: CCMSG_RM_MEP_DM (0x%04X)", msgId);
+      CHECK_INFO_SIZE(msg_bd_mep_dm_t);
+
+      if (CCMSG_RM_MEP_DM == msgId) {
+          rc = del_mep_dm(((msg_bd_mep_dm_t*)inbuffer->info)->idx, &oam)? L7_FAILURE: L7_SUCCESS;
+      }
+      else {
+       msg_bd_mep_dm_t *p;
+
+       p = (msg_bd_mep_dm_t*)inbuffer->info;
+
+       if (0==p->packet_number) rc = L7_NOT_EXIST;
+       else {
+        T_MEP_DM mep_dm;
+
+        mep_dm.n_frames =          p->packet_number;
+        mep_dm.period =            p->period;
+        mep_dm.oam_datagrm_len =   p->packet_size;
+//        mep_dm.dmmCosColor =         p->dmmCosColor;
+
+        switch (wr_mep_dm(p->idx, &mep_dm, &oam)) {
+			case 0: rc = L7_SUCCESS; break;
+			case 1: rc = L7_NOT_EXIST; break;
+			default: rc = L7_ERROR; break;
+        }//switch
+       }
+      }
+
+      if (L7_SUCCESS != rc) {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;
+
+    case CHMSG_CCM_MEP_FRAMEDELAY:
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_CCM_MEP_FRAMEDELAY (0x%04X)", msgId);
+      {
+        MSG_FRAMEDELAY_status *pi;
+        MSG_FRAMEDELAY_status *po;
+        u16 i_mep;
+
+        if (infoDim < offsetof(MSG_FRAMEDELAY_status, idx)+sizeof(pi->idx)) {
+            SetIPCNACK(outbuffer, SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE));
+            break;
+        }
+        //CHECK_INFO_SIZE(MSG_FRAMEDELAY_status);
+
+
+        pi = (MSG_FRAMEDELAY_status*)inbuffer->info;
+        i_mep = pi->idx;
+
+        po = (MSG_FRAMEDELAY_status*)outbuffer->info;
+        SETIPC_INFODIM(sizeof(MSG_FRAMEDELAY_status));
+
+        if (i_mep>=N_MEPs) rc = L7_NOT_EXIST;
+        else {
+
+//            DM_2way_frame_delay(&oam.db[i_mep].dm, &oam.db[i_mep].dm);
+        	//????
+            po->DM_Max           = oam.db[i_mep].dm.fd_max;
+            po->DM_Min           = oam.db[i_mep].dm.fd_min;
+            po->DM_Total         = oam.db[i_mep].dm.fd_sum;
+            po->DM_packet_number = oam.db[i_mep].dm.n_frames;
+            rc = L7_SUCCESS;
+        }
+      }
+
+      if (L7_SUCCESS != rc) {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+
+      break;
+
+
+#endif //__Y1731_802_1ag_OAM_ETH__
+
+    /************************************************************************** 
+    * ERPS Configuration
+    **************************************************************************/
+
+    case CCMSG_ERPS_SET:
+      {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_SET (0x%04X)", msgId);
+    
+      CHECK_INFO_SIZE_MOD(msg_erps_t);
+
+      msg_erps_t *ptr;
+      ptr = (msg_erps_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_t));
+
+      /* Execute command */
+      rc = ptin_msg_erps_set(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+      }
+      break;
+
+    case CCMSG_ERPS_DEL:
+      {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_DEL (0x%04X)", msgId);
+    
+      CHECK_INFO_SIZE_MOD(msg_erps_t);
+
+      msg_erps_t *ptr;
+      ptr = (msg_erps_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_t));
+
+      /* Execute command */
+      rc = ptin_msg_erps_del(ptr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+      }
+      break;
+
+    case CCMSG_ERPS_CONF:
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_CONF (0x%04X)", msgId);
+      
+        CHECK_INFO_SIZE_MOD(msg_erps_t);
+
+        msg_erps_t *ptr;
+        ptr = (msg_erps_t *) outbuffer->info;
+
+        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_t));
+
+        /* Execute command */
+        rc = ptin_msg_erps_config(ptr);
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPCACKOK(outbuffer);        
+      }
+      break;
+
+    case CCMSG_ERPS_STATUS:
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_STATUS (0x%04X)", msgId);
+      
+        CHECK_INFO_SIZE_MOD(msg_erps_status_t);
+
+        msg_erps_status_t *ptr;
+        ptr = (msg_erps_status_t *) outbuffer->info;
+
+        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_status_t));
+
+        /* Execute command */
+        rc = ptin_msg_erps_status(ptr);
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPC_INFODIM(sizeof(msg_erps_status_t));
+      }
+      break;
+
+    case CCMSG_ERPS_STATUS_NEXT:
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_STATUS_NEXT (0x%04X)", msgId);
+      
+        CHECK_INFO_SIZE_MOD(msg_erps_status_t);
+
+        msg_erps_status_t *ptr;
+        L7_int            n;
+
+        ptr = (msg_erps_status_t *) outbuffer->info;
+
+        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_status_t));
+
+        /* Execute command */
+        rc = ptin_msg_erps_status_next(ptr, &n);
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPC_INFODIM(sizeof(msg_erps_status_t) * n);
+      }
+      break;
+
+    case CCMSG_ERPS_OPERATOR_CMD:
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_OPERATOR_CMD (0x%04X)", msgId);
+      
+        CHECK_INFO_SIZE_MOD(msg_erps_cmd_t);
+
+        msg_erps_cmd_t *ptr;
+
+        ptr = (msg_erps_cmd_t *) outbuffer->info;
+
+        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_cmd_t));
+
+        /* Execute command */
+        rc = ptin_msg_erps_cmd(ptr);
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPCACKOK(outbuffer);        
+      }
+      break;
+
+    case CCMSG_ERPS_SYNC:
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_SYNC (0x%04X)", msgId);
+      
+        CHECK_INFO_SIZE_MOD(msg_erps_cmd_t);
+
+        msg_erps_cmd_t *ptr;
+
+        ptr = (msg_erps_cmd_t *) outbuffer->info;
+
+        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_cmd_t));
+
+        /* Execute command */
+        rc = ptin_msg_erps_cmd(ptr);
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPCACKOK(outbuffer);
+      }
+      break;
+
+
+    /************************************************************************** 
+    * ACL Configuration
+    **************************************************************************/
+
+    case CCMSG_ACL_RULE_ADD:
+    case CCMSG_ACL_RULE_DEL:
+      {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ACL_RULE_ADD/DEL (0x%04X)", msgId);
+    
+      #if 0
+      if (inbuffer->info[1] == ACL_TYPE_MAC)
+      {
+        CHECK_INFO_SIZE_MOD(msg_mac_acl_t);
+        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_mac_acl_t));
+      }
+      else if ( (inbuffer->info[1] == ACL_TYPE_IP_STANDARD) || (inbuffer->info[1] == ACL_TYPE_IP_EXTENDED) || (inbuffer->info[1] == ACL_TYPE_IP_NAMED) )
+      {
+        CHECK_INFO_SIZE_MOD(msg_ip_acl_t);
+        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_ip_acl_t)); 
+      }
+      else if (inbuffer->info[1] == ACL_TYPE_IPv6_EXTENDED)
+      {
+        CHECK_INFO_SIZE_MOD(msg_ipv6_acl_t);
+        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_ipv6_acl_t)); 
+      }
+      #endif
+
+      /* Execute command */
+      rc = ptin_msg_acl_rule_config((void *) inbuffer->info, msgId, infoDim);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+      }
+      break;
+
+    case CCMSG_ACL_APPLY:
+    case CCMSG_ACL_UNAPPLY:
+      {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ACL_APPLY/UNAPPLY (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_apply_acl_t);
+
+      /* Execute command */
+      rc = ptin_msg_acl_enable((msg_apply_acl_t *) inbuffer->info, msgId, MSG_N_ELEMS(sizeof(msg_apply_acl_t)));
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPCACKOK(outbuffer);
+      }
+      break;
+
+
+    case CCMSG_PORTMIRROR_SESSION_ADD:
+    case CCMSG_PORTMIRROR_SESSION_REMOVE:
+    case CCMSG_PORTMIRROR_PORT_ADD:
+    case CCMSG_PORTMIRROR_PORT_REMOVE:
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_PORTMIRROR (0x%04X)", msgId);
+
+        CHECK_INFO_SIZE_MOD(msg_port_mirror_t);
+
+        /* Execute command */
+        rc = ptin_msg_mirror(inbuffer, outbuffer);
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPCACKOK(outbuffer);
+      }
+      break;
+
+  #if (PTIN_BOARD_IS_MATRIX || PTIN_BOARD_IS_STANDALONE || (PTIN_BOARD == PTIN_BOARD_TA48GE))
+    case CCMSG_PTP_LNX_NET_IF_SET:
+      #if (PTIN_BOARD == PTIN_BOARD_OLT1T0)
+      if (!KERNEL_NODE_IS("OLT1T0-AC")) {
+        PT_LOG_WARN(LOG_CTX_MSGHANDLER, "Message not supported!"); 
+        SetIPCNACK (outbuffer, SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_WARNING, ERROR_CODE_NOSUCHMSG)); 
+      
+        rc = L7_FAILURE; 
+        break; 
+      }
+      #endif
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_PTP_LNX_NET_IF_SET (0x%04X)", msgId);
+
+        CHECK_INFO_SIZE_MOD(T_MSG_PTP_LNX_NET_IF_SET);
+
+        rc=ptin_msg_PTP_lnx_net_if_set(inbuffer, outbuffer);
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, rc);
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPCACKOK(outbuffer);
+      }
+      break;
+  #endif
+      
+    case CHMSG_RFC2819_MONITORING_GET_ONE_REG:
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_GET (0x%04X)", msgId);
+
+        CHECK_INFO_SIZE_MOD(msg_rfc2819_monitoring_t);
+
+        msg_rfc2819_monitoring_t *in_ptr;
+        msg_rfc2819_buffer_t *ptr;
+
+        ptr = (msg_rfc2819_buffer_t *) outbuffer->info;
+        in_ptr = (msg_rfc2819_monitoring_t *) inbuffer->info;
+
+        ENDIAN_SWAP32_MOD(in_ptr->n);
+        /* Execute command */
+        rc = ptin_msg_get_next_qualRFC2819(in_ptr->n, ptr);
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPC_INFODIM(sizeof(msg_rfc2819_buffer_t));
+      }
+      break;
+
+
+
+    case CHMSG_RFC2819_MONITORING_CONFIG:      
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_CONFIG (0x%04X)", msgId);
+
+        CHECK_INFO_SIZE_MOD(msg_rfc2819_admin_t);
+
+        msg_rfc2819_admin_t *ptr;
+
+        ptr = (msg_rfc2819_admin_t *)inbuffer->info;
+
+        /* Execute command */
+        rc = ptin_msg_config_rfc2819_monitoring(ptr);
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPCACKOK(outbuffer);
+      }
+     break;
+
+    case CHMSG_RFC2819_MONITORING_GET:
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_GET (0x%04X)", msgId);
+  
+        CHECK_INFO_SIZE_MOD(msg_rfc2819_monitoring_t);
+  
+        msg_rfc2819_buffer_t      *ptr;
+        msg_rfc2819_monitoring_t  *ptr_in;
+        L7_int                n;
+  
+        ptr     = (msg_rfc2819_buffer_t  *) outbuffer->info;
+        ptr_in  = (msg_rfc2819_monitoring_t * )inbuffer->info;
+
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "SlotID %d ", ptr_in->SlotId);
+        ENDIAN_SWAP32_MOD(ptr_in->n);
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "n %d ", ptr_in->n);
+                 
+        /* Execute command */
+        rc = ptin_msg_get_next_qualRFC2819_inv(ptr_in->n, ptr, &n);
+  
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+  
+        SETIPC_INFODIM(sizeof(msg_rfc2819_buffer_t) * n);
+      }
+      break;
+
+    case CHMSG_RFC2819_MONITORING_CLEAR:
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_CLEAR (0x%04X)", msgId);
+  
+        CHECK_INFO_SIZE_MOD(msg_rfc2819_monitoring_t);
+
+        msg_rfc2819_monitoring_t  *ptr_in;
+        msg_rfc2819_monitoring_t  *ptr_out;
+        ptr_in   = (msg_rfc2819_monitoring_t * )inbuffer->info;
+        ptr_out  = (msg_rfc2819_monitoring_t * )outbuffer->info;
+
+        /* Execute command */
+        ENDIAN_SWAP32_MOD(ptr_in->n);
+        rc = ptin_msg_clear_rfc2819_monitoring_buffer(ptr_in->n);
+  
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPCACKOK(outbuffer);
+      }
+      break;
+
+
+    case CHMSG_RFC2819_MONITORING_SHOW_CONF:
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_SHOW_CONF (0x%04X)", msgId);
+
+        L7_int Port;
+        L7_uint8 Admin;        
+        L7_uint32 *resp;        
+        CHECK_INFO_SIZE_MOD(L7_int);
+
+        Port = *((L7_uint32 *)inbuffer->info);
+        resp = (L7_uint32 *)outbuffer->info;
+
+        /* Execute command */
+        rc = ptin_msg_get_rfc2819_probe_config(Port, &Admin);
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        if (Admin==0) {
+          *resp = (Port & 0xFFFF);
+        }
+        else {
+          *resp = 0x80000000 | (Port & 0xFFFF);
+        }
+
+        SETIPC_INFODIM(sizeof(L7_uint32));
+      }
+      break;
+
+    case CHMSG_RFC2819_MONITORING_BUFF_STATUS:
+      {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_BUFF_STATUS (0x%04X)", msgId);
+
+        msg_rfc2819_buffer_status_t *status;
+        L7_int buffer_type;
+
+        status = (msg_rfc2819_buffer_status_t *) outbuffer->info;
+
+        CHECK_INFO_SIZE_MOD(L7_int);
+
+        buffer_type = *((L7_int *)inbuffer->info);
+
+        /* Execute command */
+        rc = ptin_msg_rfc2819_buffer_status(buffer_type, status);
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPC_INFODIM(sizeof(msg_rfc2819_buffer_status_t));
+      }
+      break;
+
+#ifdef __802_1x__
+    case CCMSG_WR_802_1X_ADMINMODE:
+    case CCMSG_WR_802_1X_TRACE:
+    case CCMSG_WR_802_1X_VLANASSGNMODE:
+    case CCMSG_WR_802_1X_MONMODE:
+    case CCMSG_WR_802_1X_DYNVLANMODE:
+      msg_generic_wrd(msg_wr_802_1x_Genrc, inbuffer, outbuffer, sizeof(msg_802_1x_Genrc), sizeof(msg_802_1x_Genrc));
+      break;
+
+    case CCMSG_WR_802_1X_ADMINCONTROLLEDDIRECTIONS:
+    case CCMSG_WR_802_1X_PORTCONTROLMODE:
+    case CCMSG_WR_802_1X_QUIETPERIOD:
+    case CCMSG_WR_802_1X_TXPERIOD:
+    case CCMSG_WR_802_1X_SUPPTIMEOUT:
+    case CCMSG_WR_802_1X_SERVERTIMEOUT:
+    case CCMSG_WR_802_1X_MAXREQ:
+    case CCMSG_WR_802_1X_REAUTHPERIOD:
+    case CCMSG_WR_802_1X_KEYTXENABLED:
+    case CCMSG_WR_802_1X_GUESTVLANID:
+    case CCMSG_WR_802_1X_GUSTVLANPERIOD:
+    case CCMSG_WR_802_1X_MAXUSERS:
+    case CCMSG_WR_802_1X_UNAUTHENTICATEDVLAN:
+      msg_generic_wrd(msg_wr_802_1x_Genrc2, inbuffer, outbuffer, sizeof(msg_802_1x_Genrc2), sizeof(msg_generic_prefix_t));
+      break;
+
+    case CCMSG_WR_802_1X_AUTHSERV:
+      msg_generic_wrd(msg_wr_802_1x_AuthServ, inbuffer, outbuffer, sizeof(msg_802_1x_AuthServ), sizeof(msg_generic_prefix_t));
+      break;
+#endif //__802_1x__
+
+/*****************************************Multicast Package Feature********************************************************/
+    /*Multicast Packages Add*/
+    case CCMSG_IGMP_PACKAGES_ADD:
+    {        
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGES_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_igmp_package_t);
+
+      msg_igmp_package_t *msgPtr;
+      msgPtr = (msg_igmp_package_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_igmp_package_t));
+
+      /* Execute command */
+      rc = ptin_msg_igmp_packages_add(msgPtr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_igmp_package_t));
+      break;/*Multicast Packages Add*/
+    }
+
+    /*Multicast Packages Remove*/
+    case CCMSG_IGMP_PACKAGES_REMOVE:
+    {        
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGES_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_igmp_package_t);
+
+      msg_igmp_package_t *msgPtr;
+      msgPtr = (msg_igmp_package_t *) outbuffer->info;
+
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_igmp_package_t));
+
+      /* Execute command */
+      rc = ptin_msg_igmp_packages_remove(msgPtr);
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error %u while processing message", rc);
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      SETIPC_INFODIM(sizeof(msg_igmp_package_t));
+      break; /* CCMSG_IGMP_PACKAGES_REMOVE */
+    }
+
+    /*Multicast Package Channels Add*/
+    case CCMSG_IGMP_PACKAGE_CHANNELS_ADD:
+    {        
+     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGE_CHANNELS_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_igmp_package_channels_t);
+
+      msg_igmp_package_channels_t *msgPtr;
+      msgPtr = (msg_igmp_package_channels_t *) inbuffer->info;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_package_channels_t));
+
+      /* Execute command */
+      rc = ptin_msg_igmp_package_channels_add(msgPtr, noOfMessages);
+
+      if (L7_SUCCESS != rc)
+      {       
+       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
+       SetIPCNACK(outbuffer, res);
+       break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_IGMP_PACKAGE_CHANNELS_ADD */
+    }
+
+    /*Multicast Package Channels Remove*/
+    case CCMSG_IGMP_PACKAGE_CHANNELS_REMOVE:
+    {        
+     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGE_CHANNELS_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_igmp_package_channels_t);
+
+      msg_igmp_package_channels_t *msgPtr;
+      msgPtr = (msg_igmp_package_channels_t *) inbuffer->info;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_package_channels_t));
+
+      /* Execute command */
+      rc = ptin_msg_igmp_package_channels_remove(msgPtr, noOfMessages);
+
+      if (L7_SUCCESS != rc)
+      {       
+       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
+       SetIPCNACK(outbuffer, res);
+       break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_IGMP_PACKAGE_CHANNELS_REMOVE */
+    }
+
+    /*Igmp Unicast Client Packages Add*/
+    case CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_ADD:
+    {        
+     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_igmp_unicast_client_packages_t);
+
+      msg_igmp_unicast_client_packages_t *msgPtr;
+      msgPtr = (msg_igmp_unicast_client_packages_t *) inbuffer->info;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_unicast_client_packages_t));
+
+      /* Execute command */      
+      rc = ptin_msg_igmp_unicast_client_packages_add(msgPtr, noOfMessages);
+      
+      if (L7_SUCCESS != rc)
+      {       
+       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
+       SetIPCNACK(outbuffer, res);
+       break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_ADD */
+    }
+
+    /*Igmp Unicast Client Packages Remove*/
+    case CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE:
+    {        
+     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_igmp_unicast_client_packages_t);
+
+      msg_igmp_unicast_client_packages_t *msgPtr;
+      msgPtr = (msg_igmp_unicast_client_packages_t *) inbuffer->info;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_unicast_client_packages_t));
+      
+      /* Execute command */      
+      rc = ptin_msg_igmp_unicast_client_packages_remove(msgPtr, noOfMessages);
+
+      if (L7_SUCCESS != rc)
+      {       
+       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing Channels from a Package [res:0x%x]", res);
+       SetIPCNACK(outbuffer, res);
+       break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
+    }
+
+    /*Igmp Macbridge Client Packages Add*/
+    case CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_ADD:
+    {        
+     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_igmp_macbridge_client_packages_t);
+
+      msg_igmp_macbridge_client_packages_t *msgPtr;
+      msgPtr = (msg_igmp_macbridge_client_packages_t *) inbuffer->info;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_macbridge_client_packages_t));
+
+      /* Execute command */      
+      rc = ptin_msg_igmp_macbridge_client_packages_add(msgPtr, noOfMessages);
+
+      if (L7_SUCCESS != rc)
+      {       
+       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
+       SetIPCNACK(outbuffer, res);
+       break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
+    }
+
+    /*Igmp Macbridge Client Packages Remove*/
+    case CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_REMOVE:
+    {        
+     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_igmp_macbridge_client_packages_t);
+
+      msg_igmp_macbridge_client_packages_t *msgPtr;
+      msgPtr = (msg_igmp_macbridge_client_packages_t *) inbuffer->info;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_macbridge_client_packages_t));
+
+      /* Execute command */
+      rc = ptin_msg_igmp_macbridge_client_packages_remove(msgPtr, noOfMessages);
+
+      if (L7_SUCCESS != rc)
+      {       
+       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing Channels from Package [res:0x%x]", res);
+       SetIPCNACK(outbuffer, res);
+       break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
+    }
+
+    /*Multicast Service Add*/
+    case CCMSG_MULTICAST_SERVICE_ADD:
+    {        
+     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MULTICAST_SERVICE_ADD (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_multicast_service_t);
+
+      msg_multicast_service_t *msgPtr;
+      msgPtr = (msg_multicast_service_t *) inbuffer->info;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_multicast_service_t));
+
+      /* Execute command */
+      rc = ptin_msg_igmp_multicast_service_add(msgPtr, noOfMessages);
+
+      if (L7_SUCCESS != rc)
+      {       
+       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
+       SetIPCNACK(outbuffer, res);
+       break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
+    }
+
+    /*Multicast Service Remove*/
+    case CCMSG_MULTICAST_SERVICE_REMOVE:
+    {        
+     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MULTICAST_SERVICE_REMOVE (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_multicast_service_t);
+
+      msg_multicast_service_t *msgPtr;
+      msgPtr = (msg_multicast_service_t *) inbuffer->info;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_multicast_service_t));
+
+      /* Execute command */
+      rc = ptin_msg_igmp_multicast_service_remove(msgPtr, noOfMessages);
+
+      if (L7_SUCCESS != rc)
+      {       
+       res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+       PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding Channels to Package [res:0x%x]", res);
+       SetIPCNACK(outbuffer, res);
+       break;
+      }
+
+      SETIPCACKOK(outbuffer);
+
+      break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
+    }
+/************************************End Multicast Package Feature********************************************************/
+#if (PTIN_BOARD == PTIN_BOARD_AG16GA)
+
+    case CCMSG_AGENT_TRAP_CONFIGURE:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_AGENT_TRAP_CONFIGURE (0x%04X)", inbuffer->msgId);
+
+      CHECK_INFO_SIZE(msg_agent_trap_conf_t);
+
+      msg_agent_trap_conf_t *ptr;
+        
+      ptr = (msg_agent_trap_conf_t *) outbuffer->info;
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_agent_trap_conf_t));
+
+      ptin_msg_configure_trap(ptr->vlan, ptr->port_id, ptr->protocol, ptr->admin);
+
+      /* Execute command */
+
+      if (L7_SUCCESS != rc)
+      {
+         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+         SetIPCNACK(outbuffer, res);
+         break;
+      }
+
+        outbuffer->infoDim = sizeof(msg_agent_trap_conf_t);
+        break;
+    }
+#endif
+    /************************************************************************** 
+    * MAC Limiting Configuration
+    **************************************************************************/
+
+    case CCMSG_L2_MACLIMIT_CONFIG:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_L2_MACLIMIT_CONFIG (0x%04X)", msgId); 
+      CHECK_INFO_SIZE(msg_l2_maclimit_config_t);
+
+      msg_l2_maclimit_config_t *ptr;
+    
+      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_l2_maclimit_config_t));
+      ptr = (msg_l2_maclimit_config_t *) outbuffer->info;
+
+      /* Execute command */
+      rc = ptin_msg_l2_maclimit_config(ptr);  
+    
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      //SETIPC_INFODIM(sizeof(msg_l2_maclimit_config_t));
+      SETIPCACKOK(outbuffer);
+    }
+    break;
+
+    /************************************************************************** 
+    * MAC Limiting Status
+    **************************************************************************/
+
+    case CCMSG_L2_MACLIMIT_STATUS:
+    {
+     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_L2_MACLIMIT_STATUS (0x%04X)", msgId);
+     CHECK_INFO_SIZE(msg_l2_maclimit_status_t);
+
+     msg_l2_maclimit_status_t *ptr;
+
+     ptr = (msg_l2_maclimit_status_t *) outbuffer->info;
+     memcpy(&outbuffer->info, &inbuffer->info, sizeof(msg_l2_maclimit_status_t));
+
+     /* Execute command */
+     rc = ptin_msg_l2_maclimit_status(ptr);  
+
+     if (L7_SUCCESS != rc)
+     {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+     }
+
+      SETIPC_INFODIM(sizeof(msg_l2_maclimit_status_t));
+
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status Response");
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," slotId       = %u",      ptr->slotId);
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," interface    = %u/%u",   ptr->intf.intf_type, ptr->intf.intf_id);
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," MacLearned   = %u",      ptr->number_mac_learned);
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status       = %u",      ptr->status);
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Mask         = %u",      ptr->mask);      
+    }
+    break;
+
+    /* Signalling the end of a Equipment Flush Configuration*/
+    case CCMSG_PROTECTION_MATRIX_FLUSH_CONFIGURATION_END:
+    {
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MATRIX_FLUSH_CONFIGURATION_END (0x%04X)", msgId);
+
+      #if 0
+      /*Sending Ack*/  
+      SETIPCACKOK(outbuffer);      
+
+      /* Execute command */
+      ptin_msg_protection_matrix_configuration_flush_end();      
+      #else
+      /* Execute command */
+      ptin_msg_task_process(msgId, (void*)(inbuffer->info), infoDim, 3000);
+
+      /*Sending Ack*/  
+      SETIPCACKOK(outbuffer);   
+      #endif
+      break;
+    }
+
+  #if (PTIN_BOARD_IS_STANDALONE)
+    case CCMSG_PTP_FPGA:
+      #if (PTIN_BOARD == PTIN_BOARD_OLT1T0)
+      if (!KERNEL_NODE_IS("OLT1T0-AC")) {
+        PT_LOG_WARN(LOG_CTX_MSGHANDLER, "Message not supported!");
+        SetIPCNACK (outbuffer, SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_WARNING, ERROR_CODE_NOSUCHMSG));
+
+        rc = L7_FAILURE;
+        break;
+      }
+      #endif
+      {
+        T_MSG_PTP_FPGA *p;
+        ptin_dtl_search_ptp_t e;
+        L7_uint32 ptin_port;
+        ptin_intf_t ptin_intf;
+
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_PTP_FPGA (0x%04X)", msgId); 
+        CHECK_INFO_SIZE(T_MSG_PTP_FPGA);   //CHECK_INFO_MOD(T_MSG_PTP_FPGA);
+
+        do {
+          p= (T_MSG_PTP_FPGA *) inbuffer->info;
+          ptin_intf.intf_id=     p->intf.intf_id;
+          ptin_intf.intf_type=   p->intf.intf_type;
+          rc = ptin_intf_ptintf2port(&ptin_intf, &ptin_port);
+          //ptin_intf_ptintf2intIfNum(&p->intf, &intIfNum);
+          if (L7_SUCCESS != rc) break;
+      
+          e.key.prt= ptin_port;
+          e.key.vid= p->vid;
+          //e.vid_prt=
+          e.vid_os=  p->vid_os;
+          e.encap=   p->encap;
+          memcpy(&e.ntw, &p->ntw, sizeof(e.ntw));
+          rc = ptin_ptp_fpga_entry(&e, 0==p->add0_del1? DAPI_CMD_SET:DAPI_CMD_CLEAR);
+        } while (0);
+
+        if (L7_SUCCESS != rc) {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          //res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, rc);
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        SETIPCACKOK(outbuffer);
+        break;
+      }
+
+    case CCMSG_OAM_FPGA:
+      #if (PTIN_BOARD == PTIN_BOARD_OLT1T0)
+      if (!KERNEL_NODE_IS("OLT1T0-AC")) {
+              PT_LOG_WARN(LOG_CTX_MSGHANDLER, "Message not supported!");
+              SetIPCNACK (outbuffer, SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_WARNING, ERROR_CODE_NOSUCHMSG));
+
+              rc = L7_FAILURE;
+              break;
+      }
+      #endif
+      {
+        T_MSG_OAM_FPGA *p;
+        ptin_dtl_search_oam_t e;
+        //L7_uint32 ptin_port;
+        //ptin_intf_t ptin_intf;
+
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_OAM_FPGA (0x%04X)", msgId); 
+        CHECK_INFO_SIZE(T_MSG_OAM_FPGA);   //CHECK_INFO_MOD(T_MSG_OAM_FPGA);
+
+        do {
+           p= (T_MSG_OAM_FPGA *) inbuffer->info;
+           //ptin_intf.intf_id=     p->bd.prt;
+           //ptin_intf.intf_type=   0;    //Physical
+           //rc = ptin_intf_ptintf2port(&ptin_intf, &ptin_port);
+           ////ptin_intf_ptintf2intIfNum(&p->intf, &intIfNum);
+           //if (L7_SUCCESS != rc) break;
+
+           e.key.prt= p->bd.prt;//ptin_port;
+           e.key.vid= p->bd.vid;
+           //e.vid_prt=
+           e.lvl= p->bd.level;
+           rc = ptin_oam_fpga_entry(&e, EMPTY_T_MEP(p->bd)? DAPI_CMD_CLEAR: DAPI_CMD_SET);
+        } while (0);
+
+        if (L7_SUCCESS != rc) {
+         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+         //res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, rc);
+         SetIPCNACK(outbuffer, res);
+         break;
+        }
+
+        SETIPCACKOK(outbuffer);
+        break;
+      }
+
+  #endif // PTIN_BOARD_IS_STANDALONE
+#ifdef NGPON2_SUPPORTED
+    case CCMSG_NGPON2_ADD_GROUP:
+    {
+     
+       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_NGPON2_ADD_GROUP (0x%04X)", inbuffer->msgId);
+
+       CHECK_INFO_SIZE(ptin_NGPON2group_t);
+
+       ptin_NGPON2group_t *ptr;
+
+       ptr = (ptin_NGPON2group_t *) outbuffer->info;
+
+       memcpy(&outbuffer->info, &inbuffer->info, sizeof(ptin_NGPON2group_t));
+
+       ENDIAN_SWAP8_MOD(ptr->GroupId);
+       ENDIAN_SWAP32_MOD(ptr->mask);
+       ENDIAN_SWAP8_MOD(ptr->numIntf);
+       ENDIAN_SWAP8_MOD(ptr->slotId);
+
+       /* Execute command */
+       rc = ptin_msg_NGPON2_add_group(ptr);  
+       if (L7_SUCCESS != rc)
+       {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+       }
+
+        outbuffer->infoDim = sizeof(ptin_NGPON2group_t);
+
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status Response");
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," slotId       = %u",      ptr->slotId);
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," GroupId      = %u",      ptr->GroupId);
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," NumIntf      = %u",      ptr->numIntf);
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Mask         = %u",      ptr->mask);    
+
+              /* Execute command */
+        rc = ptin_msg_NGPON2_add_group_port(ptr);  
+
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
+
+        outbuffer->infoDim = sizeof(ptin_NGPON2group_t);
+
+        L7_uint16 i = 0;
+        
+        while ( i < ptr->numIntf )
+        {
+          PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Port added with group");
+          PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Type         = %u",      ptr->NGPON2Port[i].type);
+          PT_LOG_TRACE(LOG_CTX_MSGHANDLER," ID           = %u",      ptr->NGPON2Port[i].id);   
+
+          i++;
+        }
+
+
+        
+    }
+    break;
+
+    case CCMSG_NGPON2_REM_GROUP:
+    {
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_NGPON2_REM_GROUP (0x%04X)", inbuffer->msgId);
+        CHECK_INFO_SIZE(ptin_NGPON2group_t);
+
+        ptin_NGPON2group_t *ptr;
+
+        ptr = (ptin_NGPON2group_t *) outbuffer->info;
+        memcpy(&outbuffer->info, &inbuffer->info, sizeof(ptin_NGPON2group_t));
+
+        ENDIAN_SWAP8_MOD(ptr->GroupId);
+        ENDIAN_SWAP32_MOD(ptr->mask);
+        ENDIAN_SWAP8_MOD(ptr->numIntf);
+        ENDIAN_SWAP8_MOD(ptr->slotId);
+
+        /* Execute command */
+        rc = ptin_msg_NGPON2_rem_group(ptr); 
+
+        if (L7_SUCCESS != rc)
+        {
+           PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+           res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+           SetIPCNACK(outbuffer, res);
+           break;
+        }
+
+         outbuffer->infoDim = sizeof(ptin_NGPON2group_t);
+
+         PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status Response");
+         PT_LOG_TRACE(LOG_CTX_MSGHANDLER," slotId       = %u",      ptr->slotId);
+         PT_LOG_TRACE(LOG_CTX_MSGHANDLER," GroupId      = %u",      ptr->GroupId);
+         PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status       = %u",      ptr->numIntf);
+         PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Mask         = %u",      ptr->mask);      
+
+    }
+    break;
+
+    case CCMSG_NGPON2_ADD_GROUP_PORT:
+    {
+
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_NGPON2_ADD_GROUP_PORT (0x%04X)", inbuffer->msgId);
+      CHECK_INFO_SIZE(ptin_NGPON2group_t);
+
+      ptin_NGPON2group_t *ptr;
+
+      ptr = (ptin_NGPON2group_t *) outbuffer->info;
+      memcpy(&outbuffer->info, &inbuffer->info, sizeof(ptin_NGPON2group_t));
+
+      /* Execute command */
+      rc = ptin_msg_NGPON2_add_group_port(ptr);  
+
+      if (L7_SUCCESS != rc)
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
+
+      outbuffer->infoDim = sizeof(ptin_NGPON2group_t);
+
+      L7_uint16 i = 0;
+      
+      while ( i < ptr->numIntf )
+      {
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status Response");
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," slotId       = %u",      ptr->NGPON2Port[i].slot);
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Type         = %u",      ptr->NGPON2Port[i].type);
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," ID           = %u",      ptr->NGPON2Port[i].id);   
+
+        i++;
+      }  
+    }
+    break;
+
+    case CCMSG_NGPON2_REM_GROUP_PORT:
+    {
+
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_NGPON2_REM_GROUP_PORT (0x%04X)", inbuffer->msgId);
+      CHECK_INFO_SIZE(ptin_NGPON2group_t);
+
+      ptin_NGPON2group_t *ptr;
+        
+      ptr = (ptin_NGPON2group_t *) outbuffer->info;
+      memcpy(&outbuffer->info, &inbuffer->info, sizeof(ptin_NGPON2group_t));
+
+      /* Execute command */
+      rc = ptin_msg_NGPON2_rem_group_port(ptr);  
+
+      if (L7_SUCCESS != rc)
+      {
+         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+         SetIPCNACK(outbuffer, res);
+         break;
+      }
+
+      outbuffer->infoDim = sizeof(ptin_NGPON2group_t);
+
+      L7_uint16 i = 0;
+      
+      while ( i < ptr->numIntf )
+      {
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status Response");
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," slotId       = %u",      ptr->NGPON2Port[i].slot);
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Type         = %u",      ptr->NGPON2Port[i].type);
+        PT_LOG_TRACE(LOG_CTX_MSGHANDLER," ID           = %u",      ptr->NGPON2Port[i].id);   
+
+        i++;
+      }
+    }
+    break;
+#endif
+    default:
+    {
+      PT_LOG_WARN(LOG_CTX_MSGHANDLER, "Message received: UNKNOWN! (0x%04X)\n", msgId);
+      PT_LOG_WARN(LOG_CTX_MSGHANDLER,
+                  "The received message is not supported!");
+      SetIPCNACK (outbuffer, SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_WARNING, ERROR_CODE_NOSUCHMSG));
+
+      rc = L7_FAILURE;
+      break;
+    }
+
+  }
+
+  #if 0
+  /* Save slot id parameter */
+  if (infoDim >= 1 &&
+      inbuffer->info[0]!=(L7_uint8)-1 &&
+      ptin_board_slotId!=inbuffer->info[0])
+  {
+    ptin_board_slotId = inbuffer->info[0];
+  }
+  #endif
+
+  /* Save final time */
+  time_end = osapiTimeMicrosecondsGet();
+  time_delta = time_end - time_start;
+
+  
+  if( msgId == CCMSG_ETH_PHY_ACTIVITY_GET || 
+      msgId == CCMSG_HW_INTF_INFO_GET     ||
+      msgId == CCMSG_ETH_PHY_COUNTERS_GET ||
+      msgId == CCMSG_SWITCH_TEMPERATURE_GET ||
+#if (PTIN_BOARD_IS_MATRIX)
+      msgId == CCMSG_ETH_LACP_MATRIXES_SYNC2 || 
+#endif
+      msgId == CCMSG_MGMD_PORT_SYNC || 
+      msgId == CCMSG_APPLICATION_RESOURCES)
+  {
+    PT_LOG_TRACE(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %lu usec [response:%u (bytes) rc=%u res=0x%08x]", msgId, outbuffer->infoDim, time_delta, rc, res);
+  }
+  else
+  {
+    PT_LOG_INFO(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %lu usec  [response:%u (bytes) rc=%u res=0x%08x]", msgId, outbuffer->infoDim, time_delta, rc, res);
+  }
+
+  /* Message Runtime Meter */
+  /* Only for successfull messages */
+  if (rc==L7_SUCCESS)
+  {
+    CHMessage_runtime_meter_update(msgId, time_delta);
+  }
+
+  return ret;
+}
+
+
+/**
+ * Update message runtime meter
+ * 
+ * @param msg_id : message id
+ * @param time_delta : time taken to process message
+ */
+static void CHMessage_runtime_meter_update(L7_uint msg_id, L7_uint32 time_delta)
+{
+  struct_runtime_t *msg_runtime_ptr;
+
+  if (msg_id<CCMSG_ID_MIN && msg_id>CCMSG_ID_MAX)
+  {
+    return;
+  }
+
+  msg_runtime_ptr = &msg_runtime[msg_id-CCMSG_ID_MIN];
+
+  /* If overflow, reset all data */
+  if ( (msg_runtime_ptr->number_of_calls==(L7_uint32)-1) ||
+       (msg_runtime_ptr->total_runtime + time_delta < msg_runtime_ptr->total_runtime) )
+  {
+    CHMessage_runtime_meter_init(msg_id);
+  }
+
+  /* Update database */
+  msg_runtime_ptr->number_of_calls++;
+  msg_runtime_ptr->last_runtime    = time_delta;
+  msg_runtime_ptr->total_runtime  += time_delta;
+  if ( (msg_runtime_ptr->number_of_calls)==1 || time_delta<(msg_runtime_ptr->min_runtime) )
+    msg_runtime_ptr->min_runtime = time_delta;
+  if ( time_delta > msg_runtime_ptr->max_runtime )
+    msg_runtime_ptr->max_runtime = time_delta;
+  msg_runtime_ptr->average_runtime = msg_runtime_ptr->total_runtime/msg_runtime_ptr->number_of_calls;
+}
+
+/**
+ * Initializes message runtime meter 
+ *  
+ * @param msg_id : message id 
+ */
+void CHMessage_runtime_meter_init(L7_uint msg_id)
+{
+  if (msg_id<CCMSG_ID_MIN || msg_id>CCMSG_ID_MAX)
+  {
+    memset(msg_runtime,0x00,sizeof(msg_runtime));
+  }
+  else
+  {
+    memset(&msg_runtime[msg_id-CCMSG_ID_MIN],0x00,sizeof(struct_runtime_t));
+  }
+}
+
+/**
+ * Prints meter information
+ */
+void CHMessage_runtime_meter_print(void)
+{
+  L7_uint i;
+
+  printf(" --------------------------------------------------------------------------------------------------------- \r\n");
+  printf("| Message id |   #Calls   | Total runtime |  Last runtime |  Min. runtime |  Max. runtime | Avrg. runtime |\r\n");
+  printf("|------------|------------|---------------|---------------|---------------|---------------|---------------|\r\n");
+
+  for (i=0; i<CCMSG_ID_MAX-CCMSG_ID_MIN+1; i++)
+  {
+    if (msg_runtime[i].number_of_calls==0)  continue;
+
+    printf("|   0x%04X   | %10u | %10u us | %10u us | %10u us | %10u us | %10u us |\r\n",
+           i+CCMSG_ID_MIN,
+           msg_runtime[i].number_of_calls,
+           msg_runtime[i].total_runtime,
+           msg_runtime[i].last_runtime,
+           msg_runtime[i].min_runtime,
+           msg_runtime[i].max_runtime,
+           msg_runtime[i].average_runtime);
+  }
+
+  printf(" --------------------------------------------------------------------------------------------------------- \r\n");
+
+  fflush(stdout);
+}
+
Index: src/application/ptin/base/include/ptin_cfg.h
===================================================================
--- src/application/ptin/base/include/ptin_cfg.h	(revision 7370)
+++ src/application/ptin/base/include/ptin_cfg.h	(revision 7371)
@@ -1,76 +1,76 @@
-/*
- * ptin_cfg.h
- *
- * Created on: 2010/04/08
- * Author: Andre Brizido
- * 
- * Modified on 2011/06/14 
- * By: Alexandre Santos (alexandre-r-santos@ptinovacao.pt) 
- * Notes: 
- */
-
-#ifndef _PTIN_CFG_H
-#define _PTIN_CFG_H
-
-#include "ptin_include.h"
-
-
-/***************************************************************************** 
- * Functions Prototypes
- *****************************************************************************/
-
-/**
- * Gets Network Connectivity configuration
- * 
- * @param ntwConn Pointer to the output data (mask defines what to read)
- * 
- * @return L7_RC_t L7_SUCCESS/L7_FAILURE
- */
-extern L7_RC_t ptin_cfg_ntw_connectivity_get(ptin_NtwConnectivity_t *ntwConn);
-
-/**
- * Sets Network Connectivity configuration
- * 
- * @param ntwConn Pointer to the config data (mask defines what to set)
- * 
- * @return L7_RC_t L7_SUCCESS/L7_FAILURE
- */
-extern L7_RC_t ptin_cfg_ntw_connectivity_set(ptin_NtwConnectivity_t *ntwConn);
-
-/**
- * Returns the external inBand VLAN ID
- * 
- * @return L7_uint16 inBand VID (zero if not configured)
- */
-extern inline L7_uint16 ptin_cfg_inband_vlan_get(void);
-
-/**
- * Creates a bridge between dtl0 interface and a virtual interface eth0.4093 
- *  
- * NOTE: 
- *  1. virtual interface eth0.4093 is created here 
- *  2. all operations are accomplished through an external shell script 
- *     '/usr/local/ptin/scripts/startBridge.sh'
- * 
- * @author alex (4/10/2012)
- * 
- * @return L7_RC_t 
- */
-extern L7_RC_t ptin_cfg_inband_bridge_set(void);
-
-/**
- * Creates a bridge between dtl0.2048 interface and a virtual 
- * interface eth0.2048
- *  
- * NOTE: 
- *  1. virtual interface eth0.2048 is created here 
- *  2. all operations are accomplished through an external shell script 
- *     '/usr/local/ptin/scripts/startPcapBridge.sh' 
- * 
- * @author joaom (12/16/2015)
- * 
- * @return L7_RC_t 
- */
-extern L7_RC_t ptin_cfg_pcap_bridge_set(void);
-
-#endif /* _PTIN_CFG_H */
+/*
+ * ptin_cfg.h
+ *
+ * Created on: 2010/04/08
+ * Author: Andre Brizido
+ * 
+ * Modified on 2011/06/14 
+ * By: Alexandre Santos (alexandre-r-santos@ptinovacao.pt) 
+ * Notes: 
+ */
+
+#ifndef _PTIN_CFG_H
+#define _PTIN_CFG_H
+
+#include "ptin_include.h"
+
+
+/***************************************************************************** 
+ * Functions Prototypes
+ *****************************************************************************/
+
+/**
+ * Gets Network Connectivity configuration
+ * 
+ * @param ntwConn Pointer to the output data (mask defines what to read)
+ * 
+ * @return L7_RC_t L7_SUCCESS/L7_FAILURE
+ */
+extern L7_RC_t ptin_cfg_ntw_connectivity_get(ptin_NtwConnectivity_t *ntwConn);
+
+/**
+ * Sets Network Connectivity configuration
+ * 
+ * @param ntwConn Pointer to the config data (mask defines what to set)
+ * 
+ * @return L7_RC_t L7_SUCCESS/L7_FAILURE
+ */
+extern L7_RC_t ptin_cfg_ntw_connectivity_set(ptin_NtwConnectivity_t *ntwConn);
+
+/**
+ * Returns the external inBand VLAN ID
+ * 
+ * @return L7_uint16 inBand VID (zero if not configured)
+ */
+extern inline L7_uint16 ptin_cfg_inband_vlan_get(void);
+
+/**
+ * Creates a bridge between dtl0 interface and a virtual interface eth0.4093 
+ *  
+ * NOTE: 
+ *  1. virtual interface eth0.4093 is created here 
+ *  2. all operations are accomplished through an external shell script 
+ *     '/usr/local/ptin/scripts/startBridge.sh'
+ * 
+ * @author alex (4/10/2012)
+ * 
+ * @return L7_RC_t 
+ */
+extern L7_RC_t ptin_cfg_inband_bridge_set(void);
+
+/**
+ * Creates a bridge between dtl0.2048 interface and a virtual 
+ * interface eth0.2048
+ *  
+ * NOTE: 
+ *  1. virtual interface eth0.2048 is created here 
+ *  2. all operations are accomplished through an external shell script 
+ *     '/usr/local/ptin/scripts/startPcapBridge.sh' 
+ * 
+ * @author joaom (12/16/2015)
+ * 
+ * @return L7_RC_t 
+ */
+extern L7_RC_t ptin_cfg_pcap_bridge_set(void);
+
+#endif /* _PTIN_CFG_H */
Index: src/application/switching/voice_vlan/core/voice_vlan_db.c
===================================================================
--- src/application/switching/voice_vlan/core/voice_vlan_db.c	(revision 7370)
+++ src/application/switching/voice_vlan/core/voice_vlan_db.c	(revision 7371)
@@ -1,487 +1,487 @@
-/*********************************************************************
-*
-* (C) Copyright Broadcom Corporation 2003-2007
-*
-**********************************************************************
-* @filename  voice_vlan_db.c
-*
-* @purpose   voice vlan data store file
-*
-* @component voice_vlan
-*
-* @comments  none
-*
-* @create    05/21/2008
-*
-* @author    SNK
-*
-* @end
-*
-**********************************************************************/
-
-#include "voice_vlan.h"
-#include "avl_api.h"
-
-
-/* Global parameters */
-static avlTree_t                voiceVlanDeviceInfoTreeDb;
-static avlTreeTables_t          *voiceVlanDeviceInfoTreeHeap=L7_NULLPTR;
-static voiceVlanDeviceInfo_t    *voiceVlanDeviceInfoDataHeap=L7_NULLPTR;
-
-
-/*********************************************************************
-* @purpose  Initialize voice vlan Device Info Database
-*
-* @param    nodeCount    @b{(input)} The number of nodes to be created.
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-L7_RC_t voiceVlanDeviceInfoDBInit(L7_uint32 nodeCount)
-{
-  /* Allocate the Heap structures */
-  voiceVlanDeviceInfoTreeHeap = (avlTreeTables_t *)osapiMalloc(L7_VOICE_VLAN_COMPONENT_ID,
-                                                            nodeCount * sizeof(avlTreeTables_t));
-
-  voiceVlanDeviceInfoDataHeap  = (voiceVlanDeviceInfo_t *)osapiMalloc(L7_DOT1X_COMPONENT_ID,
-                                                                    nodeCount * sizeof(voiceVlanDeviceInfo_t));
-
-  /* validate the pointers*/
-  if ((voiceVlanDeviceInfoDataHeap == L7_NULLPTR) ||(voiceVlanDeviceInfoDataHeap == L7_NULLPTR))
-  {
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_VOICE_VLAN_COMPONENT_ID,
-            "voiceVlanDeviceInfoDBInit: Error allocating data for dot1x DB Tree \n");
-    return L7_FAILURE;
-  }
-
-  /* AVL Tree creations - voiceVlanDeviceInfoTreeDb*/
-  avlCreateAvlTree(&(voiceVlanDeviceInfoTreeDb),  voiceVlanDeviceInfoTreeHeap,
-                   voiceVlanDeviceInfoDataHeap, nodeCount,
-                   sizeof(voiceVlanDeviceInfo_t), 0x10,
-                   sizeof(L7_uchar8) * L7_MAC_ADDR_LEN );
-  return L7_SUCCESS;
-}
-
-
-/*********************************************************************
-* @purpose  DeInitialize voice vlan device Info Database
-*
-* @param    none
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-L7_RC_t voiceVlanDeviceInfoDBDeInit(void)
-{
-  /* Destroy the AVL Tree */
-  if(voiceVlanDeviceInfoTreeDb.semId != L7_NULLPTR)
-  {
-    avlDeleteAvlTree(&voiceVlanDeviceInfoTreeDb);
-  }
-
-  /* Give up the memory */
-  if (voiceVlanDeviceInfoTreeHeap != L7_NULLPTR)
-  {
-    osapiFree(L7_VOICE_VLAN_COMPONENT_ID, voiceVlanDeviceInfoTreeHeap);
-    voiceVlanDeviceInfoTreeHeap = L7_NULLPTR;
-  }
-
-  if (voiceVlanDeviceInfoDataHeap != L7_NULLPTR)
-  {
-    osapiFree(L7_VOICE_VLAN_COMPONENT_ID, voiceVlanDeviceInfoDataHeap);
-    voiceVlanDeviceInfoDataHeap = L7_NULLPTR;
-  }
-  return L7_SUCCESS;
-}
-
-/*********************************************************************
-* @purpose  To Take lock for the voice vlan device Info Node
-*
-* @param    None
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments This lock needs to be taken only the API functions not running in
-*           the dot1x threads context.
-*
-* @end
-*********************************************************************/
-L7_RC_t voiceVlanDeviceInfoTakeLock(void)
-{
-  return osapiSemaTake(voiceVlanDeviceInfoTreeDb.semId, L7_WAIT_FOREVER);
-}
-
-/*********************************************************************
-* @purpose  To Giveup lock for the voice vlan device  Info Node
-*
-* @param    None
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments This lock needs to be taken only the API functions not running in
-*           the dot1x threads context.
-*
-* @end
-*********************************************************************/
-L7_RC_t voiceVlanDeviceInfoGiveLock(void)
-{
-  return osapiSemaGive(voiceVlanDeviceInfoTreeDb.semId);
-}
-
-/*********************************************************************
-* @purpose  To allocate a voice vlan Device Info Node
-*
-* @param    mac_addr        @b{(input)} Voip device mac address
-* @param    vlanId          @b{(input)} Voice Vlan Id associated with this mac address
-* @param    intIfNum        @b{(input)} The internal interface on which this
-*                                   voip device was identified
-* @param    clientAuthState @b{(input)} indicates if this device is an unauthenticated device
-* @param    sourceType      @b{(input)} sourceType of this device (LLDP, etc.)
-*
-* @returns  L7_SUCCESS    if the entry was created sucessfully
-*           L7_FAILURE
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-L7_RC_t voiceVlanDeviceInfoAlloc(L7_uchar8                 *mac_addr,
-                                 L7_uint32                  vlanId,
-                                 L7_uint32                  intIfNum,
-                                 L7_BOOL                    clientAuthState,
-                                 VOICE_VLAN_SOURCE_TYPES_t  sourceType)
-{
-  L7_uchar8   zeroMac[L7_MAC_ADDR_LEN];
-  voiceVlanDeviceInfo_t  newNode,*tmpNode=L7_NULLPTR,*retNode = L7_NULLPTR;
-
-
-   /* validate input */
-   memset (zeroMac ,0,L7_MAC_ADDR_LEN);
-
-   if ((memcmp(zeroMac,mac_addr,L7_MAC_ADDR_LEN)==0)||
-        (( clientAuthState!= L7_TRUE)&&(clientAuthState != L7_FALSE)))
-   {
-      return L7_FAILURE;
-   }
-
-   tmpNode = voiceVlanDeviceInfoGet(mac_addr);
-
-    if (tmpNode == L7_NULLPTR)
-    {
-      /* found one - use it */
-      memset(&newNode,0,sizeof(voiceVlanDeviceInfo_t));
-      memcpy(newNode.voipMac,mac_addr,L7_MAC_ADDR_LEN);
-      newNode.vlanId = vlanId;
-      newNode.intIfNum = intIfNum;
-      newNode.clientAuthState = clientAuthState;
-      newNode.sourceType = sourceType;
-
-      /* add the node to the tree */
-      osapiSemaTake(voiceVlanDeviceInfoTreeDb.semId, L7_WAIT_FOREVER);
-      retNode  = avlInsertEntry(&voiceVlanDeviceInfoTreeDb,&newNode);
-      osapiSemaGive(voiceVlanDeviceInfoTreeDb.semId);
-      if (retNode == &newNode)
-      {
-        L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-        nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
-
-        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_VOICE_VLAN_COMPONENT_ID,
-                "%s:%d Error Adding the node to the Voice Vlan Device Info Tree for mac address: %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ,phyintf %d, %s, voice vlan : %d \n",
-                __FUNCTION__,__FILE__,
-                mac_addr[0],
-                mac_addr[1],
-                mac_addr[2],
-                mac_addr[3],
-                mac_addr[4],
-                mac_addr[5],
-                intIfNum, ifName,
-                vlanId);
-        return L7_FAILURE;
-      }
-      return L7_SUCCESS;
-    }
-    else
-    {
-      /* mac address already present in the database */
-      return L7_FAILURE;
-    }
-
-  return L7_FAILURE;
-}
-
-/*********************************************************************
-* @purpose  To Deallocate a voice Vlan Device Info Node
-*
-* @param    node  pointer to voiceVlanDeviceInfo structure
-*
-* @returns  L7_SUCCESS or L7_FAILURE
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-L7_RC_t voiceVlanDeviceInfoDeAlloc(voiceVlanDeviceInfo_t *node)
-{
-  if(node != L7_NULLPTR)
-  {
-     osapiSemaTake(voiceVlanDeviceInfoTreeDb.semId, L7_WAIT_FOREVER);
-     avlDeleteEntry(&voiceVlanDeviceInfoTreeDb,node);
-     osapiSemaGive(voiceVlanDeviceInfoTreeDb.semId);
-     return L7_SUCCESS;
-
-  }
-  return L7_FAILURE;
-}
-
-/*********************************************************************
-* @purpose  To Get a voice vlan Device Info Node
-*
-* @param    mac_addr  @b{(input)} The mac address of the voip device
-*
-* @returns  voice vlan device info node
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-voiceVlanDeviceInfo_t *voiceVlanDeviceInfoGet(L7_uchar8* mac_addr_key)
-{
-  L7_uchar8 zeroMac[L7_MAC_ADDR_LEN],key[L7_MAC_ADDR_LEN];
-  voiceVlanDeviceInfo_t  *entry = L7_NULLPTR;
-
-  /*validate mac address*/
-  memset(zeroMac,0,L7_MAC_ADDR_LEN);
-  if (memcmp(mac_addr_key,zeroMac,L7_MAC_ADDR_LEN)==0)
-  {
-    return  entry;
-  }
-
-  /* copy the mac address to the key*/
-  memset(key,0,L7_MAC_ADDR_LEN);
-  memcpy(key,mac_addr_key,L7_MAC_ADDR_LEN);
-  entry = (voiceVlanDeviceInfo_t *)avlSearchLVL7(&voiceVlanDeviceInfoTreeDb,key,AVL_EXACT);
-  return entry;
-}
-
-/*********************************************************************
-* @purpose  To Get Next voice vlan Device Info Node
-*
-* @param    mac_addr_key  @b{(input)} The mac address of the voice vlan device
-*
-* @returns  Logical Internal Interface node
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-voiceVlanDeviceInfo_t *voiceVlanDeviceInfoGetNext(L7_uchar8 *mac_addr_key)
-{
-  L7_uchar8 key[L7_MAC_ADDR_LEN];
-  voiceVlanDeviceInfo_t  *entry = L7_NULLPTR;
-
-   /* copy the mac address to the key*/
-  memset(key,0,L7_MAC_ADDR_LEN);
-  memcpy(key,mac_addr_key,L7_MAC_ADDR_LEN);
-  entry = (voiceVlanDeviceInfo_t *)avlSearchLVL7(&voiceVlanDeviceInfoTreeDb,key,AVL_NEXT);
-  return entry;
-}
-
-
-
-/*********************************************************************
-* @purpose  To get First voice vlan device  for a physical interface
-*
-* @param    intIfNum  @b{(input)} The internal interface
-*
-* @returns  Voice Vlan Device node
-*
-* @comments
-*
-* @end
-*********************************************************************/
-voiceVlanDeviceInfo_t *voiceVlanDeviceInfoFirstGet(L7_uint32 intIfNum)
-{
-  L7_uchar8 mac_key[L7_MAC_ADDR_LEN];
-  voiceVlanDeviceInfo_t *node;
-
-  memset(mac_key,0,L7_MAC_ADDR_LEN);
-
-  voiceVlanDeviceInfoTakeLock();
-  node=voiceVlanDeviceInfoGetNext(mac_key);
-  while(node!=L7_NULLPTR)
-  {
-    if (node->intIfNum == intIfNum)
-    {
-      voiceVlanDeviceInfoGiveLock();
-      return node;
-    }
-    memset(mac_key,0,L7_MAC_ADDR_LEN);
-    memcpy(mac_key,node->voipMac,L7_MAC_ADDR_LEN);
-    node=voiceVlanDeviceInfoGetNext(mac_key);
-  }
-
-  voiceVlanDeviceInfoGiveLock();
-  return L7_NULLPTR;
-}
-
-/*********************************************************************
-* @purpose  To iterate all the voice vlan devices of a physical interface
-*
-* @param    intIfNum  @b{(input)} The internal interface
-* @param    mac_addr  @b{(input/output)} The mac address of the last learnt voip device
-*
-* @returns  voice vlan device node
-*
-* @comments Give the last learnt mac address on that interface to get the next one
-*
-* @end
-*********************************************************************/
-voiceVlanDeviceInfo_t *voiceVlanDeviceInfoGetNextNode(L7_uint32 intIfNum,
-                                                        L7_uchar8 *mac_addr)
-{
-  voiceVlanDeviceInfo_t *node;
-
-   voiceVlanDeviceInfoTakeLock();
-   node=voiceVlanDeviceInfoGetNext(mac_addr);
-   while(node!=L7_NULLPTR)
-  {
-    if (node->intIfNum == intIfNum &&
-        memcmp(mac_addr,node->voipMac,L7_MAC_ADDR_LEN)!=0)
-    {
-      voiceVlanDeviceInfoGiveLock();
-      return node;
-    }
-    memset(mac_addr,0,L7_MAC_ADDR_LEN);
-    memcpy(mac_addr,node->voipMac,L7_MAC_ADDR_LEN);
-    node=voiceVlanDeviceInfoGetNext(mac_addr);
-  }
-
-  voiceVlanDeviceInfoGiveLock();
-  return L7_NULLPTR;
-}
-
-
-/*********************************************************************
-* @purpose  Debug Info of the voice vlan DB
-*
-* @param    None
-*
-* @returns  None
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-void voiceVlanDebugDeviceInfo(void)
-{
-  if(voiceVlanDeviceInfoTreeHeap != L7_NULLPTR)
-  {
-    SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
-                  "The Voice Vlan Device Database has %d Nodes\n",
-    voiceVlanDeviceInfoTreeDb.count);
-  }
-}
-
-/*********************************************************************
-* @purpose  Debug Info of the voice vlan DB
-*
-* @param    None
-*
-* @returns  None
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-void voiceVlanDebugDeviceInfoList(void)
-{
-  voiceVlanDeviceInfo_t *node = L7_NULLPTR;
-  L7_uchar8 mac_addr[L7_MAC_ADDR_LEN];
-
-  /*list device info in the tree*/
-  memset(mac_addr,0,L7_MAC_ADDR_LEN);
-
-  node=voiceVlanDeviceInfoGetNext(mac_addr);
-  while(node != L7_NULLPTR)
-  {
-    sysapiPrintf("\r\n Voip Mac address:%02X:%02X:%02X:%02X:%02X:%02X",
-                 node->voipMac[0],
-                 node->voipMac[1],
-                 node->voipMac[2],
-                 node->voipMac[3],
-                 node->voipMac[4],
-                 node->voipMac[5]);
-    sysapiPrintf("\n Interface: %d",node->intIfNum);
-    sysapiPrintf("\r\n Voice Vlan:%d",node->vlanId );
-    sysapiPrintf("\r\n Client Auth State:%d ",node->clientAuthState);
-    sysapiPrintf("\r\n ---------------------------------------------------------------------");
-
-    memset(mac_addr,0,L7_MAC_ADDR_LEN);
-    memcpy(mac_addr,node->voipMac,L7_MAC_ADDR_LEN);
-
-     /*checking the get command*/
-    node = voiceVlanDeviceInfoGet(mac_addr);
-    if (node != L7_NULLPTR)
-    {
-       sysapiPrintf("\r\n Voip Mac address:%02X:%02X:%02X:%02X:%02X:%02X",
-                   node->voipMac[0],
-                   node->voipMac[1],
-                   node->voipMac[2],
-                   node->voipMac[3],
-                   node->voipMac[4],
-                   node->voipMac[5]);
-      sysapiPrintf("\n Interface: %d",node->intIfNum);
-      sysapiPrintf("\r\n Voice Vlan:%d",node->vlanId );
-      sysapiPrintf("\r\n Client Auth State:%d ",node->clientAuthState);
-      sysapiPrintf("\r\n ---------------------------------------------------------------------");
-    }
-
-    node=voiceVlanDeviceInfoGetNext(mac_addr);
-  }
-}
-
-/*********************************************************************
-* @purpose  Debug Info of the voice vlan DB
-*
-* @param    None
-*
-* @returns  None
-*
-* @comments none
-*
-* @end
-*********************************************************************/
-void voiceVlanDebugDeviceInfoIntfList(L7_uint32 intIfNum)
-{
-  voiceVlanDeviceInfo_t *node = L7_NULLPTR;
-  L7_uchar8 mac_addr[L7_MAC_ADDR_LEN];
-
-  /*list device info in the tree*/
-  memset(mac_addr,0,L7_MAC_ADDR_LEN);
-
-  node= voiceVlanDeviceInfoFirstGet(intIfNum);
-  while(node != L7_NULLPTR)
-  {
-    sysapiPrintf("\r\n Voip Mac address:%02X:%02X:%02X:%02X:%02X:%02X",
-                 node->voipMac[0],
-                 node->voipMac[1],
-                 node->voipMac[2],
-                 node->voipMac[3],
-                 node->voipMac[4],
-                 node->voipMac[5]);
-    sysapiPrintf("\n Interface: %d",node->intIfNum);
-    sysapiPrintf("\r\n Voice Vlan:%d",node->vlanId );
-    sysapiPrintf("\r\n Client Auth State:%d ",node->clientAuthState);
-    sysapiPrintf("\r\n ---------------------------------------------------------------------");
-    memset(mac_addr,0,L7_MAC_ADDR_LEN);
-    memcpy(mac_addr,node->voipMac,L7_MAC_ADDR_LEN);
-    node=voiceVlanDeviceInfoGetNextNode(intIfNum,mac_addr);
-  }
-
-}
+/*********************************************************************
+*
+* (C) Copyright Broadcom Corporation 2003-2007
+*
+**********************************************************************
+* @filename  voice_vlan_db.c
+*
+* @purpose   voice vlan data store file
+*
+* @component voice_vlan
+*
+* @comments  none
+*
+* @create    05/21/2008
+*
+* @author    SNK
+*
+* @end
+*
+**********************************************************************/
+
+#include "voice_vlan.h"
+#include "avl_api.h"
+
+
+/* Global parameters */
+static avlTree_t                voiceVlanDeviceInfoTreeDb;
+static avlTreeTables_t          *voiceVlanDeviceInfoTreeHeap=L7_NULLPTR;
+static voiceVlanDeviceInfo_t    *voiceVlanDeviceInfoDataHeap=L7_NULLPTR;
+
+
+/*********************************************************************
+* @purpose  Initialize voice vlan Device Info Database
+*
+* @param    nodeCount    @b{(input)} The number of nodes to be created.
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+L7_RC_t voiceVlanDeviceInfoDBInit(L7_uint32 nodeCount)
+{
+  /* Allocate the Heap structures */
+  voiceVlanDeviceInfoTreeHeap = (avlTreeTables_t *)osapiMalloc(L7_VOICE_VLAN_COMPONENT_ID,
+                                                            nodeCount * sizeof(avlTreeTables_t));
+
+  voiceVlanDeviceInfoDataHeap  = (voiceVlanDeviceInfo_t *)osapiMalloc(L7_DOT1X_COMPONENT_ID,
+                                                                    nodeCount * sizeof(voiceVlanDeviceInfo_t));
+
+  /* validate the pointers*/
+  if ((voiceVlanDeviceInfoDataHeap == L7_NULLPTR) ||(voiceVlanDeviceInfoDataHeap == L7_NULLPTR))
+  {
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_VOICE_VLAN_COMPONENT_ID,
+            "voiceVlanDeviceInfoDBInit: Error allocating data for dot1x DB Tree \n");
+    return L7_FAILURE;
+  }
+
+  /* AVL Tree creations - voiceVlanDeviceInfoTreeDb*/
+  avlCreateAvlTree(&(voiceVlanDeviceInfoTreeDb),  voiceVlanDeviceInfoTreeHeap,
+                   voiceVlanDeviceInfoDataHeap, nodeCount,
+                   sizeof(voiceVlanDeviceInfo_t), 0x10,
+                   sizeof(L7_uchar8) * L7_MAC_ADDR_LEN );
+  return L7_SUCCESS;
+}
+
+
+/*********************************************************************
+* @purpose  DeInitialize voice vlan device Info Database
+*
+* @param    none
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+L7_RC_t voiceVlanDeviceInfoDBDeInit(void)
+{
+  /* Destroy the AVL Tree */
+  if(voiceVlanDeviceInfoTreeDb.semId != L7_NULLPTR)
+  {
+    avlDeleteAvlTree(&voiceVlanDeviceInfoTreeDb);
+  }
+
+  /* Give up the memory */
+  if (voiceVlanDeviceInfoTreeHeap != L7_NULLPTR)
+  {
+    osapiFree(L7_VOICE_VLAN_COMPONENT_ID, voiceVlanDeviceInfoTreeHeap);
+    voiceVlanDeviceInfoTreeHeap = L7_NULLPTR;
+  }
+
+  if (voiceVlanDeviceInfoDataHeap != L7_NULLPTR)
+  {
+    osapiFree(L7_VOICE_VLAN_COMPONENT_ID, voiceVlanDeviceInfoDataHeap);
+    voiceVlanDeviceInfoDataHeap = L7_NULLPTR;
+  }
+  return L7_SUCCESS;
+}
+
+/*********************************************************************
+* @purpose  To Take lock for the voice vlan device Info Node
+*
+* @param    None
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments This lock needs to be taken only the API functions not running in
+*           the dot1x threads context.
+*
+* @end
+*********************************************************************/
+L7_RC_t voiceVlanDeviceInfoTakeLock(void)
+{
+  return osapiSemaTake(voiceVlanDeviceInfoTreeDb.semId, L7_WAIT_FOREVER);
+}
+
+/*********************************************************************
+* @purpose  To Giveup lock for the voice vlan device  Info Node
+*
+* @param    None
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments This lock needs to be taken only the API functions not running in
+*           the dot1x threads context.
+*
+* @end
+*********************************************************************/
+L7_RC_t voiceVlanDeviceInfoGiveLock(void)
+{
+  return osapiSemaGive(voiceVlanDeviceInfoTreeDb.semId);
+}
+
+/*********************************************************************
+* @purpose  To allocate a voice vlan Device Info Node
+*
+* @param    mac_addr        @b{(input)} Voip device mac address
+* @param    vlanId          @b{(input)} Voice Vlan Id associated with this mac address
+* @param    intIfNum        @b{(input)} The internal interface on which this
+*                                   voip device was identified
+* @param    clientAuthState @b{(input)} indicates if this device is an unauthenticated device
+* @param    sourceType      @b{(input)} sourceType of this device (LLDP, etc.)
+*
+* @returns  L7_SUCCESS    if the entry was created sucessfully
+*           L7_FAILURE
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+L7_RC_t voiceVlanDeviceInfoAlloc(L7_uchar8                 *mac_addr,
+                                 L7_uint32                  vlanId,
+                                 L7_uint32                  intIfNum,
+                                 L7_BOOL                    clientAuthState,
+                                 VOICE_VLAN_SOURCE_TYPES_t  sourceType)
+{
+  L7_uchar8   zeroMac[L7_MAC_ADDR_LEN];
+  voiceVlanDeviceInfo_t  newNode,*tmpNode=L7_NULLPTR,*retNode = L7_NULLPTR;
+
+
+   /* validate input */
+   memset (zeroMac ,0,L7_MAC_ADDR_LEN);
+
+   if ((memcmp(zeroMac,mac_addr,L7_MAC_ADDR_LEN)==0)||
+        (( clientAuthState!= L7_TRUE)&&(clientAuthState != L7_FALSE)))
+   {
+      return L7_FAILURE;
+   }
+
+   tmpNode = voiceVlanDeviceInfoGet(mac_addr);
+
+    if (tmpNode == L7_NULLPTR)
+    {
+      /* found one - use it */
+      memset(&newNode,0,sizeof(voiceVlanDeviceInfo_t));
+      memcpy(newNode.voipMac,mac_addr,L7_MAC_ADDR_LEN);
+      newNode.vlanId = vlanId;
+      newNode.intIfNum = intIfNum;
+      newNode.clientAuthState = clientAuthState;
+      newNode.sourceType = sourceType;
+
+      /* add the node to the tree */
+      osapiSemaTake(voiceVlanDeviceInfoTreeDb.semId, L7_WAIT_FOREVER);
+      retNode  = avlInsertEntry(&voiceVlanDeviceInfoTreeDb,&newNode);
+      osapiSemaGive(voiceVlanDeviceInfoTreeDb.semId);
+      if (retNode == &newNode)
+      {
+        L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
+        nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
+
+        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_VOICE_VLAN_COMPONENT_ID,
+                "%s:%d Error Adding the node to the Voice Vlan Device Info Tree for mac address: %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ,phyintf %d, %s, voice vlan : %d \n",
+                __FUNCTION__,__FILE__,
+                mac_addr[0],
+                mac_addr[1],
+                mac_addr[2],
+                mac_addr[3],
+                mac_addr[4],
+                mac_addr[5],
+                intIfNum, ifName,
+                vlanId);
+        return L7_FAILURE;
+      }
+      return L7_SUCCESS;
+    }
+    else
+    {
+      /* mac address already present in the database */
+      return L7_FAILURE;
+    }
+
+  return L7_FAILURE;
+}
+
+/*********************************************************************
+* @purpose  To Deallocate a voice Vlan Device Info Node
+*
+* @param    node  pointer to voiceVlanDeviceInfo structure
+*
+* @returns  L7_SUCCESS or L7_FAILURE
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+L7_RC_t voiceVlanDeviceInfoDeAlloc(voiceVlanDeviceInfo_t *node)
+{
+  if(node != L7_NULLPTR)
+  {
+     osapiSemaTake(voiceVlanDeviceInfoTreeDb.semId, L7_WAIT_FOREVER);
+     avlDeleteEntry(&voiceVlanDeviceInfoTreeDb,node);
+     osapiSemaGive(voiceVlanDeviceInfoTreeDb.semId);
+     return L7_SUCCESS;
+
+  }
+  return L7_FAILURE;
+}
+
+/*********************************************************************
+* @purpose  To Get a voice vlan Device Info Node
+*
+* @param    mac_addr  @b{(input)} The mac address of the voip device
+*
+* @returns  voice vlan device info node
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+voiceVlanDeviceInfo_t *voiceVlanDeviceInfoGet(L7_uchar8* mac_addr_key)
+{
+  L7_uchar8 zeroMac[L7_MAC_ADDR_LEN],key[L7_MAC_ADDR_LEN];
+  voiceVlanDeviceInfo_t  *entry = L7_NULLPTR;
+
+  /*validate mac address*/
+  memset(zeroMac,0,L7_MAC_ADDR_LEN);
+  if (memcmp(mac_addr_key,zeroMac,L7_MAC_ADDR_LEN)==0)
+  {
+    return  entry;
+  }
+
+  /* copy the mac address to the key*/
+  memset(key,0,L7_MAC_ADDR_LEN);
+  memcpy(key,mac_addr_key,L7_MAC_ADDR_LEN);
+  entry = (voiceVlanDeviceInfo_t *)avlSearchLVL7(&voiceVlanDeviceInfoTreeDb,key,AVL_EXACT);
+  return entry;
+}
+
+/*********************************************************************
+* @purpose  To Get Next voice vlan Device Info Node
+*
+* @param    mac_addr_key  @b{(input)} The mac address of the voice vlan device
+*
+* @returns  Logical Internal Interface node
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+voiceVlanDeviceInfo_t *voiceVlanDeviceInfoGetNext(L7_uchar8 *mac_addr_key)
+{
+  L7_uchar8 key[L7_MAC_ADDR_LEN];
+  voiceVlanDeviceInfo_t  *entry = L7_NULLPTR;
+
+   /* copy the mac address to the key*/
+  memset(key,0,L7_MAC_ADDR_LEN);
+  memcpy(key,mac_addr_key,L7_MAC_ADDR_LEN);
+  entry = (voiceVlanDeviceInfo_t *)avlSearchLVL7(&voiceVlanDeviceInfoTreeDb,key,AVL_NEXT);
+  return entry;
+}
+
+
+
+/*********************************************************************
+* @purpose  To get First voice vlan device  for a physical interface
+*
+* @param    intIfNum  @b{(input)} The internal interface
+*
+* @returns  Voice Vlan Device node
+*
+* @comments
+*
+* @end
+*********************************************************************/
+voiceVlanDeviceInfo_t *voiceVlanDeviceInfoFirstGet(L7_uint32 intIfNum)
+{
+  L7_uchar8 mac_key[L7_MAC_ADDR_LEN];
+  voiceVlanDeviceInfo_t *node;
+
+  memset(mac_key,0,L7_MAC_ADDR_LEN);
+
+  voiceVlanDeviceInfoTakeLock();
+  node=voiceVlanDeviceInfoGetNext(mac_key);
+  while(node!=L7_NULLPTR)
+  {
+    if (node->intIfNum == intIfNum)
+    {
+      voiceVlanDeviceInfoGiveLock();
+      return node;
+    }
+    memset(mac_key,0,L7_MAC_ADDR_LEN);
+    memcpy(mac_key,node->voipMac,L7_MAC_ADDR_LEN);
+    node=voiceVlanDeviceInfoGetNext(mac_key);
+  }
+
+  voiceVlanDeviceInfoGiveLock();
+  return L7_NULLPTR;
+}
+
+/*********************************************************************
+* @purpose  To iterate all the voice vlan devices of a physical interface
+*
+* @param    intIfNum  @b{(input)} The internal interface
+* @param    mac_addr  @b{(input/output)} The mac address of the last learnt voip device
+*
+* @returns  voice vlan device node
+*
+* @comments Give the last learnt mac address on that interface to get the next one
+*
+* @end
+*********************************************************************/
+voiceVlanDeviceInfo_t *voiceVlanDeviceInfoGetNextNode(L7_uint32 intIfNum,
+                                                        L7_uchar8 *mac_addr)
+{
+  voiceVlanDeviceInfo_t *node;
+
+   voiceVlanDeviceInfoTakeLock();
+   node=voiceVlanDeviceInfoGetNext(mac_addr);
+   while(node!=L7_NULLPTR)
+  {
+    if (node->intIfNum == intIfNum &&
+        memcmp(mac_addr,node->voipMac,L7_MAC_ADDR_LEN)!=0)
+    {
+      voiceVlanDeviceInfoGiveLock();
+      return node;
+    }
+    memset(mac_addr,0,L7_MAC_ADDR_LEN);
+    memcpy(mac_addr,node->voipMac,L7_MAC_ADDR_LEN);
+    node=voiceVlanDeviceInfoGetNext(mac_addr);
+  }
+
+  voiceVlanDeviceInfoGiveLock();
+  return L7_NULLPTR;
+}
+
+
+/*********************************************************************
+* @purpose  Debug Info of the voice vlan DB
+*
+* @param    None
+*
+* @returns  None
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+void voiceVlanDebugDeviceInfo(void)
+{
+  if(voiceVlanDeviceInfoTreeHeap != L7_NULLPTR)
+  {
+    SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
+                  "The Voice Vlan Device Database has %d Nodes\n",
+    voiceVlanDeviceInfoTreeDb.count);
+  }
+}
+
+/*********************************************************************
+* @purpose  Debug Info of the voice vlan DB
+*
+* @param    None
+*
+* @returns  None
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+void voiceVlanDebugDeviceInfoList(void)
+{
+  voiceVlanDeviceInfo_t *node = L7_NULLPTR;
+  L7_uchar8 mac_addr[L7_MAC_ADDR_LEN];
+
+  /*list device info in the tree*/
+  memset(mac_addr,0,L7_MAC_ADDR_LEN);
+
+  node=voiceVlanDeviceInfoGetNext(mac_addr);
+  while(node != L7_NULLPTR)
+  {
+    sysapiPrintf("\r\n Voip Mac address:%02X:%02X:%02X:%02X:%02X:%02X",
+                 node->voipMac[0],
+                 node->voipMac[1],
+                 node->voipMac[2],
+                 node->voipMac[3],
+                 node->voipMac[4],
+                 node->voipMac[5]);
+    sysapiPrintf("\n Interface: %d",node->intIfNum);
+    sysapiPrintf("\r\n Voice Vlan:%d",node->vlanId );
+    sysapiPrintf("\r\n Client Auth State:%d ",node->clientAuthState);
+    sysapiPrintf("\r\n ---------------------------------------------------------------------");
+
+    memset(mac_addr,0,L7_MAC_ADDR_LEN);
+    memcpy(mac_addr,node->voipMac,L7_MAC_ADDR_LEN);
+
+     /*checking the get command*/
+    node = voiceVlanDeviceInfoGet(mac_addr);
+    if (node != L7_NULLPTR)
+    {
+       sysapiPrintf("\r\n Voip Mac address:%02X:%02X:%02X:%02X:%02X:%02X",
+                   node->voipMac[0],
+                   node->voipMac[1],
+                   node->voipMac[2],
+                   node->voipMac[3],
+                   node->voipMac[4],
+                   node->voipMac[5]);
+      sysapiPrintf("\n Interface: %d",node->intIfNum);
+      sysapiPrintf("\r\n Voice Vlan:%d",node->vlanId );
+      sysapiPrintf("\r\n Client Auth State:%d ",node->clientAuthState);
+      sysapiPrintf("\r\n ---------------------------------------------------------------------");
+    }
+
+    node=voiceVlanDeviceInfoGetNext(mac_addr);
+  }
+}
+
+/*********************************************************************
+* @purpose  Debug Info of the voice vlan DB
+*
+* @param    None
+*
+* @returns  None
+*
+* @comments none
+*
+* @end
+*********************************************************************/
+void voiceVlanDebugDeviceInfoIntfList(L7_uint32 intIfNum)
+{
+  voiceVlanDeviceInfo_t *node = L7_NULLPTR;
+  L7_uchar8 mac_addr[L7_MAC_ADDR_LEN];
+
+  /*list device info in the tree*/
+  memset(mac_addr,0,L7_MAC_ADDR_LEN);
+
+  node= voiceVlanDeviceInfoFirstGet(intIfNum);
+  while(node != L7_NULLPTR)
+  {
+    sysapiPrintf("\r\n Voip Mac address:%02X:%02X:%02X:%02X:%02X:%02X",
+                 node->voipMac[0],
+                 node->voipMac[1],
+                 node->voipMac[2],
+                 node->voipMac[3],
+                 node->voipMac[4],
+                 node->voipMac[5]);
+    sysapiPrintf("\n Interface: %d",node->intIfNum);
+    sysapiPrintf("\r\n Voice Vlan:%d",node->vlanId );
+    sysapiPrintf("\r\n Client Auth State:%d ",node->clientAuthState);
+    sysapiPrintf("\r\n ---------------------------------------------------------------------");
+    memset(mac_addr,0,L7_MAC_ADDR_LEN);
+    memcpy(mac_addr,node->voipMac,L7_MAC_ADDR_LEN);
+    node=voiceVlanDeviceInfoGetNextNode(intIfNum,mac_addr);
+  }
+
+}
Index: src/application/switching/snooping/core/snooping_ptin_proxytimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_proxytimer.c	(revision 7370)
+++ src/application/switching/snooping/core/snooping_ptin_proxytimer.c	(revision 7371)
@@ -1,658 +1,658 @@
-/*
- * snooping_ptin_timer.c
- *
- *  Created on: 02 of Apr 2013
- *      Author: Mrcio Daniel Melo
- */
-
-#include "snooping_ptin_proxytimer.h"
-#include "snooping_ptin_util.h"
-#include "snooping_db.h"
-#include "snooping_ptin_db.h"
-
-#include "comm_mask.h"
-
-#include "ptin_igmp.h"
-
-#include <unistd.h>
-
-#define TIMER_COUNT 1
-
-/* Message placed in CB queue */
-typedef struct snoopPtinProxytimerParams_s
-{
-  L7_uint8 eventIdx;
-} snoopPtinProxytimerParams_t;
-#define PTIN_IGMP_TIMER_MSG_SIZE  sizeof(snoopPtinProxytimerParams_t)
-
-/* Static variables */
-static void                   *handleListMemHndl = L7_NULLPTR;
-static void                   *cbEventQueue = L7_NULLPTR;
-static void                   *timerSem = L7_NULLPTR;
-static L7_sll_t               timerLinkedList;
-static L7_uint32              cbTaskId = L7_ERROR;
-static L7_uint32              cbBufferPoolId = 0;
-static handle_list_t          *handleList;
-static L7_APP_TMR_CTRL_BLK_t  cbTimer;
-
-/* Static methods */
-static void     cbEventqueueTask(void);
-static void     cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData);
-static L7_RC_t  timerDataDestroy(L7_sll_member_t *ll_member);
-static L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key);
-static void     timerCallback(void *param);
-
-///* MASKISEQ verifies if mask j equal to mask k. */
-//
-//static L7_BOOL L7_INTF_MASKISEQ(L7_INTF_MASK_t mask1,L7_INTF_MASK_t mask2)
-//{
-//    L7_INTF_MASK_t *_p_;
-//    L7_INTF_MASK_t *_q_;
-//
-//    _p_ = (L7_INTF_MASK_t *)&mask1;
-//    _q_ = (L7_INTF_MASK_t *)&mask2;
-//    L7_uint32 x;
-//  for (x = 0; x < L7_INTF_INDICES; x++)
-// {
-//    if (_p_->value[x] != _q_->value[x])
-//      return L7_FALSE;
-// }
-// return L7_TRUE;
-//}
-
-/*********************************************************************
-* @purpose  Start Snooping task
-*
-* @param    none
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    none
-*
-* @end
-*********************************************************************/
-L7_RC_t snoop_ptin_proxytimer_init(void)
-{
-   /* Create queue semaphore */
-   timerSem = osapiSemaBCreate(OSAPI_SEM_Q_FIFO, OSAPI_SEM_FULL);
-   if (timerSem == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to create timers_sem semaphore!");
-     return L7_FAILURE;
-   }
-
-   /* Queue that will process timer events */
-   cbEventQueue = (void *) osapiMsgQueueCreate("cb_event_queue_proxytimer", TIMER_COUNT, PTIN_IGMP_TIMER_MSG_SIZE);
-   if (cbEventQueue == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"cb_event_queue creation error.");
-     return L7_FAILURE;
-   }
-
-   /* Create task for proxytimer management */
-   cbTaskId = osapiTaskCreate("ptin_igmp_proxytimer_task", cbEventqueueTask, 0, 0,
-                                         L7_DEFAULT_STACK_SIZE,
-                                         L7_TASK_PRIORITY_LEVEL(L7_DEFAULT_TASK_PRIORITY),
-                                         L7_DEFAULT_TASK_SLICE);
-   if (cbTaskId == L7_ERROR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR, "Could not create task ptin_igmp_proxytimer_task");
-     return L7_FAILURE;
-   }
-   if (osapiWaitForTaskInit (L7_PTIN_IGMP_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to initialize ptin_igmp_proxytimer_task");
-     return(L7_FAILURE);
-   }
-
-   /* Create CB buffer pool */
-   cbBufferPoolId = 0;
-   if(bufferPoolInit(TIMER_COUNT,
-                     sizeof(timerNode_t) /*L7_APP_TMR_NODE_SIZE*/,
-                     "PTin_IGMP_CB_ProxyTimer_Buffer",
-                     &cbBufferPoolId) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to allocate memory for IGMP Control Block timer buffers");
-     return L7_FAILURE;
-   }
-
-   /* Create SLL list for each IGMP instance */
-   if (SLLCreate(L7_PTIN_COMPONENT_ID, L7_SLL_NO_ORDER,
-                sizeof(L7_uint32)*2, timerDataCmp, timerDataDestroy,
-                &timerLinkedList) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Failed to create timer linked list");
-     return L7_FAILURE;
-   }
-
-   /* Allocate memory for the Handle List */
-   handleListMemHndl = (handle_member_t*) osapiMalloc(L7_PTIN_COMPONENT_ID, TIMER_COUNT*sizeof(handle_member_t));
-   if (handleListMemHndl == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Error allocating Handle List Buffers");
-     return L7_FAILURE;
-   }
-
-   /* Create timers handle list for this IGMP instance  */
-   if(handleListInit(L7_PTIN_COMPONENT_ID, TIMER_COUNT, &handleList, handleListMemHndl) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to create timer handle list");
-     return L7_FAILURE;
-   }
-
-   /* Initialize timer control blocks */
-   cbTimer = appTimerInit(L7_PTIN_COMPONENT_ID, (void *) cbtimerCallback,
-                          L7_NULLPTR, L7_APP_TMR_1SEC,
-                          cbBufferPoolId);
-   if (cbTimer  == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"snoopEntry App Timer Initialization Failed.");
-     return L7_FAILURE;
-   }
-
-   PT_LOG_TRACE(LOG_CTX_CNFGR,"Initializations for IGMPv3 group timers finished");
-
-  return(L7_SUCCESS);
-}
-
-/*********************************************************************
-* @purpose  Stop Snooping task
-*
-* @param    none
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    none
-*
-* @end
-*********************************************************************/
-L7_RC_t snoop_ptin_proxytimer_deinit(void)
-{
-  /* Deinitialize timer control blocks */
-  if (cbTimer != (L7_APP_TMR_CTRL_BLK_t) NULL)
-  {
-    appTimerDeInit(cbTimer);
-    cbTimer = (L7_APP_TMR_CTRL_BLK_t) NULL;
-  }
-
-  /* Remove timers handle list for this IGMP instance  */
-  handleListDeinit(L7_PTIN_COMPONENT_ID, handleList);
-
-  /* Free memory for the Handle List */
-  if (handleListMemHndl != L7_NULLPTR)
-  {
-    osapiFree(L7_PTIN_COMPONENT_ID, handleListMemHndl);
-    handleListMemHndl = L7_NULLPTR;
-  }
-
-  /* Destroy SLL list for each IGMP instance */
-  SLLDestroy(L7_PTIN_COMPONENT_ID, &timerLinkedList);
-
-  /* Buffer pool termination */
-  if (cbBufferPoolId != 0)
-  {
-    bufferPoolTerminate(cbBufferPoolId);
-    cbBufferPoolId = 0;
-  }
-
-  /* Delete task for proxytimer management */
-  if ( cbTaskId != L7_ERROR )
-  {
-    osapiTaskDelete(cbTaskId);
-    cbTaskId = L7_ERROR;
-  }
-
-  /* Queue that will process timer events */
-  if (cbEventQueue != L7_NULLPTR)
-  {
-    osapiMsgQueueDelete(cbEventQueue);
-    cbEventQueue = L7_NULLPTR;
-  }
-
-  osapiSemaDelete(timerSem);
-  timerSem = L7_NULLPTR;
-
-  return(L7_SUCCESS);
-}
-
-/*********************************************************************
-* @purpose   This function is used to send timer events
-*
-* @param     timerCtrlBlk    @b{(input)}   Timer Control Block
-* @param     ptrData         @b{(input)}   Ptr to passed data
-*
-* @returns   None
-*
-* @notes     None
-* @end
-*********************************************************************/
-void cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData)
-{
-  snoopPtinProxytimerParams_t msg = {0};
-  L7_RC_t                     rc;
-
-  rc = osapiMessageSend(cbEventQueue, &msg, PTIN_IGMP_TIMER_MSG_SIZE, L7_NO_WAIT,L7_MSG_PRIORITY_NORM);
-  if (rc != L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Proxytimer timer tick send failed");
-    return;
-  }
-}
-
-/*************************************************************************
-* @purpose Task that makes the timer processing for the proxytimer
-*          management 
-*  
-* @param    none
-*
-* @notes    none
-* @end
-*************************************************************************/
-void cbEventqueueTask(void)
-{
-  L7_uint32                   status;
-  snoopPtinProxytimerParams_t msg;
-
-  if (osapiTaskInitDone(L7_PTIN_IGMP_TASK_SYNC)!=L7_SUCCESS)
-  {
-    PT_LOG_FATAL(LOG_CTX_SSM, "Error syncing task");
-    PTIN_CRASH();
-  }
-
-  while (1)
-  {
-    status = (L7_uint32) osapiMessageReceive(cbEventQueue, (void*)&msg,
-                                             PTIN_IGMP_TIMER_MSG_SIZE, L7_WAIT_FOREVER);
-    if (status == L7_SUCCESS)
-    {
-        appTimerProcess(cbTimer);
-    }
-    else
-    {
-      PT_LOG_ERR(LOG_CTX_IGMP,"This is an invalid event");
-    }
-  }
-}
-
-/*************************************************************************
-* @purpose  Helper API to compare two proxytimer nodes and return the result
-*
-* @param     p  @b{(input)}  Pointer to Candidate 1 for comparison
-* @param     q  @b{(input)}  Pointer to Candidate 2 for comparison
-*
-* @returns   0   p = q
-* @returns  -1   p < q
-* @returns  +1   p > q
-*
-* @comments This is called by SLL library when nodes are compared
-*
-* @end
-*************************************************************************/
-L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key)
-{
-  if ((((snoopPTinProxyTimer_t *) p)->isInterface)==L7_TRUE && (((snoopPTinProxyTimer_t *) q)->isInterface)==L7_TRUE)
-  {
-    L7_uint32     pVlanId,qVlanId;
-    
-    pVlanId =       ((snoopPTinProxyInterface_t *) ((snoopPTinProxyTimer_t *) p)->groupData)->key.vlanId;
-
-    qVlanId =       ((snoopPTinProxyInterface_t *) ((snoopPTinProxyTimer_t *) q)->groupData)->key.vlanId;
-
-    if (pVlanId   == qVlanId )
-      return 0;
-
-  }
-  else if(((snoopPTinProxyTimer_t *)p)->isInterface!=L7_TRUE &&  ((snoopPTinProxyTimer_t *) q)->isInterface!=L7_TRUE)
-  {
-    L7_uint32 pvlanId,qvlanId;
-    L7_inet_addr_t pGroupAddr,qGroupAddr;
-    L7_uint8        pRecordType,qRecordType;
-
-    pvlanId =((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)p)->groupData)->key.vlanId;
-    pGroupAddr = ((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)p)->groupData)->key.groupAddr;
-    pRecordType = ((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)p)->groupData)->key.recordType;
-
-    qvlanId =((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)q)->groupData)->key.vlanId;
-
-    qGroupAddr =((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)q)->groupData)->key.groupAddr;
-    qRecordType = ((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)q)->groupData)->key.recordType;
-
-    if ( L7_INET_ADDR_COMPARE(&pGroupAddr,&qGroupAddr)==0 &&
-         pvlanId         == qvlanId         &&
-         pRecordType   == qRecordType )
-      return 0;
-  }
-  return 1;
-}
-
-/*************************************************************************
-* @purpose  API to destroy the proxytimer data node
-*
-* @param    ll_member  @b{(input)}  Linked list node containing the
-*                                   timer to be destroyed
-*
-* @returns  L7_SUCCESS
-*
-* @comments This is called by SLL library when a node is being deleted
-*
-* @end
-*************************************************************************/
-L7_RC_t timerDataDestroy (L7_sll_member_t *ll_member)
-{
-  snoopPTinProxyTimer_t *pTimerData;
-
-  /* Validate argument */
-  if (ll_member==L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
-    return L7_FAILURE;
-  }
-
-  pTimerData = (snoopPTinProxyTimer_t *)ll_member;
-
-  /* Destroy timer */
-  if (pTimerData->timer != L7_NULL)
-  {
-    /* Delete the apptimer node */
-    if (appTimerDelete(cbTimer, pTimerData->timer)!=L7_SUCCESS)
-    {
-      PT_LOG_NOTICE(LOG_CTX_IGMP,"Cannot delete timer");
-    }
-    pTimerData->timer = (L7_APP_TMR_HNDL_t) NULL;
-
-    /* Delete the handle we had created */
-    handleListNodeDelete(handleList, &pTimerData->timerHandle);
-    pTimerData->timerHandle = 0;
-  }
-  return L7_SUCCESS;
-}
-
-/*************************************************************************
- * @purpose Callback method that is called when the proxytimer expires.
- *
- * @param   param  Timer Handle
- *
- *************************************************************************/
-void timerCallback(void *param)
-{
-  char                    debug_buf[46];
-
-  snoopPTinProxyGroup_t*     groupPtr=L7_NULLPTR;
-  snoopPTinProxyInterface_t* interfacePtr;
-  L7_uint8                  robustnessVariable;
-  L7_BOOL                   isInterface;
-  L7_uint8                  reportType;
-  L7_uint32                 noOfRecords;
-  void*                     groupData;
-
-  L7_uint32               timerHandle;
-  snoopPTinProxyTimer_t *pTimerData;  
-  timerHandle = (L7_uint32) param;
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Get timer handler */
-  pTimerData = (snoopPTinProxyTimer_t*) handleListNodeRetrieve(timerHandle);
-  if (pTimerData == L7_NULLPTR)
-  {
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Failed to retrieve handle");
-    osapiSemaGive(timerSem);
-    return;
-  }
-
-  
-  /* Check if our handle is OK*/
-  if (timerHandle != pTimerData->timerHandle)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"timerHandle and pTimerData->timerHandle do not match!");
-    return;
-  }
-    
-
-  if (pTimerData->isInterface)
-  {
-    PT_LOG_TRACE(LOG_CTX_IGMP,"Proxy Interface timer expired (vlan:%u)",
-            ((snoopPTinProxyInterface_t *) pTimerData->groupData)->key.vlanId);    
-    interfacePtr    = (snoopPTinProxyInterface_t *) pTimerData->groupData;
-  }
-  else
-  {
-    PT_LOG_TRACE(LOG_CTX_IGMP,"Proxy Group timer expired(vlan:%u group:%s)",((snoopPTinProxyGroup_t *) pTimerData->groupData)->key.vlanId,
-            inetAddrPrint(&(((snoopPTinProxyGroup_t *) pTimerData->groupData)->key.groupAddr), debug_buf));
-    groupPtr    = (snoopPTinProxyGroup_t *) pTimerData->groupData;
-    interfacePtr=(snoopPTinProxyInterface_t*) groupPtr->interfacePtr;    
-  }
-  robustnessVariable=pTimerData->robustnessVariable;
-  isInterface=pTimerData->isInterface;
-  reportType=pTimerData->reportType;
-  noOfRecords=pTimerData->noOfRecords;
-  groupData=pTimerData->groupData;
-  /* Remove node for SLL list */
-  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimerData) != L7_SUCCESS)
-  {
-    osapiSemaGive(timerSem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node");
-    return;
-  }
-  osapiSemaGive(timerSem);
-
-
-  if (interfacePtr==L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"interfacePtr==L7_NULLPTR");
-    return ;
-  }
-  PT_LOG_TRACE(LOG_CTX_IGMP, "Trigger Membership Report Message");
-  if (snoopPTinScheduleReportMessage(interfacePtr->key.vlanId,&groupPtr->key.groupAddr,reportType,0,isInterface,noOfRecords,groupData,robustnessVariable)!=L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Failed snoopPTinReportSchedule()");
-    return ;
-  } 
-}
-
-/*************************************************************************
- * @purpose Start a proxytimer
- * 
- * @param   pTimer          Pointer to timer
- * @param   timeout         Timer's timeout
- * @param   groupData       Pointer to multicast group data
- * @param   interfaceIdx    Interface index
- *
- * @returns L7_SUCCESS
- * @returns L7_FAILURE
- *
- *************************************************************************/
-L7_RC_t snoop_ptin_proxytimer_start(snoopPTinProxyTimer_t* pTimer, L7_uint32 timeout,L7_uint8 reportType, L7_BOOL isInterface,L7_uint32 noOfRecords, void* groupData, L7_uint8 robustnessVariable)
-{
-  L7_BOOL                 restart_timer = L7_FALSE;
-  snoopPTinProxyTimer_t pTimerData;
-//char                    debug_buf[46];
-
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR || groupData == L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
-    return L7_FAILURE;
-  }
-
-  PT_LOG_TRACE(LOG_CTX_IGMP, "timeout:%u; reportType:%u; isInterface:%u;  noOfRecords:%u; robustnessVariable:%u",timeout,reportType,isInterface,noOfRecords,robustnessVariable);
-
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Check if this timer already exists */
-  memset(&pTimerData, 0x00, sizeof(pTimerData));
-  pTimerData.groupData     = groupData;
-  pTimerData.isInterface  = isInterface;
-  pTimerData.noOfRecords  = noOfRecords;
-  pTimerData.reportType  =  reportType;
-  pTimerData.robustnessVariable=robustnessVariable;
-  if (SLLFind(&timerLinkedList, (void *)&pTimerData) != L7_NULL)
-  {
-    restart_timer = L7_TRUE;
-    if (appTimerDelete(cbTimer, (void *) pTimer->timer) != L7_SUCCESS)
-    {
-      osapiSemaGive(timerSem);
-      PT_LOG_ERR(LOG_CTX_IGMP,"Failed restarting timer");
-      return L7_FAILURE;
-    }
-    pTimer->timer = L7_NULLPTR;
-
-    /* Remove timer handle */
-    handleListNodeDelete(handleList, &pTimer->timerHandle);
-    pTimer->timerHandle = 0;
-  }
-  else
-  {
-    pTimer->groupData    = groupData;
-    pTimer->isInterface = isInterface;
-    pTimer->reportType=reportType;
-    pTimer->noOfRecords= noOfRecords;
-    pTimer->robustnessVariable=robustnessVariable;
-  }
-
-  if (isInterface  || reportType==L7_IGMP_MEMBERSHIP_QUERY)
-  {
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Interface timer (timeout:%u)",timeout);
-  }
-  else
-  {
-#if 0
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Group timer (timeout:%u group:%s)",timeout,
-              inetAddrPrint(&pTimer->(snoopPTinProxyGroup_t*)(groupData)->key.groupAddr, debug_buf));
-#else
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Group timer (timeout:%u groupRecord:%u",timeout);
-#endif
-  }
-
-  /* New timer handle */
-  if ((pTimer->timerHandle = handleListNodeStore(handleList, pTimer)) == 0)
-  {
-    osapiSemaGive(timerSem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
-    return L7_FAILURE;
-  }
-
-  /* Add a new timer */
-  pTimer->timer = appTimerAdd(cbTimer, timerCallback,
-                              (void *) pTimer->timerHandle, timeout,
-                              "PTIN_TIMER");
-  if (pTimer->timer == NULL)
-  {
-    handleListNodeDelete(handleList, &pTimer->timerHandle);
-    pTimer->timerHandle = 0;
-    osapiSemaGive(timerSem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Could not start the proxytimer.");
-    return L7_FAILURE;
-  }
-
-  /* Add timer to SLL */
-  if (!restart_timer && (SLLAdd(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS))
-  {
-    if (appTimerDelete(cbTimer, pTimer->timer) != L7_SUCCESS)
-    {
-      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
-    }
-    pTimer->timer = L7_NULLPTR;
-    handleListNodeDelete(handleList, &pTimer->timerHandle);
-    memset(pTimer, 0x00, sizeof(pTimer));
-    osapiSemaGive(timerSem);
-    PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
-    return L7_FAILURE;
-  }
-
-  osapiSemaGive(timerSem);
-  return L7_SUCCESS;
-}
-
-/*************************************************************************
- * @purpose Stop a proxytimer
- * 
- * @param   pTimer  Pointer to timer
- *
- * @returns L7_SUCCESS
- * @returns L7_FAILURE
- *
- *************************************************************************/
-L7_RC_t snoop_ptin_proxytimer_stop(snoopPTinProxyTimer_t *pTimer)
-{
-  char debug_buf[46];
-
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR || pTimer->groupData == L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
-    return L7_FAILURE;
-  }
-
-
-  if (pTimer->isInterface)
-  {
-    PT_LOG_TRACE(LOG_CTX_IGMP,"Stopping Proxy Interface timer");    
-  }
-  else
-  {
-    PT_LOG_TRACE(LOG_CTX_IGMP,"Stopping Proxy Group timer (group:%s)",
-            inetAddrPrint(&(((snoopPTinProxyGroup_t *) pTimer->groupData)->key.groupAddr), debug_buf));    
-  }
-
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Remove node for SLL list */
-  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS)
-  {
-    osapiSemaGive(timerSem);
-    PT_LOG_NOTICE(LOG_CTX_IGMP,"Failed to delete timer node");
-    return L7_FAILURE;
-  }
-
-  osapiSemaGive(timerSem);
-
-  return L7_SUCCESS;
-}
-
-/*************************************************************************
- * @purpose Get the timeleft for a given sourcetimer
- * 
- * @param   pTimer  Pointer to timer
- *
- * @returns Timer's time left
- *
- *************************************************************************/
-L7_uint32 snoop_ptin_proxytimer_timeleft(snoopPTinProxyTimer_t *pTimer)
-{
-  L7_uint32 time_left = 0;
-
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR || pTimer->timer == L7_NULLPTR)
-  { 
-    return 0;
-  }
-
-  appTimerTimeLeftGet(cbTimer, pTimer->timer, &time_left);
-
-  return time_left;
-}
-
-
-/*************************************************************************
- * @purpose Verify if the timer is running or not
- * 
- * @param   pTimer  Pointer to timer
- *
- * @returns Timer's time left
- *
- *************************************************************************/
-L7_BOOL snoop_ptin_proxytimer_isRunning(snoopPTinProxyTimer_t *pTimer)
-{
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR || pTimer->timer == L7_NULLPTR)
-  { 
-    return L7_FALSE;
-  }
-  else
-  {
-    return L7_TRUE;
-  }
-}
-
+/*
+ * snooping_ptin_timer.c
+ *
+ *  Created on: 02 of Apr 2013
+ *      Author: Mrcio Daniel Melo
+ */
+
+#include "snooping_ptin_proxytimer.h"
+#include "snooping_ptin_util.h"
+#include "snooping_db.h"
+#include "snooping_ptin_db.h"
+
+#include "comm_mask.h"
+
+#include "ptin_igmp.h"
+
+#include <unistd.h>
+
+#define TIMER_COUNT 1
+
+/* Message placed in CB queue */
+typedef struct snoopPtinProxytimerParams_s
+{
+  L7_uint8 eventIdx;
+} snoopPtinProxytimerParams_t;
+#define PTIN_IGMP_TIMER_MSG_SIZE  sizeof(snoopPtinProxytimerParams_t)
+
+/* Static variables */
+static void                   *handleListMemHndl = L7_NULLPTR;
+static void                   *cbEventQueue = L7_NULLPTR;
+static void                   *timerSem = L7_NULLPTR;
+static L7_sll_t               timerLinkedList;
+static L7_uint32              cbTaskId = L7_ERROR;
+static L7_uint32              cbBufferPoolId = 0;
+static handle_list_t          *handleList;
+static L7_APP_TMR_CTRL_BLK_t  cbTimer;
+
+/* Static methods */
+static void     cbEventqueueTask(void);
+static void     cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData);
+static L7_RC_t  timerDataDestroy(L7_sll_member_t *ll_member);
+static L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key);
+static void     timerCallback(void *param);
+
+///* MASKISEQ verifies if mask j equal to mask k. */
+//
+//static L7_BOOL L7_INTF_MASKISEQ(L7_INTF_MASK_t mask1,L7_INTF_MASK_t mask2)
+//{
+//    L7_INTF_MASK_t *_p_;
+//    L7_INTF_MASK_t *_q_;
+//
+//    _p_ = (L7_INTF_MASK_t *)&mask1;
+//    _q_ = (L7_INTF_MASK_t *)&mask2;
+//    L7_uint32 x;
+//  for (x = 0; x < L7_INTF_INDICES; x++)
+// {
+//    if (_p_->value[x] != _q_->value[x])
+//      return L7_FALSE;
+// }
+// return L7_TRUE;
+//}
+
+/*********************************************************************
+* @purpose  Start Snooping task
+*
+* @param    none
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    none
+*
+* @end
+*********************************************************************/
+L7_RC_t snoop_ptin_proxytimer_init(void)
+{
+   /* Create queue semaphore */
+   timerSem = osapiSemaBCreate(OSAPI_SEM_Q_FIFO, OSAPI_SEM_FULL);
+   if (timerSem == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to create timers_sem semaphore!");
+     return L7_FAILURE;
+   }
+
+   /* Queue that will process timer events */
+   cbEventQueue = (void *) osapiMsgQueueCreate("cb_event_queue_proxytimer", TIMER_COUNT, PTIN_IGMP_TIMER_MSG_SIZE);
+   if (cbEventQueue == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"cb_event_queue creation error.");
+     return L7_FAILURE;
+   }
+
+   /* Create task for proxytimer management */
+   cbTaskId = osapiTaskCreate("ptin_igmp_proxytimer_task", cbEventqueueTask, 0, 0,
+                                         L7_DEFAULT_STACK_SIZE,
+                                         L7_TASK_PRIORITY_LEVEL(L7_DEFAULT_TASK_PRIORITY),
+                                         L7_DEFAULT_TASK_SLICE);
+   if (cbTaskId == L7_ERROR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR, "Could not create task ptin_igmp_proxytimer_task");
+     return L7_FAILURE;
+   }
+   if (osapiWaitForTaskInit (L7_PTIN_IGMP_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to initialize ptin_igmp_proxytimer_task");
+     return(L7_FAILURE);
+   }
+
+   /* Create CB buffer pool */
+   cbBufferPoolId = 0;
+   if(bufferPoolInit(TIMER_COUNT,
+                     sizeof(timerNode_t) /*L7_APP_TMR_NODE_SIZE*/,
+                     "PTin_IGMP_CB_ProxyTimer_Buffer",
+                     &cbBufferPoolId) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to allocate memory for IGMP Control Block timer buffers");
+     return L7_FAILURE;
+   }
+
+   /* Create SLL list for each IGMP instance */
+   if (SLLCreate(L7_PTIN_COMPONENT_ID, L7_SLL_NO_ORDER,
+                sizeof(L7_uint32)*2, timerDataCmp, timerDataDestroy,
+                &timerLinkedList) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Failed to create timer linked list");
+     return L7_FAILURE;
+   }
+
+   /* Allocate memory for the Handle List */
+   handleListMemHndl = (handle_member_t*) osapiMalloc(L7_PTIN_COMPONENT_ID, TIMER_COUNT*sizeof(handle_member_t));
+   if (handleListMemHndl == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Error allocating Handle List Buffers");
+     return L7_FAILURE;
+   }
+
+   /* Create timers handle list for this IGMP instance  */
+   if(handleListInit(L7_PTIN_COMPONENT_ID, TIMER_COUNT, &handleList, handleListMemHndl) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to create timer handle list");
+     return L7_FAILURE;
+   }
+
+   /* Initialize timer control blocks */
+   cbTimer = appTimerInit(L7_PTIN_COMPONENT_ID, (void *) cbtimerCallback,
+                          L7_NULLPTR, L7_APP_TMR_1SEC,
+                          cbBufferPoolId);
+   if (cbTimer  == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"snoopEntry App Timer Initialization Failed.");
+     return L7_FAILURE;
+   }
+
+   PT_LOG_TRACE(LOG_CTX_CNFGR,"Initializations for IGMPv3 group timers finished");
+
+  return(L7_SUCCESS);
+}
+
+/*********************************************************************
+* @purpose  Stop Snooping task
+*
+* @param    none
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    none
+*
+* @end
+*********************************************************************/
+L7_RC_t snoop_ptin_proxytimer_deinit(void)
+{
+  /* Deinitialize timer control blocks */
+  if (cbTimer != (L7_APP_TMR_CTRL_BLK_t) NULL)
+  {
+    appTimerDeInit(cbTimer);
+    cbTimer = (L7_APP_TMR_CTRL_BLK_t) NULL;
+  }
+
+  /* Remove timers handle list for this IGMP instance  */
+  handleListDeinit(L7_PTIN_COMPONENT_ID, handleList);
+
+  /* Free memory for the Handle List */
+  if (handleListMemHndl != L7_NULLPTR)
+  {
+    osapiFree(L7_PTIN_COMPONENT_ID, handleListMemHndl);
+    handleListMemHndl = L7_NULLPTR;
+  }
+
+  /* Destroy SLL list for each IGMP instance */
+  SLLDestroy(L7_PTIN_COMPONENT_ID, &timerLinkedList);
+
+  /* Buffer pool termination */
+  if (cbBufferPoolId != 0)
+  {
+    bufferPoolTerminate(cbBufferPoolId);
+    cbBufferPoolId = 0;
+  }
+
+  /* Delete task for proxytimer management */
+  if ( cbTaskId != L7_ERROR )
+  {
+    osapiTaskDelete(cbTaskId);
+    cbTaskId = L7_ERROR;
+  }
+
+  /* Queue that will process timer events */
+  if (cbEventQueue != L7_NULLPTR)
+  {
+    osapiMsgQueueDelete(cbEventQueue);
+    cbEventQueue = L7_NULLPTR;
+  }
+
+  osapiSemaDelete(timerSem);
+  timerSem = L7_NULLPTR;
+
+  return(L7_SUCCESS);
+}
+
+/*********************************************************************
+* @purpose   This function is used to send timer events
+*
+* @param     timerCtrlBlk    @b{(input)}   Timer Control Block
+* @param     ptrData         @b{(input)}   Ptr to passed data
+*
+* @returns   None
+*
+* @notes     None
+* @end
+*********************************************************************/
+void cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData)
+{
+  snoopPtinProxytimerParams_t msg = {0};
+  L7_RC_t                     rc;
+
+  rc = osapiMessageSend(cbEventQueue, &msg, PTIN_IGMP_TIMER_MSG_SIZE, L7_NO_WAIT,L7_MSG_PRIORITY_NORM);
+  if (rc != L7_SUCCESS)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Proxytimer timer tick send failed");
+    return;
+  }
+}
+
+/*************************************************************************
+* @purpose Task that makes the timer processing for the proxytimer
+*          management 
+*  
+* @param    none
+*
+* @notes    none
+* @end
+*************************************************************************/
+void cbEventqueueTask(void)
+{
+  L7_uint32                   status;
+  snoopPtinProxytimerParams_t msg;
+
+  if (osapiTaskInitDone(L7_PTIN_IGMP_TASK_SYNC)!=L7_SUCCESS)
+  {
+    PT_LOG_FATAL(LOG_CTX_SSM, "Error syncing task");
+    PTIN_CRASH();
+  }
+
+  while (1)
+  {
+    status = (L7_uint32) osapiMessageReceive(cbEventQueue, (void*)&msg,
+                                             PTIN_IGMP_TIMER_MSG_SIZE, L7_WAIT_FOREVER);
+    if (status == L7_SUCCESS)
+    {
+        appTimerProcess(cbTimer);
+    }
+    else
+    {
+      PT_LOG_ERR(LOG_CTX_IGMP,"This is an invalid event");
+    }
+  }
+}
+
+/*************************************************************************
+* @purpose  Helper API to compare two proxytimer nodes and return the result
+*
+* @param     p  @b{(input)}  Pointer to Candidate 1 for comparison
+* @param     q  @b{(input)}  Pointer to Candidate 2 for comparison
+*
+* @returns   0   p = q
+* @returns  -1   p < q
+* @returns  +1   p > q
+*
+* @comments This is called by SLL library when nodes are compared
+*
+* @end
+*************************************************************************/
+L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key)
+{
+  if ((((snoopPTinProxyTimer_t *) p)->isInterface)==L7_TRUE && (((snoopPTinProxyTimer_t *) q)->isInterface)==L7_TRUE)
+  {
+    L7_uint32     pVlanId,qVlanId;
+    
+    pVlanId =       ((snoopPTinProxyInterface_t *) ((snoopPTinProxyTimer_t *) p)->groupData)->key.vlanId;
+
+    qVlanId =       ((snoopPTinProxyInterface_t *) ((snoopPTinProxyTimer_t *) q)->groupData)->key.vlanId;
+
+    if (pVlanId   == qVlanId )
+      return 0;
+
+  }
+  else if(((snoopPTinProxyTimer_t *)p)->isInterface!=L7_TRUE &&  ((snoopPTinProxyTimer_t *) q)->isInterface!=L7_TRUE)
+  {
+    L7_uint32 pvlanId,qvlanId;
+    L7_inet_addr_t pGroupAddr,qGroupAddr;
+    L7_uint8        pRecordType,qRecordType;
+
+    pvlanId =((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)p)->groupData)->key.vlanId;
+    pGroupAddr = ((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)p)->groupData)->key.groupAddr;
+    pRecordType = ((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)p)->groupData)->key.recordType;
+
+    qvlanId =((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)q)->groupData)->key.vlanId;
+
+    qGroupAddr =((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)q)->groupData)->key.groupAddr;
+    qRecordType = ((snoopPTinProxyGroup_t *) ((snoopPTinProxyTimer_t *)q)->groupData)->key.recordType;
+
+    if ( L7_INET_ADDR_COMPARE(&pGroupAddr,&qGroupAddr)==0 &&
+         pvlanId         == qvlanId         &&
+         pRecordType   == qRecordType )
+      return 0;
+  }
+  return 1;
+}
+
+/*************************************************************************
+* @purpose  API to destroy the proxytimer data node
+*
+* @param    ll_member  @b{(input)}  Linked list node containing the
+*                                   timer to be destroyed
+*
+* @returns  L7_SUCCESS
+*
+* @comments This is called by SLL library when a node is being deleted
+*
+* @end
+*************************************************************************/
+L7_RC_t timerDataDestroy (L7_sll_member_t *ll_member)
+{
+  snoopPTinProxyTimer_t *pTimerData;
+
+  /* Validate argument */
+  if (ll_member==L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
+    return L7_FAILURE;
+  }
+
+  pTimerData = (snoopPTinProxyTimer_t *)ll_member;
+
+  /* Destroy timer */
+  if (pTimerData->timer != L7_NULL)
+  {
+    /* Delete the apptimer node */
+    if (appTimerDelete(cbTimer, pTimerData->timer)!=L7_SUCCESS)
+    {
+      PT_LOG_NOTICE(LOG_CTX_IGMP,"Cannot delete timer");
+    }
+    pTimerData->timer = (L7_APP_TMR_HNDL_t) NULL;
+
+    /* Delete the handle we had created */
+    handleListNodeDelete(handleList, &pTimerData->timerHandle);
+    pTimerData->timerHandle = 0;
+  }
+  return L7_SUCCESS;
+}
+
+/*************************************************************************
+ * @purpose Callback method that is called when the proxytimer expires.
+ *
+ * @param   param  Timer Handle
+ *
+ *************************************************************************/
+void timerCallback(void *param)
+{
+  char                    debug_buf[46];
+
+  snoopPTinProxyGroup_t*     groupPtr=L7_NULLPTR;
+  snoopPTinProxyInterface_t* interfacePtr;
+  L7_uint8                  robustnessVariable;
+  L7_BOOL                   isInterface;
+  L7_uint8                  reportType;
+  L7_uint32                 noOfRecords;
+  void*                     groupData;
+
+  L7_uint32               timerHandle;
+  snoopPTinProxyTimer_t *pTimerData;  
+  timerHandle = (L7_uint32) param;
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Get timer handler */
+  pTimerData = (snoopPTinProxyTimer_t*) handleListNodeRetrieve(timerHandle);
+  if (pTimerData == L7_NULLPTR)
+  {
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Failed to retrieve handle");
+    osapiSemaGive(timerSem);
+    return;
+  }
+
+  
+  /* Check if our handle is OK*/
+  if (timerHandle != pTimerData->timerHandle)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"timerHandle and pTimerData->timerHandle do not match!");
+    return;
+  }
+    
+
+  if (pTimerData->isInterface)
+  {
+    PT_LOG_TRACE(LOG_CTX_IGMP,"Proxy Interface timer expired (vlan:%u)",
+            ((snoopPTinProxyInterface_t *) pTimerData->groupData)->key.vlanId);    
+    interfacePtr    = (snoopPTinProxyInterface_t *) pTimerData->groupData;
+  }
+  else
+  {
+    PT_LOG_TRACE(LOG_CTX_IGMP,"Proxy Group timer expired(vlan:%u group:%s)",((snoopPTinProxyGroup_t *) pTimerData->groupData)->key.vlanId,
+            inetAddrPrint(&(((snoopPTinProxyGroup_t *) pTimerData->groupData)->key.groupAddr), debug_buf));
+    groupPtr    = (snoopPTinProxyGroup_t *) pTimerData->groupData;
+    interfacePtr=(snoopPTinProxyInterface_t*) groupPtr->interfacePtr;    
+  }
+  robustnessVariable=pTimerData->robustnessVariable;
+  isInterface=pTimerData->isInterface;
+  reportType=pTimerData->reportType;
+  noOfRecords=pTimerData->noOfRecords;
+  groupData=pTimerData->groupData;
+  /* Remove node for SLL list */
+  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimerData) != L7_SUCCESS)
+  {
+    osapiSemaGive(timerSem);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node");
+    return;
+  }
+  osapiSemaGive(timerSem);
+
+
+  if (interfacePtr==L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"interfacePtr==L7_NULLPTR");
+    return ;
+  }
+  PT_LOG_TRACE(LOG_CTX_IGMP, "Trigger Membership Report Message");
+  if (snoopPTinScheduleReportMessage(interfacePtr->key.vlanId,&groupPtr->key.groupAddr,reportType,0,isInterface,noOfRecords,groupData,robustnessVariable)!=L7_SUCCESS)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Failed snoopPTinReportSchedule()");
+    return ;
+  } 
+}
+
+/*************************************************************************
+ * @purpose Start a proxytimer
+ * 
+ * @param   pTimer          Pointer to timer
+ * @param   timeout         Timer's timeout
+ * @param   groupData       Pointer to multicast group data
+ * @param   interfaceIdx    Interface index
+ *
+ * @returns L7_SUCCESS
+ * @returns L7_FAILURE
+ *
+ *************************************************************************/
+L7_RC_t snoop_ptin_proxytimer_start(snoopPTinProxyTimer_t* pTimer, L7_uint32 timeout,L7_uint8 reportType, L7_BOOL isInterface,L7_uint32 noOfRecords, void* groupData, L7_uint8 robustnessVariable)
+{
+  L7_BOOL                 restart_timer = L7_FALSE;
+  snoopPTinProxyTimer_t pTimerData;
+//char                    debug_buf[46];
+
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR || groupData == L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
+    return L7_FAILURE;
+  }
+
+  PT_LOG_TRACE(LOG_CTX_IGMP, "timeout:%u; reportType:%u; isInterface:%u;  noOfRecords:%u; robustnessVariable:%u",timeout,reportType,isInterface,noOfRecords,robustnessVariable);
+
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Check if this timer already exists */
+  memset(&pTimerData, 0x00, sizeof(pTimerData));
+  pTimerData.groupData     = groupData;
+  pTimerData.isInterface  = isInterface;
+  pTimerData.noOfRecords  = noOfRecords;
+  pTimerData.reportType  =  reportType;
+  pTimerData.robustnessVariable=robustnessVariable;
+  if (SLLFind(&timerLinkedList, (void *)&pTimerData) != L7_NULL)
+  {
+    restart_timer = L7_TRUE;
+    if (appTimerDelete(cbTimer, (void *) pTimer->timer) != L7_SUCCESS)
+    {
+      osapiSemaGive(timerSem);
+      PT_LOG_ERR(LOG_CTX_IGMP,"Failed restarting timer");
+      return L7_FAILURE;
+    }
+    pTimer->timer = L7_NULLPTR;
+
+    /* Remove timer handle */
+    handleListNodeDelete(handleList, &pTimer->timerHandle);
+    pTimer->timerHandle = 0;
+  }
+  else
+  {
+    pTimer->groupData    = groupData;
+    pTimer->isInterface = isInterface;
+    pTimer->reportType=reportType;
+    pTimer->noOfRecords= noOfRecords;
+    pTimer->robustnessVariable=robustnessVariable;
+  }
+
+  if (isInterface  || reportType==L7_IGMP_MEMBERSHIP_QUERY)
+  {
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Interface timer (timeout:%u)",timeout);
+  }
+  else
+  {
+#if 0
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Group timer (timeout:%u group:%s)",timeout,
+              inetAddrPrint(&pTimer->(snoopPTinProxyGroup_t*)(groupData)->key.groupAddr, debug_buf));
+#else
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Group timer (timeout:%u groupRecord:%u",timeout);
+#endif
+  }
+
+  /* New timer handle */
+  if ((pTimer->timerHandle = handleListNodeStore(handleList, pTimer)) == 0)
+  {
+    osapiSemaGive(timerSem);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
+    return L7_FAILURE;
+  }
+
+  /* Add a new timer */
+  pTimer->timer = appTimerAdd(cbTimer, timerCallback,
+                              (void *) pTimer->timerHandle, timeout,
+                              "PTIN_TIMER");
+  if (pTimer->timer == NULL)
+  {
+    handleListNodeDelete(handleList, &pTimer->timerHandle);
+    pTimer->timerHandle = 0;
+    osapiSemaGive(timerSem);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Could not start the proxytimer.");
+    return L7_FAILURE;
+  }
+
+  /* Add timer to SLL */
+  if (!restart_timer && (SLLAdd(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS))
+  {
+    if (appTimerDelete(cbTimer, pTimer->timer) != L7_SUCCESS)
+    {
+      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
+    }
+    pTimer->timer = L7_NULLPTR;
+    handleListNodeDelete(handleList, &pTimer->timerHandle);
+    memset(pTimer, 0x00, sizeof(pTimer));
+    osapiSemaGive(timerSem);
+    PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
+    return L7_FAILURE;
+  }
+
+  osapiSemaGive(timerSem);
+  return L7_SUCCESS;
+}
+
+/*************************************************************************
+ * @purpose Stop a proxytimer
+ * 
+ * @param   pTimer  Pointer to timer
+ *
+ * @returns L7_SUCCESS
+ * @returns L7_FAILURE
+ *
+ *************************************************************************/
+L7_RC_t snoop_ptin_proxytimer_stop(snoopPTinProxyTimer_t *pTimer)
+{
+  char debug_buf[46];
+
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR || pTimer->groupData == L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
+    return L7_FAILURE;
+  }
+
+
+  if (pTimer->isInterface)
+  {
+    PT_LOG_TRACE(LOG_CTX_IGMP,"Stopping Proxy Interface timer");    
+  }
+  else
+  {
+    PT_LOG_TRACE(LOG_CTX_IGMP,"Stopping Proxy Group timer (group:%s)",
+            inetAddrPrint(&(((snoopPTinProxyGroup_t *) pTimer->groupData)->key.groupAddr), debug_buf));    
+  }
+
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Remove node for SLL list */
+  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS)
+  {
+    osapiSemaGive(timerSem);
+    PT_LOG_NOTICE(LOG_CTX_IGMP,"Failed to delete timer node");
+    return L7_FAILURE;
+  }
+
+  osapiSemaGive(timerSem);
+
+  return L7_SUCCESS;
+}
+
+/*************************************************************************
+ * @purpose Get the timeleft for a given sourcetimer
+ * 
+ * @param   pTimer  Pointer to timer
+ *
+ * @returns Timer's time left
+ *
+ *************************************************************************/
+L7_uint32 snoop_ptin_proxytimer_timeleft(snoopPTinProxyTimer_t *pTimer)
+{
+  L7_uint32 time_left = 0;
+
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR || pTimer->timer == L7_NULLPTR)
+  { 
+    return 0;
+  }
+
+  appTimerTimeLeftGet(cbTimer, pTimer->timer, &time_left);
+
+  return time_left;
+}
+
+
+/*************************************************************************
+ * @purpose Verify if the timer is running or not
+ * 
+ * @param   pTimer  Pointer to timer
+ *
+ * @returns Timer's time left
+ *
+ *************************************************************************/
+L7_BOOL snoop_ptin_proxytimer_isRunning(snoopPTinProxyTimer_t *pTimer)
+{
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR || pTimer->timer == L7_NULLPTR)
+  { 
+    return L7_FALSE;
+  }
+  else
+  {
+    return L7_TRUE;
+  }
+}
+
Index: src/application/switching/snooping/core/snooping_ptin_grouptimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_grouptimer.c	(revision 7370)
+++ src/application/switching/snooping/core/snooping_ptin_grouptimer.c	(revision 7371)
@@ -1,690 +1,690 @@
-/*
- * snooping_ptin_grouptimer.c
- *
- *  Created on: 22 de Abr de 2013
- *      Author: Daniel Figueira
- */
-
-#include "snooping_ptin_grouptimer.h"
-#include "snooping_ptin_util.h"
-#include "snooping_db.h"
-#include "snooping_ptin_db.h"
-
-#include "ptin_igmp.h"
-
-#include <unistd.h>
-
-#define TIMER_COUNT 1
-
-/* Message placed in CB queue */
-typedef struct snoopPtinGrouptimerParams_s
-{
-  L7_uint8 eventIdx;
-} snoopPtinGrouptimerParams_t;
-#define PTIN_IGMP_TIMER_MSG_SIZE  sizeof(snoopPtinGrouptimerParams_t)
-
-/* Static variables */
-static void                   *handleListMemHndl = L7_NULLPTR;
-static void                   *cbEventQueue = L7_NULLPTR;
-static void                   *timerSem = L7_NULLPTR;
-static L7_sll_t               timerLinkedList;
-static L7_uint32              cbTaskId = L7_ERROR;
-static L7_uint32              cbBufferPoolId = 0;
-static handle_list_t          *handleList;
-static L7_APP_TMR_CTRL_BLK_t  cbTimer;
-
-/* Static methods */
-static void     cbEventqueueTask(void);
-static void     cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData);
-static L7_RC_t  timerDataDestroy(L7_sll_member_t *ll_member);
-static L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key);
-static void     timerCallback(void *param);
-
-
-/*********************************************************************
-* @purpose  Start Snooping task
-*
-* @param    none
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    none
-*
-* @end
-*********************************************************************/
-L7_RC_t snoop_ptin_grouptimer_init(void)
-{
-   /* Create queue semaphore */
-   timerSem = osapiSemaBCreate(OSAPI_SEM_Q_FIFO, OSAPI_SEM_FULL);
-   if (timerSem == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to create timers_sem semaphore!");
-     return L7_FAILURE;
-   }
-
-   /* Queue that will process timer events */
-   cbEventQueue = (void *) osapiMsgQueueCreate("cb_event_queue_grouptimer", TIMER_COUNT, PTIN_IGMP_TIMER_MSG_SIZE);
-   if (cbEventQueue == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"cb_event_queue creation error.");
-     return L7_FAILURE;
-   }
-
-   /* Create task for grouptimer management */
-   cbTaskId = osapiTaskCreate("ptin_igmp_grouptimer_task", cbEventqueueTask, 0, 0,
-                                         L7_DEFAULT_STACK_SIZE,
-                                         L7_TASK_PRIORITY_LEVEL(L7_DEFAULT_TASK_PRIORITY),
-                                         L7_DEFAULT_TASK_SLICE);
-   if (cbTaskId == L7_ERROR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR, "Could not create task ptin_igmp_grouptimer_task");
-     return L7_FAILURE;
-   }
-   if (osapiWaitForTaskInit (L7_PTIN_IGMP_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to initialize ptin_igmp_grouptimer_task");
-     return(L7_FAILURE);
-   }
-
-   /* Create CB buffer pool */
-   cbBufferPoolId = 0;
-   if(bufferPoolInit(TIMER_COUNT,
-                     sizeof(timerNode_t) /*L7_APP_TMR_NODE_SIZE*/,
-                     "PTin_IGMP_CB_GroupTimer_Buffer",
-                     &cbBufferPoolId) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to allocate memory for IGMP Control Block timer buffers");
-     return L7_FAILURE;
-   }
-
-   /* Create SLL list for each IGMP instance */
-   if (SLLCreate(L7_PTIN_COMPONENT_ID, L7_SLL_NO_ORDER,
-                sizeof(L7_uint32)*2, timerDataCmp, timerDataDestroy,
-                &timerLinkedList) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Failed to create timer linked list");
-     return L7_FAILURE;
-   }
-
-   /* Allocate memory for the Handle List */
-   handleListMemHndl = (handle_member_t*) osapiMalloc(L7_PTIN_COMPONENT_ID, TIMER_COUNT*sizeof(handle_member_t));
-   if (handleListMemHndl == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Error allocating Handle List Buffers");
-     return L7_FAILURE;
-   }
-
-   /* Create timers handle list for this IGMP instance  */
-   if(handleListInit(L7_PTIN_COMPONENT_ID, TIMER_COUNT, &handleList, handleListMemHndl) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to create timer handle list");
-     return L7_FAILURE;
-   }
-
-   /* Initialize timer control blocks */
-   cbTimer = appTimerInit(L7_PTIN_COMPONENT_ID, (void *) cbtimerCallback,
-                          L7_NULLPTR, L7_APP_TMR_1SEC,
-                          cbBufferPoolId);
-   if (cbTimer  == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"snoopEntry App Timer Initialization Failed.");
-     return L7_FAILURE;
-   }
-
-   PT_LOG_TRACE(LOG_CTX_CNFGR,"Initializations for IGMPv3 group timers finished");
-
-  return(L7_SUCCESS);
-}
-
-/*********************************************************************
-* @purpose  Stop Snooping task
-*
-* @param    none
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    none
-*
-* @end
-*********************************************************************/
-L7_RC_t snoop_ptin_grouptimer_deinit(void)
-{
-  /* Deinitialize timer control blocks */
-  if (cbTimer != (L7_APP_TMR_CTRL_BLK_t) NULL)
-  {
-    appTimerDeInit(cbTimer);
-    cbTimer = (L7_APP_TMR_CTRL_BLK_t) NULL;
-  }
-
-  /* Remove timers handle list for this IGMP instance  */
-  handleListDeinit(L7_PTIN_COMPONENT_ID, handleList);
-
-  /* Free memory for the Handle List */
-  if (handleListMemHndl != L7_NULLPTR)
-  {
-    osapiFree(L7_PTIN_COMPONENT_ID, handleListMemHndl);
-    handleListMemHndl = L7_NULLPTR;
-  }
-
-  /* Destroy SLL list for each IGMP instance */
-  SLLDestroy(L7_PTIN_COMPONENT_ID, &timerLinkedList);
-
-  /* Buffer pool termination */
-  if (cbBufferPoolId != 0)
-  {
-    bufferPoolTerminate(cbBufferPoolId);
-    cbBufferPoolId = 0;
-  }
-
-  /* Delete task for grouptimer management */
-  if ( cbTaskId != L7_ERROR )
-  {
-    osapiTaskDelete(cbTaskId);
-    cbTaskId = L7_ERROR;
-  }
-
-  /* Queue that will process timer events */
-  if (cbEventQueue != L7_NULLPTR)
-  {
-    osapiMsgQueueDelete(cbEventQueue);
-    cbEventQueue = L7_NULLPTR;
-  }
-
-  osapiSemaDelete(timerSem);
-  timerSem = L7_NULLPTR;
-
-  return(L7_SUCCESS);
-}
-
-/*********************************************************************
-* @purpose   This function is used to send timer events
-*
-* @param     timerCtrlBlk    @b{(input)}   Timer Control Block
-* @param     ptrData         @b{(input)}   Ptr to passed data
-*
-* @returns   None
-*
-* @notes     None
-* @end
-*********************************************************************/
-void cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData)
-{
-  snoopPtinGrouptimerParams_t msg = {0};
-  L7_RC_t                     rc;
-
-  rc = osapiMessageSend(cbEventQueue, &msg, PTIN_IGMP_TIMER_MSG_SIZE, L7_NO_WAIT,L7_MSG_PRIORITY_NORM);
-  if (rc != L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Grouptimer timer tick send failed");
-    return;
-  }
-}
-
-/*************************************************************************
-* @purpose Task that makes the timer processing for the grouptimer
-*          management 
-*  
-* @param    none
-*
-* @notes    none
-* @end
-*************************************************************************/
-void cbEventqueueTask(void)
-{
-  L7_uint32                   status;
-  snoopPtinGrouptimerParams_t msg;
-
-  if (osapiTaskInitDone(L7_PTIN_IGMP_TASK_SYNC)!=L7_SUCCESS)
-  {
-    PT_LOG_FATAL(LOG_CTX_SSM, "Error syncing task");
-    PTIN_CRASH();
-  }
-
-  while (1)
-  {
-    status = (L7_uint32) osapiMessageReceive(cbEventQueue, (void*)&msg,
-                                             PTIN_IGMP_TIMER_MSG_SIZE, L7_WAIT_FOREVER);
-    if (status == L7_SUCCESS)
-    {
-        appTimerProcess(cbTimer);
-    }
-    else
-    {
-      PT_LOG_ERR(LOG_CTX_IGMP,"This is an invalid event");
-    }
-  }
-}
-
-/*************************************************************************
-* @purpose  Helper API to compare two grouptimer nodes and return the result
-*
-* @param     p  @b{(input)}  Pointer to Candidate 1 for comparison
-* @param     q  @b{(input)}  Pointer to Candidate 2 for comparison
-*
-* @returns   0   p = q
-* @returns  -1   p < q
-* @returns  +1   p > q
-*
-* @comments This is called by SLL library when nodes are compared
-*
-* @end
-*************************************************************************/
-L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key)
-{
-  L7_inet_addr_t pMcastGroupAddr, qMcastGroupAddr;
-  L7_uint32 pVlanId, pInterfaceIdx, qVlanId, qInterfaceIdx;
-
-
-  /* Validate argument */
-  if (p == L7_NULLPTR || ((snoopPTinL3Grouptimer_t *) p)->groupData == L7_NULLPTR || 
-      q == L7_NULLPTR || ((snoopPTinL3Grouptimer_t *) q)->groupData == L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
-    return 1;
-  }
-
-  pMcastGroupAddr = ((snoopPTinL3Grouptimer_t *) p)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
-  pVlanId         = ((snoopPTinL3Grouptimer_t *) p)->groupData->snoopPTinL3InfoDataKey.vlanId;
-  pInterfaceIdx   = ((snoopPTinL3Grouptimer_t *) p)->interfaceIdx;
-
-  qMcastGroupAddr = ((snoopPTinL3Grouptimer_t *) q)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
-  qVlanId         = ((snoopPTinL3Grouptimer_t *) q)->groupData->snoopPTinL3InfoDataKey.vlanId;
-  qInterfaceIdx   = ((snoopPTinL3Grouptimer_t *) q)->interfaceIdx;
-
-#if 1
-  if ( L7_INET_ADDR_COMPARE(&pMcastGroupAddr,&qMcastGroupAddr)==0 && 
-       pVlanId         == qVlanId         &&
-       pInterfaceIdx   == qInterfaceIdx )
-    return 0;
-#else
-  if ( pMcastGroupAddr.addr.ipv4.s_addr==qMcastGroupAddr.addr.ipv4.s_addr && 
-       pVlanId         == qVlanId         &&
-       pInterfaceIdx   == qInterfaceIdx )
-    return 0;
-#endif
-
-  return 1;
-}
-
-/*************************************************************************
-* @purpose  API to destroy the grouptimer data node
-*
-* @param    ll_member  @b{(input)}  Linked list node containing the
-*                                   timer to be destroyed
-*
-* @returns  L7_SUCCESS
-*
-* @comments This is called by SLL library when a node is being deleted
-*
-* @end
-*************************************************************************/
-L7_RC_t timerDataDestroy (L7_sll_member_t *ll_member)
-{
-  snoopPTinL3Grouptimer_t *pTimerData;
-
-  /* Validate argument */
-  if (ll_member==L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
-    return L7_FAILURE;
-  }
-
-  pTimerData = (snoopPTinL3Grouptimer_t *)ll_member;
-
-  /* Destroy timer */
-  if (pTimerData->timer != L7_NULL)
-  {
-    /* Delete the apptimer node */
-    if (appTimerDelete(cbTimer, pTimerData->timer)!=L7_SUCCESS)
-    {
-      PT_LOG_NOTICE(LOG_CTX_IGMP,"Cannot delete timer");
-    }
-    pTimerData->timer = (L7_APP_TMR_HNDL_t) NULL;
-
-    /* Delete the handle we had created */
-    handleListNodeDelete(handleList, &pTimerData->timerHandle);
-    pTimerData->timerHandle = 0;
-  }
-  return L7_SUCCESS;
-}
-
-/*************************************************************************
- * @purpose Callback method that is called when the grouptimer expires.
- *
- * @param   param  Timer Handle
- *
- *************************************************************************/
-void timerCallback(void *param)
-{
-  char                    debug_buf[46];
-  snoopPTinL3Interface_t  *interfacePtr;
-  L7_uint32               intIfNum;
-//L7_uint32               vlanId;
-//L7_inet_addr_t          mcastGroupAddr;
-
-  L7_uint32               timerHandle;
-  snoopPTinL3Grouptimer_t *pTimerData;
-  snoopPTinL3Source_t     *sourcePtr;
-  snoopPTinL3InfoData_t*  groupData;
-  
-#if 0
-  L7_uint8              recordType=L7_IGMP_BLOCK_OLD_SOURCES;
-  snoopPTinProxyGroup_t* groupPtr=L7_NULLPTR;       
-  snoopPTinProxyInterface_t* proxyInterfacePtr=L7_NULLPTR;
-  L7_uint32 noOfRecords=0;
-#endif
-
-
-
-  timerHandle = (L7_uint32) param;
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Get timer handler */
-  pTimerData = (snoopPTinL3Grouptimer_t*) handleListNodeRetrieve(timerHandle);
-  if (pTimerData == L7_NULLPTR)
-  {
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Failed to retrieve handle");
-    osapiSemaGive(timerSem);
-    return;
-  }
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Grouptimer expired (group:%s vlan:%u ifId:%u)", 
-            inetAddrPrint(&(pTimerData->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), pTimerData->groupData->snoopPTinL3InfoDataKey.vlanId, pTimerData->interfaceIdx);
-
-  /* Check if our handle is OK*/
-  if (timerHandle != pTimerData->timerHandle)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"timerHandle and pTimerData->timerHandle do not match!");
-    osapiSemaGive(timerSem);
-    return;
-  }
-
-  //Save grouptimer's internal data
-  groupData    = pTimerData->groupData;
-  intIfNum = pTimerData->interfaceIdx;
-//mcastGroupAddr=groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
-//vlanId=groupData->snoopPTinL3InfoDataKey.vlanId;
-
-/* Remove node for SLL list */
-  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimerData) != L7_SUCCESS)
-  {
-    osapiSemaGive(timerSem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node");
-    return;
-  }
-  osapiSemaGive(timerSem);
-
-  /* Grouptimer triggers only affect groups in filter-mode EXCLUDE */
-  interfacePtr = &groupData->interfaces[intIfNum];
-  sourcePtr    = L7_NULLPTR;
-  if (interfacePtr->filtermode == PTIN_SNOOP_FILTERMODE_EXCLUDE)
-  {
-    L7_uint32 i;
-
-    /* Remove every source whose timer has expired */
-    for (i = 0; interfacePtr->numberOfSources>0 && i < PTIN_SYSTEM_IGMP_MAXSOURCES_PER_GROUP ; ++i)
-    {
-      sourcePtr = &interfacePtr->sources[i];
-      if ((sourcePtr->status == PTIN_SNOOP_SOURCESTATE_ACTIVE) && (sourcePtr->sourceTimer.isRunning == L7_FALSE) && sourcePtr->isStatic==L7_FALSE)
-      {
-#if 0
-        if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM)
-        {
-          if (noOfRecords==0)
-          { 
-            noOfRecords=1;
-            if ( (proxyInterfacePtr=snoopPTinProxyInterfaceAdd(groupData->snoopPTinL3InfoDataKey.vlanId)) ==L7_NULLPTR)                     
-            {             
-              PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinProxyInterfaceAdd()");
-              return ;
-            }            
-            
-            if((groupPtr=snoopPTinGroupRecordAdd(proxyInterfacePtr,recordType,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr ))==L7_NULLPTR)
-            {
-              PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordGroupAdd()");
-              return ;
-            }
-          }
-          if (L7_SUCCESS != snoopPTinGroupRecordSourcedAdd(groupPtr,&sourcePtr->sourceAddr))
-          {
-            PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordSourcedAdd()");       
-            return ;
-          }        
-        }        
-#endif
-        PT_LOG_DEBUG(LOG_CTX_IGMP,"Removing sourceIdx %u", i);
-        snoopPTinSourceRemove(interfacePtr, sourcePtr);       
-      }
-    }
-
-    /* If no sources remain, remove group. Otherwise, switch to filter-mode INCLUDE */
-    if (interfacePtr->numberOfSources == 0)
-    {
-      if (interfacePtr->isStatic==L7_FALSE)
-      {        
-        snoopPTinInterfaceRemove(interfacePtr,groupData->snoopPTinL3InfoDataKey.vlanId,&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr),intIfNum);
-
-        if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM)
-        {
-#if 0
-          if (L7_SUCCESS != snoopPTinGroupRecordRemoveAllSources(groupPtr))
-          {
-           PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordRemoveAllSources()");       
-           return;
-          }
-          groupPtr->key.recordType=L7_IGMP_MODE_IS_INCLUDE;                          
-          PT_LOG_TRACE(LOG_CTX_IGMP, "Schedule Membership Report Message");
-          if(snoopPTinReportSchedule(groupData->snoopPTinL3InfoDataKey.vlanId,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr,SNOOP_PTIN_MEMBERSHIP_REPORT,0,0,1,groupPtr)!=L7_SUCCESS)
-          {
-            PT_LOG_ERR(LOG_CTX_IGMP,"Failed snoopPTinReportSchedule()");
-            return;
-          } 
-          noOfRecords=0;
-#endif
-          PT_LOG_DEBUG(LOG_CTX_IGMP,"Removed root interface");          
-          
-        }
-        else
-        {
-          PT_LOG_DEBUG(LOG_CTX_IGMP,"Removed leaf interface");          
-        }
-      }
-    }
-    else
-    {
-      interfacePtr->filtermode = PTIN_SNOOP_FILTERMODE_INCLUDE;           
-    }       
-  }
-
-#if 0
-  if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM && noOfRecords>0)
-  {
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Schedule Membership Report Message");
-    if(snoopPTinReportSchedule(groupData->snoopPTinL3InfoDataKey.vlanId,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr,SNOOP_PTIN_MEMBERSHIP_REPORT,0,0,noOfRecords,groupPtr)!=L7_SUCCESS)
-    {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Failed snoopPTinReportSchedule()");
-    return;
-    } 
-  }
-#endif
-}
-
-/*************************************************************************
- * @purpose Start a grouptimer
- * 
- * @param   pTimer          Pointer to timer
- * @param   timeout         Timer's timeout
- * @param   groupData       Pointer to multicast group data
- * @param   interfaceIdx    Interface index
- *
- * @returns L7_SUCCESS
- * @returns L7_FAILURE
- *
- *************************************************************************/
-L7_RC_t snoop_ptin_grouptimer_start(snoopPTinL3Grouptimer_t* pTimer, L7_uint32 timeout, snoopPTinL3InfoData_t* groupData, L7_uint32 interfaceIdx)
-{
-  L7_BOOL                 restart_timer = L7_FALSE;
-  snoopPTinL3Grouptimer_t pTimerData;
-  char                    debug_buf[46];
-
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR || groupData == L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
-    return L7_FAILURE;
-  }
-
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Check if this timer already exists */
-  memset(&pTimerData, 0x00, sizeof(pTimerData));
-  pTimerData.groupData     = groupData;
-  pTimerData.interfaceIdx  = interfaceIdx;
-  if (SLLFind(&timerLinkedList, (void *)&pTimerData) != L7_NULL)
-  {
-    restart_timer = L7_TRUE;
-    if (appTimerDelete(cbTimer, (void *) pTimer->timer) != L7_SUCCESS)
-    {
-      osapiSemaGive(timerSem);
-      PT_LOG_ERR(LOG_CTX_IGMP,"Failed restarting timer");
-      return L7_FAILURE;
-    }
-    pTimer->timer = L7_NULLPTR;
-
-    /* Remove timer handle */
-    handleListNodeDelete(handleList, &pTimer->timerHandle);
-    pTimer->timerHandle = 0;
-  }
-  else
-  {
-    pTimer->groupData    = groupData;
-    pTimer->interfaceIdx = interfaceIdx;
-  }
-
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Starting grouptimer (group:%s timeout:%u vlan:%u ifIdx:%u)",
-            inetAddrPrint(&(pTimer->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf),timeout,
-            pTimer->groupData->snoopPTinL3InfoDataKey.vlanId, interfaceIdx);
-
-  /* New timer handle */
-  if ((pTimer->timerHandle = handleListNodeStore(handleList, pTimer)) == 0)
-  {
-    osapiSemaGive(timerSem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
-    return L7_FAILURE;
-  }
-
-  /* Add a new timer */
-  pTimer->timer = appTimerAdd(cbTimer, timerCallback,
-                              (void *) pTimer->timerHandle, timeout,
-                              "PTIN_TIMER");
-  if (pTimer->timer == NULL)
-  {
-    handleListNodeDelete(handleList, &pTimer->timerHandle);
-    pTimer->timerHandle = 0;
-    osapiSemaGive(timerSem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Could not start the grouptimer.");
-    return L7_FAILURE;
-  }
-
-  /* Add timer to SLL */
-  if (!restart_timer && (SLLAdd(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS))
-  {
-    if (appTimerDelete(cbTimer, pTimer->timer) != L7_SUCCESS)
-    {
-      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
-    }
-    pTimer->timer = L7_NULLPTR;
-    handleListNodeDelete(handleList, &pTimer->timerHandle);
-    memset(pTimer, 0x00, sizeof(pTimer));
-    osapiSemaGive(timerSem);
-    PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
-    return L7_FAILURE;
-  }
-
-  osapiSemaGive(timerSem);
-  return L7_SUCCESS;
-}
-
-/*************************************************************************
- * @purpose Stop a grouptimer
- * 
- * @param   pTimer  Pointer to timer
- *
- * @returns L7_SUCCESS
- * @returns L7_FAILURE
- *
- *************************************************************************/
-L7_RC_t snoop_ptin_grouptimer_stop(snoopPTinL3Grouptimer_t *pTimer)
-{
-  char debug_buf[46];
-
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR || pTimer->groupData == L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
-    return L7_FAILURE;
-  }
-
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Stopping grouptimer (group:%s vlan:%u ifIdx:%u)",
-            inetAddrPrint(&(pTimer->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), pTimer->groupData->snoopPTinL3InfoDataKey.vlanId, pTimer->interfaceIdx);
-
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Remove node for SLL list */
-  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS)
-  {
-    osapiSemaGive(timerSem);
-    PT_LOG_NOTICE(LOG_CTX_IGMP,"Failed to delete timer node");
-    return L7_FAILURE;
-  }
-
-  osapiSemaGive(timerSem);
-
-  return L7_SUCCESS;
-}
-
-/*************************************************************************
- * @purpose Get the timeleft for a given sourcetimer
- * 
- * @param   pTimer  Pointer to timer
- *
- * @returns Timer's time left
- *
- *************************************************************************/
-L7_uint32 snoop_ptin_grouptimer_timeleft(snoopPTinL3Grouptimer_t *pTimer)
-{
-  L7_uint32 time_left = 0;
-
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR || pTimer->timer == L7_NULLPTR)
-  { 
-    return 0;
-  }
-
-  appTimerTimeLeftGet(cbTimer, pTimer->timer, &time_left);
-
-  return time_left;
-}
-
-
-/*************************************************************************
- * @purpose Verify if the timer is running or not
- * 
- * @param   pTimer  Pointer to timer
- *
- * @returns Timer's time left
- *
- *************************************************************************/
-L7_BOOL snoop_ptin_grouptimer_isRunning(snoopPTinL3Grouptimer_t *pTimer)
-{
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR || pTimer->timer == L7_NULLPTR)
-  { 
-    return L7_FALSE;
-  }
-  else
-  {
-    return L7_TRUE;
-  }
-}
+/*
+ * snooping_ptin_grouptimer.c
+ *
+ *  Created on: 22 de Abr de 2013
+ *      Author: Daniel Figueira
+ */
+
+#include "snooping_ptin_grouptimer.h"
+#include "snooping_ptin_util.h"
+#include "snooping_db.h"
+#include "snooping_ptin_db.h"
+
+#include "ptin_igmp.h"
+
+#include <unistd.h>
+
+#define TIMER_COUNT 1
+
+/* Message placed in CB queue */
+typedef struct snoopPtinGrouptimerParams_s
+{
+  L7_uint8 eventIdx;
+} snoopPtinGrouptimerParams_t;
+#define PTIN_IGMP_TIMER_MSG_SIZE  sizeof(snoopPtinGrouptimerParams_t)
+
+/* Static variables */
+static void                   *handleListMemHndl = L7_NULLPTR;
+static void                   *cbEventQueue = L7_NULLPTR;
+static void                   *timerSem = L7_NULLPTR;
+static L7_sll_t               timerLinkedList;
+static L7_uint32              cbTaskId = L7_ERROR;
+static L7_uint32              cbBufferPoolId = 0;
+static handle_list_t          *handleList;
+static L7_APP_TMR_CTRL_BLK_t  cbTimer;
+
+/* Static methods */
+static void     cbEventqueueTask(void);
+static void     cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData);
+static L7_RC_t  timerDataDestroy(L7_sll_member_t *ll_member);
+static L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key);
+static void     timerCallback(void *param);
+
+
+/*********************************************************************
+* @purpose  Start Snooping task
+*
+* @param    none
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    none
+*
+* @end
+*********************************************************************/
+L7_RC_t snoop_ptin_grouptimer_init(void)
+{
+   /* Create queue semaphore */
+   timerSem = osapiSemaBCreate(OSAPI_SEM_Q_FIFO, OSAPI_SEM_FULL);
+   if (timerSem == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to create timers_sem semaphore!");
+     return L7_FAILURE;
+   }
+
+   /* Queue that will process timer events */
+   cbEventQueue = (void *) osapiMsgQueueCreate("cb_event_queue_grouptimer", TIMER_COUNT, PTIN_IGMP_TIMER_MSG_SIZE);
+   if (cbEventQueue == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"cb_event_queue creation error.");
+     return L7_FAILURE;
+   }
+
+   /* Create task for grouptimer management */
+   cbTaskId = osapiTaskCreate("ptin_igmp_grouptimer_task", cbEventqueueTask, 0, 0,
+                                         L7_DEFAULT_STACK_SIZE,
+                                         L7_TASK_PRIORITY_LEVEL(L7_DEFAULT_TASK_PRIORITY),
+                                         L7_DEFAULT_TASK_SLICE);
+   if (cbTaskId == L7_ERROR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR, "Could not create task ptin_igmp_grouptimer_task");
+     return L7_FAILURE;
+   }
+   if (osapiWaitForTaskInit (L7_PTIN_IGMP_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to initialize ptin_igmp_grouptimer_task");
+     return(L7_FAILURE);
+   }
+
+   /* Create CB buffer pool */
+   cbBufferPoolId = 0;
+   if(bufferPoolInit(TIMER_COUNT,
+                     sizeof(timerNode_t) /*L7_APP_TMR_NODE_SIZE*/,
+                     "PTin_IGMP_CB_GroupTimer_Buffer",
+                     &cbBufferPoolId) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to allocate memory for IGMP Control Block timer buffers");
+     return L7_FAILURE;
+   }
+
+   /* Create SLL list for each IGMP instance */
+   if (SLLCreate(L7_PTIN_COMPONENT_ID, L7_SLL_NO_ORDER,
+                sizeof(L7_uint32)*2, timerDataCmp, timerDataDestroy,
+                &timerLinkedList) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Failed to create timer linked list");
+     return L7_FAILURE;
+   }
+
+   /* Allocate memory for the Handle List */
+   handleListMemHndl = (handle_member_t*) osapiMalloc(L7_PTIN_COMPONENT_ID, TIMER_COUNT*sizeof(handle_member_t));
+   if (handleListMemHndl == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Error allocating Handle List Buffers");
+     return L7_FAILURE;
+   }
+
+   /* Create timers handle list for this IGMP instance  */
+   if(handleListInit(L7_PTIN_COMPONENT_ID, TIMER_COUNT, &handleList, handleListMemHndl) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to create timer handle list");
+     return L7_FAILURE;
+   }
+
+   /* Initialize timer control blocks */
+   cbTimer = appTimerInit(L7_PTIN_COMPONENT_ID, (void *) cbtimerCallback,
+                          L7_NULLPTR, L7_APP_TMR_1SEC,
+                          cbBufferPoolId);
+   if (cbTimer  == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"snoopEntry App Timer Initialization Failed.");
+     return L7_FAILURE;
+   }
+
+   PT_LOG_TRACE(LOG_CTX_CNFGR,"Initializations for IGMPv3 group timers finished");
+
+  return(L7_SUCCESS);
+}
+
+/*********************************************************************
+* @purpose  Stop Snooping task
+*
+* @param    none
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    none
+*
+* @end
+*********************************************************************/
+L7_RC_t snoop_ptin_grouptimer_deinit(void)
+{
+  /* Deinitialize timer control blocks */
+  if (cbTimer != (L7_APP_TMR_CTRL_BLK_t) NULL)
+  {
+    appTimerDeInit(cbTimer);
+    cbTimer = (L7_APP_TMR_CTRL_BLK_t) NULL;
+  }
+
+  /* Remove timers handle list for this IGMP instance  */
+  handleListDeinit(L7_PTIN_COMPONENT_ID, handleList);
+
+  /* Free memory for the Handle List */
+  if (handleListMemHndl != L7_NULLPTR)
+  {
+    osapiFree(L7_PTIN_COMPONENT_ID, handleListMemHndl);
+    handleListMemHndl = L7_NULLPTR;
+  }
+
+  /* Destroy SLL list for each IGMP instance */
+  SLLDestroy(L7_PTIN_COMPONENT_ID, &timerLinkedList);
+
+  /* Buffer pool termination */
+  if (cbBufferPoolId != 0)
+  {
+    bufferPoolTerminate(cbBufferPoolId);
+    cbBufferPoolId = 0;
+  }
+
+  /* Delete task for grouptimer management */
+  if ( cbTaskId != L7_ERROR )
+  {
+    osapiTaskDelete(cbTaskId);
+    cbTaskId = L7_ERROR;
+  }
+
+  /* Queue that will process timer events */
+  if (cbEventQueue != L7_NULLPTR)
+  {
+    osapiMsgQueueDelete(cbEventQueue);
+    cbEventQueue = L7_NULLPTR;
+  }
+
+  osapiSemaDelete(timerSem);
+  timerSem = L7_NULLPTR;
+
+  return(L7_SUCCESS);
+}
+
+/*********************************************************************
+* @purpose   This function is used to send timer events
+*
+* @param     timerCtrlBlk    @b{(input)}   Timer Control Block
+* @param     ptrData         @b{(input)}   Ptr to passed data
+*
+* @returns   None
+*
+* @notes     None
+* @end
+*********************************************************************/
+void cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData)
+{
+  snoopPtinGrouptimerParams_t msg = {0};
+  L7_RC_t                     rc;
+
+  rc = osapiMessageSend(cbEventQueue, &msg, PTIN_IGMP_TIMER_MSG_SIZE, L7_NO_WAIT,L7_MSG_PRIORITY_NORM);
+  if (rc != L7_SUCCESS)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Grouptimer timer tick send failed");
+    return;
+  }
+}
+
+/*************************************************************************
+* @purpose Task that makes the timer processing for the grouptimer
+*          management 
+*  
+* @param    none
+*
+* @notes    none
+* @end
+*************************************************************************/
+void cbEventqueueTask(void)
+{
+  L7_uint32                   status;
+  snoopPtinGrouptimerParams_t msg;
+
+  if (osapiTaskInitDone(L7_PTIN_IGMP_TASK_SYNC)!=L7_SUCCESS)
+  {
+    PT_LOG_FATAL(LOG_CTX_SSM, "Error syncing task");
+    PTIN_CRASH();
+  }
+
+  while (1)
+  {
+    status = (L7_uint32) osapiMessageReceive(cbEventQueue, (void*)&msg,
+                                             PTIN_IGMP_TIMER_MSG_SIZE, L7_WAIT_FOREVER);
+    if (status == L7_SUCCESS)
+    {
+        appTimerProcess(cbTimer);
+    }
+    else
+    {
+      PT_LOG_ERR(LOG_CTX_IGMP,"This is an invalid event");
+    }
+  }
+}
+
+/*************************************************************************
+* @purpose  Helper API to compare two grouptimer nodes and return the result
+*
+* @param     p  @b{(input)}  Pointer to Candidate 1 for comparison
+* @param     q  @b{(input)}  Pointer to Candidate 2 for comparison
+*
+* @returns   0   p = q
+* @returns  -1   p < q
+* @returns  +1   p > q
+*
+* @comments This is called by SLL library when nodes are compared
+*
+* @end
+*************************************************************************/
+L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key)
+{
+  L7_inet_addr_t pMcastGroupAddr, qMcastGroupAddr;
+  L7_uint32 pVlanId, pInterfaceIdx, qVlanId, qInterfaceIdx;
+
+
+  /* Validate argument */
+  if (p == L7_NULLPTR || ((snoopPTinL3Grouptimer_t *) p)->groupData == L7_NULLPTR || 
+      q == L7_NULLPTR || ((snoopPTinL3Grouptimer_t *) q)->groupData == L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
+    return 1;
+  }
+
+  pMcastGroupAddr = ((snoopPTinL3Grouptimer_t *) p)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
+  pVlanId         = ((snoopPTinL3Grouptimer_t *) p)->groupData->snoopPTinL3InfoDataKey.vlanId;
+  pInterfaceIdx   = ((snoopPTinL3Grouptimer_t *) p)->interfaceIdx;
+
+  qMcastGroupAddr = ((snoopPTinL3Grouptimer_t *) q)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
+  qVlanId         = ((snoopPTinL3Grouptimer_t *) q)->groupData->snoopPTinL3InfoDataKey.vlanId;
+  qInterfaceIdx   = ((snoopPTinL3Grouptimer_t *) q)->interfaceIdx;
+
+#if 1
+  if ( L7_INET_ADDR_COMPARE(&pMcastGroupAddr,&qMcastGroupAddr)==0 && 
+       pVlanId         == qVlanId         &&
+       pInterfaceIdx   == qInterfaceIdx )
+    return 0;
+#else
+  if ( pMcastGroupAddr.addr.ipv4.s_addr==qMcastGroupAddr.addr.ipv4.s_addr && 
+       pVlanId         == qVlanId         &&
+       pInterfaceIdx   == qInterfaceIdx )
+    return 0;
+#endif
+
+  return 1;
+}
+
+/*************************************************************************
+* @purpose  API to destroy the grouptimer data node
+*
+* @param    ll_member  @b{(input)}  Linked list node containing the
+*                                   timer to be destroyed
+*
+* @returns  L7_SUCCESS
+*
+* @comments This is called by SLL library when a node is being deleted
+*
+* @end
+*************************************************************************/
+L7_RC_t timerDataDestroy (L7_sll_member_t *ll_member)
+{
+  snoopPTinL3Grouptimer_t *pTimerData;
+
+  /* Validate argument */
+  if (ll_member==L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
+    return L7_FAILURE;
+  }
+
+  pTimerData = (snoopPTinL3Grouptimer_t *)ll_member;
+
+  /* Destroy timer */
+  if (pTimerData->timer != L7_NULL)
+  {
+    /* Delete the apptimer node */
+    if (appTimerDelete(cbTimer, pTimerData->timer)!=L7_SUCCESS)
+    {
+      PT_LOG_NOTICE(LOG_CTX_IGMP,"Cannot delete timer");
+    }
+    pTimerData->timer = (L7_APP_TMR_HNDL_t) NULL;
+
+    /* Delete the handle we had created */
+    handleListNodeDelete(handleList, &pTimerData->timerHandle);
+    pTimerData->timerHandle = 0;
+  }
+  return L7_SUCCESS;
+}
+
+/*************************************************************************
+ * @purpose Callback method that is called when the grouptimer expires.
+ *
+ * @param   param  Timer Handle
+ *
+ *************************************************************************/
+void timerCallback(void *param)
+{
+  char                    debug_buf[46];
+  snoopPTinL3Interface_t  *interfacePtr;
+  L7_uint32               intIfNum;
+//L7_uint32               vlanId;
+//L7_inet_addr_t          mcastGroupAddr;
+
+  L7_uint32               timerHandle;
+  snoopPTinL3Grouptimer_t *pTimerData;
+  snoopPTinL3Source_t     *sourcePtr;
+  snoopPTinL3InfoData_t*  groupData;
+  
+#if 0
+  L7_uint8              recordType=L7_IGMP_BLOCK_OLD_SOURCES;
+  snoopPTinProxyGroup_t* groupPtr=L7_NULLPTR;       
+  snoopPTinProxyInterface_t* proxyInterfacePtr=L7_NULLPTR;
+  L7_uint32 noOfRecords=0;
+#endif
+
+
+
+  timerHandle = (L7_uint32) param;
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Get timer handler */
+  pTimerData = (snoopPTinL3Grouptimer_t*) handleListNodeRetrieve(timerHandle);
+  if (pTimerData == L7_NULLPTR)
+  {
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Failed to retrieve handle");
+    osapiSemaGive(timerSem);
+    return;
+  }
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Grouptimer expired (group:%s vlan:%u ifId:%u)", 
+            inetAddrPrint(&(pTimerData->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), pTimerData->groupData->snoopPTinL3InfoDataKey.vlanId, pTimerData->interfaceIdx);
+
+  /* Check if our handle is OK*/
+  if (timerHandle != pTimerData->timerHandle)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"timerHandle and pTimerData->timerHandle do not match!");
+    osapiSemaGive(timerSem);
+    return;
+  }
+
+  //Save grouptimer's internal data
+  groupData    = pTimerData->groupData;
+  intIfNum = pTimerData->interfaceIdx;
+//mcastGroupAddr=groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
+//vlanId=groupData->snoopPTinL3InfoDataKey.vlanId;
+
+/* Remove node for SLL list */
+  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimerData) != L7_SUCCESS)
+  {
+    osapiSemaGive(timerSem);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node");
+    return;
+  }
+  osapiSemaGive(timerSem);
+
+  /* Grouptimer triggers only affect groups in filter-mode EXCLUDE */
+  interfacePtr = &groupData->interfaces[intIfNum];
+  sourcePtr    = L7_NULLPTR;
+  if (interfacePtr->filtermode == PTIN_SNOOP_FILTERMODE_EXCLUDE)
+  {
+    L7_uint32 i;
+
+    /* Remove every source whose timer has expired */
+    for (i = 0; interfacePtr->numberOfSources>0 && i < PTIN_SYSTEM_IGMP_MAXSOURCES_PER_GROUP ; ++i)
+    {
+      sourcePtr = &interfacePtr->sources[i];
+      if ((sourcePtr->status == PTIN_SNOOP_SOURCESTATE_ACTIVE) && (sourcePtr->sourceTimer.isRunning == L7_FALSE) && sourcePtr->isStatic==L7_FALSE)
+      {
+#if 0
+        if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM)
+        {
+          if (noOfRecords==0)
+          { 
+            noOfRecords=1;
+            if ( (proxyInterfacePtr=snoopPTinProxyInterfaceAdd(groupData->snoopPTinL3InfoDataKey.vlanId)) ==L7_NULLPTR)                     
+            {             
+              PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinProxyInterfaceAdd()");
+              return ;
+            }            
+            
+            if((groupPtr=snoopPTinGroupRecordAdd(proxyInterfacePtr,recordType,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr ))==L7_NULLPTR)
+            {
+              PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordGroupAdd()");
+              return ;
+            }
+          }
+          if (L7_SUCCESS != snoopPTinGroupRecordSourcedAdd(groupPtr,&sourcePtr->sourceAddr))
+          {
+            PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordSourcedAdd()");       
+            return ;
+          }        
+        }        
+#endif
+        PT_LOG_DEBUG(LOG_CTX_IGMP,"Removing sourceIdx %u", i);
+        snoopPTinSourceRemove(interfacePtr, sourcePtr);       
+      }
+    }
+
+    /* If no sources remain, remove group. Otherwise, switch to filter-mode INCLUDE */
+    if (interfacePtr->numberOfSources == 0)
+    {
+      if (interfacePtr->isStatic==L7_FALSE)
+      {        
+        snoopPTinInterfaceRemove(interfacePtr,groupData->snoopPTinL3InfoDataKey.vlanId,&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr),intIfNum);
+
+        if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM)
+        {
+#if 0
+          if (L7_SUCCESS != snoopPTinGroupRecordRemoveAllSources(groupPtr))
+          {
+           PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordRemoveAllSources()");       
+           return;
+          }
+          groupPtr->key.recordType=L7_IGMP_MODE_IS_INCLUDE;                          
+          PT_LOG_TRACE(LOG_CTX_IGMP, "Schedule Membership Report Message");
+          if(snoopPTinReportSchedule(groupData->snoopPTinL3InfoDataKey.vlanId,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr,SNOOP_PTIN_MEMBERSHIP_REPORT,0,0,1,groupPtr)!=L7_SUCCESS)
+          {
+            PT_LOG_ERR(LOG_CTX_IGMP,"Failed snoopPTinReportSchedule()");
+            return;
+          } 
+          noOfRecords=0;
+#endif
+          PT_LOG_DEBUG(LOG_CTX_IGMP,"Removed root interface");          
+          
+        }
+        else
+        {
+          PT_LOG_DEBUG(LOG_CTX_IGMP,"Removed leaf interface");          
+        }
+      }
+    }
+    else
+    {
+      interfacePtr->filtermode = PTIN_SNOOP_FILTERMODE_INCLUDE;           
+    }       
+  }
+
+#if 0
+  if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM && noOfRecords>0)
+  {
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Schedule Membership Report Message");
+    if(snoopPTinReportSchedule(groupData->snoopPTinL3InfoDataKey.vlanId,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr,SNOOP_PTIN_MEMBERSHIP_REPORT,0,0,noOfRecords,groupPtr)!=L7_SUCCESS)
+    {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Failed snoopPTinReportSchedule()");
+    return;
+    } 
+  }
+#endif
+}
+
+/*************************************************************************
+ * @purpose Start a grouptimer
+ * 
+ * @param   pTimer          Pointer to timer
+ * @param   timeout         Timer's timeout
+ * @param   groupData       Pointer to multicast group data
+ * @param   interfaceIdx    Interface index
+ *
+ * @returns L7_SUCCESS
+ * @returns L7_FAILURE
+ *
+ *************************************************************************/
+L7_RC_t snoop_ptin_grouptimer_start(snoopPTinL3Grouptimer_t* pTimer, L7_uint32 timeout, snoopPTinL3InfoData_t* groupData, L7_uint32 interfaceIdx)
+{
+  L7_BOOL                 restart_timer = L7_FALSE;
+  snoopPTinL3Grouptimer_t pTimerData;
+  char                    debug_buf[46];
+
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR || groupData == L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
+    return L7_FAILURE;
+  }
+
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Check if this timer already exists */
+  memset(&pTimerData, 0x00, sizeof(pTimerData));
+  pTimerData.groupData     = groupData;
+  pTimerData.interfaceIdx  = interfaceIdx;
+  if (SLLFind(&timerLinkedList, (void *)&pTimerData) != L7_NULL)
+  {
+    restart_timer = L7_TRUE;
+    if (appTimerDelete(cbTimer, (void *) pTimer->timer) != L7_SUCCESS)
+    {
+      osapiSemaGive(timerSem);
+      PT_LOG_ERR(LOG_CTX_IGMP,"Failed restarting timer");
+      return L7_FAILURE;
+    }
+    pTimer->timer = L7_NULLPTR;
+
+    /* Remove timer handle */
+    handleListNodeDelete(handleList, &pTimer->timerHandle);
+    pTimer->timerHandle = 0;
+  }
+  else
+  {
+    pTimer->groupData    = groupData;
+    pTimer->interfaceIdx = interfaceIdx;
+  }
+
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Starting grouptimer (group:%s timeout:%u vlan:%u ifIdx:%u)",
+            inetAddrPrint(&(pTimer->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf),timeout,
+            pTimer->groupData->snoopPTinL3InfoDataKey.vlanId, interfaceIdx);
+
+  /* New timer handle */
+  if ((pTimer->timerHandle = handleListNodeStore(handleList, pTimer)) == 0)
+  {
+    osapiSemaGive(timerSem);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
+    return L7_FAILURE;
+  }
+
+  /* Add a new timer */
+  pTimer->timer = appTimerAdd(cbTimer, timerCallback,
+                              (void *) pTimer->timerHandle, timeout,
+                              "PTIN_TIMER");
+  if (pTimer->timer == NULL)
+  {
+    handleListNodeDelete(handleList, &pTimer->timerHandle);
+    pTimer->timerHandle = 0;
+    osapiSemaGive(timerSem);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Could not start the grouptimer.");
+    return L7_FAILURE;
+  }
+
+  /* Add timer to SLL */
+  if (!restart_timer && (SLLAdd(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS))
+  {
+    if (appTimerDelete(cbTimer, pTimer->timer) != L7_SUCCESS)
+    {
+      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
+    }
+    pTimer->timer = L7_NULLPTR;
+    handleListNodeDelete(handleList, &pTimer->timerHandle);
+    memset(pTimer, 0x00, sizeof(pTimer));
+    osapiSemaGive(timerSem);
+    PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
+    return L7_FAILURE;
+  }
+
+  osapiSemaGive(timerSem);
+  return L7_SUCCESS;
+}
+
+/*************************************************************************
+ * @purpose Stop a grouptimer
+ * 
+ * @param   pTimer  Pointer to timer
+ *
+ * @returns L7_SUCCESS
+ * @returns L7_FAILURE
+ *
+ *************************************************************************/
+L7_RC_t snoop_ptin_grouptimer_stop(snoopPTinL3Grouptimer_t *pTimer)
+{
+  char debug_buf[46];
+
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR || pTimer->groupData == L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
+    return L7_FAILURE;
+  }
+
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Stopping grouptimer (group:%s vlan:%u ifIdx:%u)",
+            inetAddrPrint(&(pTimer->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), pTimer->groupData->snoopPTinL3InfoDataKey.vlanId, pTimer->interfaceIdx);
+
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Remove node for SLL list */
+  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS)
+  {
+    osapiSemaGive(timerSem);
+    PT_LOG_NOTICE(LOG_CTX_IGMP,"Failed to delete timer node");
+    return L7_FAILURE;
+  }
+
+  osapiSemaGive(timerSem);
+
+  return L7_SUCCESS;
+}
+
+/*************************************************************************
+ * @purpose Get the timeleft for a given sourcetimer
+ * 
+ * @param   pTimer  Pointer to timer
+ *
+ * @returns Timer's time left
+ *
+ *************************************************************************/
+L7_uint32 snoop_ptin_grouptimer_timeleft(snoopPTinL3Grouptimer_t *pTimer)
+{
+  L7_uint32 time_left = 0;
+
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR || pTimer->timer == L7_NULLPTR)
+  { 
+    return 0;
+  }
+
+  appTimerTimeLeftGet(cbTimer, pTimer->timer, &time_left);
+
+  return time_left;
+}
+
+
+/*************************************************************************
+ * @purpose Verify if the timer is running or not
+ * 
+ * @param   pTimer  Pointer to timer
+ *
+ * @returns Timer's time left
+ *
+ *************************************************************************/
+L7_BOOL snoop_ptin_grouptimer_isRunning(snoopPTinL3Grouptimer_t *pTimer)
+{
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR || pTimer->timer == L7_NULLPTR)
+  { 
+    return L7_FALSE;
+  }
+  else
+  {
+    return L7_TRUE;
+  }
+}
Index: src/application/switching/snooping/core/snooping_ptin_sourcetimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_sourcetimer.c	(revision 7370)
+++ src/application/switching/snooping/core/snooping_ptin_sourcetimer.c	(revision 7371)
@@ -1,702 +1,702 @@
-/*
- * ptin_igmp_sourcetimer.c
- *
- *  Created on: 22 de Abr de 2013
- *      Author: Daniel Figueira
- */
-
-#include "snooping_ptin_sourcetimer.h"
-#include "snooping_ptin_util.h"
-#include "snooping_db.h"
-#include "snooping_ptin_db.h"
-
-#include "ptin_igmp.h"
-
-#include <unistd.h>
-
-#define TIMER_COUNT 1
-
-/* Message placed in CB queue */
-typedef struct snoopPtinSourcetimerParams_s
-{
-  L7_uint8 eventIdx;
-} snoopPtinSourcetimerParams_t;
-#define PTIN_IGMP_TIMER_MSG_SIZE  sizeof(snoopPtinSourcetimerParams_t)
-
-/* Static variables */
-static void                   *handleListMemHndl = L7_NULLPTR;
-static void                   *cbEventQueue = L7_NULLPTR;
-static void                   *timerSem = L7_NULLPTR;
-static L7_sll_t               timerLinkedList;
-static L7_uint32              cbTaskId = L7_ERROR;
-static L7_uint32              cbBufferPoolId = 0;
-static handle_list_t          *handleList;
-static L7_APP_TMR_CTRL_BLK_t  cbTimer;
-
-/* Static methods */
-static void     cbEventqueueTask(void);
-static void     cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData);
-static L7_RC_t  timerDataDestroy(L7_sll_member_t *ll_member);
-static L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key);
-static void     timerCallback(void *param);
-
-
-/*********************************************************************
-* @purpose  Start Snooping task
-*
-* @param    none
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    none
-*
-* @end
-*********************************************************************/
-L7_RC_t snoop_ptin_sourcetimer_init(void)
-{
-  /* Create queue semaphore */
-  timerSem = osapiSemaBCreate(OSAPI_SEM_Q_FIFO, OSAPI_SEM_FULL);
-  if (timerSem == L7_NULLPTR)
-  {
-    PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to create timers_sem semaphore!");
-    return L7_FAILURE;
-  }
-
-  /* Queue that will process timer events */
-  cbEventQueue = (void *) osapiMsgQueueCreate("cb_event_queue_sourcetimer", TIMER_COUNT, PTIN_IGMP_TIMER_MSG_SIZE);
-  if (cbEventQueue == L7_NULLPTR)
-  {
-    PT_LOG_FATAL(LOG_CTX_CNFGR,"cb_event_queue creation error.");
-    return L7_FAILURE;
-  }
-
-  /* Create task for sourcetimer management */
-  cbTaskId = osapiTaskCreate("ptin_igmp_sourcetimer_task", cbEventqueueTask, 0, 0,
-                             L7_DEFAULT_STACK_SIZE,
-                             L7_TASK_PRIORITY_LEVEL(L7_DEFAULT_TASK_PRIORITY),
-                             L7_DEFAULT_TASK_SLICE);
-  if (cbTaskId == L7_ERROR)
-  {
-    PT_LOG_FATAL(LOG_CTX_CNFGR, "Could not create task ptin_igmp_sourcetimer_task");
-    return L7_FAILURE;
-  }
-  if (osapiWaitForTaskInit (L7_PTIN_IGMP_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
-  {
-    PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to initialize ptin_igmp_sourcetimer_task");
-    return(L7_FAILURE);
-  }
-
-  /* Create CB buffer pool */
-  cbBufferPoolId = 0;
-  if (bufferPoolInit(TIMER_COUNT,
-                     sizeof(timerNode_t) /*L7_APP_TMR_NODE_SIZE*/,
-                     "PTin_IGMP_CB_SourceTimer_Buffer",
-                     &cbBufferPoolId) != L7_SUCCESS)
-  {
-    PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to allocate memory for IGMP Control Block timer buffers");
-    return L7_FAILURE;
-  }
-
-  /* Create SLL list for each IGMP instance */
-  if (SLLCreate(L7_PTIN_COMPONENT_ID, L7_SLL_NO_ORDER,
-                sizeof(L7_uint32)*2, timerDataCmp, timerDataDestroy,
-                &timerLinkedList) != L7_SUCCESS)
-  {
-    PT_LOG_FATAL(LOG_CTX_CNFGR,"Failed to create timer linked list");
-    return L7_FAILURE;
-  }
-
-  /* Allocate memory for the Handle List */
-  handleListMemHndl = (handle_member_t*) osapiMalloc(L7_PTIN_COMPONENT_ID, TIMER_COUNT*sizeof(handle_member_t));
-  if (handleListMemHndl == L7_NULLPTR)
-  {
-    PT_LOG_FATAL(LOG_CTX_CNFGR,"Error allocating Handle List Buffers");
-    return L7_FAILURE;
-  }
-
-  /* Create timers handle list for this IGMP instance  */
-  if (handleListInit(L7_PTIN_COMPONENT_ID, TIMER_COUNT, &handleList, handleListMemHndl) != L7_SUCCESS)
-  {
-    PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to create timer handle list");
-    return L7_FAILURE;
-  }
-
-  /* Initialize timer control blocks */
-  cbTimer = appTimerInit(L7_PTIN_COMPONENT_ID, (void *) cbtimerCallback,
-                         L7_NULLPTR, L7_APP_TMR_1SEC,
-                         cbBufferPoolId);
-  if (cbTimer  == L7_NULLPTR)
-  {
-    PT_LOG_FATAL(LOG_CTX_CNFGR,"snoopEntry App Timer Initialization Failed.");
-    return L7_FAILURE;
-  }
-
-  PT_LOG_TRACE(LOG_CTX_CNFGR,"Initializations for IGMPv3 source timers finished");
-
-  return(L7_SUCCESS);
-}
-
-/*********************************************************************
-* @purpose  Stop Snooping task
-*
-* @param    none
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    none
-*
-* @end
-*********************************************************************/
-L7_RC_t snoop_ptin_sourcetimer_deinit(void)
-{
-  /* Deinitialize timer control blocks */
-  if (cbTimer != (L7_APP_TMR_CTRL_BLK_t) NULL)
-  {
-    appTimerDeInit(cbTimer);
-    cbTimer = (L7_APP_TMR_CTRL_BLK_t) NULL;
-  }
-
-  /* Remove timers handle list for this IGMP instance  */
-  handleListDeinit(L7_PTIN_COMPONENT_ID, handleList);
-
-  /* Free memory for the Handle List */
-  if (handleListMemHndl != L7_NULLPTR)
-  {
-    osapiFree(L7_PTIN_COMPONENT_ID, handleListMemHndl);
-    handleListMemHndl = L7_NULLPTR;
-  }
-
-  /* Destroy SLL list for each IGMP instance */
-  SLLDestroy(L7_PTIN_COMPONENT_ID, &timerLinkedList);
-
-  /* Buffer pool termination */
-  if (cbBufferPoolId != 0)
-  {
-    bufferPoolTerminate(cbBufferPoolId);
-    cbBufferPoolId = 0;
-  }
-
-  /* Delete task for sourcetimer management */
-  if ( cbTaskId != L7_ERROR )
-  {
-    osapiTaskDelete(cbTaskId);
-    cbTaskId = L7_ERROR;
-  }
-
-  /* Queue that will process timer events */
-  if (cbEventQueue != L7_NULLPTR)
-  {
-    osapiMsgQueueDelete(cbEventQueue);
-    cbEventQueue = L7_NULLPTR;
-  }
-
-  osapiSemaDelete(timerSem);
-  timerSem = L7_NULLPTR;
-
-  return(L7_SUCCESS);
-}
-
-/*********************************************************************
-* @purpose   This function is used to send timer events
-*
-* @param     timerCtrlBlk    @b{(input)}   Timer Control Block
-* @param     ptrData         @b{(input)}   Ptr to passed data
-*
-* @returns   None
-*
-* @notes     None
-* @end
-*********************************************************************/
-void cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData)
-{
-  snoopPtinSourcetimerParams_t msg = {0};
-  L7_RC_t                      rc;
-
-  rc = osapiMessageSend(cbEventQueue, &msg, PTIN_IGMP_TIMER_MSG_SIZE, L7_NO_WAIT,L7_MSG_PRIORITY_NORM);
-  if (rc != L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Sourcetimer timer tick send failed");
-    return;
-  }
-}
-
-/*************************************************************************
-* @purpose Task that makes the timer processing for the sourcetimer
-*          management 
-*  
-* @param    none
-*
-* @notes    none
-* @end
-*************************************************************************/
-void cbEventqueueTask(void)
-{
-  L7_uint32                    status;
-  snoopPtinSourcetimerParams_t msg;
-
-  if (osapiTaskInitDone(L7_PTIN_IGMP_TASK_SYNC)!=L7_SUCCESS)
-  {
-    PT_LOG_FATAL(LOG_CTX_SSM, "Error syncing task");
-    PTIN_CRASH();
-  }
-
-  while (1)
-  {
-    status = (L7_uint32) osapiMessageReceive(cbEventQueue, (void*)&msg,
-                                             PTIN_IGMP_TIMER_MSG_SIZE, L7_WAIT_FOREVER);
-    if (status == L7_SUCCESS)
-    {
-      appTimerProcess(cbTimer);
-    }
-    else
-    {
-      PT_LOG_ERR(LOG_CTX_IGMP,"This is an invalid event");
-    }
-  }
-}
-
-/*************************************************************************
-* @purpose  Helper API to compare two sourcetimer nodes and return the result
-*
-* @param     p  @b{(input)}  Pointer to Candidate 1 for comparison
-* @param     q  @b{(input)}  Pointer to Candidate 2 for comparison
-*
-* @returns   0   p = q
-* @returns  -1   p < q
-* @returns  +1   p > q
-*
-* @comments This is called by SLL library when nodes are compared
-*
-* @end
-*************************************************************************/
-L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key)
-{
-  L7_inet_addr_t pMcastGroupAddr, qMcastGroupAddr;
-  L7_uint32 pVlanId, pInterfaceIdx, pSourceIdx, qVlanId, qInterfaceIdx, qSourceIdx;
-
-  /* Validate argument */
-  if (p == L7_NULLPTR || ((snoopPTinL3Sourcetimer_t *) p)->groupData == L7_NULLPTR || 
-      q == L7_NULLPTR || ((snoopPTinL3Sourcetimer_t *) q)->groupData == L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
-    return 1;
-  }
-
-  pMcastGroupAddr = ((snoopPTinL3Sourcetimer_t *) p)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
-  pVlanId         = ((snoopPTinL3Sourcetimer_t *) p)->groupData->snoopPTinL3InfoDataKey.vlanId;
-  pInterfaceIdx   = ((snoopPTinL3Sourcetimer_t *) p)->interfaceIdx;
-  pSourceIdx      = ((snoopPTinL3Sourcetimer_t *) p)->sourceIdx;
-
-  qMcastGroupAddr = ((snoopPTinL3Sourcetimer_t *) q)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
-  qVlanId         = ((snoopPTinL3Sourcetimer_t *) q)->groupData->snoopPTinL3InfoDataKey.vlanId;
-  qInterfaceIdx   = ((snoopPTinL3Sourcetimer_t *) q)->interfaceIdx;
-  qSourceIdx      = ((snoopPTinL3Sourcetimer_t *) q)->sourceIdx;
-#if 1
-  if ( L7_INET_ADDR_COMPARE(&pMcastGroupAddr,&qMcastGroupAddr)==0 && 
-       pVlanId         == qVlanId         &&
-       pInterfaceIdx   == qInterfaceIdx   &&
-       pSourceIdx      == qSourceIdx      )
-    return 0;
-#else
-  if ( pMcastGroupAddr.addr.ipv4.s_addr==qMcastGroupAddr.addr.ipv4.s_addr && 
-       pVlanId         == qVlanId         &&
-       pInterfaceIdx   == qInterfaceIdx   &&
-       pSourceIdx      == qSourceIdx      )
-    return 0;
-#endif
-
-  return 1;
-}
-
-/*************************************************************************
-* @purpose  API to destroy the sourcetimer data node
-*
-* @param    ll_member  @b{(input)}  Linked list node containing the
-*                                   timer to be destroyed
-*
-* @returns  L7_SUCCESS
-*
-* @comments This is called by SLL library when a node is being deleted
-*
-* @end
-*************************************************************************/
-L7_RC_t timerDataDestroy (L7_sll_member_t *ll_member)
-{
-  snoopPTinL3Sourcetimer_t *pTimerData;
-
-  /* Validate argument */
-  if (ll_member==L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
-    return L7_FAILURE;
-  }
-
-  pTimerData = (snoopPTinL3Sourcetimer_t *)ll_member;
-
-  /* Destroy timer */
-  if (pTimerData->timer != L7_NULL)
-  {
-    /* Delete the apptimer node */
-    if (appTimerDelete(cbTimer, pTimerData->timer)!=L7_SUCCESS)
-    {
-      PT_LOG_NOTICE(LOG_CTX_IGMP,"Cannot delete timer");
-    }
-    pTimerData->timer = (L7_APP_TMR_HNDL_t) NULL;
-
-    /* Delete the handle we had created */
-    handleListNodeDelete(handleList, &pTimerData->timerHandle);
-    pTimerData->timerHandle = 0;
-  }
-
-  return L7_SUCCESS;
-}
-
-/*************************************************************************
- * @purpose Callback method that is called when the sourcetimer expires.
- *
- * @param   param  Timer Handle
- * 
- * @see     RFC 3376 6.3
- *
- * @todo    When the filter-mode is EXCLUDE, are the clients removed?
- *************************************************************************/
-void timerCallback(void *param)
-{
-  L7_uint32                intIfNum, sourceIdx;
-  char                     debug_buf[IPV6_DISP_ADDR_LEN],debug_buf2[IPV6_DISP_ADDR_LEN];
-  snoopPTinL3Interface_t   *interfacePtr;
-  L7_uint32                timerHandle;
-  snoopPTinL3Sourcetimer_t *pTimerData;
-  snoopPTinL3Source_t      *sourcePtr;
-  snoopPTinL3InfoData_t*   groupData;
-
-
-#if 0
-  L7_uint8            recordType=L7_IGMP_BLOCK_OLD_SOURCES;
-  snoopPTinProxyGroup_t* groupPtr=L7_NULLPTR;
-  snoopPTinProxyInterface_t* proxyInterfacePtr=L7_NULLPTR;
-  L7_uint32 noOfRecords=0;
-#endif
-
-  timerHandle = (L7_uint32) param;
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Get timer handler */
-  pTimerData = (snoopPTinL3Sourcetimer_t*) handleListNodeRetrieve(timerHandle);
-  if (pTimerData == L7_NULLPTR)
-  {
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Failed to retrieve handle");
-    osapiSemaGive(timerSem);
-    return;
-  }
-
-
-
-  //Save grouptimer's internal data
-  groupData    = pTimerData->groupData;
-  intIfNum     = pTimerData->interfaceIdx;
-  sourceIdx    = pTimerData->sourceIdx;
-  interfacePtr = &groupData->interfaces[intIfNum];
-  sourcePtr    = &groupData->interfaces[intIfNum].sources[sourceIdx];
-
-  osapiSemaGive(timerSem);
-
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Sourcetimer expired (group:%s vlan:%u ifId:%u sourceAddr)", 
-            inetAddrPrint(&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), groupData->snoopPTinL3InfoDataKey.vlanId, intIfNum, inetAddrPrint(&sourcePtr->sourceAddr,debug_buf2));
-
-  /* Check if our handle is OK*/
-  if (timerHandle != pTimerData->timerHandle)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"timerHandle and pTimerData->timerHandle do not match!");    
-    return;
-  }
-
-  if (interfacePtr->filtermode == PTIN_SNOOP_FILTERMODE_INCLUDE)
-  {
-    if (sourcePtr->isStatic==L7_FALSE)
-    {
-
-      if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM)
-      {
-#if 0
-        if (noOfRecords==0)
-        {
-          noOfRecords=1;
-          if ( (proxyInterfacePtr=snoopPTinProxyInterfaceAdd(groupData->snoopPTinL3InfoDataKey.vlanId)) ==L7_NULLPTR)
-          {
-            PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinProxyInterfaceAdd()");
-            return ;
-          }
-
-          if ((groupPtr=snoopPTinGroupRecordAdd(proxyInterfacePtr,recordType,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr ))==L7_NULLPTR)
-          {
-            PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordGroupAdd()");
-            return ;
-          }
-        }
-        if (L7_SUCCESS != snoopPTinGroupRecordSourcedAdd(groupPtr,&sourcePtr->sourceAddr))
-        {
-          PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordSourcedAdd()");       
-          return ;
-        }
-#endif        
-        PT_LOG_DEBUG(LOG_CTX_IGMP, "Root Interface - Removing source %s", inetAddrPrint(&(sourcePtr->sourceAddr), debug_buf));        
-      }
-      else
-      {
-
-        PT_LOG_DEBUG(LOG_CTX_IGMP, "Leaf Interface - Removing source %s", inetAddrPrint(&(sourcePtr->sourceAddr), debug_buf));        
-      }
-      /* Remove source */
-      snoopPTinSourceRemove(interfacePtr, sourcePtr);        
-    }
-    /* If no more sources remain, remove group */
-    if (interfacePtr->numberOfSources == 0 && interfacePtr->isStatic==L7_FALSE)
-    {
-#if 0
-      if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM)
-      {
-        if (L7_SUCCESS != snoopPTinGroupRecordRemoveAllSources(groupPtr))
-        {
-          PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordRemoveAllSources()");       
-          return;
-        }
-        groupPtr->key.recordType=L7_IGMP_MODE_IS_INCLUDE;                       
-        PT_LOG_TRACE(LOG_CTX_IGMP, "Schedule Membership Report Message");
-        if (snoopPTinReportSchedule(groupData->snoopPTinL3InfoDataKey.vlanId,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr,SNOOP_PTIN_MEMBERSHIP_REPORT,0,0,1,groupPtr)!=L7_SUCCESS)
-        {
-          PT_LOG_ERR(LOG_CTX_IGMP,"Failed snoopPTinReportSchedule()");
-          return;
-        }
-        noOfRecords=0;
-      }
-#endif
-      PT_LOG_DEBUG(LOG_CTX_IGMP, "Group has no more sources, thus it is being removed.");
-      snoopPTinInterfaceRemove(interfacePtr,groupData->snoopPTinL3InfoDataKey.vlanId,&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr),intIfNum);
-    }
-  }
-#if 0    
-  if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM && noOfRecords>0)
-  {
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Schedule Membership Report Message");
-    if (snoopPTinReportSchedule(groupData->snoopPTinL3InfoDataKey.vlanId,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr,SNOOP_PTIN_MEMBERSHIP_REPORT,0,0,noOfRecords,groupPtr)!=L7_SUCCESS)
-    {
-      PT_LOG_ERR(LOG_CTX_IGMP,"Failed snoopPTinReportSchedule()");
-      return;
-    }
-  }
-#endif
-
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);  
-  pTimerData->isRunning = L7_FALSE;
-  osapiSemaGive(timerSem);
-}
-
-/*************************************************************************
- * @purpose Start a sourcetimer
- * 
- * @param   pTimer          Pointer to timer
- * @param   timeout         Timer's timeout
- * @param   groupData       Pointer to multicast group data
- * @param   interfaceIdx    Interface index
- *
- * @returns L7_SUCCESS
- * @returns L7_FAILURE
- *
- *************************************************************************/
-L7_RC_t snoop_ptin_sourcetimer_start(snoopPTinL3Sourcetimer_t *pTimer, L7_uint32 timeout, snoopPTinL3InfoData_t *groupData, L7_uint32 interfaceIdx, L7_uint32 sourceIdx)
-{
-  L7_BOOL                  restart_timer = L7_FALSE;
-  snoopPTinL3Sourcetimer_t pTimerData;
-  char                     debug_buf[46],debug_buf2[46];
-
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR || groupData == L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
-    return L7_FAILURE;
-  }
-
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Check if this timer already exists */
-  memset(&pTimerData, 0x00, sizeof(snoopPTinL3Sourcetimer_t));  
-  pTimerData.groupData    = groupData;
-  pTimerData.interfaceIdx = interfaceIdx;
-  pTimerData.sourceIdx    = sourceIdx;
-  if (SLLFind(&timerLinkedList, (void *)&pTimerData) != L7_NULL)
-  {
-    restart_timer = L7_TRUE;
-    if (pTimer->isRunning == L7_TRUE)
-    {
-      if (appTimerDelete(cbTimer, (void *) pTimer->timer) != L7_SUCCESS)
-      {
-        osapiSemaGive(timerSem);
-        PT_LOG_ERR(LOG_CTX_IGMP,"Failed restarting timer");
-        return L7_FAILURE;
-      }
-      pTimer->isRunning = L7_FALSE;
-      pTimer->timer = L7_NULLPTR;
-
-      /* Remove timer handle */
-      handleListNodeDelete(handleList, &pTimer->timerHandle);
-      pTimer->timerHandle = 0;
-    }
-  }
-  else
-  {
-    pTimer->groupData    = groupData;
-    pTimer->interfaceIdx = interfaceIdx;
-    pTimer->sourceIdx    = sourceIdx;
-  }
-
-  PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting sourcetimer (timeout:%u group:%s vlan:%u ifIdx:%u srcAddr:%s)",
-            timeout, inetAddrPrint(&(pTimer->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), 
-            pTimer->groupData->snoopPTinL3InfoDataKey.vlanId, interfaceIdx, inetAddrPrint(&(pTimer->groupData->interfaces[interfaceIdx].sources[sourceIdx].sourceAddr), debug_buf2));
-
-  /* If timeout was configured as 0, do not set up the timer */
-  if (timeout == 0)
-  {
-    pTimer->isRunning = L7_FALSE;
-    osapiSemaGive(timerSem);
-    return L7_SUCCESS;
-  }
-
-  /* New timer handle */
-  if ((pTimer->timerHandle = handleListNodeStore(handleList, pTimer)) == 0)
-  {
-    osapiSemaGive(timerSem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
-    return L7_FAILURE;
-  }
-
-  /* Add a new timer */
-  pTimer->timer = appTimerAdd(cbTimer, timerCallback,
-                              (void *) pTimer->timerHandle, timeout,
-                              "PTIN_TIMER");
-  if (pTimer->timer == NULL)
-  {
-    handleListNodeDelete(handleList, &pTimer->timerHandle);
-    pTimer->timerHandle = 0;
-    osapiSemaGive(timerSem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Could not start the sourcetimer.");
-    return L7_FAILURE;
-  }
-
-  /* Add timer to SLL */
-  if (!restart_timer && (SLLAdd(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS))
-  {
-    if (appTimerDelete(cbTimer, pTimer->timer) != L7_SUCCESS)
-    {
-      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
-    }
-    pTimer->timer = L7_NULLPTR;
-    handleListNodeDelete(handleList, &pTimer->timerHandle);
-    pTimer->timerHandle = 0;
-    osapiSemaGive(timerSem);
-    PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
-    return L7_FAILURE;
-  }
-
-  /* Set timer status as running */
-  pTimer->isRunning = L7_TRUE;
-  osapiSemaGive(timerSem);
-  return L7_SUCCESS;
-}
-
-/*************************************************************************
- * @purpose Stop a sourcetimer
- * 
- * @param   pTimer  Pointer to timer
- *
- * @returns L7_SUCCESS
- * @returns L7_FAILURE
- *
- *************************************************************************/
-L7_RC_t snoop_ptin_sourcetimer_stop(snoopPTinL3Sourcetimer_t *pTimer)
-{
-  char debug_buf[46],debug_buf2[46];
-
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR ||pTimer->groupData == L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
-    return L7_FAILURE;
-  }
-
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Removing sourcetimer (group:%s vlan:%u ifIdx:%u srcAddr:%s)",
-            inetAddrPrint(&(pTimer->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), pTimer->groupData->snoopPTinL3InfoDataKey.vlanId, pTimer->interfaceIdx, inetAddrPrint(&(pTimer->groupData->interfaces[pTimer->interfaceIdx].sources[pTimer->sourceIdx].sourceAddr), debug_buf2));  
-
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Remove node for SLL list */
-  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS)
-  {
-    osapiSemaGive(timerSem);
-    PT_LOG_NOTICE(LOG_CTX_IGMP,"Failed to delete timer node");
-    return L7_FAILURE;
-  }
-
-  osapiSemaGive(timerSem);
-
-  return L7_SUCCESS;
-}
-
-/*************************************************************************
- * @purpose Get the timeleft for a given sourcetimer
- * 
- * @param   pTimer  Pointer to timer
- *
- * @returns Timer's time left
- *
- *************************************************************************/
-L7_uint32 snoop_ptin_sourcetimer_timeleft(snoopPTinL3Sourcetimer_t *pTimer)
-{
-  L7_uint32 time_left = 0;
-
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR)
-  {
-    /*If timer is not running the pTimer==L7_NULLPTR*/
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
-
-    return 0;
-  }
-  else if (pTimer->isRunning == L7_FALSE) /*Check if the Timer is Still Running*/
-  {
-    return 0;     
-  }
-  else if (pTimer->timer == L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
-    return 0;
-  }
-  appTimerTimeLeftGet(cbTimer, pTimer->timer, &time_left);
-
-  return time_left;
-}
-
-
-/*************************************************************************
- * @purpose Verify if the timer is running or not
- * 
- * @param   pTimer  Pointer to timer
- *
- * @returns Timer's time left
- *
- *************************************************************************/
-L7_BOOL snoop_ptin_sourcetimer_isRunning(snoopPTinL3Sourcetimer_t *pTimer)
-{
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR || pTimer->timer == L7_NULLPTR)
-  {
-    return L7_FALSE;
-  }
-  else
-  {
-    return L7_TRUE;
-  }
-}
-
+/*
+ * ptin_igmp_sourcetimer.c
+ *
+ *  Created on: 22 de Abr de 2013
+ *      Author: Daniel Figueira
+ */
+
+#include "snooping_ptin_sourcetimer.h"
+#include "snooping_ptin_util.h"
+#include "snooping_db.h"
+#include "snooping_ptin_db.h"
+
+#include "ptin_igmp.h"
+
+#include <unistd.h>
+
+#define TIMER_COUNT 1
+
+/* Message placed in CB queue */
+typedef struct snoopPtinSourcetimerParams_s
+{
+  L7_uint8 eventIdx;
+} snoopPtinSourcetimerParams_t;
+#define PTIN_IGMP_TIMER_MSG_SIZE  sizeof(snoopPtinSourcetimerParams_t)
+
+/* Static variables */
+static void                   *handleListMemHndl = L7_NULLPTR;
+static void                   *cbEventQueue = L7_NULLPTR;
+static void                   *timerSem = L7_NULLPTR;
+static L7_sll_t               timerLinkedList;
+static L7_uint32              cbTaskId = L7_ERROR;
+static L7_uint32              cbBufferPoolId = 0;
+static handle_list_t          *handleList;
+static L7_APP_TMR_CTRL_BLK_t  cbTimer;
+
+/* Static methods */
+static void     cbEventqueueTask(void);
+static void     cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData);
+static L7_RC_t  timerDataDestroy(L7_sll_member_t *ll_member);
+static L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key);
+static void     timerCallback(void *param);
+
+
+/*********************************************************************
+* @purpose  Start Snooping task
+*
+* @param    none
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    none
+*
+* @end
+*********************************************************************/
+L7_RC_t snoop_ptin_sourcetimer_init(void)
+{
+  /* Create queue semaphore */
+  timerSem = osapiSemaBCreate(OSAPI_SEM_Q_FIFO, OSAPI_SEM_FULL);
+  if (timerSem == L7_NULLPTR)
+  {
+    PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to create timers_sem semaphore!");
+    return L7_FAILURE;
+  }
+
+  /* Queue that will process timer events */
+  cbEventQueue = (void *) osapiMsgQueueCreate("cb_event_queue_sourcetimer", TIMER_COUNT, PTIN_IGMP_TIMER_MSG_SIZE);
+  if (cbEventQueue == L7_NULLPTR)
+  {
+    PT_LOG_FATAL(LOG_CTX_CNFGR,"cb_event_queue creation error.");
+    return L7_FAILURE;
+  }
+
+  /* Create task for sourcetimer management */
+  cbTaskId = osapiTaskCreate("ptin_igmp_sourcetimer_task", cbEventqueueTask, 0, 0,
+                             L7_DEFAULT_STACK_SIZE,
+                             L7_TASK_PRIORITY_LEVEL(L7_DEFAULT_TASK_PRIORITY),
+                             L7_DEFAULT_TASK_SLICE);
+  if (cbTaskId == L7_ERROR)
+  {
+    PT_LOG_FATAL(LOG_CTX_CNFGR, "Could not create task ptin_igmp_sourcetimer_task");
+    return L7_FAILURE;
+  }
+  if (osapiWaitForTaskInit (L7_PTIN_IGMP_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
+  {
+    PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to initialize ptin_igmp_sourcetimer_task");
+    return(L7_FAILURE);
+  }
+
+  /* Create CB buffer pool */
+  cbBufferPoolId = 0;
+  if (bufferPoolInit(TIMER_COUNT,
+                     sizeof(timerNode_t) /*L7_APP_TMR_NODE_SIZE*/,
+                     "PTin_IGMP_CB_SourceTimer_Buffer",
+                     &cbBufferPoolId) != L7_SUCCESS)
+  {
+    PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to allocate memory for IGMP Control Block timer buffers");
+    return L7_FAILURE;
+  }
+
+  /* Create SLL list for each IGMP instance */
+  if (SLLCreate(L7_PTIN_COMPONENT_ID, L7_SLL_NO_ORDER,
+                sizeof(L7_uint32)*2, timerDataCmp, timerDataDestroy,
+                &timerLinkedList) != L7_SUCCESS)
+  {
+    PT_LOG_FATAL(LOG_CTX_CNFGR,"Failed to create timer linked list");
+    return L7_FAILURE;
+  }
+
+  /* Allocate memory for the Handle List */
+  handleListMemHndl = (handle_member_t*) osapiMalloc(L7_PTIN_COMPONENT_ID, TIMER_COUNT*sizeof(handle_member_t));
+  if (handleListMemHndl == L7_NULLPTR)
+  {
+    PT_LOG_FATAL(LOG_CTX_CNFGR,"Error allocating Handle List Buffers");
+    return L7_FAILURE;
+  }
+
+  /* Create timers handle list for this IGMP instance  */
+  if (handleListInit(L7_PTIN_COMPONENT_ID, TIMER_COUNT, &handleList, handleListMemHndl) != L7_SUCCESS)
+  {
+    PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to create timer handle list");
+    return L7_FAILURE;
+  }
+
+  /* Initialize timer control blocks */
+  cbTimer = appTimerInit(L7_PTIN_COMPONENT_ID, (void *) cbtimerCallback,
+                         L7_NULLPTR, L7_APP_TMR_1SEC,
+                         cbBufferPoolId);
+  if (cbTimer  == L7_NULLPTR)
+  {
+    PT_LOG_FATAL(LOG_CTX_CNFGR,"snoopEntry App Timer Initialization Failed.");
+    return L7_FAILURE;
+  }
+
+  PT_LOG_TRACE(LOG_CTX_CNFGR,"Initializations for IGMPv3 source timers finished");
+
+  return(L7_SUCCESS);
+}
+
+/*********************************************************************
+* @purpose  Stop Snooping task
+*
+* @param    none
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    none
+*
+* @end
+*********************************************************************/
+L7_RC_t snoop_ptin_sourcetimer_deinit(void)
+{
+  /* Deinitialize timer control blocks */
+  if (cbTimer != (L7_APP_TMR_CTRL_BLK_t) NULL)
+  {
+    appTimerDeInit(cbTimer);
+    cbTimer = (L7_APP_TMR_CTRL_BLK_t) NULL;
+  }
+
+  /* Remove timers handle list for this IGMP instance  */
+  handleListDeinit(L7_PTIN_COMPONENT_ID, handleList);
+
+  /* Free memory for the Handle List */
+  if (handleListMemHndl != L7_NULLPTR)
+  {
+    osapiFree(L7_PTIN_COMPONENT_ID, handleListMemHndl);
+    handleListMemHndl = L7_NULLPTR;
+  }
+
+  /* Destroy SLL list for each IGMP instance */
+  SLLDestroy(L7_PTIN_COMPONENT_ID, &timerLinkedList);
+
+  /* Buffer pool termination */
+  if (cbBufferPoolId != 0)
+  {
+    bufferPoolTerminate(cbBufferPoolId);
+    cbBufferPoolId = 0;
+  }
+
+  /* Delete task for sourcetimer management */
+  if ( cbTaskId != L7_ERROR )
+  {
+    osapiTaskDelete(cbTaskId);
+    cbTaskId = L7_ERROR;
+  }
+
+  /* Queue that will process timer events */
+  if (cbEventQueue != L7_NULLPTR)
+  {
+    osapiMsgQueueDelete(cbEventQueue);
+    cbEventQueue = L7_NULLPTR;
+  }
+
+  osapiSemaDelete(timerSem);
+  timerSem = L7_NULLPTR;
+
+  return(L7_SUCCESS);
+}
+
+/*********************************************************************
+* @purpose   This function is used to send timer events
+*
+* @param     timerCtrlBlk    @b{(input)}   Timer Control Block
+* @param     ptrData         @b{(input)}   Ptr to passed data
+*
+* @returns   None
+*
+* @notes     None
+* @end
+*********************************************************************/
+void cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData)
+{
+  snoopPtinSourcetimerParams_t msg = {0};
+  L7_RC_t                      rc;
+
+  rc = osapiMessageSend(cbEventQueue, &msg, PTIN_IGMP_TIMER_MSG_SIZE, L7_NO_WAIT,L7_MSG_PRIORITY_NORM);
+  if (rc != L7_SUCCESS)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Sourcetimer timer tick send failed");
+    return;
+  }
+}
+
+/*************************************************************************
+* @purpose Task that makes the timer processing for the sourcetimer
+*          management 
+*  
+* @param    none
+*
+* @notes    none
+* @end
+*************************************************************************/
+void cbEventqueueTask(void)
+{
+  L7_uint32                    status;
+  snoopPtinSourcetimerParams_t msg;
+
+  if (osapiTaskInitDone(L7_PTIN_IGMP_TASK_SYNC)!=L7_SUCCESS)
+  {
+    PT_LOG_FATAL(LOG_CTX_SSM, "Error syncing task");
+    PTIN_CRASH();
+  }
+
+  while (1)
+  {
+    status = (L7_uint32) osapiMessageReceive(cbEventQueue, (void*)&msg,
+                                             PTIN_IGMP_TIMER_MSG_SIZE, L7_WAIT_FOREVER);
+    if (status == L7_SUCCESS)
+    {
+      appTimerProcess(cbTimer);
+    }
+    else
+    {
+      PT_LOG_ERR(LOG_CTX_IGMP,"This is an invalid event");
+    }
+  }
+}
+
+/*************************************************************************
+* @purpose  Helper API to compare two sourcetimer nodes and return the result
+*
+* @param     p  @b{(input)}  Pointer to Candidate 1 for comparison
+* @param     q  @b{(input)}  Pointer to Candidate 2 for comparison
+*
+* @returns   0   p = q
+* @returns  -1   p < q
+* @returns  +1   p > q
+*
+* @comments This is called by SLL library when nodes are compared
+*
+* @end
+*************************************************************************/
+L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key)
+{
+  L7_inet_addr_t pMcastGroupAddr, qMcastGroupAddr;
+  L7_uint32 pVlanId, pInterfaceIdx, pSourceIdx, qVlanId, qInterfaceIdx, qSourceIdx;
+
+  /* Validate argument */
+  if (p == L7_NULLPTR || ((snoopPTinL3Sourcetimer_t *) p)->groupData == L7_NULLPTR || 
+      q == L7_NULLPTR || ((snoopPTinL3Sourcetimer_t *) q)->groupData == L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
+    return 1;
+  }
+
+  pMcastGroupAddr = ((snoopPTinL3Sourcetimer_t *) p)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
+  pVlanId         = ((snoopPTinL3Sourcetimer_t *) p)->groupData->snoopPTinL3InfoDataKey.vlanId;
+  pInterfaceIdx   = ((snoopPTinL3Sourcetimer_t *) p)->interfaceIdx;
+  pSourceIdx      = ((snoopPTinL3Sourcetimer_t *) p)->sourceIdx;
+
+  qMcastGroupAddr = ((snoopPTinL3Sourcetimer_t *) q)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
+  qVlanId         = ((snoopPTinL3Sourcetimer_t *) q)->groupData->snoopPTinL3InfoDataKey.vlanId;
+  qInterfaceIdx   = ((snoopPTinL3Sourcetimer_t *) q)->interfaceIdx;
+  qSourceIdx      = ((snoopPTinL3Sourcetimer_t *) q)->sourceIdx;
+#if 1
+  if ( L7_INET_ADDR_COMPARE(&pMcastGroupAddr,&qMcastGroupAddr)==0 && 
+       pVlanId         == qVlanId         &&
+       pInterfaceIdx   == qInterfaceIdx   &&
+       pSourceIdx      == qSourceIdx      )
+    return 0;
+#else
+  if ( pMcastGroupAddr.addr.ipv4.s_addr==qMcastGroupAddr.addr.ipv4.s_addr && 
+       pVlanId         == qVlanId         &&
+       pInterfaceIdx   == qInterfaceIdx   &&
+       pSourceIdx      == qSourceIdx      )
+    return 0;
+#endif
+
+  return 1;
+}
+
+/*************************************************************************
+* @purpose  API to destroy the sourcetimer data node
+*
+* @param    ll_member  @b{(input)}  Linked list node containing the
+*                                   timer to be destroyed
+*
+* @returns  L7_SUCCESS
+*
+* @comments This is called by SLL library when a node is being deleted
+*
+* @end
+*************************************************************************/
+L7_RC_t timerDataDestroy (L7_sll_member_t *ll_member)
+{
+  snoopPTinL3Sourcetimer_t *pTimerData;
+
+  /* Validate argument */
+  if (ll_member==L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
+    return L7_FAILURE;
+  }
+
+  pTimerData = (snoopPTinL3Sourcetimer_t *)ll_member;
+
+  /* Destroy timer */
+  if (pTimerData->timer != L7_NULL)
+  {
+    /* Delete the apptimer node */
+    if (appTimerDelete(cbTimer, pTimerData->timer)!=L7_SUCCESS)
+    {
+      PT_LOG_NOTICE(LOG_CTX_IGMP,"Cannot delete timer");
+    }
+    pTimerData->timer = (L7_APP_TMR_HNDL_t) NULL;
+
+    /* Delete the handle we had created */
+    handleListNodeDelete(handleList, &pTimerData->timerHandle);
+    pTimerData->timerHandle = 0;
+  }
+
+  return L7_SUCCESS;
+}
+
+/*************************************************************************
+ * @purpose Callback method that is called when the sourcetimer expires.
+ *
+ * @param   param  Timer Handle
+ * 
+ * @see     RFC 3376 6.3
+ *
+ * @todo    When the filter-mode is EXCLUDE, are the clients removed?
+ *************************************************************************/
+void timerCallback(void *param)
+{
+  L7_uint32                intIfNum, sourceIdx;
+  char                     debug_buf[IPV6_DISP_ADDR_LEN],debug_buf2[IPV6_DISP_ADDR_LEN];
+  snoopPTinL3Interface_t   *interfacePtr;
+  L7_uint32                timerHandle;
+  snoopPTinL3Sourcetimer_t *pTimerData;
+  snoopPTinL3Source_t      *sourcePtr;
+  snoopPTinL3InfoData_t*   groupData;
+
+
+#if 0
+  L7_uint8            recordType=L7_IGMP_BLOCK_OLD_SOURCES;
+  snoopPTinProxyGroup_t* groupPtr=L7_NULLPTR;
+  snoopPTinProxyInterface_t* proxyInterfacePtr=L7_NULLPTR;
+  L7_uint32 noOfRecords=0;
+#endif
+
+  timerHandle = (L7_uint32) param;
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Get timer handler */
+  pTimerData = (snoopPTinL3Sourcetimer_t*) handleListNodeRetrieve(timerHandle);
+  if (pTimerData == L7_NULLPTR)
+  {
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Failed to retrieve handle");
+    osapiSemaGive(timerSem);
+    return;
+  }
+
+
+
+  //Save grouptimer's internal data
+  groupData    = pTimerData->groupData;
+  intIfNum     = pTimerData->interfaceIdx;
+  sourceIdx    = pTimerData->sourceIdx;
+  interfacePtr = &groupData->interfaces[intIfNum];
+  sourcePtr    = &groupData->interfaces[intIfNum].sources[sourceIdx];
+
+  osapiSemaGive(timerSem);
+
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Sourcetimer expired (group:%s vlan:%u ifId:%u sourceAddr)", 
+            inetAddrPrint(&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), groupData->snoopPTinL3InfoDataKey.vlanId, intIfNum, inetAddrPrint(&sourcePtr->sourceAddr,debug_buf2));
+
+  /* Check if our handle is OK*/
+  if (timerHandle != pTimerData->timerHandle)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"timerHandle and pTimerData->timerHandle do not match!");    
+    return;
+  }
+
+  if (interfacePtr->filtermode == PTIN_SNOOP_FILTERMODE_INCLUDE)
+  {
+    if (sourcePtr->isStatic==L7_FALSE)
+    {
+
+      if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM)
+      {
+#if 0
+        if (noOfRecords==0)
+        {
+          noOfRecords=1;
+          if ( (proxyInterfacePtr=snoopPTinProxyInterfaceAdd(groupData->snoopPTinL3InfoDataKey.vlanId)) ==L7_NULLPTR)
+          {
+            PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinProxyInterfaceAdd()");
+            return ;
+          }
+
+          if ((groupPtr=snoopPTinGroupRecordAdd(proxyInterfacePtr,recordType,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr ))==L7_NULLPTR)
+          {
+            PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordGroupAdd()");
+            return ;
+          }
+        }
+        if (L7_SUCCESS != snoopPTinGroupRecordSourcedAdd(groupPtr,&sourcePtr->sourceAddr))
+        {
+          PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordSourcedAdd()");       
+          return ;
+        }
+#endif        
+        PT_LOG_DEBUG(LOG_CTX_IGMP, "Root Interface - Removing source %s", inetAddrPrint(&(sourcePtr->sourceAddr), debug_buf));        
+      }
+      else
+      {
+
+        PT_LOG_DEBUG(LOG_CTX_IGMP, "Leaf Interface - Removing source %s", inetAddrPrint(&(sourcePtr->sourceAddr), debug_buf));        
+      }
+      /* Remove source */
+      snoopPTinSourceRemove(interfacePtr, sourcePtr);        
+    }
+    /* If no more sources remain, remove group */
+    if (interfacePtr->numberOfSources == 0 && interfacePtr->isStatic==L7_FALSE)
+    {
+#if 0
+      if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM)
+      {
+        if (L7_SUCCESS != snoopPTinGroupRecordRemoveAllSources(groupPtr))
+        {
+          PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinGroupRecordRemoveAllSources()");       
+          return;
+        }
+        groupPtr->key.recordType=L7_IGMP_MODE_IS_INCLUDE;                       
+        PT_LOG_TRACE(LOG_CTX_IGMP, "Schedule Membership Report Message");
+        if (snoopPTinReportSchedule(groupData->snoopPTinL3InfoDataKey.vlanId,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr,SNOOP_PTIN_MEMBERSHIP_REPORT,0,0,1,groupPtr)!=L7_SUCCESS)
+        {
+          PT_LOG_ERR(LOG_CTX_IGMP,"Failed snoopPTinReportSchedule()");
+          return;
+        }
+        noOfRecords=0;
+      }
+#endif
+      PT_LOG_DEBUG(LOG_CTX_IGMP, "Group has no more sources, thus it is being removed.");
+      snoopPTinInterfaceRemove(interfacePtr,groupData->snoopPTinL3InfoDataKey.vlanId,&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr),intIfNum);
+    }
+  }
+#if 0    
+  if (intIfNum==SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM && noOfRecords>0)
+  {
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Schedule Membership Report Message");
+    if (snoopPTinReportSchedule(groupData->snoopPTinL3InfoDataKey.vlanId,&groupData->snoopPTinL3InfoDataKey.mcastGroupAddr,SNOOP_PTIN_MEMBERSHIP_REPORT,0,0,noOfRecords,groupPtr)!=L7_SUCCESS)
+    {
+      PT_LOG_ERR(LOG_CTX_IGMP,"Failed snoopPTinReportSchedule()");
+      return;
+    }
+  }
+#endif
+
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);  
+  pTimerData->isRunning = L7_FALSE;
+  osapiSemaGive(timerSem);
+}
+
+/*************************************************************************
+ * @purpose Start a sourcetimer
+ * 
+ * @param   pTimer          Pointer to timer
+ * @param   timeout         Timer's timeout
+ * @param   groupData       Pointer to multicast group data
+ * @param   interfaceIdx    Interface index
+ *
+ * @returns L7_SUCCESS
+ * @returns L7_FAILURE
+ *
+ *************************************************************************/
+L7_RC_t snoop_ptin_sourcetimer_start(snoopPTinL3Sourcetimer_t *pTimer, L7_uint32 timeout, snoopPTinL3InfoData_t *groupData, L7_uint32 interfaceIdx, L7_uint32 sourceIdx)
+{
+  L7_BOOL                  restart_timer = L7_FALSE;
+  snoopPTinL3Sourcetimer_t pTimerData;
+  char                     debug_buf[46],debug_buf2[46];
+
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR || groupData == L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
+    return L7_FAILURE;
+  }
+
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Check if this timer already exists */
+  memset(&pTimerData, 0x00, sizeof(snoopPTinL3Sourcetimer_t));  
+  pTimerData.groupData    = groupData;
+  pTimerData.interfaceIdx = interfaceIdx;
+  pTimerData.sourceIdx    = sourceIdx;
+  if (SLLFind(&timerLinkedList, (void *)&pTimerData) != L7_NULL)
+  {
+    restart_timer = L7_TRUE;
+    if (pTimer->isRunning == L7_TRUE)
+    {
+      if (appTimerDelete(cbTimer, (void *) pTimer->timer) != L7_SUCCESS)
+      {
+        osapiSemaGive(timerSem);
+        PT_LOG_ERR(LOG_CTX_IGMP,"Failed restarting timer");
+        return L7_FAILURE;
+      }
+      pTimer->isRunning = L7_FALSE;
+      pTimer->timer = L7_NULLPTR;
+
+      /* Remove timer handle */
+      handleListNodeDelete(handleList, &pTimer->timerHandle);
+      pTimer->timerHandle = 0;
+    }
+  }
+  else
+  {
+    pTimer->groupData    = groupData;
+    pTimer->interfaceIdx = interfaceIdx;
+    pTimer->sourceIdx    = sourceIdx;
+  }
+
+  PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting sourcetimer (timeout:%u group:%s vlan:%u ifIdx:%u srcAddr:%s)",
+            timeout, inetAddrPrint(&(pTimer->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), 
+            pTimer->groupData->snoopPTinL3InfoDataKey.vlanId, interfaceIdx, inetAddrPrint(&(pTimer->groupData->interfaces[interfaceIdx].sources[sourceIdx].sourceAddr), debug_buf2));
+
+  /* If timeout was configured as 0, do not set up the timer */
+  if (timeout == 0)
+  {
+    pTimer->isRunning = L7_FALSE;
+    osapiSemaGive(timerSem);
+    return L7_SUCCESS;
+  }
+
+  /* New timer handle */
+  if ((pTimer->timerHandle = handleListNodeStore(handleList, pTimer)) == 0)
+  {
+    osapiSemaGive(timerSem);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
+    return L7_FAILURE;
+  }
+
+  /* Add a new timer */
+  pTimer->timer = appTimerAdd(cbTimer, timerCallback,
+                              (void *) pTimer->timerHandle, timeout,
+                              "PTIN_TIMER");
+  if (pTimer->timer == NULL)
+  {
+    handleListNodeDelete(handleList, &pTimer->timerHandle);
+    pTimer->timerHandle = 0;
+    osapiSemaGive(timerSem);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Could not start the sourcetimer.");
+    return L7_FAILURE;
+  }
+
+  /* Add timer to SLL */
+  if (!restart_timer && (SLLAdd(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS))
+  {
+    if (appTimerDelete(cbTimer, pTimer->timer) != L7_SUCCESS)
+    {
+      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
+    }
+    pTimer->timer = L7_NULLPTR;
+    handleListNodeDelete(handleList, &pTimer->timerHandle);
+    pTimer->timerHandle = 0;
+    osapiSemaGive(timerSem);
+    PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
+    return L7_FAILURE;
+  }
+
+  /* Set timer status as running */
+  pTimer->isRunning = L7_TRUE;
+  osapiSemaGive(timerSem);
+  return L7_SUCCESS;
+}
+
+/*************************************************************************
+ * @purpose Stop a sourcetimer
+ * 
+ * @param   pTimer  Pointer to timer
+ *
+ * @returns L7_SUCCESS
+ * @returns L7_FAILURE
+ *
+ *************************************************************************/
+L7_RC_t snoop_ptin_sourcetimer_stop(snoopPTinL3Sourcetimer_t *pTimer)
+{
+  char debug_buf[46],debug_buf2[46];
+
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR ||pTimer->groupData == L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
+    return L7_FAILURE;
+  }
+
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Removing sourcetimer (group:%s vlan:%u ifIdx:%u srcAddr:%s)",
+            inetAddrPrint(&(pTimer->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), pTimer->groupData->snoopPTinL3InfoDataKey.vlanId, pTimer->interfaceIdx, inetAddrPrint(&(pTimer->groupData->interfaces[pTimer->interfaceIdx].sources[pTimer->sourceIdx].sourceAddr), debug_buf2));  
+
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Remove node for SLL list */
+  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS)
+  {
+    osapiSemaGive(timerSem);
+    PT_LOG_NOTICE(LOG_CTX_IGMP,"Failed to delete timer node");
+    return L7_FAILURE;
+  }
+
+  osapiSemaGive(timerSem);
+
+  return L7_SUCCESS;
+}
+
+/*************************************************************************
+ * @purpose Get the timeleft for a given sourcetimer
+ * 
+ * @param   pTimer  Pointer to timer
+ *
+ * @returns Timer's time left
+ *
+ *************************************************************************/
+L7_uint32 snoop_ptin_sourcetimer_timeleft(snoopPTinL3Sourcetimer_t *pTimer)
+{
+  L7_uint32 time_left = 0;
+
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR)
+  {
+    /*If timer is not running the pTimer==L7_NULLPTR*/
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
+
+    return 0;
+  }
+  else if (pTimer->isRunning == L7_FALSE) /*Check if the Timer is Still Running*/
+  {
+    return 0;     
+  }
+  else if (pTimer->timer == L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
+    return 0;
+  }
+  appTimerTimeLeftGet(cbTimer, pTimer->timer, &time_left);
+
+  return time_left;
+}
+
+
+/*************************************************************************
+ * @purpose Verify if the timer is running or not
+ * 
+ * @param   pTimer  Pointer to timer
+ *
+ * @returns Timer's time left
+ *
+ *************************************************************************/
+L7_BOOL snoop_ptin_sourcetimer_isRunning(snoopPTinL3Sourcetimer_t *pTimer)
+{
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR || pTimer->timer == L7_NULLPTR)
+  {
+    return L7_FALSE;
+  }
+  else
+  {
+    return L7_TRUE;
+  }
+}
+
Index: src/application/switching/snooping/core/snooping_ptin_querytimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_querytimer.c	(revision 7370)
+++ src/application/switching/snooping/core/snooping_ptin_querytimer.c	(revision 7371)
@@ -1,548 +1,548 @@
-/*
- * ptin_igmp_querytimer.c
- *
- *  Created on: 22 de Abr de 2013
- *      Author: Daniel Figueira
- */
-
-#include "snooping_ptin_querytimer.h"
-#include "snooping_ptin_util.h"
-#include "snooping_db.h"
-#include "snooping_ptin_db.h"
-
-#include <unistd.h>
-
-#define TIMER_COUNT 1
-
-/* Message placed in CB queue */
-typedef struct snoopPtinQuerytimerParams_s
-{
-  L7_uint8 eventIdx;
-} snoopPtinQuerytimerParams_t;
-#define PTIN_IGMP_TIMER_MSG_SIZE  sizeof(snoopPtinQuerytimerParams_t)
-
-/* Static variables */
-static void                   *handleListMemHndl = L7_NULLPTR;
-static void                   *cbEventQueue = L7_NULLPTR;
-static void                   *timerSem = L7_NULLPTR;
-static L7_sll_t               timerLinkedList;
-static L7_uint32              cbTaskId = L7_ERROR;
-static L7_uint32              cbBufferPoolId = 0;
-static handle_list_t          *handleList;
-static L7_APP_TMR_CTRL_BLK_t  cbTimer;
-
-/* Static methods */
-static void     cbEventqueueTask(void);
-static void     cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData);
-static L7_RC_t  timerDataDestroy(L7_sll_member_t *ll_member);
-static L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key);
-static void     timerCallback(void *param);
-
-
-/*********************************************************************
-* @purpose  Start Snooping task
-*
-* @param    none
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    none
-*
-* @end
-*********************************************************************/
-L7_RC_t snoop_ptin_querytimer_init(void)
-{
-   /* Create queue semaphore */
-   timerSem = osapiSemaBCreate(OSAPI_SEM_Q_FIFO, OSAPI_SEM_FULL);
-   if (timerSem == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to create timers_sem semaphore!");
-     return L7_FAILURE;
-   }
-
-   /* Queue that will process timer events */
-   cbEventQueue = (void *) osapiMsgQueueCreate("cb_event_queue_querytimer", TIMER_COUNT, PTIN_IGMP_TIMER_MSG_SIZE);
-   if (cbEventQueue == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"cb_event_queue creation error.");
-     return L7_FAILURE;
-   }
-
-   /* Create task for querytimer management */
-   cbTaskId = osapiTaskCreate("ptin_igmp_querytimer_task", cbEventqueueTask, 0, 0,
-                                         L7_DEFAULT_STACK_SIZE,
-                                         L7_TASK_PRIORITY_LEVEL(L7_DEFAULT_TASK_PRIORITY),
-                                         L7_DEFAULT_TASK_SLICE);
-   if (cbTaskId == L7_ERROR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR, "Could not create task ptin_igmp_querytimer_task");
-     return L7_FAILURE;
-   }
-   if (osapiWaitForTaskInit (L7_PTIN_IGMP_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to initialize ptin_igmp_querytimer_task");
-     return(L7_FAILURE);
-   }
-
-   /* Create CB buffer pool */
-   cbBufferPoolId = 0;
-   if(bufferPoolInit(TIMER_COUNT,
-                     sizeof(timerNode_t) /*L7_APP_TMR_NODE_SIZE*/,
-                     "PTin_IGMP_CB_QueryTimer_Buffer",
-                     &cbBufferPoolId) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to allocate memory for IGMP Control Block timer buffers");
-     return L7_FAILURE;
-   }
-
-   /* Create SLL list for each IGMP instance */
-   if (SLLCreate(L7_PTIN_COMPONENT_ID, L7_SLL_NO_ORDER,
-                sizeof(L7_uint32)*2, timerDataCmp, timerDataDestroy,
-                &timerLinkedList) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Failed to create timer linked list");
-     return L7_FAILURE;
-   }
-
-   /* Allocate memory for the Handle List */
-   handleListMemHndl = (handle_member_t*) osapiMalloc(L7_PTIN_COMPONENT_ID, TIMER_COUNT*sizeof(handle_member_t));
-   if (handleListMemHndl == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Error allocating Handle List Buffers");
-     return L7_FAILURE;
-   }
-
-   /* Create timers handle list for this IGMP instance  */
-   if(handleListInit(L7_PTIN_COMPONENT_ID, TIMER_COUNT, &handleList, handleListMemHndl) != L7_SUCCESS)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to create timer handle list");
-     return L7_FAILURE;
-   }
-
-   /* Initialize timer control blocks */
-   cbTimer = appTimerInit(L7_PTIN_COMPONENT_ID, (void *) cbtimerCallback,
-                          L7_NULLPTR, L7_APP_TMR_1SEC,
-                          cbBufferPoolId);
-   if (cbTimer  == L7_NULLPTR)
-   {
-     PT_LOG_FATAL(LOG_CTX_CNFGR,"snoopEntry App Timer Initialization Failed.");
-     return L7_FAILURE;
-   }
-
-   PT_LOG_TRACE(LOG_CTX_CNFGR,"Initializations for IGMPv3 source timers finished");
-
-  return(L7_SUCCESS);
-}
-
-/*********************************************************************
-* @purpose  Stop Snooping task
-*
-* @param    none
-*
-* @returns  L7_SUCCESS
-* @returns  L7_FAILURE
-*
-* @notes    none
-*
-* @end
-*********************************************************************/
-L7_RC_t snoop_ptin_querytimer_deinit(void)
-{
-  /* Deinitialize timer control blocks */
-  if (cbTimer != (L7_APP_TMR_CTRL_BLK_t) NULL)
-  {
-    appTimerDeInit(cbTimer);
-    cbTimer = (L7_APP_TMR_CTRL_BLK_t) NULL;
-  }
-
-  /* Remove timers handle list for this IGMP instance  */
-  handleListDeinit(L7_PTIN_COMPONENT_ID, handleList);
-
-  /* Free memory for the Handle List */
-  if (handleListMemHndl != L7_NULLPTR)
-  {
-    osapiFree(L7_PTIN_COMPONENT_ID, handleListMemHndl);
-    handleListMemHndl = L7_NULLPTR;
-  }
-
-  /* Destroy SLL list for each IGMP instance */
-  SLLDestroy(L7_PTIN_COMPONENT_ID, &timerLinkedList);
-
-  /* Buffer pool termination */
-  if (cbBufferPoolId != 0)
-  {
-    bufferPoolTerminate(cbBufferPoolId);
-    cbBufferPoolId = 0;
-  }
-
-  /* Delete task for querytimer management */
-  if ( cbTaskId != L7_ERROR )
-  {
-    osapiTaskDelete(cbTaskId);
-    cbTaskId = L7_ERROR;
-  }
-
-  /* Queue that will process timer events */
-  if (cbEventQueue != L7_NULLPTR)
-  {
-    osapiMsgQueueDelete(cbEventQueue);
-    cbEventQueue = L7_NULLPTR;
-  }
-
-  osapiSemaDelete(timerSem);
-  timerSem = L7_NULLPTR;
-
-  return(L7_SUCCESS);
-}
-
-/*********************************************************************
-* @purpose   This function is used to send timer events
-*
-* @param     timerCtrlBlk    @b{(input)}   Timer Control Block
-* @param     ptrData         @b{(input)}   Ptr to passed data
-*
-* @returns   None
-*
-* @notes     None
-* @end
-*********************************************************************/
-void cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData)
-{
-  snoopPtinQuerytimerParams_t msg = {0};
-  L7_RC_t                      rc;
-
-  rc = osapiMessageSend(cbEventQueue, &msg, PTIN_IGMP_TIMER_MSG_SIZE, L7_NO_WAIT,L7_MSG_PRIORITY_NORM);
-  if (rc != L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Querytimer timer tick send failed");
-    return;
-  }
-}
-
-/*************************************************************************
-* @purpose Task that makes the timer processing for the querytimer
-*          management 
-*  
-* @param    none
-*
-* @notes    none
-* @end
-*************************************************************************/
-void cbEventqueueTask(void)
-{
-  L7_uint32                    status;
-  snoopPtinQuerytimerParams_t msg;
-
-  if (osapiTaskInitDone(L7_PTIN_IGMP_TASK_SYNC)!=L7_SUCCESS)
-  {
-    PT_LOG_FATAL(LOG_CTX_SSM, "Error syncing task");
-    PTIN_CRASH();
-  }
-
-  while (1)
-  {
-    status = (L7_uint32) osapiMessageReceive(cbEventQueue, (void*)&msg,
-                                             PTIN_IGMP_TIMER_MSG_SIZE, L7_WAIT_FOREVER);
-    if (status == L7_SUCCESS)
-    {
-        appTimerProcess(cbTimer);
-    }
-    else
-    {
-      PT_LOG_ERR(LOG_CTX_IGMP,"This is an invalid event");
-    }
-  }
-}
-
-/*************************************************************************
-* @purpose  Helper API to compare two querytimer nodes and return the result
-*
-* @param     p  @b{(input)}  Pointer to Candidate 1 for comparison
-* @param     q  @b{(input)}  Pointer to Candidate 2 for comparison
-*
-* @returns   0   p = q
-* @returns  -1   p < q
-* @returns  +1   p > q
-*
-* @comments This is called by SLL library when nodes are compared
-*
-* @end
-*************************************************************************/
-L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key)
-{
-  L7_inet_addr_t pMcastGroupAddr, qMcastGroupAddr;
-  L7_uint32 pVlanId, pInterfaceIdx, qVlanId, qInterfaceIdx;
-
-  pMcastGroupAddr = ((snoopPTinL3Sourcetimer_t *) p)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
-  pVlanId         = ((snoopPTinL3Sourcetimer_t *) p)->groupData->snoopPTinL3InfoDataKey.vlanId;
-  pInterfaceIdx   = ((snoopPTinL3Sourcetimer_t *) p)->interfaceIdx;
-
-  qMcastGroupAddr = ((snoopPTinL3Sourcetimer_t *) q)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
-  qVlanId         = ((snoopPTinL3Sourcetimer_t *) q)->groupData->snoopPTinL3InfoDataKey.vlanId;
-  qInterfaceIdx   = ((snoopPTinL3Sourcetimer_t *) q)->interfaceIdx;
-
-  if ( L7_INET_ADDR_COMPARE(&pMcastGroupAddr,&qMcastGroupAddr)==0 && 
-       pVlanId         == qVlanId         &&
-       pInterfaceIdx   == qInterfaceIdx )
-    return 0;
-
-  return 1;
-}
-
-/*************************************************************************
-* @purpose  API to destroy the querytimer data node
-*
-* @param    ll_member  @b{(input)}  Linked list node containing the
-*                                   timer to be destroyed
-*
-* @returns  L7_SUCCESS
-*
-* @comments This is called by SLL library when a node is being deleted
-*
-* @end
-*************************************************************************/
-L7_RC_t timerDataDestroy (L7_sll_member_t *ll_member)
-{
-  snoopPTinL3Querytimer_t *pTimerData;
-
-  /* Validate argument */
-  if (ll_member==L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
-    return L7_FAILURE;
-  }
-
-  pTimerData = (snoopPTinL3Querytimer_t *)ll_member;
-
-  /* Destroy timer */
-  if (pTimerData->timer != L7_NULL)
-  {
-    /* Delete the apptimer node */
-    if (appTimerDelete(cbTimer, pTimerData->timer)!=L7_SUCCESS)
-    {
-      PT_LOG_NOTICE(LOG_CTX_IGMP,"Cannot delete timer");
-    }
-    pTimerData->timer = (L7_APP_TMR_HNDL_t) NULL;
-
-    /* Delete the handle we had created */
-    handleListNodeDelete(handleList, &pTimerData->timerHandle);
-    pTimerData->timerHandle = 0;
-  }
-
-  return L7_SUCCESS;
-}
-
-/*************************************************************************
- * @purpose Callback method that is called when the querytimer expires.
- *
- * @param   param  Timer Handle
- *
- *************************************************************************/
-void timerCallback(void *param)
-{
-  char                    debug_buf[46];
-  snoopPTinL3Interface_t  *interfacePtr;
-  L7_uint32               interfaceIdx;
-  L7_uint32               timerHandle;
-  snoopPTinL3Querytimer_t *pTimerData;
-  snoopPTinL3Source_t     *sourcePtr;
-  snoopPTinL3InfoData_t*  groupData;
-
-  timerHandle = (L7_uint32) param;
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Get timer handler */
-  pTimerData = (snoopPTinL3Querytimer_t*) handleListNodeRetrieve(timerHandle);
-  if (pTimerData == L7_NULLPTR)
-  {
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Failed to retrieve handle");
-    osapiSemaGive(timerSem);
-    return;
-  }
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Querytimer expired (group:%s vlan:%u ifId:%u)", 
-            inetAddrPrint(&(pTimerData->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), pTimerData->groupData->snoopPTinL3InfoDataKey.vlanId, pTimerData->interfaceIdx);
-
-  /* Check if our handle is OK*/
-  if (timerHandle != pTimerData->timerHandle)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"timerHandle and pTimerData->timerHandle do not match!");
-    return;
-  }
-
-  //Save grouptimer's internal data
-  groupData    = pTimerData->groupData;
-  interfaceIdx = pTimerData->interfaceIdx;
-
-  /* Remove node for SLL list */
-  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimerData) != L7_SUCCESS)
-  {
-    osapiSemaGive(timerSem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node");
-    return;
-  }
-  osapiSemaGive(timerSem);
-
-  /* Sourcetimer triggers only affect groups in filter-mode EXCLUDE */
-  interfacePtr = &groupData->interfaces[interfaceIdx];
-  sourcePtr    = L7_NULLPTR;
-  if (interfacePtr->filtermode == PTIN_SNOOP_FILTERMODE_EXCLUDE)
-  {
-    L7_uint32 i;
-
-    /* Remove every source whose timer has expired */
-    for (i = 0; i < PTIN_SYSTEM_IGMP_MAXSOURCES_PER_GROUP; ++i)
-    {
-      sourcePtr = &interfacePtr->sources[i];
-      if (sourcePtr->sourceTimer.isRunning == L7_FALSE)
-      {
-        PT_LOG_DEBUG(LOG_CTX_IGMP,"Removing sourceIdx %u", i);
-        snoopPTinSourceRemove(interfacePtr, sourcePtr);
-      }
-    }
-
-    /* If no sources remain, remove group. Otherwise, switch to filter-mode INCLUDE */
-    if (interfacePtr->numberOfSources == 0)
-    {
-      PT_LOG_DEBUG(LOG_CTX_IGMP,"Removing interface");
-      snoopPTinInterfaceRemove(interfacePtr,pTimerData->groupData->snoopPTinL3InfoDataKey.vlanId,&(pTimerData->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr),pTimerData->interfaceIdx);
-    }
-    else
-    {
-      interfacePtr->filtermode = PTIN_SNOOP_FILTERMODE_INCLUDE;
-    }
-  }
-}
-
-/*************************************************************************
- * @purpose Start a querytimer
- * 
- * @param   pTimer          Pointer to timer
- * @param   timeout         Timer's timeout
- * @param   groupData       Pointer to multicast group data
- * @param   interfaceIdx    Interface index
- *
- * @returns L7_SUCCESS
- * @returns L7_FAILURE
- *
- *************************************************************************/
-L7_RC_t snoop_ptin_querytimer_start(snoopPTinL3Querytimer_t *pTimer, L7_uint16 timeout, snoopPTinL3InfoData_t* groupData, L7_uint32 interfaceIdx)
-{
-  L7_BOOL                 restart_timer = L7_FALSE;
-  snoopPTinL3Querytimer_t pTimerData;
-  char                    debug_buf[46];
-
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR || groupData == L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
-    return L7_FAILURE;
-  }
-
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Check if this timer already exists */
-  memset(&pTimerData, 0x00, sizeof(pTimerData));
-  pTimerData.groupData     = groupData;
-  pTimerData.interfaceIdx  = interfaceIdx;
-  if (SLLFind(&timerLinkedList, (void *)&pTimerData) != L7_NULL)
-  {
-    restart_timer = L7_TRUE;
-    if (appTimerDelete(cbTimer, (void *) pTimer->timer) != L7_SUCCESS)
-    {
-      osapiSemaGive(timerSem);
-      PT_LOG_ERR(LOG_CTX_IGMP,"Failed restarting timer");
-      return L7_FAILURE;
-    }
-    pTimer->timer = L7_NULLPTR;
-
-    /* Remove timer handle */
-    handleListNodeDelete(handleList, &pTimer->timerHandle);
-    pTimer->timerHandle = 0;
-  }
-  else 
-  {
-    pTimer->groupData    = groupData;
-    pTimer->interfaceIdx = interfaceIdx;
-  }
-
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Starting querytimer (group:%s vlan:%u ifIdx:%u)",
-            inetAddrPrint(&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), groupData->snoopPTinL3InfoDataKey.vlanId, interfaceIdx);
-
-  /* New timer handle */
-  if ((pTimer->timerHandle = handleListNodeStore(handleList, pTimer)) == 0)
-  {
-    osapiSemaGive(timerSem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
-    return L7_FAILURE;
-  }
-
-  /* Add a new timer */
-  pTimer->timer = appTimerAdd(cbTimer, timerCallback,
-                              (void *) pTimer->timerHandle, timeout,
-                              "PTIN_TIMER");
-  if (pTimer->timer == NULL)
-  {
-    handleListNodeDelete(handleList, &pTimer->timerHandle);
-    pTimer->timerHandle = 0;
-    osapiSemaGive(timerSem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Could not start the querytimer.");
-    return L7_FAILURE;
-  }
-
-  /* Add timer to SLL */
-  if (!restart_timer && (SLLAdd(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS))
-  {
-    if (appTimerDelete(cbTimer, pTimer->timer) != L7_SUCCESS)
-    {
-      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
-    }
-    pTimer->timer = L7_NULLPTR;
-    handleListNodeDelete(handleList, &pTimer->timerHandle);
-    pTimer->timerHandle = 0;
-    osapiSemaGive(timerSem);
-    PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
-    return L7_FAILURE;
-  }
-
-  osapiSemaGive(timerSem);
-  return L7_SUCCESS;
-}
-
-/*************************************************************************
- * @purpose Stop a querytimer
- * 
- * @param   pTimer  Pointer to timer
- *
- * @returns L7_SUCCESS
- * @returns L7_FAILURE
- *
- *************************************************************************/
-L7_RC_t snoop_ptin_querytimer_stop(snoopPTinL3Querytimer_t *pTimer)
-{
-  char debug_buf[46];
-
-  /* Argument validation */
-  if (pTimer == L7_NULLPTR)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
-    return L7_FAILURE;
-  }
-
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Stopping querytimer (group:%s vlan:%u ifIdx:%u)",
-            inetAddrPrint(&(pTimer->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), pTimer->groupData->snoopPTinL3InfoDataKey.vlanId, pTimer->interfaceIdx);
-
-  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
-
-  /* Remove node for SLL list */
-  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS)
-  {
-    osapiSemaGive(timerSem);
-    PT_LOG_NOTICE(LOG_CTX_IGMP,"Failed to delete timer node");
-    return L7_FAILURE;
-  }
-
-  osapiSemaGive(timerSem);
-
-  return L7_SUCCESS;
-}
+/*
+ * ptin_igmp_querytimer.c
+ *
+ *  Created on: 22 de Abr de 2013
+ *      Author: Daniel Figueira
+ */
+
+#include "snooping_ptin_querytimer.h"
+#include "snooping_ptin_util.h"
+#include "snooping_db.h"
+#include "snooping_ptin_db.h"
+
+#include <unistd.h>
+
+#define TIMER_COUNT 1
+
+/* Message placed in CB queue */
+typedef struct snoopPtinQuerytimerParams_s
+{
+  L7_uint8 eventIdx;
+} snoopPtinQuerytimerParams_t;
+#define PTIN_IGMP_TIMER_MSG_SIZE  sizeof(snoopPtinQuerytimerParams_t)
+
+/* Static variables */
+static void                   *handleListMemHndl = L7_NULLPTR;
+static void                   *cbEventQueue = L7_NULLPTR;
+static void                   *timerSem = L7_NULLPTR;
+static L7_sll_t               timerLinkedList;
+static L7_uint32              cbTaskId = L7_ERROR;
+static L7_uint32              cbBufferPoolId = 0;
+static handle_list_t          *handleList;
+static L7_APP_TMR_CTRL_BLK_t  cbTimer;
+
+/* Static methods */
+static void     cbEventqueueTask(void);
+static void     cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData);
+static L7_RC_t  timerDataDestroy(L7_sll_member_t *ll_member);
+static L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key);
+static void     timerCallback(void *param);
+
+
+/*********************************************************************
+* @purpose  Start Snooping task
+*
+* @param    none
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    none
+*
+* @end
+*********************************************************************/
+L7_RC_t snoop_ptin_querytimer_init(void)
+{
+   /* Create queue semaphore */
+   timerSem = osapiSemaBCreate(OSAPI_SEM_Q_FIFO, OSAPI_SEM_FULL);
+   if (timerSem == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to create timers_sem semaphore!");
+     return L7_FAILURE;
+   }
+
+   /* Queue that will process timer events */
+   cbEventQueue = (void *) osapiMsgQueueCreate("cb_event_queue_querytimer", TIMER_COUNT, PTIN_IGMP_TIMER_MSG_SIZE);
+   if (cbEventQueue == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"cb_event_queue creation error.");
+     return L7_FAILURE;
+   }
+
+   /* Create task for querytimer management */
+   cbTaskId = osapiTaskCreate("ptin_igmp_querytimer_task", cbEventqueueTask, 0, 0,
+                                         L7_DEFAULT_STACK_SIZE,
+                                         L7_TASK_PRIORITY_LEVEL(L7_DEFAULT_TASK_PRIORITY),
+                                         L7_DEFAULT_TASK_SLICE);
+   if (cbTaskId == L7_ERROR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR, "Could not create task ptin_igmp_querytimer_task");
+     return L7_FAILURE;
+   }
+   if (osapiWaitForTaskInit (L7_PTIN_IGMP_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to initialize ptin_igmp_querytimer_task");
+     return(L7_FAILURE);
+   }
+
+   /* Create CB buffer pool */
+   cbBufferPoolId = 0;
+   if(bufferPoolInit(TIMER_COUNT,
+                     sizeof(timerNode_t) /*L7_APP_TMR_NODE_SIZE*/,
+                     "PTin_IGMP_CB_QueryTimer_Buffer",
+                     &cbBufferPoolId) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR, "Failed to allocate memory for IGMP Control Block timer buffers");
+     return L7_FAILURE;
+   }
+
+   /* Create SLL list for each IGMP instance */
+   if (SLLCreate(L7_PTIN_COMPONENT_ID, L7_SLL_NO_ORDER,
+                sizeof(L7_uint32)*2, timerDataCmp, timerDataDestroy,
+                &timerLinkedList) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Failed to create timer linked list");
+     return L7_FAILURE;
+   }
+
+   /* Allocate memory for the Handle List */
+   handleListMemHndl = (handle_member_t*) osapiMalloc(L7_PTIN_COMPONENT_ID, TIMER_COUNT*sizeof(handle_member_t));
+   if (handleListMemHndl == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Error allocating Handle List Buffers");
+     return L7_FAILURE;
+   }
+
+   /* Create timers handle list for this IGMP instance  */
+   if(handleListInit(L7_PTIN_COMPONENT_ID, TIMER_COUNT, &handleList, handleListMemHndl) != L7_SUCCESS)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"Unable to create timer handle list");
+     return L7_FAILURE;
+   }
+
+   /* Initialize timer control blocks */
+   cbTimer = appTimerInit(L7_PTIN_COMPONENT_ID, (void *) cbtimerCallback,
+                          L7_NULLPTR, L7_APP_TMR_1SEC,
+                          cbBufferPoolId);
+   if (cbTimer  == L7_NULLPTR)
+   {
+     PT_LOG_FATAL(LOG_CTX_CNFGR,"snoopEntry App Timer Initialization Failed.");
+     return L7_FAILURE;
+   }
+
+   PT_LOG_TRACE(LOG_CTX_CNFGR,"Initializations for IGMPv3 source timers finished");
+
+  return(L7_SUCCESS);
+}
+
+/*********************************************************************
+* @purpose  Stop Snooping task
+*
+* @param    none
+*
+* @returns  L7_SUCCESS
+* @returns  L7_FAILURE
+*
+* @notes    none
+*
+* @end
+*********************************************************************/
+L7_RC_t snoop_ptin_querytimer_deinit(void)
+{
+  /* Deinitialize timer control blocks */
+  if (cbTimer != (L7_APP_TMR_CTRL_BLK_t) NULL)
+  {
+    appTimerDeInit(cbTimer);
+    cbTimer = (L7_APP_TMR_CTRL_BLK_t) NULL;
+  }
+
+  /* Remove timers handle list for this IGMP instance  */
+  handleListDeinit(L7_PTIN_COMPONENT_ID, handleList);
+
+  /* Free memory for the Handle List */
+  if (handleListMemHndl != L7_NULLPTR)
+  {
+    osapiFree(L7_PTIN_COMPONENT_ID, handleListMemHndl);
+    handleListMemHndl = L7_NULLPTR;
+  }
+
+  /* Destroy SLL list for each IGMP instance */
+  SLLDestroy(L7_PTIN_COMPONENT_ID, &timerLinkedList);
+
+  /* Buffer pool termination */
+  if (cbBufferPoolId != 0)
+  {
+    bufferPoolTerminate(cbBufferPoolId);
+    cbBufferPoolId = 0;
+  }
+
+  /* Delete task for querytimer management */
+  if ( cbTaskId != L7_ERROR )
+  {
+    osapiTaskDelete(cbTaskId);
+    cbTaskId = L7_ERROR;
+  }
+
+  /* Queue that will process timer events */
+  if (cbEventQueue != L7_NULLPTR)
+  {
+    osapiMsgQueueDelete(cbEventQueue);
+    cbEventQueue = L7_NULLPTR;
+  }
+
+  osapiSemaDelete(timerSem);
+  timerSem = L7_NULLPTR;
+
+  return(L7_SUCCESS);
+}
+
+/*********************************************************************
+* @purpose   This function is used to send timer events
+*
+* @param     timerCtrlBlk    @b{(input)}   Timer Control Block
+* @param     ptrData         @b{(input)}   Ptr to passed data
+*
+* @returns   None
+*
+* @notes     None
+* @end
+*********************************************************************/
+void cbtimerCallback(L7_APP_TMR_CTRL_BLK_t timerCtrlBlk, void* ptrData)
+{
+  snoopPtinQuerytimerParams_t msg = {0};
+  L7_RC_t                      rc;
+
+  rc = osapiMessageSend(cbEventQueue, &msg, PTIN_IGMP_TIMER_MSG_SIZE, L7_NO_WAIT,L7_MSG_PRIORITY_NORM);
+  if (rc != L7_SUCCESS)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Querytimer timer tick send failed");
+    return;
+  }
+}
+
+/*************************************************************************
+* @purpose Task that makes the timer processing for the querytimer
+*          management 
+*  
+* @param    none
+*
+* @notes    none
+* @end
+*************************************************************************/
+void cbEventqueueTask(void)
+{
+  L7_uint32                    status;
+  snoopPtinQuerytimerParams_t msg;
+
+  if (osapiTaskInitDone(L7_PTIN_IGMP_TASK_SYNC)!=L7_SUCCESS)
+  {
+    PT_LOG_FATAL(LOG_CTX_SSM, "Error syncing task");
+    PTIN_CRASH();
+  }
+
+  while (1)
+  {
+    status = (L7_uint32) osapiMessageReceive(cbEventQueue, (void*)&msg,
+                                             PTIN_IGMP_TIMER_MSG_SIZE, L7_WAIT_FOREVER);
+    if (status == L7_SUCCESS)
+    {
+        appTimerProcess(cbTimer);
+    }
+    else
+    {
+      PT_LOG_ERR(LOG_CTX_IGMP,"This is an invalid event");
+    }
+  }
+}
+
+/*************************************************************************
+* @purpose  Helper API to compare two querytimer nodes and return the result
+*
+* @param     p  @b{(input)}  Pointer to Candidate 1 for comparison
+* @param     q  @b{(input)}  Pointer to Candidate 2 for comparison
+*
+* @returns   0   p = q
+* @returns  -1   p < q
+* @returns  +1   p > q
+*
+* @comments This is called by SLL library when nodes are compared
+*
+* @end
+*************************************************************************/
+L7_int32 timerDataCmp(void *p, void *q, L7_uint32 key)
+{
+  L7_inet_addr_t pMcastGroupAddr, qMcastGroupAddr;
+  L7_uint32 pVlanId, pInterfaceIdx, qVlanId, qInterfaceIdx;
+
+  pMcastGroupAddr = ((snoopPTinL3Sourcetimer_t *) p)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
+  pVlanId         = ((snoopPTinL3Sourcetimer_t *) p)->groupData->snoopPTinL3InfoDataKey.vlanId;
+  pInterfaceIdx   = ((snoopPTinL3Sourcetimer_t *) p)->interfaceIdx;
+
+  qMcastGroupAddr = ((snoopPTinL3Sourcetimer_t *) q)->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr;
+  qVlanId         = ((snoopPTinL3Sourcetimer_t *) q)->groupData->snoopPTinL3InfoDataKey.vlanId;
+  qInterfaceIdx   = ((snoopPTinL3Sourcetimer_t *) q)->interfaceIdx;
+
+  if ( L7_INET_ADDR_COMPARE(&pMcastGroupAddr,&qMcastGroupAddr)==0 && 
+       pVlanId         == qVlanId         &&
+       pInterfaceIdx   == qInterfaceIdx )
+    return 0;
+
+  return 1;
+}
+
+/*************************************************************************
+* @purpose  API to destroy the querytimer data node
+*
+* @param    ll_member  @b{(input)}  Linked list node containing the
+*                                   timer to be destroyed
+*
+* @returns  L7_SUCCESS
+*
+* @comments This is called by SLL library when a node is being deleted
+*
+* @end
+*************************************************************************/
+L7_RC_t timerDataDestroy (L7_sll_member_t *ll_member)
+{
+  snoopPTinL3Querytimer_t *pTimerData;
+
+  /* Validate argument */
+  if (ll_member==L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"Null arguments");
+    return L7_FAILURE;
+  }
+
+  pTimerData = (snoopPTinL3Querytimer_t *)ll_member;
+
+  /* Destroy timer */
+  if (pTimerData->timer != L7_NULL)
+  {
+    /* Delete the apptimer node */
+    if (appTimerDelete(cbTimer, pTimerData->timer)!=L7_SUCCESS)
+    {
+      PT_LOG_NOTICE(LOG_CTX_IGMP,"Cannot delete timer");
+    }
+    pTimerData->timer = (L7_APP_TMR_HNDL_t) NULL;
+
+    /* Delete the handle we had created */
+    handleListNodeDelete(handleList, &pTimerData->timerHandle);
+    pTimerData->timerHandle = 0;
+  }
+
+  return L7_SUCCESS;
+}
+
+/*************************************************************************
+ * @purpose Callback method that is called when the querytimer expires.
+ *
+ * @param   param  Timer Handle
+ *
+ *************************************************************************/
+void timerCallback(void *param)
+{
+  char                    debug_buf[46];
+  snoopPTinL3Interface_t  *interfacePtr;
+  L7_uint32               interfaceIdx;
+  L7_uint32               timerHandle;
+  snoopPTinL3Querytimer_t *pTimerData;
+  snoopPTinL3Source_t     *sourcePtr;
+  snoopPTinL3InfoData_t*  groupData;
+
+  timerHandle = (L7_uint32) param;
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Get timer handler */
+  pTimerData = (snoopPTinL3Querytimer_t*) handleListNodeRetrieve(timerHandle);
+  if (pTimerData == L7_NULLPTR)
+  {
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Failed to retrieve handle");
+    osapiSemaGive(timerSem);
+    return;
+  }
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Querytimer expired (group:%s vlan:%u ifId:%u)", 
+            inetAddrPrint(&(pTimerData->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), pTimerData->groupData->snoopPTinL3InfoDataKey.vlanId, pTimerData->interfaceIdx);
+
+  /* Check if our handle is OK*/
+  if (timerHandle != pTimerData->timerHandle)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP,"timerHandle and pTimerData->timerHandle do not match!");
+    return;
+  }
+
+  //Save grouptimer's internal data
+  groupData    = pTimerData->groupData;
+  interfaceIdx = pTimerData->interfaceIdx;
+
+  /* Remove node for SLL list */
+  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimerData) != L7_SUCCESS)
+  {
+    osapiSemaGive(timerSem);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node");
+    return;
+  }
+  osapiSemaGive(timerSem);
+
+  /* Sourcetimer triggers only affect groups in filter-mode EXCLUDE */
+  interfacePtr = &groupData->interfaces[interfaceIdx];
+  sourcePtr    = L7_NULLPTR;
+  if (interfacePtr->filtermode == PTIN_SNOOP_FILTERMODE_EXCLUDE)
+  {
+    L7_uint32 i;
+
+    /* Remove every source whose timer has expired */
+    for (i = 0; i < PTIN_SYSTEM_IGMP_MAXSOURCES_PER_GROUP; ++i)
+    {
+      sourcePtr = &interfacePtr->sources[i];
+      if (sourcePtr->sourceTimer.isRunning == L7_FALSE)
+      {
+        PT_LOG_DEBUG(LOG_CTX_IGMP,"Removing sourceIdx %u", i);
+        snoopPTinSourceRemove(interfacePtr, sourcePtr);
+      }
+    }
+
+    /* If no sources remain, remove group. Otherwise, switch to filter-mode INCLUDE */
+    if (interfacePtr->numberOfSources == 0)
+    {
+      PT_LOG_DEBUG(LOG_CTX_IGMP,"Removing interface");
+      snoopPTinInterfaceRemove(interfacePtr,pTimerData->groupData->snoopPTinL3InfoDataKey.vlanId,&(pTimerData->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr),pTimerData->interfaceIdx);
+    }
+    else
+    {
+      interfacePtr->filtermode = PTIN_SNOOP_FILTERMODE_INCLUDE;
+    }
+  }
+}
+
+/*************************************************************************
+ * @purpose Start a querytimer
+ * 
+ * @param   pTimer          Pointer to timer
+ * @param   timeout         Timer's timeout
+ * @param   groupData       Pointer to multicast group data
+ * @param   interfaceIdx    Interface index
+ *
+ * @returns L7_SUCCESS
+ * @returns L7_FAILURE
+ *
+ *************************************************************************/
+L7_RC_t snoop_ptin_querytimer_start(snoopPTinL3Querytimer_t *pTimer, L7_uint16 timeout, snoopPTinL3InfoData_t* groupData, L7_uint32 interfaceIdx)
+{
+  L7_BOOL                 restart_timer = L7_FALSE;
+  snoopPTinL3Querytimer_t pTimerData;
+  char                    debug_buf[46];
+
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR || groupData == L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
+    return L7_FAILURE;
+  }
+
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Check if this timer already exists */
+  memset(&pTimerData, 0x00, sizeof(pTimerData));
+  pTimerData.groupData     = groupData;
+  pTimerData.interfaceIdx  = interfaceIdx;
+  if (SLLFind(&timerLinkedList, (void *)&pTimerData) != L7_NULL)
+  {
+    restart_timer = L7_TRUE;
+    if (appTimerDelete(cbTimer, (void *) pTimer->timer) != L7_SUCCESS)
+    {
+      osapiSemaGive(timerSem);
+      PT_LOG_ERR(LOG_CTX_IGMP,"Failed restarting timer");
+      return L7_FAILURE;
+    }
+    pTimer->timer = L7_NULLPTR;
+
+    /* Remove timer handle */
+    handleListNodeDelete(handleList, &pTimer->timerHandle);
+    pTimer->timerHandle = 0;
+  }
+  else 
+  {
+    pTimer->groupData    = groupData;
+    pTimer->interfaceIdx = interfaceIdx;
+  }
+
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Starting querytimer (group:%s vlan:%u ifIdx:%u)",
+            inetAddrPrint(&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), groupData->snoopPTinL3InfoDataKey.vlanId, interfaceIdx);
+
+  /* New timer handle */
+  if ((pTimer->timerHandle = handleListNodeStore(handleList, pTimer)) == 0)
+  {
+    osapiSemaGive(timerSem);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
+    return L7_FAILURE;
+  }
+
+  /* Add a new timer */
+  pTimer->timer = appTimerAdd(cbTimer, timerCallback,
+                              (void *) pTimer->timerHandle, timeout,
+                              "PTIN_TIMER");
+  if (pTimer->timer == NULL)
+  {
+    handleListNodeDelete(handleList, &pTimer->timerHandle);
+    pTimer->timerHandle = 0;
+    osapiSemaGive(timerSem);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Could not start the querytimer.");
+    return L7_FAILURE;
+  }
+
+  /* Add timer to SLL */
+  if (!restart_timer && (SLLAdd(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS))
+  {
+    if (appTimerDelete(cbTimer, pTimer->timer) != L7_SUCCESS)
+    {
+      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
+    }
+    pTimer->timer = L7_NULLPTR;
+    handleListNodeDelete(handleList, &pTimer->timerHandle);
+    pTimer->timerHandle = 0;
+    osapiSemaGive(timerSem);
+    PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
+    return L7_FAILURE;
+  }
+
+  osapiSemaGive(timerSem);
+  return L7_SUCCESS;
+}
+
+/*************************************************************************
+ * @purpose Stop a querytimer
+ * 
+ * @param   pTimer  Pointer to timer
+ *
+ * @returns L7_SUCCESS
+ * @returns L7_FAILURE
+ *
+ *************************************************************************/
+L7_RC_t snoop_ptin_querytimer_stop(snoopPTinL3Querytimer_t *pTimer)
+{
+  char debug_buf[46];
+
+  /* Argument validation */
+  if (pTimer == L7_NULLPTR)
+  {
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
+    return L7_FAILURE;
+  }
+
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Stopping querytimer (group:%s vlan:%u ifIdx:%u)",
+            inetAddrPrint(&(pTimer->groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), pTimer->groupData->snoopPTinL3InfoDataKey.vlanId, pTimer->interfaceIdx);
+
+  osapiSemaTake(timerSem, L7_WAIT_FOREVER);
+
+  /* Remove node for SLL list */
+  if (SLLDelete(&timerLinkedList, (L7_sll_member_t *)pTimer) != L7_SUCCESS)
+  {
+    osapiSemaGive(timerSem);
+    PT_LOG_NOTICE(LOG_CTX_IGMP,"Failed to delete timer node");
+    return L7_FAILURE;
+  }
+
+  osapiSemaGive(timerSem);
+
+  return L7_SUCCESS;
+}
Index: src/l7public/common/ptin/logger.h
===================================================================
--- src/l7public/common/ptin/logger.h	(revision 7370)
+++ src/l7public/common/ptin/logger.h	(revision 7371)
@@ -1,223 +1,223 @@
-/**
- * logger.h 
- *  
- * Provides logging features 
- *  
- * Created on: 2011/06/18 
- * Author:     Alexandre Santos (alexandre-r-santos@ptinovacao.pt) 
- *  
- * Notes: 
- */
-
-#ifndef _LOGGER_H
-#define _LOGGER_H
-
-#include <stdio.h>
-
-typedef enum {
-  LOG_OUTPUT_DEFAULT=0,
-  LOG_OUTPUT_STDERR,
-  LOG_OUTOUT_STDOUT,
-  LOG_OUTPUT_FILE,
-  LOG_OUTPUT_FILE2,
-  LOG_OUTPUT_FILE3,
-  LOG_OUTPUT_MAX,
-  LOG_OUTPUT_UNINIT=0xff
-}log_output_t;
-
-/* Context
- * NOTE: new items must be added to default config (log_cfg[])* 
- *       and to log_ctx_str[] !!! */
-typedef enum {
-    LOG_CTX_LOGGER = 0,       /* Used to log logger config functions */
-    LOG_CTX_IPC,
-    LOG_CTX_MSGHANDLER,
-    LOG_CTX_MSG,
-    LOG_CTX_INTF,
-    LOG_CTX_TRUNKS,
-    LOG_CTX_HAPI,
-    LOG_CTX_DTL,
-    LOG_CTX_L2,
-    LOG_CTX_XLATE,
-    LOG_CTX_API,
-    LOG_CTX_EVC,
-    LOG_CTX_CONTROL,
-    LOG_CTX_IGMP,
-    LOG_CTX_DHCP,
-    LOG_CTX_PPPOE,
-    LOG_CTX_PROTB,
-    LOG_CTX_ROUTING,
-    LOG_CTX_SSM,
-    LOG_CTX_PACKET,
-    LOG_CTX_CNFGR,
-    LOG_CTX_MISC,             /* Used on exceptional situations */
-    LOG_CTX_OAM,
-    LOG_CTX_ERPS,
-    LOG_CTX_IPSG,
-    LOG_CTX_DAI,
-    LOG_CTX_RFC2819,
-    LOG_CTX_EVENTS,
-    LOG_CTX_SDK,
-    LOG_CTX_STARTUP,
-    LOG_CTX_OPENSAF,
-    /* Last element */
-    LOG_CONTEXT_LAST,
-} log_context_t;
-
-/* Colors list */
-typedef enum {
-    LOG_COLOR_DEFAULT = 0,
-    /* Normal */
-    LOG_COLOR_BLACK,
-    LOG_COLOR_RED,
-    LOG_COLOR_GREEN,
-    LOG_COLOR_YELLOW,
-    LOG_COLOR_BLUE,
-    LOG_COLOR_MAGENTA,
-    LOG_COLOR_CYAN,
-    LOG_COLOR_WHITE,
-    /* Bright */
-    LOG_BRIGHT_BLACK,
-    LOG_BRIGHT_RED,
-    LOG_BRIGHT_GREEN,
-    LOG_BRIGHT_YELLOW,
-    LOG_BRIGHT_BLUE,
-    LOG_BRIGHT_MAGENTA,
-    LOG_BRIGHT_CYAN,
-    LOG_BRIGHT_WHITE,
-    /* Dark */
-    LOG_DARK_BLACK,
-    LOG_DARK_RED,
-    LOG_DARK_GREEN,
-    LOG_DARK_YELLOW,
-    LOG_DARK_BLUE,
-    LOG_DARK_MAGENTA,
-    LOG_DARK_CYAN,
-    LOG_DARK_WHITE,
-    /* Last element */
-    LOG_COLOR_LAST,
-} log_color_t;
-
-/* Severity */
-typedef enum {
-    LOG_OFF = 0,        /* Turn of any print */
-    LOG_SEV_PRINT,      /* Always print */
-    LOG_SEV_FATAL,
-    LOG_SEV_CRITICAL,
-    LOG_SEV_ERROR,
-    LOG_SEV_WARNING,
-    LOG_SEV_NOTICE,
-    LOG_SEV_INFO,
-    LOG_SEV_DEBUG,
-    LOG_SEV_TRACE,
-    /* Last element */
-    LOG_SEV_LAST,
-} log_severity_t;
-
-/* Log configuration entry */
-struct log_cfg_entry_s {
-    log_context_t   context;
-    log_severity_t  severity;
-    log_color_t     color;
-    log_output_t    output;
-};
-
-/**
- * Initialize logger
- * 
- * @param default_output : type of output
- */
-extern void logger_init(log_output_t default_output);
-
-/**
- * Deinitialize logger
- */
-extern void logger_deinit(void);
-
-/**
- * Initialize stream descriptors for each output type
- * 
- * @param output : type of output
- */
-extern void logger_output_file_set(log_output_t output, char *filename);
-
-/**
- * Redirect logger to a specific file
- *  
- * @param output : type of output
- * @param output_file_path : path and file name
- */
-extern void logger_redirect(log_output_t output, char* output_file_path);
-
-/**
- * Log help
- */
-extern void logger_help(void);
-
-/**
- * Sets severity level for a group of contexts
- * 
- * @param ctx_mask bitmap that defines which contexts are affected 
- * (bit position corresponds to the context index) 
- * @param sev severity threshold
- * 
- * @return int Zero if OK, otherwise means error
- */
-extern int logger_sev_set(unsigned int ctx_mask, int sev);
-
-/**
- * Sets a color for a group of contexts
- * 
- * @param ctx_mask bitmap that defines which contexts are affected 
- * (bit position corresponds to the context index) 
- * @param color color array index of desired color (log_color_t)
- * 
- * @return int Zero if OK, otherwise means error
- */
-extern int logger_color_set(unsigned int ctx_mask, int color);
-
-
-/**
- * Prints a log message
- * 
- * @param ctx  Context
- * @param sev  Severity
- * @param file Filename (can be NULL)
- * @param func Function name (can be NULL)
- * @param line Line# (if zero, is ignored)
- * @param fmt  Format string+ arguments (like printf)
- */
-extern int logger_check(log_context_t ctx, log_severity_t sev);
-extern int logger_print(log_context_t ctx, log_severity_t sev, char const *file,
-                        char const *func, int line, char const *fmt, ...);
-
-
-#define PT_LOG_TRACE(ctx , fmt , args... ) \
-    (logger_check(ctx, LOG_SEV_TRACE   ) ? logger_print(ctx, LOG_SEV_TRACE   , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
-    
-#define PT_LOG_DEBUG(ctx , fmt , args... ) \
-    (logger_check(ctx, LOG_SEV_DEBUG   ) ? logger_print(ctx, LOG_SEV_DEBUG   , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
-    
-#define PT_LOG_INFO(ctx , fmt , args... ) \
-    (logger_check(ctx, LOG_SEV_INFO    ) ? logger_print(ctx, LOG_SEV_INFO    , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
-    
-#define PT_LOG_NOTICE(ctx , fmt , args... ) \
-    (logger_check(ctx, LOG_SEV_NOTICE  ) ? logger_print(ctx, LOG_SEV_NOTICE  , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
-    
-#define PT_LOG_WARN(ctx , fmt , args... ) \
-    (logger_check(ctx, LOG_SEV_WARNING ) ? logger_print(ctx, LOG_SEV_WARNING , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
-    
-#define PT_LOG_ERR(ctx , fmt , args... ) \
-    (logger_check(ctx, LOG_SEV_ERROR   ) ? logger_print(ctx, LOG_SEV_ERROR   , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
-    
-#define PT_LOG_CRITIC(ctx , fmt , args... ) \
-    (logger_check(ctx, LOG_SEV_CRITICAL) ? logger_print(ctx, LOG_SEV_CRITICAL, NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
-    
-#define PT_LOG_FATAL(ctx , fmt , args... ) \
-    (logger_check(ctx, LOG_SEV_FATAL   ) ? logger_print(ctx, LOG_SEV_FATAL   , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
-
-#define PT_LOG_PRINT(ctx , fmt , args... ) \
-    (logger_check(ctx, LOG_SEV_PRINT   ) ? logger_print(ctx, LOG_SEV_PRINT   , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
-    
-
-#endif /* _LOGGER_H */
+/**
+ * logger.h 
+ *  
+ * Provides logging features 
+ *  
+ * Created on: 2011/06/18 
+ * Author:     Alexandre Santos (alexandre-r-santos@ptinovacao.pt) 
+ *  
+ * Notes: 
+ */
+
+#ifndef _LOGGER_H
+#define _LOGGER_H
+
+#include <stdio.h>
+
+typedef enum {
+  LOG_OUTPUT_DEFAULT=0,
+  LOG_OUTPUT_STDERR,
+  LOG_OUTOUT_STDOUT,
+  LOG_OUTPUT_FILE,
+  LOG_OUTPUT_FILE2,
+  LOG_OUTPUT_FILE3,
+  LOG_OUTPUT_MAX,
+  LOG_OUTPUT_UNINIT=0xff
+}log_output_t;
+
+/* Context
+ * NOTE: new items must be added to default config (log_cfg[])* 
+ *       and to log_ctx_str[] !!! */
+typedef enum {
+    LOG_CTX_LOGGER = 0,       /* Used to log logger config functions */
+    LOG_CTX_IPC,
+    LOG_CTX_MSGHANDLER,
+    LOG_CTX_MSG,
+    LOG_CTX_INTF,
+    LOG_CTX_TRUNKS,
+    LOG_CTX_HAPI,
+    LOG_CTX_DTL,
+    LOG_CTX_L2,
+    LOG_CTX_XLATE,
+    LOG_CTX_API,
+    LOG_CTX_EVC,
+    LOG_CTX_CONTROL,
+    LOG_CTX_IGMP,
+    LOG_CTX_DHCP,
+    LOG_CTX_PPPOE,
+    LOG_CTX_PROTB,
+    LOG_CTX_ROUTING,
+    LOG_CTX_SSM,
+    LOG_CTX_PACKET,
+    LOG_CTX_CNFGR,
+    LOG_CTX_MISC,             /* Used on exceptional situations */
+    LOG_CTX_OAM,
+    LOG_CTX_ERPS,
+    LOG_CTX_IPSG,
+    LOG_CTX_DAI,
+    LOG_CTX_RFC2819,
+    LOG_CTX_EVENTS,
+    LOG_CTX_SDK,
+    LOG_CTX_STARTUP,
+    LOG_CTX_OPENSAF,
+    /* Last element */
+    LOG_CONTEXT_LAST,
+} log_context_t;
+
+/* Colors list */
+typedef enum {
+    LOG_COLOR_DEFAULT = 0,
+    /* Normal */
+    LOG_COLOR_BLACK,
+    LOG_COLOR_RED,
+    LOG_COLOR_GREEN,
+    LOG_COLOR_YELLOW,
+    LOG_COLOR_BLUE,
+    LOG_COLOR_MAGENTA,
+    LOG_COLOR_CYAN,
+    LOG_COLOR_WHITE,
+    /* Bright */
+    LOG_BRIGHT_BLACK,
+    LOG_BRIGHT_RED,
+    LOG_BRIGHT_GREEN,
+    LOG_BRIGHT_YELLOW,
+    LOG_BRIGHT_BLUE,
+    LOG_BRIGHT_MAGENTA,
+    LOG_BRIGHT_CYAN,
+    LOG_BRIGHT_WHITE,
+    /* Dark */
+    LOG_DARK_BLACK,
+    LOG_DARK_RED,
+    LOG_DARK_GREEN,
+    LOG_DARK_YELLOW,
+    LOG_DARK_BLUE,
+    LOG_DARK_MAGENTA,
+    LOG_DARK_CYAN,
+    LOG_DARK_WHITE,
+    /* Last element */
+    LOG_COLOR_LAST,
+} log_color_t;
+
+/* Severity */
+typedef enum {
+    LOG_OFF = 0,        /* Turn of any print */
+    LOG_SEV_PRINT,      /* Always print */
+    LOG_SEV_FATAL,
+    LOG_SEV_CRITICAL,
+    LOG_SEV_ERROR,
+    LOG_SEV_WARNING,
+    LOG_SEV_NOTICE,
+    LOG_SEV_INFO,
+    LOG_SEV_DEBUG,
+    LOG_SEV_TRACE,
+    /* Last element */
+    LOG_SEV_LAST,
+} log_severity_t;
+
+/* Log configuration entry */
+struct log_cfg_entry_s {
+    log_context_t   context;
+    log_severity_t  severity;
+    log_color_t     color;
+    log_output_t    output;
+};
+
+/**
+ * Initialize logger
+ * 
+ * @param default_output : type of output
+ */
+extern void logger_init(log_output_t default_output);
+
+/**
+ * Deinitialize logger
+ */
+extern void logger_deinit(void);
+
+/**
+ * Initialize stream descriptors for each output type
+ * 
+ * @param output : type of output
+ */
+extern void logger_output_file_set(log_output_t output, char *filename);
+
+/**
+ * Redirect logger to a specific file
+ *  
+ * @param output : type of output
+ * @param output_file_path : path and file name
+ */
+extern void logger_redirect(log_output_t output, char* output_file_path);
+
+/**
+ * Log help
+ */
+extern void logger_help(void);
+
+/**
+ * Sets severity level for a group of contexts
+ * 
+ * @param ctx_mask bitmap that defines which contexts are affected 
+ * (bit position corresponds to the context index) 
+ * @param sev severity threshold
+ * 
+ * @return int Zero if OK, otherwise means error
+ */
+extern int logger_sev_set(unsigned int ctx_mask, int sev);
+
+/**
+ * Sets a color for a group of contexts
+ * 
+ * @param ctx_mask bitmap that defines which contexts are affected 
+ * (bit position corresponds to the context index) 
+ * @param color color array index of desired color (log_color_t)
+ * 
+ * @return int Zero if OK, otherwise means error
+ */
+extern int logger_color_set(unsigned int ctx_mask, int color);
+
+
+/**
+ * Prints a log message
+ * 
+ * @param ctx  Context
+ * @param sev  Severity
+ * @param file Filename (can be NULL)
+ * @param func Function name (can be NULL)
+ * @param line Line# (if zero, is ignored)
+ * @param fmt  Format string+ arguments (like printf)
+ */
+extern int logger_check(log_context_t ctx, log_severity_t sev);
+extern int logger_print(log_context_t ctx, log_severity_t sev, char const *file,
+                        char const *func, int line, char const *fmt, ...);
+
+
+#define PT_LOG_TRACE(ctx , fmt , args... ) \
+    (logger_check(ctx, LOG_SEV_TRACE   ) ? logger_print(ctx, LOG_SEV_TRACE   , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
+    
+#define PT_LOG_DEBUG(ctx , fmt , args... ) \
+    (logger_check(ctx, LOG_SEV_DEBUG   ) ? logger_print(ctx, LOG_SEV_DEBUG   , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
+    
+#define PT_LOG_INFO(ctx , fmt , args... ) \
+    (logger_check(ctx, LOG_SEV_INFO    ) ? logger_print(ctx, LOG_SEV_INFO    , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
+    
+#define PT_LOG_NOTICE(ctx , fmt , args... ) \
+    (logger_check(ctx, LOG_SEV_NOTICE  ) ? logger_print(ctx, LOG_SEV_NOTICE  , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
+    
+#define PT_LOG_WARN(ctx , fmt , args... ) \
+    (logger_check(ctx, LOG_SEV_WARNING ) ? logger_print(ctx, LOG_SEV_WARNING , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
+    
+#define PT_LOG_ERR(ctx , fmt , args... ) \
+    (logger_check(ctx, LOG_SEV_ERROR   ) ? logger_print(ctx, LOG_SEV_ERROR   , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
+    
+#define PT_LOG_CRITIC(ctx , fmt , args... ) \
+    (logger_check(ctx, LOG_SEV_CRITICAL) ? logger_print(ctx, LOG_SEV_CRITICAL, NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
+    
+#define PT_LOG_FATAL(ctx , fmt , args... ) \
+    (logger_check(ctx, LOG_SEV_FATAL   ) ? logger_print(ctx, LOG_SEV_FATAL   , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
+
+#define PT_LOG_PRINT(ctx , fmt , args... ) \
+    (logger_check(ctx, LOG_SEV_PRINT   ) ? logger_print(ctx, LOG_SEV_PRINT   , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
+    
+
+#endif /* _LOGGER_H */
