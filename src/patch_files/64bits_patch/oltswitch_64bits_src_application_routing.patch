Index: src/application/routing/mapping/arpmap/core/include/ipmap_arp.h
===================================================================
--- src/application/routing/mapping/arpmap/core/include/ipmap_arp.h	(revision 7768)
+++ src/application/routing/mapping/arpmap/core/include/ipmap_arp.h	(working copy)
@@ -233,13 +233,13 @@ typedef struct ipMapArpIpNode_s
 
 /* IP Mapping layer ARP lock control info */
 #define ARP_LOCK_OWNER_LEN 20
 typedef struct ipMapArpLockCtrl_s
 {
   void            *semId;               /* semaphore id */
-  L7_int32        ownerTaskId;          /* current lock owner task */
+  L7_uint64       ownerTaskId;          /* current lock owner task */
   L7_int32        ownerLockCount;       /* nested lock count for current owner (signed value) */
   L7_uint32       lockTotal;            /* total number of times locked        */
   L7_uint32       unlockTotal;          /* total number of times unlocked      */
 
   /* additional debug */
   L7_char8        ownerFile[ARP_LOCK_OWNER_LEN+1];
@@ -306,13 +306,13 @@ typedef struct
   L7_ushort16               flags;
 
 } ipMapArpTimerExpMsg_t;
 
 typedef struct
 {
-  L7_int32        taskId;               /* system task identifier */
+  L7_uint64       taskId;               /* system task identifier */
   void            *pMsgQ;               /* task msg queue ptr */
   L7_uint32       totalCt;              /* total msgs processed by task */
   L7_uint32       peakCt;               /* peak msgs processed per task iteration */
   L7_uint32       maxCt;                /* max msgs avail in task msg queue */
   L7_uint32       fullQCt;              /* task msg queue full (when sending) */
   L7_uint32       failCt;               /* general failure (task-specific meaning) */
@@ -968,13 +968,13 @@ void ipMapArpAllShow(L7_uint32 amt);
 *       
 * @end
 *********************************************************************/
 L7_RC_t ipMapArpAddrResolveInternal(L7_uint32 intIfNum, L7_uint32 ipAddr,
                             L7_uchar8 *pMacAddr, 
                             ipMapArpResCallback_ft pCallbackFn,
-                            L7_uint32 cbParm1, L7_uint32 cbParm2);
+                            L7_uint64 cbParm1, L7_uint64 cbParm2);
 
 /*-----------------*/
 /* ipm_arp_table.c */
 /*-----------------*/
 
 /*********************************************************************
Index: src/application/routing/mapping/arpmap/core/ipmap_arp.c
===================================================================
--- src/application/routing/mapping/arpmap/core/ipmap_arp.c	(revision 7768)
+++ src/application/routing/mapping/arpmap/core/ipmap_arp.c	(working copy)
@@ -36,13 +36,13 @@
 #include "log.h"
 #include "l7utils_api.h"
 #include "arp_debug.h"
 #include "arp.h"
 
 /* External References */
-extern void osapiDebugStackTrace (L7_uint32 task_id, FILE *fp);
+extern void osapiDebugStackTrace (L7_uint64 task_id, FILE *fp);
 
 /* Global data */
 ipMapArpCtx_t   ipMapArpCtx_g;          /* IP Mapping layer ARP global context*/
 ipMapArpIntf_t  *ipMapArpIntfInUse_g[IPM_ARP_INTF_MAX]; /* not using entry 0 */
 L7_BOOL         ipMapRoutingStarted = L7_FALSE;          /* vendor subsystem was started */
 
@@ -65,13 +65,13 @@ extern L7_uchar8 ipMapArpBcastMac[L7_MAC
 #define ARP_HIST_FUNC_LEN 30
 #define ARP_HIST_ITEMS    200
 struct arpLockHistory_s
 {
   L7_char8  file[ARP_HIST_FILE_LEN+1];
   L7_uint32 line;
-  L7_uint32 tid;
+  L7_uint64 tid;
   L7_uint32 lockid;
   L7_char8  fname[ARP_HIST_FUNC_LEN+1];
   L7_uint32 ts;
 };
 
 static struct arpLockHistory_s arpLockHistory[ARP_HIST_ITEMS];
@@ -138,16 +138,16 @@ void arpLogLockAction(L7_char8 * fname,
 
 /* when a lock fails (suspected deadlock) this functions dumps the stack trace */
 void arpLockShowStack(L7_char8 * fname, L7_uint32 lockid, L7_char8 * file, L7_uint32 line)
 {
   osapiSleep(osapiTaskIdSelf() % 60);
   l7utilsFilenameStrip(&file);
-  sysapiPrintf("\n%s failed to lock 0x%x tsk 0x%x %s:%u",
+  sysapiPrintf("\n%s failed to lock 0x%x tsk 0x%llx %s:%u",
                fname, lockid, osapiTaskIdSelf(), file, line);
   L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
-          "\n%s failed tsk 0x%x %s:%u",
+          "\n%s failed tsk 0x%llx %s:%u",
                fname, osapiTaskIdSelf(), file, line);
   osapiSleep(90);
   if(!arpDeadlocked)
   {
     /* attempt to avoid multiple traces */
     arpDeadlocked = L7_TRUE;
@@ -404,14 +404,14 @@ e_Err ipMapArpSendCallback(t_Handle user
     }
     SYSAPI_NET_MBUF_GET_DATASTART(bufHandle, pDataBuf);
     if (F_Read(pDataBuf, pFrame, 0, (word)frameSize) != (word)frameSize)
     {
         IPM_ARP_PRT(IPM_ARP_MSGLVL_MED,
                     "IPM_ARP: ARP Send could not copy frame contents to msg block, "
-                    "pFrame=0x%8.8x intf=%d\n",
-                    (L7_uint32)pFrame, pIntf->index);
+                    "pFrame=0x%llx intf=%d\n",
+                    PTR_TO_UINT64(pFrame), pIntf->index);
         SYSAPI_NET_MBUF_FREE(bufHandle);
         break;
     }
     SYSAPI_NET_MBUF_SET_DATALENGTH(bufHandle, frameSize);
 
     /* invoke the interface raw send function (it now owns sysnet buffer) */
@@ -1420,25 +1420,25 @@ void ipMapArpCacheEventNotify(ipMapArpCa
 *
 * @end
 *************************************************************************/
 void ipMapArpSemaTake(ipMapArpLockCtrl_t *pLock, L7_int32 timeout,
                       char *file, L7_ulong32 line)
 {
-  L7_int32      taskId = osapiTaskIdSelf();
+  L7_uint64     taskId = osapiTaskIdSelf();
   L7_RC_t       rc;
 
   if(timeout == L7_WAIT_FOREVER)
     timeout = arpLockDebugTimeout;
 
   l7utilsFilenameStrip(&file);
 
   if ((rc = osapiSemaTake(pLock->semId, arpLockDebugTimeout)) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
-            "Semaphore take failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)pLock->semId);
+            "Semaphore take failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, pLock->semId);
     ARP_LOCK_DEBUG_DUMP(pLock->semId, file, line);
   }
 
   pLock->ownerTaskId = taskId;
   pLock->ownerLockCount++;
   pLock->lockTotal++;                 /* used for debug show function */
@@ -1481,14 +1481,14 @@ void ipMapArpSemaGive(ipMapArpLockCtrl_t
 
   l7utilsFilenameStrip(&file);
 
   if ((rc = osapiSemaGive(pLock->semId)) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
-            "Semaphore give failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)pLock->semId);
+            "Semaphore give failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, pLock->semId);
   }
 
   ARP_LOCK_DEBUG_LOG(file, line, pLock->semId);
 }
 
 /*********************************************************************
@@ -1650,14 +1650,14 @@ void ipMapArpTraceShow(L7_uint32 amt)
 *********************************************************************/
 void ipMapArpLockShow(void)
 {
   ipMapArpLockCtrl_t  *pLock = &ipMapArpCtx_g.arpLock;
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  ARP Component Lock:\n");
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    lock info      semId=0x%x  owner task=0x%x  owner lock count=%ld  lkTot=%lu  unlkTot=%lu\n",
-        (L7_uint32)pLock->semId, (L7_uint32)pLock->ownerTaskId, pLock->ownerLockCount,
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    lock info      semId=0x%llx  owner task=0x%llx  owner lock count=%ld  lkTot=%lu  unlkTot=%lu\n",
+        PTR_TO_UINT64(pLock->semId), pLock->ownerTaskId, pLock->ownerLockCount,
         pLock->lockTotal, pLock->unlockTotal);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    owner at %s:%u\n", pLock->ownerFile, pLock->ownerLine);
 }
 
 
 /*********************************************************************
@@ -1675,53 +1675,53 @@ void ipMapArpCtxShow(void)
 {
   ipMapArpCtx_t *pCtx = &ipMapArpCtx_g;
   ipMapArpLockCtrl_t  *pLock;
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "\nIPMAP ARP Global Context Contents\n");
 
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  arpHandle       = 0x%8.8x\n",
-              (L7_uint32)pCtx->arpHandle);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  regUserId        = 0x%8.8x\n",
-              (L7_uint32)pCtx->regUserId);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  pIntfList        = 0x%8.8x\n",
-              (L7_uint32)pCtx->pIntfList);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  arpHandle       = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->arpHandle));
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  regUserId        = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->regUserId));
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  pIntfList        = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->pIntfList));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  Reissue Task:\n");
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%8.8x\n",
-              (L7_uint32)pCtx->reissue.taskId);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    pMsgQ          = 0x%8.8x\n",
-              (L7_uint32)pCtx->reissue.pMsgQ);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%llx\n",
+              pCtx->reissue.taskId);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    pMsgQ          = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->reissue.pMsgQ));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    totalCt        = %u\n",
               (L7_uint32)pCtx->reissue.totalCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    peakCt         = %u\n",
               (L7_uint32)pCtx->reissue.peakCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    maxCt          = %u\n",
               (L7_uint32)pCtx->reissue.maxCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    fullQCt        = %u\n",
               (L7_uint32)pCtx->reissue.fullQCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    failCt         = %u\n",
               (L7_uint32)pCtx->reissue.failCt);
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  Callback Task:\n");
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%8.8x\n",
-              (L7_uint32)pCtx->callback.taskId);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    pMsgQ          = 0x%8.8x\n",
-              (L7_uint32)pCtx->callback.pMsgQ);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%llx\n",
+              pCtx->callback.taskId);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    pMsgQ          = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->callback.pMsgQ));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    totalCt        = %u\n",
               (L7_uint32)pCtx->callback.totalCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    peakCt         = %u\n",
               (L7_uint32)pCtx->callback.peakCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    maxCt          = %u\n",
               (L7_uint32)pCtx->callback.maxCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    fullQCt        = %u\n",
               (L7_uint32)pCtx->callback.fullQCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    failCt         = %u\n",
               (L7_uint32)pCtx->callback.failCt);
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  Timer Expire (XX) Task:\n");
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%8.8x\n",
-              (L7_uint32)pCtx->timerExp.taskId);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%llx\n",
+              pCtx->timerExp.taskId);
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  routingStarted      = %s\n",
               (ipMapRoutingStarted == L7_TRUE) ? "True" : "False");
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  msgLvl           = %u\n",
               pCtx->msgLvl);
 
@@ -1743,36 +1743,36 @@ void ipMapArpCtxShow(void)
               pCtx->inTgtDiscard);
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  Gateway Table:\n");
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    treeEntryMax   = %u\n",
               pCtx->gwTbl.treeEntryMax);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *treeHeap      = 0x%8.8x\n",
-              (L7_uint32)pCtx->gwTbl.treeHeap);
+              PTR_TO_UINT64(pCtx->gwTbl.treeHeap));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    treeHeapSize   = %u\n",
               pCtx->gwTbl.treeHeapSize);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *dataHeap      = 0x%8.8x\n",
-              (L7_uint32)pCtx->gwTbl.dataHeap);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *dataHeap      = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->gwTbl.dataHeap));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    dataHeapSize   = %u\n",
               pCtx->gwTbl.dataHeapSize);
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  IP Lookup Table:\n");
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    treeEntryMax   = %u\n",
               pCtx->ipTbl.treeEntryMax);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *treeHeap      = 0x%8.8x\n",
-              (L7_uint32)pCtx->ipTbl.treeHeap);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *treeHeap      = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->ipTbl.treeHeap));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    treeHeapSize   = %u\n",
               pCtx->ipTbl.treeHeapSize);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *dataHeap      = 0x%8.8x\n",
-              (L7_uint32)pCtx->ipTbl.dataHeap);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *dataHeap      = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->ipTbl.dataHeap));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    dataHeapSize   = %u\n",
               pCtx->ipTbl.dataHeapSize);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "\n");
   pLock = &pCtx->arpLock;
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  ARP Component Lock:\n");
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    lock info      semId=0x%x  owner task=0x%x  owner lock count=%ld  lkTot=%lu  unlkTot=%lu\n",
-              (L7_uint32)pLock->semId, (L7_uint32)pLock->ownerTaskId, pLock->ownerLockCount,
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    lock info      semId=0x%llx  owner task=0x%llx  owner lock count=%ld  lkTot=%lu  unlkTot=%lu\n",
+              PTR_TO_UINT64(pLock->semId), pLock->ownerTaskId, pLock->ownerLockCount,
               pLock->lockTotal, pLock->unlockTotal);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    owner at %s:%u\n", pLock->ownerFile, pLock->ownerLine);
 
   ARP_ObjectInfoShow(ipMapArpCtx_g.arpHandle);
 }
 
@@ -1827,13 +1827,13 @@ void ipMapArpAllShow(L7_uint32 amt)
 *
 * @end
 *********************************************************************/
 L7_RC_t ipMapArpAddrResolveInternal(L7_uint32 intIfNum, L7_uint32 ipAddr,
                                     L7_uchar8 *pMacAddr,
                                     ipMapArpResCallback_ft pCallbackFn,
-                                    L7_uint32 cbParm1, L7_uint32 cbParm2)
+                                    L7_uint64 cbParm1, L7_uint64 cbParm2)
 {
   ipMapArpIntf_t  *pIntf;
   t_ARPResInfo  arpResInfo;
   ipMapArpResCallbackParms_t  *pCbInfo;
   L7_uint32 netOrderIpAddr = osapiHtonl(ipAddr);
   e_Err         erc;
Index: src/application/routing/mapping/arpmap/core/ipmap_arp_api.c
===================================================================
--- src/application/routing/mapping/arpmap/core/ipmap_arp_api.c	(revision 7768)
+++ src/application/routing/mapping/arpmap/core/ipmap_arp_api.c	(working copy)
@@ -211,14 +211,14 @@ L7_RC_t ipMapArpInitPhase1Process(void)
 * @end
 *********************************************************************/
 L7_RC_t ipMapArpInitPhase2Process(void)
 {
   L7_RC_t rc;
 
-  PT_LOG_INFO(LOG_CTX_STARTUP, "Going to register function 0x%08x to family DTL_FAMILY_ROUTING_ARP_MGMT (%u)",
-           (L7_uint32) dtlIpv4ArpEntryCallback, DTL_FAMILY_ROUTING_ARP_MGMT);
+  PT_LOG_INFO(LOG_CTX_STARTUP, "Going to register function %p to family DTL_FAMILY_ROUTING_ARP_MGMT (%u)",
+              dtlIpv4ArpEntryCallback, DTL_FAMILY_ROUTING_ARP_MGMT);
 
   if ((rc = dtlCallbackRegistration(DTL_FAMILY_ROUTING_ARP_MGMT,
               dtlIpv4ArpEntryCallback)) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
             "IPM_ARP: Could not register ARP Query callback with DTL, rc=%d\n",
@@ -647,13 +647,13 @@ L7_RC_t ipMapArpIntfUnregister(L7_uint32
 *
 * @end
 *********************************************************************/
 L7_RC_t ipMapArpAddrResolve(L7_uint32 intIfNum, L7_uint32 ipAddr,
                             L7_uchar8 *pMacAddr,
                             ipMapArpResCallback_ft pCallbackFn,
-                            L7_uint32 cbParm1, L7_uint32 cbParm2)
+                            L7_uint64 cbParm1, L7_uint64 cbParm2)
 {
   L7_RC_t rc;
   IPM_ARP_SEMA_TAKE(&ipMapArpCtx_g.arpLock, L7_WAIT_FOREVER);
   rc = ipMapArpAddrResolveInternal(intIfNum, ipAddr,
                                    pMacAddr, pCallbackFn,
                                    cbParm1, cbParm2);
Index: src/application/routing/mapping/arpmap/core/ipmap_arp_exten.c
===================================================================
--- src/application/routing/mapping/arpmap/core/ipmap_arp_exten.c	(revision 7768)
+++ src/application/routing/mapping/arpmap/core/ipmap_arp_exten.c	(working copy)
@@ -762,13 +762,13 @@ void ipMapArpExtenAddrConflictStatsShow(
   L7_uint32 intIfNum = 0, tmpIp, ip;
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
   L7_uchar8 ipAddrStr[OSAPI_INET_NTOA_BUF_SIZE];
 
   for (addrEnt = p_A->addrEnt; addrEnt; addrEnt = addrEnt->next)
   {
-    if(ipMapArpExtenGetIntIfNum(addrEnt->intfNum, &intIfNum) == L7_SUCCESS)
+    if(ipMapArpExtenGetIntIfNum(addrEnt->intfNum, &intIfNum) == E_OK)
     {
       memset(ifName, 0, sizeof(ifName));
       nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
       memcpy(&tmpIp, addrEnt->ipAddr, sizeof(tmpIp));
       ip = osapiNtohl(tmpIp);
       osapiInetNtoa(ip, ipAddrStr);
@@ -796,13 +796,13 @@ void ipMapArpExtenAddrConflictStatsReset
   t_ARP *p_A = (t_ARP *)ipMapArpCtx_g.arpHandle;
   t_ADDREnt *addrEnt;
   L7_uint32 intIfNum = 0;
 
   for (addrEnt = p_A->addrEnt; addrEnt; addrEnt = addrEnt->next)
   {
-    if(ipMapArpExtenGetIntIfNum(addrEnt->intfNum, &intIfNum) == L7_SUCCESS)
+    if(ipMapArpExtenGetIntIfNum(addrEnt->intfNum, &intIfNum) == E_OK)
     {
       addrEnt->addrConflictStats.numOfConflictsDetected = 0;
     }
   }
 }
 
Index: src/application/routing/mapping/arpmap/core/ipmap_arp_table.c
===================================================================
--- src/application/routing/mapping/arpmap/core/ipmap_arp_table.c	(revision 7768)
+++ src/application/routing/mapping/arpmap/core/ipmap_arp_table.c	(working copy)
@@ -203,14 +203,14 @@ L7_RC_t ipMapArpGwTableDelete(void)
     {
       pArpCtx->gwTbl.treeData.semId = L7_NULLPTR;
     }
     else
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
-              "%s: Could not delete AVL tree semaphore, id=0x%8.8x\n",
-              routine_name, (L7_uint32)pArpCtx->gwTbl.treeData.semId);
+              "%s: Could not delete AVL tree semaphore, id=%p\n",
+              routine_name, pArpCtx->gwTbl.treeData.semId);
       /* keep going */
     }
   }
 
   /* free the data heap memory */
   if (pArpCtx->gwTbl.dataHeap != L7_NULLPTR)
@@ -326,13 +326,13 @@ L7_RC_t ipMapArpGwTableInsert(L7_uint32
 
       /* when the first gateway arp entry added, start the ARP request timer */
       if(avlTreeCount(&ipMapArpCtx_g.gwTbl.treeData) == 1)
       {
         if(TIMER_StartSec(ipMapArpCtx_g.gwArpRqstTimer, ARP_GW_RQSTTIME,
                           TRUE /* repetitive timer */, gwArpRequestTimeExp,
-                          (t_Handle)ipMapArpCtx_g.timerExp.taskId) != E_OK)
+                          (t_Handle) UINT_TO_PTR(ipMapArpCtx_g.timerExp.taskId)) != E_OK)
           L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_ARP_MAP_COMPONENT_ID,
                   "%s: Start ARP Gateway timer failed\n", routine_name);
       }
     }
   }
   else if (pNode != &gw)
@@ -619,15 +619,15 @@ void ipMapArpGwTableShow(void)
     L7_uchar8   ipStr[OSAPI_INET_NTOA_BUF_SIZE];
     /* store key for use in next search */
     gw.ipAddr = pNode->ipAddr;
     gw.intIfNum = pNode->intIfNum;
 
     osapiInetNtoa(gw.ipAddr, ipStr);
-    IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%6u    %-15s %8d %10d 0x%8.8x %5s %5s\n",
+    IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%6u    %-15s %8d %10d 0x%llx %5s %5s\n",
                 ++count, ipStr, pNode->intIfNum, pNode->refCnt,
-                (L7_uint32)pNode, (pNode->holdover == L7_TRUE) ? "Y" : "N",
+                PTR_TO_UINT64(pNode), (pNode->holdover == L7_TRUE) ? "Y" : "N",
                 pNode->staticRouteGw ? "Y" : "N");
   }
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "\n\n");
 }
 
 
@@ -734,14 +734,14 @@ L7_RC_t ipMapArpIpTableDelete(void)
     {
       pArpCtx->ipTbl.treeData.semId = L7_NULLPTR;
     }
     else
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
-              "%s: Could not delete AVL tree semaphore, id=0x%8.8x\n",
-              routine_name, (L7_uint32)pArpCtx->ipTbl.treeData.semId);
+              "%s: Could not delete AVL tree semaphore, id=%p\n",
+              routine_name, pArpCtx->ipTbl.treeData.semId);
       /* keep going */
     }
   }
 
   /* free the data heap memory */
   if (pArpCtx->ipTbl.dataHeap != L7_NULLPTR)
@@ -949,17 +949,17 @@ L7_RC_t ipMapArpIpTableInsert(ipMapArpIp
               "%s: Failure adding %s in device ARP table\n",
               routine_name, (char *)ipStr);
     }
 
     /* debug message */
     IPM_ARP_PRT(IPM_ARP_MSGLVL_LO,
-                "[%10.10u] IPM_ARP: inserted %s intf %d, pNode=0x%8.8x t_Age=0x%8.8x t_Rsp=0x%8.8x  (inDev=%1s)\n",
+                "[%10.10u] IPM_ARP: inserted %s intf %d, pNode=0x%llx t_Age=0x%llx t_Rsp=0x%llx  (inDev=%1s)\n",
                 osapiTimeMillisecondsGet64(), (L7_uchar8 *)ipStr,
-                pIpInfo->intIfNum, (L7_uint32)pNode,
-                (L7_uint32)pNode->arpEntry.arpAgeTimer,
-                (L7_uint32)pNode->arpEntry.arpRspTimer,
+                pIpInfo->intIfNum, PTR_TO_UINT64(pNode),
+                PTR_TO_UINT64(pNode->arpEntry.arpAgeTimer),
+                PTR_TO_UINT64(pNode->arpEntry.arpRspTimer),
                 (pNode->inDevice == L7_TRUE) ? "Y" : "N");
 
     rc = L7_SUCCESS;                    /* all went well */
 
   } while (0);  /* enddowhile one-pass control loop */
 
@@ -1038,17 +1038,17 @@ L7_RC_t ipMapArpIpTableUpdate(ipMapArpIp
               "%s: Failure updating %s intf %s in device ARP table\n",
               routine_name, (char *)ipStr, ifName);
     }
 
     /* debug message */
     IPM_ARP_PRT(IPM_ARP_MSGLVL_LO,
-                "[%10.10u] IPM_ARP: %s %s %d, pNode=0x%8.8x t_Age=0x%8.8x t_Rsp=0x%8.8x  (inDev=%1s)\n",
+                "[%10.10u] IPM_ARP: %s %s %d, pNode=0x%llx t_Age=0x%llx t_Rsp=0x%llx  (inDev=%1s)\n",
                 osapiTimeMillisecondsGet64(), (event == IPM_ARP_TABLE_UPDATE) ? "updated" : "reissued",
-                (L7_uchar8 *)ipStr, pIpInfo->intIfNum, (L7_uint32)pNode,
-                (L7_uint32)pNode->arpEntry.arpAgeTimer,
-                (L7_uint32)pNode->arpEntry.arpRspTimer,
+                (L7_uchar8 *)ipStr, pIpInfo->intIfNum, PTR_TO_UINT64(pNode),
+                PTR_TO_UINT64(pNode->arpEntry.arpAgeTimer),
+                PTR_TO_UINT64(pNode->arpEntry.arpRspTimer),
                 (pNode->inDevice == L7_TRUE) ? "Y" : "N");
 
     rc = L7_SUCCESS;                    /* all went well */
 
   } while (0);  /* enddowhile one-pass control loop */
 
@@ -1079,13 +1079,13 @@ L7_RC_t ipMapArpIpTableRemove(ipMapArpIp
 {
   static const char *routine_name = "ipMapArpIpTableRemove";
   L7_uchar8         ipStr[OSAPI_INET_NTOA_BUF_SIZE];
   ipMapArpIpNode_t  *pNode;
   L7_RC_t           rc = L7_FAILURE;
   L7_BOOL           inDeviceSaved;      /* save for debug msg */
-  L7_uint32         ageTimerId, rspTimerId;
+  L7_uint64         ageTimerId, rspTimerId;
 
 
   osapiInetNtoa(pIpInfo->key, ipStr);
 
   /* use one-pass loop for error exit control */
   do
@@ -1117,14 +1117,14 @@ L7_RC_t ipMapArpIpTableRemove(ipMapArpIp
       rc = L7_FAILURE;
       break;                            /* exit control loop */
     }
 
     /* save value of inDevice flag for debug msg before it is changed/deleted */
     inDeviceSaved = pNode->inDevice;
-    ageTimerId = (L7_uint32)pNode->arpEntry.arpAgeTimer;
-    rspTimerId = (L7_uint32)pNode->arpEntry.arpRspTimer;
+    ageTimerId = PTR_TO_UINT64(pNode->arpEntry.arpAgeTimer);
+    rspTimerId = PTR_TO_UINT64(pNode->arpEntry.arpRspTimer);
 
     /* delete the entry from the ARP table */
     if (ipMapArpIpTableRemoveCommon(pNode) != L7_SUCCESS)
     {
       L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
       nimGetIntfName(pNode->intIfNum, L7_SYSNAME, ifName);
@@ -1136,15 +1136,15 @@ L7_RC_t ipMapArpIpTableRemove(ipMapArpIp
       rc = L7_FAILURE;                  /* node not removed from table */
       break;                            /* exit control loop */
     }
 
     /* debug message */
     IPM_ARP_PRT(IPM_ARP_MSGLVL_LO,
-                "[%10.10u] IPM_ARP: removed %s, intf %d pNode=0x%8.8x t_Age=0x%8.8x t_Rsp=0x%8.8x  (inDev=%1s)\n",
+                "[%10.10u] IPM_ARP: removed %s, intf %d pNode=0x%llx t_Age=0x%llx t_Rsp=0x%llx  (inDev=%1s)\n",
                 osapiTimeMillisecondsGet64(), ipStr, pNode->intIfNum,
-                (L7_uint32)pNode, ageTimerId, rspTimerId,
+                PTR_TO_UINT64(pNode), ageTimerId, rspTimerId,
                 (inDeviceSaved == L7_TRUE) ? "Y" : "N");
 
     rc = L7_SUCCESS;                    /* all went well */
 
   } while (0);  /* enddowhile one-pass control loop */
 
@@ -1174,13 +1174,13 @@ L7_RC_t ipMapArpIpTableOldestRemove(L7_B
 {
   static const char *routine_name = "ipMapArpIpTableOldestRemove";
   L7_uchar8         ipStr[OSAPI_INET_NTOA_BUF_SIZE];
   ipMapArpIpNode_t  *pNode = L7_NULLPTR;
   L7_RC_t           rc = L7_FAILURE, rc2;
   L7_BOOL           inDeviceSaved;      /* save for debug msg */
-  L7_uint32         ageTimerId, rspTimerId;
+  L7_uint64         ageTimerId, rspTimerId;
 
 
   /* use one-pass loop for error exit control */
   do
   {
     /* find oldest entry in ARP table */
@@ -1200,14 +1200,14 @@ L7_RC_t ipMapArpIpTableOldestRemove(L7_B
     /* NOTE: pNode points to oldest dynamic (or gateway) entry to be removed */
 
     osapiInetNtoa(pNode->key, ipStr);
 
     /* save value of inDevice flag for debug msg before it is changed/deleted */
     inDeviceSaved = pNode->inDevice;
-    ageTimerId = (L7_uint32)pNode->arpEntry.arpAgeTimer;
-    rspTimerId = (L7_uint32)pNode->arpEntry.arpRspTimer;
+    ageTimerId = PTR_TO_UINT64(pNode->arpEntry.arpAgeTimer);
+    rspTimerId = PTR_TO_UINT64(pNode->arpEntry.arpRspTimer);
 
     /* delete the entry from the ARP table */
     if (ipMapArpIpTableRemoveCommon(pNode) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
               "%s: Failure to remove %s from ARP table\n",
@@ -1216,15 +1216,15 @@ L7_RC_t ipMapArpIpTableOldestRemove(L7_B
       rc = L7_FAILURE;                  /* node not removed from table */
       break;                            /* exit control loop */
     }
 
     /* debug message */
     IPM_ARP_PRT(IPM_ARP_MSGLVL_LO,
-                "[%10.10u] IPM_ARP: oldest removed %s intf %d, pNode=0x%8.8x t_Age=0x%8.8x t_Rsp=0x%8.8x  (inDev=%1s)\n",
+                "[%10.10u] IPM_ARP: oldest removed %s intf %d, pNode=0x%llx t_Age=0x%llx t_Rsp=0x%llx  (inDev=%1s)\n",
                 osapiTimeMillisecondsGet64(), ipStr, pNode->intIfNum,
-                (L7_uint32)pNode, ageTimerId, rspTimerId,
+                PTR_TO_UINT64(pNode), ageTimerId, rspTimerId,
                 (inDeviceSaved == L7_TRUE) ? "Y" : "N");
 
     rc = L7_SUCCESS;                    /* all went well */
 
   } while (0);  /* enddowhile one-pass control loop */
 
@@ -1776,16 +1776,16 @@ void ipMapArpIpTableShow(L7_uint32 intIf
       for (i = 0; i < L7_MAC_ADDR_LEN-1; i++)
       {
         IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%2.2x:", pNode->arpEntry.macAddr[i]);
       }
       IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%2.2x ", pNode->arpEntry.macAddr[i]);
 
-      IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, " %2.1u  %-8.8s %8u   %1s    %2u   0x%8.8x\n",
+      IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, " %2.1u  %-8.8s %8u   %1s    %2u   0x%llx\n",
                   pIntf->intIfNum, ipMapArpEntryTypeStr[entryType], ageTime,
                   (pNode->inDevice == L7_TRUE) ? "Y" : "N", pNode->failedDevAdds,
-                  (L7_uint32)pNode->arpEntry.pNode);
+                  PTR_TO_UINT64(pNode->arpEntry.pNode));
 
       numEnt--;
     }
 
   } /* endwhile */
 
@@ -1995,14 +1995,14 @@ void ipMapArpIpAgeListShow(L7_uint32 int
   L7_uint32         count, ipAddr, entryType;
   ulng              ageTime;
   ipMapArpIntf_t    *pIntf;
 
 
   /* display the head and tail pointers */
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "\nAge List head = 0x%8.8x  tail = 0x%8.8x\n",
-              (L7_uint32)pAgeList->head, (L7_uint32)pAgeList->tail);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "\nAge List head = 0x%llx  tail = 0x%llx\n",
+              PTR_TO_UINT64(pAgeList->head), PTR_TO_UINT64(pAgeList->tail));
 
   /* quick-scan the list to count the entries */
   for (pNode = pAgeList->head, count = 0;
        pNode != L7_NULLPTR;
        pNode = pNode->ageCtrl.next, count++);
 
@@ -2057,15 +2057,15 @@ void ipMapArpIpAgeListShow(L7_uint32 int
     if ((intIfNum == 0) || (intIfNum == pIntf->intIfNum))
     {
       osapiInetNtoa(ipAddr, ipStr);
       entryType = (L7_uint32)pNode->arpEntry.entryType;
       ipMapArpExtenEntryAgeCalc(pNode->arpEntry.timeStamp, (ulng *)&ageTime);
 
-      IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%6u   %-15.15s %-8.8s  %2.1u  %8u 0x%8.8x\n",
+      IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%6u   %-15.15s %-8.8s  %2.1u  %8u 0x%llx\n",
                   ++count, ipStr, ipMapArpEntryTypeStr[entryType],
-                  pIntf->intIfNum, ageTime, (L7_uint32)pNode);
+                  pIntf->intIfNum, ageTime, PTR_TO_UINT64(pNode));
 
       numEnt--;
     }
 
     pNode = pNode->ageCtrl.next;
 
Index: src/application/routing/mapping/ipmap/core/include/ip_util.h
===================================================================
--- src/application/routing/mapping/ipmap/core/include/ip_util.h	(revision 7768)
+++ src/application/routing/mapping/ipmap/core/include/ip_util.h	(working copy)
@@ -875,13 +875,13 @@ L7_RC_t ipMapLockGive(e_ipMapLockType lo
 L7_RC_t ipMapStaticRejectRoutesAdd(void);
 L7_RC_t ipMapStaticRejectRoutesRemove(void);
 L7_RC_t ipMapSubnetStaticRoutesRemove(L7_uint32 intIfNum, L7_IP_ADDR_t ipAddr, L7_IP_MASK_t ipMask);
 L7_RC_t ipMapSubnetLocalRouteRemove(L7_uint32 ipAddr, L7_uint32 ipMask);
 L7_uchar8 *ipMapNsfProtocolName(L7_NSF_PROTOCOL_t protocol);
 L7_uchar8 *ipMapNsfRoutesPendingString(void);
-void ipMapStaleRouteTimerExp(L7_uint32 unused1, L7_uint32 unused2);
+void ipMapStaleRouteTimerExp(L7_uint64 unused1, L7_uint64 unused2);
 
 /*-------------------------------------------------------------*/
 /*                   ipmap_cnfgr.c                             */
 /*-------------------------------------------------------------*/
 L7_RC_t ipMapInit(L7_CNFGR_CMD_DATA_t *pCmdData);
 void ipMapInitUndo();
Index: src/application/routing/mapping/ipmap/core/ip_api.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ip_api.c	(revision 7768)
+++ src/application/routing/mapping/ipmap/core/ip_api.c	(working copy)
@@ -5166,13 +5166,13 @@ L7_RC_t ipMapVlanRtrIntIfNumToVlanId(L7_
   if (nimGetIntfType(intIfNum, &sysIntfType) == L7_SUCCESS)
   {
     if (sysIntfType == L7_LOGICAL_VLAN_INTF)
     {
       if ( nimGetMacroPortAssignment(intIfNum, &macroPortIntf) == L7_SUCCESS)
       {
-        *vlanId    = (L7_uint32)macroPortIntf.macroInfo;
+        *vlanId    = PTR_TO_UINT32(macroPortIntf.macroInfo);
         return L7_SUCCESS;
       }
     }
   }
 
   return L7_FAILURE;
Index: src/application/routing/mapping/ipmap/core/ip_util.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ip_util.c	(revision 7768)
+++ src/application/routing/mapping/ipmap/core/ip_util.c	(working copy)
@@ -4298,13 +4298,13 @@ L7_RC_t ipMapRtrIntfDataGet( L7_uint32 i
 
   if (sysIntfType == L7_LOGICAL_VLAN_INTF)
   {
     /* VLAN routing interface */
     if (nimGetMacroPortAssignment(intIfNum, &macroPortIntf) == L7_SUCCESS)
     {
-      vlanId = (L7_uint32)macroPortIntf.macroInfo;
+      vlanId = PTR_TO_UINT32(macroPortIntf.macroInfo);
     }
     else
     {
       return L7_ERROR;
     }
   }
@@ -4357,13 +4357,13 @@ L7_RC_t ipMapLockTake(e_ipMapLockType lo
   L7_RC_t rc;
   L7_uint32 startTime = osapiTimeMillisecondsGet();
 
   if (ipMapTraceFlags & IPMAP_TRACE_LOCK)
   {
     L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
-    osapiSnprintf(traceBuf, IPMAP_TRACE_LEN_MAX, "%s taking %s lock on task %#x. wait %d.",
+    osapiSnprintf(traceBuf, IPMAP_TRACE_LEN_MAX, "%s taking %s lock on task %#llx. wait %d.",
             lockHolder, (lockType == IPMAP_READ_LOCK ? "READ" : "WRITE"),
             osapiTaskIdSelf(), wait);
     ipMapTraceWrite(traceBuf);
   }
 
   /* Make sure IP MAP has created semaphore */
@@ -4484,13 +4484,13 @@ L7_RC_t ipMapLockGive(e_ipMapLockType lo
 {
   L7_RC_t rc = L7_FAILURE;
 
   if (ipMapTraceFlags & IPMAP_TRACE_LOCK)
   {
     L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
-    osapiSnprintf(traceBuf, IPMAP_TRACE_LEN_MAX, "%s giving %s lock on task %#x.",
+    osapiSnprintf(traceBuf, IPMAP_TRACE_LEN_MAX, "%s giving %s lock on task %#llx.",
                   lockHolder, (lockType == IPMAP_READ_LOCK ? "READ" : "WRITE"),
                   osapiTaskIdSelf());
     ipMapTraceWrite(traceBuf);
   }
 
   /* Make sure IP MAP has created semaphore */
Index: src/application/routing/mapping/ipmap/core/ipmap.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ipmap.c	(revision 7768)
+++ src/application/routing/mapping/ipmap/core/ipmap.c	(working copy)
@@ -113,15 +113,15 @@ the event times out (and bad things prob
 
 #ifdef L7_QOS_FLEX_PACKAGE_ACL
 #include "support_api.h"
 #endif
 
 
-L7_int32                ipMapForwardingTaskId = L7_NULL;
-L7_int32                ipMapProcessingTaskId = L7_NULL;
-ipMapInfo_t                 *pIpMapInfo                                 = L7_NULL;
+L7_uint64               ipMapForwardingTaskId = L7_NULL;
+L7_uint64               ipMapProcessingTaskId = L7_NULL;
+ipMapInfo_t             *pIpMapInfo                                 = L7_NULL;
 void *ipMapMsgQSema = L7_NULL;
 void *ipMapForwardQueue[L7_L3_FORWARD_QUEUE_COUNT];
 L7_uint32 ipMapForwardQueueHWMark[L7_L3_FORWARD_QUEUE_COUNT];
 void *ipMapProcess_Queue = L7_NULL;
 pIpRoutingEventNotifyList_t  pIpIntfStateNotifyList;
 L7_rtrIntfMap_t    rtrIntfMap[L7_RTR_MAX_RTR_INTERFACES+1];
@@ -976,13 +976,13 @@ L7_RC_t ipMapIntfDelete(L7_uint32 intIfN
 * @returns  void
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void ipMapStaleRouteTimerExp(L7_uint32 unused1, L7_uint32 unused2)
+void ipMapStaleRouteTimerExp(L7_uint64 unused1, L7_uint64 unused2)
 {
   ipMapMsg_t   Message;
   L7_RC_t rc;
 
   memset(&Message, 0, sizeof(ipMapMsg_t));
   Message.msgId = IPMAP_STALE_ROUTE_TIMER;
Index: src/application/routing/mapping/ipmap/core/ipmap_cnfgr.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ipmap_cnfgr.c	(revision 7768)
+++ src/application/routing/mapping/ipmap/core/ipmap_cnfgr.c	(working copy)
@@ -36,14 +36,14 @@
 
 ipMapCnfgrState_t ipMapCnfgrState = IPMAP_PHASE_INIT_0;
 extern void *ipMapForwardQueue[L7_L3_FORWARD_QUEUE_COUNT];
 extern L7_uint32 ipMapForwardQueueHWMark[L7_L3_FORWARD_QUEUE_COUNT];
 extern void *ipMapProcess_Queue;
 
-extern L7_int32 ipMapForwardingTaskId;
-extern L7_int32 ipMapProcessingTaskId;
+extern L7_uint64 ipMapForwardingTaskId;
+extern L7_uint64 ipMapProcessingTaskId;
 extern L7_ipMapCfg_t           *ipMapCfg;
 extern L7_rtrStaticRouteCfg_t  *route;
 extern L7_rtrStaticArpCfg_t    *arp;
 extern ipMapInfo_t             *pIpMapInfo;
 extern L7_uint32               *intIfToCfgIndex;
 extern pIpRoutingEventNotifyList_t  pIpIntfStateNotifyList;
@@ -518,14 +518,14 @@ L7_RC_t ipMapCnfgrInitPhase2Process( L7_
     *pReason   = L7_CNFGR_ERR_RC_FATAL;
     ipMapRC     = L7_ERROR;
 
     return ipMapRC;
   }
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapArpRecvIP related to type=%u, protocol_type=%u: 0x%08x",
-           SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_ARP,  (L7_uint32) ipMapArpRecvIP);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapArpRecvIP related to type=%u, protocol_type=%u: %p",
+              SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_ARP,  ipMapArpRecvIP);
 
   /* Register with SYSNET to receive ARP packets */
   memset((void *)&snEntry, 0, sizeof(sysnetNotifyEntry_t));
   strcpy(snEntry.funcName, "ipMapArpRecvIP");
   snEntry.notify_pdu_receive = ipMapArpRecvIP;
   snEntry.type = SYSNET_ETHERTYPE_ENTRY;
@@ -536,14 +536,14 @@ L7_RC_t ipMapCnfgrInitPhase2Process( L7_
     *pReason   = L7_CNFGR_ERR_RC_FATAL;
     ipMapRC     = L7_ERROR;
 
     return ipMapRC;
   }
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapRecvIP related to type=%u, protocol_type=%u: 0x%08x",
-           SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_IP,  (L7_uint32) ipMapRecvIP);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapRecvIP related to type=%u, protocol_type=%u: %p",
+              SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_IP, ipMapRecvIP);
 
   /* Register with sysNET to receive IP packets */
   memset((void *)&snEntry, 0, sizeof(sysnetNotifyEntry_t));
   strcpy(snEntry.funcName, "ipMapRecvIP");
   snEntry.notify_pdu_receive = ipMapRecvIP;
   snEntry.type = SYSNET_ETHERTYPE_ENTRY;
@@ -625,14 +625,14 @@ L7_RC_t ipMapCnfgrRegisterCallbacks(L7_i
 {
   sysnetNotifyEntry_t snEntry;
 
   /* Register with SYSNET to receive ARP packets */
   if (which == 1)
   {
-    PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapArpRecvIP related to type=%u, protocol_type=%u: 0x%08x",
-             SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_ARP,  (L7_uint32) ipMapArpRecvIP);
+    PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapArpRecvIP related to type=%u, protocol_type=%u: %p",
+                SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_ARP, ipMapArpRecvIP);
 
     memset((void *)&snEntry, 0, sizeof(sysnetNotifyEntry_t)); 
     strcpy(snEntry.funcName, "ipMapArpRecvIP");
     snEntry.notify_pdu_receive = ipMapArpRecvIP;
     snEntry.type = SYSNET_ETHERTYPE_ENTRY;
     snEntry.u.protocol_type = L7_ETYPE_ARP;
@@ -642,14 +642,14 @@ L7_RC_t ipMapCnfgrRegisterCallbacks(L7_i
     }
   }
 
   /* Register with sysNET to receive IP packets */
   if (which == 2)
   {
-    PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapRecvIP related to type=%u, protocol_type=%u: 0x%08x",
-             SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_IP,  (L7_uint32) ipMapRecvIP);
+    PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapRecvIP related to type=%u, protocol_type=%u: %p",
+                SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_IP, ipMapRecvIP);
 
     memset((void *)&snEntry, 0, sizeof(sysnetNotifyEntry_t));
     strcpy(snEntry.funcName, "ipMapRecvIP");
     snEntry.notify_pdu_receive = ipMapRecvIP;
     snEntry.type = SYSNET_ETHERTYPE_ENTRY;
     snEntry.u.protocol_type = L7_ETYPE_IP;
Index: src/application/routing/mapping/ipmap/core/ipmap_debug.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ipmap_debug.c	(revision 7768)
+++ src/application/routing/mapping/ipmap/core/ipmap_debug.c	(working copy)
@@ -78,14 +78,14 @@ L7_uint32 ipMapTraceFlags = 0x0;
 L7_uint32 ipMapTraceIntf = 0;
 
 /* ICMP Rate limiting Stats */
 ipMapDebugIcmpCtlStats_t icmpCtlStats;
 L7_BOOL ratelimitKicks = L7_FALSE;
 
-extern L7_int32 ipMapForwardingTaskId;
-extern L7_int32 ipMapProcessingTaskId;
+extern L7_uint64 ipMapForwardingTaskId;
+extern L7_uint64 ipMapProcessingTaskId;
 
 /*---------------------------------------*/
 /* Global Configuration Data Structures  */
 /*---------------------------------------*/
 extern L7_ipMapCfg_t            *ipMapCfg;
 extern L7_rtrStaticRouteCfg_t   *route;
@@ -1678,13 +1678,13 @@ void dbg_form_arp(L7_uchar8 *buf, L7_uin
 void dbg_arp_req(L7_uint32 intIfNum, L7_uint32 ipSa, L7_uint32 ipDa)
 {
     L7_uchar8 *buff = osapiMalloc(L7_IP_MAP_COMPONENT_ID, 100);
     L7_uchar8 sMac[6] = {0, 0, 0, 1, 2, 0};
     L7_uchar8 dMac[6] = {0, 0, 0, 4, 5, 0};
     sysnet_pdu_info_t pduInfo;
-    L7_uint32 bufHandle;
+    L7_uint64 bufHandle;
     L7_ushort16 pFlag = L7_LL_ENCAP_ENET | L7_LL_USE_L3_SRC_MAC;
 
     sMac[4] = (ipSa & 0xFF00)>>8;
     sMac[5] = (ipSa & 0xFF);
 
     dMac[4] = (ipDa & 0xFF00)>>8;
@@ -1702,13 +1702,13 @@ void dbg_arp_req(L7_uint32 intIfNum, L7_
 void dbg_arp_rep(L7_uint32 intIfNum, L7_uint32 ipSa, L7_uint32 ipDa)
 {
     L7_uchar8 *buff = osapiMalloc(L7_IP_MAP_COMPONENT_ID, 100);
     L7_uchar8 sMac[6] = {0, 0, 0, 1, 2, 0};
     L7_uchar8 dMac[6] = {0, 0, 0, 4, 5, 0};
     sysnet_pdu_info_t pduInfo;
-    L7_uint32 bufHandle;
+    L7_uint64 bufHandle;
     L7_ushort16 pFlag = L7_LL_ENCAP_ENET | L7_LL_USE_L3_SRC_MAC;
 
     sMac[4] = (ipSa & 0xFF00)>>8;
     sMac[5] = (ipSa & 0xFF);
 
     dMac[4] = (ipDa & 0xFF00)>>8;
@@ -1768,13 +1768,13 @@ void dbg_form_ip(L7_uchar8 *buff, L7_uin
 void dbg_ip_rcv(L7_uint32 intIfNum, L7_uint32 ipSa, L7_uint32 ipDa, L7_uint32 op)
 {
     L7_uchar8 *buff = osapiMalloc(L7_IP_MAP_COMPONENT_ID, 100);
     L7_uchar8 sMac[6] = {0, 0, 0, 1, 2, 0};
     L7_uchar8 dMac[6] = {0, 0, 0, 4, 5, 0};
     sysnet_pdu_info_t pduInfo;
-    L7_uint32 bufHandle;
+    L7_uint64 bufHandle;
     L7_ushort16 pFlag = L7_LL_ENCAP_ENET | L7_LL_USE_L3_SRC_MAC;
 
     sMac[4] = (ipSa & 0xFF00)>>8;
     sMac[5] = (ipSa & 0xFF);
 
     dMac[4] = (ipDa & 0xFF00)>>8;
Index: src/application/routing/mapping/ospfmap/core/ospf_cnfgr.c
===================================================================
--- src/application/routing/mapping/ospfmap/core/ospf_cnfgr.c	(revision 7768)
+++ src/application/routing/mapping/ospfmap/core/ospf_cnfgr.c	(working copy)
@@ -58,13 +58,13 @@
 #include "ospf_ckpt.h"
 #endif
 
 static L7_BOOL traceConfigState = L7_FALSE;
 
 ospfMapCnfgrState_t ospfMapCnfgrState = OSPFMAP_PHASE_INIT_0;
-L7_int32 ospfProcTaskHandle = 0;
+L7_uint64 ospfProcTaskHandle = 0;
 
 /* The OSPF processing thread reads events from two message queues. msgQSema
  * is a counting semaphore to indicate whether data is available in
  * one of the message queues. Ospf_Proc_Queue contains all events other than
  * redistribution events. Ospf_Redist_Queue contains the redistribution events.
  * There can be many redistribution events all at once, and we don't want
Index: src/application/routing/mapping/ospfmap/core/ospf_vend_ctrl.c
===================================================================
--- src/application/routing/mapping/ospfmap/core/ospf_vend_ctrl.c	(revision 7768)
+++ src/application/routing/mapping/ospfmap/core/ospf_vend_ctrl.c	(working copy)
@@ -2666,13 +2666,13 @@ static e_Err sockReceive(t_Handle userId
 
 
 static void sockStatus( t_Handle userId,     /* User Id of connection */
                         t_Handle connId,     /* Connection Idreturned by TcpUdpBind_Open */
                         word status)         /* Connection status flags */
 {
-  OSPFMAP_TRACE("Socket 0x%8.8X status is %ld\n", (unsigned int)connId, (ulng)status);
+  OSPFMAP_TRACE("Socket 0x%llX status is %ld\n", PTR_TO_UINT64(connId), (ulng)status);
 }
 
 
 /*********************************************************************
 * @purpose  Creates the OSPF socket
 *
Index: src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c
===================================================================
--- src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c	(revision 7768)
+++ src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c	(working copy)
@@ -1615,19 +1615,19 @@ static e_Err ospfMapExtenIntfAreaIdSet(v
 * @end
 *********************************************************************/
 L7_RC_t ospfMapExtenIntfAreaIdPack(L7_uint32 intIfNum, L7_uint32 area)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     PACKET_INIT(xxci, ospfMapExtenIntfAreaIdSet, 0, 0, 3, (ulng)intIfNum);
     PACKET_PUT(xxci, (ulng)area);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -1655,13 +1655,13 @@ L7_RC_t ospfMapExtenIntfAreaIdPack(L7_ui
     {
         PACKET_PUT(xxci, (ulng) 0);
         e = ospfMapExtenIntfAreaIdSet(xxci);
         XX_Free(xxci);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread !=  pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return L7_SUCCESS;
 }
@@ -7328,21 +7328,21 @@ L7_RC_t ospfMapExtenAreaStubAreaSet(L7_u
 e_Err ospfAbrEntry_Lookup_Pack(L7_uint32 destinationIp,
                                L7_RtbEntryInfo_t *p_rtbEntry)
 {
   t_XXCallInfo  *xxci;      /* XX_Call info */
   e_Err         e;
   L7_RC_t       rc = L7_FAILURE;
-  L7_int32      currThread = osapiTaskIdSelf();
+  L7_uint64      currThread = osapiTaskIdSelf();
   OS_Thread     *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   if(p_rtbEntry == NULL)
   {
     return E_FAILED;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -7370,13 +7370,13 @@ e_Err ospfAbrEntry_Lookup_Pack(L7_uint32
   }
   else
   {
     rc = ospfAbrEntry_Lookup(destinationIp, p_rtbEntry);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -7399,21 +7399,21 @@ e_Err ospfAbrEntry_Lookup_Pack(L7_uint32
 e_Err ospfAsbrEntry_Lookup_Pack(L7_uint32 destinationIp,
                                 L7_RtbEntryInfo_t *p_rtbEntry)
 {
   t_XXCallInfo  *xxci;      /* XX_Call info */
   e_Err         e;
   L7_RC_t       rc = L7_FAILURE;
-  L7_int32      currThread = osapiTaskIdSelf();
+  L7_uint64     currThread = osapiTaskIdSelf();
   OS_Thread     *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   if(p_rtbEntry == NULL)
   {
     return E_FAILED;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -7441,13 +7441,13 @@ e_Err ospfAsbrEntry_Lookup_Pack(L7_uint3
   }
   else
   {
     rc = ospfAsbrEntry_Lookup(destinationIp, p_rtbEntry);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -7648,30 +7648,30 @@ L7_RC_t ospfMapExtenAsbrEntryGet ( L7_ui
 e_Err ospfAbrEntryNext_Pack(L7_uint32 *destinationIp,
                             L7_RtbEntryInfo_t *p_rtbEntry)
 {
   t_XXCallInfo  *xxci;      /* XX_Call info */
   e_Err         e;
   L7_RC_t       rc = L7_FAILURE;
-  L7_int32      currThread = osapiTaskIdSelf();
+  L7_uint64     currThread = osapiTaskIdSelf();
   OS_Thread     *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   if(p_rtbEntry == NULL)
   {
     return E_FAILED;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
     }
 
-    PACKET_INIT(xxci, ospfAbrEntryNext_UnPack, 0, 0, 3, (L7_uint32)destinationIp);
+    PACKET_INIT(xxci, ospfAbrEntryNext_UnPack, 0, 0, 3, PTR_TO_UINT32(destinationIp));
     PACKET_PUT(xxci, (L7_RtbEntryInfo_t *)p_rtbEntry);
     PACKET_PUT(xxci, (L7_RC_t *)&rc);
     e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
 
     if (e != E_OK)
     {
@@ -7690,13 +7690,13 @@ e_Err ospfAbrEntryNext_Pack(L7_uint32 *d
   }
   else
   {
     rc = ospfAbrEntryNext(destinationIp, p_rtbEntry);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -7719,30 +7719,30 @@ e_Err ospfAbrEntryNext_Pack(L7_uint32 *d
 e_Err ospfAsbrEntryNext_Pack(L7_uint32 *destinationIp,
                              L7_RtbEntryInfo_t *p_rtbEntry)
 {
   t_XXCallInfo  *xxci;      /* XX_Call info */
   e_Err         e;
   L7_RC_t       rc = L7_FAILURE;
-  L7_int32      currThread = osapiTaskIdSelf();
+  L7_uint64     currThread = osapiTaskIdSelf();
   OS_Thread     *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   if(p_rtbEntry == NULL)
   {
     return E_FAILED;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
     }
 
-    PACKET_INIT(xxci, ospfAsbrEntryNext_UnPack, 0, 0, 3, (L7_uint32)destinationIp);
+    PACKET_INIT(xxci, ospfAsbrEntryNext_UnPack, 0, 0, 3, PTR_TO_UINT32(destinationIp));
     PACKET_PUT(xxci, (L7_RtbEntryInfo_t *)p_rtbEntry);
     PACKET_PUT(xxci, (L7_RC_t *)&rc);
     e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
 
     if (e != E_OK)
     {
@@ -7761,13 +7761,13 @@ e_Err ospfAsbrEntryNext_Pack(L7_uint32 *
   }
   else
   {
     rc = ospfAsbrEntryNext(destinationIp, p_rtbEntry);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -12113,26 +12113,26 @@ e_Err RTO_Config_Pack(t_Handle RTO_Id, t
 {
     t_S_RouterCfg   *p_rtoCfg;  /* ospf router object configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     void            *p_info;
     int             numOfMsgs = 0, i;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the router configuration info */
     p_rtoCfg = XX_Malloc(sizeof(t_S_RouterCfg));
     if (!p_rtoCfg)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_rtoCfg, p_Cfg, sizeof(t_S_RouterCfg));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_rtoCfg);
@@ -12186,13 +12186,13 @@ e_Err RTO_Config_Pack(t_Handle RTO_Id, t
     }
   }
 
     memcpy(p_Cfg, p_rtoCfg, sizeof(t_S_RouterCfg));
     XX_Free(p_rtoCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -12258,13 +12258,13 @@ static e_Err IFO_Config_Unpack(void *p_I
 *********************************************************************/
 e_Err IFO_Config_Pack(t_Handle IFO_Id, t_IFO_Cfg *p_Cfg)
 {
     t_IFO_Cfg       *p_ifoCfg;  /* interface configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the interface configuration info */
     p_ifoCfg = XX_Malloc(sizeof(t_IFO_Cfg));
 
     if (!p_ifoCfg)
@@ -12272,13 +12272,13 @@ e_Err IFO_Config_Pack(t_Handle IFO_Id, t
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_ifoCfg, p_Cfg, sizeof(t_IFO_Cfg));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_ifoCfg);
@@ -12310,13 +12310,13 @@ e_Err IFO_Config_Pack(t_Handle IFO_Id, t
         e = IFO_Config(IFO_Id, p_ifoCfg);
     }
 
     memcpy(p_Cfg, p_ifoCfg, sizeof(t_IFO_Cfg));
     XX_Free(p_ifoCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -12367,26 +12367,26 @@ static e_Err ARO_Config_Unpack(void *p_I
 *********************************************************************/
 e_Err ARO_Config_Pack(t_Handle ARO_Id, t_S_AreaCfg *p_Cfg)
 {
     t_S_AreaCfg     *p_aroCfg;  /* ospf area configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the area configuration info */
     p_aroCfg = XX_Malloc(sizeof(t_S_AreaCfg));
     if (!p_aroCfg)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_aroCfg, p_Cfg, sizeof(t_S_AreaCfg));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_aroCfg);
@@ -12418,13 +12418,13 @@ e_Err ARO_Config_Pack(t_Handle ARO_Id, t
         e = ARO_Config(ARO_Id, p_aroCfg);
     }
 
     memcpy(p_Cfg, p_aroCfg, sizeof(t_S_AreaCfg));
     XX_Free(p_aroCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -12558,22 +12558,22 @@ e_Err ospfLsdbAdvertisement_Lookup_Pack(
                                         L7_ospfLsdbEntry_t *p_Lsa,
                                         L7_char8 **p_LsdbAdvertisement)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(p_Lsa == NULL)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -12609,13 +12609,13 @@ e_Err ospfLsdbAdvertisement_Lookup_Pack(
         rc = ospfLsdbAdvertisement_Lookup(LsdbAreaId, LsdbType,
                           LsdbId, LsdbRouterId,
                           p_Lsa,
                           p_LsdbAdvertisement);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -12643,22 +12643,22 @@ e_Err ospfLsdbTable_Lookup_Pack(L7_uint3
                                 L7_uint32 LsdbRouterId,
                                 L7_ospfLsdbEntry_t *p_Lsa)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(p_Lsa == NULL)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -12689,13 +12689,13 @@ e_Err ospfLsdbTable_Lookup_Pack(L7_uint3
     }
     else
     {
         rc = ospfLsdbTable_Lookup(LsdbAreaId, LsdbType, LsdbId, LsdbRouterId, p_Lsa);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -12755,31 +12755,31 @@ e_Err ospfLsdbTable_GetNext_Pack(L7_uint
                                  L7_uint32 *RouterId,
                                  L7_ospfLsdbEntry_t *p_Lsa)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(p_Lsa == NULL)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
         }
 
-        PACKET_INIT(xxci, ospfLsdbTable_GetNext_Unpack, 0, 0, 6, (L7_uint32)areaId);
+        PACKET_INIT(xxci, ospfLsdbTable_GetNext_Unpack, 0, 0, 6, PTR_TO_UINT32(areaId));
         PACKET_PUT(xxci, (L7_uint32 *)Type);
         PACKET_PUT(xxci, (L7_uint32 *)Lsid);
         PACKET_PUT(xxci, (L7_uint32 *)RouterId);
         PACKET_PUT(xxci, (L7_ospfLsdbEntry_t *)p_Lsa);
         PACKET_PUT(xxci, (L7_RC_t *)&rc);
         e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
@@ -12801,13 +12801,13 @@ e_Err ospfLsdbTable_GetNext_Pack(L7_uint
     }
     else
     {
         rc = ospfLsdbTable_GetNext(areaId, Type, Lsid, RouterId, p_Lsa);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -12867,22 +12867,22 @@ e_Err ospfExtLsdbAdvertisement_Lookup_Pa
                                            L7_ospfLsdbEntry_t *p_Lsa,
                                            L7_char8 **p_LsdbAdvertisement)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(p_Lsa == NULL)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -12916,13 +12916,13 @@ e_Err ospfExtLsdbAdvertisement_Lookup_Pa
     {
         rc = ospfExtLsdbAdvertisement_Lookup(LsdbType, LsdbId, LsdbRouterId,
                                  p_Lsa,
                              p_LsdbAdvertisement);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -12946,22 +12946,22 @@ e_Err ospfExtLsdbTable_Lookup_Pack(L7_ui
                                    L7_uint32 LsdbRouterId,
                                    L7_ospfLsdbEntry_t *p_Lsa)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(p_Lsa == NULL)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -12991,13 +12991,13 @@ e_Err ospfExtLsdbTable_Lookup_Pack(L7_ui
     }
     else
     {
         rc = ospfExtLsdbTable_Lookup(LsdbType, LsdbId, LsdbRouterId, p_Lsa);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -13055,31 +13055,31 @@ e_Err ospfExtLsdbTable_GetNext_Pack(L7_u
                                     L7_uint32 *RouterId,
                                     L7_ospfLsdbEntry_t *p_Lsa)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(! p_Lsa)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
         }
 
-        PACKET_INIT(xxci, ospfExtLsdbTable_GetNext_Unpack, 0, 0, 5, (L7_uint32)Type);
+        PACKET_INIT(xxci, ospfExtLsdbTable_GetNext_Unpack, 0, 0, 5, PTR_TO_UINT32(Type));
         PACKET_PUT(xxci, (L7_uint32 *)Lsid);
         PACKET_PUT(xxci, (L7_uint32 *)RouterId);
         PACKET_PUT(xxci, (L7_ospfLsdbEntry_t *)p_Lsa);
         PACKET_PUT(xxci, (L7_RC_t *)&rc);
         e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
 
@@ -13100,13 +13100,13 @@ e_Err ospfExtLsdbTable_GetNext_Pack(L7_u
     }
     else
     {
         rc = ospfExtLsdbTable_GetNext(Type, Lsid, RouterId, p_Lsa);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -13157,26 +13157,26 @@ static e_Err NBO_Config_Unpack(void *p_I
 *********************************************************************/
 e_Err NBO_Config_Pack(t_Handle NBO_Id, t_S_NeighborCfg *p_Cfg)
 {
     t_S_NeighborCfg *p_nboCfg;  /* ospf neighbor configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the neighbor configuration info */
     p_nboCfg = XX_Malloc(sizeof(t_S_NeighborCfg));
     if (!p_nboCfg)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_nboCfg, p_Cfg, sizeof(t_S_NeighborCfg));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_nboCfg);
@@ -13208,13 +13208,13 @@ e_Err NBO_Config_Pack(t_Handle NBO_Id, t
         e = NBO_Config(NBO_Id, p_nboCfg);
     }
 
     memcpy(p_Cfg, p_nboCfg, sizeof(t_S_NeighborCfg));
     XX_Free(p_nboCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13265,13 +13265,13 @@ static e_Err RTO_AsExternalCfg_Unpack(vo
 *********************************************************************/
 e_Err RTO_AsExternalCfg_Pack(t_Handle RTO_Id, t_S_AsExternalCfg *p_Cfg)
 {
   t_S_AsExternalCfg *p_asExtCfg;  /* ospf router object configuration info */
   t_XXCallInfo      *xxci;        /* XX_Call info */
   e_Err             e;
-  L7_int32          currThread = osapiTaskIdSelf();
+  L7_uint64         currThread = osapiTaskIdSelf();
   OS_Thread         *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   /* Fill in the router configuration info */
   p_asExtCfg = XX_Malloc(sizeof(t_S_AsExternalCfg));
   if(!p_asExtCfg)
     return E_NOMEMORY;
@@ -13283,13 +13283,13 @@ e_Err RTO_AsExternalCfg_Pack(t_Handle RT
   Due to a callback for RTO, this function can be called
   on the main OSPF thread.  If this happens, the sync
   semaphore should not be used, AND the call to
   RTO_AsExternalCfg should happen inline
   */
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if(osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
           XX_Free(p_asExtCfg);
@@ -13320,13 +13320,13 @@ e_Err RTO_AsExternalCfg_Pack(t_Handle RT
     e = RTO_AsExternalCfg(RTO_Id, p_asExtCfg);
   }
 
   memcpy(p_Cfg, p_asExtCfg, sizeof(t_S_AsExternalCfg));
   XX_Free(p_asExtCfg);
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
       osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return E_OK;
 }
@@ -13374,16 +13374,16 @@ static e_Err RTO_PurgeExternalLsas_Unpac
 * @end
 *********************************************************************/
 e_Err RTO_PurgeExternalLsas_Pack(t_Handle RTO_Id)
 {
     t_XXCallInfo      *xxci;        /* XX_Call info */
     e_Err             e;
-    L7_int32        currThread = osapiTaskIdSelf();
-    OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
+    L7_uint64         currThread = osapiTaskIdSelf();
+    OS_Thread         *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -13409,13 +13409,13 @@ e_Err RTO_PurgeExternalLsas_Pack(t_Handl
     }
     else
     {
         e = RTO_PurgeExternalLsas(RTO_Id);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13466,26 +13466,26 @@ static e_Err ARO_StubMetric_Unpack(void
 *********************************************************************/
 e_Err ARO_StubMetric_Pack(t_Handle ARO_Id, t_S_StubAreaEntry *p_Cfg)
 {
     t_S_StubAreaEntry   *p_stubCfg;  /* ospf area configuration info */
     t_XXCallInfo        *xxci;      /* XX_Call info */
     e_Err               e;
-    L7_int32            currThread = osapiTaskIdSelf();
+    L7_uint64           currThread = osapiTaskIdSelf();
     OS_Thread           *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the area configuration info */
     p_stubCfg = XX_Malloc(sizeof(t_S_StubAreaEntry));
     if (!p_stubCfg)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_stubCfg, p_Cfg, sizeof(t_S_StubAreaEntry));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_stubCfg);
@@ -13517,13 +13517,13 @@ e_Err ARO_StubMetric_Pack(t_Handle ARO_I
         e = ARO_StubMetric(ARO_Id, p_stubCfg);
     }
 
     memcpy(p_Cfg, p_stubCfg, sizeof(t_S_StubAreaEntry));
     XX_Free(p_stubCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13602,13 +13602,13 @@ static e_Err ARO_AddressRange_Unpack(voi
 *********************************************************************/
 e_Err ARO_AddressRange_Pack(t_S_AreaAggregateEntry *p_Cfg)
 {
     t_S_AreaAggregateEntry  *p_adrRange; /* ospf area configuration info */
     t_XXCallInfo            *xxci;       /* XX_Call info */
     e_Err                   e;
-    L7_int32                currThread = osapiTaskIdSelf();
+    L7_uint64               currThread = osapiTaskIdSelf();
     OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the area configuration info */
     p_adrRange = XX_Malloc(sizeof(t_S_AreaAggregateEntry));
     if (!p_adrRange)
     {
@@ -13616,13 +13616,13 @@ e_Err ARO_AddressRange_Pack(t_S_AreaAggr
     }
 
     /* copy user supplied configuration info */
     memcpy(p_adrRange, p_Cfg, sizeof(t_S_AreaAggregateEntry));
     PACKET_INIT(xxci, ARO_AddressRange_Unpack, 0, 0, 2, (ulng)p_adrRange);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_adrRange);
@@ -13655,13 +13655,13 @@ e_Err ARO_AddressRange_Pack(t_S_AreaAggr
         XX_Free(xxci);
     }
 
     memcpy(p_Cfg, p_adrRange, sizeof(t_S_AreaAggregateEntry));
     XX_Free(p_adrRange);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13712,26 +13712,26 @@ static e_Err ARO_HostConfig_Unpack(void
 *********************************************************************/
 e_Err ARO_HostConfig_Pack(t_Handle ARO_Id, t_S_HostRouteCfg *p_Cfg)
 {
     t_S_HostRouteCfg    *p_hosts;  /* ospf area configuration info */
     t_XXCallInfo        *xxci;      /* XX_Call info */
     e_Err               e;
-    L7_int32            currThread = osapiTaskIdSelf();
+    L7_uint64           currThread = osapiTaskIdSelf();
     OS_Thread           *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the area configuration info */
     p_hosts = XX_Malloc(sizeof(t_S_HostRouteCfg));
     if (!p_hosts)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_hosts, p_Cfg, sizeof(t_S_HostRouteCfg));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_hosts);
@@ -13763,13 +13763,13 @@ e_Err ARO_HostConfig_Pack(t_Handle ARO_I
         e = ARO_HostConfig(ARO_Id, p_hosts);
     }
 
     memcpy(p_Cfg, p_hosts, sizeof(t_S_HostRouteCfg));
     XX_Free(p_hosts);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13819,16 +13819,16 @@ static e_Err ARO_Delete_Unpack(void *p_I
 * @end
 *********************************************************************/
 e_Err ARO_Delete_Pack(t_Handle ARO_Id, ulng flag)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -13855,13 +13855,13 @@ e_Err ARO_Delete_Pack(t_Handle ARO_Id, u
     }
     else
     {
         e = ARO_Delete(ARO_Id, flag);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13918,16 +13918,16 @@ static e_Err IFO_Delete_Unpack(void *p_I
 * @end
 *********************************************************************/
 e_Err IFO_Delete_Pack(t_Handle IFO_Id, ulng flag, L7_uint32 intIfNum)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -13955,13 +13955,13 @@ e_Err IFO_Delete_Pack(t_Handle IFO_Id, u
     }
     else
     {
         e = IFO_Delete(IFO_Id, flag);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14009,16 +14009,16 @@ static e_Err IFO_Up_Unpack(void *p_Info)
 * @end
 *********************************************************************/
 e_Err IFO_Up_Pack(t_Handle IFO_Id)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -14044,13 +14044,13 @@ e_Err IFO_Up_Pack(t_Handle IFO_Id)
     }
     else
     {
         e = IFO_Up(IFO_Id);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14098,16 +14098,16 @@ static e_Err IFO_Down_Unpack(void *p_Inf
 * @end
 *********************************************************************/
 e_Err IFO_Down_Pack(t_Handle IFO_Id)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -14133,13 +14133,13 @@ e_Err IFO_Down_Pack(t_Handle IFO_Id)
     }
     else
     {
         e = IFO_Down(IFO_Id);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14190,26 +14190,26 @@ static e_Err IFO_MetricConfig_Unpack(voi
 *********************************************************************/
 e_Err IFO_MetricConfig_Pack(t_Handle IFO_Id, t_S_IfMetric *p_Cfg)
 {
     t_S_IfMetric    *p_metric;  /* interface configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the interface configuration info */
     p_metric = XX_Malloc(sizeof(t_S_IfMetric));
     if (!p_metric)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_metric, p_Cfg, sizeof(t_S_IfMetric));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_metric);
@@ -14241,13 +14241,13 @@ e_Err IFO_MetricConfig_Pack(t_Handle IFO
         e = IFO_MetricConfig(IFO_Id, p_metric);
     }
 
     memcpy(p_Cfg, p_metric, sizeof(t_S_IfMetric));
     XX_Free(p_metric);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14298,26 +14298,26 @@ static e_Err IFO_AuthKeyConfig_Unpack(vo
 *********************************************************************/
 e_Err IFO_AuthKeyConfig_Pack(t_Handle IFO_Id, t_OspfAuthKey *p_Cfg)
 {
     t_OspfAuthKey   *p_authKeyCfg;  /* auth key configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the auth key configuration info */
     p_authKeyCfg = XX_Malloc(sizeof(t_OspfAuthKey));
     if (!p_authKeyCfg)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_authKeyCfg, p_Cfg, sizeof(t_OspfAuthKey));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_authKeyCfg);
@@ -14349,13 +14349,13 @@ e_Err IFO_AuthKeyConfig_Pack(t_Handle IF
         e = IFO_AuthKeyConfig(IFO_Id, p_authKeyCfg);
     }
 
     memcpy(p_Cfg, p_authKeyCfg, sizeof(t_OspfAuthKey));
     XX_Free(p_authKeyCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14426,13 +14426,13 @@ static e_Err NSSA_Config_Unpack(void *p_
 *********************************************************************/
 e_Err NSSA_Config_Pack(L7_uint32 areaId, t_S_NssaCfg *p_Cfg)
 {
     t_S_NssaCfg     *p_nssaCfg;  /* ospf area configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the NSSA configuration info */
     p_nssaCfg = XX_Malloc(sizeof(t_S_NssaCfg));
     if (!p_nssaCfg)
     {
@@ -14441,13 +14441,13 @@ e_Err NSSA_Config_Pack(L7_uint32 areaId,
 
     /* copy user supplied configuration info */
     memcpy(p_nssaCfg, p_Cfg, sizeof(t_S_NssaCfg));
     PACKET_INIT(xxci, NSSA_Config_Unpack, 0, 0, 3, (ulng)areaId);
     PACKET_PUT(xxci, (ulng)p_nssaCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_nssaCfg);
@@ -14488,13 +14488,13 @@ e_Err NSSA_Config_Pack(L7_uint32 areaId,
         XX_Free(xxci);
     }
 
     memcpy(p_Cfg, p_nssaCfg, sizeof(t_S_NssaCfg));
     XX_Free(p_nssaCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14625,28 +14625,28 @@ static e_Err IFO_Stats_Unpack(void *p_In
 *
 * @end
 *********************************************************************/
 e_Err IFO_Stats_Pack(t_IFO *p_IFO, t_PCK_Stats *intfStats)
 {
   t_XXCallInfo  *xxci;      /* XX_Call info */
-    e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
-    OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
+    e_Err       e;
+    L7_uint64   currThread = osapiTaskIdSelf();
+    OS_Thread   *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   /* Should never be called on OSPF protocol thread */
-    if (currThread == (L7_int32) pThreadGlobal->TaskID)
+    if (currThread == pThreadGlobal->TaskID)
     return E_FAILED;
 
   if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
             "Failed to take OSPF sync semaphore\n");
     return E_FAILED;
   }
 
-  PACKET_INIT(xxci, IFO_Stats_Unpack, 0, 0, 2, (L7_uint32)p_IFO);
+  PACKET_INIT(xxci, IFO_Stats_Unpack, 0, 0, 2, PTR_TO_UINT32(p_IFO));
   PACKET_PUT(xxci, intfStats);
   e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
 
   if (e != E_OK)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
@@ -14741,16 +14741,16 @@ static e_Err RTO_OpaqueCapability_Get_Un
  * @end
  *********************************************************************/
 e_Err RTO_OpaqueCapability_Get_Pack(t_Handle RTO_Id, L7_uint32 *opaqueEnabled)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -14777,13 +14777,13 @@ e_Err RTO_OpaqueCapability_Get_Pack(t_Ha
   }
   else
   {
     e = RTO_OpaqueCapability_Get(RTO_Id, opaqueEnabled);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return e;
 }
@@ -14861,16 +14861,16 @@ static e_Err RTO_OpaqueCapability_Set_Un
  * @end
  *********************************************************************/
 e_Err RTO_OpaqueCapability_Set_Pack(t_Handle RTO_Id, L7_BOOL opaqueEnabled)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -14897,13 +14897,13 @@ e_Err RTO_OpaqueCapability_Set_Pack(t_Ha
   }
   else
   {
     e = RTO_OpaqueCapability_Set(RTO_Id, opaqueEnabled);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return E_OK;
 }
@@ -15050,24 +15050,24 @@ static e_Err ospfAreaOpaqueLsdbTable_Loo
 e_Err ospfAreaOpaqueLsdbTable_Lookup_Pack(L7_uint32 lsdbAreaId,
     L7_uint32 lsdbType, L7_uint32 lsdbId,
     L7_uint32 lsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
-  e_Err                   e;
-  L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
-  OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
+  e_Err           e;
+  L7_RC_t         rc;
+  L7_uint64       currThread = osapiTaskIdSelf();
+  OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -15098,13 +15098,13 @@ e_Err ospfAreaOpaqueLsdbTable_Lookup_Pac
   }
   else
   {
     rc = ospfAreaOpaqueLsdbTable_Lookup(lsdbAreaId, lsdbType, lsdbId, lsdbRouterId, p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -15254,31 +15254,31 @@ e_Err ospfAreaOpaqueLsdbTable_NextLookup
     L7_uint32 *LsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
     }
 
-    PACKET_INIT(xxci, ospfAreaOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 6, (L7_uint32)LsdbAreaId);
+    PACKET_INIT(xxci, ospfAreaOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 6, PTR_TO_UINT32(LsdbAreaId));
     PACKET_PUT(xxci, (L7_int32*)LsdbType);
     PACKET_PUT(xxci, (L7_uint32*)LsdbId);
     PACKET_PUT(xxci, (L7_uint32*)LsdbRouterId);
     PACKET_PUT(xxci, (L7_ospfOpaqueLsdbEntry_t *)p_Lsa);
     PACKET_PUT(xxci, (L7_RC_t *)&rc);
     e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
@@ -15300,13 +15300,13 @@ e_Err ospfAreaOpaqueLsdbTable_NextLookup
   }
   else
   {
     rc = ospfAreaOpaqueLsdbTable_NextLookup(LsdbAreaId, LsdbType, LsdbId, LsdbRouterId, p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -15595,22 +15595,22 @@ e_Err ospfAreaOpaqueAdvertisement_Lookup
     L7_ospfOpaqueLsdbEntry_t *p_Lsa,
     L7_char8 **p_LsdbAdvertisement)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t      temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -15646,13 +15646,13 @@ e_Err ospfAreaOpaqueAdvertisement_Lookup
     rc = ospfType10Advertisement_Lookup(LsdbAreaId, LsdbType,
         LsdbId, LsdbRouterId,
         p_Lsa,
         p_LsdbAdvertisement);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -15823,22 +15823,22 @@ e_Err ospfLinkOpaqueLsdbTable_Lookup_Pac
     L7_uint32 LsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -15871,13 +15871,13 @@ e_Err ospfLinkOpaqueLsdbTable_Lookup_Pac
   else
   {
     rc = ospfLinkOpaqueLsdbTable_Lookup(ipAddr,ifIndex,LsdbType,
         LsdbId,LsdbRouterId,p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -16059,31 +16059,31 @@ e_Err ospfLinkOpaqueLsdbTable_NextLookup
     L7_uint32 *LsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
     }
 
-    PACKET_INIT(xxci, ospfLinkOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 7, (L7_uint32)ipAddr);
+    PACKET_INIT(xxci, ospfLinkOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 7, PTR_TO_UINT32(ipAddr));
     PACKET_PUT(xxci, (L7_int32*)ifIndex);
     PACKET_PUT(xxci, (L7_int32*)LsdbType);
     PACKET_PUT(xxci, (L7_uint32*)LsdbId);
     PACKET_PUT(xxci, (L7_uint32*)LsdbRouterId);
     PACKET_PUT(xxci, (L7_ospfOpaqueLsdbEntry_t *)p_Lsa);
     PACKET_PUT(xxci, (L7_RC_t *)&rc);
@@ -16107,13 +16107,13 @@ e_Err ospfLinkOpaqueLsdbTable_NextLookup
   else
   {
     rc = ospfLinkOpaqueLsdbTable_NextLookup(ipAddr,ifIndex,LsdbType,
         LsdbId,LsdbRouterId,p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -16426,22 +16426,22 @@ e_Err ospfLinkOpaqueAdvertisement_Lookup
     L7_ospfOpaqueLsdbEntry_t *p_Lsa,
     L7_char8 **p_LsdbAdvertisement)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t      temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -16476,13 +16476,13 @@ e_Err ospfLinkOpaqueAdvertisement_Lookup
   else
   {
     rc = ospfType9Advertisement_Lookup(ipAddr,ifIndex,LsdbType,LsdbId,
         LsdbRouterId,p_Lsa,p_LsdbAdvertisement);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -16636,22 +16636,22 @@ e_Err ospfAsOpaqueLsdbTable_Lookup_Pack(
     L7_uint32 LsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -16681,13 +16681,13 @@ e_Err ospfAsOpaqueLsdbTable_Lookup_Pack(
   }
   else
   {
     rc = ospfAsOpaqueLsdbTable_Lookup(LsdbType,LsdbId,LsdbRouterId,p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -16823,31 +16823,31 @@ e_Err ospfAsOpaqueLsdbTable_NextLookup_P
     L7_uint32 *LsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
     }
 
-    PACKET_INIT(xxci, ospfAsOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 5, (L7_uint32)LsdbType);
+    PACKET_INIT(xxci, ospfAsOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 5, PTR_TO_UINT32(LsdbType));
     PACKET_PUT(xxci, (L7_uint32*)LsdbId);
     PACKET_PUT(xxci, (L7_uint32*)LsdbRouterId);
     PACKET_PUT(xxci, (L7_ospfOpaqueLsdbEntry_t *)p_Lsa);
     PACKET_PUT(xxci, (L7_RC_t *)&rc);
     e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
 
@@ -16868,13 +16868,13 @@ e_Err ospfAsOpaqueLsdbTable_NextLookup_P
   }
   else
   {
     rc = ospfAsOpaqueLsdbTable_NextLookup(LsdbType,LsdbId,LsdbRouterId,p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -17148,22 +17148,22 @@ e_Err ospfAsOpaqueAdvertisement_Lookup_P
     L7_ospfOpaqueLsdbEntry_t *p_Lsa,
     L7_char8 **p_LsdbAdvertisement)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t      temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -17196,13 +17196,13 @@ e_Err ospfAsOpaqueAdvertisement_Lookup_P
   else
   {
     rc = ospfType11Advertisement_Lookup(LsdbType,LsdbId,
         LsdbRouterId,p_Lsa,p_LsdbAdvertisement);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -17296,16 +17296,16 @@ static e_Err ospfASOpaqueCksumSum_Get_Un
  * @end
  *********************************************************************/
 e_Err ospfASOpaqueCksumSum_Get_Pack(t_Handle RTO_Id, L7_uint32 *opaqueCksumSum)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -17332,13 +17332,13 @@ e_Err ospfASOpaqueCksumSum_Get_Pack(t_Ha
   }
   else
   {
     e = RTO_ASOpaqueCksumSum_Get(RTO_Id, opaqueCksumSum);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return e;
 }
@@ -17411,16 +17411,16 @@ static e_Err ospfIsStubRtr_Get_Unpack(vo
  * @end
  *********************************************************************/
 e_Err ospfIsStubRtr_Get_Pack(t_Handle RTO_Id, L7_BOOL *isStubRtr)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -17447,13 +17447,13 @@ e_Err ospfIsStubRtr_Get_Pack(t_Handle RT
   }
   else
   {
     e = RTO_IsStubRtr_Get(RTO_Id, isStubRtr);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return e;
 }
@@ -17527,16 +17527,16 @@ static e_Err ospfExtLsdbOverflow_Get_Unp
  * @end
  *********************************************************************/
 e_Err ospfExtLsdbOverflow_Get_Pack(t_Handle RTO_Id, L7_BOOL *extLsdbOverflow)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -17563,13 +17563,13 @@ e_Err ospfExtLsdbOverflow_Get_Pack(t_Han
   }
   else
   {
     e = RTO_ExtLsdbOverflow_Get(RTO_Id, extLsdbOverflow);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return e;
 }
@@ -17641,16 +17641,16 @@ static e_Err ospfGlobalStatus_Unpack(voi
 * @end
 *********************************************************************/
 e_Err ospfGlobalStatus_Pack(t_Handle RTO_Id, L7_ospfStatus_t *status)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* This is for UI to get OSPFv2 status. Should never be called
      * on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
@@ -17727,16 +17727,16 @@ L7_RC_t ospfMapExtenStatusGet(L7_ospfSta
 * @end
 *********************************************************************/
 e_Err ospfNeighborClear_Pack(t_Handle RTO_Id, t_IFO *p_IFO, L7_uint32 routerId)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* This is for UI to get OSPFv2 status. Should never be called
      * on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
@@ -17846,16 +17846,16 @@ L7_RC_t ospfMapExtenNeighborClear(L7_uin
 * @end
 *********************************************************************/
 e_Err ospfCountersClear_Pack(t_Handle RTO_Id)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* Should never be called on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
   PACKET_INIT(xxci, ospfCountersClear_Unpack, 0, 0, 3, (ulng)RTO_Id);
@@ -17901,16 +17901,16 @@ e_Err ospfCountersClear_Pack(t_Handle RT
 * @end
 *********************************************************************/
 e_Err ospfStubRouterClear_Pack(t_Handle RTO_Id)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* Should never be called on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
   PACKET_INIT(xxci, ospfStubRouterClear_Unpack, 0, 0, 3, (ulng)RTO_Id);
@@ -18051,16 +18051,16 @@ L7_RC_t ospfMapExtenStubRouterClear(void
 * @end
 *********************************************************************/
 e_Err ospfBeginGr_Pack(t_Handle RTO_Id)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* Should never be called on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
   PACKET_INIT(xxci, ospfBeginGr_Unpack, 0, 0, 3, (ulng)RTO_Id);
@@ -18155,16 +18155,16 @@ L7_RC_t ospfMapExtenBeginGracefulRestart
 * @end
 *********************************************************************/
 e_Err ospfStartupDone_Pack(t_Handle RTO_Id)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* Should never be called on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
   PACKET_INIT(xxci, ospfStartupDone_Unpack, 0, 0, 3, (ulng)RTO_Id);
@@ -18349,16 +18349,16 @@ static e_Err ospfHelpfulNbrStatus_Unpack
 e_Err ospfHelpfulNbrStatus_Pack(t_Handle RTO_Id, L7_uint32 intIfNum,
                                 L7_uint32 nbrIpAddr,
                                 L7_ospfHelpfulNbrStatus_t *status)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* This is for UI to get OSPFv2 status. Should never be called
      * on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
Index: src/application/routing/mapping/ospfmap/core/ospfmap_debug.c
===================================================================
--- src/application/routing/mapping/ospfmap/core/ospfmap_debug.c	(revision 7768)
+++ src/application/routing/mapping/ospfmap/core/ospfmap_debug.c	(working copy)
@@ -43,13 +43,13 @@ extern struct ospfMapCtrl_s  ospfMapCtrl
 /* Debug functions */
 extern L7_RC_t usmDbInetAton(L7_uchar8 *ipAddr, L7_uint32 *val);
 extern t_IFO * ifoPtrGet(L7_uint32 intIfNum);
 extern L7_RC_t ifoAuthKeyCfgGet(L7_uint32 intIfNum, t_OspfAuthKey *p_Auth);
 extern L7_RC_t virtIfAuthKeyCfgGet(t_Handle IFO_Id, t_OspfAuthKey *p_Auth);
 extern void XX_DisplayQueue(t_Handle threadID, ulng queueId, ulng resolveNames, long maxDepth);
-extern void osapiDebugStackTrace (L7_uint32 task_id, FILE *fp);
+extern void osapiDebugStackTrace (L7_uint64 task_id, FILE *fp);
 
 
 static void ospfRedistCfgBuildTestConfigData(ospfRedistCfg_t *redistCfg, L7_uint32 seed);
 static void ospfDefaultRouteCfgBuildTestConfigData(ospfDefRouteCfg_t *defRouteCfg);
 static void ospfAreaStubCfgDataShow(void);
 static void ospfAreaNssaCfgDataShow(void);
@@ -779,15 +779,15 @@ void ospfMapExtenIFOShow(L7_uint32 unit,
       else
       {
         SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTaken......................................false");
       }
       osapiInetNtoa((L7_uint32)p_IFO->IfoId, debug_buf);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIfoId......................................0x%x  (%-15.15s)", (L7_uint32)p_IFO->IfoId, debug_buf);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLowLayerId.................................0x%x", (L7_uint32)p_IFO->LowLayerId);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nARO_Id.....................................0x%x", (L7_uint32)p_IFO->ARO_Id);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.....................................0x%x", (L7_uint32)p_IFO->RTO_Id);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLowLayerId.................................%p", p_IFO->LowLayerId);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nARO_Id.....................................%p", p_IFO->ARO_Id);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.....................................%p", p_IFO->RTO_Id);
 
       memset(&ifoCfg, 0, sizeof(t_IFO_Cfg));
       memcpy(&ifoCfg, &p_IFO->Cfg, sizeof(t_IFO_Cfg));
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nIFO config Data:");
 
       osapiInetNtoa((L7_uint32)ifoCfg.IpAdr, debug_buf);
@@ -1137,25 +1137,25 @@ void ospfMapExtenIFOShow(L7_uint32 unit,
 
       osapiInetNtoa((L7_uint32)p_IFO->DrId, debug_buf);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nDrId.......................................%-15.15s", debug_buf);
 
       osapiInetNtoa((L7_uint32)p_IFO->BackupId, debug_buf);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nBackupId...................................%-15.15s", debug_buf);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTransitARO.................................0x%x", (L7_uint32)p_IFO->TransitARO);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTransitARO.................................%p", p_IFO->TransitARO);
 
       osapiInetNtoa((L7_uint32)p_IFO->VrtNgbIpAdr, debug_buf);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nVrtNgbIpAdr................................%-15.15s", debug_buf);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nVirtIfIndex................................%u", (L7_uint32)p_IFO->VirtIfIndex);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHelloTimer.................................0x%x", (L7_uint32)p_IFO->HelloTimer);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nWaitTimer..................................0x%x", (L7_uint32)p_IFO->WaitTimer);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNboHl......................................0x%x", (L7_uint32)p_IFO->NboHl);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsAck......................................0x%x", (L7_uint32)p_IFO->LsAck);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAckTimer...................................0x%x", (L7_uint32)p_IFO->AckTimer);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMetricHl...................................0x%x", (L7_uint32)p_IFO->MetricHl);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNbmaHl.....................................0x%x", (L7_uint32)p_IFO->NbmaHl);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAuthKeyHl..................................0x%x", (L7_uint32)p_IFO->AuthKeyHl);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHelloTimer.................................%p", p_IFO->HelloTimer);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nWaitTimer..................................%p", p_IFO->WaitTimer);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNboHl......................................%p", p_IFO->NboHl);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsAck......................................%p", p_IFO->LsAck);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAckTimer...................................%p", p_IFO->AckTimer);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMetricHl...................................%p", p_IFO->MetricHl);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNbmaHl.....................................%p", p_IFO->NbmaHl);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAuthKeyHl..................................%p", p_IFO->AuthKeyHl);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTimeStamp..................................%u", (L7_uint32)p_IFO->TimeStamp);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nCfgMetric..................................%u", (L7_uint32)p_IFO->CfgMetric);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nPacket Statistics:");
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\tRxPackets....................%u", (L7_uint32)p_IFO->PckStats.RxPackets);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\tDiscardPackets...............%u", (L7_uint32)p_IFO->PckStats.DiscardPackets);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\tBadVersion...................%u", (L7_uint32)p_IFO->PckStats.BadVersion);
@@ -1295,13 +1295,13 @@ void ospfMapExtenRTOShow(void)
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTaken......................................true");
   }
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTaken......................................false");
   }
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId......................................0x%x", (L7_uint32)p_RTO->MngId);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId......................................%p", p_RTO->MngId);
 
   memset(&rtrCfg, 0, sizeof(t_S_RouterCfg));
   memcpy(&rtrCfg, &p_RTO->Cfg, sizeof(t_S_RouterCfg));
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nRTO config Data:");
 
   osapiInetNtoa((L7_uint32)rtrCfg.RouterId, debug_buf);
@@ -1408,14 +1408,14 @@ void ospfMapExtenRTOShow(void)
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\tRouterStatus.....................rowModify");
     break;
   default:
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\tRouterStatus.....................unknown");
     break;
   }
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nOspfSysLabel...............................0x%x", (L7_uint32)p_RTO->OspfSysLabel.threadHndle);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfRtbThread..............................0x%x", (L7_uint32)p_RTO->OspfRtbThread.threadHndle);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nOspfSysLabel...............................%p", p_RTO->OspfSysLabel.threadHndle);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfRtbThread..............................%p", p_RTO->OspfRtbThread.threadHndle);
   if (p_RTO->RtbOwnThread == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRtbOwnThread...............................true");
   }
   else
   {
@@ -1427,31 +1427,31 @@ void ospfMapExtenRTOShow(void)
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIsOverflowed...............................true");
   }
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIsOverflowed...............................false");
   }
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOverflowTimer..............................0x%x", (L7_uint32)p_RTO->OverflowTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOverflowTimer..............................%p", p_RTO->OverflowTimer);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nnonDefExtLsaCount..........................0x%x", (L7_uint32)p_RTO->NonDefExtLsaCount);
   
   if (p_RTO->LsdbOverload == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsdbOverload...............................true");
   }
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsdbOverload...............................false");
   }
   
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsExtRoutesHl..............................0x%x", (L7_uint32)p_RTO->AsExtRoutesHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsExternalLsaHl............................0x%x", (L7_uint32)p_RTO->AsExternalLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsOpaqueLsaHl..............................0x%x", (L7_uint32)p_RTO->AsOpaqueLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRtbHl......................................0x%x", (L7_uint32)p_RTO->RtbHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIfoIndexHl.................................0x%x", (L7_uint32)p_RTO->IfoIndexHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nFaIndexHl..................................0x%x", (L7_uint32)p_RTO->FaIndexHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAroHl......................................0x%x", (L7_uint32)p_RTO->AroHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsExtRoutesHl..............................%p", p_RTO->AsExtRoutesHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsExternalLsaHl............................%p", p_RTO->AsExternalLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsOpaqueLsaHl..............................%p", p_RTO->AsOpaqueLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRtbHl......................................%p", p_RTO->RtbHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIfoIndexHl.................................%p", p_RTO->IfoIndexHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nFaIndexHl..................................%p", p_RTO->FaIndexHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAroHl......................................%p", p_RTO->AroHl);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreasNum...................................%u", (L7_uint32)p_RTO->AreasNum);
 }
 
 /*********************************************************************
 * @purpose  debug function to dump the list of prefixes in AsExtRoutesHl
 *
@@ -1631,28 +1631,28 @@ void ospfMapExtenAROShow(L7_uint32 areaI
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOperationState...............................true");
   }
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOperationState...............................false");
   }
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.......................................0x%x", (L7_uint32)p_ARO->RTO_Id);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.......................................%p", p_ARO->RTO_Id);
 
   osapiInetNtoa((L7_uint32)p_ARO->AreaId, debug_buf);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaId.......................................%-15.15s", debug_buf);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId........................................0x%x", (L7_uint32)p_ARO->MngId);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIfoHl........................................0x%x", (L7_uint32)p_ARO->IfoHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAdrRangeHl...................................0x%x", (L7_uint32)p_ARO->AdrRangeHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHostHl.......................................0x%x", (L7_uint32)p_ARO->HostHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRouterLsaHl..................................0x%x", (L7_uint32)p_ARO->RouterLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNetworkLsaHl.................................0x%x", (L7_uint32)p_ARO->NetworkLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNetSummaryLsaHl..............................0x%x", (L7_uint32)p_ARO->NetSummaryLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsBoundSummaryLsaHl..........................0x%x", (L7_uint32)p_ARO->AsBoundSummaryLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNssaLsaHl....................................0x%x", (L7_uint32)p_ARO->NssaLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaOpaqueLsaHl..............................0x%x", (L7_uint32)p_ARO->AreaOpaqueLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nSpfHl........................................0x%x", (L7_uint32)p_ARO->SpfHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nCandidateHl..................................0x%x", (L7_uint32)p_ARO->CandidateHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId........................................%p", p_ARO->MngId);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIfoHl........................................%p", p_ARO->IfoHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAdrRangeHl...................................%p", p_ARO->AdrRangeHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHostHl.......................................%p", p_ARO->HostHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRouterLsaHl..................................%p", p_ARO->RouterLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNetworkLsaHl.................................%p", p_ARO->NetworkLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNetSummaryLsaHl..............................%p", p_ARO->NetSummaryLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsBoundSummaryLsaHl..........................%p", p_ARO->AsBoundSummaryLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNssaLsaHl....................................%p", p_ARO->NssaLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaOpaqueLsaHl..............................%p", p_ARO->AreaOpaqueLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nSpfHl........................................%p", p_ARO->SpfHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nCandidateHl..................................%p", p_ARO->CandidateHl);
 
   if (p_ARO->TransitCapability == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTransitCapability............................true");
   }
   else
@@ -1673,13 +1673,13 @@ void ospfMapExtenAROShow(L7_uint32 areaI
     break;
   default:
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nExternalRoutingCapability....................unknown");
     break;
   }
 
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nStubDefaultCostHl............................0x%x", (L7_uint32)p_ARO->StubDefaultCostHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nStubDefaultCostHl............................%p", p_ARO->StubDefaultCostHl);
 
   switch (p_ARO->ImportSummaries)
   {
   case TRUE:
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nImportSummaries..............................True");
     break;
@@ -1695,14 +1695,14 @@ void ospfMapExtenAROShow(L7_uint32 areaI
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nSpfRuns......................................%u", (L7_uint32)p_ARO->SpfRuns);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaBdrRtrCount..............................%u", (L7_uint32)p_ARO->AreaBdrRtrCount);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsBdrRtrCount................................%u", (L7_uint32)p_ARO->AsBdrRtrCount);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaIntRtrCount..............................%u", (L7_uint32)p_ARO->AreaIntRtrCount);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaLsaCount.................................%u", (L7_uint32)p_ARO->AreaLsaCount);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaLsaCksumSum..............................%u", (L7_uint32)p_ARO->AreaLsaCksumSum);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDelayedLsa...................................0x%x", (L7_uint32)p_ARO->DelayedLsa);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDlyLsaTimer..................................0x%x", (L7_uint32)p_ARO->DlyLsaTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDelayedLsa...................................%p", p_ARO->DelayedLsa);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDlyLsaTimer..................................%p", p_ARO->DlyLsaTimer);
   
 #if 0  
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMcSpfRuns....................................%u", (L7_uint32)p_ARO->McSpfRuns);
 
   switch (p_ARO->McInitCase)
   {
@@ -1724,13 +1724,13 @@ void ospfMapExtenAROShow(L7_uint32 areaI
   default:
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMcInitCase...................................unknown");
     break;
   }
 #endif
 
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfSysLabel.................................0x%x", (L7_uint32)p_ARO->OspfSysLabel.threadHndle);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfSysLabel.................................%p", p_ARO->OspfSysLabel.threadHndle);
 
   if (p_ARO->HasVirtLink == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHasVirtLink..................................true");
   }
   else
@@ -1875,21 +1875,21 @@ void ospfDebugNBOShowPtr(t_NBO * p_NBO)
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOperationState.............................false");
   }
 
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nState......................................%u", (L7_uint32)p_NBO->State);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIFO_Id.....................................0x%x", (L7_uint32)p_NBO->IFO_Id);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.....................................0x%x", (L7_uint32)p_NBO->RTO_Id);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nARO_Id.....................................0x%x", (L7_uint32)p_NBO->ARO_Id);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId......................................0x%x", (L7_uint32)p_NBO->MngId);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nInactivityTimer............................0x%x", (L7_uint32)p_NBO->InactivityTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIFO_Id.....................................%p", p_NBO->IFO_Id);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.....................................%p", p_NBO->RTO_Id);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nARO_Id.....................................%p", p_NBO->ARO_Id);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId......................................%p", p_NBO->MngId);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nInactivityTimer............................%p", p_NBO->InactivityTimer);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nInactivityInterval.........................%u", (L7_uint32)p_NBO->InactivityInterval);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDdRxmtTimer................................0x%x", (L7_uint32)p_NBO->DdRxmtTimer);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRqRxmtTimer................................0x%x", (L7_uint32)p_NBO->RqRxmtTimer);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nSlaveLastDdTimer...........................0x%x", (L7_uint32)p_NBO->SlaveLastDdTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDdRxmtTimer................................%p", p_NBO->DdRxmtTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRqRxmtTimer................................%p", p_NBO->RqRxmtTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nSlaveLastDdTimer...........................%p", p_NBO->SlaveLastDdTimer);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRxmtInterval...............................%u", (L7_uint32)p_NBO->RxmtInterval);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHloIntCount................................%u", (L7_uint32)p_NBO->HloIntCount);
 
   if (p_NBO->IsMaster == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIsMaster...................................true");
@@ -1924,15 +1924,15 @@ void ospfDebugNBOShowPtr(t_NBO * p_NBO)
 
   osapiInetNtoa((L7_uint32)p_NBO->DrId, debug_buf);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDrId.......................................%-15.15s", debug_buf);
 
   osapiInetNtoa((L7_uint32)p_NBO->BackupId, debug_buf);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nBackupId...................................%-15.15s", debug_buf);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLeReTx.....................................0x%x", (L7_uint32)p_NBO->LsReTx);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDbSum......................................0x%x", (L7_uint32)p_NBO->DbSum);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsReq......................................0x%x", (L7_uint32)p_NBO->LsReq);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLeReTx.....................................%p", p_NBO->LsReTx);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDbSum......................................%p", p_NBO->DbSum);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsReq......................................%p", p_NBO->LsReq);
 
   if (p_NBO->ExchOrLoadState == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nExchOrLoadState............................true");
   }
   else
@@ -1973,13 +1973,13 @@ void ospfDebugNBOShowPtr(t_NBO * p_NBO)
   }
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nInitDDSent.................................false");
   }
 
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfSysLabel...............................0x%x", (L7_uint32)p_NBO->OspfSysLabel.threadHndle);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfSysLabel...............................%p", p_NBO->OspfSysLabel.threadHndle);
 }
 
 /*********************************************************************
 * @purpose  debug function to dump the specified NBO structure onto
 *           the screen
 *
@@ -2235,13 +2235,13 @@ void ospfMapNetworkAreaShow()
 *********************************************************************/
 void ospfMsgQLen(L7_uint32 detail)
 {
   L7_int32 i, msgQLen = 0;
   OS_Thread *threadId = (OS_Thread*) ospfMapCtrl_g.ospfThread;
 
-  printf("\nOSPF protocol thread ID:  %#x", (unsigned int) threadId);
+  printf("\nOSPF protocol thread ID: %p", threadId);
   for(i = 0; i < OSPF_NUM_QUEUES; i++)
   {
     if (osapiMsgQueueGetNumMsgs((void*)threadId->QueueID[i], &msgQLen) == L7_SUCCESS)
     {
       SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_OSPFMAP, 
                     "\nOSPF %s (Q%d) length:  %d", 
@@ -2692,13 +2692,13 @@ void ospfOpaqueCapabilitySet(void)
 }
 
 void ospfStackTrace(void)
 {
   OS_Thread		*pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-	osapiDebugStackTrace((L7_int32) pThreadGlobal->TaskID, NULL);
+	osapiDebugStackTrace(pThreadGlobal->TaskID, NULL);
 }
 
 
 /*============================================================================*/
 /*========================  END OF CONFIG MIGRATION DEBUG CHANGES ============*/
 /*============================================================================*/
Index: src/application/routing/mapping/relaymap/include/relay_util.h
===================================================================
--- src/application/routing/mapping/relaymap/include/relay_util.h	(revision 7768)
+++ src/application/routing/mapping/relaymap/include/relay_util.h	(working copy)
@@ -169,13 +169,13 @@ typedef struct ihStats_s
 } ihStats_t;
 
 typedef struct dhcpRelayInfo_s
 {
     /* indicates whether DHCP_RELAY is initialized or not.*/
     L7_BOOL         dhcpRelayInitialized;
-    L7_uint32       dhcpRelayTaskId;
+    L7_uint64       dhcpRelayTaskId;
 
     /* L7_TRUE if sysnet intercept currently registered. */
     L7_BOOL regWithSysnet;
 
   /* IP helper code is run by multiple threads. Packets are 
    * intercepted on the IP MAP forwarding thread. Configuration changes 
Index: src/application/routing/mapping/relaymap/relay_main.c
===================================================================
--- src/application/routing/mapping/relaymap/relay_main.c	(revision 7768)
+++ src/application/routing/mapping/relaymap/relay_main.c	(working copy)
@@ -680,13 +680,13 @@ L7_RC_t ihUdpMessageForward(L7_ipHeader_
   L7_uint32 ipHeaderLen = 0x0F & ipPkt->iph_versLen;   /* 4 byte words */
   L7_udp_header_t *udpHeader;
   L7_ipHeader_t *newIpHeader;
   /* Always building a 14 byte MAC header here */
   L7_uint32 ethHeaderLen = 2 * L7_MAC_ADDR_LEN + sizeof(L7_ushort16);
   L7_ushort16 srcPort, destPort;   /* host byte order */
-  L7_uint32 alignmentShift;
+  L7_uint64 alignmentShift;
 
   /* IP MAP requires packet be in an mbuf. So allocate a new one. Not optimal, but 
    * better than rewriting all the sw forwarding code. */
   SYSAPI_NET_MBUF_GET(bufHandle);
   if (bufHandle == L7_NULL)
   {
@@ -697,13 +697,13 @@ L7_RC_t ihUdpMessageForward(L7_ipHeader_
   SYSAPI_NET_MBUF_SET_LOC(bufHandle, MBUF_LOC_UDP_RELAY_TX);
   SYSAPI_NET_MBUF_GET_DATASTART(bufHandle, dataStart);
 
   /* Be picky about alignment. We know we are going to use a 14-byte
    * ethernet header. Assuming dataStart is 4-byte aligned, this will
    * make the IP header not 4-byte aligned. So move dataStart by 2 bytes. */
-  alignmentShift = ((L7_uint32)dataStart) % 4; 
+  alignmentShift = PTR_TO_UINT64(dataStart) % 4; 
   dataStart += alignmentShift;
   SYSAPI_NET_MBUF_SET_DATASTART(bufHandle, dataStart);
 
   /* Work from the inside out. Copy payload and build UDP header. */
   payloadLength = osapiNtohs(ipPkt->iph_len) - (4 * ipHeaderLen + sizeof(L7_udp_header_t));
   udpHeader = (L7_udp_header_t*) (((L7_uint32*) ipPkt) + ipHeaderLen);
Index: src/application/routing/mapping/relaymap/relaymap.c
===================================================================
--- src/application/routing/mapping/relaymap/relaymap.c	(revision 7768)
+++ src/application/routing/mapping/relaymap/relaymap.c	(working copy)
@@ -442,21 +442,21 @@ void ihTraceFlagsSet(L7_uint32 traceFlag
 void ihDebugShow(void)
 {
   L7_PORT_EVENTS_t event;
 
   if (osapiSemaTake(ihInfo->ihLock, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
-    printf("\nFailed to take IP helper semaphore at %#x.", (L7_uint32) ihInfo->ihLock);
+    printf("\nFailed to take IP helper semaphore at %p.", ihInfo->ihLock);
     return;
   }
-  printf("\nIP helper thread ID:  %#x", ihInfo->dhcpRelayTaskId);
+  printf("\nIP helper thread ID:  %#llx", ihInfo->dhcpRelayTaskId);
   printf("\nMax number of relay entries:  %u", ihCfg->relayEntryList.maxEntries);
   printf("\nCurrent number of relay entries:  %u", ihRelayEntryCount());
   printf("\nServer addr pool ID:  %u", pDhcpRelayInfo->serverPoolId);
   printf("\nPacket pool ID:  %u", pDhcpRelayInfo->packetPoolId);
-  printf("\nIP helper semaphore: %#x", (L7_uint32) ihInfo->ihLock);
+  printf("\nIP helper semaphore: %p", ihInfo->ihLock);
   printf("\nSysnet intercept registered?:  %s", ihInfo->regWithSysnet ? "Yes" : "No");
   printf("\nCurrent trace flags:  %#x", ihInfo->ihTraceFlags);
 
   printf("\nIP Helper registered for the following NIM events:");
   for (event = L7_PORT_DISABLE; event < L7_LAST_PORT_EVENT; event++)
   {
Index: src/application/routing/mapping/ripmap/include/rip_util.h
===================================================================
--- src/application/routing/mapping/ripmap/include/rip_util.h	(revision 7768)
+++ src/application/routing/mapping/ripmap/include/rip_util.h	(working copy)
@@ -59,14 +59,14 @@
 /*  RIP MAP INFO STRUCTURES            */
 /*-------------------------------------*/
 
 typedef struct ripInfo_s     
 {
   L7_BOOL         ripInitialized;           /* indicates vendor RIP stack init'd */
-  L7_uint32       ripTaskId;                /* RIP vendor code task ID */
-  L7_uint32       ripMapProcessingTaskId;   /* RIP mapping layer task ID */
+  L7_uint64       ripTaskId;                /* RIP vendor code task ID */
+  L7_uint64       ripMapProcessingTaskId;   /* RIP mapping layer task ID */
 
   /* The RIP processing thread reads from two message queues. There is a separate
    * queue for redistribution events so that we can give priority to other events,
    * such as interface, router, and configuration events. */
   void           *ripMapProcessQueue;       /* main RIP mapping layer processing queue */
   void           *ripMapRedistQueue;        /* Queue for redistribution events */
Index: src/application/routing/mapping/ripmap/rip_map.c
===================================================================
--- src/application/routing/mapping/ripmap/rip_map.c	(revision 7768)
+++ src/application/routing/mapping/ripmap/rip_map.c	(working copy)
@@ -1746,14 +1746,14 @@ void ripMapDebugShow(void)
   ripMapSemaTake();
 
   RIP_MAP_PRT(RIP_MAP_MSGLVL_ON,
               "RIP Internal Debug Information\n");
 
   RIP_MAP_PRT(RIP_MAP_MSGLVL_ON,
-              "  RIP Control Ctx:  taskSemId=0x%8.8x  taskSemAvail=%d  msgLvl=%d\n",
-              (L7_uint32)ripMapCtrl_g.taskCtrl.semId, ripMapCtrl_g.taskCtrl.semAvail,
+              "  RIP Control Ctx:  taskSemId=0x%llx  taskSemAvail=%d  msgLvl=%d\n",
+              PTR_TO_UINT64(ripMapCtrl_g.taskCtrl.semId), ripMapCtrl_g.taskCtrl.semAvail,
               ripMapCtrl_g.msgLvl);
 
   RIP_MAP_PRT(RIP_MAP_MSGLVL_ON,
               "    traceMode=%d  RIP Initialized=%d  Task Id=0x%8.8x\n",
               ripMapCtrl_g.traceEnabled, pRipInfo->ripInitialized, pRipInfo->ripTaskId);
 
Index: src/application/routing/mapping/ripmap/rip_vend_ctrl.c
===================================================================
--- src/application/routing/mapping/ripmap/rip_vend_ctrl.c	(revision 7768)
+++ src/application/routing/mapping/ripmap/rip_vend_ctrl.c	(working copy)
@@ -1330,13 +1330,13 @@ static int ripRouteEntryDisplay(struct r
                ripMapVendRedistProtoStr[rts->rts_redist_proto]);
 
     if (RT->rt_ifp != 0)
       pIntName = RT->rt_ifp->int_name;
     else
       pIntName = "n/a";
-    RIP_MAP_PRT(RIP_MAP_MSGLVL_ON, "%s (0x%x)\n", pIntName, (L7_uint32)RT->rt_ifp);
+    RIP_MAP_PRT(RIP_MAP_MSGLVL_ON, "%s (0x%llx)\n", pIntName, PTR_TO_UINT64(RT->rt_ifp));
 
   } /* endfor */
 
   return 0;
 }
 
Index: src/application/routing/mapping/rtrdisc/include/rtrdisc_util.h
===================================================================
--- src/application/routing/mapping/rtrdisc/include/rtrdisc_util.h	(revision 7768)
+++ src/application/routing/mapping/rtrdisc/include/rtrdisc_util.h	(working copy)
@@ -31,13 +31,13 @@
 #include "l7_cnfgr_api.h"
 
 
 /* Holds information required by the processing task */
 typedef struct rtrDiscInfo_s
 {
-    L7_uint32       rtrDiscProcessingTaskId;
+    L7_uint64       rtrDiscProcessingTaskId;
     void *          rtrDiscProcessingQueue;
 } rtrDiscInfo_t;
 
 extern rtrDiscInfo_t          *pRtrDiscInfo;
       
 
@@ -96,13 +96,13 @@ typedef struct rtrDiscIntfInfo_s
 * @returns  void
 *       
 * @notes    none
 *       
 * @end
 *********************************************************************/
-void rtrDiscTimerTick(void * parm1, L7_uint32 parm2);
+void rtrDiscTimerTick(L7_uint64 parm1, L7_uint64 parm2);
 
 /*********************************************************************
 * @purpose  Processes the timer tick messages
 *
 * @param    
 *
Index: src/application/routing/mapping/rtrdisc/rtrdisc_util.c
===================================================================
--- src/application/routing/mapping/rtrdisc/rtrdisc_util.c	(revision 7768)
+++ src/application/routing/mapping/rtrdisc/rtrdisc_util.c	(working copy)
@@ -62,13 +62,13 @@ extern osapiTimerDescr_t *pRtrDiscTimerH
 * @returns  void
 *
 * @notes    none
 *
 * @end
 *********************************************************************/
-void rtrDiscTimerTick(void * parm1, L7_uint32 parm2)
+void rtrDiscTimerTick(L7_uint64 parm1, L7_uint64 parm2)
 {
     L7_RC_t rc;
     rtrDiscMsg_t msg;
 
     if (pRtrDiscInfo->rtrDiscProcessingQueue == L7_NULLPTR)
     {
Index: src/application/routing/mapping/vrrpmap/vrrp_cnfgr.c
===================================================================
--- src/application/routing/mapping/vrrpmap/vrrp_cnfgr.c	(revision 7768)
+++ src/application/routing/mapping/vrrpmap/vrrp_cnfgr.c	(working copy)
@@ -45,13 +45,13 @@ vrrpCnfgrState_t vrrpCnfgrState = VRRP_P
 
 extern L7_vrrpMapCfg_t   *pVrrpMapCfgData;
 extern L7_uint32         *vrrpIntfMapTbl;
 extern vrrpRouterBasicConfiguration_t  vrrpBasicConfig_g;
 extern void  *vrrp_Queue;
 extern void     *VrrpConfigSema;
-extern L7_int32  vrrpTaskDaemonId;
+extern L7_uint64 vrrpTaskDaemonId;
 extern vrrpList_t * listMemPool_g[L7_VRRP_INTF_MAX_COUNT + 1];
 extern vrrpRouterInfo_t * routersArray_g[L7_VRRP_INTF_MAX_COUNT + 1];
 extern vrrpIntfInformation_t * vrrpIntfInfoTbl;
 extern L7_uchar8 *  vrrpVRIdToIndexMapTbl[L7_MAX_INTERFACE_COUNT];
 extern osapiTimerDescr_t   *pVRRPAdTimerHolder;
 extern osapiTimerDescr_t   *pVRRPMasterTimerHolder;
Index: src/application/routing/mapping/vrrpmap/vrrp_map.c
===================================================================
--- src/application/routing/mapping/vrrpmap/vrrp_map.c	(revision 7768)
+++ src/application/routing/mapping/vrrpmap/vrrp_map.c	(working copy)
@@ -53,13 +53,13 @@
 L7_int32                L7_vrrp_task_id;
 L7_vrrpMapCfg_t        *pVrrpMapCfgData = L7_NULL;
 
 /* Cannot hold this semaphore when calling an IP MAP API. IP MAP can call
  * ARP, which can call VRRP. Can get a deadlock. */
 void  *                 VrrpConfigSema;
-L7_int32                vrrpTaskDaemonId;
+L7_uint64               vrrpTaskDaemonId;
 L7_uint32              *vrrpIntfMapTbl;
 
 
 /*global variable*/
 extern vrrpList_t* paramHead_g;
 extern L7_short16 totalRouters_g;
@@ -1102,13 +1102,13 @@ void vrrpInfoShow(L7_uint32 intIfNum, L7
 
 
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\n+--------------------------------------------------------+");
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\n|                 VRRP CONFIGURATION DATA                |");
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\n+--------------------------------------------------------+");
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\nvrid..................................%d", (L7_uint32)vrrpInfo->object->vrrpCfgInfo.vrid);                  /* Virtual Router ID           */
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\ndescription..................................%s", (L7_uint32)vrrpInfo->object->vrrpCfgInfo.description);           /* Virtual Router ID  description   */
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\ndescription..................................%s", vrrpInfo->object->vrrpCfgInfo.description);           /* Virtual Router ID  description   */
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\npriority..............................%d", (L7_uint32)vrrpInfo->object->vrrpCfgInfo.priority);              /* Priority                    */
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\nadver_int.............................%d", (L7_uint32)vrrpInfo->object->vrrpCfgInfo.adver_int);             /* Advertisement Interval      */
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\nauth_data.............................");
   for (i=0;i<L7_VRRP_MAX_AUTH_DATA;i++)
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "%c", vrrpInfo->object->vrrpCfgInfo.auth_data[i]);
 
Index: src/application/routing/protocol/ospf/sparo.c
===================================================================
--- src/application/routing/protocol/ospf/sparo.c	(revision 7768)
+++ src/application/routing/protocol/ospf/sparo.c	(working copy)
@@ -255,16 +255,16 @@ void ospfDebugDdShow(char * str, t_A_DbE
     osapiInetNtoa(p_ARO->AreaId, areaIdStr);
   }
   else
   {
     strcpy(areaIdStr, "0");
   }
-  sprintf(traceBuf, "\r\n%s DB %s LSID: %s, Adv Router: %s, Area %s, InitAge: %d, OrgTime %u, SeqNo: 0x%lx, Opt 0x%x, p_Lsa 0x%x, isCur %s",
+  sprintf(traceBuf, "\r\n%s DB %s LSID: %s, Adv Router: %s, Area %s, InitAge: %d, OrgTime %u, SeqNo: 0x%lx, Opt 0x%x, p_Lsa 0x%llx, isCur %s",
           str, lsaTypeNames[p_DbEntry->Lsa.LsType], lsIdStr, advRouterStr, areaIdStr,
           p_DbEntry->InitAge, (unsigned int)p_DbEntry->OrgTime, A_GET_4B(p_DbEntry->Lsa.SeqNum), p_DbEntry->Lsa.Options,
-          (unsigned int)p_DbEntry->p_Lsa, (L7_BIT_ISSET(p_DbEntry->dbFlags, O2_DB_ENTRY_IS_CUR) ? "TRUE" : "FALSE") );
+          PTR_TO_UINT64(p_DbEntry->p_Lsa), (L7_BIT_ISSET(p_DbEntry->dbFlags, O2_DB_ENTRY_IS_CUR) ? "TRUE" : "FALSE") );
   sysapiPrintf(traceBuf);    
 }
 
 
 /*********************************************************************
  * @purpose   Debug utility to print out the aging table.
@@ -5014,13 +5014,13 @@ void ospfDebugVlinks(void)
       L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
       L7_uchar8 nbrIdStr[OSAPI_INET_NTOA_BUF_SIZE];
       L7_uchar8 nbrAddrStr[OSAPI_INET_NTOA_BUF_SIZE];
       L7_uchar8 localAddrStr[OSAPI_INET_NTOA_BUF_SIZE];
       t_ARO *p_transitARO = (t_ARO*) p_IFO->TransitARO;
       RTO_InterfaceName(p_IFO, ifName);
-      printf("\nIFO pointer  %#x", (L7_uint32) p_IFO);
+      printf("\nIFO pointer %p", p_IFO);
       printf("\n\nVirtual interface %s...", ifName);
       printf("\nTransit area ID %lu.", (ulng) p_IFO->Cfg.VirtTransitAreaId);
       if (p_transitARO)
         printf("\nTransit area object %lu.", p_transitARO->AreaId);
       else
         printf("\nNot referencing a transit area.");
@@ -7373,14 +7373,14 @@ static Bool AgingRemoveOverAgedLsa(t_Han
 
     if(p_ARO->ExchOrLoadState)
     {
       if (p_RTO->ospfTraceFlags & OSPF_TRACE_AGING)
       {
          char traceBuf[OSPF_MAX_TRACE_STR_LEN];
-         sprintf(traceBuf, "Skip deleting aged DB 0x%x LSID 0x%08x, area 0x%08x in Exchange/Load state",
-                (L7_uint32)p_DbEntry, (L7_uint32)A_GET_4B(p_DbEntry->Lsa.LsId), (L7_uint32)p_ARO->AreaId);
+         sprintf(traceBuf, "Skip deleting aged DB 0x%llx LSID 0x%08x, area 0x%08x in Exchange/Load state",
+                 PTR_TO_UINT64(p_DbEntry), (L7_uint32)A_GET_4B(p_DbEntry->Lsa.LsId), (L7_uint32)p_ARO->AreaId);
          RTO_TraceWrite(traceBuf);
       }
 
      return TRUE;
     }
 
@@ -7398,14 +7398,14 @@ static Bool AgingRemoveOverAgedLsa(t_Han
          {
            foundInRetxList = TRUE;
 
            if (p_RTO->ospfTraceFlags & OSPF_TRACE_AGING)
            {
               char traceBuf[OSPF_MAX_TRACE_STR_LEN];
-              sprintf(traceBuf, "Skip deleting aged DB 0x%x LSID %x, area %x SeqNo: 0x%x, on NBO %x ReTx list",
-                     (L7_uint32)p_DbEntry, (L7_uint32)(A_GET_4B(p_DbEntry->Lsa.LsId)), 
+              sprintf(traceBuf, "Skip deleting aged DB 0x%llx LSID %x, area %x SeqNo: 0x%x, on NBO %x ReTx list",
+                     PTR_TO_UINT64(p_DbEntry), (L7_uint32)(A_GET_4B(p_DbEntry->Lsa.LsId)), 
                      (L7_uint32)p_ARO->AreaId, (L7_uint32)(A_GET_4B(p_DbEntry->Lsa.SeqNum)), 
                      (L7_uint32)p_NBO->IpAdr);
               RTO_TraceWrite(traceBuf);
            }
          }
 
@@ -7444,14 +7444,14 @@ static Bool AgingRemoveOverAgedLsa(t_Han
     }
     else
     {
       if (p_RTO->ospfTraceFlags & OSPF_TRACE_AGING)
       {
          char traceBuf[OSPF_MAX_TRACE_STR_LEN];
-         sprintf(traceBuf, "Deleting DBE 0x%x type %d on area %x. LSID: %x, Adv Router: %x, Age: %d, SeqNo: 0x%x",
-                (L7_uint32)p_DbEntry, (L7_uint32)p_DbEntry->Lsa.LsType, 
+         sprintf(traceBuf, "Deleting DBE 0x%llx type %d on area %x. LSID: %x, Adv Router: %x, Age: %d, SeqNo: 0x%x",
+                PTR_TO_UINT64(p_DbEntry), (L7_uint32)p_DbEntry->Lsa.LsType, 
                 p_ARO ? (L7_uint32)p_ARO->AreaId : 0, (L7_uint32)A_GET_4B(p_DbEntry->Lsa.LsId), 
                 (L7_uint32)A_GET_4B(p_DbEntry->Lsa.AdvertisingRouter), 
                 (L7_uint32)A_GET_2B(p_DbEntry->Lsa.LsAge), 
                 (L7_uint32)A_GET_4B(p_DbEntry->Lsa.SeqNum));
          RTO_TraceWrite(traceBuf);    
       }
Index: src/application/routing/protocol/ospf/spnbo.c
===================================================================
--- src/application/routing/protocol/ospf/spnbo.c	(revision 7768)
+++ src/application/routing/protocol/ospf/spnbo.c	(working copy)
@@ -3582,14 +3582,14 @@ void ospfDebugNboRetx(t_NBO *p_NBO)
   {
     printf("\nMust supply the memory address of a neighbor.");
     printf("\nUse ospfDebugNBOPrint() to get a list of neighbors.");
     return;
   }
 
-  sprintf(traceBuf, "NBO 0x%x ipaddr %s area 0x%x", 
-    (L7_uint32)p_NBO, osapiInet_ntoa((L7_uint32)p_NBO->IpAdr), 
+  sprintf(traceBuf, "NBO 0x%llx ipaddr %s area 0x%x", 
+    PTR_TO_UINT64(p_NBO), osapiInet_ntoa((L7_uint32)p_NBO->IpAdr), 
     (L7_uint32)((t_ARO*)(p_NBO->ARO_Id))->AreaId);
 
   if(p_NBO->LsReTxHead)
   {
     if(!p_NBO->LsReTxTail)
       strcat(traceBuf, " head but no tail!");
Index: src/application/routing/rlim/rlim.h
===================================================================
--- src/application/routing/rlim/rlim.h	(revision 7768)
+++ src/application/routing/rlim/rlim.h	(working copy)
@@ -61,15 +61,15 @@
 
 /*
  * Operational defines and data structures
  */
 typedef struct {
   void *processQueue;
-  L7_uint32 procTaskHandle;
+  L7_uint64 procTaskHandle;
   void *cnfgrQueue;
-  L7_uint32 cnfgrTaskHandle;
+  L7_uint64 cnfgrTaskHandle;
   osapiTimerDescr_t *ip4NhopChangeTimer;
   osapiTimerDescr_t *tunnelDestAgeTimer;
 
   /* Bit mask of NIM events that RLIM is registered to receive */
   PORTEVENT_MASK_t nimEventMask;
 } rlimOpData_t;
Index: src/application/routing/rlim/rlim_tnnl.c
===================================================================
--- src/application/routing/rlim/rlim_tnnl.c	(revision 7768)
+++ src/application/routing/rlim/rlim_tnnl.c	(working copy)
@@ -733,13 +733,13 @@ void rlimTunnelOpRemoteAddrUpdate(L7_uin
    switch (tcp->remoteAddr.addrType)
    {
      case RLIM_ADDRTYPE_UNDEFINED:
        break;
 
      case RLIM_ADDRTYPE_IP4:
-       rtoNHResCallbackUnregister(tcp->remoteAddr.un.ip4addr, rlimTunnelIp4NhopChangeCallback, (void *)tunnelId);
+       rtoNHResCallbackUnregister(tcp->remoteAddr.un.ip4addr, rlimTunnelIp4NhopChangeCallback, UINT_TO_PTR(tunnelId));
        break;
 
 #if 0 /* not yet */
      case RLIM_ADDRTYPE_IP6:
        rto6NHResCallbackUnregister(&tcp->remoteAddr.un.ip6addr, rlimTunnelIp6NhopChangeCallback, (void *)tunnelId);
        break;
@@ -765,13 +765,13 @@ void rlimTunnelOpRemoteAddrUpdate(L7_uin
   {
     case RLIM_ADDRTYPE_UNDEFINED:
       break;
 
     case RLIM_ADDRTYPE_IP4:
       rlimTunnelIp4ReachabilityCheck(tunnelId);
-      rtoNHResCallbackRegister(tcp->remoteAddr.un.ip4addr, rlimTunnelIp4NhopChangeCallback, (void *)tunnelId);
+      rtoNHResCallbackRegister(tcp->remoteAddr.un.ip4addr, rlimTunnelIp4NhopChangeCallback, UINT_TO_PTR(tunnelId));
       break;
 
 #if 0 /* not yet */
     case RLIM_ADDRTYPE_IP6:
       rlimTunnelIp6ReachabilityCheck(tunnelId);
       rto6NHResCallbackRegister(&tcp->remoteAddr.un.ip6addr, rlimTunnelIp6NhopChangeCallback, (void *)tunnelId);
Index: src/application/routing/rto/rto.c
===================================================================
--- src/application/routing/rto/rto.c	(revision 7768)
+++ src/application/routing/rto/rto.c	(working copy)
@@ -1076,19 +1076,22 @@ L7_RC_t rtoRouteAdd (L7_routeEntry_t *ro
     /* NULL indicates successful insertion */
     if (pData == L7_NULLPTR)
     {
       rtoStats.radix_entries++;
     }
     else
-      L7_LOG_ERROR((L7_uint32) pData);
+    {
+      L7_LOG_ERROR(PTR_TO_UINT32(pData));
+    }
 
     /* Find the new entry so that we can attach route info. */
     pData = radixLookupNode(&rtoRouteTreeData, &routeData.network, &routeData.netmask, L7_RN_EXACT);
     if (!pData)
     {
-      L7_LOG_ERROR("Error: rto.c radix corruption detected!\n"); /* Database corruption. */
+      L7_LOGF(L7_LOG_SEVERITY_CRITICAL, L7_LOG_COMPONENT_DEFAULT,
+              "Error: rto.c radix corruption detected!\n"); /* Database corruption. */
       return L7_FAILURE;
     }          
   }
   else
   {
     /* We already have a route to this destination. Note current best route. */
Index: src/application/routing/rto/rto_debug.c
===================================================================
--- src/application/routing/rto/rto_debug.c	(revision 7768)
+++ src/application/routing/rto/rto_debug.c	(working copy)
@@ -335,13 +335,13 @@ L7_uint32 rtoDebugWalkMkNodes()
 
   osapiReadLockTake(rtoRwLock, L7_WAIT_FOREVER);
   ptr = rtoRouteTreeData.mask_rnhead.rn_masknodefreelist;
   offset_next = RADIX_MASK_NODE_ITEM_OFFSET_NEXT(rtoRouteTreeData.mask_rnhead.max_keylen);
   while (ptr)
   {
-    ptr = (void*)(*((L7_uint32*)((char*)ptr+offset_next)));
+    ptr = UINT_TO_PTR(*((L7_uint32*)((char*)ptr+offset_next)));
     i++;
   }
   osapiReadLockGive(rtoRwLock);
 
   return i;
 }
@@ -362,13 +362,13 @@ L7_uint32 rtoDebugWalkDataNodes()
   osapiReadLockTake(rtoRwLock, L7_WAIT_FOREVER);
   offset_next = rtoRouteTreeData.offset_next;
   ptr = rtoRouteTreeData.rn_datanodefreelist;
 
   while (ptr)
   {
-    ptr=(void*)(*((L7_uint32*)((char*)ptr+offset_next)));
+    ptr=UINT_TO_PTR(*((L7_uint32*)((char*)ptr+offset_next)));
     i++;
   }
   osapiReadLockGive(rtoRwLock);
 
   return i;
 }
Index: src/application/routing/services/rtipforwardmisc.c
===================================================================
--- src/application/routing/services/rtipforwardmisc.c	(revision 7768)
+++ src/application/routing/services/rtipforwardmisc.c	(working copy)
@@ -80,13 +80,13 @@ void rtcreateIcmpErrPckt(struct rtmbuf *
   pkt_len = (int)osapiNtohs(ip->ip_len);
   mcopy->rtm_len = mcopy->rtm_pkthdr.len = rtmin(header_len,pkt_len);
   /*rtm_copydata(m, 0, mcopy->rtm_len, rtmtod(mcopy, caddr_t));*/
   memcpy(mcopy->rtm_data, m->rtm_data, (unsigned int)mcopy->rtm_len);
 
   /* Save the ethernet header so that we can use it search for a VRRP IP address */
-  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)m->rtm_bufhandle, dataStart);
+  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), dataStart);
   if(dataStart != NULL)
      memcpy(mcopy->m_dmac, dataStart, L7_MAC_ADDR_LEN);
   else
      memset(mcopy->m_dmac, 0, L7_MAC_ADDR_LEN);
 }
 
Index: src/application/routing/services/rtiprecv.c
===================================================================
--- src/application/routing/services/rtiprecv.c	(revision 7768)
+++ src/application/routing/services/rtiprecv.c	(working copy)
@@ -105,13 +105,13 @@ void rtLvl7IPRecv(L7_netBufHandle bufHan
   /* Get ifnet structure */
   m->rtm_pkthdr.rcvif = &gRtmIfnet[rtrIfNum];
 
   /* Get the received Physical port number */
   m->rtm_pkthdr.rxPort = pduInfo->rxPort;
 
-  m->rtm_bufhandle = (void *)bufHandle;
+  m->rtm_bufhandle = (void *) UINT_TO_PTR(bufHandle);
   SYSAPI_NET_MBUF_GET_DATASTART(m->rtm_bufhandle, data);
 
   rtmDataOffset = sysNetDataOffsetGet(data);
   m->rtm_data = (caddr_t)(data + rtmDataOffset);
   SYSAPI_NET_MBUF_GET_DATALENGTH(m->rtm_bufhandle, datalen);
 
Index: src/application/routing/services/rtproto.c
===================================================================
--- src/application/routing/services/rtproto.c	(revision 7768)
+++ src/application/routing/services/rtproto.c	(working copy)
@@ -339,14 +339,14 @@ rtoIPv4Handle (L7_netBufHandle bufHandle
 *
 * @notes    none
 *
 * @end
 *********************************************************************/
 static void
-rtIPForwardArpCallback (L7_uint32 mbufHandle,
-                        L7_uint32 callbackparam,
+rtIPForwardArpCallback (L7_uint64 mbufHandle,
+                        L7_uint64 callbackparam,
                         L7_uchar8 *mac,
                         L7_RC_t  rc)
 {
   L7_int32 type = 0, code;
   struct rtmbuf *m, *mcopy;
   cbparam_t *p_callbackparam;
@@ -354,18 +354,18 @@ rtIPForwardArpCallback (L7_uint32 mbufHa
   L7_uchar8 *buffer_addr;
   L7_RC_t rc1;
   L7_uint32 tosEnable;
   L7_uint32 icmpUnreachablesMode = L7_DISABLE;
   L7_uint32 icmpRedirectsMode = L7_DISABLE;
 
-  m = (struct rtmbuf *)mbufHandle;
-  p_callbackparam = (cbparam_t *)callbackparam;
+  m = (struct rtmbuf *) UINT_TO_PTR(mbufHandle);
+  p_callbackparam = (cbparam_t *) UINT_TO_PTR(callbackparam);
 
 #if RTPROTO_DEBUG
-  printf("rtIPForwardArpCallback: rc = %d, intIfNum = %d, bufHandle = 0x%x\n",
-         rc, p_callbackparam->intIfNum, (L7_netBufHandle)m->rtm_bufhandle);
+  printf("rtIPForwardArpCallback: rc = %d, intIfNum = %d, bufHandle = 0x%llx\n",
+         rc, p_callbackparam->intIfNum, (L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
 #endif
 
   /* Can't resolve. Delete the packet.
   */
   if (rc != L7_SUCCESS)
   {
@@ -394,13 +394,13 @@ rtIPForwardArpCallback (L7_uint32 mbufHa
           rtcreateIcmpErrPckt(m, mcopy);
           icmp_error(mcopy, type, code, 0, 0);
         }
       }
     }
 
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle));
     bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) m);
     bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) p_callbackparam);
     return;
   }
 
   /* Send ICMP Redirect if necessary. Do this before sending the packet,
@@ -437,13 +437,13 @@ rtIPForwardArpCallback (L7_uint32 mbufHa
           }
         }
       }
     }
   }
   /* Send the data packet */
-  rtLvl7TxIPForward ( (L7_netBufHandle)m->rtm_bufhandle, p_callbackparam->intIfNum, mac);
+  rtLvl7TxIPForward ( (L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), p_callbackparam->intIfNum, mac);
 
   bufferPoolFree(rtBufferPoolId, (L7_uchar8 *) m);
   bufferPoolFree(rtBufferPoolId, (L7_uchar8 *) p_callbackparam);
 }
 
 
@@ -508,13 +508,13 @@ rtInIPForwardArpTable (L7_uint32 dest_ip
     memset(p,0,sizeof(L7_enetHeader_t));
     p += sizeof(L7_enetHeader_t);
     *(L7_ushort16 *)p = osapiHtons(L7_ETYPE_IP);
     p += 2;
     memcpy(p, m->rtm_data, m->rtm_len);
     SYSAPI_NET_MBUF_SET_DATALENGTH(netMbufHandle, m->rtm_len + (p - pdataStart));
-    m->rtm_bufhandle = (void *)netMbufHandle;
+    m->rtm_bufhandle = (void *) UINT_TO_PTR(netMbufHandle);
   }
 
   callbackparam = 0;
   rc = bufferPoolAllocate (rtBufferPoolId, &buffer_addr);
   if (rc != L7_SUCCESS)
   {
@@ -540,27 +540,27 @@ rtInIPForwardArpTable (L7_uint32 dest_ip
     else
     {
       rc = ipMapArpAddrResolve (intIfNum,
                                 dest_ip_addr,
                                 mac,
                                 rtIPForwardArpCallback,
-                                (L7_uint32)m,
-                                (L7_uint32)callbackparam);
+                                PTR_TO_UINT64(m),
+                                PTR_TO_UINT64(callbackparam));
     }
   }
 
   if (rc == L7_SUCCESS)
   {
     /* ARP entry already resolved. So why did hw not forward the packet?
      * Maybe L2 table entry has aged out. That can happen with asymmetric
      * traffic, where we forward to a neighbor but he doesn't send to us.
      * Update swFwdCount on ARP entry and possibly send an out-of-cycle
      * ARP request to repopulate the L2 table. */
     ipMapArpAddrUsed(dest_ip_addr, intIfNum);
 
-    rtLvl7TxIPForward ( (L7_netBufHandle)m->rtm_bufhandle, intIfNum, mac);
+    rtLvl7TxIPForward ( (L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle), intIfNum, mac);
     bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) m);
     bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) callbackparam);
     return L7_SUCCESS;
   }
 
   /* ARP entry is in progress. ARP will call rtIPForwardArpCallback() when the
@@ -572,13 +572,13 @@ rtInIPForwardArpTable (L7_uint32 dest_ip
       L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
       L7_uchar8 destStr[OSAPI_INET_NTOA_BUF_SIZE];
       osapiInetNtoa(ntohl(dest_ip_addr), destStr);
       sprintf(traceBuf, "ARP in progress for IP address %s", destStr);
       ipMapTraceWrite(traceBuf);
     }
-    SYSAPI_NET_MBUF_SET_LOC((L7_netBufHandle)m->rtm_bufhandle, MBUF_LOC_ARP_PEND_Q);
+    SYSAPI_NET_MBUF_SET_LOC((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle), MBUF_LOC_ARP_PEND_Q);
     return EARPINPROGRESS;
   }
 
   /* Can't resolve. Delete the packet. */
   if (ipMapTraceFlags & IPMAP_TRACE_FORWARDING)
   {
@@ -587,13 +587,13 @@ rtInIPForwardArpTable (L7_uint32 dest_ip
     osapiInetNtoa(ntohl(dest_ip_addr), destStr);
     sprintf(traceBuf, "rtInIPForwardArpTable() failed to resolve IP address %s",
             destStr);
     ipMapTraceWrite(traceBuf);
   }
 
-  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+  SYSAPI_NET_MBUF_FREE((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle));
   bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) m);
   if (callbackparam)
   {
     bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) callbackparam);
   }
   return EHOSTUNREACH;
Index: src/application/routing/vendor/freebsd/forwarding/rtin_cksum.c
===================================================================
--- src/application/routing/vendor/freebsd/forwarding/rtin_cksum.c	(revision 7768)
+++ src/application/routing/vendor/freebsd/forwarding/rtin_cksum.c	(working copy)
@@ -121,13 +121,13 @@ rtin_cksum(m, len)
 		if (len < mlen)
 			mlen = len;
 		len -= mlen;
 		/*
 		 * Force to even boundary.
 		 */
-		if ((1 & (int) w) && (mlen > 0)) {
+		if ((1 & PTR_TO_UINT32(w)) && (mlen > 0)) {
 			REDUCE;
 			sum <<= 8;
 			s_util.c[0] = *(u_char *)w;
 			w = (u_short *)((char *)w + 1);
 			mlen--;
 			byte_swapped = 1;
Index: src/application/routing/vendor/freebsd/forwarding/rtip_input.c
===================================================================
--- src/application/routing/vendor/freebsd/forwarding/rtip_input.c	(revision 7768)
+++ src/application/routing/vendor/freebsd/forwarding/rtip_input.c	(working copy)
@@ -249,13 +249,13 @@ ip_input(struct rtmbuf *m)
   if (m->rtm_pkthdr.len < sizeof(struct ip))
     goto tooshort;
 
   if (m->rtm_len < sizeof (struct ip))
   {
     L7_ipstat.ips_toosmall++;
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle));
     rtm_freem(m);
     return;
   }
   ip = rtmtod(m, struct ip *);
 
   if (IP_VHL_V(ip->ip_vhl) != IPVERSION)
@@ -419,19 +419,19 @@ ip_input(struct rtmbuf *m)
   ** is freed here if the caller consumes it.  So, the interceptor should make a copy of the
   ** frame if processing is done on another task.
   */
   memset(&pduInfo, 0, sizeof(sysnet_pdu_info_t));
   pduInfo.intIfNum = m->rtm_pkthdr.rcvif->if_index;
 
-  if (SYSNET_PDU_INTERCEPT(L7_AF_INET, SYSNET_INET_VALID_IN, (L7_netBufHandle)m->rtm_bufhandle,
+  if (SYSNET_PDU_INTERCEPT(L7_AF_INET, SYSNET_INET_VALID_IN, (L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle),
                            &pduInfo, L7_NULLPTR, &hookVerdict) == L7_TRUE)
   {
     /* If freed by intercept call, don't free it again */
     if (hookVerdict != SYSNET_PDU_RC_DISCARD)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle));
     }
       rtm_freem(m);
       if (hookVerdict == SYSNET_PDU_RC_DISCARD)
         SYSAPI_IP_STATS_INCREMENT(FD_CNFGR_NIM_MIN_CPU_INTF_NUM,
                                   L7_PLATFORM_CTR_RX_IP_IN_DISCARDS);
       return;
@@ -497,13 +497,13 @@ ip_input(struct rtmbuf *m)
      * ip_mforward() returns a non-zero value, the packet
      * must be discarded, else it may be accepted below.
      */
 
       if (mfcIpv4PktRecv(ip, m->rtm_pkthdr.rcvif, m, 0) != L7_FALSE) {
           L7_ipstat.ips_cantforward++;
-          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+          SYSAPI_NET_MBUF_FREE((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle));
           rtm_freem(m);
           return;
       }
   }
 #endif /* L7_MCAST_PACKAGE */
 
@@ -572,24 +572,24 @@ ip_input(struct rtmbuf *m)
   /*
    * Not for us; forward if possible and desirable.
    */
   if (rtipforwarding == 0)
   {
     L7_ipstat.ips_cantforward++;
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
     rtm_freem(m);
 
   }
   else
     ip_forward(m, 0);
   return;
 
   ours:
 
   intIfNum = m->rtm_pkthdr.rcvif->if_index;
-  if (ipmRecvLocal((L7_netBufHandle)m->rtm_bufhandle,intIfNum) != L7_SUCCESS)
+  if (ipmRecvLocal((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle),intIfNum) != L7_SUCCESS)
   {
     SYSAPI_IP_STATS_INCREMENT(FD_CNFGR_NIM_MIN_CPU_INTF_NUM,
                               L7_PLATFORM_CTR_RX_IP_IN_DISCARDS);
   }
 
   /* The corresponding sysapi network buffer (m->rtm_bufhandle) does not need to be
@@ -597,13 +597,13 @@ ip_input(struct rtmbuf *m)
   ** wrapper function.
    */
   rtm_freem(m);
     return;
 
   bad:
-  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
   rtm_freem(m);
 
 }
 
 /*
  * Do option processing on a datagram,
@@ -768,13 +768,13 @@ struct rtmbuf *m;
         else
         {
           /*
            * Not acting as a router, so silently drop.
            */
           L7_ipstat.ips_cantforward++;
-          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
           rtm_freem(m);
           return(1);
         }
       }
 
       /*
@@ -1033,13 +1033,13 @@ struct rtmbuf *m;
       mcopy->rtm_pkthdr.rcvif = m->rtm_pkthdr.rcvif;
       rtcreateIcmpErrPckt(m, mcopy);
       icmp_error(mcopy, type, code, 0, 0);
     }
   }
 
-  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
   rtm_freem(m);
   return(1);
 }
 
 /*
  * Save incoming source route for use in replies,
@@ -1247,19 +1247,19 @@ int srcrt;
   ** is freed here if the caller consumes it.  So, the interceptor should make a copy of the
   ** frame if processing is done on another task.
   */
   memset(&pduInfo, 0, sizeof(sysnet_pdu_info_t));
   pduInfo.intIfNum = m->rtm_pkthdr.rcvif->if_index;
 
-  if (SYSNET_PDU_INTERCEPT(L7_AF_INET, SYSNET_INET_FORWARD_IN, (L7_netBufHandle)m->rtm_bufhandle,
+  if (SYSNET_PDU_INTERCEPT(L7_AF_INET, SYSNET_INET_FORWARD_IN, (L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle),
                            &pduInfo, L7_NULLPTR, &hookVerdict) == L7_TRUE)
   {
     /* If freed by intercept call, don't free it again */
     if (hookVerdict != SYSNET_PDU_RC_DISCARD)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
     }
     rtm_freem(m);
     return;
   }
 
   dest = 0;
@@ -1313,13 +1313,13 @@ int srcrt;
   if (((m->rtm_flags & M_MCAST) && ((m->rtm_flags & M_BCAST) != M_BCAST)) ||
       ((m->rtm_flags & M_BCAST) && ntohl(ip->ip_dst.s_addr) == 0xffffffff) ||
       rtin_canforward(ip->ip_dst) == 0)
 #endif /* L7_ORIGINAL_VENDOR_CODE */
   {
     L7_ipstat.ips_cantforward++;
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
     rtm_freem(m);
     return;
   }
 
     if (ip->ip_ttl <= IPTTLDEC)
     {
@@ -1332,13 +1332,13 @@ int srcrt;
         memset(mcopy, 0, sizeof( *mcopy));
         mcopy->rtm_pkthdr.rcvif = m->rtm_pkthdr.rcvif;
         rtcreateIcmpErrPckt(m, mcopy);
         icmp_error(mcopy, ICMP_TIMXCEED, ICMP_TIMXCEED_INTRANS, dest, 0);
       }
 
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
       rtm_freem(m);
       /* lvl7_@ip_forward end*/
       return;
     }
 
   /* lvl7_@ip_forward start*/
@@ -1384,13 +1384,13 @@ int srcrt;
           icmp_error(mcopy, ICMP_UNREACH, ICMP_UNREACH_TOSNET, dest, 0);
         else
           icmp_error(mcopy, ICMP_UNREACH, ICMP_UNREACH_NET, dest, 0);
       }
     }
 
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
     rtm_freem(m);
     return;
   }
 
   /* Type 2 and type 3 differentiation is done here. Check the note at the
      begining of this function. Type 3 should be dropped here.
@@ -1405,13 +1405,13 @@ int srcrt;
     if ((osapiNtohl(ip->ip_dst.s_addr) & (~netMask)) != (~netMask))
 #else /* L7_ORIGINAL_VENDOR_CODE */
     if ((ntohl(ip->ip_dst.s_addr) & (~netMask)) != (~netMask))
 #endif /* L7_ORIGINAL_VENDOR_CODE */
     {
       L7_ipstat.ips_cantforward++;
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
       rtm_freem(m);
       return;
     }
   }
 
 #ifndef L7_ORIGINAL_VENDOR_CODE
@@ -1430,41 +1430,41 @@ int srcrt;
         /* Get an mbuf to make a copy of the packet to be forwarded. Receive
          * mbuf will be consumed locally. */
         SYSAPI_NET_MBUF_GET(netMbufHandle);
         if (netMbufHandle == L7_NULL)
         {
           /* Cant forward. Can still consume locally */
-          SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)m->rtm_bufhandle, olddataStart);
+          SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), olddataStart);
           memcpy(&olddataStart[0], (L7_char8 *)rtetherbroadcastaddr, 6);
-          ipmRecvLocal((L7_netBufHandle)m->rtm_bufhandle,MyLocalIfIndex);
+          ipmRecvLocal((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle),MyLocalIfIndex);
 
-          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
           rtm_freem(m);
           return ;
         }
         SYSAPI_NET_MBUF_GET_DATASTART(netMbufHandle, pdataStart);
-        SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)m->rtm_bufhandle, olddataStart);
-        SYSAPI_NET_MBUF_GET_DATALENGTH((L7_netBufHandle)m->rtm_bufhandle, datalen);
+        SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), olddataStart);
+        SYSAPI_NET_MBUF_GET_DATALENGTH((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), datalen);
         memcpy(&pdataStart[0], &olddataStart[0], datalen);
 
         SYSAPI_NET_MBUF_SET_DATALENGTH(netMbufHandle, datalen);
 
       }
 
-      SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)m->rtm_bufhandle, olddataStart);
+      SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), olddataStart);
       memcpy(&olddataStart[0], (L7_char8 *)rtetherbroadcastaddr, 6);
-      ipmRecvLocal((L7_netBufHandle)m->rtm_bufhandle,MyLocalIfIndex);
+      ipmRecvLocal((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle),MyLocalIfIndex);
 
       if (netDirectBCastsEnable != L7_ENABLE)
       {
         L7_ipstat.ips_noroute++;
         rtm_freem(m);
         return;
       }
       else
-        m->rtm_bufhandle = (void *)netMbufHandle;
+        m->rtm_bufhandle = (void *)UINT_TO_PTR(netMbufHandle);
     }
 
   }
   else
   {
     if (~netMask)
@@ -1476,13 +1476,13 @@ int srcrt;
 #endif /* L7_ORIGINAL_VENDOR_CODE */
       {
         netDirectBCastsEnable = ipMapRtrIntfNetDirectBcastsGet(MyLocalIfIndex);
         if (netDirectBCastsEnable != L7_ENABLE)
         {
           L7_ipstat.ips_noroute++;
-          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
           rtm_freem(m);
           return;
         }
 
       }
     }
@@ -1500,13 +1500,13 @@ int srcrt;
   if ((netMask != L7_NULL_IP_MASK) && (netMask != 0xffffffff) &&
       ((ntohl(ip->ip_dst.s_addr) & (~netMask)) == L7_NULL_IP_ADDR))
 #endif /* L7_ORIGINAL_VENDOR_CODE */
   {
     /* Discard the packet. */
     L7_ipstat.ips_cantforward++;
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
     rtm_freem(m);
     return;
   }
 
   /* lvl7_@ip_forward end*/
 
@@ -1594,24 +1594,24 @@ if ((MyLocalIfIndex == m->rtm_pkthdr.rcv
   if (icmpSendRedirectMode == L7_DISABLE || icmpIfSendRedirectMode == L7_DISABLE)
   {
     icmpCtlStats.totalSuppressedRedirects++;
   }
 }
 error = 0;
-  if ((sysapiNetMbufGetRxReasonCode((L7_netBufHandle)m->rtm_bufhandle)&
+  if ((sysapiNetMbufGetRxReasonCode((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle))&
               L7_MBUF_RX_REASON_ICMP_REDIR) == 0 )
   {
 #endif /* L7_ORIGINAL_VENDOR_CODE */
     error = rtip_output(m, (struct rtmbuf *)0, routerIP, netMask, MyLocalIfIndex,
                       IP_FORWARDING, 0, srcrt);
 #ifndef L7_ORIGINAL_VENDOR_CODE
   }
   else
   {
      if (m->rtm_bufhandle != NULL)
-                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
         rtm_freem(m);
   }
 #endif /* L7_ORIGINAL_VENDOR_CODE */
 
   if (error && error != EARPINPROGRESS)
     /* lvl7_@ip_forward end*/
Index: src/application/routing/vendor/freebsd/forwarding/rtip_output.c
===================================================================
--- src/application/routing/vendor/freebsd/forwarding/rtip_output.c	(revision 7768)
+++ src/application/routing/vendor/freebsd/forwarding/rtip_output.c	(working copy)
@@ -93,13 +93,13 @@ rtip_output(m0, opt, routerIP, netMask,
   */
   memset(&pduInfo, 0, sizeof(sysnet_pdu_info_t));
   if (m->rtm_pkthdr.rcvif != (struct rtm_ifnet *)0)
     pduInfo.intIfNum = m->rtm_pkthdr.rcvif->if_index;
   pduInfo.destIntIfNum = intIfNum;
   if (SYSNET_PDU_INTERCEPT(L7_AF_INET, SYSNET_INET_RECV_OUT,
-                           (L7_netBufHandle)m->rtm_bufhandle,
+                           (L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle),
                            &pduInfo, L7_NULLPTR, &hookVerdict) == L7_TRUE)
   {
     if (hookVerdict == SYSNET_PDU_RC_DISCARD)
       SYSAPI_IP_STATS_INCREMENT(FD_CNFGR_NIM_MIN_CPU_INTF_NUM, 
                                 L7_PLATFORM_CTR_TX_IP_OUT_DISCARDS);
     rtm_freem(m);
@@ -209,13 +209,13 @@ rtip_output(m0, opt, routerIP, netMask,
 		 * are not sent -- the above call to ip_mloopback() will
 		 * loop back a copy if this host actually belongs to the
 		 * destination group on the loopback interface.
 		 */
 		if (ip->ip_ttl == 0 || ifp->if_flags & IFF_LOOPBACK) {
             if (m->rtm_bufhandle != NULL)
-                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
 			rtm_freem(m);
             goto done;
 		}
 
 		goto sendit;
 	}
@@ -257,13 +257,13 @@ sendit:
                                 L7_PLATFORM_CTR_TX_IP_OUT_DISCARDS);
 	 goto bad;
 done:
 	return (error);
 bad:
     if (m->rtm_bufhandle != NULL)
-                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
 	rtm_freem(m0);
     goto done;
 }
 
 
 
