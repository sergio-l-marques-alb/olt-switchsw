Index: andl/hapi/esw/ip_mcast/broad_l3_mcast.c
===================================================================
--- andl/hapi/esw/ip_mcast/broad_l3_mcast.c	(revision 7375)
+++ andl/hapi/esw/ip_mcast/broad_l3_mcast.c	(revision 7378)
@@ -1781,13 +1781,13 @@ L7_RC_t hapiBroadRoutingIntfMcastSnoopAs
       if (memcmp(mcastMacAddr, tempMcastMacAddr, L7_MAC_ADDR_LEN) == 0)
       {
 /************** RPF interface modify code ***********************/
         if (dapiCmd->cmdData.mcastModify.outIntfDirection == DAPI_SNOOP_L3_NOTIFY_INGRESS)
         {
           if (memcmp(&(BroadGroupList[tableIndex].rpf_usp),
-                     outRtrPortUsp, sizeof(outRtrPortUsp)) == 0)
+                     outRtrPortUsp, sizeof(*outRtrPortUsp)) == 0)
           {
             if (dapiCmd->cmdData.mcastModify.snoopVlanOperState == L7_TRUE)
             {
              HAPI_L3_MCAST_DEBUG("\nTable Index %u L2 Bitmap of entries with rpf_us %u/%u/%u modified. Make specified list as part of L2 Bitmap.",
                                tableIndex,
                                BroadGroupList[tableIndex].rpf_usp.unit,
@@ -2233,13 +2233,13 @@ L7_RC_t hapiBroadRoutingIntfMcastAsyncAd
       rv = usl_bcmx_ipmc_remove(&ipmc_info, 0);
       if ((L7_BCMX_OK(rv) != L7_TRUE))
       {
         /* Delete failed; complain */
         L7_LOGF (L7_LOG_SEVERITY_CRITICAL, L7_DRIVER_COMPONENT_ID,
                  "usl_bcmx_ipmc_remove failed: group = %08X, source = %08X, vlan = %5d, rv = %d\n",
-                       groupIp, srcAddr, old_vlan_id, rv);
+                 groupIp.addr.ipv4.s_addr, srcAddr.addr.ipv4.s_addr, old_vlan_id, rv);
       }
       else /* ((L7_BCMX_OK(rv) != L7_TRUE)) */
       {
         /* Delete successful; account for it no longer being in hardware */
         BroadGroupList[tableIndex].flags &= ~BROAD_GROUP_ENTRY_FLAGS_IN_HW;
         groupEntriesInHw--;
@@ -2476,13 +2476,13 @@ L7_RC_t hapiBroadRoutingIntfMcastAsyncDe
     if (BroadGroupList[table_index].flags & BROAD_GROUP_ENTRY_FLAGS_IN_HW)
     {
       /* the entry *should* have been in the hardware table, but we couldn't delete it */
       /* since we just found it, this could indicate problems, but *maybe* not fatal */
       L7_LOGF (L7_LOG_SEVERITY_ALERT, L7_DRIVER_COMPONENT_ID,
                "usl_bcmx_ipmc_remove failed: group = %x, source = %x, vlan = %d, rv = %d\n",
-               groupIp, srcAddr, vlan_id, rv);
+               groupIp.addr.ipv4.s_addr, srcAddr.addr.ipv4.s_addr, vlan_id, rv);
     }
   }
   if (BroadGroupList[table_index].flags & BROAD_GROUP_ENTRY_FLAGS_IN_HW)
   {
     /* Account for the entry not being in hardware now */
     groupEntriesInHw--;
Index: andl/hapi/esw/switching/broad_l2_lag.c
===================================================================
--- andl/hapi/esw/switching/broad_l2_lag.c	(revision 7375)
+++ andl/hapi/esw/switching/broad_l2_lag.c	(revision 7378)
@@ -139,13 +139,13 @@ L7_RC_t hapiBroadLagAsyncDoneWait(L7_int
                          L7_WAIT_FOREVER, 
                          L7_MSG_PRIORITY_NORM);
   if (rc != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID,
             "Lag async done message send failed on Driver Lag queue 0x%x",
-            hapiBroadLagAsyncCmdQueue);
+            (L7_uint32) hapiBroadLagAsyncCmdQueue);
     return rc;
   }
 
   /* Signal the L2 Async task that work is pending. */
   (void)hapiBroadL2AsyncTaskSignal();
 
@@ -159,13 +159,13 @@ L7_RC_t hapiBroadLagAsyncDoneWait(L7_int
 
   rc = osapiSemaTake(hapiBroadLagAsyncDoneSema, wait);
   if (rc != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_DRIVER_COMPONENT_ID,
             "Lag Async done message wait timeout on lag queue 0x%x, timeout %d secs",
-            hapiBroadLagAsyncCmdQueue, timeout);
+            (L7_uint32) hapiBroadLagAsyncCmdQueue, timeout);
   }
 
   return rc;
 }
 
 /*********************************************************************
@@ -1705,13 +1705,13 @@ L7_RC_t hapiBroadLagPortAsyncDelete(DAPI
         PT_LOG_DEBUG(LOG_CTX_TRUNKS, "(lagMemberSet[%d].usp.unit == cmdLagPortDelete->cmdData.lagPortDelete.memberSet[entry].unit): %u",
                   searchEntry, cond1);
         PT_LOG_DEBUG(LOG_CTX_TRUNKS, "(lagMemberSet[%d].usp.slot == cmdLagPortDelete->cmdData.lagPortDelete.memberSet[entry].slot): %u",
                   searchEntry, cond2);
         PT_LOG_DEBUG(LOG_CTX_TRUNKS, "(lagMemberSet[%d].usp.port == cmdLagPortDelete->cmdData.lagPortDelete.memberSet[entry].port): %u",
                   searchEntry, cond3);
-        PT_LOG_DEBUG(LOG_CTX_TRUNKS, "Total: %u\n", __FUNCTION__, __LINE__, cond);
+        PT_LOG_DEBUG(LOG_CTX_TRUNKS, "Total: %u\n", cond);
       }
 
       /* This code was never asserted as true, although all the conditions were right... weird! */
 //    if ((lagMemberSet[searchEntry].inUse    == L7_TRUE) &&
 //        (lagMemberSet[searchEntry].usp.unit == cmdLagPortDelete->cmdData.lagPortDelete.memberSet[entry].unit) &&
 //        (lagMemberSet[searchEntry].usp.slot == cmdLagPortDelete->cmdData.lagPortDelete.memberSet[entry].slot) &&
Index: andl/hapi/esw/qos/broad_cos.c
===================================================================
--- andl/hapi/esw/qos/broad_cos.c	(revision 7375)
+++ andl/hapi/esw/qos/broad_cos.c	(revision 7378)
@@ -1169,14 +1169,16 @@ static L7_RC_t hapiBroadQosCosApplyPolic
                                                 qos->dscpMap,
                                                 qosPortPtr->cos.defaultCos,
                                                 qos->dscpMapDirty);
         #endif
 
         if (result == L7_SUCCESS)
+        {
            qos->dscpMapDirty = L7_FALSE;
            qosPortPtr->cos.dscpMapDirty = L7_FALSE;   /* PTin added: CoS */
+        }
         break;
 
 #if defined(FEAT_METRO_CPE_V1_0)
     case DAPI_QOS_COS_INTF_MODE_TRUST_UNSET_IPDSCP:
         hapiBroadQosCosResetDscpMapping(dstPortPtr->bcmx_lport);
         qosPortPtr->cos.trustMode = DAPI_QOS_COS_INTF_MODE_UNTRUSTED;
Index: andl/hapi/esw/usl/port/l7_rpc_port.c
===================================================================
--- andl/hapi/esw/usl/port/l7_rpc_port.c	(revision 7375)
+++ andl/hapi/esw/usl/port/l7_rpc_port.c	(revision 7378)
@@ -16,12 +16,17 @@
 *
 * @author     nshrivastav
 * @end
 *
 **********************************************************************/
 
+#if (__GNUC__ >= 6) /* PTin added */
+#pragma GCC diagnostic ignored "-Waggressive-loop-optimizations"
+#endif
+
+
 #include "l7_common.h"
 #include "log.h"
 #include "sysapi_hpc.h"
 #include "l7_rpc_port.h"
 
 #include "sal/core/libc.h"
Index: andl/hapi/esw/base/base/broad_init.c
===================================================================
--- andl/hapi/esw/base/base/broad_init.c	(revision 7375)
+++ andl/hapi/esw/base/base/broad_init.c	(revision 7378)
@@ -2057,21 +2057,21 @@ L7_RC_t hapiBroadPhysicalPortMapGet(L7_u
       }
 
       /* Configure the uport in bcmx */
       HAPI_BROAD_USP_TO_UPORT(&usp,uport);
       bcmx_uport_set(hapiPortPtr->bcmx_lport, uport);
 
-      PT_LOG_INFO(LOG_CTX_STARTUP,"usp={%d,%d,%d} lport=0x%x uport=0x%x",usp.unit, usp.slot, usp.port, hapiPortPtr->bcmx_lport, uport);
+      PT_LOG_INFO(LOG_CTX_STARTUP,"usp={%d,%d,%d} lport=0x%x uport=0x%x",usp.unit, usp.slot, usp.port, hapiPortPtr->bcmx_lport, (L7_uint32) uport);
 
       hapiPortPtr->bcm_modid = BCM_GPORT_MODPORT_MODID_GET (hapiPortPtr->bcmx_lport);
       mod_port               = BCM_GPORT_MODPORT_PORT_GET(hapiPortPtr->bcmx_lport);
 
       if ((hapiPortPtr->bcm_modid == HAPI_BROAD_INVALID_MODID) ||
           (mod_port == HAPI_BROAD_INVALID_MODPORT))
       {
-        PT_LOG_ERR(LOG_CTX_STARTUP,"Invalid usp={%d,%d,%d} lport=0x%x uport=0x%x\r\n",usp.unit, usp.slot, usp.port, hapiPortPtr->bcmx_lport, uport);
+        PT_LOG_ERR(LOG_CTX_STARTUP,"Invalid usp={%d,%d,%d} lport=0x%x uport=0x%x\r\n",usp.unit, usp.slot, usp.port, hapiPortPtr->bcmx_lport, (L7_uint32) uport);
         L7_LOG_ERROR(0);
       }
 
       hapiBroadModidModportToLportSet (hapiPortPtr->bcm_modid,
                                        mod_port,
                                        hapiPortPtr->bcmx_lport);
@@ -2331,23 +2331,23 @@ L7_RC_t hapiBroadBcmxRegisterUnit(L7_ush
   BCMX_UNIT_ITER(bcm_unit, i)
   {
     rv = bcmx_linkscan_device_add(bcm_unit);
     if (L7_BCMX_OK(rv) != L7_TRUE)
     {
       L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_DRIVER_COMPONENT_ID,
-              "Driver: Failed to attach card %s/%d at linkscan, error code %d\n", 
+              "Driver: Failed to attach card %d/%d at linkscan, error code %d\n", 
               unitNum, slotNum, rv);
       result = L7_FAILURE;
       return result;
     }
 
     rv = bcmx_rx_device_add (bcm_unit);
     if (L7_BCMX_OK(rv) != L7_TRUE)
     {
       L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_DRIVER_COMPONENT_ID,
-              "Driver: Failed to attach card %s/%d in rx subsystem, error code %d\n", 
+              "Driver: Failed to attach card %d/%d in rx subsystem, error code %d\n", 
               unitNum, slotNum, rv);
       result = L7_FAILURE;
       return result;
     }
   }
 
Index: andl/hapi/esw/base/base/broad_system.c
===================================================================
--- andl/hapi/esw/base/base/broad_system.c	(revision 7375)
+++ andl/hapi/esw/base/base/broad_system.c	(revision 7378)
@@ -4176,13 +4176,13 @@ L7_RC_t hapiBroadConfigDhcpV4TrapAll(DAP
 
   do
   {
     result = hapiBroadPolicyCreate(policyType);
     if (result != L7_SUCCESS) break;
 
-    PT_LOG_TRACE(LOG_CTX_HAPI, "Policy of cell %u created", index);
+    PT_LOG_TRACE(LOG_CTX_HAPI, "Policy created");
 
     /* give dhcp frames high priority and trap to the CPU. */
 
     /* DHCP packets from client */
     ip_type = BROAD_IP_TYPE_IPV4;
     result = hapiBroadPolicyPriorityRuleAdd(&ruleId, BROAD_POLICY_RULE_PRIORITY_HIGH2);
@@ -4234,13 +4234,13 @@ L7_RC_t hapiBroadConfigDhcpV4TrapAll(DAP
     PT_LOG_TRACE(LOG_CTX_HAPI, "Commiting policy");
 
     result = hapiBroadPolicyCommit(&policyId);
 
     if (result == L7_SUCCESS)
     {
-      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", *policy_id);
+      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", policyId);
     }
     else
     {
       PT_LOG_ERR(LOG_CTX_HAPI, "Error commiting policy");
     }
   }
@@ -4312,13 +4312,13 @@ L7_RC_t hapiBroadConfigDhcpV6Trap(L7_uin
   do
   {
     result = hapiBroadPolicyCreate(policyType);
     if (result != L7_SUCCESS)
       break;
 
-    PT_LOG_TRACE(LOG_CTX_HAPI, "Policy of cell %u created", index);
+    PT_LOG_TRACE(LOG_CTX_HAPI, "Policy created");
 
     /* Rate limit */
     if (PTIN_VLAN_IS_QUATTRO(vlanId))
     {
       meterInfo = ptin_components_meter.quattro;
     }
@@ -4397,13 +4397,13 @@ L7_RC_t hapiBroadConfigDhcpV6Trap(L7_uin
     PT_LOG_TRACE(LOG_CTX_HAPI, "Commiting policy");
 
     result = hapiBroadPolicyCommit(&policyId);
 
     if (result == L7_SUCCESS)
     {
-      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", *policy_id);
+      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", policyId);
     }
     else
     {
       PT_LOG_ERR(LOG_CTX_HAPI, "Error commiting policy");
     }
   }
@@ -4472,13 +4472,13 @@ L7_RC_t hapiBroadConfigDhcpV6TrapAll(DAP
 
   do
   {
     result = hapiBroadPolicyCreate(policyType);
     if (result != L7_SUCCESS) break;
 
-    PT_LOG_TRACE(LOG_CTX_HAPI, "Policy of cell %u created", index);
+    PT_LOG_TRACE(LOG_CTX_HAPI, "Policy created");
 
     /* give dhcp frames high priority and trap to the CPU. */
 
     /* DHCP packets from client */
     ip_type = BROAD_IP_TYPE_IPV6;
     result = hapiBroadPolicyPriorityRuleAdd(&ruleId, BROAD_POLICY_RULE_PRIORITY_HIGH);
@@ -4528,13 +4528,13 @@ L7_RC_t hapiBroadConfigDhcpV6TrapAll(DAP
     PT_LOG_TRACE(LOG_CTX_HAPI, "Commiting policy");
 
     result = hapiBroadPolicyCommit(&policyId);
 
     if (result == L7_SUCCESS)
     {
-      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", *policy_id);
+      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", policyId);
     }
     else
     {
       PT_LOG_ERR(LOG_CTX_HAPI, "Error commiting policy");
     }
   }
@@ -4591,13 +4591,13 @@ L7_RC_t hapiBroadConfigPPPoETrap(L7_uint
   do
   {
     result = hapiBroadPolicyCreate(policyType);
     if (result != L7_SUCCESS)
       break;
 
-    PT_LOG_TRACE(LOG_CTX_HAPI, "Policy of cell %u created", index);
+    PT_LOG_TRACE(LOG_CTX_HAPI, "Policy created");
 
     /* Rate limit */
     if (PTIN_VLAN_IS_QUATTRO(vlanId))
     {
       meterInfo = ptin_components_meter.quattro;
     }
@@ -4635,13 +4635,13 @@ L7_RC_t hapiBroadConfigPPPoETrap(L7_uint
     PT_LOG_TRACE(LOG_CTX_HAPI, "Commiting policy");
 
     result = hapiBroadPolicyCommit(&policyId);
 
     if (result == L7_SUCCESS)
     {
-      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", *policy_id);
+      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", policyId);
     }
     else
     {
       PT_LOG_ERR(LOG_CTX_HAPI, "Error commiting policy");
     }
   }
@@ -4693,13 +4693,13 @@ L7_RC_t hapiBroadConfigPPPoETrapAll(DAPI
   do
   {
     result = hapiBroadPolicyCreate(policyType);
     if (result != L7_SUCCESS)
       break;
 
-    PT_LOG_TRACE(LOG_CTX_HAPI, "Policy of cell %u created", index);
+    PT_LOG_TRACE(LOG_CTX_HAPI, "Policy created");
 
     meterInfo = ptin_components_meter.pppoe;
  
     /* PPPoE packets from client */
     result = hapiBroadPolicyPriorityRuleAdd(&ruleId, BROAD_POLICY_RULE_PRIORITY_HIGH);
     if (result != L7_SUCCESS)  break;
@@ -4725,13 +4725,13 @@ L7_RC_t hapiBroadConfigPPPoETrapAll(DAPI
     PT_LOG_TRACE(LOG_CTX_HAPI, "Commiting policy");
 
     result = hapiBroadPolicyCommit(&policyId);
 
     if (result == L7_SUCCESS)
     {
-      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", *policy_id);
+      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", policyId);
     }
     else
     {
       PT_LOG_ERR(LOG_CTX_HAPI, "Error commiting policy");
     }
   }
@@ -4852,13 +4852,13 @@ L7_RC_t hapiBroadConfigApsTrap(/*DAPI_US
     PT_LOG_TRACE(LOG_CTX_HAPI, "Commiting policy");
 
     result = hapiBroadPolicyCommit(&policyId);
 
     if (result == L7_SUCCESS)
     {
-      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", *policy_id);
+      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", policyId);
     }
     else
     {
       PT_LOG_ERR(LOG_CTX_HAPI, "Error commiting policy");
     }
   }
@@ -4974,13 +4974,13 @@ L7_RC_t hapiBroadConfigIpDtl0Trap(L7_uin
     PT_LOG_TRACE(LOG_CTX_HAPI, "Commiting policy");
 
     result = hapiBroadPolicyCommit(&policyId);
 
     if (result == L7_SUCCESS)
     {
-      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", *policy_id);
+      PT_LOG_TRACE(LOG_CTX_HAPI, "policy %d commited successfully", policyId);
     }
     else
     {
       PT_LOG_ERR(LOG_CTX_HAPI, "Error commiting policy");
     }
   }
@@ -5026,13 +5026,13 @@ L7_RC_t hapiBroadConfigCcmFilter(DAPI_US
   L7_uchar8 ccm_MacAddr[] = {0x01,0x80,0xC2,0x00,0x00,0x37};
   L7_uchar8               exact_match[] = {FIELD_MASK_NONE, FIELD_MASK_NONE, FIELD_MASK_NONE,
                                           FIELD_MASK_NONE, FIELD_MASK_NONE, FIELD_MASK_NONE};
   L7_uint16               vlan_match = 0xfff;
   BROAD_METER_ENTRY_t     meterInfo;
   BROAD_POLICY_TYPE_t     policyType = BROAD_POLICY_TYPE_SYSTEM;
-  L7_ulong32 index, ccm_index, ccm_index_free;
+  L7_uint32 index, ccm_index, ccm_index_free;
 
   PT_LOG_TRACE(LOG_CTX_HAPI, "Starting CCM trapping processing\tenable=%d\tvlanId=%u\toam_level=%u", enable, vlanId, oam_level);
 
   /* Initialization */
   if (first_time)
   {
@@ -7019,13 +7019,13 @@ L7_RC_t hapiBroadIntfFiberDiagTest(DAPI_
       dapiCmd->cmdData.cableFiberDiag.txFault     = (L7_BOOL)txFault;
       dapiCmd->cmdData.cableFiberDiag.los         = (L7_BOOL)los;
     }
     else
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DRIVER_COMPONENT_ID, 
-              "\n%s %d: %s(usp=%d.%d.%d, cmd=%d) - Invalid getOrSet Command = %d\n"
+              "\n%s %d: %s(usp=%d.%d.%d, cmd=%d) - Invalid getOrSet Command = %d\n",
               __FILE__, __LINE__, __func__, usp->unit, usp->slot, usp->port, cmd, result);
     }
   }
 
   return result;
 }
Index: andl/hapi/esw/base/base/broad_cpu_intf.c
===================================================================
--- andl/hapi/esw/base/base/broad_cpu_intf.c	(revision 7375)
+++ andl/hapi/esw/base/base/broad_cpu_intf.c	(revision 7378)
@@ -2290,14 +2290,14 @@ L7_RC_t hapiBroadSend(DAPI_USP_t *usp, D
   {
     osapiTaskYield();
   }
 
   if (cpu_transmit_debug & CPU_INTERCEPT_DEBUG_LEVEL1)
   {
-    PT_LOG_DEBUG(LOG_CTX_HAPI, "Sending to usp %d.%d.%d (bcmx_lport 0x%08x), with sendVLAN %u, length=%u/%u (frameType %u, pktflags 0x%x): bcmTxRv=%d result=%d",
-              destUsp.unit, destUsp.slot, destUsp.port, hapiPortPtr->bcmx_lport, cmdInfo->cmdData.send.vlanID, bcm_pkt.pkt_data->len, frameType, bcm_pkt.flags, bcmTxRv, result);
+    PT_LOG_DEBUG(LOG_CTX_HAPI, "Sending to usp %d.%d.%d (bcmx_lport 0x%08x), with sendVLAN %u, length=%u (frameType %u, pktflags 0x%x): bcmTxRv=%d result=%d",
+                 destUsp.unit, destUsp.slot, destUsp.port, hapiPortPtr->bcmx_lport, cmdInfo->cmdData.send.vlanID, bcm_pkt.pkt_data->len, frameType, bcm_pkt.flags, bcmTxRv, result);
   }
 
   return result;
 
 }
 
Index: andl/hapi/esw/base/base/broad_ptin.c
===================================================================
--- andl/hapi/esw/base/base/broad_ptin.c	(revision 7375)
+++ andl/hapi/esw/base/base/broad_ptin.c	(revision 7378)
@@ -1973,13 +1973,13 @@ L7_RC_t hapiBroadPTinPrbsEnable(DAPI_USP
       } while (((tries++) < 10) &&
                (bcm_port_speed_get    (0, bcm_port, &speed  ) != BCM_E_NONE || speed   != 40000 ||
                 bcm_port_autoneg_get  (0, bcm_port, &autoneg) != BCM_E_NONE || autoneg != L7_DISABLE ||
                 bcm_port_duplex_get   (0, bcm_port, &duplex ) != BCM_E_NONE || duplex  != L7_TRUE ||
                 bcm_port_interface_get(0, bcm_port, &if_type) != BCM_E_NONE || if_type != BCM_PORT_IF_KR4));
 
-      PT_LOG_INFO(LOG_CTX_HAPI, "Needed %u tries to wait for KR4 reestablishment (bcm_port %u)", bcm_port);
+      PT_LOG_INFO(LOG_CTX_HAPI, "Needed %u tries to wait for KR4 reestablishment (bcm_port %u)", tries, bcm_port);
 
       /* Force previous tap settings */
       if (rc == L7_SUCCESS)
       {
         PT_LOG_INFO(LOG_CTX_HAPI, "Going to force original preemphasys (1:0x%08x, 2:0x%08x, 3:0x%08x, 4:0x%08x) to bcm_port %u",
                  preemphasys[0], preemphasys[1], preemphasys[2], preemphasys[3], bcm_port);
@@ -1997,19 +1997,19 @@ L7_RC_t hapiBroadPTinPrbsEnable(DAPI_USP
     }
   }
 
   /* PRBS generated by internal PHY */
   if (bcm_port_control_set(0, bcm_port, bcmPortControlPrbsMode, 0)!=L7_SUCCESS)
   {
-    PT_LOG_ERR(LOG_CTX_HAPI, "ERROR applying bcmPortControlPrbsMode 0 to port %d, bcm_port=%d",enable, port, bcm_port);
+    PT_LOG_ERR(LOG_CTX_HAPI, "ERROR applying bcmPortControlPrbsMode 0 to port %d, bcm_port=%d", port, bcm_port);
     return L7_FAILURE;
   }
   /* PRBS polynomial 31 */
   if (bcm_port_control_set(0, bcm_port, bcmPortControlPrbsPolynomial, BCM_PORT_PRBS_POLYNOMIAL_X31_X28_1)!=L7_SUCCESS)
   {
-    PT_LOG_ERR(LOG_CTX_HAPI, "ERROR applying bcmPortControlPrbsMode 0 to port %d, bcm_port=%d",enable, port, bcm_port);
+    PT_LOG_ERR(LOG_CTX_HAPI, "ERROR applying bcmPortControlPrbsMode 0 to port %d, bcm_port=%d", port, bcm_port);
     return L7_FAILURE;
   }
   /* For OLT1T1, SFI and XFI modes, invert PRBS sequence */
 #if (PTIN_BOARD == PTIN_BOARD_CXO160G)
   if (dapiCardPtr->wcPortMap[port].wcSpeedG == 10)
   {
@@ -2056,14 +2056,15 @@ L7_RC_t hapiBroadPTinPrbsEnable(DAPI_USP
         PT_LOG_ERR(LOG_CTX_HAPI, "Error restoring KR4 mode at bcm_port %u", bcm_port);
       }
     }
   }
 
   PT_LOG_TRACE(LOG_CTX_HAPI, "PRBS TX/RX %s for port {%d,%d,%d}, bcm_port=%d",
-            ((enable) ? "enabled" : "disabled"),
-            port, bcm_port);
+               ((enable) ? "enabled" : "disabled"),
+               usp->unit, usp->slot, usp->port,
+               bcm_port);
 
   return L7_SUCCESS;
 }
 
 /**
  * Read number of PRBS errors
@@ -2850,13 +2851,13 @@ L7_RC_t hapiBroadPtinMEPCreate(DAPI_USP_
   */
   if (BCM_E_NONE==r) return L7_SUCCESS;
 
 _hapiBroadPtinMEPCreate_nokend:
   if (!alrdy) {
       bcm_oam_group_destroy(0, ginfo.id);
-      PT_LOG_TRACE(LOG_CTX_API, "ERROR\n\r", r);
+      PT_LOG_TRACE(LOG_CTX_API, "ERROR\n\r");
   }
 
   return r;
 }//hapiBroadPtinMEPCreate
 
 
Index: andl/hapi/esw/base/base/broad_llpf.c
===================================================================
--- andl/hapi/esw/base/base/broad_llpf.c	(revision 7375)
+++ andl/hapi/esw/base/base/broad_llpf.c	(revision 7378)
@@ -898,13 +898,13 @@ L7_RC_t hapiBroadIntfLlpfBlockModeConfig
 
   if (L7_SUCCESS != rc)
   {
     /*log*/
     L7_LOGF(L7_LOG_SEVERITY_WARNING,L7_LLPF_COMPONENT_ID,
             "Failed to set/unset(%d) LLPF BlockType (%d) with Policy ID(%d) port %d lport  0x%x\n",
-             usp->port,hapiPortPtr->bcmx_lport); 
+             cmd, llpfBlockType, policyId, usp->port,hapiPortPtr->bcmx_lport); 
              
     /*Debug trace*/
      HAPI_BROAD_LLPF_DEBUG(\
             "Failed to set/unset(%d) LLPF BlockType (%d) with Policy ID(%d) \
              on port: Unit %d, slot %d port %d lport  0x%x\n" \
              ,portEnabled,llpfBlockType,policyId,usp->unit \
Index: andl/hapi/esw/ptin/ptin_hapi_l2.c
===================================================================
--- andl/hapi/esw/ptin/ptin_hapi_l2.c	(revision 7375)
+++ andl/hapi/esw/ptin/ptin_hapi_l2.c	(revision 7378)
@@ -823,13 +823,13 @@ L7_RC_t ptin_hapi_vport_maclimit_reset(b
       send_trap_switch_event(macLearn_info_flow[vport_id].ptin_intf.intf_type, macLearn_info_flow[vport_id].ptin_intf.intf_id, TRAP_ALARM_MAC_LIMIT, TRAP_ALARM_STATUS_END, 0);
       macLearn_info_flow[vport_id].trap_sent = L7_FALSE;
     }
   }
   else
   {
-    PT_LOG_WARN(LOG_CTX_HAPI, "GPORT is not valid! (vport_id)", vport_id);
+    PT_LOG_WARN(LOG_CTX_HAPI, "GPORT is not valid! (vport_id=0x%x)", vport_id);
     return L7_FAILURE;
   }
 
   return L7_SUCCESS;
 }
 
@@ -1051,13 +1051,13 @@ L7_RC_t ptin_hapi_vport_maclimit_setmax(
       ptin_hapi_maclimit_fdbFlush(vlan_id, gport, BROAD_FLUSH_BY_VLAN);
     }
     #endif
   }
   else
   {
-    PT_LOG_WARN(LOG_CTX_HAPI, "GPORT is not valid! (vport_id)", vport_id);
+    PT_LOG_WARN(LOG_CTX_HAPI, "GPORT is not valid! (vport_id=%x)", vport_id);
     return L7_FAILURE;
   }
   return L7_SUCCESS;
 }
 
 /**
@@ -1448,13 +1448,13 @@ L7_RC_t ptin_hapi_vport_maclimit_alarmco
     /* Virtual port ID is valid? */
     if (vport_id >= MAX_GPORTS)
     {
       PT_LOG_NOTICE(LOG_CTX_HAPI, "GPORT is out of range! (vport_id=%u max=%u)", vport_id, MAX_GPORTS);
       return L7_FAILURE;
     }
-    PT_LOG_NOTICE(LOG_CTX_HAPI, "(GPORT=0x%x) MAC Learned limit information %u, bcm_port %u, outer_vid %d", gport, bcm_port, outer_vid);
+    PT_LOG_NOTICE(LOG_CTX_HAPI, "(GPORT=0x%x) MAC Learned limit information, bcm_port %u, outer_vid %d", gport, bcm_port, outer_vid);
 
     hapi_ptin_port_get(bcm_port, &port);
 
     macLearn_info_flow[vport_id].ptin_intf.intf_type =  type;
     if( macLearn_info_flow[vport_id].ptin_intf.intf_type == PTIN_EVC_INTF_PHYSICAL)
     {
@@ -1466,13 +1466,13 @@ L7_RC_t ptin_hapi_vport_maclimit_alarmco
     }
 
     macLearn_info_flow[vport_id].uni_ovid =             outer_vid;              // GEM id
   }
   else
   {
-    PT_LOG_WARN(LOG_CTX_HAPI, "GPORT is not valid! (vport_id)", vport_id);
+    PT_LOG_WARN(LOG_CTX_HAPI, "GPORT is not valid! (vport_id=0x%x)", vport_id);
     return L7_FAILURE;
   }
   return L7_SUCCESS;
 }
 
 /**
Index: andl/hapi/esw/ptin/ptin_hapi_l3.c
===================================================================
--- andl/hapi/esw/ptin/ptin_hapi_l3.c	(revision 7375)
+++ andl/hapi/esw/ptin/ptin_hapi_l3.c	(revision 7378)
@@ -587,13 +587,13 @@ L7_RC_t ptin_hapi_l3_ipmc_reset(void)
   int   rv = L7_SUCCESS;
  
   /*Initialize IPMC Table*/   
   rv = bcm_ipmc_remove_all(0);
   if (BCM_FAILURE(rv))
   {
-    PT_LOG_ERR(LOG_CTX_HAPI,"Error initializing IPMC Table: rv=\"%s\" (rv:%u)", bcm_errmsg(rv));
+    PT_LOG_ERR(LOG_CTX_HAPI,"Error initializing IPMC Table: rv=\"%s\" (rv:%u)", bcm_errmsg(rv), rv);
     return ptin_bcm_to_fp_error_code(rv);
   }
   return rv;
 }
   
 #include <bcm/qos.h>
Index: andl/hapi/esw/ptin/ptin_hapi.c
===================================================================
--- andl/hapi/esw/ptin/ptin_hapi.c	(revision 7375)
+++ andl/hapi/esw/ptin/ptin_hapi.c	(revision 7378)
@@ -168,13 +168,13 @@ L7_RC_t ptin_hapi_phySemaTake(L7_uint16
   {
     PT_LOG_ERR(LOG_CTX_HAPI, "ptin_port %u: bcm_port %u does not have any semaphore associated to it", ptin_port, hapiPortPtr->bcm_port);
     return L7_FAILURE;
   }
   if (osapiSemaTake(hapiPortPtr->hapiModeparm.physical.phySemaphore, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
-    PT_LOG_ERR(LOG_CTX_HAPI, "ptin_port %u: Error blocking semaphore related to bcm_port %u (port %u)", ptin_port, hapiPortPtr->bcm_port);
+    PT_LOG_ERR(LOG_CTX_HAPI, "ptin_port %u: Error blocking semaphore related to bcm_port %u", ptin_port, hapiPortPtr->bcm_port);
     return L7_FAILURE;
   }
 
   return L7_SUCCESS;
 }
 
@@ -223,13 +223,13 @@ L7_RC_t ptin_hapi_phySemaGive(L7_uint16
   {
     PT_LOG_ERR(LOG_CTX_HAPI, "ptin_port %u: bcm_port %u does not have any semaphore associated to it", ptin_port, hapiPortPtr->bcm_port);
     return L7_FAILURE;
   }
   if (osapiSemaGive(hapiPortPtr->hapiModeparm.physical.phySemaphore) != L7_SUCCESS)
   {
-    PT_LOG_ERR(LOG_CTX_HAPI, "ptin_port %u: Error releasing semaphore related to bcm_port %u (port %u)", ptin_port, hapiPortPtr->bcm_port);
+    PT_LOG_ERR(LOG_CTX_HAPI, "ptin_port %u: Error releasing semaphore related to bcm_port %u", ptin_port, hapiPortPtr->bcm_port);
     return L7_FAILURE;
   }
 
   return L7_SUCCESS;
 }
 
@@ -2168,13 +2168,13 @@ L7_RC_t ptin_hapi_linkscan_get(DAPI_USP_
     PT_LOG_WARN(LOG_CTX_HAPI, "Port {%d,%d,%d} is not physical", usp->unit, usp->slot, usp->port);
     return L7_NOT_SUPPORTED;
   }
 
   if (bcm_linkscan_mode_get(0, hapiPortPtr->bcm_port, &mode) != BCM_E_NONE)
   {
-    PT_LOG_ERR(LOG_CTX_HAPI, "Error reading linkscan state for port {%d,%d,%d}/bcm_port %u/port %u to %u",
+    PT_LOG_ERR(LOG_CTX_HAPI, "Error reading linkscan state for port {%d,%d,%d}, bcm_port %u",
             usp->unit, usp->slot, usp->port, hapiPortPtr->bcm_port);
     return L7_FAILURE;
   }
 
   if (enable != L7_NULLPTR)
   {
@@ -4123,14 +4123,14 @@ L7_RC_t hapi_ptin_counters_activity_get_
   if (hapi_ptin_counters_activity_get(&portsActivity) != L7_SUCCESS) {
     PT_LOG_ERR(LOG_CTX_HAPI, "Error on hapi_ptin_counters_activity_get()");
     return L7_FAILURE;
   }
 
   PT_LOG_DEBUG(LOG_CTX_HAPI, "Port# %2u", phyPort);
-  PT_LOG_DEBUG(LOG_CTX_HAPI, " .port_mask         = 0x%08X", portsActivity.ports_mask);
-  PT_LOG_DEBUG(LOG_CTX_HAPI, " .activity_mask     = 0x%08X", portsActivity.activity_mask);
+  PT_LOG_DEBUG(LOG_CTX_HAPI, " .port_mask         = 0x%016llX", portsActivity.ports_mask);
+  PT_LOG_DEBUG(LOG_CTX_HAPI, " .activity_mask     = 0x%016llX", portsActivity.activity_mask);
   PT_LOG_DEBUG(LOG_CTX_HAPI, " .activity_bmap[%02u] = 0x%08X", phyPort, portsActivity.activity_bmap[phyPort]);
 
   return L7_SUCCESS;
 }
 
 /****** STORM CONTROL ***********************************************/
@@ -6193,14 +6193,12 @@ L7_RC_t teste_case(void)
   {
     PT_LOG_ERR(LOG_CTX_STARTUP, "Error configuring rule");
     hapiBroadPolicyCreateCancel();
     return L7_FAILURE;
   }
 
-  PT_LOG_TRACE(LOG_CTX_STARTUP, "I am here!", policyId);
-
   /* Apply rules */
   rc = hapiBroadPolicyCommit(&policyId);
   if (rc != L7_SUCCESS)
   {
     PT_LOG_ERR(LOG_CTX_STARTUP, "Error commiting policy");
     hapiBroadPolicyCreateCancel();
@@ -7275,13 +7273,13 @@ L7_RC_t ptin_hapi_temperature_monitor(pt
   rv = bcm_switch_temperature_monitor_get(0, n, temp_data, &count);
 
   PT_LOG_TRACE(LOG_CTX_HAPI, "Obtained data from %u sensors (rv=%d)\r\n", count, rv);
 
   if (rv != BCM_E_NONE)
   {
-    PT_LOG_ERR(LOG_CTX_HAPI, "Error reading temperature sensors (rv=%d)", count, rv);
+    PT_LOG_ERR(LOG_CTX_HAPI, "Error reading temperature sensors (rv=%d)", rv);
     return L7_FAILURE;
   }
 
   PT_LOG_TRACE(LOG_CTX_HAPI, "Index=%d", temp_info->index);
   PT_LOG_TRACE(LOG_CTX_HAPI, "Number of sensors=%d", temp_info->number_of_sensors);
 
Index: andl/hapi/esw/ptin/ptin_hapi_xconnect.c
===================================================================
--- andl/hapi/esw/ptin/ptin_hapi_xconnect.c	(revision 7375)
+++ andl/hapi/esw/ptin/ptin_hapi_xconnect.c	(revision 7378)
@@ -819,13 +819,13 @@ L7_RC_t ptin_hapi_multicast_egress_port_
   {
     PT_LOG_ERR(LOG_CTX_HAPI, "Invalid MC group");
     return L7_FAILURE;
   }
 
   PT_LOG_TRACE(LOG_CTX_HAPI, "port={%d,%d,%d}, mcast_group=%d",
-            dapiPort->usp->unit,dapiPort->usp->slot,dapiPort->usp->port, mcast_group);
+            dapiPort->usp->unit, dapiPort->usp->slot, dapiPort->usp->port, *mcast_group);
 
   /* Validate interface */
   if ( dapiPort->usp->unit<0 || dapiPort->usp->slot<0 || dapiPort->usp->port<0 )
   {
     PT_LOG_ERR(LOG_CTX_HAPI, "ERROR: Invalid interfaces");
     return L7_FAILURE;
Index: andl/hapi/esw/ptin/ptin_hapi_fp_utils.c
===================================================================
--- andl/hapi/esw/ptin/ptin_hapi_fp_utils.c	(revision 7375)
+++ andl/hapi/esw/ptin/ptin_hapi_fp_utils.c	(revision 7378)
@@ -16,13 +16,14 @@
 #define FP_POLICY_GET_PTR_FROM_INDEX(index,db)  ( (void *) ((char *) (db)->database_base + (index)*(db)->database_elem_sizeof) )
 /* Get database base pointer (first element) */
 #define FP_POLICY_GET_DATABASE_PTR(db)          ( (void *) (db)->database_base )
 /* Get the following element pointer in database */
 #define FP_POLICY_GET_PTR_NEXT(ptr,db)          ( (void *) ((char *) (ptr) + (db)->database_elem_sizeof) )
 /* Increment database element pointer */
-#define FP_POLICY_INC_PTR(ptr,db)               ( ((void *) ((char *) (ptr))) += (db)->database_elem_sizeof)
+//#define FP_POLICY_INC_PTR(ptr,db)               ( (void *) ( ((L7_uint32) (char *) (ptr)) += (db)->database_elem_sizeof ) )
+#define FP_POLICY_INC_PTR(ptr,db)               ptr = (void *) ((char *) (ptr) + (db)->database_elem_sizeof)
 /* Get the first free element in database */
 #define FP_FREEPOLICY_GET_INDEX(db)             ( (db)->database_index_first_free )
 /* Check if database has no free elements */
 #define FP_FREEPOLICY_HAS_NOVALUE(db)           ( (db)->database_index_first_free<0 )
 /* Set free element index in database with a new value */
 #define FP_FREEPOLICY_SET_INDEX(index,db)       { (db)->database_index_first_free = (index); }
Index: andl/hapi/esw/ptin/ptin_ptp_fpga.c
===================================================================
--- andl/hapi/esw/ptin/ptin_ptp_fpga.c	(revision 7375)
+++ andl/hapi/esw/ptin/ptin_ptp_fpga.c	(revision 7378)
@@ -183,20 +183,20 @@ ptin_HwEthMef10Evc_t evcConf;
             evcConf.intf[1].vid         = 0;
             evcConf.intf[1].action_outer= PTIN_XLATE_ACTION_NONE;
             evcConf.intf[1].action_inner= PTIN_XLATE_ACTION_NONE;
             /* Create circuit */
             rc = ptin_evc_create(&evcConf);
             if (rc != L7_SUCCESS) {
-              PT_LOG_ERR(LOG_CTX_API, "Error creating EVC# %u for connecting Port %u to FPGA", EVCprt(prt), prt);
+              PT_LOG_ERR(LOG_CTX_API, "Error creating EVC# %lu for connecting Port %lu to FPGA", EVCprt(prt), prt);
               //return rc;
             }
 
             //Remove VID(po) (=VID(pi)) @ PO/PI port's egress
             rc2 = ptin_xlate_egress_set(prt, VIDprt(prt), PTIN_XLATE_ACTION_DELETE, -1);
             if (rc2 != L7_SUCCESS) {
-              PT_LOG_ERR(LOG_CTX_API, "Error defining pop xlate action for EVC# %u (CPU-FPGA): rc=%d", EVCprt(prt), rc);
+              PT_LOG_ERR(LOG_CTX_API, "Error defining pop xlate action for EVC# %lu (CPU-FPGA): rc=%d", EVCprt(prt), rc);
               //return rc2;
             }
             if (rc!=L7_SUCCESS || rc2!=L7_SUCCESS) {
                 //del_entry(&prt_vid_table, NULL, sizeof(ent), sizeof(ent.prt), N_FPGA_VIDPRTS, i);
                 ////del_entry(&prt_vid_table, &ent, sizeof(ent), sizeof(ent.prt), N_FPGA_VIDPRTS, i);
                 return -4;
@@ -216,13 +216,13 @@ ptin_HwEthMef10Evc_t evcConf;
         p= (T_PRT_VID *) pointer2table_index(&prt_vid_table, i, N_FPGA_VIDPRTS, sizeof(ent));
         vid_prt=p->vid_prt;
         del_entry(&prt_vid_table, NULL, sizeof(ent), sizeof(ent.prt), N_FPGA_VIDPRTS, i);
         if (0==index2n_used(&prt_vid_table, i, N_FPGA_VIDPRTS)) {   //last entity leaving
             rc = ptin_evc_delete(EVCprt(prt));
             if (rc != L7_SUCCESS) {
-              PT_LOG_ERR(LOG_CTX_API, "Error deleting EVC# %u for connecting Port %u to FPGA", EVCprt(prt), prt);
+              PT_LOG_ERR(LOG_CTX_API, "Error deleting EVC# %lu for connecting Port %lu to FPGA", EVCprt(prt), prt);
               return -6;
             }
         }//if (0==index2n_used(&prt_vid_table, i, N_FPGA_VIDPRTS))  //last entity leaving
      }
      break;
  case 3:
@@ -387,13 +387,13 @@ L7_RC_t ptin_hapi_ptp_entry_add(ptin_dap
 
 
 
 
   tbl_entry.e = *entry; //tbl_entry.e.key = entry->key;
   i = find_entry(&search_PTP_table, &tbl_entry, sizeof(tbl_entry), sizeof(entry->key), N_SEARCH_PTP, -1, &_1st_free);
-  PT_LOG_TRACE(LOG_CTX_HAPI, "i=%u\t_1st_free=%u\t(N_SEARCH_PTP=%u)", i, _1st_free, N_SEARCH_PTP);
+  PT_LOG_TRACE(LOG_CTX_HAPI, "i=%lu\t_1st_free=%lu\t(N_SEARCH_PTP=%u)", i, _1st_free, N_SEARCH_PTP);
 
   if (i<N_SEARCH_PTP) { //Entry found
       p = (ptin_hapi_search_ptp_t*) pointer2table_index(&search_PTP_table, i, N_SEARCH_PTP, sizeof(tbl_entry));
       if (!memcmp(entry, &p->e, sizeof(p->e))) return L7_SUCCESS;  //Nothing to do; same entry
 
       //Delete entry
@@ -595,13 +595,13 @@ L7_RC_t ptin_hapi_ptp_entry_add(ptin_dap
 
   // Save entry
   tbl_entry.policyId = policyId;
   i = add_entry(&search_PTP_table, &tbl_entry, sizeof(tbl_entry), sizeof(entry->key), N_SEARCH_PTP, i, 0, 0);
   //wr_entry(&search_PTP_table, &tbl_entry, sizeof(tbl_entry), N_SEARCH_PTP, i);
 
-  PT_LOG_TRACE(LOG_CTX_HAPI,"add_entry()=%u\t(N_SEARCH_PTP=%u)", i, N_SEARCH_PTP);
+  PT_LOG_TRACE(LOG_CTX_HAPI,"add_entry()=%lu\t(N_SEARCH_PTP=%u)", i, N_SEARCH_PTP);
   //PT_LOG_TRACE(LOG_CTX_HAPI,"Operation finished successfully");
 
   return L7_SUCCESS;
 #endif
 }//ptin_hapi_ptp_entry_add
 
@@ -638,13 +638,13 @@ L7_RC_t rc = L7_SUCCESS;
     i = find_entry(&search_PTP_table, &tbl_entry, sizeof(tbl_entry), sizeof(entry->key), N_SEARCH_PTP, -1, NULL);
     if (i>=N_SEARCH_PTP) return L7_FAILURE; //not found
 
     p = (ptin_hapi_search_ptp_t*) pointer2table_index(&search_PTP_table, i, N_SEARCH_PTP, sizeof(tbl_entry));
 
     //Delete entry
-    PT_LOG_TRACE(LOG_CTX_HAPI, "Deleting entry %u (prt=%u, vid=%u, vid_os=%u, policyId=%u)...",
+    PT_LOG_TRACE(LOG_CTX_HAPI, "Deleting entry %lu (prt=%u, vid=%u, vid_os=%u, policyId=%u)...",
                  i, p->e.key.prt, p->e.key.vid, p->e.vid_os, p->policyId);
     rc = hapiBroadPolicyDelete(p->policyId);
     if (rc != L7_SUCCESS) {PT_LOG_ERR(LOG_CTX_HAPI, "Cannot hapiBroadPolicyDelete()");}
 
     return N_SEARCH_PTP > del_entry(&search_PTP_table, NULL, sizeof(tbl_entry), sizeof(entry->key), N_SEARCH_PTP, i)
            &&
@@ -742,13 +742,13 @@ ptin_dtl_search_ptp_t   *entry;
 
 
 
 //DTL/APP LAYER**********************************************************************************
 //extern int search_oam_ptp_add_ptp_entry_pair(T_SEARCH_OAM_PTP_TABLE *t_table, u16 vid_prt, u16 vid, u16 vid_os);
 //extern int search_oam_ptp_del_ptp_entry_pair(T_SEARCH_OAM_PTP_TABLE *t_table, u16 vid_prt, u16 vid, u16 vid_os);
-extern inline L7_RC_t ptin_intf_port2intIfNum(L7_uint32 ptin_port, L7_uint32 *intIfNum);
+extern L7_RC_t ptin_intf_port2intIfNum(L7_uint32 ptin_port, L7_uint32 *intIfNum);
 extern L7_RC_t ptin_xlate_ingress_set( L7_uint port, L7_uint16 outer_vlan, L7_uint op, L7_uint16 newOuterVlanId);
 extern L7_RC_t ptin_xlate_ingress_clear( L7_uint port, L7_uint16 outer_vlan, L7_uint16 inner_vlan);
 extern L7_RC_t dtlPtinGeneric(L7_uint32 intIfNum, L7_uint16 msgId, DAPI_CMD_GET_SET_t operation, L7_uint32 dataSize, void *data);
 
 L7_RC_t ptin_ptp_fpga_entry(ptin_dtl_search_ptp_t *e, DAPI_CMD_GET_SET_t operation) {
 #if (!PTIN_BOARD_IS_STANDALONE)
@@ -902,13 +902,13 @@ bcmx_lport_t  lport;
 
 
 
 
     tbl_entry.e = *entry; //tbl_entry.e.key = entry->key;
     i = find_entry(&search_OAM_table, &tbl_entry, sizeof(tbl_entry), sizeof(entry->key), N_SEARCH_OAM, -1, &_1st_free);
-    PT_LOG_TRACE(LOG_CTX_HAPI, "i=%u\t_1st_free=%u\t(N_SEARCH_OAM=%u)", i, _1st_free, N_SEARCH_OAM);
+    PT_LOG_TRACE(LOG_CTX_HAPI, "i=%lu\t_1st_free=%lu\t(N_SEARCH_OAM=%u)", i, _1st_free, N_SEARCH_OAM);
 
     if (i<N_SEARCH_OAM) { //Entry found
         p = (ptin_hapi_search_oam_t*) pointer2table_index(&search_OAM_table, i, N_SEARCH_OAM, sizeof(tbl_entry));
         if (!memcmp(entry, &p->e, sizeof(p->e))) return L7_SUCCESS;  //Nothing to do; same entry
 
         //Delete entry
@@ -1043,13 +1043,13 @@ bcmx_lport_t  lport;
 
     // Save entry
     tbl_entry.policyId = policyId;
     i = add_entry(&search_OAM_table, &tbl_entry, sizeof(tbl_entry), sizeof(entry->key), N_SEARCH_OAM, i, 0, 0);
     //wr_entry(&search_OAM_table, &tbl_entry, sizeof(tbl_entry), N_SEARCH_OAM, i);
 
-    PT_LOG_TRACE(LOG_CTX_HAPI,"add_entry()=%u\t(N_SEARCH_OAM=%u)", i, N_SEARCH_OAM);
+    PT_LOG_TRACE(LOG_CTX_HAPI,"add_entry()=%lu\t(N_SEARCH_OAM=%u)", i, N_SEARCH_OAM);
 
     return L7_SUCCESS;
 #endif
 }//ptin_hapi_oam_entry_add
 
 
@@ -1074,13 +1074,13 @@ L7_RC_t rc = L7_SUCCESS;
     i = find_entry(&search_OAM_table, &tbl_entry, sizeof(tbl_entry), sizeof(entry->key), N_SEARCH_OAM, -1, NULL);
     if (i>=N_SEARCH_OAM) return L7_FAILURE; //not found
 
     p = (ptin_hapi_search_oam_t*) pointer2table_index(&search_OAM_table, i, N_SEARCH_OAM, sizeof(tbl_entry));
 
     //Delete entry
-    PT_LOG_TRACE(LOG_CTX_HAPI, "Deleting entry %u (prt=%u, vid=%u, oam_level=%u, policyId=%u)...",
+    PT_LOG_TRACE(LOG_CTX_HAPI, "Deleting entry %lu (prt=%u, vid=%u, oam_level=%u, policyId=%u)...",
                  i, p->e.key.prt, p->e.key.vid, p->e.lvl, p->policyId);
     rc = hapiBroadPolicyDelete(p->policyId);
     if (rc != L7_SUCCESS) {PT_LOG_ERR(LOG_CTX_HAPI, "Cannot hapiBroadPolicyDelete()");}
 
     return N_SEARCH_OAM > del_entry(&search_OAM_table, NULL, sizeof(tbl_entry), sizeof(entry->key), N_SEARCH_OAM, i)
            &&
Index: os/linux/routing/lvl7arpd.c
===================================================================
--- os/linux/routing/lvl7arpd.c	(revision 7375)
+++ os/linux/routing/lvl7arpd.c	(revision 7378)
@@ -37,13 +37,13 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <errno.h>
 #include <string.h>
 /* PTin added: ARM processor */
 #ifndef __arm__
-#include <stropts.h>
+//#include <stropts.h>
 #endif
 #include <asm/types.h>
 #include <sys/socket.h>
 #include <sys/ioctl.h>
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
Index: os/linux/osapi/osapi.c
===================================================================
--- os/linux/osapi/osapi.c	(revision 7375)
+++ os/linux/osapi/osapi.c	(revision 7378)
@@ -658,14 +658,16 @@ static void osapiMallocDetailRecord(FILE
       total_size += mem_alloc->length;
   
       if (((comp_id == 0) || (mem_alloc->component_id == comp_id)) &&
           (mem_alloc->length > size) &&
           (mem_alloc->time_stamp > time_stamp))
       {
-      if (cnt < sizeAllocBuffer)
-        memcpy(&allocBuffer[cnt++], mem_alloc, sizeof(osapiMemAllocType));
+        if (cnt < sizeAllocBuffer)
+        {
+          memcpy(&allocBuffer[cnt++], mem_alloc, sizeof(osapiMemAllocType));
+        }
 
         total_blocks_match++;
         total_size_match += mem_alloc->length;
       }
       
       mem_alloc = mem_alloc->next;
Index: os/linux/osapi/osapi_task.c
===================================================================
--- os/linux/osapi/osapi_task.c	(revision 7375)
+++ os/linux/osapi/osapi_task.c	(revision 7378)
@@ -627,13 +627,13 @@ L7_int32  osapiTaskCreate( L7_char8 *tas
     /* Free the stack and task structure */
     osapi_task_destroy(newTask);
     
     return(L7_ERROR);
   }
 
-  PT_LOG_NOTICE(LOG_CTX_STARTUP, "New pthread created: \"%s\" -> pthread_id=%u (task_id=%u)",
+  PT_LOG_NOTICE(LOG_CTX_STARTUP, "New pthread created: \"%s\" -> pthread_id=%lu (task_id=%u)",
              namePtr, newTask->thread, (unsigned int)task_id);
 
   return(task_id);
 
 }
 
Index: os/linux/log/log_extend.c
===================================================================
--- os/linux/log/log_extend.c	(revision 7375)
+++ os/linux/log/log_extend.c	(revision 7378)
@@ -252,13 +252,13 @@ Log_Init(unsigned long event_log_size,
     long        i, j;
     L7_int32    fd;
 
     if (Log_Ptr != L7_NULLPTR)
     {
         L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LOG_COMPONENT_ID,
-                "Log_Init: Re-initializing logs, old size %d, new size %d\n",
+                "Log_Init: Re-initializing logs, old size %ld, new size %ld\n",
                 EventLogSize, event_log_size);
 
         if (event_log_size != EventLogSize)
         {
             osapiFree(L7_LOG_COMPONENT_ID, Log_Ptr);
             Log_Ptr = L7_NULLPTR;
Index: src/system_support/routing/utils/frame.c
===================================================================
--- src/system_support/routing/utils/frame.c	(revision 7375)
+++ src/system_support/routing/utils/frame.c	(revision 7378)
@@ -509,13 +509,13 @@ word    F_AddByteToStart( void *p_Frame,
       /* Not empty frame */
       useCount = buffer->useCount;
       if(B_GetSize(buffer) > (word)B_GetLength(buffer))
       {
          /* first buffer has enough space to prepend data */
          frame->frameLen++;
-         B_AddByteToStart( buffer, data );
+         (void)B_AddByteToStart( buffer, data );
          return TRUE;
       }
       p = &buffer->prev;
    }
 
    /* Allocate a new buffer and put data into it */
@@ -524,13 +524,13 @@ word    F_AddByteToStart( void *p_Frame,
 
    buffer->next = frame->firstBuf;
    *p = buffer; /* where (*p) is (firstBuf==NULL) ? firstBuf : firstBuf->prev */
    frame->firstBuf = buffer;
    buffer->useCount = useCount;
    frame->frameLen++;
-   B_AddByteToStart( buffer, data );
+   (void)B_AddByteToStart( buffer, data );
    return TRUE;
 }
 
 /* Add array to the end of the frame */
 word   F_AddToEnd( void *p_Frame, byte *pData, word Length )
 {
@@ -651,26 +651,26 @@ word    F_AddByteToEnd( void *p_Frame, b
       /* Not empty frame */
       useCount = buffer->useCount;
       if(B_GetSize(buffer)>(word)B_GetLength(buffer))
       {
          /* last buffer has enough space to pospend data */
          frame->frameLen++;
-         B_AddByteToEnd( buffer, data );
+         (void)B_AddByteToEnd( buffer, data );
          return TRUE;
       }
    }
 
    /* Try allocate a new buffer and put data into it */
    if( (buf = (t_Buffer *)B_NewEx(frame->bufPool,  frame->datPool, B_BUFFER_SIZE)) == NULLP)
       return 0;
 
    buf->useCount = useCount;
    *p = buf;
    frame->frameLen++;
    buf->prev = buffer;
-   B_AddByteToEnd( buf, data );
+   (void)B_AddByteToEnd( buf, data );
    return TRUE;
 }
 
 
 /* Remove data from the start of the frame */
 word    F_CutFromStart( void *p_Frame, word Length )
Index: src/system_support/routing/utils/timer.c
===================================================================
--- src/system_support/routing/utils/timer.c	(revision 7375)
+++ src/system_support/routing/utils/timer.c	(revision 7378)
@@ -985,13 +985,13 @@ static void _checkTimers( t_TimeTblDesc
             PACKET_PUT(callInfo, seq);
             (void) XX_Call(thread, callInfo);  /* May fail if queue full. OK for some queues. */
          }
          else
          {
            L7_LOGF(L7_LOG_SEVERITY_CRITICAL, L7_IP_MAP_COMPONENT_ID,
-                   "Memory allocation failure in _checkTimers for queue %d thread 0x%x",
+                   "Memory allocation failure in _checkTimers for queue %lu thread 0x%lx",
                    p_T->queueId, thread->TaskID);
          }
          XX_Freeze();
       }
 
       /* set p_T to the begin of the table */
Index: src/system_support/routing/utils/ospfv2_decode.c
===================================================================
--- src/system_support/routing/utils/ospfv2_decode.c	(revision 7375)
+++ src/system_support/routing/utils/ospfv2_decode.c	(revision 7378)
@@ -128,13 +128,13 @@ char *v2aseLsaMetricStr = "Metric";
 char *v2aseLsaMetricStrType="Metric Type";
 char *v2aseLsaForwAddrStr = "Forwarding Address";
 char *v2aseLsaTagStr = "Tag";
 char *v2aseLsaOptionsEBitStr = "E-Bit";
 
 /* graceful restart reasons (RFC 3623) */
-static char* restartReasonStr(restartReason)
+static char* restartReasonStr(L7_uint restartReason)
 {
   switch (restartReason)
   {
     case 0: return "Unknown";
     case 1: return "Software restart";
     case 2: return "Software reload/upgrade";
Index: src/system_support/routing/arp/arp.c
===================================================================
--- src/system_support/routing/arp/arp.c	(revision 7375)
+++ src/system_support/routing/arp/arp.c	(revision 7378)
@@ -1367,13 +1367,13 @@ e_Err ARP_SendARPReq(t_Handle Id, byte *
    }
    p_Rqe = (t_RQE *)XX_Malloc(sizeof(t_RQE ));
    if (p_Rqe == NULL)
    {
      return E_NOMEMORY;
    }
-   memset(p_Rqe, 0, sizeof(p_Rqe));
+   memset(p_Rqe, 0, sizeof(*p_Rqe));
    p_Rqe->dstAddrId = p_Adr;
    p_Rqe->userId = userId;
    p_Rqe->l3addr.protocolId = 0;
    memcpy(p_Rqe->l3addr.lay3Addr, ipAddr, sizeof(t_IPAddr));
    XX_AddToDLList(p_Rqe, p_Adr->request);
    
@@ -1417,13 +1417,13 @@ e_Err ARP_SendARPReqNoRxmt(t_Handle Id,
     p_Adr = XX_Malloc(sizeof(t_ADR));
     if (p_Adr)
     {
       memset(p_Adr, 0, sizeof(t_ADR));
       p_Adr->p_obj = p_A;
       p_Adr->status = ARP_ENT_STAT_Valid;
-      memcpy(p_Adr->ipAddr, ipAddr, sizeof(ipAddr));
+      memcpy(p_Adr->ipAddr, ipAddr, sizeof(*ipAddr));
       p_Adr->intfNum = index;
       p_Adr->entryType = ARP_ENTRY_TYPE_DYNAMIC;
       temporary = L7_TRUE;
     }
   }
   if (p_Adr)
Index: src/system_support/routing/tcp/tcpbind.c
===================================================================
--- src/system_support/routing/tcp/tcpbind.c	(revision 7375)
+++ src/system_support/routing/tcp/tcpbind.c	(revision 7378)
@@ -1441,13 +1441,13 @@ static e_Err checkConnStatus(void *dummy
 
             if (reqLength != rxLength)
             {
               /* should never happen */
               recvLenError++;
               L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_OSPF_MAP_COMPONENT_ID,
-                     "OSPF receive thread requested %d bytes. Received %d bytes.");
+                     "OSPF receive thread requested %d bytes. Received %d bytes.", reqLength, rxLength);
             }
             if (noPeekFlags & MSG_TRUNC)
             {
               /* should never happen */
               recvTrunc++;
               L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_OSPF_MAP_COMPONENT_ID,
Index: src/system_support/security/radius/client/radius_control.c
===================================================================
--- src/system_support/security/radius/client/radius_control.c	(revision 7375)
+++ src/system_support/security/radius/client/radius_control.c	(revision 7378)
@@ -884,13 +884,13 @@ L7_RC_t radiusEventServerHostNameAdd(dns
       ipaddr = 0;
       RADIUS_DLOG(RD_LEVEL_INFO,"%s(): DNS resolution failed.. ",__FUNCTION__);
     }
     else
     {
       RADIUS_DLOG(RD_LEVEL_INFO,"%s(): DNS Resolution success, host: %s - ip: %s\n",
-                     hostAddr->host.hostName,osapiInet_ntoa(ipaddr));
+                     __FUNCTION__, hostAddr->host.hostName,osapiInet_ntoa(ipaddr));
     }
   }
   else
   {
     ipaddr = hostAddr->host.ipAddr;
   }
@@ -2880,13 +2880,13 @@ L7_RC_t radiusServerNameEntryGet(L7_uint
   }
 
   else if( 0 == index || L7_NULLPTR == serverName ||
            0 == authServerNameArray[index-1].serverCount  )
   {
     RADIUS_DLOG(RD_LEVEL_INFO,"RADIUS: %s() Invalid Parameters: \
-                    index=%d serverName(ptr):%u serverCount:%d\n",__FUNCTION__,
+                    index=%d serverName:%s serverCount:%d\n",__FUNCTION__,
                     index,serverName,authServerNameArray[index-1].serverCount);
     return L7_FAILURE;
   }
 
   osapiStrncpySafe(serverName,authServerNameArray[index-1].serverName,
                      L7_RADIUS_SERVER_NAME_LENGTH+1);
Index: src/system_support/security/radius/client/radius_txrx.c
===================================================================
--- src/system_support/security/radius/client/radius_txrx.c	(revision 7375)
+++ src/system_support/security/radius/client/radius_txrx.c	(revision 7378)
@@ -991,13 +991,13 @@ L7_RC_t radiusNwInterfaceSocketTimeStamp
   L7_uint32 i;
   L7_RC_t rc = L7_FAILURE;
 
   if( L7_NULL == interfaceSocket )
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_RADIUS_COMPONENT_ID,
-            "RADIUS: %S(): Invalid parameters \n",__FUNCTION__);
+            "RADIUS: %s(): Invalid parameters \n",__FUNCTION__);
     return L7_FAILURE;
   }
 
   for(i=0;i<radiusGlobalData.totalNwInterfaces;i++)
   {
     if(radiusGlobalData.nwInterfaces[i].socket == interfaceSocket)
@@ -1009,13 +1009,13 @@ L7_RC_t radiusNwInterfaceSocketTimeStamp
     }
   }
   if(L7_FAILURE == rc )
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_RADIUS_COMPONENT_ID,
             "RADIUS: radiusNwInterfaceSocketTimeStampPut(): Could not find the \
-                     ipAddr for specified socket : %s\n",interfaceSocket);
+                     ipAddr for specified socket : %u\n",interfaceSocket);
   }
 
   return rc;
 }
 
 /*********************************************************************
Index: src/system_support/base/system/base/hpc_util.c
===================================================================
--- src/system_support/base/system/base/hpc_util.c	(revision 7375)
+++ src/system_support/base/system/base/hpc_util.c	(revision 7378)
@@ -1381,13 +1381,13 @@ void hpcDebugBcastMsgSend(void)
   L7_uchar8 payload[] = "hpcDebugBcastMsgSend test msg";
 
   /* Send off the packet to all CPUs */
   hpcBroadcastMessageSend(test_registrarID, sizeof(payload), payload);
 }
 
-void hpcDebugMsgSend(unit)
+void hpcDebugMsgSend(int unit)
 {
   L7_uchar8 payload[] = "hpcDebugMsgSend test msg";
 
   /* Send off the packet to selected CPU */
   hpcMessageSend(test_registrarID, unit, sizeof(payload), payload);
 }
Index: src/system_support/base/system/base/sysapi.c
===================================================================
--- src/system_support/base/system/base/sysapi.c	(revision 7375)
+++ src/system_support/base/system/base/sysapi.c	(revision 7378)
@@ -2490,13 +2490,13 @@ static L7_RC_t sysapiCfgTreeUpdate( L7_C
   if (dataArea == L7_NULL)
   {
     dataArea = osapiMalloc (component_id, compressedFileSize);
     if (dataArea == L7_NULL)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_SIM_COMPONENT_ID,
-              "Failed to allocate %ld for config file %s\n", compressedFileSize, filename);
+              "Failed to allocate %d for config file %s\n", compressedFileSize, filename);
       return L7_ERROR;
     }
   }
 
   /*
    * copy cfg data into this new data area
Index: src/system_support/base/system/base/sysapi_cputil.c
===================================================================
--- src/system_support/base/system/base/sysapi_cputil.c	(revision 7375)
+++ src/system_support/base/system/base/sysapi_cputil.c	(revision 7378)
@@ -70,13 +70,13 @@ L7_BOOL sysapiCpuUtilMonitorSuspended =
 *********************************************************************/
 void sysapiCpuUtilLockTake(void)
 {
   if (osapiSemaTake(sysapiCpuUtilTblSema, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_OSAPI_COMPONENT_ID,
-            "Failed to take cpuUtilSema %x\n", sysapiCpuUtilTblSema);
+            "Failed to take cpuUtilSema %x\n", (int)sysapiCpuUtilTblSema);
   }
 }
 
 
 /*********************************************************************
 * @purpose   Give the cpu utilization table lock
@@ -92,13 +92,13 @@ void sysapiCpuUtilLockTake(void)
 *********************************************************************/
 void sysapiCpuUtilLockGive(void)
 {
   if (osapiSemaGive(sysapiCpuUtilTblSema) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_OSAPI_COMPONENT_ID,
-            "Failed to give cpuUtilSema %x\n", sysapiCpuUtilTblSema);
+            "Failed to give cpuUtilSema %x\n", (int)sysapiCpuUtilTblSema);
   }
 }
 
 
 /*********************************************************************
 * @purpose  Arrange the utilization time periods in sorted order for 
Index: src/system_support/base/system/support/sysapi_support.c
===================================================================
--- src/system_support/base/system/support/sysapi_support.c	(revision 7375)
+++ src/system_support/base/system/support/sysapi_support.c	(revision 7378)
@@ -428,13 +428,13 @@ static L7_RC_t sysapiSupportCfgFileSepar
 
   /* Make sure that the configuration file is correct for the target device.
   */
   if (cfgFileHdr.targetDevice != hpc_unit->configLoadTargetId)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_SIM_COMPONENT_ID,
-            "Unexpected target device:  %s\n",cfgFileHdr.targetDevice);
+            "Unexpected target device:  %d\n",cfgFileHdr.targetDevice);
     (void)osapiFsClose (file_desc);
     (void)osapiSemaGive(sysapiSupportCfgSema);
     return L7_ERROR;
   }
 
 
@@ -1309,13 +1309,13 @@ static L7_RC_t sysapiSupportCfgTreeUpdat
   if (dataArea == L7_NULL)
   {
     dataArea = osapiMalloc (component_id, compressedFileSize);
     if (dataArea == L7_NULL)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_SIM_COMPONENT_ID,
-              "Failed to allocate %ld for support config file %s\n", compressedFileSize, filename);
+              "Failed to allocate %d for support config file %s\n", compressedFileSize, filename);
       return L7_ERROR;
     }
   }
 
     /*
      * copy cfg data into this new data area
Index: src/system_support/base/network/dns/dns_client_txrx.c
===================================================================
--- src/system_support/base/network/dns/dns_client_txrx.c	(revision 7375)
+++ src/system_support/base/network/dns/dns_client_txrx.c	(revision 7378)
@@ -156,12 +156,13 @@ static L7_RC_t dnsNameServerOpen(L7_inet
   dnsNameServerEntry_t *entry = L7_NULLPTR;
   L7_uint32 i = 0;
   L7_sockaddr_union_t addr;
   L7_uint32      opt = 1;
   L7_uint32      broadcastEnable = (L7_INET_IS_ADDR_BROADCAST(&serverAddr))?1:0;
   L7_uchar8      family = 0;
+  L7_uchar8      srvAddr[DNS_INET_ADDR_LEN];
 
   /* Get the family from server address */
   family = L7_INET_GET_FAMILY(serverAddr);
 
   /* find or create the active entry for this server, config entries
      are reordered on add/remove, so we do not use the config index */
@@ -236,14 +237,15 @@ static L7_RC_t dnsNameServerOpen(L7_inet
       }
       addr.u.sa4.sin_family = L7_AF_INET;
       addr.u.sa4.sin_port = osapiHtons(DNS_UDP_PORT);
       addr.u.sa4.sin_addr.s_addr = L7_INADDR_ANY;
       if (osapiSocketBind(entry->socket,(L7_sockaddr_t *)&addr.u.sa4,sizeof(addr.u.sa4)) != L7_SUCCESS)
       {
+        inetAddrPrint(serverAddr, srvAddr);
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DNS_CLIENT_COMPONENT_ID,
-                "DNS Client: Bind error on addr 0x%X\n", serverAddr);
+                "DNS Client: Bind error on addr %s\n", srvAddr);
         osapiSocketClose(entry->socket);
         return L7_FAILURE;
       }
     }
 #if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
     else if (family == L7_AF_INET6)
@@ -251,14 +253,15 @@ static L7_RC_t dnsNameServerOpen(L7_inet
       /* bind IN6ADDR_ANY */
       memset(&addr.u.sa6, 0, sizeof(addr.u.sa6));
       addr.u.sa6.sin6_family = L7_AF_INET6;
       addr.u.sa6.sin6_port = osapiHtons(DNS_UDP_PORT);
       if (osapiSocketBind(entry->socket,(L7_sockaddr_t *)&addr.u.sa6,sizeof(addr)) != L7_SUCCESS)
       {
+        inetAddrPrint(serverAddr, srvAddr);
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DNS_CLIENT_COMPONENT_ID,
-                "DNS Client: Bind error on addr 0x%X\n", serverAddr);
+                "DNS Client: Bind error on addr %s\n", srvAddr);
         osapiSocketClose(entry->socket);
         return L7_FAILURE;
       }
     }
 #endif
     else
@@ -367,17 +370,18 @@ L7_RC_t dnsNameServerPacketReceive(void)
       if (osapiSocketRecvfrom(dnsOprData->serverTbl[i].socket,
                               (L7_uchar8 *)packet,
                               DNS_UDP_MSG_SIZE_MAX,
                               L7_NULL,
                               ( L7_sockaddr_t *)&rx_addr, &addrlen, &length) != L7_SUCCESS)
       {
+        inetAddrPrint(&dnsOprData->serverTbl[i].serverAddr, srvAddr);
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DNS_CLIENT_COMPONENT_ID,
-                "DNS Client: osapiSocketRecvFrom returned error for addr 0x%X."
+                "DNS Client: osapiSocketRecvFrom returned error for addr %s."
                 " Indicates there is a stack error in receiving the DNS response"
                 " packet from the server.",
-                inetAddrPrint(&dnsOprData->serverTbl[i].serverAddr, srvAddr));
+                srvAddr);
         continue;
       }
 
       if (length < sizeof(dnsMessageHeader_t))
       {
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DNS_CLIENT_COMPONENT_ID,
Index: src/system_support/base/network/dns/dns_client_cnfgr.c
===================================================================
--- src/system_support/base/network/dns/dns_client_cnfgr.c	(revision 7375)
+++ src/system_support/base/network/dns/dns_client_cnfgr.c	(revision 7378)
@@ -546,13 +546,13 @@ L7_RC_t dnsCnfgrUconfigPhase2(L7_CNFGR_R
   *pReason    = 0;
 
   /* disable the client */
   dnsClientAdminModeApply(L7_FALSE);
 
   memset(dnsNotifyTbl, 0, L7_LAST_COMPONENT_ID * sizeof(dnsNotifyEntry_t));
-  memset(dnsCfgData, 0, sizeof(dnsCfgData));
+  memset(dnsCfgData, 0, sizeof(*dnsCfgData));
 
   dnsCnfgrState = DNS_CLIENT_PHASE_WMU;
 
   return L7_SUCCESS;
 }
 
Index: src/system_support/base/network/xmodem/getput.c
===================================================================
--- src/system_support/base/network/xmodem/getput.c	(revision 7375)
+++ src/system_support/base/network/xmodem/getput.c	(revision 7378)
@@ -314,13 +314,14 @@ extern int consoleFd;
 int fpTtyOptions, fpTtyNewOptions;  /* vxWorks tty options */
 static int fpConsoleFd;
 #endif
 #ifdef _L7_OS_ECOS_
 struct sigaction origSignal, newSignal;
 #else
-struct sigvec origSignal, newSignal;
+/* PTin removed: GCC6 */
+//struct sigvec origSignal, newSignal;
 #endif
 
 void setmodes(void)
 {
 
   extern void onintr();
@@ -362,13 +363,14 @@ void setmodes(void)
   newSignal.sa_mask = 0;
   newSignal.sa_flags = 0;
   sigaction(SIGTERM, &newSignal, NULL);
 #else
 /* PTin modified: ARM processor */
 /* Ptin TODO: signal */
-#ifndef __arm__
+//#ifndef __arm__
+#if 0
   sigvec(SIGTERM, (struct sigvec *) NULL,  &origSignal);
   newSignal.sv_handler = onintr;
   newSignal.sv_mask = 0;
   newSignal.sv_flags = 0;
   sigvec(SIGTERM, &newSignal, NULL);
 #endif
@@ -394,13 +396,14 @@ void restoremodes(int errcall )
 #endif /* _L7_OS_VXWORKS */
 
 #ifdef _L7_OS_ECOS_
   sigaction(SIGTERM, &origSignal, NULL);
 #else
 /* PTin TODO: signal */
-#ifndef __arm__
+//#ifndef __arm__
+#if 0
   sigvec(SIGTERM, &origSignal, NULL);
 #endif
 #endif
   return;
 }
 
Index: src/system_support/base/network/dhcp/dhcp_prot.c
===================================================================
--- src/system_support/base/network/dhcp/dhcp_prot.c	(revision 7375)
+++ src/system_support/base/network/dhcp/dhcp_prot.c	(revision 7378)
@@ -317,13 +317,13 @@ get_tag( struct bootp *ppkt, L7_uchar8 t
 
     dhcpNotifyRegisteredUsers(&notifyInfo);
     break;
 
     default:
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DHCP_CLIENT_COMPONENT_ID,
-            "%s: Unsupported DHCP option requested for extraction.");
+            "%s: Unsupported DHCP option requested for extraction.", __FUNCTION__);
   }
 
   /*option was not present in the first place*/
   return L7_FAILURE;
 }
 
Index: src/system_support/base/infrastructure/nim/nim_migrate.c
===================================================================
--- src/system_support/base/infrastructure/nim/nim_migrate.c	(revision 7375)
+++ src/system_support/base/infrastructure/nim/nim_migrate.c	(revision 7378)
@@ -461,17 +461,17 @@ nimMigrateConfigV4V5Convert (nimConfigDa
   diff = L7_MAX_NUM_LAG_INTF_REL_4_4 - L7_MAX_NUM_LAG_INTF_REL_4_3;
   i = count + 1;
   count = min (L7_MAX_INTERFACE_COUNT_REL_4_3, L7_MAX_INTERFACE_COUNT_REL_4_4);
   for ( ; i <= count; i++)
   {
     MIGRATE_COPY_STRUCT (pCfgV5->cfgPort[i+diff], pCfgV4->cfgPort[i]);
-    if (pCfgV5->cfgPort[i+diff].configIdMaskOffset != 0)
-    {
-      /* Adjust configIdMaskOffset as that contains intIfNum */
-      pCfgV5->cfgPort[i+diff].configIdMaskOffset = pCfgV5->cfgPort[i+diff].configIdMaskOffset + diff;
-    }
+//    if (pCfgV5->cfgPort[i+diff].configIdMaskOffset != 0)
+//    {
+//      /* Adjust configIdMaskOffset as that contains intIfNum */
+//      pCfgV5->cfgPort[i+diff].configIdMaskOffset = pCfgV5->cfgPort[i+diff].configIdMaskOffset + diff;
+//    }
   }
 
 
 
   /* Signal truncation if more nim entries existed than can be copied to
    * the current number of entries.  Note that numOfInterfaces will already
Index: src/system_support/base/infrastructure/box_services/boxs_api.c
===================================================================
--- src/system_support/base/infrastructure/box_services/boxs_api.c	(revision 7375)
+++ src/system_support/base/infrastructure/box_services/boxs_api.c	(revision 7378)
@@ -388,13 +388,13 @@ L7_RC_t boxsApiXfpStatusTrapEnableSet(L7
 
 L7_RC_t boxsApiTempStatusTrapEnableGet(L7_BOOL *enable)
 {
   if (boxsCfg == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_BOX_SERVICES_COMPONENT_ID,
-            "invalid value %d\n",enable);
+            "invalid value %d\n", (int)enable);
     return L7_FAILURE;
   }
   /* we don't need any sync for read operation */
   *enable = boxsCfg->cfg.globalCfgData.trapTempStatusEnabled;
 
   return L7_SUCCESS;
@@ -414,13 +414,13 @@ L7_RC_t boxsApiTempStatusTrapEnableGet(L
 
 L7_RC_t boxsApiFanStatusTrapEnableGet(L7_BOOL *enable)
 {
   if (boxsCfg == L7_NULLPTR)
   {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_BOX_SERVICES_COMPONENT_ID,
-              "invalid value %d\n",enable);
+              "invalid value %d\n", (int)enable);
     return L7_FAILURE;
   }
   /* we don't need any sync for read operation */
   *enable = boxsCfg->cfg.globalCfgData.trapFanStatusEnabled;
 
   return L7_SUCCESS;
@@ -440,13 +440,13 @@ L7_RC_t boxsApiFanStatusTrapEnableGet(L7
 
 L7_RC_t boxsApiPowSupplyStatusTrapEnableGet(L7_BOOL *enable)
 {
   if (boxsCfg == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_BOX_SERVICES_COMPONENT_ID,
-            "box services configuration: null pointer\n",enable);
+            "box services configuration: null pointer\n");
     return L7_FAILURE;
   }
   /* we don't need any sync for read operation */
   *enable = boxsCfg->cfg.globalCfgData.trapPowSupplyStatusEnabled;
 
   return L7_SUCCESS;
@@ -464,13 +464,13 @@ L7_RC_t boxsApiPowSupplyStatusTrapEnable
 *********************************************************************/
 L7_RC_t boxsApiSfpStatusTrapEnableGet(L7_BOOL *enable)
 {
   if (boxsCfg == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_BOX_SERVICES_COMPONENT_ID,
-            "box services configuration: null pointer\n",enable);
+            "box services configuration: null pointer\n");
     return L7_FAILURE;
   }
   /* we don't need any sync for read operation */
   *enable = boxsCfg->cfg.globalCfgData.trapSfpStatusEnabled;
 
   return L7_SUCCESS;
@@ -488,13 +488,13 @@ L7_RC_t boxsApiSfpStatusTrapEnableGet(L7
 *********************************************************************/
 L7_RC_t boxsApiXfpStatusTrapEnableGet(L7_BOOL *enable)
 {
   if (boxsCfg == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_BOX_SERVICES_COMPONENT_ID,
-            "box services configuration: null pointer\n",enable);
+            "box services configuration: null pointer\n");
     return L7_FAILURE;
   }
   /* we don't need any sync for read operation */
   *enable = boxsCfg->cfg.globalCfgData.trapXfpStatusEnabled;
 
   return L7_SUCCESS;
Index: src/system_support/base/l7util/l7utils/l7utils_convert.c
===================================================================
--- src/system_support/base/l7util/l7utils/l7utils_convert.c	(revision 7375)
+++ src/system_support/base/l7util/l7utils/l7utils_convert.c	(revision 7378)
@@ -290,17 +290,17 @@ L7_RC_t l7utilsBitMaskToLeadingOnesCount
   *pResult = leadingOnesCount;
   return L7_SUCCESS;
 }
 
 L7_uint32 l7utilsBytesToInt(L7_char8 *b)
 {
-#ifdef PC_LINUX_HOST
+//#ifdef PC_LINUX_HOST
   return b[0]<<24 | (b[1]&0xff)<<16 | (b[2]&0xff)<<8 | (b[3]&0xff);
-#else
-  return *b<<24 | ((*++b)&0xff)<<16 | ((*++b)&0xff)<<8 | ((*++b)&0xff);
-#endif
+//#else
+//  return *b<<24 | ((*++b)&0xff)<<16 | ((*++b)&0xff)<<8 | ((*++b)&0xff);
+//#endif
 }
 
 void l7utilsIntToBytes(L7_char8 *b, L7_uint32 i)
 {
   *b   = (L7_char8)(i>>24);
   *++b = (L7_char8)(i>>16);
Index: src/system_support/base/l7util/radix/l7_radix.c
===================================================================
--- src/system_support/base/l7util/radix/l7_radix.c	(revision 7375)
+++ src/system_support/base/l7util/radix/l7_radix.c	(revision 7378)
@@ -285,17 +285,17 @@ rn_lookup(v_arg, m_arg, head, type)
    * note that we still have the match in saved_x. This
    * serves as a starting point for getting the next entry
    */
   if(!keyMatch)
     x = 0;
 
-    if (x && netmask) {
-        /* walk duplicates e.g. for 1.1.1.0/24 and 1.1.1.0/28 */
-        while (x && x->rn_mask != netmask)
-            x = x->rn_dupedkey;
-    }
+  if (x && netmask) {
+    /* walk duplicates e.g. for 1.1.1.0/24 and 1.1.1.0/28 */
+    while (x && x->rn_mask != netmask)
+      x = x->rn_dupedkey;
+  }
 
   /* exact match? */
   if(type == L7_RN_EXACT)
           return x;
 
   /* found an exact match? */
@@ -2158,13 +2158,13 @@ rn_match_count(v_arg, head, rn_bits)
      *
      * Never return the root node itself, it seems to cause a
      * lot of confusion.
      */
     if (t->rn_flags & RNF_ROOT)
         t = t->rn_dupedkey;
-        return t;
+    return t;
 
 on1:
     /* The search tested the bit specified by rn_bmask (rn_bit)
      * so some other  bit may also vary before it!
      * So find first bit that differs!
      * also test is an int so & with 0xff to ensure all leading bits are zero */
Index: src/l7public/common/ptin/logger.h
===================================================================
--- src/l7public/common/ptin/logger.h	(revision 7375)
+++ src/l7public/common/ptin/logger.h	(revision 7378)
@@ -186,13 +186,13 @@ extern int logger_color_set(unsigned int
  * @param func Function name (can be NULL)
  * @param line Line# (if zero, is ignored)
  * @param fmt  Format string+ arguments (like printf)
  */
 extern int logger_check(log_context_t ctx, log_severity_t sev);
 extern int logger_print(log_context_t ctx, log_severity_t sev, char const *file,
-                        char const *func, int line, char const *fmt, ...);
+                         char const *func, int line, char const *fmt, ...) __attribute__((format(printf, 6, 7)));
 
 
 #define PT_LOG_TRACE(ctx , fmt , args... ) \
     (logger_check(ctx, LOG_SEV_TRACE   ) ? logger_print(ctx, LOG_SEV_TRACE   , NULL, __FUNCTION__, __LINE__, fmt, ##args) : 0)
     
 #define PT_LOG_DEBUG(ctx , fmt , args... ) \
Index: src/l7public/common/ptin/ptin_utils.h
===================================================================
--- src/l7public/common/ptin/ptin_utils.h	(revision 7375)
+++ src/l7public/common/ptin/ptin_utils.h	(revision 7378)
@@ -169,19 +169,19 @@ extern dl_queue_elem_t * dl_queue_get_ne
 
 
 /****************************************************************************** 
  * BITMAPS MANIPULATION
  ******************************************************************************/
 
-extern inline int _bmp_set(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
-extern inline int _bmp_set_all(bmp_cell_t bmp[], unsigned int sizeof_bmp);
+extern int _bmp_set(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
+extern int _bmp_set_all(bmp_cell_t bmp[], unsigned int sizeof_bmp);
 
-extern inline int _bmp_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
-extern inline int _bmp_clear_all(bmp_cell_t bmp[], unsigned int sizeof_bmp);
+extern int _bmp_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
+extern int _bmp_clear_all(bmp_cell_t bmp[], unsigned int sizeof_bmp);
                                     
-extern inline int _bmp_is_set(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
-extern inline int _bmp_is_all_set(bmp_cell_t bmp[], unsigned int sizeof_bmp);
+extern int _bmp_is_set(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
+extern int _bmp_is_all_set(bmp_cell_t bmp[], unsigned int sizeof_bmp);
 
-extern inline int _bmp_is_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
-extern inline int _bmp_is_all_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp);
+extern int _bmp_is_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
+extern int _bmp_is_all_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp);
 
 #endif
Index: src/l7public/common/ptin/ptin_globaldefs.h
===================================================================
--- src/l7public/common/ptin/ptin_globaldefs.h	(revision 7375)
+++ src/l7public/common/ptin/ptin_globaldefs.h	(revision 7378)
@@ -38,13 +38,13 @@
 #define PTIN_SYSTEM_MAX_N_LAGS                      PTIN_SYSTEM_MAX_N_PORTS
 #define PTIN_SYSTEM_MAX_NGPON2_GROUPS               64
 #define PTIN_SYSTEM_MAX_NGPON2_GROUPS_ELEMENTS      32
 #define PTIN_SYSTEM_MAX_SERVICES_PER_ONU            8
 #define PTIN_SYSTEM_ETH_MTU_SIZE                    9600
 #define PTIN_SYSTEM_PON_MTU_SIZE                    2048
-#define PTIN_SYSTEM_EXT_EVCS_MGMT                   (1UL << 22)     /* 17 bits will be used by management */
+#define PTIN_SYSTEM_EXT_EVCS_MGMT                   (1U << 22)     /* 17 bits will be used by management */
 #define PTIN_SYSTEM_N_EXTENDED_EVCS                 (PTIN_SYSTEM_EXT_EVCS_MGMT + 64)    /* 64 Extra EVCs */
 
 #define PTIN_IS_PORT_PON(p)           ((((unsigned long long)1 << p) & PTIN_SYSTEM_PON_PORTS_MASK) != 0)
 #define PTIN_IS_PORT_ETH(p)           ((((unsigned long long)1 << p) & PTIN_SYSTEM_ETH_PORTS_MASK) != 0)
 #define PTIN_IS_PORT_10G(p)           ((((unsigned long long)1 << p) & PTIN_SYSTEM_10G_PORTS_MASK) != 0)
 
Index: src/application/ip_mcast/mapping/mcastmap/core/mcast_debug.c
===================================================================
--- src/application/ip_mcast/mapping/mcastmap/core/mcast_debug.c	(revision 7375)
+++ src/application/ip_mcast/mapping/mcastmap/core/mcast_debug.c	(revision 7378)
@@ -747,13 +747,13 @@ void mcastDebugPacketRxTxTrace(L7_uchar8
     MCAST_USER_TRACE("Received mcast data pkt with Src %s and Grp %s on interface %d/%d/%d of len = %d",
                      inetAddrPrint(&srcAddr, srcBuff), inetAddrPrint(&grpAddr, destBuff),
                      usp.unit, usp.slot, usp.port, length);
   }
   else
   {
-    MCAST_USER_TRACE("Sent mcast data pkt %s with Src %s and Grp %s on interface %d/%d/%d of len = %d ",
+    MCAST_USER_TRACE("Sent mcast data pkt with Src %s and Grp %s on interface %d/%d/%d of len = %d ",
                      inetAddrPrint(&srcAddr, srcBuff), inetAddrPrint(&grpAddr, destBuff),
                      usp.unit, usp.slot, usp.port, length);
   }
   return;
 }
 
Index: src/application/ip_mcast/mapping/dvmrpmap/dvmrp_map_util.c
===================================================================
--- src/application/ip_mcast/mapping/dvmrpmap/dvmrp_map_util.c	(revision 7375)
+++ src/application/ip_mcast/mapping/dvmrpmap/dvmrp_map_util.c	(revision 7378)
@@ -195,13 +195,13 @@ L7_RC_t dvmrpMapIntfAdminModeApply(L7_ui
 
     /* delete DVMRP router multicast address from NPU */
     if (dtlIpv4LocalMulticastAddrDelete(intIfNum, L7_IP_ALL_DVMRP_RTRS_ADDR)
         != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_FLEX_DVMRP_MAP_COMPONENT_ID,
-              "DVMRP All Routers Address - %x Delete from the DTL Mcast List "
+              "DVMRP All Routers Address - %lx Delete from the DTL Mcast List "
               "Failed for intf - %s"
               " DMVRP All Routers Address deletion from the local multicast list Failed."
               " As a result of this, DVMRP Multicast packets are still received at the"
               " application though DVMRP is disabled.", L7_IP_ALL_DVMRP_RTRS_ADDR, ifName);
       /*return L7_FAILURE;*/
     }
@@ -239,13 +239,13 @@ L7_RC_t dvmrpMapIntfAdminModeApply(L7_ui
 
     /* set DVMRP router multicast address in NPU */
     if (dtlIpv4LocalMulticastAddrAdd(intIfNum, L7_IP_ALL_DVMRP_RTRS_ADDR)
         != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_FLEX_DVMRP_MAP_COMPONENT_ID,
-              "DVMRP All Routers Address - %x Add to the DTL Mcast List "
+              "DVMRP All Routers Address - %lx Add to the DTL Mcast List "
               "Failed for intf - %s"
               "DMVRP All Routers Address addition to the local multicast list Failed."
               " As a result of this, DVMRP Multicast packets with this address will not"
               " be received at the application.", L7_IP_ALL_DVMRP_RTRS_ADDR, ifName);
       return L7_FAILURE;
     }
Index: src/application/ip_mcast/vendor/pimsm/pimsmrp.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmrp.c	(revision 7375)
+++ src/application/ip_mcast/vendor/pimsm/pimsmrp.c	(revision 7378)
@@ -686,13 +686,13 @@ L7_RC_t pimsmRpGrpListGrpNodeAdd(pimsmCB
                   "Unable to allocate buffer from pimsmRpGrpAddrListPoolId");
       *ppAddrListNode = L7_NULLPTR;
       return L7_FAILURE;
     }
 
     /* 2. populate the rp_node */
-    memset(pAddrListNode,0,sizeof(pAddrListNode));
+    memset(pAddrListNode,0,sizeof(*pAddrListNode));
     inetCopy(&pAddrListNode->pimsmIpAddr, &grpAddr);
     pAddrListNode->pimsmCb = pimsmCb;
     pAddrListNode->pimsmOrigin = origin;
     pAddrListNode->pimsmMaskLen = grpMaskLen;
     pAddrListNode->pimsmRpGrpNode = (void *)pRpGrpNode;
     /*create the handle */
@@ -910,13 +910,13 @@ L7_RC_t pimsmRpSetTreeRpNodeAdd(pimsmCB_
                                 pimsmRpGrpNode_t  *pRpGrpNode,
                                 L7_inet_addr_t     rpAddr,
                                 PIMSM_RP_GRP_MAPPING_ORIGIN_TYPE  origin,
                                 pimsmAddrList_t  **ppAddrListNode)
 {
   pimsmRpBlock_t     *rpBlock;
-  pimsmAddrList_t    *pAddrListNode = L7_NULLPTR,addrListSearchNode;
+  pimsmAddrList_t    *pAddrListNode = L7_NULLPTR, addrListSearchNode;
 
   rpBlock = pimsmCb->pimsmRpInfo;
   /* 1. search for the node in the node's rp list */
   memset(&addrListSearchNode,0,sizeof(pimsmAddrList_t));
   inetCopy(&addrListSearchNode.pimsmIpAddr, &rpAddr);
   addrListSearchNode.pimsmOrigin = origin;
@@ -937,13 +937,13 @@ L7_RC_t pimsmRpSetTreeRpNodeAdd(pimsmCB_
                   "Unable to allocate buffer from pimsmRpGrpAddrListPoolId");
       *ppAddrListNode = L7_NULLPTR;
       return L7_FAILURE;
     }
 
     /* 2. populate the pRpGrpNode */
-    memset(pAddrListNode,0,sizeof(pAddrListNode));
+    memset(pAddrListNode,0,sizeof(*pAddrListNode));
     inetCopy(&pAddrListNode->pimsmIpAddr, &rpAddr);
     pAddrListNode->pimsmCb= pimsmCb;
     pAddrListNode->pimsmOrigin = origin;
     pAddrListNode->pimsmRpGrpNode = pRpGrpNode;
     pAddrListNode->pimsmOriginFlag = L7_FALSE;
     if (pimsmRpSetTreeRpIsExists(pRpSetNode, rpAddr, &origin) == L7_TRUE)
Index: src/application/switching/vlan/dot1q/dot1q_control.c
===================================================================
--- src/application/switching/vlan/dot1q/dot1q_control.c	(revision 7375)
+++ src/application/switching/vlan/dot1q/dot1q_control.c	(revision 7378)
@@ -1093,13 +1093,13 @@ L7_RC_t dot1qVlanDeleteProcess(L7_uint32
                  return L7_FAILURE;
                }   
             } 
           } 
           /* Somebody has taken the ownership and we dont need to do actual deletion */         
           L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1Q_COMPONENT_ID,
-                 "Can not delete the VLAN, Some unknown component has taken the ownership!",vlanId); 
+                 "Can not delete the VLAN=%u, Some unknown component has taken the ownership!",vlanId); 
           dot1qCurrentVlanCountUpdate(L7_TRUE);
           osapiSemaGive(dot1qSem);
           return L7_SUCCESS;  
        }
     }
 
Index: src/application/switching/dynamic_arp_inspection/dai_cnfgr.c
===================================================================
--- src/application/switching/dynamic_arp_inspection/dai_cnfgr.c	(revision 7375)
+++ src/application/switching/dynamic_arp_inspection/dai_cnfgr.c	(revision 7378)
@@ -409,13 +409,13 @@ L7_RC_t daiCnfgrInitPhase1Process(L7_CNF
   {
     *pResponse = 0;
     *pReason = L7_CNFGR_ERR_RC_LACK_OF_RESOURCES;
     daiRC = L7_ERROR;
     return daiRC;
   }
-  memset(daiInfo, 0, sizeof(daiInfo));
+  memset(daiInfo, 0, sizeof(*daiInfo));
   daiInfoInit();
 
   daiIntfInfo = (daiIntfInfo_t*) osapiMalloc(L7_DAI_COMPONENT_ID,
                                              DAI_MAX_INTF_COUNT * sizeof(daiIntfInfo_t));
   if (!daiIntfInfo)
   {
Index: src/application/switching/link_aggregation/core/dot3ad_lacp.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_lacp.c	(revision 7375)
+++ src/application/switching/link_aggregation/core/dot3ad_lacp.c	(revision 7378)
@@ -91,13 +91,17 @@ static dot3ad_mux_machine_state_t muxSta
 
 };
 
 extern L7_uint32 dot3adBufferPoolId;
 
 static unsigned short int ptin_debug_lacp = 0;
-inline void ptin_debug_lacp_set(unsigned short int enable){ptin_debug_lacp = enable;};
+
+static inline void ptin_debug_lacp_set(unsigned short int enable)
+{
+  ptin_debug_lacp = enable;
+};
 
 /**************************************************************************
 *
 * @purpose  Records the parameter values for the actor carried in the rx pdu
 *
 * @param   *p  pointer to the aggregator port structure
Index: src/application/switching/link_aggregation/core/dot3ad_debug.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_debug.c	(revision 7375)
+++ src/application/switching/link_aggregation/core/dot3ad_debug.c	(revision 7378)
@@ -852,13 +852,13 @@ char *dot3adDisplayTraceCode(L7_uchar8 t
     default: return "Unknown ";
   }
 }
 
 L7_uchar8* dot3adDisplayState(L7_uchar8 state, L7_uchar8 *buf, L7_uint32 size)
 {
- memset(buf,0,sizeof(buf));
+ memset(buf,0,size);
 
  if (state & DOT3AD_STATE_EXPIRED)
  {
   osapiSnprintfcat(buf,size,"Exp,");
  }
  if (state & DOT3AD_STATE_DEFAULTED)
Index: src/application/switching/link_aggregation/core/dot3ad_cfg.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_cfg.c	(revision 7375)
+++ src/application/switching/link_aggregation/core/dot3ad_cfg.c	(revision 7378)
@@ -481,13 +481,13 @@ void dot3adNimEventCreateCompletionCallb
         dot3adNimEventCompletionCallback(retVal);
         break;
 
       default:
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                 "%s: notification received for unknown event(%d), intf(%s), reason(%d)\n",
-            retVal.event,ifName,retVal.response.reason);
+            __FUNCTION__,retVal.event,ifName,retVal.response.reason);
         /* only care about create for now */
         break;
     }
   }
 }
 
Index: src/application/switching/voice_vlan/core/voice_vlan_db.c
===================================================================
--- src/application/switching/voice_vlan/core/voice_vlan_db.c	(revision 7375)
+++ src/application/switching/voice_vlan/core/voice_vlan_db.c	(revision 7378)
@@ -190,13 +190,13 @@ L7_RC_t voiceVlanDeviceInfoAlloc(L7_ucha
       {
         L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
         nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
 
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_VOICE_VLAN_COMPONENT_ID,
                 "%s:%d Error Adding the node to the Voice Vlan Device Info Tree for mac address: %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ,phyintf %d, %s, voice vlan : %d \n",
-                __FUNCTION__,__FILE__,
+                __FUNCTION__,__LINE__,
                 mac_addr[0],
                 mac_addr[1],
                 mac_addr[2],
                 mac_addr[3],
                 mac_addr[4],
                 mac_addr[5],
Index: src/application/switching/garp/garp_timer.c
===================================================================
--- src/application/switching/garp/garp_timer.c	(revision 7375)
+++ src/application/switching/garp/garp_timer.c	(revision 7378)
@@ -261,13 +261,13 @@ static L7_RC_t garpTimerListDeleteElemen
     }
 
 
     if (timerList == L7_NULL)
     {
         L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_GARP_COMPONENT_ID,
-                "Error:Timer Type (%d) of the timer (%x) invalid :timerList cannot be found \n", pTimer->timerType , pTimer);
+                "Error:Timer Type (%d) of the timer (%x) invalid :timerList cannot be found \n", pTimer->timerType , (L7_uint)pTimer);
         return rc;
     }
 
     if (timerList->head == L7_NULL)
     {
 
@@ -411,13 +411,13 @@ L7_RC_t garpTimerFree(garpTimerDescr_t *
                 (pTimer->timer_status == GARP_TIMER_POPPED) ? &garpTimers.garpTimersPoppedList : L7_NULL;
 
     /* delete pTimer from listToSearch */
     if (garpTimerListDeleteElement(pTimer,timerList)!= L7_SUCCESS)
     {
         L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_GARP_COMPONENT_ID,
-                "Failed to free timer: timerType %d, port %d, vid %d, status %d, expiry %d\n",
+                "Failed to free timer: timerType %d, port %d, vid %d, status %d, expiry %lld\n",
                 pTimer->timerType, pTimer->port_no, pTimer->vid, pTimer->timer_status,
                 pTimer->expiryTime);
     }
 
     /* Mark the timer as being unused */
     pTimer->timer_status = GARP_TIMER_UNDEFINED;
@@ -475,13 +475,13 @@ void garpTimerAdd(L7_uint32 vid, L7_uint
                     pTimer->timer_status, pTimer->timerType, pTimer->port_no, pTimer->vid);
         }
     }
     else
     {
         /* A timer is being added */
-        memset(pTimer, 0, sizeof(pTimer));
+        memset(pTimer, 0, sizeof(*pTimer));
 
         pTimer->timerType    = timer_type;
         pTimer->vid          = vid;
         pTimer->port_no      = port_no;
         pTimer->expiryTime   = newExpiryTime;
         pTimer->timer_status = GARP_TIMER_PENDING;
@@ -823,13 +823,13 @@ void garpDebugUnitTestGarpTimerList(L7_u
 
                 milliseconds = rand();
 
                 pTimer = &timerList[index % 20];
                 index++;
 
-                memset(pTimer, 0, sizeof(pTimer));
+                memset(pTimer, 0, sizeof(*pTimer));
 
                 pTimer->timerType    = 4;
                 pTimer->vid          = 1;
                 pTimer->port_no      = 21;
                 pTimer->expiryTime   = milliseconds + osapiTimeMillisecondsGet64();
                 pTimer->timer_status = GARP_TIMER_PENDING;
Index: src/application/switching/garp/garp_debug.c
===================================================================
--- src/application/switching/garp/garp_debug.c	(revision 7375)
+++ src/application/switching/garp/garp_debug.c	(revision 7378)
@@ -2166,13 +2166,13 @@ void garpDebugTrackVlanPrint()
   void garpDebugTrackVlanSet(Vlan_id vlanId)
   {
     L7_uint32 i=0;
     if ( vlanId > L7_MAX_VLANS)
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_GARP_COMPONENT_ID,
-              "\n%s: Vlan Id out of range. Vlan Id : %u",vlanId);
+              "\n%s: Vlan Id out of range. Vlan Id : %u", __FUNCTION__, vlanId);
       return;
     }
 
     /* check if vlanId needs to be tracked */
     for(i=0;i<vlanCnt;i++)
     {
@@ -2229,13 +2229,13 @@ void garpDebugTrackVlanRecord(L7_uchar8
      return;
    }
 
    if ((VlanIndx <0 ) || ( VlanIndx > L7_MAX_VLAN_TRACK))
    {
      L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_GARP_COMPONENT_ID,
-             "\n%s: Vlan Id out of range. Vlan Index : %u",VlanIndx);
+             "\n%s: Vlan Id out of range. Vlan Index : %u", __FUNCTION__, VlanIndx);
      return;
    }
 
    /* set vlan cnt */
    if (garpDebugVlanRec[VlanIndx].bVlanCreated == L7_FALSE)
    {
Index: src/application/switching/garp/gid.c
===================================================================
--- src/application/switching/garp/gid.c	(revision 7375)
+++ src/application/switching/garp/gid.c	(revision 7378)
@@ -107,13 +107,13 @@ static L7_BOOL gid_create_gid(Garp *appl
 
    GARP_TRACE_INTERNAL_EVENTS("%s Gid %x created for port no %d application %s \n",
                                __FUNCTION__, my_port, port_no,
                               (GARP_GMRP_APP == application->app) ? "GMRP" :
                               (GARP_GVRP_APP == application->app) ? "GVRP" : "Unknown");
 
-   memset(my_port, 0x00, sizeof(my_port));
+   memset(my_port, 0x00, sizeof(*my_port));
 
    my_port->application            = application;
    my_port->port_no                = port_no;
    my_port->next_in_port_ring      = my_port;
    my_port->next_in_connected_ring = my_port;
 
Index: src/application/switching/garp/garpapi.c
===================================================================
--- src/application/switching/garp/garpapi.c	(revision 7375)
+++ src/application/switching/garp/garpapi.c	(revision 7378)
@@ -506,13 +506,13 @@ L7_uint32 GarpPktIsTagged(L7_uchar8 *pPk
 *********************************************************************/
 void garpIntfStartupCallback(NIM_STARTUP_PHASE_t startupPhase)
 {
   GarpPacket   msg;
   L7_RC_t      rc;
 
-  if (!GarpIsReady() == L7_TRUE)
+  if (GarpIsReady() != L7_TRUE)
   {
     nimStartupEventDone(L7_GARP_COMPONENT_ID);
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_GARP_COMPONENT_ID,
             "Received NIM startup %d callback while in init state %s",
             startupPhase, garpCnfgrStateNames[garpCnfgrState]);
     return;
Index: src/application/switching/dhcp_snooping/core/ds_main.c
===================================================================
--- src/application/switching/dhcp_snooping/core/ds_main.c	(revision 7375)
+++ src/application/switching/dhcp_snooping/core/ds_main.c	(revision 7378)
@@ -796,13 +796,13 @@ SYSNET_PDU_RC_t dsPacketIntercept(L7_uin
       {
         L7_uchar8 traceMsg[DS_MAX_TRACE_LEN];
         osapiSnprintf(traceMsg, DS_MAX_TRACE_LEN,
                       "(%s) Packet ignored, because of ip source (0x%08x)",
                       __FUNCTION__, osapiNtohl(ipHeader->iph_src));
         dsTraceWrite(traceMsg);
-        PT_LOG_TRACE(LOG_CTX_DHCP,"Packet ignored, because of ip source (0x%08x)", osapiNtohl(ipHeader->iph_src));
+        PT_LOG_TRACE(LOG_CTX_DHCP,"Packet ignored, because of ip source (0x%08x)", (L7_uint32)osapiNtohl(ipHeader->iph_src));
       }
 
       return SYSNET_PDU_RC_IGNORED;
     }
 
     udpHeader = (L7_udp_header_t *)((L7_char8 *)ipHeader + dsIpHdrLen(ipHeader));
@@ -2354,13 +2354,13 @@ L7_RC_t dsv6AddOption18or37(L7_uint32 in
 
    if(L7_DHCP6_OPT_INTERFACE_ID == dhcpOp)
    {
       if(!strlen(circuit_id))
       {
         if (ptin_debug_dhcp_snooping)
-          PT_LOG_ERR(LOG_CTX_DHCP, "DHCP Relay-Agent: Invalid circuit-id string (string length is 0)", circuit_id);
+          PT_LOG_ERR(LOG_CTX_DHCP, "DHCP Relay-Agent: Invalid circuit-id string (string length is 0)");
         return L7_FAILURE;
       }
       if (ptin_debug_dhcp_snooping)
         PT_LOG_TRACE(LOG_CTX_DHCP, "DHCP Relay-Agent: Adding interface-id '%s'", circuit_id);
       memcpy(frame + *frameLen, circuit_id, strlen(circuit_id)); //Copy circuit-id string
       *frameLen += strlen(circuit_id);
@@ -2374,13 +2374,13 @@ L7_RC_t dsv6AddOption18or37(L7_uint32 in
      memcpy(frame + *frameLen, &enterprise_number, sizeof(L7_uint32));
      *frameLen += sizeof(L7_uint32);
 
       if(!strlen(remote_id))
       {
         if (ptin_debug_dhcp_snooping)
-          PT_LOG_ERR(LOG_CTX_DHCP, "DHCP Relay-Agent: Invalid remote-id string (string length is 0)", remote_id);
+          PT_LOG_ERR(LOG_CTX_DHCP, "DHCP Relay-Agent: Invalid remote-id string (string length is 0)");
         return L7_FAILURE;
       }
       if (ptin_debug_dhcp_snooping)
         PT_LOG_TRACE(LOG_CTX_DHCP, "DHCP Relay-Agent: Adding remote-id '%s'", remote_id);
       memcpy(frame + *frameLen, remote_id, strlen(remote_id)); //Copy remote-id string
       *frameLen += strlen(remote_id);
@@ -3583,13 +3583,13 @@ L7_RC_t dsRelayAgentInfoRemoveOrGet (L7_
   relayEnd = relayOffset + relayLen + DHCP_OPTION_CONTENT_OFFSET;
   passOverLen = relayEnd - (L7_uchar8 *)packet;
   relayOffset += DHCP_OPTION_CONTENT_OFFSET;
   while ((relayOffset < relayEnd) && (*relayOffset != DHO_END))
   {
     if (ptin_debug_dhcp_snooping)
-      PT_LOG_TRACE(LOG_CTX_DHCP,"Suboption detected? %u (relayOffset=%u)",*relayOffset,relayOffset);
+      PT_LOG_TRACE(LOG_CTX_DHCP,"Suboption detected? (relayOffset=%u)", *relayOffset);
 
     switch (*relayOffset)
     {
     case DHCP_RELAY_AGENT_CIRCUIT_ID_SUBOPTION:
       {
         optLen = *(relayOffset + 1);
@@ -4256,13 +4256,13 @@ L7_BOOL dsFilterClientMessage(L7_uint32
           {
             lastMsg = osapiUpTimeRaw();
             nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
             dsMacToString(srcMacAddr->addr, srcMacStr);
             L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_DHCP_SNOOPING_COMPONENT_ID,
                     "DHCP snooping dropping %s received on "
-                    "interface %s, vlan %u, from %s. Station not in bindings table.",
+                    "interface %s, vlan %u, from %s. Station not in bindings table."
                       " This message appears when DHCP Snooping untrusted port  drops "
                       "DHCP Decline or DHCP release messages for a non-existing entry "
                       "in SNOOPING table.",
                     dhcpMsgTypeNames[dhcpPktType], ifName, vlanId, srcMacStr);
             dsLogEthernetHeader((L7_enetHeader_t*) frame, DS_TRACE_LOG);
             dsLogIpHeader(ipHeader, DS_TRACE_LOG);
Index: src/application/switching/dhcp_snooping/core/ds_util.c
===================================================================
--- src/application/switching/dhcp_snooping/core/ds_util.c	(revision 7375)
+++ src/application/switching/dhcp_snooping/core/ds_util.c	(revision 7378)
@@ -592,13 +592,13 @@ L7_BOOL dsIntfIsSnooping(L7_uint32 intIf
 {
   if (intIfNum > DS_MAX_INTF_COUNT)
     return L7_FALSE;
   if (dsIntfInfo[intIfNum].dsNumVlansEnabled > 0)
     return L7_TRUE;
 
-    return L7_FALSE;
+  return L7_FALSE;
 }
 
 /*********************************************************************
 * @purpose  Enable DHCP snooping on a port.
 *
 * @param    intIfNum   @b((input)) internal interface number
Index: src/application/switching/dhcp_snooping/core/ds_cnfgr.c
===================================================================
--- src/application/switching/dhcp_snooping/core/ds_cnfgr.c	(revision 7375)
+++ src/application/switching/dhcp_snooping/core/ds_cnfgr.c	(revision 7378)
@@ -470,25 +470,25 @@ L7_RC_t dsCnfgrInitPhase1Process(L7_CNFG
   {
     *pResponse = 0;
     *pReason = L7_CNFGR_ERR_RC_LACK_OF_RESOURCES;
     dsRC = L7_ERROR;
     return dsRC;
   }
-  memset(dsInfo, 0, sizeof(dsInfo));
+  memset(dsInfo, 0, sizeof(*dsInfo));
   dsInfoInit();
   dsBindingsTableCreate();
 #ifdef L7_IPSG_PACKAGE
   ipsgInfo = (ipsgInfo_t*) osapiMalloc(L7_DHCP_SNOOPING_COMPONENT_ID, sizeof(ipsgInfo_t));
   if (!ipsgInfo)
   {
     *pResponse = 0;
     *pReason = L7_CNFGR_ERR_RC_LACK_OF_RESOURCES;
     dsRC = L7_ERROR;
     return dsRC;
   }
-  memset(ipsgInfo, 0, sizeof(ipsgInfo));
+  memset(ipsgInfo, 0, sizeof(*ipsgInfo));
   ipsgInfoInit();
   ipsgEntryTableCreate();
 #endif
   dsIntfInfo = (dsIntfInfo_t*) osapiMalloc(L7_DHCP_SNOOPING_COMPONENT_ID,
                                            (DS_MAX_INTF_COUNT+1) * sizeof(dsIntfInfo_t));
   if (!dsIntfInfo)
Index: src/application/switching/port_mac_locking/pml_cnfgr.c
===================================================================
--- src/application/switching/port_mac_locking/pml_cnfgr.c	(revision 7375)
+++ src/application/switching/port_mac_locking/pml_cnfgr.c	(revision 7378)
@@ -483,13 +483,13 @@ L7_RC_t pmlCnfgrUconfigPhase2( L7_CNFGR_
     *pReason    = L7_CNFGR_ERR_RC_FATAL;
     pmlRC     = L7_ERROR;
 
     return pmlRC;
   }
 
-  memset(pmlCfgData, 0, sizeof(pmlCfgData));
+  memset(pmlCfgData, 0, sizeof(*pmlCfgData));
 
   pmlCnfgrState = PML_PHASE_WMU;
 
   return pmlRC;
 }
 
Index: src/application/switching/snooping/core/snooping_ptin_sourcetimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_sourcetimer.c	(revision 7375)
+++ src/application/switching/snooping/core/snooping_ptin_sourcetimer.c	(revision 7378)
@@ -400,14 +400,17 @@ void timerCallback(void *param)
   sourceIdx    = pTimerData->sourceIdx;
   interfacePtr = &groupData->interfaces[intIfNum];
   sourcePtr    = &groupData->interfaces[intIfNum].sources[sourceIdx];
 
   osapiSemaGive(timerSem);
 
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Sourcetimer expired (group:%s vlan:%u ifId:%u sourceAddr)", 
-            inetAddrPrint(&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), groupData->snoopPTinL3InfoDataKey.vlanId, intIfNum, inetAddrPrint(&sourcePtr->sourceAddr,debug_buf2));
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Sourcetimer expired (group:%s vlan:%u ifId:%u sourceAddr:%s)", 
+               inetAddrPrint(&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf),
+               groupData->snoopPTinL3InfoDataKey.vlanId,
+               intIfNum,
+               inetAddrPrint(&sourcePtr->sourceAddr,debug_buf2));
 
   /* Check if our handle is OK*/
   if (timerHandle != pTimerData->timerHandle)
   {
     PT_LOG_ERR(LOG_CTX_IGMP,"timerHandle and pTimerData->timerHandle do not match!");    
     return;
Index: src/application/switching/snooping/core/snooping_ptin_querytimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_querytimer.c	(revision 7375)
+++ src/application/switching/snooping/core/snooping_ptin_querytimer.c	(revision 7378)
@@ -388,13 +388,13 @@ void timerCallback(void *param)
   sourcePtr    = L7_NULLPTR;
   if (interfacePtr->filtermode == PTIN_SNOOP_FILTERMODE_EXCLUDE)
   {
     L7_uint32 i;
 
     /* Remove every source whose timer has expired */
-    for (i = 0; i < PTIN_SYSTEM_IGMP_MAXSOURCES_PER_GROUP; ++i)
+    for (i = 0; i < (sizeof(interfacePtr->sources)/sizeof(*interfacePtr->sources)); ++i)
     {
       sourcePtr = &interfacePtr->sources[i];
       if (sourcePtr->sourceTimer.isRunning == L7_FALSE)
       {
         PT_LOG_DEBUG(LOG_CTX_IGMP,"Removing sourceIdx %u", i);
         snoopPTinSourceRemove(interfacePtr, sourcePtr);
Index: src/application/switching/snooping/core/snooping_ctrl.c
===================================================================
--- src/application/switching/snooping/core/snooping_ctrl.c	(revision 7375)
+++ src/application/switching/snooping/core/snooping_ctrl.c	(revision 7378)
@@ -3387,13 +3387,14 @@ static void snoopMgmdSwitchPortOpenProce
 
   if( L7_SUCCESS != (rc=ptin_evc_intRootVlan_get(serviceId, &mcastRootVlan)))
   {
     if( rc != L7_NOT_EXIST)
     {
       if (ptin_debug_igmp_snooping)
-        PT_LOG_ERR(LOG_CTX_IGMP, "Unable to get mcastRootVlan [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s isStatic:%s isProtection:%s]", mcastRootVlan, serviceId, intIfNum, groupAddrStr, sourceAddrStr, isStatic?"Yes":"No", isProtection?"Yes":"No");
+        PT_LOG_ERR(LOG_CTX_IGMP, "Unable to get mcastRootVlan [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s isStatic:%s isProtection:%s]",
+                   serviceId, intIfNum, groupAddrStr, sourceAddrStr, isStatic?"Yes":"No", isProtection?"Yes":"No");
       return;
     }
     if (ptin_debug_igmp_snooping)
       PT_LOG_NOTICE(LOG_CTX_IGMP, "Evc Id is not yet created. Silently Ignoring Port Open Request! [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s isStatic:%s isProtection:%s]", serviceId, intIfNum, groupAddrStr, sourceAddrStr, isStatic?"Yes":"No", isProtection?"Yes":"No");
     return;
   }
Index: src/application/switching/snooping/core/snooping_ptin_util.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_util.c	(revision 7375)
+++ src/application/switching/snooping/core/snooping_ptin_util.c	(revision 7378)
@@ -719,13 +719,14 @@ L7_RC_t snoopPTinPacketBuild(L7_uint32 v
     /* Validate the group address being reported */
     snoopMulticastMacFromIpAddr(destIp, destMac);
 
     /* Validate MAC address */
     if (snoopMacAddrCheck(destMac, L7_AF_INET) != L7_SUCCESS)
     {
-      PT_LOG_ERR(LOG_CTX_IGMP, "Invalid MAC Address :%06x",destMac);
+      PT_LOG_ERR(LOG_CTX_IGMP, "Invalid MAC Address :%02x:%02x:%02x:%02x:%02x:%02x",
+                 destMac[0], destMac[1], destMac[2], destMac[3], destMac[4], destMac[5]);
       return L7_FAILURE;
     }
 
     /* Get base MAC address (could be BIA or LAA) and use it as src MAC */
     if (simGetSystemIPMacType() == L7_SYSMAC_BIA)
     {
@@ -828,13 +829,13 @@ L7_RC_t snoopPTinPacketBuild(L7_uint32 v
   /* Update frame length */
   *length = L7_ENET_HDR_SIZE + 4 + L7_ENET_ENCAPS_HDR_SIZE + L7_IP_HDR_LEN + IGMP_IP_ROUTER_ALERT_LENGTH + igmpFrameLength;
 
   /* Verify packet size */
   if (*length > L7_MAX_FRAME_SIZE)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Packet Size Invalid length : %u > L7_MAX_FRAME_SIZE",*length,L7_MAX_FRAME_SIZE);
+    PT_LOG_ERR(LOG_CTX_IGMP, "Packet Size Invalid length : %u > L7_MAX_FRAME_SIZE=%u", *length, L7_MAX_FRAME_SIZE);
     return L7_FAILURE;
   }
   else
   {
     PT_LOG_TRACE(LOG_CTX_IGMP, "Packet Size length : %u" ,*length);
   }
Index: src/application/switching/snooping/core/snooping_api.c
===================================================================
--- src/application/switching/snooping/core/snooping_api.c	(revision 7375)
+++ src/application/switching/snooping/core/snooping_api.c	(revision 7378)
@@ -92,13 +92,13 @@ L7_RC_t __remoteslot_mfdbport_sync(L7_ui
     }    
   }
   else
   {
     if (workingPortId == protectionPortId)
     {
-      PT_LOG_ERR(LOG_CTX_PROTB, "Invalid Configuration: protectionSlotId:%u == workingSlotId:%u && workingPortId == protectionPortId = :%u", protectionSlotId, workingPortId);
+      PT_LOG_ERR(LOG_CTX_PROTB, "Invalid Configuration: protectionSlotId:%u == workingSlotId:%u && workingPortId == protectionPortId = :%u", protectionSlotId, workingSlotId, workingPortId);
       return L7_FAILURE;
     }
   }  
 
   /* Fill the sync structure */
   mgmdPortSync.SlotId     = protectionSlotId;
@@ -4083,13 +4083,13 @@ L7_RC_t snoopPortClose(L7_uint32 service
   char           groupAddrStr[IPV6_DISP_ADDR_LEN]={};
   char           sourceAddrStr[IPV6_DISP_ADDR_LEN]={};
 
   inetAddrPrint(groupAddr, groupAddrStr);
   inetAddrPrint(sourceAddr, sourceAddrStr);
 
-  PT_LOG_DEBUG(LOG_CTX_IGMP, "Context [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s isProtection:%s]", serviceId, intIfNum, groupAddr, sourceAddr, isProtection?"Yes":"No");
+  PT_LOG_DEBUG(LOG_CTX_IGMP, "Context [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s isProtection:%s]", serviceId, intIfNum, groupAddrStr, sourceAddrStr, isProtection?"Yes":"No");
 
 #if !PTIN_SYSTEM_IGMP_L3_MULTICAST_FORWARD
   /*In L2 we do not support forwarding multicast packets based on the Source Address. 
     To support IGMPv3 protocol we only close the ports if the Source Address is equal to 0x0000.
     If not we ignore the request*/
   if(sourceAddr != PTIN_MGMD_ANY_IPv4_HOST)
@@ -4116,13 +4116,13 @@ L7_RC_t snoopPortClose(L7_uint32 service
   #error "Not Implemented Yet!"
   #endif
   && isProtection == L7_FALSE
   )
   {
 //  if (ptin_debug_igmp_snooping)
-      PT_LOG_NOTICE(LOG_CTX_IGMP, "Ignoring Port Close. This port is standby [serviceId:%u portId:%u groupAddr:%08X sourceAddr:%08X]", serviceId, intIfNum, groupAddr, sourceAddr);
+      PT_LOG_NOTICE(LOG_CTX_IGMP, "Ignoring Port Close. This port is standby [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s]", serviceId, intIfNum, groupAddrStr, sourceAddrStr);
    
     return rc;
   } 
 
   /* Get Snoop Execution Block and Control Block */
   pSnoopEB = snoopEBGet();
Index: src/application/switching/snooping/core/snooping_ptin_proxytimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_proxytimer.c	(revision 7375)
+++ src/application/switching/snooping/core/snooping_ptin_proxytimer.c	(revision 7378)
@@ -518,13 +518,13 @@ L7_RC_t snoop_ptin_proxytimer_start(snoo
   else
   {
 #if 0
     PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Group timer (timeout:%u group:%s)",timeout,
               inetAddrPrint(&pTimer->(snoopPTinProxyGroup_t*)(groupData)->key.groupAddr, debug_buf));
 #else
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Group timer (timeout:%u groupRecord:%u",timeout);
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Group timer (timeout:%u",timeout);
 #endif
   }
 
   /* New timer handle */
   if ((pTimer->timerHandle = handleListNodeStore(handleList, pTimer)) == 0)
   {
@@ -552,13 +552,13 @@ L7_RC_t snoop_ptin_proxytimer_start(snoo
     if (appTimerDelete(cbTimer, pTimer->timer) != L7_SUCCESS)
     {
       PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
     }
     pTimer->timer = L7_NULLPTR;
     handleListNodeDelete(handleList, &pTimer->timerHandle);
-    memset(pTimer, 0x00, sizeof(pTimer));
+    memset(pTimer, 0x00, sizeof(*pTimer));
     osapiSemaGive(timerSem);
     PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
     return L7_FAILURE;
   }
 
   osapiSemaGive(timerSem);
Index: src/application/switching/snooping/core/snooping_ptin_db.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_db.c	(revision 7375)
+++ src/application/switching/snooping/core/snooping_ptin_db.c	(revision 7378)
@@ -3287,13 +3287,14 @@ static L7_RC_t snoopPTinActiveGroups(L7_
  *
  *************************************************************************/
 L7_RC_t snoopPTinAddStaticGroup(L7_uint32 vlanId, L7_uint32 intIfNum,L7_inet_addr_t *groupAddr,L7_uint32 noOfSources,L7_inet_addr_t* sourceAddr)
 {
   ptin_IgmpProxyCfg_t igmpCfg;  
   L7_uint32 clientIdx;
-  snoopPTinL3InfoData_t  *snoopEntry; 
+  snoopPTinL3InfoData_t  *snoopEntry;
+  L7_uchar8 groupAddrStr[IPV6_DISP_ADDR_LEN];
 
   L7_BOOL newEntry,interfaceProvided=L7_FALSE;
 
 
   L7_RC_t rc=L7_SUCCESS;
 
@@ -3330,13 +3331,13 @@ L7_RC_t snoopPTinAddStaticGroup(L7_uint3
     {
       PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Add L3 Entry");
       return L7_FAILURE;
     }
     else
     {
-      PT_LOG_TRACE(LOG_CTX_IGMP, "snoopPTinL3EntryAdd(%u,%u)",groupAddr,vlanId);
+      PT_LOG_TRACE(LOG_CTX_IGMP, "snoopPTinL3EntryAdd(%u,%s)", vlanId, inetAddrPrint(groupAddr, groupAddrStr));
     }
     if (L7_NULLPTR == (snoopEntry = snoopPTinL3EntryFind(vlanId, groupAddr, L7_MATCH_EXACT)))
     {
       PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Add&Find L3 Entry");
       return L7_FAILURE;
     }
Index: src/application/switching/snooping/core/snooping_timer.c
===================================================================
--- src/application/switching/snooping/core/snooping_timer.c	(revision 7375)
+++ src/application/switching/snooping/core/snooping_timer.c	(revision 7378)
@@ -240,13 +240,13 @@ void snoopTimerUpdate(snoopInfoData_t *s
           */
 
       if (snoopTimerStart(L7_NULL, intIfNum, vlanId, timerType, pSnoopCB)
                             != L7_SUCCESS)
       {
         L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
-               "snoopTimerUpdate: Failed to re-start mrtr timer\n", timerValue);
+               "snoopTimerUpdate: Failed to re-start mrtr timer\n");
       }
     }/* End of mrtr timer data validity check */
   }/* End of timer type check */
 }
 /*************************************************************************
 * @purpose  Halts & destroys the specified timer with specified timer
Index: src/application/switching/snooping/core/snooping.c
===================================================================
--- src/application/switching/snooping/core/snooping.c	(revision 7375)
+++ src/application/switching/snooping/core/snooping.c	(revision 7378)
@@ -765,13 +765,13 @@ L7_RC_t snoopPacketHandle(L7_netBufHandl
      {
        ptin_timer_stop(74);  
        /*Client Does Not Exist*/
        if (rc == L7_NOT_EXIST)
        {
          #ifdef IGMP_DYNAMIC_CLIENTS_SUPPORTED
-          PT_LOG_TRACE(LOG_CTX_IGMP,"Client Does Not Exist: (intIfNum=%u vlan=%u innerVlanId=%u", rc, pduInfo->intIfNum, pduInfo->vlanId, pduInfo->innerVlanId);  
+          PT_LOG_TRACE(LOG_CTX_IGMP,"Client Does Not Exist: (intIfNum=%u vlan=%u innerVlanId=%u", pduInfo->intIfNum, pduInfo->vlanId, pduInfo->innerVlanId);  
          #else         
           PT_LOG_ERR(LOG_CTX_IGMP,"Failed (rc:%u) to obtain clientId (intIfNum=%u vlan=%u innerVlanId=%u", rc, pduInfo->intIfNum, pduInfo->vlanId, pduInfo->innerVlanId);  
           return L7_FAILURE;
          #endif
        }
        else
@@ -923,21 +923,22 @@ L7_RC_t snoopPacketHandle(L7_netBufHandl
           //Convert to Little Endian
           sourceAddr.addr.ipv4.s_addr = osapiNtohl(sourceAddr.addr.ipv4.s_addr);
         }        
       }
       else
       {
-        PT_LOG_DEBUG(LOG_CTX_IGMP,"Number of Group Records:%u [vlan=%u innerVlan=%u client_idx]: Packet Silently ignored...",
+        PT_LOG_DEBUG(LOG_CTX_IGMP,"Number of Group Records:%u [vlan=%u innerVlan=%u client_idx=%u]: Packet Silently ignored...",
                 noOfGroupRecords, pduInfo->vlanId, pduInfo->innerVlanId, client_idx);  
         ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
         return L7_FAILURE;
       }      
     }
     else
     {
-      PT_LOG_ERR(LOG_CTX_IGMP, "Protocol Not Supported :%u [vlan=%u innerVlan=%u client_idx]", igmpPtr[0], pduInfo->vlanId, pduInfo->innerVlanId, client_idx);
+      PT_LOG_ERR(LOG_CTX_IGMP, "Protocol Not Supported :%u [vlan=%u innerVlan=%u client_idx=%u]",
+                 igmpPtr[0], pduInfo->vlanId, pduInfo->innerVlanId, client_idx);
       ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
       return L7_NOT_SUPPORTED;
     }
      
     /*RFC5771 - Local Network Control Block (224.0.0.0 - 224.0.0.255 (224.0.0/24)) 
     The range of addresses between 224.0.0.0 and 224.0.0.255, inclusive, is reserved for the use of routing protocols and other low-level topology discovery or maintenance protocols, such as gateway discovery
@@ -1927,13 +1928,13 @@ L7_RC_t snoopPacketProcess(snoopPDU_Msg_
     snoopStatIgmpField=SNOOP_STAT_FIELD_VALID_RX;
   else if (rc==L7_FAILURE) /*Invalid Packet Type*/
     snoopStatIgmpField=SNOOP_STAT_FIELD_INVALID_RX;
   else /*if (rc==L7_ERROR)*/
     snoopStatIgmpField=SNOOP_STAT_FIELD_DROPPED_RX;               
 
-    ptin_igmp_stat_increment_field(mcastPacket.intIfNum, mcastPacket.vlanId, mcastPacket.client_idx, snoopPacketType2IGMPStatField(/*mcastPacket.msgType*/msgType,snoopStatIgmpField));
+  ptin_igmp_stat_increment_field(mcastPacket.intIfNum, mcastPacket.vlanId, mcastPacket.client_idx, snoopPacketType2IGMPStatField(/*mcastPacket.msgType*/msgType,snoopStatIgmpField));
 #endif
 
 
   /* If client is dynamic, and no channels are associated, flush it */
   //ptin_igmp_dynamic_client_flush(mcastPacket.vlanId, mcastPacket.client_idx);
 
Index: src/application/switching/snooping/core/snooping_db.c
===================================================================
--- src/application/switching/snooping/core/snooping_db.c	(revision 7375)
+++ src/application/switching/snooping/core/snooping_db.c	(revision 7378)
@@ -1690,13 +1690,13 @@ L7_RC_t snoopChannelClientAdd(snoopInfoD
   }
 
   /* Verify if one more client can be added */
   if (snoopEntry->channel_list[channel_index].number_of_clients>=PTIN_SYSTEM_IGMP_MAXCLIENTS)
   {
     if (ptin_debug_igmp_snooping)
-      PT_LOG_ERR(LOG_CTX_IGMP,"snoopClientAdd: No more room to add a new client",client);
+      PT_LOG_ERR(LOG_CTX_IGMP,"snoopClientAdd: No more room to add a new client (idx %u)", client);
     return L7_FAILURE;
   }
 
   /* Activate new client for this IP channel */
   PTIN_SET_MASKBIT(snoopEntry->channel_list[channel_index].clients_list,client);
   PTIN_INCREMENT_COUNTER(snoopEntry->channel_list[channel_index].intf_number_of_clients[intIfNum],1);
@@ -1814,12 +1814,13 @@ L7_RC_t snoop_channel_add_procedure(L7_u
   snoopInfoData_t *snoopEntry;
   L7_BOOL fwdFlag = L7_FALSE;
   L7_uint32 igmp_network_version;
   L7_uint32 intIfNum;
   L7_INTF_MASK_t mcastClientAttached;
   L7_uint32      noOfInterfaces = 0;
+  L7_char8       groupAddrStr[IPV6_DISP_ADDR_LEN];
 
   /* Validate arguments */
   if (dmac==L7_NULLPTR || vlanId<PTIN_VLAN_MIN || vlanId>PTIN_VLAN_MAX ||
       mgmdGroupAddr==L7_NULLPTR || mgmdGroupAddr->family!=L7_AF_INET)
   {
     if (ptin_debug_igmp_snooping)
@@ -1958,13 +1959,13 @@ L7_RC_t snoop_channel_add_procedure(L7_u
       {
         if ( (L7_INTF_ISMASKBITSET(mcastClientAttached,intIfNum)) )
         {
           if (snoopChannelIntfAdd(snoopEntry, intIfNum, mgmdGroupAddr, L7_FALSE)!=L7_SUCCESS)
           {
             if (ptin_debug_igmp_snooping)
-              PT_LOG_ERR(LOG_CTX_IGMP, "Error adding intIfNum %u to channel 0x%08x",intIfNum,mgmdGroupAddr);
+              PT_LOG_ERR(LOG_CTX_IGMP, "Error adding intIfNum %u to channel %s", intIfNum, inetAddrPrint(mgmdGroupAddr,  groupAddrStr));
           }
         }
       }
     }
 
     /* Only send joins if in matrix or standalone */
@@ -3487,13 +3488,13 @@ L7_RC_t snoopL3GroupIntfRemove(L7_uint32
         }
 
         if (PTIN_IS_MASKBITSET(pChannelIntfMask->snoopChannelIntfMaskInfoDataKey.channelIntfMask, intf))
         {
           if (intf == intIfNum)
           {
-            PT_LOG_ERR(LOG_CTX_IGMP, "intf == intIfNum", intf, intIfNum);              
+            PT_LOG_ERR(LOG_CTX_IGMP, "intf == intIfNum = %u", intf);
           }
           #if defined IGMP_SMART_MC_EVC_SUPPORTED
           l3_intf_id = -1;
           L7_uint32 iptv_evc_id;
 
           if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
@@ -4153,13 +4154,13 @@ L7_BOOL snoopChannelExist4VlanId(L7_uint
   channel_index = PTIN_CHANNEL_INDEX_GET(channel);
 
   /* Find snoop entry */
   if ((entry=snoopEntryFind(dmac,vlanId,L7_AF_INET,AVL_EXACT))==L7_NULLPTR)
   {
     if (ptin_debug_igmp_snooping)
-      PT_LOG_WARN(LOG_CTX_IGMP,"VLAN+MAC (%u+%02x:02x:02x:02x:02x:02x) do not exist!",vlanId,dmac[0],dmac[1],dmac[2],dmac[3],dmac[4],dmac[5]);
+      PT_LOG_WARN(LOG_CTX_IGMP,"VLAN+MAC (%u+%02x:%02x:%02x:%02x:%02x:%02x) do not exist!",vlanId,dmac[0],dmac[1],dmac[2],dmac[3],dmac[4],dmac[5]);
     return L7_FALSE;
   }
 
   /* Output snoop entry pointer */
   if (snoopEntry!=L7_NULLPTR)
   {
@@ -4439,13 +4440,14 @@ void snoopChannelsGet(L7_uint16 vlanId,
     {
       PT_LOG_NOTICE(LOG_CTX_IGMP,"Found group :%s", inetAddrPrint(&avlTreeEntry->snoopPTinL3InfoDataKey.mcastGroupAddr, debug_buf));
 
       snoopPTinL3Interface_t  *interface_ptr;
       L7_uint8                sourceIdx;
 
-      PT_LOG_TRACE(LOG_CTX_IGMP,"\tInterface:%u Clients:0x%0*X", 8*PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE, SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM);
+// ARS: comentado porque no existe correlao entre a fmt string e os parametros
+//      PT_LOG_TRACE(LOG_CTX_IGMP,"\tInterface:%u Clients:0x%0*X", 8*PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE, SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM);
 
       //Add an entry for clients that have requested this group but with no source in particular.
       interface_ptr = &avlTreeEntry->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM];
 
       
       for (sourceIdx=0; sourceIdx < PTIN_SYSTEM_IGMP_MAXSOURCES_PER_GROUP; ++sourceIdx)
@@ -4475,13 +4477,14 @@ void snoopChannelsGet(L7_uint16 vlanId,
             avlTreeEntry->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM].sources[sourceIdx].sourceTimer.isRunning==L7_TRUE &&
             snoopPTinZeroClients(avlTreeEntry->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM].sources[sourceIdx].clients)==L7_ALREADY_CONFIGURED)
         { 
           //Filter by client (if requested)
           if ((client_index == (L7_uint16)-1) || (PTIN_IS_MASKBITSET(avlTreeEntry->interfaces[intIfNum].sources[sourceIdx].clients, client_index)))
           {
-            PT_LOG_TRACE(LOG_CTX_IGMP,"\t\tSource:0x%08X Clients:0x%0*X", 8*PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE, source_ptr->sourceAddr);
+// ARS: comentado porque no existe correlao entre a fmt string e os parametros
+//            PT_LOG_TRACE(LOG_CTX_IGMP,"\t\tSource:0x%08X Clients:0x%0*X", 8*PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE, source_ptr->sourceAddr);
             inetCopy(&channel_list[*num_channels].groupAddr, &avlTreeKey.mcastGroupAddr);
             inetCopy(&channel_list[*num_channels].sourceAddr, &source_ptr->sourceAddr);
             /* If group address is static, get static information to source channel */
             if (avlTreeEntry->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM].isStatic)
             {
               channel_list[*num_channels].static_type = source_ptr->isStatic;
@@ -6061,15 +6064,15 @@ snoopPTinProxyGroup_t *snoopPTinProxyGro
 
 #if 0
   fdbGetTypeOfVL(&fdbType);
 #endif
 
 //memcpy(&key.interfacePtr,&interfacePtr, sizeof(snoopPTinProxyInterface_t*));
-  memcpy(&key.vlanId,&vlanId, sizeof(L7_uint32*));  
-  memcpy(&key.groupAddr,groupAddr,sizeof(L7_inet_addr_t));
-  memcpy(&key.recordType,&recordType,sizeof(L7_uint8));
+  memcpy(&key.vlanId, &vlanId, sizeof(key.vlanId));  
+  memcpy(&key.groupAddr, groupAddr,sizeof(L7_inet_addr_t));
+  memcpy(&key.recordType, &recordType,sizeof(L7_uint8));
   pData = avlSearchLVL7(&pSnoopEB->snoopPTinProxyGroupAvlTree, &key, flag);
   if (flag == L7_MATCH_GETNEXT)
   {
     while (pData)
     {
 #if 0
Index: src/application/switching/snooping/core/snooping_ptin_grouptimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_grouptimer.c	(revision 7375)
+++ src/application/switching/snooping/core/snooping_ptin_grouptimer.c	(revision 7378)
@@ -593,13 +593,13 @@ L7_RC_t snoop_ptin_grouptimer_start(snoo
     if (appTimerDelete(cbTimer, pTimer->timer) != L7_SUCCESS)
     {
       PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
     }
     pTimer->timer = L7_NULLPTR;
     handleListNodeDelete(handleList, &pTimer->timerHandle);
-    memset(pTimer, 0x00, sizeof(pTimer));
+    memset(pTimer, 0x00, sizeof(*pTimer));
     osapiSemaGive(timerSem);
     PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
     return L7_FAILURE;
   }
 
   osapiSemaGive(timerSem);
Index: src/application/switching/spanning_tree/dot1s/core/dot1s_cfg.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/core/dot1s_cfg.c	(revision 7375)
+++ src/application/switching/spanning_tree/dot1s/core/dot1s_cfg.c	(revision 7378)
@@ -535,86 +535,86 @@ L7_RC_t dot1sApplyConfigData(void)
       continue;
     if (nimIntIfFromConfigIDGet(&dot1sCfg->cfg.dot1sCfgPort[i].configId, &intIfNum) != L7_SUCCESS)
       continue;
     if (dot1sIsValidIntf(intIfNum) != L7_TRUE)
       continue;
 
-      pPort = dot1sIntfFind(intIfNum);
+    pPort = dot1sIntfFind(intIfNum);
 
-      if (pPort == L7_NULLPTR)
-      {
-        return L7_FAILURE;
-      }
-      /* Initialize with the defaults then replace the configured fields
-       * with their configured values.
-       */
-      rc = dot1sPortDefaultPopulate(pPort, intIfNum);
+    if (pPort == L7_NULLPTR)
+    {
+      return L7_FAILURE;
+    }
+    /* Initialize with the defaults then replace the configured fields
+     * with their configured values.
+     */
+    rc = dot1sPortDefaultPopulate(pPort, intIfNum);
 
     pPortCfg = &dot1sCfg->cfg.dot1sCfgPort[intIfNum];
 
-      pPort->portAdminMode = pPortCfg->portAdminMode;
-      /* notParticipating must be kept in sync with Admin Mode
-       * up until the time of an IhAcquire or IhRelease
-       */
-      if (pPort->portAdminMode == L7_ENABLE)
-      {
-        pPort->notParticipating = L7_FALSE;
-      }
-      else
-      {
-        pPort->notParticipating = L7_TRUE;
-      }
+    pPort->portAdminMode = pPortCfg->portAdminMode;
+    /* notParticipating must be kept in sync with Admin Mode
+     * up until the time of an IhAcquire or IhRelease
+     */
+    if (pPort->portAdminMode == L7_ENABLE)
+    {
+      pPort->notParticipating = L7_FALSE;
+    }
+    else
+    {
+      pPort->notParticipating = L7_TRUE;
+    }
 
     pPort->portNum = intIfNum;
-      pPort->adminEdge = pPortCfg->adminEdge;
-      pPort->autoEdge = pPortCfg->autoEdge;
-      pPort->restrictedRole = pPortCfg->restrictedRole;
-      pPort->loopGuard = pPortCfg->loopGuard;
-      pPort->restrictedTcn = pPortCfg->restrictedTcn;
-
-      for (instIndex = DOT1S_CIST_INDEX; instIndex <= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
-      {
-        pPort->portInstInfo[instIndex].ExternalPortPathCost = pPortCfg->portInstInfo[instIndex].ExternalPortPathCost;
-        pPort->portInstInfo[instIndex].InternalPortPathCost = pPortCfg->portInstInfo[instIndex].InternalPortPathCost;
-        pPort->portInstInfo[instIndex].autoInternalPortPathCost = pPortCfg->portInstInfo[instIndex].autoInternalPortPathCost;
+    pPort->adminEdge = pPortCfg->adminEdge;
+    pPort->autoEdge = pPortCfg->autoEdge;
+    pPort->restrictedRole = pPortCfg->restrictedRole;
+    pPort->loopGuard = pPortCfg->loopGuard;
+    pPort->restrictedTcn = pPortCfg->restrictedTcn;
+
+    for (instIndex = DOT1S_CIST_INDEX; instIndex <= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
+    {
+      pPort->portInstInfo[instIndex].ExternalPortPathCost = pPortCfg->portInstInfo[instIndex].ExternalPortPathCost;
+      pPort->portInstInfo[instIndex].InternalPortPathCost = pPortCfg->portInstInfo[instIndex].InternalPortPathCost;
+      pPort->portInstInfo[instIndex].autoInternalPortPathCost = pPortCfg->portInstInfo[instIndex].autoInternalPortPathCost;
       pPort->portInstInfo[instIndex].autoExternalPortPathCost = pPortCfg->portInstInfo[instIndex].autoExternalPortPathCost;
 
       pPort->portInstInfo[instIndex].portId = ((pPortCfg->portInstInfo[instIndex].portPriority << 8) | intIfNum);
-        /* msti */
-        if (instIndex != DOT1S_CIST_INDEX)
-        {
-        priInstId = dot1sCfg->cfg.dot1sInstance.msti[instIndex].BridgeIdentifier.priInstId;
-
-          pPort->portInstInfo[instIndex].inst.msti.mstiDesignatedPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.msti.mstiDesignatedPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.msti.mstiMsgPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.msti.mstiMsgPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.msti.mstiPortPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.msti.mstiPortPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-        }
-        else /* cist */
-        {
-        priInstId = dot1sCfg->cfg.dot1sInstance.cist.BridgeIdentifier.priInstId;
+      /* msti */
+      if (instIndex != DOT1S_CIST_INDEX)
+      {
+      priInstId = dot1sCfg->cfg.dot1sInstance.msti[instIndex].BridgeIdentifier.priInstId;
 
-          pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.rootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.rootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.rootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-        }
-      }/*endfor instIndex*/
-
-      /* Handle the current link state for this port in case it is
-       * already up.
-       */
-      if (nimGetIntfLinkState(intIfNum, &portLinkState) == L7_SUCCESS)
+        pPort->portInstInfo[instIndex].inst.msti.mstiDesignatedPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.msti.mstiDesignatedPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.msti.mstiMsgPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.msti.mstiMsgPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.msti.mstiPortPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.msti.mstiPortPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+      }
+      else /* cist */
       {
+        priInstId = dot1sCfg->cfg.dot1sInstance.cist.BridgeIdentifier.priInstId;
+
+        pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.rootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.rootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.rootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+      }
+    }/*endfor instIndex*/
+
+    /* Handle the current link state for this port in case it is
+     * already up.
+     */
+    if (nimGetIntfLinkState(intIfNum, &portLinkState) == L7_SUCCESS)
+    {
       rc = dot1sIhNotifySystem(intIfNum, portLinkState);
     }
   }
   /* Set mode to the saved configured value and generate all necessary events */
   if (cfgMode == L7_ENABLE)
   {
Index: src/application/switching/spanning_tree/dot1s/encryption/md5.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/encryption/md5.c	(revision 7375)
+++ src/application/switching/spanning_tree/dot1s/encryption/md5.c	(revision 7378)
@@ -140,14 +140,14 @@ void L7_MD5Update (L7_MD5_CTX_t *context
 
   /* Compute number of bytes mod 64 */
   index = (L7_uint32)((context->count[0] >> 3) & 0x3F);
 
   /* Update number of bits */
   if ((context->count[0] += ((L7_uint32)inputLen << 3)) < ((L7_uint32)inputLen << 3))
-	  context->count[1]++;
-	  context->count[1] += ((L7_uint32)inputLen >> 29);
+    context->count[1]++;
+  context->count[1] += ((L7_uint32)inputLen >> 29);
 
   partLen = 64 - index;
 
   /* Transform as many times as possible.
 */
   if (inputLen >= partLen) {
Index: src/application/qos/diffserv/base/diffserv_distiller.c
===================================================================
--- src/application/qos/diffserv/base/diffserv_distiller.c	(revision 7375)
+++ src/application/qos/diffserv/base/diffserv_distiller.c	(revision 7378)
@@ -1416,13 +1416,13 @@ L7_RC_t dsDistillerPolicyEvaluate(L7_uin
                                         &nameStr) != L7_SUCCESS)
             {
               sprintf((char *)nameStr, "index %u", policyIndex);
             }
             L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
                     "Policy invalid for service intf: "
-                    "policy \'%s\', intf %s, direction %u."
+                    "policy \'%s\', intf %u, direction %u."
                     " The DiffServ policy definition is not compatible"
                     " with the capabilities of the interface specified.  "
                     "Check the platform release notes for information on "
                     "configuration limitations.",
                     (char *)nameStr, intIfNum, ifDirection);
 
Index: src/application/qos/diffserv/base/diffserv_cluster.c
===================================================================
--- src/application/qos/diffserv/base/diffserv_cluster.c	(revision 7375)
+++ src/application/qos/diffserv/base/diffserv_cluster.c	(revision 7378)
@@ -2860,13 +2860,13 @@ L7_RC_t diffServClusterConfigVerify(L7_d
    *       from the service interface, but does not result in a config failure.
    */
   if (diffServClusterConfigServiceIntfRemap(pCfgData) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
             "%s: Error mapping DiffServ service interface config.\n",
-            __FUNCTION__, dsmibPrvtTableIdStr[tableID]);
+            __FUNCTION__);
     rc = L7_FAILURE;
   }
 
   DIFFSERV_CLUSTER_DLOG("LEAVING %s (rc = %d)\n", __FUNCTION__, rc);
 
   return rc;
Index: src/application/qos/iscsi/core/iscsi.c
===================================================================
--- src/application/qos/iscsi/core/iscsi.c	(revision 7375)
+++ src/application/qos/iscsi/core/iscsi.c	(revision 7378)
@@ -491,13 +491,13 @@ L7_RC_t iscsiImpTargetTcpPortAdd(L7_uint
 {
   if (dtlIscsiTargetPortAdd(tcpPort, ipAddress, cosQueue, taggingEnabled, tagMode, tagData) == L7_SUCCESS)
     return L7_SUCCESS;
   else
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_FLEX_QOS_ISCSI_COMPONENT_ID,
-            "Error adding iSCSI target TCP port/address: tcpPort = %u, ipAddress=%X, cosQueue=%u, ",
+            "Error adding iSCSI target TCP port/address: tcpPort = %u, ipAddress=%X, cosQueue=%u, "
             "taggingEnabled=%u, tagMode=%u, tagData=%u",
             tcpPort, ipAddress, cosQueue, taggingEnabled, tagMode, tagData);
     return L7_FAILURE;
   }
 }
 
Index: src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c
===================================================================
--- src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c	(revision 7375)
+++ src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c	(revision 7378)
@@ -2314,117 +2314,117 @@ L7_RC_t ospfMapExtenIfStatusSet(L7_uint3
 
   /* In this function, we check for the secondaryFlags that
    * was set due to "network area" or "ip ospf area secondaries none"
    * and compile only the enabled addresses on the interface
    * and inform the vendor code.
    */
-    if ((p_IFO = ifoPtrGet(intIfNum)) == NULL)
-    {
-        return L7_ERROR;
-    }
+  if ((p_IFO = ifoPtrGet(intIfNum)) == NULL)
+  {
+      return L7_ERROR;
+  }
 
-    memcpy(&ifoCfg, &p_IFO->Cfg, sizeof(t_IFO_Cfg));
+  memcpy(&ifoCfg, &p_IFO->Cfg, sizeof(t_IFO_Cfg));
   memcpy((L7_char8 *)prevAddrs, (L7_char8 *)ifoCfg.addrs,
          L7_L3_NUM_IP_ADDRS*sizeof(L7_rtrIntfIpAddr_t));
 
-    if (ipMapRtrIntfIpAddrListGet(intIfNum, addrs) == L7_SUCCESS)
-    {
-    ifoCfg.DupNet[0] = 0;
-    memset((L7_char8 *)ifoCfg.addrs, 0,
-               L7_L3_NUM_IP_ADDRS*(sizeof(L7_rtrIntfIpAddr_t)));
-
-    memcpy((L7_char8 *)(&ifoCfg.addrs[0]), (L7_char8 *)(&addrs[0]),
-           sizeof(L7_rtrIntfIpAddr_t));
-
-    ospfMapIntfEffectiveSecondariesFlagGet(intIfNum, &secondariesFlag);
-    for (i = 1; i < L7_L3_NUM_IP_ADDRS; i++)
-        {
-            ifoCfg.DupNet[i] = 0;
-      if(secondariesFlag & (1<<i))
+  if (ipMapRtrIntfIpAddrListGet(intIfNum, addrs) == L7_SUCCESS)
+  {
+  ifoCfg.DupNet[0] = 0;
+  memset((L7_char8 *)ifoCfg.addrs, 0,
+             L7_L3_NUM_IP_ADDRS*(sizeof(L7_rtrIntfIpAddr_t)));
+
+  memcpy((L7_char8 *)(&ifoCfg.addrs[0]), (L7_char8 *)(&addrs[0]),
+         sizeof(L7_rtrIntfIpAddr_t));
+
+  ospfMapIntfEffectiveSecondariesFlagGet(intIfNum, &secondariesFlag);
+  for (i = 1; i < L7_L3_NUM_IP_ADDRS; i++)
       {
-        j++;
-        memcpy((L7_char8 *)(&ifoCfg.addrs[j]), (L7_char8 *)(&addrs[i]),
-               sizeof(L7_rtrIntfIpAddr_t));
+          ifoCfg.DupNet[i] = 0;
+    if(secondariesFlag & (1<<i))
+    {
+      j++;
+      memcpy((L7_char8 *)(&ifoCfg.addrs[j]), (L7_char8 *)(&addrs[i]),
+             sizeof(L7_rtrIntfIpAddr_t));
+    }
       }
-        }
 
-        for (i = 0; i < L7_L3_NUM_IP_ADDRS - 1; i++)
-        {
-            if (addrs[i].ipAddr == 0)
-            {
-                continue;
-            }
-
-            ipNet1 = addrs[i].ipAddr & addrs[i].ipMask;
-            for (j = i+1; j < L7_L3_NUM_IP_ADDRS; j++)
-            {
-                if (addrs[j].ipAddr == 0)
-                {
-                    continue;
-                }
-
-                ipNet2 = addrs[j].ipAddr & addrs[j].ipMask;
-
-                if (ipNet2 == ipNet1)
-                {
-                    ifoCfg.DupNet[j] = 1;
-                }
-            }
-        }
-    }
+      for (i = 0; i < L7_L3_NUM_IP_ADDRS - 1; i++)
+      {
+          if (addrs[i].ipAddr == 0)
+          {
+              continue;
+          }
+
+          ipNet1 = addrs[i].ipAddr & addrs[i].ipMask;
+          for (j = i+1; j < L7_L3_NUM_IP_ADDRS; j++)
+          {
+              if (addrs[j].ipAddr == 0)
+              {
+                  continue;
+              }
+
+              ipNet2 = addrs[j].ipAddr & addrs[j].ipMask;
+
+              if (ipNet2 == ipNet1)
+              {
+                  ifoCfg.DupNet[j] = 1;
+              }
+          }
+      }
+  }
 
   /* There is no change in the set of addresses
    * to be informed to the vendor code
    */
   if(memcmp((void *)prevAddrs, (void *)ifoCfg.addrs,
      L7_L3_NUM_IP_ADDRS*sizeof(L7_rtrIntfIpAddr_t)) == 0)
     return L7_SUCCESS;
 
-    switch (val)
-    {
-        case L7_OSPF_ROW_ACTIVE:
-            parm = ROW_ACTIVE;
-            break;
-
-        case L7_OSPF_ROW_NOT_IN_SERVICE:
-            parm = ROW_NOT_IN_SERVICE;
-            break;
-
-        case L7_OSPF_ROW_NOT_READY:
-            parm = ROW_NOT_READY;
-            break;
-
-        case L7_OSPF_ROW_CREATE_AND_GO:
-            parm = ROW_CREATE_AND_GO;
-            break;
-
-        case L7_OSPF_ROW_CREATE_AND_WAIT:
-            parm = ROW_CREATE_AND_WAIT;
-            break;
-
-        case L7_OSPF_ROW_DESTROY:
-            parm = ROW_DESTROY;
-            break;
-
-        case L7_OSPF_ROW_CHANGE:
-            parm = ROW_CHANGE;
-            break;
-
-        default:
-            return L7_FAILURE;
-            break;
-    }
-
-    ifoCfg.IfStatus = parm;
+  switch (val)
+  {
+      case L7_OSPF_ROW_ACTIVE:
+          parm = ROW_ACTIVE;
+          break;
+
+      case L7_OSPF_ROW_NOT_IN_SERVICE:
+          parm = ROW_NOT_IN_SERVICE;
+          break;
+
+      case L7_OSPF_ROW_NOT_READY:
+          parm = ROW_NOT_READY;
+          break;
+
+      case L7_OSPF_ROW_CREATE_AND_GO:
+          parm = ROW_CREATE_AND_GO;
+          break;
+
+      case L7_OSPF_ROW_CREATE_AND_WAIT:
+          parm = ROW_CREATE_AND_WAIT;
+          break;
+
+      case L7_OSPF_ROW_DESTROY:
+          parm = ROW_DESTROY;
+          break;
+
+      case L7_OSPF_ROW_CHANGE:
+          parm = ROW_CHANGE;
+          break;
+
+      default:
+          return L7_FAILURE;
+          break;
+  }
+
+  ifoCfg.IfStatus = parm;
+
+  if (IFO_Config_Pack((t_Handle)p_IFO, &ifoCfg) != E_OK)
+  {
+      return L7_FAILURE;
+  }
 
-    if (IFO_Config_Pack((t_Handle)p_IFO, &ifoCfg) != E_OK)
-    {
-        return L7_FAILURE;
-    }
-
-    return L7_SUCCESS;
+  return L7_SUCCESS;
 }
 
 /*********************************************************************
 * @purpose  Test if Ospf multicast forwarding for the specified
 *           interface is settable.
 *
Index: src/application/routing/mapping/ipmap/core/ip_util.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ip_util.c	(revision 7375)
+++ src/application/routing/mapping/ipmap/core/ip_util.c	(revision 7378)
@@ -1555,13 +1555,13 @@ static L7_RC_t ipMapIntfDisable(L7_uint3
     pCfg->flags &= ~(L7_RTR_INTF_HOST);
   }
 
   return rc;
 }
 
-L7_RC_t ptin_ipMapRoutingIntfCreate(intIfNum)
+L7_RC_t ptin_ipMapRoutingIntfCreate(L7_uint32 intIfNum)
 {
   return ipMapRoutingIntfCreate(intIfNum);
 }
 
 /*********************************************************************
 * @purpose  Check the state of an interface and determine whether the
@@ -3432,19 +3432,19 @@ L7_RC_t ipMapRtrIntfSecondaryIpAddressRe
     L7_routeEntry_t routeEntry;
   L7_rtrCfgCkt_t *pCfg;
 
   if (!ipMapMapIntfIsConfigurable(intIfNum, &pCfg))
     return L7_FAILURE;
 
-    if (ipMapTraceFlags & IPMAP_TRACE_SECONDARY)
-    {
-        L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
-        sprintf(traceBuf, "ipMapRtrIntfSecondaryIpAddressRemoveApply: intIfNum %d\n",
-            intIfNum);
-        ipMapTraceWrite(traceBuf);
-    }
+  if (ipMapTraceFlags & IPMAP_TRACE_SECONDARY)
+  {
+      L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
+      sprintf(traceBuf, "ipMapRtrIntfSecondaryIpAddressRemoveApply: intIfNum %d\n",
+          intIfNum);
+      ipMapTraceWrite(traceBuf);
+  }
 
   /* De-activate static routes and static ARP entries on this subnet. */
   ipMapRtrIntfStaticConfigRemoveApply(intIfNum, ipAddr, ipMask);
 
     /* Remove the secondary address from the IP stack */
     if (ipmRouterIfSecondaryAddrDelete(intIfNum, ipAddr, ipMask, index) != L7_SUCCESS)
Index: src/application/routing/mapping/ripmap/rip_map_sysctl.c
===================================================================
--- src/application/routing/mapping/ripmap/rip_map_sysctl.c	(revision 7375)
+++ src/application/routing/mapping/ripmap/rip_map_sysctl.c	(revision 7378)
@@ -167,46 +167,53 @@ static int ripMapSysctlTwo(int *name, u_
   /* perform sysctl_rtable work */
   name += 3;
   namelen -= 3;
 
   if (new)
     return (EPERM);
-    if (namelen != 3)
-        return (EINVAL);
-    af = name[0];
+
+  if (namelen != 3)
+      return (EINVAL);
+  af = name[0];
+
   if (af != AF_INET)
     return (ENOPROTOOPT);
-    bzero((caddr_t)&w, sizeof(w));
+
+  bzero((caddr_t)&w, sizeof(w));
   w.w_where = where;
   w.w_given = *given;
   w.w_needed = 0 - w.w_given;
-    w.w_op = name[1];
-    w.w_arg = name[2];
+  w.w_op = name[1];
+  w.w_arg = name[2];
 
-    /* s = splnet(); */                   /* LVL7_MOD */
-    switch (w.w_op) {
+  /* s = splnet(); */                   /* LVL7_MOD */
+  switch (w.w_op) {
 
     case NET_RT_IFLIST:
-        error = ripMapSysctl_iflist(af, &w);
-    break;
+      error = ripMapSysctl_iflist(af, &w);
+      break;
+
+    default:
+      break;
+  }
 
-  default:
-    break;
-    }
-    /* splx(s); */                        /* LVL7_MOD */
-    if (w.w_tmem)
+  /* splx(s); */                        /* LVL7_MOD */
+  if (w.w_tmem)
     osapiFree(L7_RIP_MAP_COMPONENT_ID, w.w_tmem);                /* LVL7_MOD */
+
   w.w_needed += w.w_given;
+
   if (where) {
     *given = w.w_where - where;
-    if (*given < w.w_needed)
-      return (ENOMEM);
+  if (*given < w.w_needed)
+    return (ENOMEM);
   } else {
     *given = (w.w_needed * 11) / 10;
   }
-    return (error);
+
+  return (error);
 }
 
 
 /*********************************************************************
 * @purpose  Prepares the message buffer containing information about all
 *           currently configured RIP interfaces
Index: src/application/routing/protocol/ospf/ospfmib.c
===================================================================
--- src/application/routing/protocol/ospf/ospfmib.c	(revision 7375)
+++ src/application/routing/protocol/ospf/ospfmib.c	(revision 7378)
@@ -904,31 +904,32 @@ t_Handle ospfAreaTable_Lookup(t_Handle o
  * @notes
  *
  * @end
  * ********************************************************************/
 e_Err ospfAreaTable_SetTest(word lastOid, ulng newValue, t_Handle p)
 {
-   ospfAreaEntry *p_areaEntry = (ospfAreaEntry *)p;  
+  ospfAreaEntry *p_areaEntry = (ospfAreaEntry *)p;  
 
-   /* The first verification: the new value of the object is in range */
-   if (!CheckValueInRange(ospfAreaTestTable, 
-                            sizeof(ospfAreaTestTable)/sizeof(ospfAreaTestTable[0]),
-                            lastOid, newValue))
+  /* The first verification: the new value of the object is in range */
+  if (!CheckValueInRange(ospfAreaTestTable, 
+                           sizeof(ospfAreaTestTable)/sizeof(ospfAreaTestTable[0]),
+                           lastOid, newValue))
+     return E_FAILED;
+  
+  /* Since OSPF Area configuration parameters are "CREATE_READ" objects, */
+  /* they can be changed (set) only during conceptual row creation.      */
+  /* Rowstatus are "READ_WRITE" objects, so they can be set at any time. */
+
+  if ( lastOid == ospfAreaTableRowStatusSubId)  
+     return E_OK;
+  else
+    if((p_areaEntry->info.rowStatus != notReady) &&
+       (p_areaEntry->info.rowStatus != notInService))
       return E_FAILED;
-   
-   /* Since OSPF Area configuration parameters are "CREATE_READ" objects, */
-   /* they can be changed (set) only during conceptual row creation.      */
-   /* Rowstatus are "READ_WRITE" objects, so they can be set at any time. */
 
-   if ( lastOid == ospfAreaTableRowStatusSubId)  
-      return E_OK;
-   else
-      if((p_areaEntry->info.rowStatus != notReady) &&
-         (p_areaEntry->info.rowStatus != notInService))
-          return E_FAILED;
-      return E_OK;   
+  return E_OK;   
 }
 
 
 
 
 /*********************************************************************
@@ -4762,38 +4763,38 @@ t_Handle ospfVirtIfTable_GetFirst(t_Hand
  * @notes
  *
  * @end
  * ********************************************************************/
 e_Err ospfVirtIfTable_SetTest(word lastOid, ulng newValue, t_Handle p)
 {
-   ospfVirtIfEntry *p_virtIfEntry = (ospfVirtIfEntry *)p;
-   
-   /* The first verification: the new value of the object is in range */
-   if (!CheckValueInRange(ospfVirtIfTestTable,
-                            sizeof(ospfVirtIfTestTable)/
-                            sizeof(ospfVirtIfTestTable[0]),
-                            lastOid, newValue))
-      return E_FAILED;
-
-   /* OSPF Virt Interface table fields are "CREATE_READ" objects. */
-   /* Therefore they can be changed (set) only during conceptual  */
-   /* row creation (i.e. before the row status becomes "active"). */
+  ospfVirtIfEntry *p_virtIfEntry = (ospfVirtIfEntry *)p;
+  
+  /* The first verification: the new value of the object is in range */
+  if (!CheckValueInRange(ospfVirtIfTestTable,
+                           sizeof(ospfVirtIfTestTable)/
+                           sizeof(ospfVirtIfTestTable[0]),
+                           lastOid, newValue))
+     return E_FAILED;
 
-   if (lastOid == ospfVirtIfTableRowStatusSubId)
-   {
-      if (p_virtIfEntry)
-         if (p_virtIfEntry->info.internalCreated == TRUE)
-            return E_FAILED;
-      return E_OK;
-   }
-   else
-      if((p_virtIfEntry->info.rowStatus != notReady) &&
-         (p_virtIfEntry->info.rowStatus != notInService))
-          return E_FAILED;
+  /* OSPF Virt Interface table fields are "CREATE_READ" objects. */
+  /* Therefore they can be changed (set) only during conceptual  */
+  /* row creation (i.e. before the row status becomes "active"). */
+
+  if (lastOid == ospfVirtIfTableRowStatusSubId)
+  {
+    if (p_virtIfEntry)
+      if (p_virtIfEntry->info.internalCreated == TRUE)
+        return E_FAILED;
+    return E_OK;
+  }
+  else
+     if((p_virtIfEntry->info.rowStatus != notReady) &&
+        (p_virtIfEntry->info.rowStatus != notInService))
+       return E_FAILED;
 
-      return E_OK;   
+  return E_OK;   
 }
 
 
 
 /*********************************************************************
  * @purpose      Set new value for row status of the ospfVirtIfTable
@@ -5499,34 +5500,34 @@ t_Handle ospfNbrTable_GetFirst(t_Handle
  * @notes
  *
  * @end
  * ********************************************************************/
 e_Err ospfNbrTable_SetTest(word lastOid, ulng newValue, t_Handle p)
 {
-   ospfNbrEntry  *p_nbrEntry = (ospfNbrEntry *)p;
-   
-   /* The first verification: the new value of the object is in range */
-   if (!CheckValueInRange(ospfNbrTestTable, 
-                            sizeof(ospfNbrTestTable)/
-                            sizeof(ospfNbrTestTable[0]),
-                            lastOid, newValue))
+  ospfNbrEntry  *p_nbrEntry = (ospfNbrEntry *)p;
+  
+  /* The first verification: the new value of the object is in range */
+  if (!CheckValueInRange(ospfNbrTestTable, 
+                           sizeof(ospfNbrTestTable)/
+                           sizeof(ospfNbrTestTable[0]),
+                           lastOid, newValue))
+     return E_FAILED;
+  
+  /* OSPF Neighbor table fields are "CREATE_READ" objects.         */
+  /* Therefore they can be changed (set) only during conceptual row      */
+  /* creation (i.e. before the row status becomes "active").             */
+  /* Rowstatus are "READ_WRITE" objects, so they can be set at any time. */
+
+  if (lastOid == ospfNbrTableRowStatusSubId)  
+    return E_OK;
+  else
+    if((p_nbrEntry->info.rowStatus != notReady) &&
+       (p_nbrEntry->info.rowStatus != notInService))
       return E_FAILED;
-   
-   /* OSPF Neighbor table fields are "CREATE_READ" objects.         */
-   /* Therefore they can be changed (set) only during conceptual row      */
-   /* creation (i.e. before the row status becomes "active").             */
-   /* Rowstatus are "READ_WRITE" objects, so they can be set at any time. */
-
-   if (lastOid == ospfNbrTableRowStatusSubId)  
-      return E_OK;
-   else
-      if((p_nbrEntry->info.rowStatus != notReady) &&
-         (p_nbrEntry->info.rowStatus != notInService))
-          return E_FAILED;
 
-      return E_OK;   
+  return E_OK;   
 }
 
 
 
 /*********************************************************************
  * @purpose      Set new value for row status of the ospfNbrTable
Index: src/application/routing/protocol/ospf/spifo.c
===================================================================
--- src/application/routing/protocol/ospf/spifo.c	(revision 7375)
+++ src/application/routing/protocol/ospf/spifo.c	(revision 7378)
@@ -344,40 +344,42 @@ Bool IFO_Delete( t_Handle Id, ulng flag)
 
   TIMER_Delete( p_IFO->AckTimer );
   TIMER_Delete( p_IFO->HelloTimer );
   TIMER_Delete( p_IFO->WaitTimer );
   TIMER_Delete(p_IFO->grSuppressHelloTimer);
 
-   /* if no more Interfaces in this Area */
-   if (p_ARO && flag)
-      if (HL_GetFirst(p_ARO->IfoHl, (void *)&p_tmpIfo) != E_OK)
-      {
-          if (p_RTO->Cfg.DelAreaOnLastIfDel)
-            ARO_Delete(p_ARO, 1);
-
-         /* If the deleted area is not the last one of the router */
-         /* Recalculate the appropriate routing table             */
-         if(p_RTO->AreasNum != 0)
-         {
-            if(HL_FindFirst(p_RTO->RtbHl, (byte *) &zero, (void *)&p_RTB) == E_OK)
-            {
-               /* Start recalculation timer */
-               if(!TIMER_Active(p_RTB->RecalcTimer))
-               {
-                 RTB_ComputeCalcDelay(p_RTB, p_RTO);
-                 TIMER_StartSec(p_RTB->RecalcTimer, p_RTB->CalcDelay, 0, RecalcTimerExp,
-                                p_RTO->OspfRtbThread.threadHndle);
-               }
-            }
-         }
-      }
+  /* if no more Interfaces in this Area */
+  if (p_ARO && flag)
+  {
+    if (HL_GetFirst(p_ARO->IfoHl, (void *)&p_tmpIfo) != E_OK)
+    {
+        if (p_RTO->Cfg.DelAreaOnLastIfDel)
+          ARO_Delete(p_ARO, 1);
+    
+       /* If the deleted area is not the last one of the router */
+       /* Recalculate the appropriate routing table             */
+       if(p_RTO->AreasNum != 0)
+       {
+          if(HL_FindFirst(p_RTO->RtbHl, (byte *) &zero, (void *)&p_RTB) == E_OK)
+          {
+             /* Start recalculation timer */
+             if(!TIMER_Active(p_RTB->RecalcTimer))
+             {
+               RTB_ComputeCalcDelay(p_RTB, p_RTO);
+               TIMER_StartSec(p_RTB->RecalcTimer, p_RTB->CalcDelay, 0, RecalcTimerExp,
+                              p_RTO->OspfRtbThread.threadHndle);
+             }
+          }
+       }
+    }
+  }
 
-      if (p_IFO->PendingUpdate)
-      {
-        F_Delete(p_IFO->PendingUpdate);
-      }
+  if (p_IFO->PendingUpdate)
+  {
+    F_Delete(p_IFO->PendingUpdate);
+  }
 
 #if L7_OSPF_TE
    /* Free the interface TE Link Lsa instance number   */
    /* (i.e. set the appropriate bit to FALSE)          */
    if (((t_RTO *)p_IFO->RTO_Id)->TeLsaInstBS)
       BS_SetBit(((t_RTO *)p_IFO->RTO_Id)->TeLsaInstBS,
@@ -1267,13 +1269,13 @@ void *IFO_AllocPacket(t_IFO *p_IFO, e_S_
    if(! maxBufLen)
    {
        L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
        nimGetIntfName(p_IFO->Cfg.IfIndex, L7_SYSNAME, ifName);
 
        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
-               "Max allowed OSPF pkt len on intf %d, %s is zero", p_IFO->Cfg.IfIndex, ifName);
+               "Max allowed OSPF pkt len on intf %lu, %s is zero", p_IFO->Cfg.IfIndex, ifName);
        return NULL;
    }
 
    p_B = B_NewEx(0, 0, maxBufLen);
    if (p_B == NULL)
    {
Index: src/application/routing/protocol/ospf/sparo.c
===================================================================
--- src/application/routing/protocol/ospf/sparo.c	(revision 7375)
+++ src/application/routing/protocol/ospf/sparo.c	(revision 7378)
@@ -3885,24 +3885,26 @@ next_interface:
        ((p_DbEntry->Lsa.LsType == S_ROUTER_LSA) || 
         (p_DbEntry->Lsa.LsType == S_NETWORK_LSA)) &&
        (A_GET_2B(p_DbEntry->Lsa.LsAge) >= MaxAge))
    {
      t_VpnCos VpnCos = OSPF_PUBLIC_VPN_ID;
      t_RTB *p_RTB = NULL;
-      /* Remove LSA preparsing elements */
-      if (p_DbEntry->ConnList)
-         LsaParseDel(p_ARO, p_DbEntry);
-
-      if (HL_FindFirst(p_RTO->RtbHl, (byte *) &VpnCos, (void *)&p_RTB) == E_OK)
-      {
-        if(!TIMER_Active(p_RTB->RecalcTimer))
-          /* Start recalculation timer */
-          RTB_ComputeCalcDelay(p_RTB, p_RTO);
-          TIMER_StartSec(p_RTB->RecalcTimer, p_RTB->CalcDelay,
-                         0, RecalcTimerExp, p_RTO->OspfRtbThread.threadHndle);
-      }
+     /* Remove LSA preparsing elements */
+     if (p_DbEntry->ConnList)
+        LsaParseDel(p_ARO, p_DbEntry);
+
+     if (HL_FindFirst(p_RTO->RtbHl, (byte *) &VpnCos, (void *)&p_RTB) == E_OK)
+     {
+       if(!TIMER_Active(p_RTB->RecalcTimer))
+       {
+         /* Start recalculation timer */
+         RTB_ComputeCalcDelay(p_RTB, p_RTO);
+         TIMER_StartSec(p_RTB->RecalcTimer, p_RTB->CalcDelay,
+                        0, RecalcTimerExp, p_RTO->OspfRtbThread.threadHndle);
+       }
+     }
    }
      
    return E_OK;
 }
 
 
@@ -4341,13 +4343,13 @@ e_Err FindSummaryOrASExtLsa(t_RTO *p_RTO
    if((err == E_OK) && (NetMask == A_GET_4B(p_DbEntry->p_Lsa)))
    {
       if(p_foundLsa)
          *p_foundLsa = p_DbEntry;
       if(p_LsId)
          *p_LsId = A_GET_4B(p_DbEntry->Lsa.LsId);
-         return E_OK;
+      return E_OK;
    }
 
    return E_NOT_FOUND;
 }
 
 
Index: src/application/routing/rlim/rlim_api.c
===================================================================
--- src/application/routing/rlim/rlim_api.c	(revision 7375)
+++ src/application/routing/rlim/rlim_api.c	(revision 7378)
@@ -386,13 +386,13 @@ L7_RC_t rlimTunnelCreate(L7_uint32 tunne
   {
     if (nimIntfQuery(&nimQueryData) != L7_SUCCESS)
     {
       /* should never get here */
       nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
       L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_RLIM_COMPONENT_ID,
-              "nimIntfQuery() failed for interface %s with intIfNum",
+              "nimIntfQuery() failed for interface %s with intIfNum %u",
               ifName, intIfNum);
       return L7_FAILURE;
     }
 
     if (nimQueryData.data.state >= L7_INTF_CREATED)
     {
Index: src/application/routing/services/rtproto.c
===================================================================
--- src/application/routing/services/rtproto.c	(revision 7375)
+++ src/application/routing/services/rtproto.c	(revision 7378)
@@ -521,13 +521,13 @@ rtInIPForwardArpTable (L7_uint32 dest_ip
     ipForwardBufAllocFail++;
     rc = L7_FAILURE;
   }
   else
   {
     callbackparam = (cbparam_t *) buffer_addr;
-    memset(callbackparam,0,sizeof(callbackparam));
+    memset(callbackparam,0,sizeof(*callbackparam));
     callbackparam->intIfNum = intIfNum;
     callbackparam->routerIP = dest_ip_addr;
     callbackparam->srcrt = srcrt;
 
     /* Try to resolve the ARP entry. If it is net directed broadcast packet,
      there is no need to resolve the arp because, mac is a broadcast mac.
Index: src/application/security/dot1x/core/dot1x_control.c
===================================================================
--- src/application/security/dot1x/core/dot1x_control.c	(revision 7375)
+++ src/application/security/dot1x/core/dot1x_control.c	(revision 7378)
@@ -6328,13 +6328,13 @@ L7_RC_t dot1xCtlLogicalMonitorModeRemove
             /* Mac-based mode */
             dot1xMacBasedVlanParticipationReset(logicalPortInfo, logicalPortInfo->defaultVlanId);
           }
 
           logicalPortInfo->isMonitorModeClient = L7_FALSE;
           logicalPortInfo->defaultVlanId = L7_NULL;
-          L7_LOGF(L7_LOG_SEVERITY_ERROR,L7_DOT1X_COMPONENT_ID,"Port:[%u] moved from authenticated state as Monitor Mode is not Operational\n\r",
+          L7_LOGF(L7_LOG_SEVERITY_ERROR,L7_DOT1X_COMPONENT_ID,"%s(%u) Port:[%u] moved from authenticated state as Monitor Mode is not Operational\n\r",
                       __FUNCTION__, __LINE__, lIntIfNum);          
         }
         logicalPortInfo = dot1xLogicalPortInfoGetNextNode(intIfNum, &lIntIfNum);
       }
   }while(dot1xNextValidIntf(intIfNum, &intIfNum) == L7_SUCCESS);
 
Index: src/application/security/dot1x/core/dot1x_db.c
===================================================================
--- src/application/security/dot1x/core/dot1x_db.c	(revision 7375)
+++ src/application/security/dot1x/core/dot1x_db.c	(revision 7378)
@@ -180,26 +180,26 @@ dot1xLogicalPortInfo_t *dot1xLogicalPort
       retNode  = avlInsertEntry(&dot1xLogicalPortTreeDb,&newNode);
       osapiSemaGive(dot1xLogicalPortTreeDb.semId);
       if (retNode == &newNode)
       {
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1X_COMPONENT_ID,
                 "%s:%d Error Adding the node to the Dot1x Tree for phyintf %s \n",
-                __FUNCTION__,__FILE__,ifName);
+                __FUNCTION__,__LINE__,ifName);
         return L7_NULLPTR;
       }
       return dot1xLogicalPortInfoGet(lIntIfNum);
     }
     else if(tmpNode->inUse == L7_FALSE)
     {
       return tmpNode;
     }
   }
   L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
       "%s:%d Error allocating node for phyintf %s as it reached maximum limit per port."
       " Could not allocate memory for client as maximum number of clients  allowed per port"
-      " has been reached.", __FUNCTION__,__FILE__,ifName);
+      " has been reached.", __FUNCTION__,__LINE__,ifName);
   return L7_NULLPTR;
 }
 
 /*********************************************************************
 * @purpose  To Deallocate a Logical Port Info Node
 *
Index: src/application/security/dot1x/core/dot1x_debug.c
===================================================================
--- src/application/security/dot1x/core/dot1x_debug.c	(revision 7375)
+++ src/application/security/dot1x/core/dot1x_debug.c	(revision 7378)
@@ -1368,19 +1368,19 @@ void dot1xDebugPacketTrace(L7_uint32 int
       nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
 
       if ((dot1xDebugPacketTraceRxFlag == L7_TRUE) && (rxFlag == L7_TRUE))
       {
         DOT1X_USER_TRACE_RX(DOT1X_DEBUG_PACKET_RX_FORMAT,
                             (L7_uint32)usp.unit, (L7_int32)usp.slot, (L7_int32)usp.port,
-                            intIfNum,ifName,srcMac, destMac, type,code,eapPkt->id);
+                            intIfNum,ifName,srcMac, destMac, type); //,code,eapPkt->id);
       }
       else if ((dot1xDebugPacketTraceTxFlag == L7_TRUE) && (txFlag == L7_TRUE))
       {
         DOT1X_USER_TRACE_TX(DOT1X_DEBUG_PACKET_TX_FORMAT,
                             (L7_uint32)usp.unit, (L7_int32)usp.slot, (L7_int32)usp.port,
-                            intIfNum,ifName,srcMac, destMac, type,code,eapPkt->id);
+                            intIfNum,ifName,srcMac, destMac, type,code); //,eapPkt->id);
       }
     }
   }
 
   return;
 }
Index: src/application/security/mgmt_acal/macal_cnfgr.c
===================================================================
--- src/application/security/mgmt_acal/macal_cnfgr.c	(revision 7375)
+++ src/application/security/mgmt_acal/macal_cnfgr.c	(revision 7378)
@@ -419,13 +419,13 @@ L7_RC_t macalCnfgrUconfigPhase2( L7_CNFG
   *pResponse  = L7_CNFGR_CMD_COMPLETE;
   *pReason    = 0;
 
   /* Sysnet deregister for Management Access Control and Administration List */
   (void)macalSysnetRegisterDeregister(L7_FALSE);
 
-  memset(macalCfgData, 0, sizeof(macalCfgData));
+  memset(macalCfgData, 0, sizeof(macalCfgData_t));
 
   macalCnfgrState = MACAL_PHASE_WMU;
 
   return L7_SUCCESS;
 }
 
Index: src/application/base/isdp/isdp_util.c
===================================================================
--- src/application/base/isdp/isdp_util.c	(revision 7375)
+++ src/application/base/isdp/isdp_util.c	(revision 7378)
@@ -680,13 +680,13 @@ void isdpIntfStartupCallback(NIM_STARTUP
   msg.event = ISDP_INTF_STARTUP_EVENT;
   msg.data.nimStartupEvent.startupPhase = startupPhase;
 
   if (isdpProcessMsgQueue(msg) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ISDP_COMPONENT_ID,
-            "%s: Failed to send NIM startup %s msg to ISDP msg queue.",
+            "%s: Failed to send NIM startup %d msg to ISDP msg queue.",
             __FUNCTION__, startupPhase);
   }
 
   return;
 }
 
Index: src/application/base/doublevlantag/dvlantag_ih.c
===================================================================
--- src/application/base/doublevlantag/dvlantag_ih.c	(revision 7375)
+++ src/application/base/doublevlantag/dvlantag_ih.c	(revision 7378)
@@ -641,16 +641,18 @@ L7_BOOL dvlantagIntfConfigEntryGet(L7_ui
     }
   }
 
   if (i < L7_DVLANTAG_MAX_INTERFACE_COUNT)
   {
     dvlantagMapTbl[intIfNum] = i;
+
     if (pCfg != L7_NULLPTR)
-        *pCfg = &dvlantagCfg->intfCfg[i];
-        return L7_TRUE;
-      }
+      *pCfg = &dvlantagCfg->intfCfg[i];
+
+    return L7_TRUE;
+  }
 
   return L7_FALSE;
 }
 
 /*********************************************************************
 *
Index: src/application/base/dot1ab/core/lldp_cnfgr.c
===================================================================
--- src/application/base/dot1ab/core/lldp_cnfgr.c	(revision 7375)
+++ src/application/base/dot1ab/core/lldp_cnfgr.c	(revision 7378)
@@ -700,13 +700,13 @@ L7_RC_t lldpCnfgrUconfigPhase2(L7_CNFGR_
 {
   *pResponse  = L7_CNFGR_CMD_COMPLETE;
   *pReason    = 0;
 
   /* TBD - disable Tx/Rx on all interfaces?? */
 
-  memset(lldpCfgData, 0, sizeof(lldpCfgData));
+  memset(lldpCfgData, 0, sizeof(*lldpCfgData));
 
   lldpCnfgrState = LLDP_PHASE_WMU;
 
   return L7_SUCCESS;
 }
 
Index: src/application/base/dot1ab/core/lldp_rdb.c
===================================================================
--- src/application/base/dot1ab/core/lldp_rdb.c	(revision 7375)
+++ src/application/base/dot1ab/core/lldp_rdb.c	(revision 7378)
@@ -510,30 +510,30 @@ lldpRemDataEntry_t *lldpRemEntryAdd(lldp
 
   currEntry = avlInsertEntry(&lldpRemDbTree,entry);
   if (currEntry == entry)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
             "%s:%d Error Adding the node to the Remote Tree for intf %s \n",
-            __FUNCTION__,__FILE__,ifName);
+            __FUNCTION__,__LINE__,ifName);
     return L7_NULLPTR;
   }
   currEntry = lldpRemDataEntryGet((lldpRemDataKey_t*)entry);
   if (currEntry == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
             "%s:%d Error Retrieving the node from the Remote Tree for intf %s \n",
-            __FUNCTION__,__FILE__,ifName);
+            __FUNCTION__,__LINE__,ifName);
     return L7_NULLPTR;
   }
   /* allocate the index list */
   if (bufferPoolAllocate(lldpRemDBIndexBufferPoolId,
                          (L7_uchar8 **)&indexNode) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
             "%s:%d Error allocating the node to the remote index for intf %s \n",
-            __FUNCTION__,__FILE__,ifName);
+            __FUNCTION__,__LINE__,ifName);
     lldpRemEntryDelete(currEntry);
     avlDeleteEntry(&lldpRemDbTree,currEntry);
     return L7_NULLPTR;
   }
 
   indexNode->timestamp = currEntry->timestamp = osapiUpTimeRaw();
Index: src/application/base/sflow/sflow_api.c
===================================================================
--- src/application/base/sflow/sflow_api.c	(revision 7375)
+++ src/application/base/sflow/sflow_api.c	(revision 7378)
@@ -872,13 +872,13 @@ L7_RC_t sFlowFsEntryGetNext(L7_uint32 Un
     ifIndex=0;
     if (usmDbIntIfNumTypeFirstGet(UnitIndex, inclintIfType, exclintIfType,
                                    &intIfIndex) == L7_SUCCESS)
     {
       if( usmDbExtIfNumFromIntIfNum(intIfIndex, &ifIndex) == L7_SUCCESS)
       {
-        memset(index, 0, sizeof(index));
+//        memset(index, 0, sizeof(index)); ???
         sprintf(index,"%s.%d",L7_SFLOW_IFINDEX, ifIndex);
         *instance =1;
         return L7_SUCCESS;
       }
       return L7_FAILURE;
     }
@@ -1246,13 +1246,13 @@ L7_RC_t sFlowCpEntryGetNext(L7_uint32 Un
     ifIndex=0;
     if (usmDbIntIfNumTypeFirstGet(UnitIndex, inclintIfType, exclintIfType,
                                    &intIfIndex) == L7_SUCCESS)
     {
       if( usmDbExtIfNumFromIntIfNum(intIfIndex, &ifIndex) == L7_SUCCESS)
       {
-        memset(index, 0, sizeof(index));
+//        memset(index, 0, sizeof(index)); ???
         sprintf(index,"%s.%d",L7_SFLOW_IFINDEX, ifIndex);
         *instance =1;
         return L7_SUCCESS;
       }
       return L7_FAILURE;
     }
Index: src/application/ptin/utils/ipc_lib.c
===================================================================
--- src/application/ptin/utils/ipc_lib.c	(revision 7375)
+++ src/application/ptin/utils/ipc_lib.c	(revision 7378)
@@ -109,13 +109,13 @@ int open_ipc (int porto_rx, unsigned int
 
    tv.tv_sec = 1;
    tv.tv_usec = 0;
    *handlerid = -1;
 //   DEBUGTRACE (TRACE_MODULE_ALL | TRACE_LAYER_IPC, TRACE_SEVERITY_INFORMATIONAL,
    PT_LOG_INFO(LOG_CTX_IPC,
-            "Abertura de canal de comunicacao (%d, %08X, %d).", porto_rx, MessageHandler, timeout); 
+            "Abertura de canal de comunicacao (%d, %08X, %d).", porto_rx, (int)MessageHandler, timeout); 
    // Deteccao do primeiro canal livre
    for(i=0;i<IPCLIB_MAX_CANAIS;i++)
    {
       if(ipc_canais[i].estado==IPCLIB_CANAL_LIVRE)
          break;
    }
Index: src/application/ptin/utils/ptin_timerMng.c
===================================================================
--- src/application/ptin/utils/ptin_timerMng.c	(revision 7375)
+++ src/application/ptin/utils/ptin_timerMng.c	(revision 7378)
@@ -667,13 +667,14 @@ L7_RC_t ptin_timerMng_start(ptin_timerMn
     }
   }
 
   osapiSemaGive(ptin_timers_sem);
 
   if (ptin_timerMng_debug_snooping)
-    PT_LOG_DEBUG(LOG_CTX_MISC,"Timer Started: timerCB=%p timer=%p timerHandle=%p timeout=%u (s)", timersMng.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
+    PT_LOG_DEBUG(LOG_CTX_MISC,"Timer Started: timerCB=%p timer=%p timerHandle=%u timeout=%u (s)", 
+                 timersMng.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
 
   return L7_SUCCESS;
 }
 
 /**
  * Stops a running timer, andf remove all related resources
Index: src/application/ptin/base/ptin_dhcp.c
===================================================================
--- src/application/ptin/base/ptin_dhcp.c	(revision 7375)
+++ src/application/ptin/base/ptin_dhcp.c	(revision 7378)
@@ -225,26 +225,26 @@ static L7_RC_t ptin_dhcp_clientId_conver
 //static L7_RC_t ptin_dhcp_clientId_restore(ptin_client_id_t *client);
 
 /*********************************************************** 
  * INLINE FUNCTIONS
  ***********************************************************/
 
-inline L7_BOOL dhcp_clientIndex_check_free(L7_uint dhcp_idx)
+static inline L7_BOOL dhcp_clientIndex_check_free(L7_uint dhcp_idx)
 {
   /* Validate arguments */
   if (dhcp_idx >= PTIN_SYSTEM_N_DHCP_INSTANCES)
   {
     PT_LOG_ERR(LOG_CTX_DHCP,"Invalid DHCP instance %u", dhcp_idx);
     return -1;
   }
 
   return (dhcpClients_unified.number_of_clients < PTIN_SYSTEM_DHCP_MAXCLIENTS &&
           queue_free_clients.n_elems > 0);
 }
 
-inline L7_int dhcp_clientIndex_allocate(L7_uint dhcp_idx, ptinDhcpClientInfoData_t *infoData)
+static inline L7_int dhcp_clientIndex_allocate(L7_uint dhcp_idx, ptinDhcpClientInfoData_t *infoData)
 {
   L7_int  client_idx;
   struct ptin_clientIdx_entry_s  *clientIdx_pool_entry;
   struct ptin_clientInfo_entry_s *clientInfo_pool_entry;
   L7_RC_t rc;
 
@@ -303,13 +303,13 @@ inline L7_int dhcp_clientIndex_allocate(
   dhcpClients_unified.number_of_clients++;
 
   /* Return new client id */
   return client_idx;
 }
 
-inline void dhcp_clientIndex_release(L7_uint dhcp_idx, L7_uint32 client_idx)
+static inline void dhcp_clientIndex_release(L7_uint dhcp_idx, L7_uint32 client_idx)
 {
   struct ptin_clientIdx_entry_s  *clientIdx_pool_entry;
   struct ptin_clientInfo_entry_s *clientInfo_pool_entry;
   L7_RC_t rc;
 
   /* Validate arguments */
Index: src/application/ptin/base/ptin_pppoe.c
===================================================================
--- src/application/ptin/base/ptin_pppoe.c	(revision 7375)
+++ src/application/ptin/base/ptin_pppoe.c	(revision 7378)
@@ -225,26 +225,26 @@ static L7_RC_t ptin_pppoe_clientId_conve
 //static L7_RC_t ptin_pppoe_clientId_restore(ptin_client_id_t *client);
 
 /*********************************************************** 
  * INLINE FUNCTIONS
  ***********************************************************/
 
-inline L7_BOOL pppoe_clientIndex_check_free(L7_uint pppoe_idx)
+static inline L7_BOOL pppoe_clientIndex_check_free(L7_uint pppoe_idx)
 {
   /* Validate arguments */
   if (pppoe_idx >= PTIN_SYSTEM_N_PPPOE_INSTANCES)
   {
     PT_LOG_ERR(LOG_CTX_PPPOE,"Invalid PPPOE instance %u", pppoe_idx);
     return -1;
   }
 
   return (pppoeClients_unified.number_of_clients < PTIN_SYSTEM_PPPOE_MAXCLIENTS &&
           queue_free_clients.n_elems > 0);
 }
 
-inline L7_int pppoe_clientIndex_allocate(L7_uint pppoe_idx, ptinPppoeClientInfoData_t *infoData)
+static inline L7_int pppoe_clientIndex_allocate(L7_uint pppoe_idx, ptinPppoeClientInfoData_t *infoData)
 {
   L7_int  client_idx;
   struct ptin_clientIdx_entry_s  *clientIdx_pool_entry;
   struct ptin_clientInfo_entry_s *clientInfo_pool_entry;
   L7_RC_t rc;
 
@@ -303,13 +303,13 @@ inline L7_int pppoe_clientIndex_allocate
   pppoeClients_unified.number_of_clients++;
 
   /* Return new client id */
   return client_idx;
 }
 
-inline void pppoe_clientIndex_release(L7_uint pppoe_idx, L7_uint32 client_idx)
+static inline void pppoe_clientIndex_release(L7_uint pppoe_idx, L7_uint32 client_idx)
 {
   struct ptin_clientIdx_entry_s  *clientIdx_pool_entry;
   struct ptin_clientInfo_entry_s *clientInfo_pool_entry;
   L7_RC_t rc;
 
   /* Validate arguments */
@@ -2893,12 +2893,13 @@ L7_RC_t ptin_pppoe_clientIndex_get(L7_ui
                               "ipAddr=%u.%u.%u.%u,"
             #endif
             #if (PPPOE_CLIENT_MACADDR_SUPPORTED)
                               "MacAddr=%02x:%02x:%02x:%02x:%02x:%02x"
             #endif
                               "}"
+            ,client_idx
             #if (PPPOE_CLIENT_INTERF_SUPPORTED)
             ,clientInfo->pppoeClientDataKey.ptin_port
             #endif
             #if (PPPOE_CLIENT_OUTERVLAN_SUPPORTED)
             ,clientInfo->pppoeClientDataKey.outerVlan
             #endif
Index: src/application/ptin/base/ptin_intf.c
===================================================================
--- src/application/ptin/base/ptin_intf.c	(revision 7375)
+++ src/application/ptin/base/ptin_intf.c	(revision 7378)
@@ -814,13 +814,13 @@ L7_RC_t ptin_intf_portExt_get(const ptin
   PT_LOG_TRACE(LOG_CTX_INTF," inner_tpid = %u"                  , mefExt->inner_tpid);
   PT_LOG_TRACE(LOG_CTX_INTF," egress_type = %u"                 , mefExt->egress_type);
   PT_LOG_TRACE(LOG_CTX_INTF," macLearn_enable = %u"             , mefExt->macLearn_enable);
   PT_LOG_TRACE(LOG_CTX_INTF," macLearn_stationMove_enable = %u" , mefExt->macLearn_stationMove_enable);
   PT_LOG_TRACE(LOG_CTX_INTF," macLearn_stationMove_prio   = %u" , mefExt->macLearn_stationMove_prio);
   PT_LOG_TRACE(LOG_CTX_INTF," Max Channels      = %u"           , mefExt->maxChannels);
-  PT_LOG_TRACE(LOG_CTX_INTF," Max Bandwidth     = %u"           , mefExt->maxBandwidth);
+  PT_LOG_TRACE(LOG_CTX_INTF," Max Bandwidth     = %llu"         , mefExt->maxBandwidth);
   PT_LOG_TRACE(LOG_CTX_INTF," Interface trusted = %u"           , mefExt->dhcp_trusted);
 
   PT_LOG_TRACE(LOG_CTX_INTF, "Success getting MEF Ext of port %u/%u", ptin_intf->intf_type,ptin_intf->intf_id);
 
   return L7_SUCCESS;
 }
@@ -4994,13 +4994,13 @@ L7_RC_t ptin_QoS_intf_config_set(const p
   PT_LOG_TRACE(LOG_CTX_INTF,"Interface = %u/%u",ptin_intf->intf_type,ptin_intf->intf_id);
   PT_LOG_TRACE(LOG_CTX_INTF,"Mask         = 0x%02x",intfQos->mask);
   PT_LOG_TRACE(LOG_CTX_INTF,"TrustMode    = %u",intfQos->trust_mode);
   PT_LOG_TRACE(LOG_CTX_INTF,"BWunits      = %u",intfQos->bandwidth_unit);
   PT_LOG_TRACE(LOG_CTX_INTF,"ShapingRate  = %u",intfQos->shaping_rate);
   PT_LOG_TRACE(LOG_CTX_INTF,"WREDDecayExp = %u",intfQos->wred_decay_exponent);
-  PT_LOG_TRACE(LOG_CTX_INTF,"PrioMap.mask   =0x%02x",intfQos->pktprio.mask);
+  PT_LOG_TRACE(LOG_CTX_INTF,"PrioMap.mask   =0x%02x", (L7_uint32)intfQos->pktprio.mask);
   PT_LOG_TRACE(LOG_CTX_INTF,"PrioMap.prio[8]={0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x}",
             intfQos->pktprio.cos[0],
             intfQos->pktprio.cos[1],
             intfQos->pktprio.cos[2],
             intfQos->pktprio.cos[3],
             intfQos->pktprio.cos[4],
Index: src/application/ptin/base/ptin_xlate_api.c
===================================================================
--- src/application/ptin/base/ptin_xlate_api.c	(revision 7375)
+++ src/application/ptin/base/ptin_xlate_api.c	(revision 7378)
@@ -1365,15 +1365,16 @@ L7_RC_t ptin_xlate_egress_add( ptin_HwEt
   /* Remove VLANs? */
   xlate.remove_VLANs = (xlate_table_pvid[intIfNum] == newOuterVlanId);
 
   if (xlate.remove_VLANs)
   {
     /* Set untagged port */
-    if (usmDbVlanTaggedSet(unit, intf_vlan->vid, intIfNum, L7_DOT1Q_UNTAGGED) != L7_SUCCESS)
+    rc = usmDbVlanTaggedSet(unit, intf_vlan->vid, intIfNum, L7_DOT1Q_UNTAGGED);
+    if (rc != L7_SUCCESS)
     {
-      PT_LOG_ERR(LOG_CTX_EVC, "Error setting intIfNum# %u internal VLAN %u as UNtagged (rc=%d)", intIfNum, intf_vlan->vid);
+      PT_LOG_ERR(LOG_CTX_EVC, "Error setting intIfNum# %u internal VLAN %u as UNtagged (rc=%d)", intIfNum, intf_vlan->vid, rc);
       return L7_FAILURE;
     }
   }
 
   /* DTL call */
   rc = ptin_xlate_operation(DAPI_CMD_SET, L7_ALL_INTERFACES, &xlate);
Index: src/application/ptin/base/ptin_prot_uplink.c
===================================================================
--- src/application/ptin/base/ptin_prot_uplink.c	(revision 7375)
+++ src/application/ptin/base/ptin_prot_uplink.c	(revision 7378)
@@ -786,13 +786,14 @@ L7_RC_t ptin_prot_timer_start(L7_uint32
     }
   }
 
   osapiSemaGive(ptin_prot_timers_sem);
 
   //if (ptin_debug_igmp_snooping)
-  PT_LOG_DEBUG(LOG_CTX_INTF,"Timer Started: protIdx=%u timerCB=%p timer=%p timerHandle=%p timeout=%u (s)", protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
+  PT_LOG_DEBUG(LOG_CTX_INTF,"Timer Started: protIdx=%u timerCB=%p timer=%p timerHandle=%u timeout=%u (s)",
+               protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
 
   return L7_SUCCESS;
 }
 
 /**
  * Stops a running timer, andf remove all related resources
@@ -835,20 +836,22 @@ L7_RC_t ptin_prot_timer_stop(L7_uint32 p
 
   /* Remove node for SLL list */
   if (SLLDelete(&prot_timerMgmt.ll_timerList, (L7_sll_member_t *)&timerData) != L7_SUCCESS)
   {
     osapiSemaGive(ptin_prot_timers_sem);
     //if (ptin_debug_igmp_snooping)
-    PT_LOG_ERR(LOG_CTX_INTF,"Failed to delete timer node: protIdx=%u timerCB=%p timer=%p timerHandle=%p", protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
+    PT_LOG_ERR(LOG_CTX_INTF,"Failed to delete timer node: protIdx=%u timerCB=%p timer=%p timerHandle=%u",
+               protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
     return L7_FAILURE;
   }
 
   osapiSemaGive(ptin_prot_timers_sem);
 
   //if (ptin_debug_igmp_snooping)
-  PT_LOG_DEBUG(LOG_CTX_INTF,"Timer stopped successfully for protIdx=%u timerCB=%p timer=%p timerHandle=%p", protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
+  PT_LOG_DEBUG(LOG_CTX_INTF,"Timer stopped successfully for protIdx=%u timerCB=%p timer=%p timerHandle=%u",
+               protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
 
   return L7_SUCCESS;
 }
 
 /**
  * Timer Timeout for an existent timer
@@ -892,20 +895,22 @@ L7_RC_t ptin_prot_timer_timeout_get(L7_u
   }
 
   if (pTimerData->timer == L7_NULL)
   {
     osapiSemaGive(ptin_prot_timers_sem);
     //if (ptin_debug_igmp_snooping)
-    PT_LOG_ERR(LOG_CTX_INTF,"Client timer not running: protIdx=%u timerCB=%p timer=%p timerHandle=%p", protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle);
+    PT_LOG_ERR(LOG_CTX_INTF,"Client timer not running: protIdx=%u timerCB=%p timer=%p timerHandle=%u",
+               protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle);
     return L7_FAILURE;
   }
 
   appTimerTimeLeftGet(prot_timerMgmt.timerCB, pTimerData->timer, &time_left);
 
   //if (ptin_debug_igmp_snooping)
-  PT_LOG_DEBUG(LOG_CTX_INTF,"Client Timer TimeOut: protIdx=%u timerCB=%p timer=%p timerHandle=%p time_left=%u (s))", protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle, time_left);
+  PT_LOG_DEBUG(LOG_CTX_INTF,"Client Timer TimeOut: protIdx=%u timerCB=%p timer=%p timerHandle=%u time_left=%u (s))",
+               protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle, time_left);
 
   osapiSemaGive(ptin_prot_timers_sem);
 
   if (timeLeft != L7_NULLPTR)
   {
     *timeLeft = time_left;
@@ -933,13 +938,13 @@ void prot_timer_expiry(void *param)
   protTimerData_t timerData;
   L7_uint32 protIdx;
 
   protTimerData_t *pTimerData;
 
   //if (ptin_debug_igmp_snooping)
-  PT_LOG_DEBUG(LOG_CTX_INTF,"Expiration event ocurred for timerHandle %p!",timerHandle);
+  PT_LOG_DEBUG(LOG_CTX_INTF,"Expiration event ocurred for timerHandle %u!",timerHandle);
 
   osapiSemaTake(ptin_prot_timers_sem, L7_WAIT_FOREVER);
 
   /* Get timer handler */
   pTimerData = (protTimerData_t *) handleListNodeRetrieve(timerHandle);
   if (pTimerData == L7_NULLPTR)
@@ -962,17 +967,19 @@ void prot_timer_expiry(void *param)
   timerData.protIdx = protIdx;
 
   PT_LOG_TRACE(LOG_CTX_INTF,"Deleting SLL node (protIdx=%u)", protIdx);
   /* Remove node for SLL list */
   if (SLLDelete(&prot_timerMgmt.ll_timerList, (L7_sll_member_t *)&timerData) != L7_SUCCESS)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node: protIdx=%u timerCB=%p timer=%p timerHandle=%p", protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node: protIdx=%u timerCB=%p timer=%p timerHandle=%u",
+               protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
   }
 
   //if (ptin_debug_igmp_snooping)
-  PT_LOG_TRACE(LOG_CTX_INTF,"Expiration event ocurred for protIidx=%u timerCB=%p timer=%p timerHandle=%p", protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle);
+  PT_LOG_TRACE(LOG_CTX_INTF,"Expiration event ocurred for protIidx=%u timerCB=%p timer=%p timerHandle=%u",
+               protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle);
 
   osapiSemaGive(ptin_prot_timers_sem);
 
   /* Processing timeout */
   osapiSemaTake(ptin_prot_uplink_sem, L7_WAIT_FOREVER);
  
@@ -2793,13 +2800,13 @@ L7_RC_t ptin_prot_uplink_intf_reload(L7_
     PT_LOG_DEBUG(LOG_CTX_INTF, "Using intIfNum %u...", intIfNum);
   }
   
   rc = ptin_prot_uplink_index_find(intIfNum, &protIdx, &portType);
   if (rc != L7_SUCCESS)
   {
-    PT_LOG_WARN(LOG_CTX_INTF, "No group found using this intIfNum", intIfNum);
+    PT_LOG_WARN(LOG_CTX_INTF, "No group found using this intIfNum %u:s", intIfNum);
     return L7_SUCCESS;
   }
   
   /* Skip inactive instances */
   if (!uplinkprot[protIdx].admin)
   {
Index: src/application/ptin/base/ptin_xconnect_api.c
===================================================================
--- src/application/ptin/base/ptin_xconnect_api.c	(revision 7375)
+++ src/application/ptin/base/ptin_xconnect_api.c	(revision 7378)
@@ -867,13 +867,13 @@ L7_RC_t ptin_virtual_port_add(L7_uint32
   rc = dtlPtinVirtualPort(intIfNum, &vport);
 
   if (rc == L7_SUCCESS)
   {
     if (vport.virtual_gport <= 0)
     {
-      PT_LOG_ERR(LOG_CTX_API, "Finished: Invalid vport id %d (MC group=%d)", rc, vport.virtual_gport, vport.multicast_group);
+      PT_LOG_ERR(LOG_CTX_API, "Finished: Invalid vport id %d (MC group=%d)", vport.virtual_gport, vport.multicast_group);
       return L7_FAILURE;
     }
     /* Return vport id */
     if (vport_id != L7_SUCCESS)
       *vport_id = vport.virtual_gport;
   }
Index: src/application/ptin/base/ptin_l2.c
===================================================================
--- src/application/ptin/base/ptin_l2.c	(revision 7375)
+++ src/application/ptin/base/ptin_l2.c	(revision 7378)
@@ -278,16 +278,17 @@ L7_RC_t ptin_l2_mac_table_load(void)
   #if PTIN_QUATTRO_FLOWS_FEATURE_ENABLED
     if (intfType==L7_VLAN_PORT_INTF) {
         intf_vp_entry_t   e;
 
         e.vport_id = fdbEntry.dot1dTpFdbVirtualPort;
         if (intf_vp_DB(3, &e)) {
-            PT_LOG_WARN(LOG_CTX_L2,"PON&GEMid for intIfNum %lu / vport %lu not found",fdbEntry.dot1dTpFdbPort,fdbEntry.dot1dTpFdbVirtualPort);
+            PT_LOG_WARN(LOG_CTX_L2,"PON&GEMid for intIfNum %u / vport %u not found",
+                        fdbEntry.dot1dTpFdbPort, fdbEntry.dot1dTpFdbVirtualPort);
             continue;
         }
-        else PT_LOG_TRACE(LOG_CTX_L2,"intIfNum %lu / vport %u, PON=%u/%u GEMid=%u",
+        else PT_LOG_TRACE(LOG_CTX_L2,"intIfNum %u / vport %u, PON=%u/%u GEMid=%u",
                        fdbEntry.dot1dTpFdbPort, fdbEntry.dot1dTpFdbVirtualPort, e.pon.intf_type, e.pon.intf_id, e.gem_id);
         ptin_intf = e.pon;
         gem_id    = e.gem_id;
     }
     else
   #endif
Index: src/application/ptin/base/ptin_msghandler.c
===================================================================
--- src/application/ptin/base/ptin_msghandler.c	(revision 7375)
+++ src/application/ptin/base/ptin_msghandler.c	(revision 7378)
@@ -5973,17 +5973,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
 #if (PTIN_BOARD_IS_MATRIX)
       msgId == CCMSG_ETH_LACP_MATRIXES_SYNC2 || 
 #endif
       msgId == CCMSG_MGMD_PORT_SYNC || 
       msgId == CCMSG_APPLICATION_RESOURCES)
   {
-    PT_LOG_TRACE(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %lu usec [response:%u (bytes) rc=%u res=0x%08x]", msgId, outbuffer->infoDim, time_delta, rc, res);
+    PT_LOG_TRACE(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %u usec [response:%u (bytes) rc=%u res=0x%08x]",
+                 msgId, time_delta, outbuffer->infoDim, rc, res);    
   }
   else
   {
-    PT_LOG_INFO(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %lu usec  [response:%u (bytes) rc=%u res=0x%08x]", msgId, outbuffer->infoDim, time_delta, rc, res);
+    PT_LOG_INFO(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %u usec  [response:%u (bytes) rc=%u res=0x%08x]",
+                msgId, time_delta, outbuffer->infoDim, rc, res);
   }
 
   /* Message Runtime Meter */
   /* Only for successfull messages */
   if (rc==L7_SUCCESS)
   {
Index: src/application/ptin/base/ptin_msg.c
===================================================================
--- src/application/ptin/base/ptin_msg.c	(revision 7375)
+++ src/application/ptin/base/ptin_msg.c	(revision 7378)
@@ -1431,14 +1431,14 @@ L7_RC_t ptin_msg_PhyStatus_get(msg_HWEth
   msgPhyStatus->Port              = ENDIAN_SWAP8(port);
   msgPhyStatus->phy.alarmes       = ENDIAN_SWAP32(msgPhyStatus->phy.alarmes);
   msgPhyStatus->phy.alarmes_mask  = ENDIAN_SWAP32(msgPhyStatus->phy.alarmes_mask);
 
   /* Output info read */
   PT_LOG_DEBUG(LOG_CTX_MSG, "Port # %u",                   ENDIAN_SWAP8 (msgPhyStatus->Port));
-  PT_LOG_DEBUG(LOG_CTX_MSG, " alarmes          = 0x%04X",  ENDIAN_SWAP32(msgPhyStatus->phy.alarmes));
-  PT_LOG_DEBUG(LOG_CTX_MSG, " alarmes_mask     = 0x%04X",  ENDIAN_SWAP32(msgPhyStatus->phy.alarmes_mask));
+  PT_LOG_DEBUG(LOG_CTX_MSG, " alarmes          = 0x%04X", ENDIAN_SWAP32(msgPhyStatus->phy.alarmes));
+  PT_LOG_DEBUG(LOG_CTX_MSG, " alarmes_mask     = 0x%04X", ENDIAN_SWAP32(msgPhyStatus->phy.alarmes_mask));
 
   return L7_SUCCESS;
 }
 
 /**
  * Configuration from OLTD application
@@ -1910,13 +1910,13 @@ L7_RC_t ptin_msg_portExt_set(msg_HWPortE
         }
       }
     }
 #endif // ONE_MULTICAST_VLAN_RING_SUPPORT  
   }
 
-  PT_LOG_DEBUG(LOG_CTX_MSG, "Success setting MEF EXT configurations",__FUNCTION__);
+  PT_LOG_DEBUG(LOG_CTX_MSG, "Success setting MEF EXT configurations");
 
   return L7_SUCCESS;
 }
 
 /**
  * Read Port Type settings
@@ -2051,13 +2051,13 @@ L7_RC_t ptin_msg_portMAC_set(msg_HWPortM
     {
       PT_LOG_ERR(LOG_CTX_MSG,"Error setting MAC address");
       return L7_FAILURE;
     }
   }
 
-  PT_LOG_DEBUG(LOG_CTX_MSG, "Success setting MAC address",__FUNCTION__);
+  PT_LOG_DEBUG(LOG_CTX_MSG, "Success setting MAC address");
 
   return L7_SUCCESS;
 }
 
 /**
  * Get MAC addresses for the given interfaces
@@ -5404,13 +5404,13 @@ L7_RC_t ptin_msg_dai_vlan_config(msg_dai
         continue;
       }
       /* Get internal VLAN from eEVC# */
       dai_maxVlans = 1;
       if (ptin_evc_intRootVlan_get(item->service.id_val.evc_id, &dai_intVid_list[0]) != L7_SUCCESS)
       {
-        PT_LOG_ERR(LOG_CTX_MSG, "Cannot get intVlan from eEVC#%u!", item->service.id_val.evc_id, dai_intVid_list[0]);
+        PT_LOG_ERR(LOG_CTX_MSG, "Cannot get intVlan from eEVC#%u!", item->service.id_val.evc_id);
         rc_global = rc_global_failure = L7_FAILURE;
         continue;
       }
     }
     /* Use given VLANs range */
     else if (item->service.id_type == MSG_ID_NNIVID_TYPE)
@@ -5534,13 +5534,13 @@ L7_RC_t ptin_msg_dai_stats_get(msg_dai_s
     item = &msg_stats[i];
 
     PT_LOG_DEBUG(LOG_CTX_MSG,"Stats index %u:", i);
     PT_LOG_DEBUG(LOG_CTX_MSG," SlotId       = %u", ENDIAN_SWAP8 (item->slotId));
     PT_LOG_DEBUG(LOG_CTX_MSG," EVC id       = %u", ENDIAN_SWAP32(item->evc_idx));
     PT_LOG_DEBUG(LOG_CTX_MSG," VLAN id      = %u", ENDIAN_SWAP16(item->vlan_id));
-    PT_LOG_DEBUG(LOG_CTX_MSG," Intf         = %u", ENDIAN_SWAP8 (item->intf.intf_type), ENDIAN_SWAP8 (item->intf.intf_id));
+    PT_LOG_DEBUG(LOG_CTX_MSG," Intf         = %u/%u", ENDIAN_SWAP8 (item->intf.intf_type), ENDIAN_SWAP8 (item->intf.intf_id));
 
     /* Clear list of VLANs */
     memset(dai_intVid_list, 0x00, sizeof(dai_intVid_list));
     dai_maxVlans = 0;
 
     /* If EVC id is provided, get related VLAN */
@@ -6123,17 +6123,18 @@ L7_RC_t ptin_msg_EVC_create(ipc_msg *inb
       ptinEvcConf.intf[index_port].mef_type    = ENDIAN_SWAP8 (msgEvcConf->evc.intf[i].mef_type) /*PTIN_EVC_INTF_ROOT*/;
       ptinEvcConf.intf[index_port].vid         = ENDIAN_SWAP16(msgEvcConf->evc.intf[i].vid);
       ptinEvcConf.intf[index_port].vid_inner   = ENDIAN_SWAP16(msgEvcConf->evc.intf[i].inner_vid);
       ptinEvcConf.intf[index_port].action_outer= PTIN_XLATE_ACTION_REPLACE;
       ptinEvcConf.intf[index_port].action_inner= PTIN_XLATE_ACTION_NONE;
 
-      PT_LOG_DEBUG(LOG_CTX_MSG, "   %s %02u %s VID=%04u/%-04u",
-         ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_type == PTIN_EVC_INTF_PHYSICAL ? "PHY":"LAG",
-         ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_id,
-         ptinEvcConf.intf[index_port].mef_type == PTIN_EVC_INTF_ROOT ? "Root":"Leaf",
-         ptinEvcConf.intf[index_port].vid,ptinEvcConf.intf[i].vid_inner);
+      PT_LOG_DEBUG(LOG_CTX_MSG, "   %s %02u %s VID=%04u/%-4u",
+                   ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_type == PTIN_EVC_INTF_PHYSICAL ? "PHY":"LAG",
+                   ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_id,
+                   ptinEvcConf.intf[index_port].mef_type == PTIN_EVC_INTF_ROOT ? "Root":"Leaf",
+                   ptinEvcConf.intf[index_port].vid,
+                   ptinEvcConf.intf[i].vid_inner);
       PT_LOG_DEBUG(LOG_CTX_MSG, "PTIN_INTF_TYPE_DEBUG: %u", ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_type);
 
 #ifdef NGPON2_SUPPORTED
       /* If is a physical port apply the EVC */
       if ( ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_type == PTIN_EVC_INTF_PHYSICAL )
       {
@@ -6381,13 +6382,13 @@ L7_RC_t ptin_msg_evc_qos_set(ipc_msg *in
     }
     else
     {
       evc_id = ENDIAN_SWAP32(msgEvcQoS[i].id.id_val.evc_id);
       if (ptin_evc_get_NNIvlan_fromEvcId(evc_id, &nni_vlan) != L7_SUCCESS)
       {
-        PT_LOG_ERR(LOG_CTX_MSG, "Error obtaining NNI_VLAN %u from EVC %u", evc_id);
+        PT_LOG_ERR(LOG_CTX_MSG, "Error obtaining NNI_VLAN from EVC %u", evc_id);
         return L7_NOT_EXIST;
       }
     }
 
     /* Get EVC flags */
     if (ptin_evc_flags_get(evc_id, &flags, L7_NULLPTR) != L7_SUCCESS)
@@ -7832,15 +7833,15 @@ L7_RC_t ptin_msg_stormControl2_get(msg_H
     return L7_FAILURE;
   }
 
   PT_LOG_DEBUG(LOG_CTX_MSG," slotId = %u",          ENDIAN_SWAP8 (msgStormControl->SlotId));
   PT_LOG_DEBUG(LOG_CTX_MSG," intf   = %u/%u",       ENDIAN_SWAP8 (msgStormControl->intf.intf_type), ENDIAN_SWAP8 (msgStormControl->intf.intf_id));
   PT_LOG_DEBUG(LOG_CTX_MSG," mask   = 0x%02x",      ENDIAN_SWAP8 (msgStormControl->mask));
-  PT_LOG_DEBUG(LOG_CTX_MSG," Broadcast = %ld (%u)", ENDIAN_SWAP32(msgStormControl->broadcast.rate_value),  ENDIAN_SWAP8 (msgStormControl->broadcast.rate_units));
-  PT_LOG_DEBUG(LOG_CTX_MSG," Multicast = %ld (%u)", ENDIAN_SWAP32(msgStormControl->multicast.rate_value),  ENDIAN_SWAP8 (msgStormControl->multicast.rate_units));
-  PT_LOG_DEBUG(LOG_CTX_MSG," UnknownUC = %ld (%u)", ENDIAN_SWAP32(msgStormControl->unknown_uc.rate_value), ENDIAN_SWAP8 (msgStormControl->unknown_uc.rate_units));
+  PT_LOG_DEBUG(LOG_CTX_MSG," Broadcast = %u (%u)",  ENDIAN_SWAP32(msgStormControl->broadcast.rate_value),  ENDIAN_SWAP8 (msgStormControl->broadcast.rate_units));
+  PT_LOG_DEBUG(LOG_CTX_MSG," Multicast = %u (%u)",  ENDIAN_SWAP32(msgStormControl->multicast.rate_value),  ENDIAN_SWAP8 (msgStormControl->multicast.rate_units));
+  PT_LOG_DEBUG(LOG_CTX_MSG," UnknownUC = %u (%u)",  ENDIAN_SWAP32(msgStormControl->unknown_uc.rate_value), ENDIAN_SWAP8 (msgStormControl->unknown_uc.rate_units));
   PT_LOG_DEBUG(LOG_CTX_MSG," Block UC = %u",        ENDIAN_SWAP8 (msgStormControl->block_unicast));
   PT_LOG_DEBUG(LOG_CTX_MSG," Block MC = %u",        ENDIAN_SWAP8 (msgStormControl->block_multicast));
 
   return L7_SUCCESS;
 }
 
@@ -7881,38 +7882,38 @@ L7_RC_t ptin_msg_stormControl2_set(msg_H
   ENDIAN_SWAP8_MOD (msgStormControl->block_unicast);
   ENDIAN_SWAP8_MOD (msgStormControl->block_multicast);
 
   PT_LOG_DEBUG(LOG_CTX_MSG," slotId = %u",          msgStormControl->SlotId);
   PT_LOG_DEBUG(LOG_CTX_MSG," intf   = %u/%u",       msgStormControl->intf.intf_type, msgStormControl->intf.intf_id);
   PT_LOG_DEBUG(LOG_CTX_MSG," mask   = 0x%02x",      msgStormControl->mask);
-  PT_LOG_DEBUG(LOG_CTX_MSG," Broadcast = %ld (%u)", msgStormControl->broadcast.rate_value,  msgStormControl->broadcast.rate_units);
-  PT_LOG_DEBUG(LOG_CTX_MSG," Multicast = %ld (%u)", msgStormControl->multicast.rate_value,  msgStormControl->multicast.rate_units);
-  PT_LOG_DEBUG(LOG_CTX_MSG," UnknownUC = %ld (%u)", msgStormControl->unknown_uc.rate_value, msgStormControl->unknown_uc.rate_units);
+  PT_LOG_DEBUG(LOG_CTX_MSG," Broadcast = %u (%u)",  msgStormControl->broadcast.rate_value,  msgStormControl->broadcast.rate_units);
+  PT_LOG_DEBUG(LOG_CTX_MSG," Multicast = %u (%u)",  msgStormControl->multicast.rate_value,  msgStormControl->multicast.rate_units);
+  PT_LOG_DEBUG(LOG_CTX_MSG," UnknownUC = %u (%u)",  msgStormControl->unknown_uc.rate_value, msgStormControl->unknown_uc.rate_units);
   PT_LOG_DEBUG(LOG_CTX_MSG," Block UC = %u",        msgStormControl->block_unicast);
   PT_LOG_DEBUG(LOG_CTX_MSG," Block MC = %u",        msgStormControl->block_multicast);
 
   ptin_intf.intf_type = msgStormControl->intf.intf_type;
   ptin_intf.intf_id   = msgStormControl->intf.intf_id;
 
   //KATANA2 workaround ( KT2 doesn't support 1 pps rate limit)
   if (PTIN_BOARD == PTIN_BOARD_TG16GF || PTIN_BOARD == PTIN_BOARD_OLT1T0F || PTIN_BOARD == PTIN_BOARD_TT04SXG || PTIN_BOARD == PTIN_BOARD_AG16GA)
   {
     if(msgStormControl->broadcast.rate_value == 1 && msgStormControl->broadcast.rate_units == 0 /* PPS */)
     {
       msgStormControl->broadcast.rate_value = 2;
-      PT_LOG_NOTICE(LOG_CTX_MSG," Broadcast = %ld (%u) (changed)", msgStormControl->broadcast.rate_value,  msgStormControl->broadcast.rate_units);
+      PT_LOG_NOTICE(LOG_CTX_MSG," Broadcast = %u (%u) (changed)", msgStormControl->broadcast.rate_value,  msgStormControl->broadcast.rate_units);
     }
     if(msgStormControl->multicast.rate_value == 1 && msgStormControl->multicast.rate_units == 0 /* PPS */)
     {
       msgStormControl->multicast.rate_value = 2;
-      PT_LOG_NOTICE(LOG_CTX_MSG," Multicast = %ld (%u) (changed)", msgStormControl->multicast.rate_value,  msgStormControl->multicast.rate_units);
+      PT_LOG_NOTICE(LOG_CTX_MSG," Multicast = %u (%u) (changed)", msgStormControl->multicast.rate_value,  msgStormControl->multicast.rate_units);
     }
     if(msgStormControl->unknown_uc.rate_value == 1 && msgStormControl->unknown_uc.rate_units == 0 /* PPS */)
     {
       msgStormControl->unknown_uc.rate_value = 2;
-      PT_LOG_NOTICE(LOG_CTX_MSG," UnknownUC = %ld (%u) (changed)", msgStormControl->unknown_uc.rate_value,  msgStormControl->unknown_uc.rate_units);
+      PT_LOG_NOTICE(LOG_CTX_MSG," UnknownUC = %u (%u) (changed)", msgStormControl->unknown_uc.rate_value,  msgStormControl->unknown_uc.rate_units);
     }
   }
 
   /* -------- BROADCAST STORMCONTROL -------- */
   if (msgStormControl->mask & MSG_STORMCONTROL_MASK_BCAST)
   {
@@ -10756,13 +10757,13 @@ L7_RC_t ptin_msg_igmp_client_add(msg_Igm
     PT_LOG_DEBUG(LOG_CTX_MSG, "   Client.OVlan = %u",     McastClient[i].client.outer_vlan);
     PT_LOG_DEBUG(LOG_CTX_MSG, "   Client.IVlan = %u",     McastClient[i].client.inner_vlan);
     PT_LOG_DEBUG(LOG_CTX_MSG, "   Client.Intf  = %u/%u",  McastClient[i].client.intf.intf_type, McastClient[i].client.intf.intf_id);
 
     if (McastClient[i].mask > PTIN_MSG_IGMP_CLIENT_MASK_VALID)
     {
-      PT_LOG_ERR(LOG_CTX_MSG, "Invalid Mask [mask:0x%02x]",McastClient[i].mask, McastClient[i].maxBandwidth, McastClient[i].maxChannels);
+      PT_LOG_ERR(LOG_CTX_MSG, "Invalid Mask [mask:0x%02x]", McastClient[i].mask);
       return L7_FAILURE;
     }
 
 #if PTIN_SYSTEM_IGMP_ADMISSION_CONTROL_SUPPORT                                         
     if ( ( ( (McastClient[i].mask & PTIN_MSG_IGMP_CLIENT_MASK_MAX_ALLOWED_BANDWIDTH) == PTIN_MSG_IGMP_CLIENT_MASK_MAX_ALLOWED_BANDWIDTH ) &&
             ( McastClient[i].maxBandwidth != PTIN_IGMP_ADMISSION_CONTROL_MAX_BANDWIDTH_IN_BPS_DISABLE && McastClient[i].maxBandwidth > PTIN_IGMP_ADMISSION_CONTROL_MAX_BANDWIDTH_IN_BPS) ) ||
@@ -12520,13 +12521,14 @@ L7_RC_t ptin_msg_snoop_sync_reply(msg_Sn
     PT_LOG_ERR(LOG_CTX_MSG, "Failed to obtain ipAddress of slotId:%u", protTypebIntfConfig.pairSlotId);
     return L7_FAILURE;
   }
   #endif
   snoopSyncRequest.portId = protTypebIntfConfig.pairIntfNum;
 
-  PT_LOG_DEBUG(LOG_CTX_MSG, "Sending Snoop Sync Request Message [groupAddr:%08X | serviceId:%u | portId:%u] to ipAddr:%08X to Sync the Remaining Snoop Entries", snoopSyncRequest.groupAddr, snoopSyncRequest.serviceId, snoopSyncRequest.portId, ipAddr);
+  PT_LOG_DEBUG(LOG_CTX_MSG, "Sending Snoop Sync Request Message [groupAddr:%08X | serviceId:%u | portId:%u] to ipAddr:%08X to Sync the Remaining Snoop Entries",
+               snoopSyncRequest.groupAddr.addr.ipv4, snoopSyncRequest.serviceId, snoopSyncRequest.portId, ipAddr);
 #endif
               
   
   /*Send the snoop sync request to the protection matrix */  
   if (send_ipc_message(IPC_HW_FASTPATH_PORT, ipAddr, CCMSG_MGMD_SNOOP_SYNC_REQUEST,
                        (char *)(&snoopSyncRequest), NULL,
@@ -13107,13 +13109,13 @@ L7_RC_t ptin_msg_uplink_prot_create(ipc_
     PT_LOG_DEBUG(LOG_CTX_MSG, " slotId    = %u",  protConf[i].slotId);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protIndex = %u",  protConf[i].protIndex);
     PT_LOG_DEBUG(LOG_CTX_MSG, " mask      = 0x%x",protConf[i].confMask);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.OperationMode     = %u", protConf[i].protParams.OperationMode);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.HoldOffTimer      = %u", protConf[i].protParams.HoldOffTimer);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.WaitToRestoreTimer= %u", protConf[i].protParams.WaitToRestoreTimer);
-    PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.alarmsEnFlag      = 0x%08x", protConf[i].protParams.alarmsEnFlag);
+    PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.alarmsEnFlag      = 0x%08lx", protConf[i].protParams.alarmsEnFlag);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.flags             = 0x%02x", protConf[i].protParams.flags);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.slotW/portW = %u/%u", protConf[i].protParams.slotW, protConf[i].protParams.portW);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.slotP/portP = %u/%u", protConf[i].protParams.slotP, protConf[i].protParams.portP);
 
     /* Validate index */
     if (protConf[i].protIndex >= MAX_UPLINK_PROT)
@@ -13261,13 +13263,13 @@ L7_RC_t ptin_msg_uplink_prot_config(ipc_
     PT_LOG_DEBUG(LOG_CTX_MSG, " slotId    = %u", protConf[i].slotId);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protIndex = %u", protConf[i].protIndex);
     PT_LOG_DEBUG(LOG_CTX_MSG, " mask      = 0x%x", protConf[i].confMask);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.OperationMode     = %u", protConf[i].protParams.OperationMode);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.HoldOffTimer      = %u", protConf[i].protParams.HoldOffTimer);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.WaitToRestoreTimer= %u", protConf[i].protParams.WaitToRestoreTimer);
-    PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.alarmsEnFlag      = 0x%08x", protConf[i].protParams.alarmsEnFlag);
+    PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.alarmsEnFlag      = 0x%08lx", protConf[i].protParams.alarmsEnFlag);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.flags             = 0x%02x", protConf[i].protParams.flags);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.slotW/portW = %u/%u", protConf[i].protParams.slotW, protConf[i].protParams.portW);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.slotP/portP = %u/%u", protConf[i].protParams.slotP, protConf[i].protParams.portP);
 
     rc = L7_SUCCESS;
 
@@ -13796,13 +13798,13 @@ L7_RC_t ptin_msg_prbs_status(msg_ptin_pr
       }
 
       /* Read number of PRBS errors */
       rc = ptin_pcs_prbs_errors_get(intIfNum, &rxStatus);
       if (rc != L7_SUCCESS)
       {
-        PT_LOG_ERR(LOG_CTX_MSG,"Error getting PRBS errors from port %u/%u", port);
+        PT_LOG_ERR(LOG_CTX_MSG,"Error getting PRBS errors from port %u", port);
         rc_global = rc;
         continue;
       }
 
       PT_LOG_TRACE(LOG_CTX_MSG,"Success getting PRBS errors from port %u", port);
 
@@ -13843,13 +13845,13 @@ L7_RC_t ptin_msg_prbs_status(msg_ptin_pr
       }
 
       /* Read number of PRBS errors */
       rc = ptin_pcs_prbs_errors_get(intIfNum, &rxStatus);
       if (rc != L7_SUCCESS)
       {
-        PT_LOG_ERR(LOG_CTX_MSG,"Error getting PRBS errors from port %u/%u", port);
+        PT_LOG_ERR(LOG_CTX_MSG,"Error getting PRBS errors from port %u", port);
         rc_global = rc;
         continue;
       }
 
       PT_LOG_TRACE(LOG_CTX_MSG,"Success getting PRBS errors from port %u", port);
 
@@ -14266,13 +14268,13 @@ L7_RC_t ptin_msg_wr_MEP(ipc_msg *inbuff,
 
   if ((pi[i].flags & 0x01)) {
   L7_uint16 slot, port;
 
     if (L7_SUCCESS!=ptin_intf_port2SlotPort(porta, &slot, &port, L7_NULLPTR)) return L7_FAILURE;
     if (slot!=pi[i].tu_slot) {
-        PT_LOG_ERR(LOG_CTX_MSG, "ptin_intf_port=%lu => (slot,port)=(%u,%u) struct_passed_slot=%u", porta, slot, port, pi[i].tu_slot);
+        PT_LOG_ERR(LOG_CTX_MSG, "ptin_intf_port=%u => (slot,port)=(%u,%u) struct_passed_slot=%u", porta, slot, port, pi[i].tu_slot);
         //return L7_FAILURE;
     }
     if (send_also_uplinkprot_traps(1, slot, port, pi[i].bd.vid));// return L7_FAILURE;
   }
 
 
@@ -14330,13 +14332,13 @@ L7_RC_t ptin_msg_wr_MEP(ipc_msg *inbuff,
        else
        {
          PT_LOG_DEBUG(LOG_CTX_MSG, "Sucess MEP CONTROL");
        }
      }
     }
-    PT_LOG_DEBUG(LOG_CTX_MSG, "i_MEP#%llu\tporta=%lu\tvid=%llu\tlevel=%lu", pi[i].index, porta, pi[i].bd.vid, pi[i].bd.level);
+    PT_LOG_DEBUG(LOG_CTX_MSG, "i_MEP#%llu\tporta=%u\tvid=%llu\tlevel=%u", pi[i].index, porta, pi[i].bd.vid, pi[i].bd.level);
     break;
   case 2:    r=ERROR_CODE_FULLTABLE;    break;
   case 3:    r=  CCMSG_FLUSH_MEP==inbuff->msgId?   S_OK:   ERROR_CODE_FULLTABLE; break;
   case 4:    r=ERROR_CODE_NOTPRESENT;  break;
   default:   r=ERROR_CODE_INVALIDPARAM; break;
   }//switch
@@ -14522,13 +14524,13 @@ L7_RC_t ptin_msg_wr_RMEP(ipc_msg *inbuff
        else
        {
          PT_LOG_DEBUG(LOG_CTX_MSG, "Sucess MEP CONTROL");
        }
      }
     }
-    PT_LOG_DEBUG(LOG_CTX_MSG, "i_MEP#%lu\ti_RMEP#%lu\tporta=%lu\tvid=%llu\tlevel=%lu", i_mep, i_rmep, pi[i].bd.prt, pi[i].bd.vid, pi[i].bd.level);
+    PT_LOG_DEBUG(LOG_CTX_MSG, "i_MEP#%u\ti_RMEP#%u\tporta=%u\tvid=%llu\tlevel=%u", i_mep, i_rmep, pi[i].bd.prt, pi[i].bd.vid, pi[i].bd.level);
     break;
   case 4:
     if (CCMSG_FLUSH_RMEP==inbuff->msgId)
     {
       r=S_OK;
       break;
@@ -14636,13 +14638,13 @@ L7_RC_t ptin_msg_del_RMEP(ipc_msg *inbuf
          else
          {
            PT_LOG_DEBUG(LOG_CTX_MSG, "Sucess MEP CONTROL");
          }
        }
       }
-      PT_LOG_DEBUG(LOG_CTX_MSG, "i_MEP#%lu\ti_RMEP#%lu\tporta=%lu\tvid=%llu\tlevel=%lu", i_mep, i_rmep, pi[i].bd.prt, pi[i].bd.vid, pi[i].bd.level);
+      PT_LOG_DEBUG(LOG_CTX_MSG, "i_MEP#%u\ti_RMEP#%u\tporta=%u\tvid=%llu\tlevel=%u", i_mep, i_rmep, pi[i].bd.prt, pi[i].bd.vid, pi[i].bd.level);
       break;
     //case 2:    r=HW_RESOURCE_UNAVAILABLE; break;
   default:   r=ERROR_CODE_INVALIDPARAM;
   }
 
 
@@ -16441,13 +16443,13 @@ L7_RC_t ptin_msg_mirror(ipc_msg *inbuffe
 
   /* Validate Session ID */
   sessionNum = 1; // msg->sessionId;
 
   if( sessionNum > L7_MIRRORING_MAX_SESSIONS || sessionNum == 0)
   {
-    PT_LOG_ERR(LOG_CTX_MSG, "Invalid Session ID %u, sessionNum");
+    PT_LOG_ERR(LOG_CTX_MSG, "Invalid Session ID %u", sessionNum);
     return L7_FAILURE;
   }
 
   /* Check if Feature is supported */
   if(cnfgrIsFeaturePresent(L7_PORT_MIRROR_COMPONENT_ID, L7_MIRRORING_DIRECTION_PER_SOURCE_PORT_SUPPORTED_FEATURE_ID) != L7_TRUE)
   {
@@ -17680,35 +17682,35 @@ L7_RC_t ptin_msg_get_next_qualRFC2819_in
       buffer[*n_elements].Pkts65to127Octets     = ENDIAN_SWAP64(ring_buffer.Pkts65to127Octets);                  
       buffer[*n_elements].Pkts128to255Octets    = ENDIAN_SWAP64(ring_buffer.Pkts128to255Octets);                 
       buffer[*n_elements].Pkts256to511Octets    = ENDIAN_SWAP64(ring_buffer.Pkts256to511Octets);                 
       buffer[*n_elements].Pkts512to1023Octets   = ENDIAN_SWAP64(ring_buffer.Pkts512to1023Octets);                
       buffer[*n_elements].Pkts1024to1518Octets  = ENDIAN_SWAP64(ring_buffer.Pkts1024to1518Octets);
 			
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %d", buffer[*n_elements].index);
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %d",  buffer[*n_elements].arg );   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %d", buffer[*n_elements].time );   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %d",  buffer[*n_elements].path);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %d", buffer[*n_elements].cTempo);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %d", buffer[*n_elements].Octets );   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %d", buffer[*n_elements].Pkts);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %d", buffer[*n_elements].Broadcast);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %d", buffer[*n_elements].Multicast);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %d", buffer[*n_elements].CRCAlignErrors);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts", buffer[*n_elements].UndersizePkts);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %d", buffer[*n_elements].OversizePkts);
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %lu", buffer[*n_elements].index);
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %lu",  buffer[*n_elements].arg );   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %lu", buffer[*n_elements].time );   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %lu",  buffer[*n_elements].path);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %lu", buffer[*n_elements].cTempo);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %llu", buffer[*n_elements].Octets );   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %llu", buffer[*n_elements].Pkts);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %llu", buffer[*n_elements].Broadcast);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %llu", buffer[*n_elements].Multicast);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %llu", buffer[*n_elements].CRCAlignErrors);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts %llu", buffer[*n_elements].UndersizePkts);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %llu", buffer[*n_elements].OversizePkts);
       
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %d", buffer[*n_elements].Fragments );   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %d",  buffer[*n_elements].Jabbers);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %d", buffer[*n_elements].Collisions);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %d", buffer[*n_elements].Utilization );   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %d", buffer[*n_elements].Pkts64Octets);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %d", buffer[*n_elements].Pkts65to127Octets);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %d", buffer[*n_elements].Pkts128to255Octets);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %d", buffer[*n_elements].Pkts256to511Octets);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets", buffer[*n_elements].Pkts512to1023Octets);   
-      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %d", buffer[*n_elements].Pkts1024to1518Octets);
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %llu", buffer[*n_elements].Fragments );   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %llu",  buffer[*n_elements].Jabbers);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %llu", buffer[*n_elements].Collisions);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %llu", buffer[*n_elements].Utilization );   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %llu", buffer[*n_elements].Pkts64Octets);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %llu", buffer[*n_elements].Pkts65to127Octets);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %llu", buffer[*n_elements].Pkts128to255Octets);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %llu", buffer[*n_elements].Pkts256to511Octets);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets %llu", buffer[*n_elements].Pkts512to1023Octets);   
+      PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %llu", buffer[*n_elements].Pkts1024to1518Octets);
 
       if (first_reg<0) 
       break;
 
       (*n_elements)++;
       continue;  
@@ -17746,46 +17748,46 @@ L7_RC_t ptin_msg_get_next_qualRFC2819_in
     buffer[*n_elements].Pkts65to127Octets     = ENDIAN_SWAP64(ring_buffer.Pkts65to127Octets);                  
     buffer[*n_elements].Pkts128to255Octets    = ENDIAN_SWAP64(ring_buffer.Pkts128to255Octets);                 
     buffer[*n_elements].Pkts256to511Octets    = ENDIAN_SWAP64(ring_buffer.Pkts256to511Octets);                 
     buffer[*n_elements].Pkts512to1023Octets   = ENDIAN_SWAP64(ring_buffer.Pkts512to1023Octets);                
     buffer[*n_elements].Pkts1024to1518Octets  = ENDIAN_SWAP64(ring_buffer.Pkts1024to1518Octets);
 
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %d", buffer[*n_elements].index);
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %d",  buffer[*n_elements].arg );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %d", buffer[*n_elements].time );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %d",  buffer[*n_elements].path);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %d", buffer[*n_elements].cTempo);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %d", buffer[*n_elements].Octets );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %d", buffer[*n_elements].Pkts);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %d", buffer[*n_elements].Broadcast);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %d", buffer[*n_elements].Multicast);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %d", buffer[*n_elements].CRCAlignErrors);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts", buffer[*n_elements].UndersizePkts);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %d", buffer[*n_elements].OversizePkts);
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %lu", buffer[*n_elements].index);
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %lu",  buffer[*n_elements].arg );   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %lu", buffer[*n_elements].time );   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %lu",  buffer[*n_elements].path);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %lu", buffer[*n_elements].cTempo);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %llu", buffer[*n_elements].Octets );   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %llu", buffer[*n_elements].Pkts);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %llu", buffer[*n_elements].Broadcast);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %llu", buffer[*n_elements].Multicast);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %llu", buffer[*n_elements].CRCAlignErrors);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts %llu", buffer[*n_elements].UndersizePkts);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %llu", buffer[*n_elements].OversizePkts);
    
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %d", buffer[*n_elements].Fragments );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %d",  buffer[*n_elements].Jabbers);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %d", buffer[*n_elements].Collisions);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %d", buffer[*n_elements].Utilization );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %d", buffer[*n_elements].Pkts64Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %d", buffer[*n_elements].Pkts65to127Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %d", buffer[*n_elements].Pkts128to255Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %d", buffer[*n_elements].Pkts256to511Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets", buffer[*n_elements].Pkts512to1023Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %d", buffer[*n_elements].Pkts1024to1518Octets);	  
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %llu", buffer[*n_elements].Fragments );   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %llu",  buffer[*n_elements].Jabbers);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %llu", buffer[*n_elements].Collisions);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %llu", buffer[*n_elements].Utilization );   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %llu", buffer[*n_elements].Pkts64Octets);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %llu", buffer[*n_elements].Pkts65to127Octets);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %llu", buffer[*n_elements].Pkts128to255Octets);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %llu", buffer[*n_elements].Pkts256to511Octets);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets %llu", buffer[*n_elements].Pkts512to1023Octets);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %llu", buffer[*n_elements].Pkts1024to1518Octets);	  
     
     if (first_reg<0) 
       break;
 
     (*n_elements)++;
      continue;	
                     
     #endif
   }  
 
-	PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %d", n_elements);
+	PT_LOG_DEBUG(LOG_CTX_MSG, "n_elements=%d", *n_elements);
   return L7_SUCCESS;
 }
 
 /**
  * get entrys from rfc2819 ring buffer
  * 
@@ -17806,65 +17808,65 @@ L7_RC_t ptin_msg_get_next_qualRFC2819(L7
   if (buffer_index & 0x80000000)
     buffer_index=RFC2819_BUFFER_24HOURS;
   else
     buffer_index=RFC2819_BUFFER_15MIN;
 
 
-    if(ptin_rfc2819_buffer_get(buffer_index, buffer_id, &ring_buffer) <0) 
-    {
-      memset(&buffer[n_elements], 0x00, sizeof(msg_rfc2819_buffer_t)); // When no performance monotoring is avaiable send zeros.
-      return L7_SUCCESS;
-    }
-        
-    buffer[n_elements].index                = ENDIAN_SWAP32(ring_buffer.index);
-    buffer[n_elements].arg                  = ENDIAN_SWAP32(ring_buffer.arg);
-    buffer[n_elements].time                 = ENDIAN_SWAP32(ring_buffer.time);
-    buffer[n_elements].path                 = ENDIAN_SWAP32(ring_buffer.path);
-    buffer[n_elements].cTempo               = ENDIAN_SWAP32(ring_buffer.cTempo);
-
-    buffer[n_elements].Octets               = ENDIAN_SWAP64(ring_buffer.Octets);
-    buffer[n_elements].Pkts                 = ENDIAN_SWAP64(ring_buffer.Pkts);                
-    buffer[n_elements].Broadcast            = ENDIAN_SWAP64(ring_buffer.Broadcast);
-    buffer[n_elements].Multicast            = ENDIAN_SWAP64(ring_buffer.Multicast);           
-    buffer[n_elements].CRCAlignErrors       = ENDIAN_SWAP64(ring_buffer.CRCAlignErrors);      
-    buffer[n_elements].UndersizePkts        = ENDIAN_SWAP64(ring_buffer.UndersizePkts);       
-    buffer[n_elements].OversizePkts         = ENDIAN_SWAP64(ring_buffer.OversizePkts);        
-    buffer[n_elements].Fragments            = ENDIAN_SWAP64(ring_buffer.Fragments);           
-    buffer[n_elements].Jabbers              = ENDIAN_SWAP64(ring_buffer.Jabbers);             
-    buffer[n_elements].Collisions           = ENDIAN_SWAP64(ring_buffer.Collisions);          
-    buffer[n_elements].Utilization          = ENDIAN_SWAP64(ring_buffer.Utilization);         
-    buffer[n_elements].Pkts64Octets         = ENDIAN_SWAP64(ring_buffer.Pkts64Octets);        
-    buffer[n_elements].Pkts65to127Octets    = ENDIAN_SWAP64(ring_buffer.Pkts65to127Octets);   
-    buffer[n_elements].Pkts128to255Octets   = ENDIAN_SWAP64(ring_buffer.Pkts128to255Octets);  
-    buffer[n_elements].Pkts256to511Octets   = ENDIAN_SWAP64(ring_buffer.Pkts256to511Octets);  
-    buffer[n_elements].Pkts512to1023Octets  = ENDIAN_SWAP64(ring_buffer.Pkts512to1023Octets); 
-    buffer[n_elements].Pkts1024to1518Octets = ENDIAN_SWAP64(ring_buffer.Pkts1024to1518Octets);
-   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %d", buffer[n_elements].index);
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %d",  buffer[n_elements].arg );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %d", buffer[n_elements].time );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %d",  buffer[n_elements].path);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %d", buffer[n_elements].cTempo);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %d", buffer[n_elements].Octets );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %d", buffer[n_elements].Pkts);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %d", buffer[n_elements].Broadcast);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %d", buffer[n_elements].Multicast);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %d", buffer[n_elements].CRCAlignErrors);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts", buffer[n_elements].UndersizePkts);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %d", buffer[n_elements].OversizePkts);
-
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %d", buffer[n_elements].Fragments );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %d",  buffer[n_elements].Jabbers);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %d", buffer[n_elements].Collisions);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %d", buffer[n_elements].Utilization );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %d", buffer[n_elements].Pkts64Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %d", buffer[n_elements].Pkts65to127Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %d", buffer[n_elements].Pkts128to255Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %d", buffer[n_elements].Pkts256to511Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets", buffer[n_elements].Pkts512to1023Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %d", buffer[n_elements].Pkts1024to1518Octets);
+  if(ptin_rfc2819_buffer_get(buffer_index, buffer_id, &ring_buffer) <0) 
+  {
+    memset(&buffer[n_elements], 0x00, sizeof(msg_rfc2819_buffer_t)); // When no performance monotoring is avaiable send zeros.
+    return L7_SUCCESS;
+  }
+      
+  buffer[n_elements].index                = ENDIAN_SWAP32(ring_buffer.index);
+  buffer[n_elements].arg                  = ENDIAN_SWAP32(ring_buffer.arg);
+  buffer[n_elements].time                 = ENDIAN_SWAP32(ring_buffer.time);
+  buffer[n_elements].path                 = ENDIAN_SWAP32(ring_buffer.path);
+  buffer[n_elements].cTempo               = ENDIAN_SWAP32(ring_buffer.cTempo);
+
+  buffer[n_elements].Octets               = ENDIAN_SWAP64(ring_buffer.Octets);
+  buffer[n_elements].Pkts                 = ENDIAN_SWAP64(ring_buffer.Pkts);                
+  buffer[n_elements].Broadcast            = ENDIAN_SWAP64(ring_buffer.Broadcast);
+  buffer[n_elements].Multicast            = ENDIAN_SWAP64(ring_buffer.Multicast);           
+  buffer[n_elements].CRCAlignErrors       = ENDIAN_SWAP64(ring_buffer.CRCAlignErrors);      
+  buffer[n_elements].UndersizePkts        = ENDIAN_SWAP64(ring_buffer.UndersizePkts);       
+  buffer[n_elements].OversizePkts         = ENDIAN_SWAP64(ring_buffer.OversizePkts);        
+  buffer[n_elements].Fragments            = ENDIAN_SWAP64(ring_buffer.Fragments);           
+  buffer[n_elements].Jabbers              = ENDIAN_SWAP64(ring_buffer.Jabbers);             
+  buffer[n_elements].Collisions           = ENDIAN_SWAP64(ring_buffer.Collisions);          
+  buffer[n_elements].Utilization          = ENDIAN_SWAP64(ring_buffer.Utilization);         
+  buffer[n_elements].Pkts64Octets         = ENDIAN_SWAP64(ring_buffer.Pkts64Octets);        
+  buffer[n_elements].Pkts65to127Octets    = ENDIAN_SWAP64(ring_buffer.Pkts65to127Octets);   
+  buffer[n_elements].Pkts128to255Octets   = ENDIAN_SWAP64(ring_buffer.Pkts128to255Octets);  
+  buffer[n_elements].Pkts256to511Octets   = ENDIAN_SWAP64(ring_buffer.Pkts256to511Octets);  
+  buffer[n_elements].Pkts512to1023Octets  = ENDIAN_SWAP64(ring_buffer.Pkts512to1023Octets); 
+  buffer[n_elements].Pkts1024to1518Octets = ENDIAN_SWAP64(ring_buffer.Pkts1024to1518Octets);
+ 
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %lu", buffer[n_elements].index);
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %lu",  buffer[n_elements].arg );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %lu", buffer[n_elements].time );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %lu",  buffer[n_elements].path);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %lu", buffer[n_elements].cTempo);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %llu", buffer[n_elements].Octets );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %llu", buffer[n_elements].Pkts);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %llu", buffer[n_elements].Broadcast);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %llu", buffer[n_elements].Multicast);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %llu", buffer[n_elements].CRCAlignErrors);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts %llu", buffer[n_elements].UndersizePkts);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %llu", buffer[n_elements].OversizePkts);
+
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %llu", buffer[n_elements].Fragments );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %llu",  buffer[n_elements].Jabbers);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %llu", buffer[n_elements].Collisions);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %llu", buffer[n_elements].Utilization );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %llu", buffer[n_elements].Pkts64Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %llu", buffer[n_elements].Pkts65to127Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %llu", buffer[n_elements].Pkts128to255Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %llu", buffer[n_elements].Pkts256to511Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets %llu", buffer[n_elements].Pkts512to1023Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %llu", buffer[n_elements].Pkts1024to1518Octets);
       
   return L7_SUCCESS;
 }
 
 /**
  * RFC2819 Probe Configuration
@@ -19165,13 +19167,13 @@ L7_RC_t ptin_msg_igmp_macbridge_client_p
       memset(&ptinEvcFlow, 0x00, sizeof(ptinEvcFlow));
 
       #if PTIN_BOARD_IS_ACTIVETH   
       if (ENDIAN_SWAP8(msg[messageIterator].onuId) != 0)
       {
         PT_LOG_WARN(LOG_CTX_MSG, "   I'm an Active Ethernet Card. OnuId:%u is different from 0. Going to set it to zero", ENDIAN_SWAP8(msg[messageIterator].onuId));
-        ENDIAN_SWAP8(msg[messageIterator].onuId) = 0;
+        msg[messageIterator].onuId = 0;
       }    
       #endif
 
       /* Copy data */                                                                                                  
       ptinEvcFlow.evc_idx             = ENDIAN_SWAP32(msg[messageIterator].evcId);                                     
       ptinEvcFlow.int_ivid            = ENDIAN_SWAP16(msg[messageIterator].nni_cvlan);                                 
@@ -19431,22 +19433,31 @@ L7_RC_t ptin_msg_igmp_multicast_service_
     }
     else
 #endif /*NGPON2_SUPPORTED*/
     {
       /*Input Parameters*/
       PT_LOG_DEBUG(LOG_CTX_MSG, "Input Arguments [slotId:%u evcId:%u intf.type:%u intf.id:%u onuId:%u]",
-                ENDIAN_SWAP8(msg[messageIterator].slotId),ENDIAN_SWAP32(msg[messageIterator].evcId), ENDIAN_SWAP8(msg[messageIterator].intf.intf_type), ENDIAN_SWAP8(msg[messageIterator].intf.intf_id), ENDIAN_SWAP8(msg[messageIterator].onuId));
+                   ENDIAN_SWAP8(msg[messageIterator].slotId),
+                   ENDIAN_SWAP32(msg[messageIterator].evcId), 
+                   ENDIAN_SWAP8(msg[messageIterator].intf.intf_type), 
+                   ENDIAN_SWAP8(msg[messageIterator].intf.intf_id), 
+                   ENDIAN_SWAP8(msg[messageIterator].onuId));
 
       /*Copy to ptin intf struct*/
       ptinIntf.intf_type = ENDIAN_SWAP8(msg[messageIterator].intf.intf_type);
       ptinIntf.intf_id   = ENDIAN_SWAP8(msg[messageIterator].intf.intf_id);
 
       /*Convert from ptin intf to otin port*/
       if ( L7_SUCCESS != (rc = ptin_intf_ptintf2port(&ptinIntf, &ptinPort) ) )
       {
-        PT_LOG_ERR(LOG_CTX_IGMP, "Failed to convert to ptin port [slotId:%u evcId:%u intf.type:%u intf.id:%u onuId:%u]");  
+        PT_LOG_ERR(LOG_CTX_IGMP, "Failed to convert to ptin port [slotId:%u evcId:%u intf.type:%u intf.id:%u onuId:%u]",
+                   ENDIAN_SWAP8(msg[messageIterator].slotId),
+                   ENDIAN_SWAP32(msg[messageIterator].evcId), 
+                   ENDIAN_SWAP8(msg[messageIterator].intf.intf_type), 
+                   ENDIAN_SWAP8(msg[messageIterator].intf.intf_id), 
+                   ENDIAN_SWAP8(msg[messageIterator].onuId));  
         return rc;
       }
 
       /*If Any Error Occurs It is Already Logged*/
       if ( L7_SUCCESS != (rc = ptin_igmp_multicast_service_remove(ptinPort, ENDIAN_SWAP8(msg[messageIterator].onuId), ENDIAN_SWAP32(msg[messageIterator].evcId)) ) )
       {
@@ -19675,27 +19686,27 @@ L7_RC_t rc;
                 }
                 if (L7_SUCCESS!=osapiIfEnable(ifName)) {
                     PT_LOG_ERR(LOG_CTX_MSG,"osapiIfEnable(ifName=%s)", ifName);
                     return ERROR_CODE_INVALIDPARAM;
                 }
                 if (L7_SUCCESS!=osapiNetIfConfig(ifName, ip, msk)) {
-                    PT_LOG_ERR(LOG_CTX_MSG,"osapiNetIfConfig(ifName=%s, ip=0x%lx, msk=0x%lx)", ifName, ip, msk);
+                    PT_LOG_ERR(LOG_CTX_MSG,"osapiNetIfConfig(ifName=%s, ip=0x%x, msk=0x%x)", ifName, ip, msk);
                     return ERROR_CODE_INVALIDPARAM;
                 }
                 //sprintf(com, "ifconfig %s %d.%d.%d.%d netmask %d.%d.%d.%d up\n", ifName,
                 //                ib->IP[0], ib->IP[1], ib->IP[2], ib->IP[3],
                 //                ib->IPmsk[0], ib->IPmsk[1], ib->IPmsk[2], ib->IPmsk[3]);
                 //PT_LOG_NOTICE(LOG_CTX_MSG, com);
                 //system(com);
             }
 
 #if (!PTIN_BOARD_IS_STANDALONE)
             rc = ptin_ipdtl0_control(ib->dtl0vid, ib->vid, internalVid, intIfNum, PTIN_IPDTL0_ETH_IPv4_UDP_PTP, enable);
             if (L7_SUCCESS!=rc) {
-                PT_LOG_ERR(LOG_CTX_MSG,"ptin_ipdtl0_control(ib->dtl0vid=%u, ib->vid=%u, internalVid=%u, intIfNum=%lu, PTIN_IPDTL0_ETH_IPv4_UDP_PTP, enable=%u)=%d",
-                                            ib->dtl0vid, ib->vid, internalVid, intIfNum, PTIN_IPDTL0_ETH_IPv4_UDP_PTP, enable, rc);
+                PT_LOG_ERR(LOG_CTX_MSG,"ptin_ipdtl0_control(ib->dtl0vid=%u, ib->vid=%u, internalVid=%u, intIfNum=%u, PTIN_IPDTL0_ETH_IPv4_UDP_PTP=%u, enable=%u)=%d",
+                           ib->dtl0vid, ib->vid, internalVid, intIfNum, PTIN_IPDTL0_ETH_IPv4_UDP_PTP, enable, rc);
                 return ERROR_CODE_INVALIDPARAM;
             }
 #endif
 
             if (!enable) {
                 sprintf(com, "vconfig rem %s\n", ifName);
Index: src/application/ptin/base/ptin_routing.c
===================================================================
--- src/application/ptin/base/ptin_routing.c	(revision 7375)
+++ src/application/ptin/base/ptin_routing.c	(revision 7378)
@@ -1343,13 +1343,13 @@ L7_RC_t ptin_routing_traceroutesession_c
     return L7_FAILURE;
   }
 
   /* Ensure that the requested index belongs to a traceroute session not in use */
   if(__traceroute_sessions[sessionIdx].isRunning == L7_TRUE)
   {
-    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index is already being used in an active traceroute session [index:%u]", index);
+    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index is already being used in an active traceroute session [index:%u]", sessionIdx);
     return L7_FAILURE;
   }
 
   /* Save session configurations */
   __traceroute_sessions[sessionIdx].index         = sessionIdx;
   __traceroute_sessions[sessionIdx].isRunning     = L7_TRUE;
@@ -1452,13 +1452,13 @@ L7_RC_t ptin_routing_traceroutesession_g
     PT_LOG_ERR(LOG_CTX_ROUTING, "Abnormal context [readEntries:%p buffer:%p]", readEntries, buffer);
     return L7_ERROR;
   }
 
   if(sessionIdx > __traceroute_sessions_max)
   {
-    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index[%u] is higher than the maximum allowed number of ping sessions", index);
+    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index[%u] is higher than the maximum allowed number of ping sessions", sessionIdx);
     return L7_FAILURE;
   }
 
   /* Ensure that the requested index belongs to a created session */
   if(__traceroute_sessions[sessionIdx].handle == 0)
   {
@@ -1627,13 +1627,13 @@ L7_RC_t __ptin_routing_ICMPRedirects_set
   {
     PT_LOG_ERR(LOG_CTX_ROUTING, "Error while setting ICMP Redirects on intfIfNum %u to value %d", routingIntfNum, enable);
     return L7_FAILURE;
   }
 
   /* Enable/Disable ICMP Redirects on this Router */
-  PT_LOG_DEBUG(LOG_CTX_ROUTING, "Setting ICMP Redirects on Router to value %d", routingIntfNum, enable);
+  PT_LOG_DEBUG(LOG_CTX_ROUTING, "Setting ICMP Redirects on Router to value %d", enable);
   usmDbIpMapRtrICMPRedirectsModeSet(enable);
 
   return L7_SUCCESS;
 }
 
 /**
@@ -2291,13 +2291,13 @@ static void __traceroutehops_snapshot_re
     dl_queue_add_tail(&__traceroutehops_pool, (dl_queue_elem_t*)localSnapshotEntry);
   }
 
   /* Get the handle for this traceroute session */
   if(sessionIdx > __traceroute_sessions_max)
   {
-    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index[%u] is higher than the maximum allowed number of ping sessions", index);
+    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index[%u] is higher than the maximum allowed number of ping sessions", sessionIdx);
     return;
   }
   if(__traceroute_sessions[sessionIdx].handle == 0)
   {
     PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index is does not belong to a created session [sessionIdx:%u]", sessionIdx);
     return;
Index: src/application/ptin/base/ptin_igmp.c
===================================================================
--- src/application/ptin/base/ptin_igmp.c	(revision 7375)
+++ src/application/ptin/base/ptin_igmp.c	(revision 7378)
@@ -3308,13 +3308,13 @@ L7_RC_t ptin_igmp_evc_add(L7_uint32 evc_
     if (new_instance)
       memset(&igmpInstances[igmp_idx], 0x00, sizeof(st_IgmpInstCfg_t));
     ptin_evc_igmpInst_set(evc_idx, IGMP_INVALID_ENTRY);
     return L7_FAILURE;
   }
 
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Going to enable trap rule of igmp_idx=%u",evc_idx, igmp_idx);
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Going to enable trap rule of igmp_idx=%u", igmp_idx);
 
   /* Trap rule */
 #if PTIN_QUATTRO_FLOWS_FEATURE_ENABLED
   if (evc_type != PTIN_EVC_TYPE_QUATTRO_STACKED || igmp_quattro_stacked_evcs == 0)
 #endif
   {
@@ -3366,13 +3366,13 @@ L7_RC_t ptin_igmp_evc_remove(L7_uint32 e
     return L7_FAILURE;
   }
 
   /* Check if there is an instance with these parameters */
   if ( ptin_igmp_instance_find(evc_idx, 0 /*Not used*/, &igmp_idx)!=L7_SUCCESS )
   {
-    PT_LOG_WARN(LOG_CTX_IGMP,"There is no instance with [mcEvcId,ucEvcId]=[%u,%u]",evc_idx);
+    PT_LOG_WARN(LOG_CTX_IGMP,"There is no instance with EvcId=%u", evc_idx);
     return L7_SUCCESS;
   }
 
   /* Get EVC type */
   if (ptin_evc_check_evctype(evc_idx, &evc_type) != L7_SUCCESS)
   {
@@ -3971,13 +3971,13 @@ L7_RC_t ptin_igmp_clientList_get(L7_uint
       ptin_mgmd_event_ctrl_parse(&resMsg, &ctrlResMsg);
       PT_LOG_DEBUG(LOG_CTX_IGMP, "Response");
       PT_LOG_DEBUG(LOG_CTX_IGMP, "  CTRL Msg Code            : %08X",      ctrlResMsg.msgCode);
       PT_LOG_DEBUG(LOG_CTX_IGMP, "  CTRL Msg Id              : %08X",      ctrlResMsg.msgId);
       PT_LOG_DEBUG(LOG_CTX_IGMP, "  CTRL Res                 : %u",        ctrlResMsg.res);
       PT_LOG_DEBUG(LOG_CTX_IGMP, "  CTRL Length              : %u", ctrlResMsg.dataLength);
-      PT_LOG_DEBUG(LOG_CTX_IGMP, "  Entry Length             : %u", sizeof(PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t), ctrlResMsg.dataLength/sizeof(PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t));
+      PT_LOG_DEBUG(LOG_CTX_IGMP, "  Entry Length             : %u", sizeof(PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t));
       PT_LOG_DEBUG(LOG_CTX_IGMP, "  Number Of Entries Length : %u", ctrlResMsg.dataLength/sizeof(PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t));
 
       if (0 != ctrlResMsg.dataLength%sizeof(PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t))
       {
         if (ctrlResMsg.res==NOT_EXIST)
           break;
@@ -7788,13 +7788,14 @@ L7_RC_t ptin_igmp_timer_start(L7_uint32
     }
   }
 
   osapiSemaGive(ptin_igmp_timers_sem);
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer Started: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p timeout=%u (s)", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer Started: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u timeout=%u (s)",
+                 ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
 
   return L7_SUCCESS;
 }
 
 /**
  * Restart a timer for an existent client
@@ -7846,31 +7847,34 @@ L7_RC_t ptin_igmp_timer_update(L7_uint32
   }
 
   if (pTimerData->timer == L7_NULL)
   {
     osapiSemaGive(ptin_igmp_timers_sem);
     if (ptin_debug_igmp_snooping)
-      PT_LOG_ERR(LOG_CTX_IGMP,"Client timer not running: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle:%p", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
+      PT_LOG_ERR(LOG_CTX_IGMP,"Client timer not running: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle:%u",
+                 ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
     return L7_FAILURE;
   }
 
   timeout = (igmpProxyCfg.querier.group_membership_interval*3)/2;
 
   if (appTimerUpdate(igmpDeviceClients.timerCB, pTimerData->timer,
                      L7_NULLPTR, L7_NULLPTR, timeout,
                      "PTIN_TIMER") != L7_SUCCESS)
   {
     osapiSemaGive(ptin_igmp_timers_sem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to update client timer: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p timeout=%u (s)", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to update client timer: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u timeout=%u (s)",
+               ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
     return L7_FAILURE;
   }
 
   osapiSemaGive(ptin_igmp_timers_sem);
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer Updated: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p timeout=%u (s)", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer Updated: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u timeout=%u (s)",
+                 ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
 
   return L7_SUCCESS;
 }
 
 /**
  * Timer Tiemout for an existent client
@@ -7921,20 +7925,20 @@ L7_uint32 ptin_igmp_timer_timeout_get(L7
   }
 
   if (pTimerData->timer == L7_NULL)
   {
     osapiSemaGive(ptin_igmp_timers_sem);
     if (ptin_debug_igmp_snooping)
-      PT_LOG_ERR(LOG_CTX_IGMP,"Client timer not running: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
+      PT_LOG_ERR(LOG_CTX_IGMP,"Client timer not running: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
     return L7_FAILURE;
   }
 
   appTimerTimeLeftGet(igmpDeviceClients.timerCB, pTimerData->timer, &time_left);
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Client Timer TimeOut: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p time_left=%u (s))", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, time_left);
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Client Timer TimeOut: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u time_left=%u (s))", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, time_left);
 
   osapiSemaGive(ptin_igmp_timers_sem);
 
   return time_left;
 }
 
@@ -7977,20 +7981,20 @@ L7_RC_t ptin_igmp_timer_stop(L7_uint32 p
 
   /* Remove node for SLL list */
   if (SLLDelete(&igmpDeviceClients.ll_timerList, (L7_sll_member_t *)&timerData) != L7_SUCCESS)
   {
     osapiSemaGive(ptin_igmp_timers_sem);
     if (ptin_debug_igmp_snooping)
-      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p", ptin_port, client_idx, igmpDeviceClients.timerCB, timerData.timer, timerData.timerHandle);
+      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u", ptin_port, client_idx, igmpDeviceClients.timerCB, timerData.timer, timerData.timerHandle);
     return L7_FAILURE;
   }
 
   osapiSemaGive(ptin_igmp_timers_sem);
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer stopped successfully for ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p", ptin_port, client_idx, igmpDeviceClients.timerCB, timerData.timer, timerData.timerHandle);
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer stopped successfully for ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u", ptin_port, client_idx, igmpDeviceClients.timerCB, timerData.timer, timerData.timerHandle);
 
   return L7_SUCCESS;
 }
 
 /*************************************************************************
 * @purpose  Process the expiry timer events
@@ -8009,13 +8013,13 @@ void igmp_timer_expiry(void *param)
   L7_uint32 timerHandle = (L7_uint32) param;
   L7_uint ptin_port, client_idx;
 
   igmpTimerData_t *pTimerData;
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP,"Expiration event ocurred for timerHandle %p!",timerHandle);
+    PT_LOG_TRACE(LOG_CTX_IGMP,"Expiration event ocurred for timerHandle %u!",timerHandle);
 
   osapiSemaTake(ptin_igmp_clients_sem, L7_WAIT_FOREVER);
   osapiSemaTake(ptin_igmp_timers_sem, L7_WAIT_FOREVER);
 
   /* Get timer handler */
   pTimerData = (igmpTimerData_t *) handleListNodeRetrieve(timerHandle);
@@ -8044,13 +8048,13 @@ void igmp_timer_expiry(void *param)
     ptin_igmp_ports_default(0xFF);
     PT_LOG_ERR(LOG_CTX_IGMP, "Ring Passou: Timer expired fot the local_router_port, ptin_igmp_ports_default executed successfully ");
   }
 #endif
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP,"Expiration event ocurred for ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
+    PT_LOG_TRACE(LOG_CTX_IGMP,"Expiration event ocurred for ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
 
 #if 0
   /* Delete timer */
   if (appTimerDelete(igmpClients_unified.timerCB, pTimerData->timer)!=L7_SUCCESS)
   {
     if (ptin_debug_igmp_snooping)
@@ -8621,13 +8625,13 @@ L7_RC_t igmp_assoc_channel_add( L7_uint3
     //Default MC Service Gateway Not Supported on MGMD Lib
     if (inetIsAddressZero(channel_group) != L7_TRUE)
     {
       //Only IPv4 is supported!
       if (channel_group->family!=L7_AF_INET || channel_source->family!=L7_AF_INET)
       {
-        PT_LOG_ERR(LOG_CTX_IGMP,"IPv6 not supported for MGMD [UC_EVC=%u MC_EVC]",evc_uc,evc_mc);
+        PT_LOG_ERR(LOG_CTX_IGMP,"IPv6 not supported for MGMD [UC_EVC=%u MC_EVC=%u]", evc_uc, evc_mc);
         return L7_FAILURE;                       
       }
       if (L7_SUCCESS != ptin_igmp_mgmd_whitelist_add(evc_mc,channel_group->addr.ipv4.s_addr,channel_grpMask,channel_source->addr.ipv4.s_addr, channel_srcMask,channelBandwidth))
       {
         PT_LOG_ERR(LOG_CTX_IGMP,"Unable to create requested entry in the whitelist");
         return L7_FAILURE;
@@ -8875,13 +8879,14 @@ static L7_RC_t ptin_igmp_channel_to_netm
 {
   L7_uchar8 maxMasklen;
 
   /*Validate Input Parameters*/
   if (channel_in == L7_NULLPTR || channel_out == L7_NULLPTR || number_of_channels == L7_NULLPTR)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Invalid Input Arguments: channel_in:%p channel_out:%p number_of_channels:%p");
+    PT_LOG_ERR(LOG_CTX_IGMP,"Invalid Input Arguments: channel_in:%p channel_out:%p number_of_channels:%p",
+               (void*)channel_in, (void*)channel_out, (void*)number_of_channels);
     return L7_FAILURE;
   }
 
   if ( L7_SUCCESS != ptin_igmp_max_mask_size(channel_in->family, &maxMasklen) )
   {
     PT_LOG_ERR(LOG_CTX_IGMP, "Failed to obtain Max Mask Size for family:%u", channel_in->family);
@@ -14981,18 +14986,20 @@ static ptinIgmpChannelBandwidthCache_t*
  */
 RC_t ptin_igmp_admission_control_port_set(L7_uint32 ptin_port, L7_uint8 mask, L7_uint16 maxAllowedChannels, L7_uint64 maxAllowedBandwidth)  
 {
   /*Input Parameters Validation*/
   if (ptin_port >= PTIN_SYSTEM_N_UPLINK_INTERF)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%ull]",ptin_port, mask, maxAllowedChannels, maxAllowedBandwidth);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%llu]",
+               ptin_port, mask, maxAllowedChannels, maxAllowedBandwidth);    
     return L7_FAILURE;
   }
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Input arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%ull]",ptin_port, mask, maxAllowedChannels, maxAllowedBandwidth);
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Input arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%llu]",
+                 ptin_port, mask, maxAllowedChannels, maxAllowedBandwidth);
 
   if ( (mask & PTIN_IGMP_ADMISSION_CONTROL_MASK_MAX_ALLOWED_CHANNELS) == PTIN_IGMP_ADMISSION_CONTROL_MASK_MAX_ALLOWED_CHANNELS)
   {
     if (maxAllowedChannels == PTIN_IGMP_ADMISSION_CONTROL_MAX_CHANNELS_DISABLE) /*Disable this Parameter*/
     {
       igmpPortAdmissionControl[ptin_port].admissionControl.maxAllowedChannels = 0;
@@ -15019,13 +15026,17 @@ RC_t ptin_igmp_admission_control_port_se
       igmpPortAdmissionControl[ptin_port].admissionControl.maxAllowedBandwidth = maxAllowedBandwidth / 1000; /*Convert from bps to kbps*/
       igmpPortAdmissionControl[ptin_port].admissionControl.mask |= PTIN_IGMP_ADMISSION_CONTROL_MASK_MAX_ALLOWED_BANDWIDTH;
     }
   }
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Output arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%ull]",ptin_port, igmpPortAdmissionControl[ptin_port].admissionControl.mask, igmpPortAdmissionControl[ptin_port].admissionControl.maxAllowedChannels, igmpPortAdmissionControl[ptin_port].admissionControl.maxAllowedBandwidth);
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Output arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%u]",
+                 ptin_port, 
+                 igmpPortAdmissionControl[ptin_port].admissionControl.mask, 
+                 igmpPortAdmissionControl[ptin_port].admissionControl.maxAllowedChannels, 
+                 igmpPortAdmissionControl[ptin_port].admissionControl.maxAllowedBandwidth);
 
   return L7_SUCCESS;
 }
 
 /**
  * @purpose Reset Admission Control Port Allocation Parameters
@@ -15294,18 +15305,19 @@ RC_t ptin_igmp_admission_control_multica
     return L7_FAILURE;
   }
 
   if (igmpAdmissionControl->ptin_port >= PTIN_SYSTEM_N_UPLINK_INTERF || igmpAdmissionControl->onuId > PTIN_SYSTEM_IGMP_MAXONUS_PER_INTF || igmpAdmissionControl->mask > PTIN_IGMP_ADMISSION_CONTROL_MASK_VALID ||
       ((L7_uint8) -1) == (internalServiceId = ptin_igmp_admission_control_multicast_internal_id_get(igmpAdmissionControl->serviceId)) || internalServiceId >= PTIN_IGMP_MAX_MULTICAST_INTERNAL_SERVICE_ID)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [ptin_port:%u onuId:%u serviceId:%u internalServiceId:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%ull]",igmpAdmissionControl->ptin_port, igmpAdmissionControl->onuId, igmpAdmissionControl->serviceId, internalServiceId, igmpAdmissionControl->mask, igmpAdmissionControl->maxAllowedChannels, igmpAdmissionControl->maxAllowedBandwidth);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [ptin_port:%u onuId:%u serviceId:%u internalServiceId:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%llu]",
+               igmpAdmissionControl->ptin_port, igmpAdmissionControl->onuId, igmpAdmissionControl->serviceId, internalServiceId, igmpAdmissionControl->mask, igmpAdmissionControl->maxAllowedChannels, igmpAdmissionControl->maxAllowedBandwidth);    
     return L7_FAILURE;
   }
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Arguments [ptin_port:%u onuId:%u serviceId:%u internalServiceId:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%ull]",igmpAdmissionControl->ptin_port, igmpAdmissionControl->onuId, igmpAdmissionControl->serviceId, internalServiceId, igmpAdmissionControl->mask, igmpAdmissionControl->maxAllowedChannels, igmpAdmissionControl->maxAllowedBandwidth);
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Arguments [ptin_port:%u onuId:%u serviceId:%u internalServiceId:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%llu]",igmpAdmissionControl->ptin_port, igmpAdmissionControl->onuId, igmpAdmissionControl->serviceId, internalServiceId, igmpAdmissionControl->mask, igmpAdmissionControl->maxAllowedChannels, igmpAdmissionControl->maxAllowedBandwidth);
 
   if ( (igmpAdmissionControl->mask & PTIN_IGMP_ADMISSION_CONTROL_MASK_MAX_ALLOWED_CHANNELS) == PTIN_IGMP_ADMISSION_CONTROL_MASK_MAX_ALLOWED_CHANNELS)
   {
     if (igmpAdmissionControl->maxAllowedChannels == PTIN_IGMP_ADMISSION_CONTROL_MAX_CHANNELS_DISABLE) /*Disable this Parameter*/
     {
       igmpMulticastAdmissionControl[igmpAdmissionControl->ptin_port][igmpAdmissionControl->onuId][internalServiceId].admissionControl.maxAllowedChannels = 0;
@@ -17412,14 +17424,14 @@ void ptin_igmp_querier_dump(L7_int evc_i
     printf("\nPrinting only IGMP UC service provided %u:\r\n",evc_idx);
   }
 
   for (evc_idx=0; evc_idx<PTIN_SYSTEM_N_EXTENDED_EVCS; evc_idx++)
   {
     /* Print this? */
-    if (evc_idx>0)
-      continue;
+//    if (evc_idx>0 && evc_idx!=evc_idx)
+//      continue;
 
     /* EVC must be active */
     if (!ptin_evc_is_in_use(evc_idx))
     {
       if (evc_idx>0)
         printf("EVC %u does not exist!\r\n",evc_idx);
@@ -18515,19 +18527,20 @@ static struct channelPoolEntry_s* queue_
 
 static RC_t queue_channel_entry_find(L7_uint32 packageId, ptinIgmpChannelInfoData_t *channelAvlTreeEntry, struct channelPoolEntry_s **channelEntry)
 {
   /* Input Argument validation */
   if ( packageId >= PTIN_SYSTEM_IGMP_MAXPACKAGES || channelAvlTreeEntry == L7_NULLPTR  || channelEntry ==  L7_NULLPTR)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u channelAvlTreeEntry:%p channelEntry:%u]", packageId, channelAvlTreeEntry, channelEntry);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u channelAvlTreeEntry:%p channelEntry:%p]",
+               packageId, channelAvlTreeEntry, channelEntry);    
     return L7_FAILURE;
   }
 
   /*Input Parameters*/
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [packageId:%u channelAvlTreeEntry:%p channelEntry:%u]",
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [packageId:%u channelAvlTreeEntry:%p channelEntry:%p]",
               packageId, channelAvlTreeEntry, channelEntry);
 
   if (multicastPackage[packageId].queueChannel.n_elems != 0)
   {
     *channelEntry = (struct channelPoolEntry_s*) multicastPackage[packageId].queueChannel.head;
     while ( *channelEntry != L7_NULLPTR)
@@ -18766,19 +18779,20 @@ static struct packagePoolEntry_s* queue_
 
 static RC_t queue_package_entry_find(L7_uint32 packageId, ptinIgmpChannelInfoData_t *channelAvlTreeEntry, struct packagePoolEntry_s  **packageEntry )
 {
   /* Input Argument validation */
   if ( packageId >= PTIN_SYSTEM_IGMP_MAXPACKAGES || channelAvlTreeEntry == L7_NULLPTR  || packageEntry ==  L7_NULLPTR)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u channelAvlTreeEntry:%p channelEntry:%u]", packageId, channelAvlTreeEntry, packageEntry);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u channelAvlTreeEntry:%p packageEntry:%p]",
+               packageId, channelAvlTreeEntry, packageEntry);    
     return L7_FAILURE;
   }
 
   /*Input Parameters*/
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [packageId:%u channelAvlTreeEntry:%p channelEntry:%u]",
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [packageId:%u channelAvlTreeEntry:%p packageEntry:%p]",
               packageId, channelAvlTreeEntry, packageEntry);
 
   if (channelAvlTreeEntry->queuePackage.n_elems != 0)
   {
     *packageEntry = (struct packagePoolEntry_s*) channelAvlTreeEntry->queuePackage.head;
     while ( *packageEntry != L7_NULLPTR)
@@ -19389,15 +19403,17 @@ RC_t ptin_igmp_multicast_channel_service
     PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [ptinPort:%u deviceClientId:%u groupAddr:%s sourceAddr:%s serviceId:%p]",
               ptinPort, deviceClientId, inetAddrPrint(groupAddr, groupAddrStr), inetAddrPrint(sourceAddr, sourceAddrStr), serviceId);
 
   if ( (groupClient = deviceClientId2groupClientPtr(ptinPort, deviceClientId)) == L7_NULLPTR)
   {
 #ifdef ONE_MULTICAST_VLAN_RING_SUPPORT
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Failed to Obtain groupClient [ptinPort:%u deviceClientId:%u serviceId:%u groupAddr:%p sourceAddr:%p serviceId:%p groupClient:%p]",ptinPort, deviceClientId, groupAddr, sourceAddr, serviceId, groupClient);    
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Failed to Obtain groupClient [ptinPort:%u deviceClientId:%u serviceId:%u groupAddr:%p sourceAddr:%p serviceId:%p groupClient:%p]",
+                 ptinPort, deviceClientId, *serviceId, groupAddr, sourceAddr, serviceId, groupClient);    
 #else
-    PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Obtain groupClient [ptinPort:%u deviceClientId:%u serviceId:%u groupAddr:%p sourceAddr:%p serviceId:%p groupClient:%p]",ptinPort, deviceClientId, groupAddr, sourceAddr, serviceId, groupClient);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Obtain groupClient [ptinPort:%u deviceClientId:%u serviceId:%u groupAddr:%p sourceAddr:%p serviceId:%p groupClient:%p]",
+               ptinPort, deviceClientId, *serviceId, groupAddr, sourceAddr, serviceId, groupClient);    
 #endif
     return L7_FAILURE;
   }
 
   /*Save the ONU Id*/
   onuId = groupClient->onuId;
@@ -19455,14 +19471,22 @@ RC_t ptin_igmp_multicast_channel_service
 
       /*Next Multicast Service*/      
       continue;      
     }
     else if (rc != L7_SUCCESS || channelEntry == L7_NULLPTR )
     {
-      PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Search Channel Entry [ptinPort:%u deviceClientId:%u onuId:%u serviceId:%u groupAddr:%p sourceAddr:%p serviceId:%u internalServiceId:%u noOfMulticastServices:%u]", 
-              ptinPort, deviceClientId, onuId, inetAddrPrint(groupAddr, groupAddrStr), inetAddrPrint(sourceAddr, sourceAddrStr), serviceIdAux, internalServiceId, multicastServices[ptinPort][onuId].noOfMulticastServices);    
+      PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Search Channel Entry:");
+      PT_LOG_ERR(LOG_CTX_IGMP, "  ptinPort:       %u", ptinPort);
+      PT_LOG_ERR(LOG_CTX_IGMP, "  deviceClientId: %u", deviceClientId);
+      PT_LOG_ERR(LOG_CTX_IGMP, "  onuId:          %u", onuId);
+      PT_LOG_ERR(LOG_CTX_IGMP, "  serviceId:      %u", serviceIdAux);
+      PT_LOG_ERR(LOG_CTX_IGMP, "  groupAddr:      %p", inetAddrPrint(groupAddr, groupAddrStr));
+      PT_LOG_ERR(LOG_CTX_IGMP, "  sourceAddr:     %p", inetAddrPrint(sourceAddr, sourceAddrStr));
+      PT_LOG_ERR(LOG_CTX_IGMP, "  intServiceId:   %u", internalServiceId);
+      PT_LOG_ERR(LOG_CTX_IGMP, "  Nr MC Services: %u", multicastServices[ptinPort][onuId].noOfMulticastServices);
+
       return L7_FAILURE;
     }
 
     /* Is clientId Not Set in the client bitmap */
     if (IS_BITMAP_BIT_SET(channelEntry->groupClientBmpPerPort[ptinPort], groupClientId, UINT32_BITSIZE) == L7_FALSE)
     {
@@ -20189,20 +20213,21 @@ static RC_t ptin_igmp_multicast_client_p
  */
 RC_t ptin_igmp_multicast_client_package_get(L7_uint32 packageId, ptinIgmpGroupClientInfoData_t *groupClient, L7_BOOL *isBitSet)
 {
   /* Input Argument validation */
   if ( packageId >= PTIN_SYSTEM_IGMP_MAXPACKAGES || groupClient == L7_NULLPTR  || isBitSet == L7_NULLPTR )
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u groupClient:%p isBitSet:%p]",packageId, groupClient);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u groupClient:%p isBitSet:%p]",
+               packageId, groupClient, isBitSet);
     return L7_FAILURE;
   }
 
   /*Input Parameters*/
   if (ptin_debug_igmp_snooping)
     PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [packageId:%u groupClient:%p isBitSet:%p]",
-              packageId, groupClient);
+                packageId, groupClient, isBitSet);
 
   /*Let us Check if this Package is Configured*/
   if (multicastPackage[packageId].inUse == L7_FALSE )
   {
     PT_LOG_ERR(LOG_CTX_IGMP, "This package does not exist [packageId:%u]", packageId);    
     return L7_NOT_EXIST;
@@ -20420,24 +20445,24 @@ static RC_t ptin_igmp_package_channel_co
     }
   }
 
   while ( L7_NULLPTR != (channelEntry = queue_channel_entry_get_next(packageId, channelEntry)) && 
           L7_NULLPTR != (channelAvlTreeEntryAux = channelEntry->channelAvlTreeEntry) )
   {
-    if ( channelAvlTreeEntryAux->channelDataKey.evc_mc == channelEntry->channelAvlTreeEntry->channelDataKey.evc_mc)
+    if (channelAvlTreeEntryAux->channelDataKey.evc_mc == channelEntry->channelAvlTreeEntry->channelDataKey.evc_mc)
     {
       /*Move to next Channel*/
       continue;
     }
 
     if ( (L7_INET_ADDR_COMPARE(&channelAvlTreeEntryAux->channelDataKey.channel_group, 
                                &channelAvlTreeEntryAux->channelDataKey.channel_group) == 0) &&
          (L7_INET_ADDR_COMPARE(&channelAvlTreeEntryAux->channelDataKey.channel_source, 
                                &channelAvlTreeEntryAux->channelDataKey.channel_source) == 0) )
     {
-      PT_LOG_ERR(LOG_CTX_IGMP,"Conflict Found: Channel configured within two services [packageId:%u serviceId:%u groupAddr:%s sourceAddr:%s][serviceIdNew:]",
+      PT_LOG_ERR(LOG_CTX_IGMP,"Conflict Found: Channel configured within two services [packageId:%u serviceId:%u groupAddr:%s sourceAddr:%s][serviceIdNew:%u]",
               packageId, channelAvlTreeEntry->channelDataKey.evc_mc, 
               inetAddrPrint(&channelAvlTreeEntry->channelDataKey.channel_group, groupAddrStr), inetAddrPrint(&channelAvlTreeEntry->channelDataKey.channel_source, sourceAddrStr),
               channelAvlTreeEntryAux->channelDataKey.evc_mc);    
       return L7_FAILURE;
     }
   }
Index: src/application/ptin/base/ptin_hal_erps.c
===================================================================
--- src/application/ptin/base/ptin_hal_erps.c	(revision 7375)
+++ src/application/ptin/base/ptin_hal_erps.c	(revision 7378)
@@ -580,14 +580,12 @@ L7_RC_t ptin_hal_erps_entry_deinit(L7_ui
  */
 L7_RC_t ptin_hal_erps_clear(void)
 {
   L7_uint8 erps_idx;
   L7_RC_t  ret = L7_SUCCESS;
 
-  PT_LOG_TRACE(LOG_CTX_ERPS, "");
-
   for (erps_idx=0; erps_idx<MAX_PROT_PROT_ERPS; erps_idx++) {
     if ((ret=ptin_hal_erps_entry_deinit(erps_idx))!=L7_SUCCESS) {
       PT_LOG_ERR(LOG_CTX_ERPS, "ERROR: (%d) while removing ERPS#%d\n\r", ret, erps_idx);
       ret = L7_FAILURE;
     }
   }
Index: src/application/ptin/base/ptin_rfc2819.c
===================================================================
--- src/application/ptin/base/ptin_rfc2819.c	(revision 7375)
+++ src/application/ptin/base/ptin_rfc2819.c	(revision 7378)
@@ -242,13 +242,13 @@ void ptin_rfc2819_regista_15min(L7_uint8
   aux_qual_RFC2819.Pkts65to127Octets    =   qual->status[RFC2819_ACTUAL].Pkts65to127Octets   ;
   aux_qual_RFC2819.Pkts128to255Octets   =   qual->status[RFC2819_ACTUAL].Pkts128to255Octets  ;
   aux_qual_RFC2819.Pkts256to511Octets   =   qual->status[RFC2819_ACTUAL].Pkts256to511Octets  ;
   aux_qual_RFC2819.Pkts512to1023Octets  =   qual->status[RFC2819_ACTUAL].Pkts512to1023Octets ;
   aux_qual_RFC2819.Pkts1024to1518Octets =   qual->status[RFC2819_ACTUAL].Pkts1024to1518Octets;   
 
-  PT_LOG_TRACE(LOG_CTX_RFC2819, "15MIN  : %.08lx  |  %.02d-%.02d-%.04d  |  %d:%.02d:00  | %5d | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld",
+  PT_LOG_TRACE(LOG_CTX_RFC2819, "15MIN  : %.08lx  |  %.02d-%.02d-%.04d  |  %d:%.02d:00  | %5ld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld",
             qual->conf.path,
             qual->reg_data.dia,
             qual->reg_data.mes,
             qual->reg_data.ano,
             qual->reg_data.hora,
             qual->reg_data.min,
@@ -316,13 +316,13 @@ void ptin_rfc2819_regista_24horas(L7_uin
   aux_qual_RFC2819.Pkts65to127Octets   =   qual->status[RFC2819_PER24HORAS].Pkts65to127Octets   ;
   aux_qual_RFC2819.Pkts128to255Octets  =   qual->status[RFC2819_PER24HORAS].Pkts128to255Octets  ;
   aux_qual_RFC2819.Pkts256to511Octets  =   qual->status[RFC2819_PER24HORAS].Pkts256to511Octets  ;
   aux_qual_RFC2819.Pkts512to1023Octets =   qual->status[RFC2819_PER24HORAS].Pkts512to1023Octets ;
   aux_qual_RFC2819.Pkts1024to1518Octets=   qual->status[RFC2819_PER24HORAS].Pkts1024to1518Octets;
 
-  PT_LOG_TRACE(LOG_CTX_RFC2819, "24HOURS: %.08lx  |  %.02d-%.02d-%.04d  |  %d:%.02d:00  | %5d | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld",
+  PT_LOG_TRACE(LOG_CTX_RFC2819, "24HOURS: %.08lx  |  %.02d-%.02d-%.04d  |  %d:%.02d:00  | %5ld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld",
             qual->conf.path,
             qual->reg_data.dia,
             qual->reg_data.mes,
             qual->reg_data.ano,
             qual->reg_data.hora,
             qual->reg_data.min,
Index: src/application/ptin/base/ptin_ssm.c
===================================================================
--- src/application/ptin/base/ptin_ssm.c	(revision 7375)
+++ src/application/ptin/base/ptin_ssm.c	(revision 7378)
@@ -612,13 +612,13 @@ L7_RC_t ssmPDUProcess(L7_uint32 intf, vo
   /* Validar restantes campos do campo */
   /* ITU-OUI */
   itu_oui = ((L7_uint32) pdu->itu_oui[0]<<16) | ((L7_uint32) pdu->itu_oui[1]<<8) | ((L7_uint32) pdu->itu_oui[2]);
 
   if (itu_oui != SSM_ITU_OUI)
   {
-    PT_LOG_ERR(LOG_CTX_SSM,"ITU-T field is not valid: received=0x%x, expected=0x%x",itu_oui,SSM_ITU_OUI);
+    PT_LOG_ERR(LOG_CTX_SSM,"ITU-T field is not valid: received=0x%x, expected=0x%lx",itu_oui,SSM_ITU_OUI);
     bufferPoolFree(ssmBufferPoolId,  buffer);
     return L7_FAILURE;
   }
   /* Protocol version */
   if ((pdu->version >> 4) != 1)
   {
Index: src/application/ptin/base/ptin_packet.c
===================================================================
--- src/application/ptin/base/ptin_packet.c	(revision 7375)
+++ src/application/ptin/base/ptin_packet.c	(revision 7378)
@@ -232,13 +232,14 @@ L7_RC_t ptinMacBcastRecv(L7_netBufHandle
   }
 
   /* Validate interface and vlan, as belonging to a valid interface in a valid EVC */
   if (ptin_evc_intfVlan_validate(intIfNum, vlanId)!=L7_SUCCESS)
   {
     if (ptin_packet_debug_enable)
-      PT_LOG_ERR(LOG_CTX_PACKET,"intIfNum %u and vlan %u does not belong to any valid EVC/interface");
+      PT_LOG_ERR(LOG_CTX_PACKET,"intIfNum %u and vlan %u does not belong to any valid EVC/interface",
+                 intIfNum, vlanId);
     return L7_FAILURE;
   }
 
   /* Send packet to queue */
   memset(&msg, 0x00, sizeof(msg));
   msg.msgId       = PTIN_PACKET_RECEIVE;
Index: src/application/ptin/base/ptin_fieldproc.c
===================================================================
--- src/application/ptin/base/ptin_fieldproc.c	(revision 7375)
+++ src/application/ptin/base/ptin_fieldproc.c	(revision 7378)
@@ -184,13 +184,13 @@ L7_RC_t ptin_bwPolicer_set(ptin_bw_profi
         if (ptin_intf_LagConfig_get(&lagInfo) == L7_SUCCESS && lagInfo.admin && lagInfo.members_pbmp64 != 0)
         {
           ptin_port_bmp = lagInfo.members_pbmp64;
         }
         else
         {
-          PT_LOG_ERR(LOG_CTX_API, "ptin_port %u (LAG) does not have members", intIfNum, profile->ptin_port);
+          PT_LOG_ERR(LOG_CTX_API, "ptin_port %u (LAG) does not have members", profile->ptin_port);
           return L7_FAILURE;
         }
       }
       else
       {
         PT_LOG_ERR(LOG_CTX_API, "Invalid ptin_port %u", profile->ptin_port);
Index: src/application/ptin/base/include/ptin_xlate_api.h
===================================================================
--- src/application/ptin/base/include/ptin_xlate_api.h	(revision 7375)
+++ src/application/ptin/base/include/ptin_xlate_api.h	(revision 7378)
@@ -17,13 +17,13 @@
 #define PTIN_XLATE_PORTGROUP_ROOTS        (PTIN_XLATE_PORTGROUP_SPECIAL_BASE+1)     /* Root ports (1G) */
 #define PTIN_XLATE_PORTGROUP_ROOTS_10G    (PTIN_XLATE_PORTGROUP_SPECIAL_BASE+2)     /* 10G Root ports */
 
 /**
  * Inline functions
  */
-inline char ptin_vlanxlate_action_getchar(ptin_vlanXlate_action_enum action);
+extern char ptin_vlanxlate_action_getchar(ptin_vlanXlate_action_enum action);
 
 /**
  * Module initialization function
  * 
  * @return L7_RC_t : L7_SUCCESS or L7_FAILURE
  */
Index: src/application/ptin/base/include/ptin_cfg.h
===================================================================
--- src/application/ptin/base/include/ptin_cfg.h	(revision 7375)
+++ src/application/ptin/base/include/ptin_cfg.h	(revision 7378)
@@ -39,13 +39,13 @@ extern L7_RC_t ptin_cfg_ntw_connectivity
 
 /**
  * Returns the external inBand VLAN ID
  * 
  * @return L7_uint16 inBand VID (zero if not configured)
  */
-extern inline L7_uint16 ptin_cfg_inband_vlan_get(void);
+extern L7_uint16 ptin_cfg_inband_vlan_get(void);
 
 /**
  * Creates a bridge between dtl0 interface and a virtual interface eth0.4093 
  *  
  * NOTE: 
  *  1. virtual interface eth0.4093 is created here 
Index: src/application/ptin/base/include/ptin_intf.h
===================================================================
--- src/application/ptin/base/include/ptin_intf.h	(revision 7375)
+++ src/application/ptin/base/include/ptin_intf.h	(revision 7378)
@@ -326,161 +326,161 @@ extern L7_RC_t ptin_intf_slotPort2IntIfN
  * 
  * @param ptin_port PTin port index
  * @param intIfNum  FP intIfNum
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_port2intIfNum(L7_uint32 ptin_port, L7_uint32 *intIfNum);
+extern L7_RC_t ptin_intf_port2intIfNum(L7_uint32 ptin_port, L7_uint32 *intIfNum);
 
 /**
  * Converts FP interface# to PTin port mapping (including LAGs)
  * 
  * @param intIfNum  FP intIfNum
  * @param ptin_port PTin port index
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_intIfNum2port(L7_uint32 intIfNum, L7_uint32 *ptin_port);
+extern L7_RC_t ptin_intf_intIfNum2port(L7_uint32 intIfNum, L7_uint32 *ptin_port);
 
 /**
  * Converts ptin_port index to LAG index
  * 
  * @param ptin_port PTin port index
  * @param lag_idx   LAG index
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_port2lag(L7_uint32 ptin_port, L7_uint32 *lag_idx);
+extern L7_RC_t ptin_intf_port2lag(L7_uint32 ptin_port, L7_uint32 *lag_idx);
 
 /**
  * Converts LAG index to ptin_port
  *  
  * @param lag_idx   LAG index 
  * @param ptin_port PTin port index 
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-inline L7_RC_t ptin_intf_lag2port(L7_uint32 lag_idx, L7_uint32 *ptin_port);
+extern L7_RC_t ptin_intf_lag2port(L7_uint32 lag_idx, L7_uint32 *ptin_port);
 
 /**
  * Converts ptin_port index to PTin port type and id
  * 
  * @param ptin_port PTin port index
  * @param port_type PTin port type (0 is physical and 1 is LAG) 
  * @param port_id   PTin port id
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_port2ptintf(L7_uint32 ptin_port, ptin_intf_t *ptin_intf);
+extern L7_RC_t ptin_intf_port2ptintf(L7_uint32 ptin_port, ptin_intf_t *ptin_intf);
 
 /**
  * Converts PTin port type and id to ptin_port index
  * 
  * @param port_type PTin port type (0 is physical and 1 is LAG) 
  * @param port_id   PTin port id
  * @param ptin_port PTin port index
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_ptintf2port(const ptin_intf_t *ptin_intf, L7_uint32 *ptin_port);
+extern L7_RC_t ptin_intf_ptintf2port(const ptin_intf_t *ptin_intf, L7_uint32 *ptin_port);
 
 /**
  * Converts PTin port type and id to ptin_port index
  * 
  * @param intf_type PTin port type (0 is physical and 1 is LAG) 
  * @param intf_id   PTin port id
  * @param ptin_port PTin port index
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_typeId2port(L7_uint8 intf_type, L7_uint8 intf_id, L7_uint32 *ptin_port);
+extern L7_RC_t ptin_intf_typeId2port(L7_uint8 intf_type, L7_uint8 intf_id, L7_uint32 *ptin_port);
 
 /**
  * Converts ptin_port index to port type and id
  * 
  * @param ptin_port PTin port index
  * @param intf_type PTin port type (out)
  * @param intf_id   PTin port id (out)
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_port2typeId(L7_uint32 ptin_port, L7_uint8 *intf_type, L7_uint8 *intf_id);
+extern L7_RC_t ptin_intf_port2typeId(L7_uint32 ptin_port, L7_uint8 *intf_type, L7_uint8 *intf_id);
 
 /**
  * Converts FP interface# to PTin port type and id
  * 
  * @param intIfNum  FP intIfNum
  * @param port_type PTin port type (0 is physical and 1 is LAG) 
  * @param port_id   PTin port id
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_intIfNum2ptintf(L7_uint32 intIfNum, ptin_intf_t *ptin_intf);
+extern L7_RC_t ptin_intf_intIfNum2ptintf(L7_uint32 intIfNum, ptin_intf_t *ptin_intf);
 
 /**
  * Converts PTin port type and id to FP interface#
  * 
  * @param port_type PTin port type (0 is physical and 1 is LAG) 
  * @param port_id   PTin port id
  * @param intIfNum  FP intIfNum
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_ptintf2intIfNum(const ptin_intf_t *ptin_intf, L7_uint32 *intIfNum);
+extern L7_RC_t ptin_intf_ptintf2intIfNum(const ptin_intf_t *ptin_intf, L7_uint32 *intIfNum);
 
 /**
  * Converts PTin port type and id to FP interface#
  * 
  * @param intf_type PTin port type (0 is physical and 1 is LAG) 
  * @param intf_id   PTin port id
  * @param intIfNum  FP intIfNum
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_typeId2intIfNum(L7_uint8 intf_type, L7_uint8 intf_id, L7_uint32 *intIfNum);
+extern L7_RC_t ptin_intf_typeId2intIfNum(L7_uint8 intf_type, L7_uint8 intf_id, L7_uint32 *intIfNum);
 
 /**
  * Converts LAG index [1..PTIN_SYSTEM_N_LAGS] to FP intIfNum
  * 
  * @param intIfNum  FP intIfNum
  * @param ptin_port PTin port index
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_lag2intIfNum(L7_uint32 lag_idx, L7_uint32 *intIfNum);
+extern L7_RC_t ptin_intf_lag2intIfNum(L7_uint32 lag_idx, L7_uint32 *intIfNum);
 
 /**
  * Convert intIfNum to LAG index
  * 
  * @param intIfNum  FP intIfNum
  * @param lag_idx   LAG index (output)
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_intIfNum2lag(L7_uint32 intIfNum, L7_uint32 *lag_idx);
+extern L7_RC_t ptin_intf_intIfNum2lag(L7_uint32 intIfNum, L7_uint32 *lag_idx);
 
 #if PTIN_BOARD_IS_MATRIX
 /**
  * Converts Slot to LAG index [0..PTIN_SYSTEM_N_LAGS[
  * 
  * @param slot      slot
  * @param lag_idx   LAG index [0..PTIN_SYSTEM_N_LAGS[ (output)
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_slot2lagIdx(L7_uint16 slot, L7_uint32 *lag_idx);
+extern L7_RC_t ptin_intf_slot2lagIdx(L7_uint16 slot, L7_uint32 *lag_idx);
 #endif
 
 /**
  * Check if a LAG is created [1..PTIN_SYSTEM_N_LAGS]
  * 
  * @param lag_idx   LAG index [1..PTIN_SYSTEM_N_LAGS]
  * 
  * @return L7_RC_t L7_TRUE/L7_FALSE
  */
-extern inline L7_RC_t ptin_intf_lag_exists(L7_uint32 lag_idx);
+extern L7_RC_t ptin_intf_lag_exists(L7_uint32 lag_idx);
 
 
 /**
  * Check if a particular port is used for uplink protection
  * 
  * @author mruas (5/2/2014)
Index: src/application/ptin/base/ptin_prot_erps.c
===================================================================
--- src/application/ptin/base/ptin_prot_erps.c	(revision 7375)
+++ src/application/ptin/base/ptin_prot_erps.c	(revision 7378)
@@ -595,13 +595,13 @@ int ptin_erps_remove_entry(L7_uint8 erps
   }
 
   osapiSemaTake(ptin_prot_erps_sem, L7_WAIT_FOREVER);
 
   if (tbl_erps[erps_idx].admin == PROT_ERPS_ENTRY_FREE) {
     osapiSemaGive(ptin_prot_erps_sem);
-    PT_LOG_TRACE(LOG_CTX_ERPS, "Entry free.", ret);
+    PT_LOG_TRACE(LOG_CTX_ERPS, "Entry free %d.", ret);
     return(ret);
   }
 
   ptin_erps_blockOrUnblockPort(erps_idx, PROT_ERPS_PORT0, ERPS_PORT_FLUSHING, __LINE__);
   ptin_erps_blockOrUnblockPort(erps_idx, PROT_ERPS_PORT1, ERPS_PORT_FLUSHING, __LINE__);
   ptin_erps_FlushFDB(erps_idx, __LINE__);
@@ -625,14 +625,12 @@ int ptin_erps_remove_entry(L7_uint8 erps
  * @return int 
  */
 int ptin_erps_clear(void)
 {
   int erps_idx, ret=PROT_ERPS_EXIT_OK;
 
-  PT_LOG_TRACE(LOG_CTX_ERPS, "");
-
   for (erps_idx=0; erps_idx<MAX_PROT_PROT_ERPS; erps_idx++) {
     if ((ret=ptin_erps_remove_entry(erps_idx))!=erps_idx) {
       PT_LOG_ERR(LOG_CTX_ERPS, "ERROR: (%d) while removing ERPS#%d\n\r", ret, erps_idx);
       ret = PROT_ERPS_EXIT_NOK1;
     }
   }
@@ -1206,13 +1204,13 @@ int ptin_erps_blockOrUnblockPort(L7_uint
   {
     PT_LOG_ERR(LOG_CTX_ERPS,"ERPS#%d not valid", erps_idx);
     return PROT_ERPS_INDEX_VIOLATION;
   }
   if (port > PROT_ERPS_PORT1)
   {
-    PT_LOG_ERR(LOG_CTX_ERPS,"ERPS#%d: Invalid port id %u", port);
+    PT_LOG_ERR(LOG_CTX_ERPS,"ERPS#%d: Invalid port id %u", erps_idx, port);
     return PROT_ERPS_INDEX_VIOLATION;
   }
 
   PT_LOG_TRACE(LOG_CTX_ERPS, "ERPS#%d: port %d, portState %s (line_callback %d)", erps_idx, port, strPortState[portState], line_callback);
 
   #ifdef SM_PTIN_MODS
@@ -1262,13 +1260,13 @@ int ptin_erps_force_alarms(L7_uint8 erps
   {
     PT_LOG_ERR(LOG_CTX_ERPS,"ERPS#%d not valid", erps_idx);
     return PROT_ERPS_INDEX_VIOLATION;
   }
   if (port > PROT_ERPS_PORT1)
   {
-    PT_LOG_ERR(LOG_CTX_ERPS,"ERPS#%d: Invalid port id %u", port);
+    PT_LOG_ERR(LOG_CTX_ERPS,"ERPS#%d: Invalid port id %u", erps_idx, port);
     return PROT_ERPS_INDEX_VIOLATION;
   }
 
   PT_LOG_TRACE(LOG_CTX_ERPS,"ERPS#%d: port %d, SF %d", erps_idx, port, sf&1);
 
   force_erps_SF[erps_idx][port] = sf;
@@ -1300,13 +1298,13 @@ int ptin_erps_rd_alarms(L7_uint8 erps_id
   {
     PT_LOG_ERR(LOG_CTX_ERPS,"ERPS#%d not valid", erps_idx);
     return PROT_ERPS_INDEX_VIOLATION;
   }
   if (port > PROT_ERPS_PORT1)
   {
-    PT_LOG_ERR(LOG_CTX_ERPS,"ERPS#%d: Invalid port id %u", port);
+    PT_LOG_ERR(LOG_CTX_ERPS,"ERPS#%d: Invalid port id %u", erps_idx, port);
     return PROT_ERPS_INDEX_VIOLATION;
   }
 
   if (force_erps_SF[erps_idx][port]) {
     ret[port] = (force_erps_SF[erps_idx][port] & 1);
 
Index: src/application/ptin/base/ethsrv_oam.c
===================================================================
--- src/application/ptin/base/ethsrv_oam.c	(revision 7375)
+++ src/application/ptin/base/ethsrv_oam.c	(revision 7378)
@@ -2449,13 +2449,13 @@ T_ETH_OAM_MAC this_MP_MAC;
 
      //Response to an LTM
      //if (0==p_ltm->TTL) return 0;//5
 
      this_MPs_MAC(oam_prt, vid, MEP_in_DB?1:0, this_MP_MAC.byte);
      TerminalMP= memcmp(p_ltm->targ_mac, this_MP_MAC.byte, sizeof(T_ETH_OAM_MAC))? 0:1;
-     ETHSRV_OAM_LOG("this_MP_MAC=%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\tTerminalMP=%2.2u TTL=%u transID=%u pkt_len-2=%u"NLS,
+     ETHSRV_OAM_LOG("this_MP_MAC=%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\tTerminalMP=%2.2u TTL=%u transID=%lu pkt_len-2=%lu"NLS,
                     this_MP_MAC.byte[0], this_MP_MAC.byte[1], this_MP_MAC.byte[2],
                     this_MP_MAC.byte[3], this_MP_MAC.byte[4], this_MP_MAC.byte[5], TerminalMP,
                     p_ltm->TTL, p_ltm->transID, pkt_len-2);
 
      if (MEP_in_DB) {   //we're a MEP
          if (!TerminalMP) return 0;//6;
Index: src/application/ptin/base/ptin_evc.c
===================================================================
--- src/application/ptin/base/ptin_evc.c	(revision 7375)
+++ src/application/ptin/base/ptin_evc.c	(revision 7378)
@@ -2184,13 +2184,13 @@ L7_BOOL ptin_evc_intf_isRoot(L7_uint16 i
     return L7_TRUE;
   }
 
   /* Get interface configuration */
   if (ptin_evc_intf_type_get(intVlan, intIfNum, &intf_type)!=L7_SUCCESS)
   {
-    PT_LOG_WARN(LOG_CTX_DHCP, "Error acquiring interface %u/%u type from internalVid %u and intIfNum %u", intVlan, intIfNum);
+    PT_LOG_WARN(LOG_CTX_DHCP, "Error acquiring from internalVid %u and intIfNum %u", intVlan, intIfNum);
     return L7_FALSE;
   }
   if(intf_type == PTIN_EVC_INTF_ROOT)
   {
      return L7_TRUE;
   }
@@ -4709,13 +4709,13 @@ int intf_vp_DB(int _0init_1insert_2remov
 
      for (intf_vp_modu=INTF_VP_MAX; 1;) {                                     //Just to improve modulus
          for (i=2; i*i<intf_vp_modu; i++) if (0==intf_vp_modu%i) break;
          if (i*i>=intf_vp_modu) break;
          intf_vp_modu++;
      }
-     PT_LOG_INFO(LOG_CTX_EVC, "IfN_vp_DB init(%d)\tN=%lu\tmodu=%lu\tL7_MAX_INTERFACE_COUNT=%lu", _0init_1insert_2remove_3find, INTF_VP_MAX, intf_vp_modu, L7_MAX_INTERFACE_COUNT);
+     PT_LOG_INFO(LOG_CTX_EVC, "IfN_vp_DB init(%d)\tN=%d\tmodu=%lu\tL7_MAX_INTERFACE_COUNT=%d", _0init_1insert_2remove_3find, INTF_VP_MAX, intf_vp_modu, L7_MAX_INTERFACE_COUNT);
      break;
   case 1:
   case 2:
   case 3:
      i=vportId__2__i(entry->vport_id, intf_vp_modu%INTF_VP_MAX);
      for (j=0, k=i, _1st_empty=-1;  j<INTF_VP_MAX;  j++) {
@@ -4929,13 +4929,13 @@ static int intf_vp_policer(intf_vp_entry
   }
   else
   {
     /* Check if policer exists */
     if (!intf_vp->policer.in_use)
     {
-      PT_LOG_WARN(LOG_CTX_L2, "vport 0x%x already does not have policer", intf_vp->vport_id);
+      PT_LOG_WARN(LOG_CTX_L2, "vport 0x%lx already does not have policer", intf_vp->vport_id);
       return L7_SUCCESS;
     }
 
     PT_LOG_TRACE(LOG_CTX_EVC,"Going to remove policer");
 
     /* Remove this policer to all MAC entries */
@@ -5001,13 +5001,13 @@ static int intf_vp_policer(intf_vp_entry
     }
   }
 
   /* If success... */
   if (rc == L7_SUCCESS)
   {
-    PT_LOG_TRACE(LOG_CTX_L2, "Success updating policer to virtual port 0x%08x",intf_vp->vport_id);
+    PT_LOG_TRACE(LOG_CTX_L2, "Success updating policer to virtual port 0x%08lx",intf_vp->vport_id);
 
     /* Remove policer, if it was that intention */
     if (meter == L7_NULLPTR || meter->cir == (L7_uint32)-1)
     {
       PT_LOG_TRACE(LOG_CTX_EVC,"Policer %d", intf_vp->policer.policer_id);
 
@@ -5029,13 +5029,13 @@ static int intf_vp_policer(intf_vp_entry
       memset(&intf_vp->policer, 0x00, sizeof(intf_vp_entry_policer_t));
       intf_vp->policer.in_use = L7_FALSE;
     }
   }
   else
   {
-    PT_LOG_ERR(LOG_CTX_L2, "Error updating policer to virtual port 0x%08x",intf_vp->vport_id);
+    PT_LOG_ERR(LOG_CTX_L2, "Error updating policer to virtual port 0x%08lx",intf_vp->vport_id);
   }
 
   PT_LOG_TRACE(LOG_CTX_EVC,"Finished");
 
   return L7_SUCCESS;
 }
@@ -5066,13 +5066,13 @@ L7_RC_t ptin_evc_macbridge_client_packag
   L7_uint32   leaf_port;
   L7_uint32   intIfNum; 
 
   /* Input Argument validation */
   if ( ecvFlow  == L7_NULLPTR)
   {
-    PT_LOG_ERR(LOG_CTX_EVC, "Invalid arguments [msg:%p noOfMessages:%u]",ecvFlow);    
+    PT_LOG_ERR(LOG_CTX_EVC, "Invalid arguments");    
     return L7_FAILURE;
   }
   
   evc_ext_id = ecvFlow->evc_idx;
   PT_LOG_TRACE(LOG_CTX_EVC, "Adding eEVC# %u flow connection...", evc_ext_id);
 
@@ -5174,13 +5174,13 @@ L7_RC_t ptin_evc_macbridge_client_packag
   L7_uint32   leaf_port;
   L7_uint32   intIfNum;
     
   /* Input Argument validation */
   if ( ecvFlow  == L7_NULLPTR)
   {
-    PT_LOG_ERR(LOG_CTX_EVC, "Invalid arguments [msg:%p noOfMessages:%u]",ecvFlow);    
+    PT_LOG_ERR(LOG_CTX_EVC, "Invalid arguments");
     return L7_FAILURE;
   }
 
   evc_ext_id = ecvFlow->evc_idx;
   PT_LOG_TRACE(LOG_CTX_EVC, "Adding eEVC# %u flow connection...", evc_ext_id);
 
@@ -5544,21 +5544,24 @@ L7_RC_t ptin_evc_flow_add(ptin_HwEthEvcF
     pflow->maxBandwidth = evcFlow->maxBandwidth;
     pflow->maxChannels  = evcFlow->maxChannels;
 
     dl_queue_add_tail(&evcs[evc_id].intf[leaf_port].clients, (dl_queue_elem_t*) pflow); /* add it to the corresponding interface */
     evcs[evc_id].n_clientflows++;
 
-    PT_LOG_TRACE(LOG_CTX_EVC, "eEVC# %u: flow successfully added (vport_id=%lu\tpon=%u/%u(%lu)\tgem_id=%u\tvirtual_gport=0x%8.8lx)",
+    PT_LOG_TRACE(LOG_CTX_EVC, "eEVC# %u: flow successfully added (vport_id=%d\tpon=%u/%u(%u)\tgem_id=%u\tvirtual_gport=0x%8.8x)",
              evc_ext_id,
              vport_id & 0xffffff,
-             evcFlow->ptin_intf.intf_type,evcFlow->ptin_intf.intf_id, intIfNum,
-             evcFlow->uni_ovid, vport_id);
+             evcFlow->ptin_intf.intf_type,
+             evcFlow->ptin_intf.intf_id,
+             intIfNum,
+             evcFlow->uni_ovid,
+             vport_id);
   }
   else
   {
-    PT_LOG_WARN(LOG_CTX_EVC, "EVC# %u: GEM id already exists", evc_id, evcFlow->uni_ovid, leaf_port);
+    PT_LOG_WARN(LOG_CTX_EVC, "EVC# %u: GEM id already exists", evc_id);
   }
 
   /* Protocols */
   igmp_enabled    = (evcFlow->flags & PTIN_EVC_MASK_IGMP_PROTOCOL  ) == PTIN_EVC_MASK_IGMP_PROTOCOL;
   dhcpv4_enabled  = (evcFlow->flags & PTIN_EVC_MASK_DHCPV4_PROTOCOL) == PTIN_EVC_MASK_DHCPV4_PROTOCOL;
   dhcpv6_enabled  = (evcFlow->flags & PTIN_EVC_MASK_DHCPV6_PROTOCOL) == PTIN_EVC_MASK_DHCPV6_PROTOCOL;
@@ -9594,13 +9597,13 @@ static L7_RC_t ptin_evc_intf_remove(L7_u
     if (iptv_flag)
     {
       rc = ptin_igmp_mgmd_port_remove(evcs[evc_id].extended_id, intIfNum);
       if (rc != L7_SUCCESS)
       {
         PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: error removing Mgmd Port [extended_id=%u intIfNum=%u]",
-                evcs[evc_id].extended_id, intIfNum);
+                evc_id, evcs[evc_id].extended_id, intIfNum);
   //    return rc;
       }
       else
       {
         PT_LOG_TRACE(LOG_CTX_EVC, "Removed Mgmd Port [extended_id:%u intIfNum=%u]", evcs[evc_id].extended_id, intIfNum);
       }
@@ -11315,14 +11318,14 @@ static L7_RC_t switching_elan_leaf_remov
   /* Remove egress xlate entry: (leaf_intf) (Vr,Vc) => (Vs',Vc) */
   if (leaf_out_vlan >= 1)
   {
     rc = ptin_xlate_egress_delete(intIfNum, int_vlan, leaf_inner_vlan);
     if (rc != L7_SUCCESS)
     {
-      PT_LOG_ERR(LOG_CTX_EVC, "Error deleting intf %u xlate Egress entry [Root Int.VLAN %u + Inn.VLAN %u (rc=%d)",
-              leaf_intf, int_vlan, leaf_inner_vlan, leaf_out_vlan, rc);
+      PT_LOG_ERR(LOG_CTX_EVC, "Error deleting intfIfNum %u xlate Egress entry [Root Int.VLAN %u + Inn.VLAN %u (rc=%d)",
+              intIfNum, int_vlan, leaf_inner_vlan, rc);
       return rc;
     }
   }
   else
   {
     PT_LOG_WARN(LOG_CTX_EVC, "No need to remove egress translations (leaf_intf %u)", leaf_intf);
@@ -11415,14 +11418,14 @@ static L7_RC_t switching_mcevc_leaf_remo
   /* Add egress xlate entry: (leaf_intf) (Vr,Vc) => (Vs',Vc) */
   if (leaf_out_vlan >= 1)
   {
     rc = ptin_xlate_egress_delete(intIfNum, int_vlan, 0); 
     if (rc != L7_SUCCESS)
     {
-      PT_LOG_ERR(LOG_CTX_EVC, "Error deleting intf %u xlate Egress entry [Root Int.VLAN %u (rc=%d)",
-              leaf_intf, int_vlan, leaf_out_vlan, rc);
+      PT_LOG_ERR(LOG_CTX_EVC, "Error deleting intfIfNum %u xlate Egress entry [Root Int.VLAN %u (rc=%d)",
+              intIfNum, int_vlan, rc);
       return rc;
     }
   }
   else
   {
     PT_LOG_WARN(LOG_CTX_EVC, "No need to remove egress translations (leaf_intf %u)", leaf_intf);
@@ -12320,13 +12323,13 @@ L7_RC_t ptin_evc_bwProfile_verify(L7_uin
           {
             if (profile->outer_vlan_lookup!=pclientFlow->uni_ovid)
             {
               PT_LOG_ERR(LOG_CTX_EVC,"OVid_in %u does not match to the one in EVC client (%u)", profile->outer_vlan_lookup, pclientFlow->uni_ovid);
               return L7_FAILURE;
             }
-            PT_LOG_TRACE(LOG_CTX_EVC,"OVid_in %u verified for client %u",ptin_port,profile->outer_vlan_lookup,profile->inner_vlan_ingress);
+            PT_LOG_TRACE(LOG_CTX_EVC,"OVid_in %u verified for client %u", profile->outer_vlan_lookup, profile->inner_vlan_ingress);
           }
           /* Removed: for non QUATTRO services, these vlans should be null */
           //profile->outer_vlan_out = pclientFlow->uni_ovid;
           //profile->inner_vlan_out = 0;                /* There is no inner vlan, after packet leaves the port (leaf port in a stacked service) */
         }
 
@@ -12483,13 +12486,13 @@ static L7_RC_t ptin_evc_evcStats_verify(
         {
           if (profile->outer_vlan_lookup!=pclientFlow->uni_ovid)
           {
             PT_LOG_ERR(LOG_CTX_EVC,"OVid_in %u does not match to the one in EVC client (%u)",profile->outer_vlan_lookup,pclientFlow->uni_ovid);
             return L7_FAILURE;
           }
-          PT_LOG_TRACE(LOG_CTX_EVC,"OVid_in %u verified for client %u",ptin_port,profile->outer_vlan_lookup,profile->inner_vlan_ingress);
+          PT_LOG_TRACE(LOG_CTX_EVC,"OVid_in %u verified for client %u", profile->outer_vlan_lookup, profile->inner_vlan_ingress);
         }
         profile->outer_vlan_egress = pclientFlow->uni_ovid;
         profile->inner_vlan_egress = 0;                /* No need to consider inner vlan at the egress */
       }
     } /* else (profile->inner_vlan_in==0) */
 
Index: src/dtl/base/dtl_pdu_landd.c
===================================================================
--- src/dtl/base/dtl_pdu_landd.c	(revision 7375)
+++ src/dtl/base/dtl_pdu_landd.c	(revision 7378)
@@ -59,13 +59,17 @@ L7_BOOL pdu_receive_debug = 0;
 void pdu_receive_debug_enable(L7_BOOL enable)
 {
   pdu_receive_debug = enable;
 }
 
 static L7_uint8  ptin_debug_dtl = 0;
-inline void ptin_debug_dtl_set(L7_uint8 enable){ptin_debug_dtl = enable;};
+
+static inline void ptin_debug_dtl_set(L7_uint8 enable)
+{
+  ptin_debug_dtl = enable;
+};
 #endif
 
 
 /*
 **********************************************************************
 *                           PRIVATE FUNCTIONS PROTOTYPES
Index: src/dtl/switching/dtl_l2_fdb.c
===================================================================
--- src/dtl/switching/dtl_l2_fdb.c	(revision 7375)
+++ src/dtl/switching/dtl_l2_fdb.c	(revision 7378)
@@ -670,13 +670,13 @@ L7_RC_t dtlFdbMacAddrDelete(L7_uchar8 *m
   DAPI_USP_t ddUsp;
   DAPI_ADDR_MGMT_CMD_t dapiCmd;
   DAPI_ADDR_FLAG_t dapiFlag;
   L7_RC_t dr;
   nimUSP_t usp;
 
-  PT_LOG_TRACE(LOG_CTX_L2, "vlan=%u, MAC=%02x:%02x:%02x:%02x:%02x:%02x",
+  PT_LOG_TRACE(LOG_CTX_L2, "vlan=%lu, MAC=%02x:%02x:%02x:%02x:%02x:%02x",
             filterDbID,
             macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5]);
 
   if (nimGetUnitSlotPort(intfNum, &usp) != L7_SUCCESS)
   {
     PT_LOG_ERR(LOG_CTX_L2,"Error!");
Index: src/mgmt/snmp/packages/routing/vrrp/k_mib_vrrp.c
===================================================================
--- src/mgmt/snmp/packages/routing/vrrp/k_mib_vrrp.c	(revision 7375)
+++ src/mgmt/snmp/packages/routing/vrrp/k_mib_vrrp.c	(revision 7378)
@@ -1457,9 +1457,9 @@ k_agentRouterVrrpTrackRouteEntry_set(age
                                 intIfNum,data->agentRouterVrrpTrackRtPfx, data->agentRouterVrrpTrackRtPfxLen,
                                 data->agentRouterVrrpTrackRtStatus) != L7_SUCCESS))
     return(COMMIT_FAILED_ERROR);
 
 
 
-    return NO_ERROR;
+  return NO_ERROR;
 }
 
Index: src/mgmt/snmp/packages/base/k_mib_fastpath_timerange.c
===================================================================
--- src/mgmt/snmp/packages/base/k_mib_fastpath_timerange.c	(revision 7375)
+++ src/mgmt/snmp/packages/base/k_mib_fastpath_timerange.c	(revision 7378)
@@ -275,16 +275,16 @@ timeRangeEntry_undo(doList_t *doHead, do
   if ( undodata == NULL )
   {
     /* ignore if deleting a non-existant entry */
     if (data->timeRangeStatus == D_timeRangeStatus_destroy)
       return NO_ERROR;
 
-      /* undoin g an add, so delete */
-      data->timeRangeStatus = D_timeRangeStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoin g an add, so delete */
+    data->timeRangeStatus = D_timeRangeStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if ((undodata->timeRangeStatus == D_timeRangeStatus_notReady)
          || (undodata->timeRangeStatus == D_timeRangeStatus_notInService))
@@ -679,16 +679,16 @@ timeRangeAbsoluteEntry_undo(doList_t *do
   if ( undodata == NULL )
   {
     /* ignore if deleting a non-existant entry */
     if (data->timeRangeAbsoluteStatus == D_timeRangeAbsoluteStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->timeRangeAbsoluteStatus = D_timeRangeAbsoluteStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->timeRangeAbsoluteStatus = D_timeRangeAbsoluteStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if ((undodata->timeRangeAbsoluteStatus == D_timeRangeAbsoluteStatus_notReady)
          || (undodata->timeRangeAbsoluteStatus == D_timeRangeAbsoluteStatus_notInService))
@@ -1085,16 +1085,16 @@ timeRangePeriodicEntry_undo(doList_t *do
   if ( undodata == NULL )
   {
     /* ignore if deleting a non-existant entry */
     if (data->timeRangePeriodicStatus == D_timeRangePeriodicStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->timeRangePeriodicStatus = D_timeRangePeriodicStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->timeRangePeriodicStatus = D_timeRangePeriodicStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if ((undodata->timeRangePeriodicStatus == D_timeRangePeriodicStatus_notReady)
          || (undodata->timeRangePeriodicStatus == D_timeRangePeriodicStatus_notInService))
Index: src/mgmt/snmp/packages/ip_mcast/k_mib_mcast_api.h
===================================================================
--- src/mgmt/snmp/packages/ip_mcast/k_mib_mcast_api.h	(revision 7375)
+++ src/mgmt/snmp/packages/ip_mcast/k_mib_mcast_api.h	(revision 7378)
@@ -294,23 +294,23 @@ snmpMcastMrouteBoundaryStatusSet(L7_uint
   if(L7_SUCCESS != inetAddressSet(L7_AF_INET, &ipAddr, &inetMRtSrc))
     return L7_FAILURE;
   inetAddressReset(&inetSrcMask);
   if(L7_SUCCESS != inetAddressSet(L7_AF_INET, &ipMask, &inetSrcMask))
     return L7_FAILURE;
 
-    switch (val)
-    {
-        case D_ipMRouteBoundaryStatus_active:
-        case D_ipMRouteBoundaryStatus_createAndGo:
-			 rc = usmDbMcastMrouteBoundaryAdd(UnitIndex, intIfNum, &inetMRtSrc, &inetSrcMask);
-             break;
+  switch (val)
+  {
+      case D_ipMRouteBoundaryStatus_active:
+      case D_ipMRouteBoundaryStatus_createAndGo:
+           rc = usmDbMcastMrouteBoundaryAdd(UnitIndex, intIfNum, &inetMRtSrc, &inetSrcMask);
+           break;
 
-        case D_ipMRouteBoundaryStatus_destroy:
-             rc = usmDbMcastMrouteBoundaryDelete(UnitIndex, intIfNum, &inetMRtSrc, &inetSrcMask);
-	        break;
-        default:
-             rc = L7_FAILURE;
-    }
+      case D_ipMRouteBoundaryStatus_destroy:
+           rc = usmDbMcastMrouteBoundaryDelete(UnitIndex, intIfNum, &inetMRtSrc, &inetSrcMask);
+          break;
+      default:
+           rc = L7_FAILURE;
+  }
 
   return rc;
 }
 #endif
Index: src/mgmt/snmp/packages/switching/common/k_mib_fastpathswitching_api.h
===================================================================
--- src/mgmt/snmp/packages/switching/common/k_mib_fastpathswitching_api.h	(revision 7375)
+++ src/mgmt/snmp/packages/switching/common/k_mib_fastpathswitching_api.h	(revision 7378)
@@ -13422,27 +13422,27 @@ L7_RC_t snmpAgentSwitchVoiceVlanDeviceEn
   {
      if (usmdbVoiceVlanPortDeviceInfoFirstGet(UnitIndex,intIfNum,deviceMacAddr) == L7_SUCCESS )
      {
        if (memcmp(deviceMacAddr,macAddress,sizeof(deviceMacAddr))== 0)
        {
          if(voiceVlanDeviceDebugFlag== L7_TRUE)
-          printf("\n %s: Returning success",__FUNCTION__);
-          return L7_SUCCESS;
+           printf("\n %s: Returning success",__FUNCTION__);
+         return L7_SUCCESS;
        }
      }
      else
      {
        rc1=usmdbVoiceVlanPortDeviceInfoNextGet(UnitIndex,intIfNum,deviceMacAddr);
         while(rc1==L7_SUCCESS)
         {
           if (memcmp(deviceMacAddr,macAddress,sizeof(deviceMacAddr))== 0)
-            {
-              if(voiceVlanDeviceDebugFlag== L7_TRUE)
-                printf("\n %s: Returning success",__FUNCTION__);
-              return L7_SUCCESS;
-            }
+          {
+            if(voiceVlanDeviceDebugFlag== L7_TRUE)
+              printf("\n %s: Returning success",__FUNCTION__);
+            return L7_SUCCESS;
+          }
           rc1 = usmdbVoiceVlanPortDeviceInfoNextGet(UnitIndex,intIfNum,deviceMacAddr);
         }
      }
   }
 
   if(voiceVlanDeviceDebugFlag== L7_TRUE)
Index: src/mgmt/snmp/packages/qos/k_mib_qos_acl.c
===================================================================
--- src/mgmt/snmp/packages/qos/k_mib_qos_acl.c	(revision 7375)
+++ src/mgmt/snmp/packages/qos/k_mib_qos_acl.c	(revision 7378)
@@ -227,16 +227,16 @@ aclEntry_undo(doList_t *doHead, doList_t
   if ( undodata == NULL )
   {
     /* ignore if deleting a non-existant entry */
     if (data->aclStatus == D_aclStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->aclStatus = D_aclStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->aclStatus = D_aclStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if((undodata->aclStatus == D_aclStatus_notReady)
          || (undodata->aclStatus == D_aclStatus_notInService))
@@ -468,16 +468,16 @@ aclIfEntry_undo(doList_t *doHead, doList
   if ( undodata == NULL )
   {
     /* ignore if deleting a non-existant entry */
     if (data->aclIfStatus == D_aclIfStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->aclIfStatus = D_aclIfStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->aclIfStatus = D_aclIfStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if((undodata->aclIfStatus == D_aclIfStatus_notReady)
          || (undodata->aclIfStatus == D_aclIfStatus_notInService))
@@ -1130,16 +1130,16 @@ aclRuleEntry_undo(doList_t *doHead, doLi
   if ( undodata == NULL )
   {
     /* ignore if deleting a non-existant entry */
     if (data->aclRuleStatus == D_aclRuleStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->aclRuleStatus = D_aclRuleStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->aclRuleStatus = D_aclRuleStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if((undodata->aclRuleStatus == D_aclRuleStatus_notReady)
          || (undodata->aclRuleStatus == D_aclRuleStatus_notInService))
@@ -1412,16 +1412,16 @@ aclMacEntry_undo(doList_t *doHead, doLis
   if ( undodata == NULL )
   {
     /* ignore if deleting a non-existant entry */
     if (data->aclMacStatus == D_aclMacStatus_destroy)
       return NO_ERROR;
 
-      /* undoin g an add, so delete */
-      data->aclMacStatus = D_aclMacStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoin g an add, so delete */
+    data->aclMacStatus = D_aclMacStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if((undodata->aclMacStatus == D_aclMacStatus_notReady)
          || (undodata->aclMacStatus == D_aclMacStatus_notInService))
@@ -2066,16 +2066,16 @@ aclMacRuleEntry_undo(doList_t *doHead, d
   if ( undodata == NULL )
   {
     /* ignore if deleting a non-existant entry */
     if (data->aclMacRuleStatus == D_aclMacRuleStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->aclMacRuleStatus = D_aclMacRuleStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->aclMacRuleStatus = D_aclMacRuleStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if((undodata->aclMacRuleStatus == D_aclMacRuleStatus_notReady)
          || (undodata->aclMacRuleStatus == D_aclMacRuleStatus_notInService))
Index: src/mgmt/snmp/packages/qos/k_mib_qos_diffserv_private_api.h
===================================================================
--- src/mgmt/snmp/packages/qos/k_mib_qos_diffserv_private_api.h	(revision 7375)
+++ src/mgmt/snmp/packages/qos/k_mib_qos_diffserv_private_api.h	(revision 7378)
@@ -1479,13 +1479,13 @@ L7_RC_t snmpDiffServClassRuleMatchDstIpv
                                                    L7_uint32 *prefix_len, 
                                                    L7_uint32 *prefixLen)
 {
    L7_in6_addr_t prefix;
    
    memset(&prefix, 0x00, sizeof(prefix));
-   memset(snmp_buffer, 0x00, sizeof(snmp_buffer));
+   memset(snmp_buffer, 0x00, sizeof(*snmp_buffer));
    if((usmDbDiffServClassRuleMatchDstIpv6AddrGet(UnitIndex, classIndex, classRuleIndex, &prefix) == L7_SUCCESS) &&
       (usmDbDiffServClassRuleMatchDstIpv6PrefLenGet(UnitIndex, classIndex, classRuleIndex, prefixLen) == L7_SUCCESS))
    {
       memcpy(snmp_buffer, prefix.in6.addr8, sizeof(prefix.in6.addr8)); 
       *prefix_len = sizeof(prefix.in6.addr8);
       return L7_SUCCESS;
@@ -1500,13 +1500,13 @@ L7_RC_t snmpDiffServClassRuleMatchSrcIpv
                                                    L7_uint32 *prefix_len, 
                                                    L7_uint32 *prefixLen)
 {
    L7_in6_addr_t prefix6;
 
    memset(&prefix6, 0x00, sizeof(prefix6));
-   memset(snmp_buffer, 0x00, sizeof(snmp_buffer));
+   memset(snmp_buffer, 0x00, sizeof(*snmp_buffer));
    if((usmDbDiffServClassRuleMatchSrcIpv6AddrGet(UnitIndex, classIndex, classRuleIndex, &prefix6) == L7_SUCCESS) &&
       (usmDbDiffServClassRuleMatchSrcIpv6PrefLenGet(UnitIndex, classIndex, classRuleIndex, prefixLen) == L7_SUCCESS))
    {
       memcpy(snmp_buffer, prefix6.in6.addr8, sizeof(prefix6.in6.addr8)); 
       *prefix_len = sizeof(prefix6.in6.addr8);
       return L7_SUCCESS;
Index: src/mgmt/snmp/util/ip_mcast/trap_api_ip_mcast.c
===================================================================
--- src/mgmt/snmp/util/ip_mcast/trap_api_ip_mcast.c	(revision 7375)
+++ src/mgmt/snmp/util/ip_mcast/trap_api_ip_mcast.c	(revision 7378)
@@ -111,17 +111,19 @@ L7_RC_t SnmpPimNeighborLossTrapSend(L7_u
 {
   L7_SNMP_TRAP_IP_MCAST_PimNeighborLoss_t *trap = L7_NULLPTR;
 
   trap = osapiMalloc(L7_SNMP_COMPONENT_ID, sizeof(L7_SNMP_TRAP_IP_MCAST_PimNeighborLoss_t));
 
   if (trap == L7_NULLPTR)
+  {
     return L7_ERROR;
+  }
 
-    trap->pimNeighborUpTime = pimNeighborUpTime;
-     return snmpTrapSend(L7_SNMP_TRAP_IP_MCAST_PimNeighborLoss, (void*)trap, &SnmpTrapSendCallback_ip_mcast);
+  trap->pimNeighborUpTime = pimNeighborUpTime;
 
+  return snmpTrapSend(L7_SNMP_TRAP_IP_MCAST_PimNeighborLoss, (void*)trap, &SnmpTrapSendCallback_ip_mcast);
 }
 
 /*********************************************************************
 *
 * @purpose  Send a trap when DVMRP neighbor is not pruning
 *
Index: src/mgmt/user_mgr/user_mgr_radius.c
===================================================================
--- src/mgmt/user_mgr/user_mgr_radius.c	(revision 7375)
+++ src/mgmt/user_mgr/user_mgr_radius.c	(revision 7378)
@@ -190,13 +190,13 @@ void userMgrRadiusChallengeInfoGet( L7_u
 {
   L7_radiusAttrHeader_t *radiusAttr;
   L7_BOOL done = L7_FALSE;
 
   /* Initialize pChallengeFlag to false in case the challenge phrase is not found. */
   *pChallengeFlag = L7_FALSE;
-  memset( pChallengePhrase, 0, sizeof(pChallengePhrase));
+  memset( pChallengePhrase, 0, sizeof(*pChallengePhrase));
 
   /* If no attributes found, exit. */
   if (attributesLen <= sizeof(L7_radiusAttrHeader_t))
     return;
 
   radiusAttr = (L7_radiusAttrHeader_t *)attributes;
Index: src/mgmt/broadcom/emweb/linux/ewmain.c
===================================================================
--- src/mgmt/broadcom/emweb/linux/ewmain.c	(revision 7375)
+++ src/mgmt/broadcom/emweb/linux/ewmain.c	(revision 7378)
@@ -1827,16 +1827,16 @@ void ewaNetBufferPreAlloc()
   ewaFree(ptrs);
 
 }
 
 /*********************************************************************
 *********************************************************************/
-L7_RC_t L7_ewsPhaseOneInit(arg0 /* max connections - use default */
-                           ,arg1 /* max buffers - use default */
-                           ,arg2 /* buffer data size - use default */
-                           ,arg3 /* port number - use default */
+L7_RC_t L7_ewsPhaseOneInit(int arg0 /* max connections - use default */
+                           ,int arg1 /* max buffers - use default */
+                           ,int arg2 /* buffer data size - use default */
+                           ,int arg3 /* port number - use default */
                           )
 {
 #if defined(L7_WEB_PACKAGE) || defined(L7_XWEB_PACKAGE)
   EwaStatus             app_status;
 #endif
   /*
Index: src/mgmt/broadcom/cli/switching/spanning_tree/cliutil_dot1s.c
===================================================================
--- src/mgmt/broadcom/cli/switching/spanning_tree/cliutil_dot1s.c	(revision 7375)
+++ src/mgmt/broadcom/cli/switching/spanning_tree/cliutil_dot1s.c	(revision 7378)
@@ -547,13 +547,13 @@ L7_RC_t cliSpanTreeGetPortFwdState( L7_u
     return L7_ERROR;
   }
 
   if ( usmDbDot1sMstiPortForwardingStateGet(unit, instance,
                                             iface, &val) == L7_SUCCESS )
   {
-    memset (stat, 0,sizeof(stat));
+    memset (stat, 0, size);
     switch (val)
     {
     case L7_DOT1S_DISCARDING:
       if ((usmDbDot1sMstiPortLoopInconsistentStateGet(unit, instance, iface, &val) == L7_SUCCESS) 
             && (val == L7_TRUE))
       {
Index: src/mgmt/broadcom/cli/qos/diffserv/cliutil_diffserv.c
===================================================================
--- src/mgmt/broadcom/cli/qos/diffserv/cliutil_diffserv.c	(revision 7375)
+++ src/mgmt/broadcom/cli/qos/diffserv/cliutil_diffserv.c	(revision 7378)
@@ -1661,26 +1661,26 @@ void cliConstructPoliceParmsSyntax(L7_ch
   osapiStrncat(buf, pStrErr_qos_PoliceTx, bufLenMax - strlen(buf) - 1);
   return;
 }
 
 void cliConstructAndPrintPoliceSimpleSyntax(EwsContext ewsContext, L7_char8 * buf, L7_int32 bufLenMax)
 {
-  memset (buf, 0,sizeof(buf));
+  memset (buf, 0, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, pStrErr_common_IncorrectInput, buf, pStrErr_qos_PoliceSimple_1, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, L7_NULLPTR, buf, pStrErr_qos_PoliceViolate, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncat(buf, pStrErr_qos_Close, bufLenMax - strlen(buf) - 1);
   ewsTelnetWrite( ewsContext, buf);
   cliSyntaxBottom(ewsContext);
   return;
 }
 
 void cliConstructAndPrintPoliceSingleRateSyntax(EwsContext ewsContext, L7_char8 * buf, L7_int32 bufLenMax)
 {
-  memset (buf, 0,sizeof(buf));
+  memset (buf, 0, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, pStrErr_common_IncorrectInput, buf, pStrErr_qos_PoliceSingleRate_1, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, L7_NULLPTR, buf, pStrErr_qos_PoliceExceed, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, L7_NULLPTR, buf, pStrErr_qos_PoliceViolate, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
@@ -1689,13 +1689,13 @@ void cliConstructAndPrintPoliceSingleRat
   cliSyntaxBottom(ewsContext);
   return;
 }
 
 void cliConstructAndPrintPoliceTwoRateSyntax(EwsContext ewsContext, L7_char8 * buf, L7_int32 bufLenMax)
 {
-  memset (buf, 0,sizeof(buf));
+  memset (buf, 0, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, pStrErr_common_IncorrectInput, buf, pStrErr_qos_PoliceTwoRate_1, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, L7_NULLPTR, buf, pStrErr_qos_PoliceExceed, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, L7_NULLPTR, buf, pStrErr_qos_PoliceViolate, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
Index: src/mgmt/broadcom/cli/qos/acl/cli_config_acl.c
===================================================================
--- src/mgmt/broadcom/cli/qos/acl/cli_config_acl.c	(revision 7375)
+++ src/mgmt/broadcom/cli/qos/acl/cli_config_acl.c	(revision 7378)
@@ -1293,13 +1293,13 @@ L7_char8 *  getMacAndMask(EwsContext ews
     ewsTelnetWrite( ewsContext, buf);
     cliSyntaxBottom(ewsContext);
     return NULL;
   }
 
   osapiStrncpySafe( strMacAddr, argv[index+*relIndex], sizeof(strMacAddr));
-  memset (macAddr, 0,sizeof(macAddr));
+  memset (macAddr, 0, (size_t)L7_MAC_ADDR_LEN);
   *relIndex  = *relIndex+1;
 
   if (cliConvertMac(strMacAddr, macAddr) != L7_TRUE)
   {
     sprintfAddBlanks (1, 0, 0, 0, pStrErr_common_IncorrectInput, buf,pStrErr_qos_IncorrectMacAddrType);
     ewsTelnetWrite( ewsContext, buf);
Index: src/mgmt/broadcom/cli/base/common/cli_txtcfg.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/cli_txtcfg.c	(revision 7375)
+++ src/mgmt/broadcom/cli/base/common/cli_txtcfg.c	(revision 7378)
@@ -692,13 +692,13 @@ L7_RC_t cliTxtCfgGenerateFile (L7_char8
    */
 
   if (osapiSemaTake(cliRunCfgSema, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_CLI_WEB_COMPONENT_ID,
            "Failed to take cliRunCfgSemaphore %x\n",
-            cliRunCfgSema);
+            (int)cliRunCfgSema);
   }
 
   if (strcmp(filename,sysapiTxtRunCfgFileGet()) == 0 )
   {
     context = &cliTxtRunCfg->ewsContext;
     context->showRunningDefaultFlag = L7_HIDE_DEFAULT;
@@ -746,13 +746,13 @@ L7_RC_t cliTxtCfgGenerateFile (L7_char8
   context->unbufferedWrite = L7_FALSE;
 
   if (osapiSemaGive(cliRunCfgSema) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_CLI_WEB_COMPONENT_ID,
             "Failed to give cliRunCfgSema %x\n",
-            cliRunCfgSema);
+            (int)cliRunCfgSema);
   }
 
 
 
   return L7_SUCCESS;
 }
Index: src/mgmt/broadcom/cli/base/common/cliutil.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/cliutil.c	(revision 7375)
+++ src/mgmt/broadcom/cli/base/common/cliutil.c	(revision 7378)
@@ -779,13 +779,13 @@ L7_BOOL cliSSHLoginCheck(L7_char8 *enter
       {
         rc = L7_FAILURE;
         challengeFlags= L7_TRUE;
       }
       if (L7_SUCCESS == rc)
         {
-            memset(challengePhrase, 0, sizeof(challengePhrase));
+            memset(challengePhrase, 0, sizeof(*challengePhrase));
             /* User is authenticated */
             usmDbLoginSessionUserSet(U_IDX, cliLoginSessionIndexGet(), userNameSSH);
 
             /* Store access level */
             cliCommon[cliUtil.handleNum].userAccess = accessLevel; /* for security */
 
Index: src/mgmt/broadcom/cli/base/common/cli_show_running_config.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/cli_show_running_config.c	(revision 7375)
+++ src/mgmt/broadcom/cli/base/common/cli_show_running_config.c	(revision 7378)
@@ -5366,22 +5366,22 @@ const L7_char8 *cliShowRunningConfig(Ews
   const L7_char8 *prompt;
 
   if (osapiSemaTake(cliRunCfgSema, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_CLI_WEB_COMPONENT_ID,
            "Failed to take cliRunCfgSemaphore %x\n",
-            cliRunCfgSema);
+            (int)cliRunCfgSema);
   }
 
   prompt = cliShowRunningConfigGenerate(ewsContext, argv, numArg, chkFile);
 
   if (osapiSemaGive(cliRunCfgSema) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_CLI_WEB_COMPONENT_ID,
             "Failed to give cliRunCfgSema %x\n",
-            cliRunCfgSema);
+            (int)cliRunCfgSema);
   }
 
   return prompt;
 }
 
 /*********************************************************************
Index: src/mgmt/broadcom/cli/base/common/cli_config_time.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/cli_config_time.c	(revision 7375)
+++ src/mgmt/broadcom/cli/base/common/cli_config_time.c	(revision 7378)
@@ -440,16 +440,17 @@ const L7_char8  *commandClockSummerTimeR
 
   /* get switch ID based on presence/absence of STACKING package */
   if (cliIsStackingSupported () == L7_TRUE)
     unit = EWSUNIT (ewsContext);
   else
     unit = cliGetUnitId ();
-    if (cliConvertTo32BitUnsignedInteger (argv[index], &stWeek) != L7_SUCCESS)
+
+  if (cliConvertTo32BitUnsignedInteger (argv[index], &stWeek) != L7_SUCCESS)
   {
 
-  if (usmDbWeekNumberGet ((L7_char8 *)argv[index], &stWeek) != L7_SUCCESS)
+    if (usmDbWeekNumberGet ((L7_char8 *)argv[index], &stWeek) != L7_SUCCESS)
     {
       ewsTelnetWrite (ewsContext, pStrInfo_base_clierror_summertime_startweek);
       cliSyntaxBottom (ewsContext);
       return cliPrompt (ewsContext);
     }
   }
Index: src/usmdb/system_support/base/usmdb_util.c
===================================================================
--- src/usmdb/system_support/base/usmdb_util.c	(revision 7375)
+++ src/usmdb/system_support/base/usmdb_util.c	(revision 7378)
@@ -467,17 +467,17 @@ L7_RC_t usmDb64BitsToString(L7_ulong64 n
   L7_uint32 i;
   L7_ulong32 value[4], part, carry = 0;
 
 #define MAX_VALUE 4440000U
 
 
-  /* If no num */
-  if (&num == NULL)
-  {
-    return L7_FAILURE;
-  }
+///* If no num */
+//if (&num == NULL)
+//{
+//  return L7_FAILURE;
+//}
 
   /* If only a 32 bit counter */
   if (num.high == 0)
   {
     sprintf(buf, "%lu", (L7_ulong32) num.low);
     return L7_SUCCESS;
@@ -3342,13 +3342,13 @@ L7_RC_t usmDbConvertTimeTicksToDaysHours
   if(timeTicks == NULL || buf == NULL)
   {
     return L7_FAILURE;
   }
   
   memcpy (&timeInSeconds, timeTicks, sizeof (L7_uint32));
-  memset (buf, 0, sizeof (buf));
+//  memset (buf, 0, sizeof (buf)); MEDO!!!
   
   timeInSeconds = timeInSeconds / 100;  /*to get no of seconds */  
   days = timeInSeconds / 86400;
   timeInSeconds = timeInSeconds % 86400;
   hours = timeInSeconds / 3600;
   timeInSeconds = timeInSeconds % 3600;
Index: vendor/snmp/linux/src/include/osconf/linux.h
===================================================================
--- vendor/snmp/linux/src/include/osconf/linux.h	(revision 7375)
+++ vendor/snmp/linux/src/include/osconf/linux.h	(revision 7378)
@@ -44,15 +44,21 @@ extern "C" {
 
 /* MANUALLY ADDED */
 /*
  * see /usr/include/features.h for the ramifications of setting this
  * ifndef checks avoid redefinition error messages.
  */
+#if ((__GNUC__ == 4 && __GNUC_MINOR__ >= 9) || (__GNUC__ > 4)) /* PTin modified */
+#ifndef _DEFAULT_SOURCE
+ #define _DEFAULT_SOURCE
+#endif /* _DEFAULT_SOURCE */
+#else
 #ifndef _BSD_SOURCE
-#define _BSD_SOURCE
+ #define _BSD_SOURCE
 #endif /* _BSD_SOURCE */
+#endif
 
 #ifndef _POSIX_SOURCE
 #define _POSIX_SOURCE
 #endif /* _POSIX_SOURCE */
 
 /* Define if on AIX 3.
