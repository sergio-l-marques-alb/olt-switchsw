Index: src/application/qos/diffserv/base/diffserv_distiller.c
===================================================================
--- src/application/qos/diffserv/base/diffserv_distiller.c	(revision 7772)
+++ src/application/qos/diffserv/base/diffserv_distiller.c	(revision 7778)
@@ -1737,22 +1737,22 @@ L7_RC_t dsDistillerCtrlShow(void)
                  "\n\nDiffServ Distiller Ctrl Struct does not exist.\n");
     return L7_FAILURE;
   }
 
 
   DIFFSERV_PRT(msgLvlReqd,
-               "\nDisplaying Distiller Ctrl struct from location 0x%8.8x:\n",
-               (L7_uint32)p);
+               "\nDisplaying Distiller Ctrl struct from location 0x%llx:\n",
+               PTR_TO_UINT64(p));
 
   /* general fields */
   DIFFSERV_PRT(msgLvlReqd,
-               "  Service intf OLL tree anchor: 0x%8.8x:\n",
-               (L7_uint32)p->pOLL);
+               "  Service intf OLL tree anchor: 0x%llx:\n",
+               PTR_TO_UINT64(p->pOLL));
   DIFFSERV_PRT(msgLvlReqd,
-               "  OLL mutex semaphore id      : 0x%8.8x:\n",
-               (L7_uint32)p->ollSemId);
+               "  OLL mutex semaphore id      : 0x%llx:\n",
+               PTR_TO_UINT64(p->ollSemId));
   DIFFSERV_PRT(msgLvlReqd,
                "  TLV block handle            : 0x%8.8x:\n",
                (L7_uint32)p->tlvHandle);
 
   /* policy information */
   for (i = 1; i <= L7_DIFFSERV_POLICY_LIM; i++)
Index: src/application/qos/diffserv/base/diffserv_callback.c
===================================================================
--- src/application/qos/diffserv/base/diffserv_callback.c	(revision 7772)
+++ src/application/qos/diffserv/base/diffserv_callback.c	(revision 7778)
@@ -138,14 +138,14 @@ void diffServCallbackFini(void)
 
     if (pDiffServCallbackInfo_g->semId != L7_NULLPTR)
     {
       if (osapiSemaDelete(pDiffServCallbackInfo_g->semId) != L7_SUCCESS)
       {
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-                "%s: Error freeing callback table semaphore (0x%8.8x)\n",
-                __FUNCTION__, (L7_uint32)pDiffServCallbackInfo_g->semId);
+                "%s: Error freeing callback table semaphore (%p)\n",
+                __FUNCTION__, pDiffServCallbackInfo_g->semId);
       }
     }
 
     osapiFree(L7_FLEX_QOS_DIFFSERV_COMPONENT_ID, pDiffServCallbackInfo_g);
     pDiffServCallbackInfo_g = L7_NULLPTR;
   }
@@ -503,14 +503,14 @@ static L7_RC_t dsCommonCallbackTableShow
 
       if (cnfgrApiComponentMnemonicGet(pCbEntry->compId, compIdStr) != L7_SUCCESS)
       {
         osapiSnprintf(compIdStr, sizeof(compIdStr), "<unknown>");
       }
       DIFFSERV_PRT(msgLvlReqd,
-              " [%2u] funcPtr=0x%8.8x comp=%-*s descr=%s\n",
-              i, (L7_uint32)pCbEntry->funcPtr, sizeof(compIdStr), compIdStr, pCbEntry->displayStr);
+              " [%2u] funcPtr=0x%llx comp=%-*s descr=%s\n",
+              i, PTR_TO_UINT64(pCbEntry->funcPtr), sizeof(compIdStr), compIdStr, pCbEntry->displayStr);
     }
   } /* endfor */
 
   DIFFSERV_PRT(msgLvlReqd, "\n");
 
   DIFFSERV_SEMA_GIVE(pDiffServCallbackInfo_g->semId);
Index: src/application/qos/diffserv/base/diffserv_util.c
===================================================================
--- src/application/qos/diffserv/base/diffserv_util.c	(revision 7772)
+++ src/application/qos/diffserv/base/diffserv_util.c	(revision 7778)
@@ -179,14 +179,14 @@ void diffServSemaTake(void *semId, L7_in
   L7_RC_t       rc;
 
   if ((rc = osapiSemaTake(semId, timeout)) != L7_SUCCESS)
   {
     l7utilsFilenameStrip(&file);
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "Semaphore take failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)semId);
+            "Semaphore take failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, semId);
   }
 }
 
 /**************************************************************************
 * @purpose  Give a semaphore
 *
@@ -208,14 +208,14 @@ void diffServSemaGive(void *semId, char
   L7_RC_t       rc;
 
   if ((rc = osapiSemaGive(semId)) != L7_SUCCESS)
   {
     l7utilsFilenameStrip(&file);
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-            "Semaphore give failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)semId);
+            "Semaphore give failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, semId);
   }
 }
 
 /*********************************************************************
 * @purpose  Show the DiffServ feature support list for this platform
 *
Index: src/application/qos/diffserv/base/diffserv_distiller_tlv.c
===================================================================
--- src/application/qos/diffserv/base/diffserv_distiller_tlv.c	(revision 7772)
+++ src/application/qos/diffserv/base/diffserv_distiller_tlv.c	(revision 7778)
@@ -873,14 +873,13 @@ L7_RC_t dsDstlTlvPolicyDel(L7_uint32 pol
 
         else
         {
           /* intf node pointer changed from value we started with */
           L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
                   "dsDstlTlvPolicyDel:  Intf node ptr changed unexpectedly "
-                  "from 0x%8.8x to 0x%8.8x\n", (L7_uint32)pNode,
-                  (L7_uint32)pNodeCheck);
+                  "from %p to %p\n", pNode, pNodeCheck);
           rc = L7_FAILURE;
         }
 
         DIFFSERV_SEMA_GIVE(pDsDstlCtrl->ollSemId);
 
       } /* endif TLV successfully built */
@@ -3599,19 +3598,19 @@ L7_RC_t dsDstlTlvParse(L7_tlv_t *pTlv, L
       (pDiffServInfo_g->diffServMsgLvl < msgLvlReqd))
     return L7_SUCCESS;
 
   /* print a title line */
   if (intIfNum != 0)
   {
-    DIFFSERV_PRT(msgLvlReqd, "\nParsing TLV at location 0x%8.8x (intf %u):\n\n",
-                 (L7_uint32)pTlv, intIfNum);
+    DIFFSERV_PRT(msgLvlReqd, "\nParsing TLV at location 0x%llx (intf %u):\n\n",
+                 PTR_TO_UINT64(pTlv), intIfNum);
   }
   else
   {
-    DIFFSERV_PRT(msgLvlReqd, "\nParsing TLV at location 0x%8.8x:\n\n",
-                 (L7_uint32)pTlv);
+    DIFFSERV_PRT(msgLvlReqd, "\nParsing TLV at location 0x%llx:\n\n",
+                 PTR_TO_UINT64(pTlv));
   }
 
   /* use the TLV utility to traverse the TLV
    * (it uses our designated show function to display the TLV contents)
    */
   if (tlvParse(pTlv, dsDstlTlvEntryDisplay) != L7_SUCCESS)
Index: src/application/qos/diffserv/base/diffserv_cluster.c
===================================================================
--- src/application/qos/diffserv/base/diffserv_cluster.c	(revision 7772)
+++ src/application/qos/diffserv/base/diffserv_cluster.c	(revision 7778)
@@ -48,13 +48,13 @@ static L7_BOOL          dsClusterRxCfgMs
 static dsClusterMsgIe_t dsClusterRxCfgIeExpected  = DS_CLUSTER_MSG_IE_NONE; /* next expected IE in a defined sequence */
 
 /* copy of data received from cluster member switch */
 static L7_BOOL  dsClusterRxInProg   = L7_FALSE; /* indicates Rx operation currently in progress */
 static L7_BOOL  dsClusterRxError    = L7_FALSE; /* indicates unrecoverable error receiving, drop remaining messages */
 
-static L7_int32 dsClusterTaskId     = L7_ERROR;
+static L7_uint64 dsClusterTaskId    = L7_ERROR;
 static void     *dsClusterQueue     = L7_NULLPTR;
 static L7_BOOL  dsClusterDebug      = L7_FALSE;
 
 static L7_COMPONENT_IDS_t dsCompId  = L7_FLEX_QOS_DIFFSERV_COMPONENT_ID;
 
 static dsClusterTableParms_t dsClusterTableParms[DSMIB_TABLE_ID_TOTAL] =
@@ -477,13 +477,13 @@ L7_RC_t diffServClusterDebugShow(void)
   sysapiPrintf("  dsClusterTmpCfg          = %p\n",      dsClusterTmpCfg);
   sysapiPrintf("  dsClusterRxCfgMsgStarted = %d\n",      dsClusterRxCfgMsgStarted);
   sysapiPrintf("  dsClusterRxCfgIeExpected = 0x%4.4x\n", dsClusterRxCfgIeExpected);
   sysapiPrintf("  dsClusterRxInProg        = %d\n",      dsClusterRxInProg);
   sysapiPrintf("  dsClusterRxError         = %d\n",      dsClusterRxError);
   sysapiPrintf("  dsClusterTaskId          = 0x%x\n",    dsClusterTaskId);
-  sysapiPrintf("  dsClusterQueue           = 0x%x\n",    (L7_uint32)dsClusterQueue);
+  sysapiPrintf("  dsClusterQueue           = %p\n",      dsClusterQueue);
   sysapiPrintf("  dsClusterDebug           = %d\n",      dsClusterDebug);
   sysapiPrintf("\n");
   return L7_SUCCESS;
 }
 
 /*********************************************************************
Index: src/application/qos/diffserv/stdmib/diffserv_stdmib.c
===================================================================
--- src/application/qos/diffserv/stdmib/diffserv_stdmib.c	(revision 7772)
+++ src/application/qos/diffserv/stdmib/diffserv_stdmib.c	(revision 7778)
@@ -95,14 +95,14 @@ void diffServStandardMibFini(void)
   /* delete the semaphore for all standard MIB tables */
   if (dsStdMibSemId != L7_NULLPTR)
   {
     if (osapiSemaDelete(dsStdMibSemId) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-              "%s: Error freeing standard MIB index table semaphore (0x%8.8x)\n",
-              __FUNCTION__, (L7_uint32)dsStdMibSemId);
+              "%s: Error freeing standard MIB index table semaphore (%p)\n",
+              __FUNCTION__, dsStdMibSemId);
     }
   }
 }
 
 /*********************************************************************
 * @purpose  Reset all DiffServ standard MIB contents to initial state
@@ -2668,14 +2668,14 @@ void dsStdMibAvlCtrlShow(void)
     allocBytes = (treeHeapElemSize + pCtrl->entrySize) * pCtrl->entryMaxNum;
     totalBytes += allocBytes;
 
     DIFFSERV_PRT(msgLvlReqd, "\n%s Table:\n", dsmibStdTableIdStr[i]);
     DIFFSERV_PRT(msgLvlReqd, "  maxEnt=%u entSize=%u keySize=%u ",
                  pCtrl->entryMaxNum, pCtrl->entrySize, pCtrl->entryKeySize);
-    DIFFSERV_PRT(msgLvlReqd, "pTreeHeap=0x%8.8x pDataHeap=0x%8.8x ",
-                 (L7_uint32)pCtrl->pTreeHeap, (L7_uint32)pCtrl->pDataHeap);
+    DIFFSERV_PRT(msgLvlReqd, "pTreeHeap=0x%llx pDataHeap=0x%llx ",
+                 PTR_TO_UINT64(pCtrl->pTreeHeap), PTR_TO_UINT64(pCtrl->pDataHeap));
     DIFFSERV_PRT(msgLvlReqd, "allocBytes=%u\n", allocBytes);
   }
   DIFFSERV_PRT(msgLvlReqd, "\nTotal standard MIB AVL resource byte allocation:  %u\n\n", totalBytes);
 }
 
 /*********************************************************************
Index: src/application/qos/diffserv/stdmib/diffserv_dropper_api.c
===================================================================
--- src/application/qos/diffserv/stdmib/diffserv_dropper_api.c	(revision 7772)
+++ src/application/qos/diffserv/stdmib/diffserv_dropper_api.c	(revision 7778)
@@ -281,13 +281,13 @@ L7_RC_t diffServAlgDropCreate(L7_uint32
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             algDropId, 0, 0,
-                            (L7_uint32)pAlgDropRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pAlgDropRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -363,13 +363,13 @@ L7_RC_t diffServAlgDropDelete(dsStdMibRo
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             algDropId, 0, 0,
-                            (L7_uint32)pAlgDropRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pAlgDropRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
 
 /*********************************************************************
Index: src/application/qos/diffserv/stdmib/diffserv_meter_api.c
===================================================================
--- src/application/qos/diffserv/stdmib/diffserv_meter_api.c	(revision 7772)
+++ src/application/qos/diffserv/stdmib/diffserv_meter_api.c	(revision 7778)
@@ -269,13 +269,13 @@ L7_RC_t diffServMeterCreate(dsStdMibRowP
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             meterId, 0, 0,
-                            (L7_uint32)pMeterRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pMeterRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -348,13 +348,13 @@ L7_RC_t diffServMeterDelete(dsStdMibRowP
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             meterId, 0, 0,
-                            (L7_uint32)pMeterRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pMeterRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
 
 /*********************************************************************
@@ -802,13 +802,13 @@ L7_RC_t diffServTBParamCreate(L7_uint32
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             tbParamId, 0, 0,
-                            (L7_uint32)pTBParamRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pTBParamRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -861,13 +861,13 @@ L7_RC_t diffServTBParamDelete(L7_uint32
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             tbParamId, 0, 0,
-                            (L7_uint32)pTBParamRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pTBParamRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
 
 /*********************************************************************
@@ -1277,13 +1277,13 @@ L7_RC_t diffServColorAwareCreate(L7_uint
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             meterId, 0, 0,
-                            (L7_uint32)pMeterRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pMeterRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -1336,13 +1336,13 @@ L7_RC_t diffServColorAwareDelete(L7_uint
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             meterId, 0, 0,                                                
-                            (L7_uint32)pRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
                                                                             
 /*********************************************************************
Index: src/application/qos/diffserv/stdmib/diffserv_action_api.c
===================================================================
--- src/application/qos/diffserv/stdmib/diffserv_action_api.c	(revision 7772)
+++ src/application/qos/diffserv/stdmib/diffserv_action_api.c	(revision 7778)
@@ -280,13 +280,13 @@ L7_RC_t diffServActionCreate(L7_uint32
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             actionId, 0, 0,
-                            (L7_uint32)pActionRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pActionRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -356,13 +356,13 @@ L7_RC_t diffServActionDelete(dsStdMibRow
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             actionId, 0, 0,
-                            (L7_uint32)pActionRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pActionRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
   
 /*********************************************************************
@@ -1169,13 +1169,13 @@ L7_RC_t diffServCountActCreate(L7_uint32
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             countActId, 0, 0,
-                            (L7_uint32)pCountActRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pCountActRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -1228,13 +1228,13 @@ L7_RC_t diffServCountActDelete(L7_uint32
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             countActId, 0, 0,                                                
-                            (L7_uint32)pRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
                                                                             
 /*********************************************************************
@@ -1637,13 +1637,13 @@ L7_RC_t diffServAssignQueueCreate(L7_uin
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             assignId, 0, 0,
-                            (L7_uint32)pAssignRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pAssignRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -1696,13 +1696,13 @@ L7_RC_t diffServAssignQueueDelete(L7_uin
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             assignId, 0, 0,                                                
-                            (L7_uint32)pRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
                                                                             
 /*********************************************************************
@@ -2078,13 +2078,13 @@ L7_RC_t diffServRedirectCreate(L7_uint32
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             redirectId, 0, 0,
-                            (L7_uint32)pRedirectRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pRedirectRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -2137,13 +2137,13 @@ L7_RC_t diffServRedirectDelete(L7_uint32
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             redirectId, 0, 0,                                                
-                            (L7_uint32)pRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
                                                                             
 /*********************************************************************
@@ -2518,13 +2518,13 @@ L7_RC_t diffServMirrorCreate(L7_uint32 p
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             mirrorId, 0, 0,
-                            (L7_uint32)pMirrorRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pMirrorRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -2577,13 +2577,13 @@ L7_RC_t diffServMirrorDelete(L7_uint32 m
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             mirrorId, 0, 0,                                                
-                            (L7_uint32)pRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
                                                                             
 /*********************************************************************
Index: src/application/qos/diffserv/stdmib/diffserv_clfr_api.c
===================================================================
--- src/application/qos/diffserv/stdmib/diffserv_clfr_api.c	(revision 7772)
+++ src/application/qos/diffserv/stdmib/diffserv_clfr_api.c	(revision 7778)
@@ -480,13 +480,13 @@ L7_RC_t diffServClfrCreate(dsStdMibRowPt
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             clfrId, 0, 0,
-                            (L7_uint32)pClfrRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pClfrRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -551,13 +551,13 @@ L7_RC_t diffServClfrDelete(dsStdMibRowPt
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             clfrId, 0, 0,
-                            (L7_uint32)pClfrRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pClfrRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
 
 
@@ -941,13 +941,13 @@ L7_RC_t diffServClfrElemCreate(L7_uint32
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             clfrId, clfrElemId, 0,
-                            (L7_uint32)pClfrElemRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pClfrElemRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -1023,13 +1023,13 @@ L7_RC_t diffServClfrElemDelete(dsStdMibR
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             clfrId, clfrElemId, 0,
-                            (L7_uint32)pClfrElemRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pClfrElemRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
  
 /********************************************************************* 
@@ -1740,13 +1740,13 @@ L7_RC_t diffServAuxMFClfrCreate(dsStdMib
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             auxMFClfrId, 0, 0,
-                            (L7_uint32)pAuxMFClfrRow, (L7_uchar8)rc,
+                            PTR_TO_UINT32(pAuxMFClfrRow), (L7_uchar8)rc,
                             (L7_uchar8)L7_TRUE);
   }
 
   return rc;
 }
 
@@ -1813,13 +1813,13 @@ L7_RC_t diffServAuxMFClfrDelete(L7_uint3
   } while (0);
 
   if (DS_TRACE_MODE_ENHANCED() == L7_TRUE)
   {
     DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_STDMIB, (L7_uchar8)tableId, 
                             auxMFClfrId, 0, 0,
-                            (L7_uint32)pAuxMFClfrRow, (L7_uchar8)rc);
+                            PTR_TO_UINT32(pAuxMFClfrRow), (L7_uchar8)rc);
   }
 
   return rc;
 }
 
 /*********************************************************************
Index: src/application/qos/diffserv/prvtmib/diffserv_policyattr_api.c
===================================================================
--- src/application/qos/diffserv/prvtmib/diffserv_policyattr_api.c	(revision 7772)
+++ src/application/qos/diffserv/prvtmib/diffserv_policyattr_api.c	(revision 7778)
@@ -301,13 +301,13 @@ L7_RC_t diffServPolicyAttrCreate(L7_uint
   /* make sure change gets picked up when config is saved */
   if (dataChanged == L7_TRUE)
     pDiffServCfgData_g->cfgHdr.dataChanged = L7_TRUE;
 
   DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           policyIndex, policyInstIndex, policyAttrIndex,
-                          (L7_uint32)pRow, (L7_uchar8)rc,
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc,
                           (L7_uchar8)activateRow);
 
   return rc;
 }
 
 /*************************************************************************
@@ -592,13 +592,13 @@ L7_RC_t dsmibPolicyAttrDelete(L7_uint32
      */
     diffServChangeNotify(policyIndex, DIFFSERV_EVENT_MODIFY, L7_NULLPTR);
   }
 
   DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           policyIndex, policyInstIndex, policyAttrIndex,
-                          (L7_uint32)pRow, (L7_uchar8)rc);
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc);
 
   return rc;
 }
 
 /*********************************************************************
 * @purpose  Verify that a Policy Attribute Table row exists for the
Index: src/application/qos/diffserv/prvtmib/diffserv_prvtmib.c
===================================================================
--- src/application/qos/diffserv/prvtmib/diffserv_prvtmib.c	(revision 7772)
+++ src/application/qos/diffserv/prvtmib/diffserv_prvtmib.c	(revision 7778)
@@ -120,14 +120,14 @@ void diffServPrivateMibFini(void)
 
   if (dsmibIndexSemId != L7_NULLPTR)
   {
     if (osapiSemaDelete(dsmibIndexSemId) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
-              "%s: Error freeing MIB index table semaphore (0x%8.8x)\n",
-              __FUNCTION__, (L7_uint32)dsmibIndexSemId);
+              "%s: Error freeing MIB index table semaphore (%p)\n",
+              __FUNCTION__, dsmibIndexSemId);
     }
     dsmibIndexSemId = L7_NULLPTR;
   }
 }
 
 
@@ -1103,14 +1103,14 @@ void dsmibAvlCtrlShow(void)
     allocBytes = (treeHeapElemSize + pCtrl->entrySize) * pCtrl->entryMaxNum;
     totalBytes += allocBytes;
 
     DIFFSERV_PRT(msgLvlReqd, "\n%s Table:\n", dsmibPrvtTableIdStr[i]);
     DIFFSERV_PRT(msgLvlReqd, "  maxEnt=%u entSize=%u keySize=%u ",
                  pCtrl->entryMaxNum, pCtrl->entrySize, pCtrl->entryKeySize);
-    DIFFSERV_PRT(msgLvlReqd, "pTreeHeap=0x%8.8x pDataHeap=0x%8.8x ",
-                 (L7_uint32)pCtrl->pTreeHeap, (L7_uint32)pCtrl->pDataHeap);
+    DIFFSERV_PRT(msgLvlReqd, "pTreeHeap=0x%llx pDataHeap=0x%llx ",
+                 PTR_TO_UINT64(pCtrl->pTreeHeap), PTR_TO_UINT64(pCtrl->pDataHeap));
     DIFFSERV_PRT(msgLvlReqd, "allocBytes=%u\n", allocBytes);
   }
   DIFFSERV_PRT(msgLvlReqd, "\nTotal private MIB AVL resource byte allocation:  %u\n\n", totalBytes);
 }
 
 /*********************************************************************
Index: src/application/qos/diffserv/prvtmib/diffserv_policyperf_api.c
===================================================================
--- src/application/qos/diffserv/prvtmib/diffserv_policyperf_api.c	(revision 7772)
+++ src/application/qos/diffserv/prvtmib/diffserv_policyperf_api.c	(revision 7778)
@@ -762,13 +762,13 @@ L7_RC_t dsmibPolicyPerfInCreate(L7_uint3
     }
 
   } while (0);
 
   DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           policyIndex, policyInstIndex, intIfNum,
-                          (L7_uint32)pRow, (L7_uchar8)rc,
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc,
                           (L7_uchar8)activateRow);
 
   return rc;
 }
 
 /*************************************************************************
@@ -864,13 +864,13 @@ L7_RC_t dsmibPolicyPerfInDelete(L7_uint3
     DIFFSERV_SEMA_GIVE(dsmibIndexSemId);
 
   } while (0);
 
   DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           policyIndex, policyInstIndex, intIfNum,
-                          (L7_uint32)pRow, (L7_uchar8)rc);
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc);
 
   return rc;
 }
 
 /*********************************************************************
 * @purpose  Obtain pointer to specified Policy-Class Inbound Performance
@@ -1121,13 +1121,13 @@ L7_RC_t dsmibPolicyPerfOutCreate(L7_uint
     }
 
   } while (0);
 
   DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           policyIndex, policyInstIndex, intIfNum,
-                          (L7_uint32)pRow, (L7_uchar8)rc,
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc,
                           (L7_uchar8)activateRow);
 
   return rc;
 }
 
 /*************************************************************************
@@ -1223,13 +1223,13 @@ L7_RC_t dsmibPolicyPerfOutDelete(L7_uint
     DIFFSERV_SEMA_GIVE(dsmibIndexSemId);
 
   } while (0);
 
   DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           policyIndex, policyInstIndex, intIfNum,
-                          (L7_uint32)pRow, (L7_uchar8)rc);
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc);
 
   return rc;
 }
 
 /*********************************************************************
 * @purpose  Obtain pointer to specified Policy-Class Outbound Performance
Index: src/application/qos/diffserv/prvtmib/diffserv_classrule_api.c
===================================================================
--- src/application/qos/diffserv/prvtmib/diffserv_classrule_api.c	(revision 7772)
+++ src/application/qos/diffserv/prvtmib/diffserv_classrule_api.c	(revision 7778)
@@ -303,13 +303,13 @@ L7_RC_t diffServClassRuleCreate(L7_uint3
   /* make sure change gets picked up when config is saved */
   if (dataChanged == L7_TRUE)
     pDiffServCfgData_g->cfgHdr.dataChanged = L7_TRUE;
 
   DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           classIndex, classRuleIndex, 0,
-                          (L7_uint32)pRow, (L7_uchar8)rc,
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc,
                           (L7_uchar8)activateRow);
 
   return rc;
 }
 
 /*************************************************************************
@@ -598,13 +598,13 @@ L7_RC_t dsmibClassRuleDelete(L7_uint32 c
     /* send callbacks for all policies that reference the affected class */
     dsmibClassRulePolicyChangeNotify(classIndex);
   }
 
   DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           classIndex, classRuleIndex, 0,
-                          (L7_uint32)pRow, (L7_uchar8)rc);
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc);
 
   return rc;
 }
 
 /*********************************************************************
 * @purpose  Verify that a Class Rule Table row exists for the specified indexes
Index: src/application/qos/diffserv/prvtmib/diffserv_policyinst_api.c
===================================================================
--- src/application/qos/diffserv/prvtmib/diffserv_policyinst_api.c	(revision 7772)
+++ src/application/qos/diffserv/prvtmib/diffserv_policyinst_api.c	(revision 7778)
@@ -311,13 +311,13 @@ L7_RC_t diffServPolicyInstCreate(L7_uint
   /* make sure change gets picked up when config is saved */
   if (dataChanged == L7_TRUE)
     pDiffServCfgData_g->cfgHdr.dataChanged = L7_TRUE;
 
   DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           policyIndex, policyInstIndex, 0,
-                          (L7_uint32)pRow, (L7_uchar8)rc,
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc,
                           (L7_uchar8)activateRow);
 
   return rc;
 }
 
 /*************************************************************************
@@ -612,13 +612,13 @@ L7_RC_t dsmibPolicyInstDelete(L7_uint32
      */
     diffServChangeNotify(policyIndex, DIFFSERV_EVENT_MODIFY, L7_NULLPTR);
   }
 
   DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           policyIndex, policyInstIndex, 0,
-                          (L7_uint32)pRow, (L7_uchar8)rc);
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc);
 
   return rc;
 }
 
 /*********************************************************************
 * @purpose  Verify that a Policy-Class Instance Table row exists for the
Index: src/application/qos/diffserv/prvtmib/diffserv_policy_api.c
===================================================================
--- src/application/qos/diffserv/prvtmib/diffserv_policy_api.c	(revision 7772)
+++ src/application/qos/diffserv/prvtmib/diffserv_policy_api.c	(revision 7778)
@@ -266,13 +266,13 @@ L7_RC_t diffServPolicyCreate(L7_uint32 p
   /* NOTE: Not sending notify event callbacks here since policy does not
    *       contain any meaningful instance definition yet.
    */
 
   DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           policyIndex, 0, 0,
-                          (L7_uint32)pRow, (L7_uchar8)rc,
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc,
                           (L7_uchar8)activateRow);
 
   return rc;
 }
 
 /*************************************************************************
@@ -424,13 +424,13 @@ L7_RC_t diffServPolicyDelete(L7_uint32 p
     /* send notify event callbacks for this policy */
     diffServDeleteNotify(policyIndex, policyType, policyName);
   }
 
   DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           policyIndex, 0, 0,
-                          (L7_uint32)pRow, (L7_uchar8)rc);
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc);
 
   return rc;
 }
 
 /*********************************************************************
 * @purpose  Verify that a Policy Table row exists for the specified index
Index: src/application/qos/diffserv/prvtmib/diffserv_service_api.c
===================================================================
--- src/application/qos/diffserv/prvtmib/diffserv_service_api.c	(revision 7772)
+++ src/application/qos/diffserv/prvtmib/diffserv_service_api.c	(revision 7778)
@@ -201,13 +201,13 @@ L7_RC_t diffServServiceCreate(L7_uint32
   /* make sure change gets picked up when config is saved */
   if (dataChanged == L7_TRUE)
     pDiffServCfgData_g->cfgHdr.dataChanged = L7_TRUE;
 
   DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           intIfNum, ifDirection, 0,
-                          (L7_uint32)pRow, (L7_uchar8)rc,
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc,
                           (L7_uchar8)activateRow);
 
   return rc;
 }
 
 /*************************************************************************
@@ -340,13 +340,13 @@ L7_RC_t diffServServiceDelete(L7_uint32
     DIFFSERV_SEMA_GIVE(dsmibIndexSemId);
 
   } while (0);
 
   DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           intIfNum, ifDirection, 0,
-                          (L7_uint32)pRow, (L7_uchar8)rc);
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc);
 
   return rc;
 }
 
 /*********************************************************************
 * @purpose  Verify that a Service Table row exists for the specified
Index: src/application/qos/diffserv/prvtmib/diffserv_class_api.c
===================================================================
--- src/application/qos/diffserv/prvtmib/diffserv_class_api.c	(revision 7772)
+++ src/application/qos/diffserv/prvtmib/diffserv_class_api.c	(revision 7778)
@@ -262,13 +262,13 @@ L7_RC_t diffServClassCreate(L7_uint32 cl
   /* make sure change gets picked up when config is saved */
   if (dataChanged == L7_TRUE)
     pDiffServCfgData_g->cfgHdr.dataChanged = L7_TRUE;
 
   DS_TRACE_PT_CREATE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           classIndex, 0, 0,
-                          (L7_uint32)pRow, (L7_uchar8)rc,
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc,
                           (L7_uchar8)activateRow);
 
   return rc;
 }
 
 /*************************************************************************
@@ -409,13 +409,13 @@ L7_RC_t diffServClassDelete(L7_uint32 cl
     DIFFSERV_SEMA_GIVE(dsmibIndexSemId);
 
   } while (0);
 
   DS_TRACE_PT_DELETE_EXIT(DS_TRACE_SUBID_PRVTMIB, (L7_uchar8)tableId,
                           classIndex, 0, 0,
-                          (L7_uint32)pRow, (L7_uchar8)rc);
+                          PTR_TO_UINT32(pRow), (L7_uchar8)rc);
 
   return rc;
 }
 
 /*********************************************************************
 * @purpose  Verify that a Class Table row exists for the specified index
Index: src/application/qos/iscsi/core/iscsi_cnfgr.c
===================================================================
--- src/application/qos/iscsi/core/iscsi_cnfgr.c	(revision 7772)
+++ src/application/qos/iscsi/core/iscsi_cnfgr.c	(revision 7778)
@@ -34,13 +34,13 @@
 #include "cli_txt_cfg_api.h"
 #endif
 
 /* externs */
 extern iscsiCfgData_t      *iscsiCfgData;
 extern void                *iscsiQueue;
-extern L7_uint32            iscsiTaskId;
+extern L7_uint64            iscsiTaskId;
 extern L7_uint32            iscsiPacketBufferPoolId;
 extern osapiRWLock_t        iscsiCfgRWLock;
 
 /* global variables */
 iscsiCnfgrState_t           iscsiCnfgrState_g = ISCSI_PHASE_INIT_0;
 L7_BOOL                     iscsiWarmStart;
Index: src/application/qos/iscsi/core/iscsi.c
===================================================================
--- src/application/qos/iscsi/core/iscsi.c	(revision 7772)
+++ src/application/qos/iscsi/core/iscsi.c	(revision 7778)
@@ -35,13 +35,13 @@
 #include "iscsi_ckpt.h"
 #endif
 
 extern iscsiCfgData_t  *iscsiCfgData;
 
 void                   *iscsiQueue        = L7_NULLPTR;
-L7_int32                iscsiTaskId;
+L7_uint64               iscsiTaskId;
 static void            *iscsiSema         = L7_NULL;
 L7_uint32               iscsiDebug = ISCSI_TRACE_ALWAYS_ON;
 
 void iscsiImpConnectionDelete(L7_uint32 connectionId);
 void iscsiImpSessionDelete(L7_uint32 sessionId);
 
Index: src/application/qos/iscsi/core/iscsi_control.c
===================================================================
--- src/application/qos/iscsi/core/iscsi_control.c	(revision 7772)
+++ src/application/qos/iscsi/core/iscsi_control.c	(revision 7778)
@@ -29,13 +29,13 @@
 #include "iscsi_api.h"
 #include "iscsi_sid.h"
 #include "iscsi_packet.h"
 #include "dtl_iscsi.h"
 
 extern void            *iscsiQueue;
-extern L7_int32         iscsiTaskId;
+extern L7_uint64        iscsiTaskId;
 
 L7_int32                  iscsiPacketBufferPoolId;
 static osapiTimerDescr_t *iscsiTimer         = L7_NULLPTR;
 static L7_uint32          iscsiIdleTimeMsecs = ISCSI_IDLE_TIMEOUT;
 
 extern void iscsiImpSessionDelete(L7_uint32 sessionId);
Index: src/application/qos/voip/core/voip_control.c
===================================================================
--- src/application/qos/voip/core/voip_control.c	(revision 7772)
+++ src/application/qos/voip/core/voip_control.c	(revision 7778)
@@ -37,13 +37,13 @@
 #include "osapi_support.h"
 #include "voip_control.h"
 #include "voip_exports.h"
 #include "dtl_voip.h"
 
 void                   *voipQueue        = L7_NULLPTR;
-L7_int32                voipTaskId;
+L7_uint64               voipTaskId;
 
 #define VOIP_TIMER_INTERVAL   1000*60*3  /* wake up every 3 minutes (idle timeout) when there are pending requests */
 #define VOIP_CALL_IDLE_TIMEOUT  VOIP_TIMER_INTERVAL
 /* use one timer that wakes up every second, maintain a
    a reference count and delete the timer when we have no pending sessions */
 static osapiTimerDescr_t *voipTimer       = L7_NULLPTR;
Index: src/application/qos/voip/core/voip_cnfgr.c
===================================================================
--- src/application/qos/voip/core/voip_cnfgr.c	(revision 7772)
+++ src/application/qos/voip/core/voip_cnfgr.c	(revision 7778)
@@ -38,13 +38,13 @@
 #endif
 
 /* externs */
 extern voipCfgData_t       *voipCfgData;
 extern L7_uint32           *voipMapTbl;
 extern void                *voipQueue;
-extern L7_int32             voipTaskId;
+extern L7_uint64            voipTaskId;
 extern osapiRWLock_t        voipCfgRWLock;
 extern voipIntfInfo_t      *voipIntfInfo;
 L7_uint32                  voipTimerTaskId;
 
 L7_BOOL                 voipWarmStart;
 extern PORTEVENT_MASK_t voipPortEventMask_g;
Index: src/application/qos/acl/acl_migrate.c
===================================================================
--- src/application/qos/acl/acl_migrate.c	(revision 7772)
+++ src/application/qos/acl/acl_migrate.c	(revision 7778)
@@ -355,18 +355,18 @@ aclMigrateConfigData(L7_uint32 oldVer, L
           (sizeof(pCfgCur->cfgParms.aclMsgLvl) != sizeof(pCfgV6->cfgParms.aclMsgLvl)))
       {
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID,
                 "Configuration structure size mismatch.  Building default configuration.\n " \
                       "sizeof(pCfgCur->cfgParms.aclIntfCfgData) = %u, sizeof(pCfgV6->cfgParms.aclIntfCfgData) = %u\n" \
                       "sizeof(pCfgCur->cfgParms.aclVlanCfgData) = %u, sizeof(pCfgV6->cfgParms.aclVlanCfgData) = %u\n",
-                      sizeof(pCfgCur->cfgParms.aclIntfCfgData), sizeof(pCfgV6->cfgParms.aclIntfCfgData),
-                      sizeof(pCfgCur->cfgParms.aclVlanCfgData), sizeof(pCfgV6->cfgParms.aclVlanCfgData));
+                      (L7_uint32) sizeof(pCfgCur->cfgParms.aclIntfCfgData), (L7_uint32) sizeof(pCfgV6->cfgParms.aclIntfCfgData),
+                      (L7_uint32) sizeof(pCfgCur->cfgParms.aclVlanCfgData), (L7_uint32) sizeof(pCfgV6->cfgParms.aclVlanCfgData));
 #ifdef PROD_USE_BINARY_CONFIGURATION
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID,
                 "sizeof(pCfgCur->cfgParms.aclData) = %u, sizeof(pCfgV6->cfgParms.aclData) = %u\n",
-                      sizeof(pCfgCur->cfgParms.aclData), sizeof(pCfgV6->cfgParms.aclData));
+                      (L7_uint32) sizeof(pCfgCur->cfgParms.aclData), (L7_uint32) sizeof(pCfgV6->cfgParms.aclData));
 #endif
         buildDefault = L7_TRUE;
       }
       else
       {
 #ifdef PROD_USE_BINARY_CONFIGURATION
Index: src/application/qos/acl/acl_api.c
===================================================================
--- src/application/qos/acl/acl_api.c	(revision 7772)
+++ src/application/qos/acl/acl_api.c	(revision 7778)
@@ -5449,14 +5449,14 @@ static L7_RC_t aclCommonCallbackTableSho
 
       if (cnfgrApiComponentMnemonicGet(pCbEntry->compId, compIdStr) != L7_SUCCESS)
       {
         osapiSnprintf(compIdStr, sizeof(compIdStr), "<unknown>");
       }
       ACL_PRT(msgLvlReqd,
-              " [%2u] funcPtr=0x%8.8x comp=%-*s descr=%s\n",
-              i, (L7_uint32)pCbEntry->funcPtr, sizeof(compIdStr), compIdStr, pCbEntry->displayStr);
+              " [%2u] funcPtr=0x%llx comp=%-*s descr=%s\n",
+              i, PTR_TO_UINT64(pCbEntry->funcPtr), sizeof(compIdStr), compIdStr, pCbEntry->displayStr);
     }
   } /* endfor */
 
   ACL_PRT(msgLvlReqd, "\n");
 
   if (ACL_READ_LOCK_GIVE(aclRwLock) != L7_SUCCESS)
Index: src/application/qos/acl/acl_cnfgr.c
===================================================================
--- src/application/qos/acl/acl_cnfgr.c	(revision 7772)
+++ src/application/qos/acl/acl_cnfgr.c	(revision 7778)
@@ -31,14 +31,14 @@
 #include "dtlapi.h"
 #include "dtl_acl.h"
 #include "clustering_api.h"
 #include "acl_cluster.h"
 
 aclCnfgrState_t aclCnfgrState = ACL_PHASE_INIT_0;
-L7_int32        aclLogTaskId_g = L7_ERROR;      /* this is what osapi returns */
-L7_int32        aclEventTaskId_g = L7_ERROR;  /* this is what osapi returns */ 
+L7_uint64       aclLogTaskId_g = L7_ERROR;      /* this is what osapi returns */
+L7_uint64       aclEventTaskId_g = L7_ERROR;  /* this is what osapi returns */ 
 /* ACL Queue to post event notifications
  * currently this is used for time range notifications 
 */
 void            *aclEventQueue = L7_NULLPTR; 
 /* ACL Time Range Table */
 aclTRTableEntry_t *aclTimeRangeTable = L7_NULLPTR;
@@ -270,13 +270,13 @@ void aclApiCnfgrCommand(L7_CNFGR_CMD_DAT
 L7_RC_t aclCnfgrInitPhase1Process( L7_CNFGR_RESPONSE_t *pResponse,
                                    L7_CNFGR_ERR_RC_t   *pReason )
 {
   L7_RC_t aclRC;
   L7_RC_t maxIntf;
   L7_RC_t maxVlan;
-  L7_RC_t i, j, k;
+  int i, j, k;
 
   *pResponse  = L7_CNFGR_CMD_COMPLETE;
   *pReason    = 0;
   aclRC       = L7_SUCCESS;
   
   maxIntf = platIntfMaxCountGet();
Index: src/application/qos/acl/acl.c
===================================================================
--- src/application/qos/acl/acl.c	(revision 7772)
+++ src/application/qos/acl/acl.c	(revision 7778)
@@ -5871,26 +5871,26 @@ L7_RC_t aclTlvParse(L7_tlv_t *pTlv, L7_u
     return L7_SUCCESS;
 
   /* print a title line */
   if (intIfNum != 0)
   {
     ACL_PRT(msgLvlReqd,
-            "\nParsing TLV at location 0x%8.8x (intf %u, dir %u):\n\n",
-            (L7_uint32)pTlv, intIfNum, direction);
+            "\nParsing TLV at location 0x%llx (intf %u, dir %u):\n\n",
+            PTR_TO_UINT64(pTlv), intIfNum, direction);
   }
   else if (vlanId != 0)
   {
     ACL_PRT(msgLvlReqd,
-            "\nParsing TLV at location 0x%8.8x (vlan %u, dir %u):\n\n",
-            (L7_uint32)pTlv, vlanId, direction);
+            "\nParsing TLV at location 0x%llx (vlan %u, dir %u):\n\n",
+            PTR_TO_UINT64(pTlv), vlanId, direction);
   }
   else
   {
     ACL_PRT(msgLvlReqd,
-            "\nParsing TLV at location 0x%8.8x:\n\n",
-            (L7_uint32)pTlv);
+            "\nParsing TLV at location 0x%llx:\n\n",
+            PTR_TO_UINT64(pTlv));
   }
 
   /* use the TLV utility to traverse the TLV
    * (it uses our designated show function to display the TLV contents)
    */
   if (tlvParse(pTlv, aclTlvEntryDisplay) != L7_SUCCESS)
@@ -10028,14 +10028,14 @@ L7_RC_t aclSemaTake(void *semId, L7_int3
   L7_RC_t       rc;
 
   rc = osapiSemaTake(semId, timeout);
   if (rc != L7_SUCCESS)
   {
     l7utilsFilenameStrip(&file);
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Semaphore take failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)semId);
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Semaphore take failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, semId);
   }
   return rc;
 }
 
 /**************************************************************************
 * @purpose  Give an ACL semaphore
@@ -10059,14 +10059,14 @@ L7_RC_t aclSemaGive(void *semId, char *f
   L7_RC_t       rc;
 
   rc = osapiSemaGive(semId);
   if (rc != L7_SUCCESS)
   {
     l7utilsFilenameStrip(&file);
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Semaphore give failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)semId);
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Semaphore give failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, semId);
   }
   return rc;
 }
 
 /**************************************************************************
 * @purpose  Take an ACL read lock
@@ -10096,14 +10096,14 @@ L7_RC_t aclReadLockTake(osapiRWLock_t rw
   L7_RC_t       rc;
 
   rc = osapiReadLockTake(rwlock, timeout);
   if (rc != L7_SUCCESS)
   {
     l7utilsFilenameStrip(&file);
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Read lock take failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)rwlock.handle);
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Read lock take failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, rwlock.handle);
   }
   return rc;
 }
 
 /**************************************************************************
 * @purpose  Give an ACL read lock
@@ -10127,14 +10127,14 @@ L7_RC_t aclReadLockGive(osapiRWLock_t rw
   L7_RC_t       rc;
 
   rc = osapiReadLockGive(rwlock);
   if (rc != L7_SUCCESS)
   {
     l7utilsFilenameStrip(&file);
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Read lock give failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)rwlock.handle);
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Read lock give failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, rwlock.handle);
   }
   return rc;
 }
 
 /**************************************************************************
 * @purpose  Take an ACL write lock
@@ -10164,14 +10164,14 @@ L7_RC_t aclWriteLockTake(osapiRWLock_t r
   L7_RC_t       rc;
 
   rc = osapiWriteLockTake(rwlock, timeout);
   if (rc != L7_SUCCESS)
   {
     l7utilsFilenameStrip(&file);
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Write lock take failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)rwlock.handle);
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Write lock take failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, rwlock.handle);
   }
   return rc;
 }
 
 /**************************************************************************
 * @purpose  Give an ACL write lock
@@ -10195,14 +10195,14 @@ L7_RC_t aclWriteLockGive(osapiRWLock_t r
   L7_RC_t       rc;
 
   rc = osapiWriteLockGive(rwlock);
   if (rc != L7_SUCCESS)
   {
     l7utilsFilenameStrip(&file);
-    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Write lock give failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)rwlock.handle);
+    L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_ACL_COMPONENT_ID, "Write lock give failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, rwlock.handle);
   }
   return rc;
 }
 
 
 /*********************************************************************
Index: src/application/qos/acl/acl_cluster.c
===================================================================
--- src/application/qos/acl/acl_cluster.c	(revision 7772)
+++ src/application/qos/acl/acl_cluster.c	(revision 7778)
@@ -53,13 +53,13 @@ static L7_ushort16        aclRxCount = 0
 static L7_ushort16        aclMacRxCount = 0;
 static L7_uint32          aclRxRuleCount = 0;    /* total rules received to verify against L7_ACL_MAX_RULES */
 static L7_BOOL            aclRxInProg = L7_FALSE; /* indicates Rx operation currently in progress */
 static L7_BOOL            aclRxError = L7_FALSE; /* indicates unrecoverable error receiving, drop remaining messages */
 
 
-static L7_int32 aclClusterTaskId = L7_ERROR;
+static L7_uint64 aclClusterTaskId = L7_ERROR;
 static void    *aclClusterQueue  = L7_NULLPTR;
 static L7_BOOL  aclClusterDebug  = L7_FALSE;
 
 /*********************************************************************
 * @purpose  Check if room in message buffer to add IE, send and clear
 *           buffer when max message size is reached.
Index: src/application/routing/protocol/ospf/spnbo.c
===================================================================
--- src/application/routing/protocol/ospf/spnbo.c	(revision 7772)
+++ src/application/routing/protocol/ospf/spnbo.c	(revision 7778)
@@ -3582,14 +3582,14 @@ void ospfDebugNboRetx(t_NBO *p_NBO)
   {
     printf("\nMust supply the memory address of a neighbor.");
     printf("\nUse ospfDebugNBOPrint() to get a list of neighbors.");
     return;
   }
 
-  sprintf(traceBuf, "NBO 0x%x ipaddr %s area 0x%x", 
-    (L7_uint32)p_NBO, osapiInet_ntoa((L7_uint32)p_NBO->IpAdr), 
+  sprintf(traceBuf, "NBO 0x%llx ipaddr %s area 0x%x", 
+    PTR_TO_UINT64(p_NBO), osapiInet_ntoa((L7_uint32)p_NBO->IpAdr), 
     (L7_uint32)((t_ARO*)(p_NBO->ARO_Id))->AreaId);
 
   if(p_NBO->LsReTxHead)
   {
     if(!p_NBO->LsReTxTail)
       strcat(traceBuf, " head but no tail!");
Index: src/application/routing/protocol/ospf/sparo.c
===================================================================
--- src/application/routing/protocol/ospf/sparo.c	(revision 7772)
+++ src/application/routing/protocol/ospf/sparo.c	(revision 7778)
@@ -255,16 +255,16 @@ void ospfDebugDdShow(char * str, t_A_DbE
     osapiInetNtoa(p_ARO->AreaId, areaIdStr);
   }
   else
   {
     strcpy(areaIdStr, "0");
   }
-  sprintf(traceBuf, "\r\n%s DB %s LSID: %s, Adv Router: %s, Area %s, InitAge: %d, OrgTime %u, SeqNo: 0x%lx, Opt 0x%x, p_Lsa 0x%x, isCur %s",
+  sprintf(traceBuf, "\r\n%s DB %s LSID: %s, Adv Router: %s, Area %s, InitAge: %d, OrgTime %u, SeqNo: 0x%lx, Opt 0x%x, p_Lsa 0x%llx, isCur %s",
           str, lsaTypeNames[p_DbEntry->Lsa.LsType], lsIdStr, advRouterStr, areaIdStr,
           p_DbEntry->InitAge, (unsigned int)p_DbEntry->OrgTime, A_GET_4B(p_DbEntry->Lsa.SeqNum), p_DbEntry->Lsa.Options,
-          (unsigned int)p_DbEntry->p_Lsa, (L7_BIT_ISSET(p_DbEntry->dbFlags, O2_DB_ENTRY_IS_CUR) ? "TRUE" : "FALSE") );
+          PTR_TO_UINT64(p_DbEntry->p_Lsa), (L7_BIT_ISSET(p_DbEntry->dbFlags, O2_DB_ENTRY_IS_CUR) ? "TRUE" : "FALSE") );
   sysapiPrintf(traceBuf);    
 }
 
 
 /*********************************************************************
  * @purpose   Debug utility to print out the aging table.
@@ -5014,13 +5014,13 @@ void ospfDebugVlinks(void)
       L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
       L7_uchar8 nbrIdStr[OSAPI_INET_NTOA_BUF_SIZE];
       L7_uchar8 nbrAddrStr[OSAPI_INET_NTOA_BUF_SIZE];
       L7_uchar8 localAddrStr[OSAPI_INET_NTOA_BUF_SIZE];
       t_ARO *p_transitARO = (t_ARO*) p_IFO->TransitARO;
       RTO_InterfaceName(p_IFO, ifName);
-      printf("\nIFO pointer  %#x", (L7_uint32) p_IFO);
+      printf("\nIFO pointer %p", p_IFO);
       printf("\n\nVirtual interface %s...", ifName);
       printf("\nTransit area ID %lu.", (ulng) p_IFO->Cfg.VirtTransitAreaId);
       if (p_transitARO)
         printf("\nTransit area object %lu.", p_transitARO->AreaId);
       else
         printf("\nNot referencing a transit area.");
@@ -7373,14 +7373,14 @@ static Bool AgingRemoveOverAgedLsa(t_Han
 
     if(p_ARO->ExchOrLoadState)
     {
       if (p_RTO->ospfTraceFlags & OSPF_TRACE_AGING)
       {
          char traceBuf[OSPF_MAX_TRACE_STR_LEN];
-         sprintf(traceBuf, "Skip deleting aged DB 0x%x LSID 0x%08x, area 0x%08x in Exchange/Load state",
-                (L7_uint32)p_DbEntry, (L7_uint32)A_GET_4B(p_DbEntry->Lsa.LsId), (L7_uint32)p_ARO->AreaId);
+         sprintf(traceBuf, "Skip deleting aged DB 0x%llx LSID 0x%08x, area 0x%08x in Exchange/Load state",
+                 PTR_TO_UINT64(p_DbEntry), (L7_uint32)A_GET_4B(p_DbEntry->Lsa.LsId), (L7_uint32)p_ARO->AreaId);
          RTO_TraceWrite(traceBuf);
       }
 
      return TRUE;
     }
 
@@ -7398,14 +7398,14 @@ static Bool AgingRemoveOverAgedLsa(t_Han
          {
            foundInRetxList = TRUE;
 
            if (p_RTO->ospfTraceFlags & OSPF_TRACE_AGING)
            {
               char traceBuf[OSPF_MAX_TRACE_STR_LEN];
-              sprintf(traceBuf, "Skip deleting aged DB 0x%x LSID %x, area %x SeqNo: 0x%x, on NBO %x ReTx list",
-                     (L7_uint32)p_DbEntry, (L7_uint32)(A_GET_4B(p_DbEntry->Lsa.LsId)), 
+              sprintf(traceBuf, "Skip deleting aged DB 0x%llx LSID %x, area %x SeqNo: 0x%x, on NBO %x ReTx list",
+                     PTR_TO_UINT64(p_DbEntry), (L7_uint32)(A_GET_4B(p_DbEntry->Lsa.LsId)), 
                      (L7_uint32)p_ARO->AreaId, (L7_uint32)(A_GET_4B(p_DbEntry->Lsa.SeqNum)), 
                      (L7_uint32)p_NBO->IpAdr);
               RTO_TraceWrite(traceBuf);
            }
          }
 
@@ -7444,14 +7444,14 @@ static Bool AgingRemoveOverAgedLsa(t_Han
     }
     else
     {
       if (p_RTO->ospfTraceFlags & OSPF_TRACE_AGING)
       {
          char traceBuf[OSPF_MAX_TRACE_STR_LEN];
-         sprintf(traceBuf, "Deleting DBE 0x%x type %d on area %x. LSID: %x, Adv Router: %x, Age: %d, SeqNo: 0x%x",
-                (L7_uint32)p_DbEntry, (L7_uint32)p_DbEntry->Lsa.LsType, 
+         sprintf(traceBuf, "Deleting DBE 0x%llx type %d on area %x. LSID: %x, Adv Router: %x, Age: %d, SeqNo: 0x%x",
+                PTR_TO_UINT64(p_DbEntry), (L7_uint32)p_DbEntry->Lsa.LsType, 
                 p_ARO ? (L7_uint32)p_ARO->AreaId : 0, (L7_uint32)A_GET_4B(p_DbEntry->Lsa.LsId), 
                 (L7_uint32)A_GET_4B(p_DbEntry->Lsa.AdvertisingRouter), 
                 (L7_uint32)A_GET_2B(p_DbEntry->Lsa.LsAge), 
                 (L7_uint32)A_GET_4B(p_DbEntry->Lsa.SeqNum));
          RTO_TraceWrite(traceBuf);    
       }
Index: src/application/routing/rlim/rlim.h
===================================================================
--- src/application/routing/rlim/rlim.h	(revision 7772)
+++ src/application/routing/rlim/rlim.h	(revision 7778)
@@ -61,15 +61,15 @@
 
 /*
  * Operational defines and data structures
  */
 typedef struct {
   void *processQueue;
-  L7_uint32 procTaskHandle;
+  L7_uint64 procTaskHandle;
   void *cnfgrQueue;
-  L7_uint32 cnfgrTaskHandle;
+  L7_uint64 cnfgrTaskHandle;
   osapiTimerDescr_t *ip4NhopChangeTimer;
   osapiTimerDescr_t *tunnelDestAgeTimer;
 
   /* Bit mask of NIM events that RLIM is registered to receive */
   PORTEVENT_MASK_t nimEventMask;
 } rlimOpData_t;
Index: src/application/routing/rlim/rlim_tnnl.c
===================================================================
--- src/application/routing/rlim/rlim_tnnl.c	(revision 7772)
+++ src/application/routing/rlim/rlim_tnnl.c	(revision 7778)
@@ -733,13 +733,13 @@ void rlimTunnelOpRemoteAddrUpdate(L7_uin
    switch (tcp->remoteAddr.addrType)
    {
      case RLIM_ADDRTYPE_UNDEFINED:
        break;
 
      case RLIM_ADDRTYPE_IP4:
-       rtoNHResCallbackUnregister(tcp->remoteAddr.un.ip4addr, rlimTunnelIp4NhopChangeCallback, (void *)tunnelId);
+       rtoNHResCallbackUnregister(tcp->remoteAddr.un.ip4addr, rlimTunnelIp4NhopChangeCallback, UINT_TO_PTR(tunnelId));
        break;
 
 #if 0 /* not yet */
      case RLIM_ADDRTYPE_IP6:
        rto6NHResCallbackUnregister(&tcp->remoteAddr.un.ip6addr, rlimTunnelIp6NhopChangeCallback, (void *)tunnelId);
        break;
@@ -765,13 +765,13 @@ void rlimTunnelOpRemoteAddrUpdate(L7_uin
   {
     case RLIM_ADDRTYPE_UNDEFINED:
       break;
 
     case RLIM_ADDRTYPE_IP4:
       rlimTunnelIp4ReachabilityCheck(tunnelId);
-      rtoNHResCallbackRegister(tcp->remoteAddr.un.ip4addr, rlimTunnelIp4NhopChangeCallback, (void *)tunnelId);
+      rtoNHResCallbackRegister(tcp->remoteAddr.un.ip4addr, rlimTunnelIp4NhopChangeCallback, UINT_TO_PTR(tunnelId));
       break;
 
 #if 0 /* not yet */
     case RLIM_ADDRTYPE_IP6:
       rlimTunnelIp6ReachabilityCheck(tunnelId);
       rto6NHResCallbackRegister(&tcp->remoteAddr.un.ip6addr, rlimTunnelIp6NhopChangeCallback, (void *)tunnelId);
Index: src/application/routing/services/rtproto.c
===================================================================
--- src/application/routing/services/rtproto.c	(revision 7772)
+++ src/application/routing/services/rtproto.c	(revision 7778)
@@ -339,14 +339,14 @@ rtoIPv4Handle (L7_netBufHandle bufHandle
 *
 * @notes    none
 *
 * @end
 *********************************************************************/
 static void
-rtIPForwardArpCallback (L7_uint32 mbufHandle,
-                        L7_uint32 callbackparam,
+rtIPForwardArpCallback (L7_uint64 mbufHandle,
+                        L7_uint64 callbackparam,
                         L7_uchar8 *mac,
                         L7_RC_t  rc)
 {
   L7_int32 type = 0, code;
   struct rtmbuf *m, *mcopy;
   cbparam_t *p_callbackparam;
@@ -354,18 +354,18 @@ rtIPForwardArpCallback (L7_uint32 mbufHa
   L7_uchar8 *buffer_addr;
   L7_RC_t rc1;
   L7_uint32 tosEnable;
   L7_uint32 icmpUnreachablesMode = L7_DISABLE;
   L7_uint32 icmpRedirectsMode = L7_DISABLE;
 
-  m = (struct rtmbuf *)mbufHandle;
-  p_callbackparam = (cbparam_t *)callbackparam;
+  m = (struct rtmbuf *) UINT_TO_PTR(mbufHandle);
+  p_callbackparam = (cbparam_t *) UINT_TO_PTR(callbackparam);
 
 #if RTPROTO_DEBUG
-  printf("rtIPForwardArpCallback: rc = %d, intIfNum = %d, bufHandle = 0x%x\n",
-         rc, p_callbackparam->intIfNum, (L7_netBufHandle)m->rtm_bufhandle);
+  printf("rtIPForwardArpCallback: rc = %d, intIfNum = %d, bufHandle = 0x%llx\n",
+         rc, p_callbackparam->intIfNum, (L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
 #endif
 
   /* Can't resolve. Delete the packet.
   */
   if (rc != L7_SUCCESS)
   {
@@ -394,13 +394,13 @@ rtIPForwardArpCallback (L7_uint32 mbufHa
           rtcreateIcmpErrPckt(m, mcopy);
           icmp_error(mcopy, type, code, 0, 0);
         }
       }
     }
 
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle));
     bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) m);
     bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) p_callbackparam);
     return;
   }
 
   /* Send ICMP Redirect if necessary. Do this before sending the packet,
@@ -437,13 +437,13 @@ rtIPForwardArpCallback (L7_uint32 mbufHa
           }
         }
       }
     }
   }
   /* Send the data packet */
-  rtLvl7TxIPForward ( (L7_netBufHandle)m->rtm_bufhandle, p_callbackparam->intIfNum, mac);
+  rtLvl7TxIPForward ( (L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), p_callbackparam->intIfNum, mac);
 
   bufferPoolFree(rtBufferPoolId, (L7_uchar8 *) m);
   bufferPoolFree(rtBufferPoolId, (L7_uchar8 *) p_callbackparam);
 }
 
 
@@ -508,13 +508,13 @@ rtInIPForwardArpTable (L7_uint32 dest_ip
     memset(p,0,sizeof(L7_enetHeader_t));
     p += sizeof(L7_enetHeader_t);
     *(L7_ushort16 *)p = osapiHtons(L7_ETYPE_IP);
     p += 2;
     memcpy(p, m->rtm_data, m->rtm_len);
     SYSAPI_NET_MBUF_SET_DATALENGTH(netMbufHandle, m->rtm_len + (p - pdataStart));
-    m->rtm_bufhandle = (void *)netMbufHandle;
+    m->rtm_bufhandle = (void *) UINT_TO_PTR(netMbufHandle);
   }
 
   callbackparam = 0;
   rc = bufferPoolAllocate (rtBufferPoolId, &buffer_addr);
   if (rc != L7_SUCCESS)
   {
@@ -540,27 +540,27 @@ rtInIPForwardArpTable (L7_uint32 dest_ip
     else
     {
       rc = ipMapArpAddrResolve (intIfNum,
                                 dest_ip_addr,
                                 mac,
                                 rtIPForwardArpCallback,
-                                (L7_uint32)m,
-                                (L7_uint32)callbackparam);
+                                PTR_TO_UINT64(m),
+                                PTR_TO_UINT64(callbackparam));
     }
   }
 
   if (rc == L7_SUCCESS)
   {
     /* ARP entry already resolved. So why did hw not forward the packet?
      * Maybe L2 table entry has aged out. That can happen with asymmetric
      * traffic, where we forward to a neighbor but he doesn't send to us.
      * Update swFwdCount on ARP entry and possibly send an out-of-cycle
      * ARP request to repopulate the L2 table. */
     ipMapArpAddrUsed(dest_ip_addr, intIfNum);
 
-    rtLvl7TxIPForward ( (L7_netBufHandle)m->rtm_bufhandle, intIfNum, mac);
+    rtLvl7TxIPForward ( (L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle), intIfNum, mac);
     bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) m);
     bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) callbackparam);
     return L7_SUCCESS;
   }
 
   /* ARP entry is in progress. ARP will call rtIPForwardArpCallback() when the
@@ -572,13 +572,13 @@ rtInIPForwardArpTable (L7_uint32 dest_ip
       L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
       L7_uchar8 destStr[OSAPI_INET_NTOA_BUF_SIZE];
       osapiInetNtoa(ntohl(dest_ip_addr), destStr);
       sprintf(traceBuf, "ARP in progress for IP address %s", destStr);
       ipMapTraceWrite(traceBuf);
     }
-    SYSAPI_NET_MBUF_SET_LOC((L7_netBufHandle)m->rtm_bufhandle, MBUF_LOC_ARP_PEND_Q);
+    SYSAPI_NET_MBUF_SET_LOC((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle), MBUF_LOC_ARP_PEND_Q);
     return EARPINPROGRESS;
   }
 
   /* Can't resolve. Delete the packet. */
   if (ipMapTraceFlags & IPMAP_TRACE_FORWARDING)
   {
@@ -587,13 +587,13 @@ rtInIPForwardArpTable (L7_uint32 dest_ip
     osapiInetNtoa(ntohl(dest_ip_addr), destStr);
     sprintf(traceBuf, "rtInIPForwardArpTable() failed to resolve IP address %s",
             destStr);
     ipMapTraceWrite(traceBuf);
   }
 
-  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+  SYSAPI_NET_MBUF_FREE((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle));
   bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) m);
   if (callbackparam)
   {
     bufferPoolFree (rtBufferPoolId, (L7_uchar8 *) callbackparam);
   }
   return EHOSTUNREACH;
Index: src/application/routing/services/rtiprecv.c
===================================================================
--- src/application/routing/services/rtiprecv.c	(revision 7772)
+++ src/application/routing/services/rtiprecv.c	(revision 7778)
@@ -105,13 +105,13 @@ void rtLvl7IPRecv(L7_netBufHandle bufHan
   /* Get ifnet structure */
   m->rtm_pkthdr.rcvif = &gRtmIfnet[rtrIfNum];
 
   /* Get the received Physical port number */
   m->rtm_pkthdr.rxPort = pduInfo->rxPort;
 
-  m->rtm_bufhandle = (void *)bufHandle;
+  m->rtm_bufhandle = (void *) UINT_TO_PTR(bufHandle);
   SYSAPI_NET_MBUF_GET_DATASTART(m->rtm_bufhandle, data);
 
   rtmDataOffset = sysNetDataOffsetGet(data);
   m->rtm_data = (caddr_t)(data + rtmDataOffset);
   SYSAPI_NET_MBUF_GET_DATALENGTH(m->rtm_bufhandle, datalen);
 
Index: src/application/routing/services/rtipforwardmisc.c
===================================================================
--- src/application/routing/services/rtipforwardmisc.c	(revision 7772)
+++ src/application/routing/services/rtipforwardmisc.c	(revision 7778)
@@ -80,13 +80,13 @@ void rtcreateIcmpErrPckt(struct rtmbuf *
   pkt_len = (int)osapiNtohs(ip->ip_len);
   mcopy->rtm_len = mcopy->rtm_pkthdr.len = rtmin(header_len,pkt_len);
   /*rtm_copydata(m, 0, mcopy->rtm_len, rtmtod(mcopy, caddr_t));*/
   memcpy(mcopy->rtm_data, m->rtm_data, (unsigned int)mcopy->rtm_len);
 
   /* Save the ethernet header so that we can use it search for a VRRP IP address */
-  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)m->rtm_bufhandle, dataStart);
+  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), dataStart);
   if(dataStart != NULL)
      memcpy(mcopy->m_dmac, dataStart, L7_MAC_ADDR_LEN);
   else
      memset(mcopy->m_dmac, 0, L7_MAC_ADDR_LEN);
 }
 
Index: src/application/routing/rto/rto.c
===================================================================
--- src/application/routing/rto/rto.c	(revision 7772)
+++ src/application/routing/rto/rto.c	(revision 7778)
@@ -1076,19 +1076,22 @@ L7_RC_t rtoRouteAdd (L7_routeEntry_t *ro
     /* NULL indicates successful insertion */
     if (pData == L7_NULLPTR)
     {
       rtoStats.radix_entries++;
     }
     else
-      L7_LOG_ERROR((L7_uint32) pData);
+    {
+      L7_LOG_ERROR(PTR_TO_UINT32(pData));
+    }
 
     /* Find the new entry so that we can attach route info. */
     pData = radixLookupNode(&rtoRouteTreeData, &routeData.network, &routeData.netmask, L7_RN_EXACT);
     if (!pData)
     {
-      L7_LOG_ERROR("Error: rto.c radix corruption detected!\n"); /* Database corruption. */
+      L7_LOGF(L7_LOG_SEVERITY_CRITICAL, L7_LOG_COMPONENT_DEFAULT,
+              "Error: rto.c radix corruption detected!\n"); /* Database corruption. */
       return L7_FAILURE;
     }          
   }
   else
   {
     /* We already have a route to this destination. Note current best route. */
Index: src/application/routing/rto/rto_debug.c
===================================================================
--- src/application/routing/rto/rto_debug.c	(revision 7772)
+++ src/application/routing/rto/rto_debug.c	(revision 7778)
@@ -335,13 +335,13 @@ L7_uint32 rtoDebugWalkMkNodes()
 
   osapiReadLockTake(rtoRwLock, L7_WAIT_FOREVER);
   ptr = rtoRouteTreeData.mask_rnhead.rn_masknodefreelist;
   offset_next = RADIX_MASK_NODE_ITEM_OFFSET_NEXT(rtoRouteTreeData.mask_rnhead.max_keylen);
   while (ptr)
   {
-    ptr = (void*)(*((L7_uint32*)((char*)ptr+offset_next)));
+    ptr = UINT_TO_PTR(*((L7_uint32*)((char*)ptr+offset_next)));
     i++;
   }
   osapiReadLockGive(rtoRwLock);
 
   return i;
 }
@@ -362,13 +362,13 @@ L7_uint32 rtoDebugWalkDataNodes()
   osapiReadLockTake(rtoRwLock, L7_WAIT_FOREVER);
   offset_next = rtoRouteTreeData.offset_next;
   ptr = rtoRouteTreeData.rn_datanodefreelist;
 
   while (ptr)
   {
-    ptr=(void*)(*((L7_uint32*)((char*)ptr+offset_next)));
+    ptr=UINT_TO_PTR(*((L7_uint32*)((char*)ptr+offset_next)));
     i++;
   }
   osapiReadLockGive(rtoRwLock);
 
   return i;
 }
Index: src/application/routing/mapping/ipmap/core/ip_util.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ip_util.c	(revision 7772)
+++ src/application/routing/mapping/ipmap/core/ip_util.c	(revision 7778)
@@ -4298,13 +4298,13 @@ L7_RC_t ipMapRtrIntfDataGet( L7_uint32 i
 
   if (sysIntfType == L7_LOGICAL_VLAN_INTF)
   {
     /* VLAN routing interface */
     if (nimGetMacroPortAssignment(intIfNum, &macroPortIntf) == L7_SUCCESS)
     {
-      vlanId = (L7_uint32)macroPortIntf.macroInfo;
+      vlanId = PTR_TO_UINT32(macroPortIntf.macroInfo);
     }
     else
     {
       return L7_ERROR;
     }
   }
@@ -4357,13 +4357,13 @@ L7_RC_t ipMapLockTake(e_ipMapLockType lo
   L7_RC_t rc;
   L7_uint32 startTime = osapiTimeMillisecondsGet();
 
   if (ipMapTraceFlags & IPMAP_TRACE_LOCK)
   {
     L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
-    osapiSnprintf(traceBuf, IPMAP_TRACE_LEN_MAX, "%s taking %s lock on task %#x. wait %d.",
+    osapiSnprintf(traceBuf, IPMAP_TRACE_LEN_MAX, "%s taking %s lock on task %#llx. wait %d.",
             lockHolder, (lockType == IPMAP_READ_LOCK ? "READ" : "WRITE"),
             osapiTaskIdSelf(), wait);
     ipMapTraceWrite(traceBuf);
   }
 
   /* Make sure IP MAP has created semaphore */
@@ -4484,13 +4484,13 @@ L7_RC_t ipMapLockGive(e_ipMapLockType lo
 {
   L7_RC_t rc = L7_FAILURE;
 
   if (ipMapTraceFlags & IPMAP_TRACE_LOCK)
   {
     L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
-    osapiSnprintf(traceBuf, IPMAP_TRACE_LEN_MAX, "%s giving %s lock on task %#x.",
+    osapiSnprintf(traceBuf, IPMAP_TRACE_LEN_MAX, "%s giving %s lock on task %#llx.",
                   lockHolder, (lockType == IPMAP_READ_LOCK ? "READ" : "WRITE"),
                   osapiTaskIdSelf());
     ipMapTraceWrite(traceBuf);
   }
 
   /* Make sure IP MAP has created semaphore */
Index: src/application/routing/mapping/ipmap/core/ipmap_cnfgr.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ipmap_cnfgr.c	(revision 7772)
+++ src/application/routing/mapping/ipmap/core/ipmap_cnfgr.c	(revision 7778)
@@ -36,14 +36,14 @@
 
 ipMapCnfgrState_t ipMapCnfgrState = IPMAP_PHASE_INIT_0;
 extern void *ipMapForwardQueue[L7_L3_FORWARD_QUEUE_COUNT];
 extern L7_uint32 ipMapForwardQueueHWMark[L7_L3_FORWARD_QUEUE_COUNT];
 extern void *ipMapProcess_Queue;
 
-extern L7_int32 ipMapForwardingTaskId;
-extern L7_int32 ipMapProcessingTaskId;
+extern L7_uint64 ipMapForwardingTaskId;
+extern L7_uint64 ipMapProcessingTaskId;
 extern L7_ipMapCfg_t           *ipMapCfg;
 extern L7_rtrStaticRouteCfg_t  *route;
 extern L7_rtrStaticArpCfg_t    *arp;
 extern ipMapInfo_t             *pIpMapInfo;
 extern L7_uint32               *intIfToCfgIndex;
 extern pIpRoutingEventNotifyList_t  pIpIntfStateNotifyList;
@@ -518,14 +518,14 @@ L7_RC_t ipMapCnfgrInitPhase2Process( L7_
     *pReason   = L7_CNFGR_ERR_RC_FATAL;
     ipMapRC     = L7_ERROR;
 
     return ipMapRC;
   }
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapArpRecvIP related to type=%u, protocol_type=%u: 0x%08x",
-           SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_ARP,  (L7_uint32) ipMapArpRecvIP);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapArpRecvIP related to type=%u, protocol_type=%u: %p",
+              SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_ARP,  ipMapArpRecvIP);
 
   /* Register with SYSNET to receive ARP packets */
   memset((void *)&snEntry, 0, sizeof(sysnetNotifyEntry_t));
   strcpy(snEntry.funcName, "ipMapArpRecvIP");
   snEntry.notify_pdu_receive = ipMapArpRecvIP;
   snEntry.type = SYSNET_ETHERTYPE_ENTRY;
@@ -536,14 +536,14 @@ L7_RC_t ipMapCnfgrInitPhase2Process( L7_
     *pReason   = L7_CNFGR_ERR_RC_FATAL;
     ipMapRC     = L7_ERROR;
 
     return ipMapRC;
   }
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapRecvIP related to type=%u, protocol_type=%u: 0x%08x",
-           SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_IP,  (L7_uint32) ipMapRecvIP);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapRecvIP related to type=%u, protocol_type=%u: %p",
+              SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_IP, ipMapRecvIP);
 
   /* Register with sysNET to receive IP packets */
   memset((void *)&snEntry, 0, sizeof(sysnetNotifyEntry_t));
   strcpy(snEntry.funcName, "ipMapRecvIP");
   snEntry.notify_pdu_receive = ipMapRecvIP;
   snEntry.type = SYSNET_ETHERTYPE_ENTRY;
@@ -625,14 +625,14 @@ L7_RC_t ipMapCnfgrRegisterCallbacks(L7_i
 {
   sysnetNotifyEntry_t snEntry;
 
   /* Register with SYSNET to receive ARP packets */
   if (which == 1)
   {
-    PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapArpRecvIP related to type=%u, protocol_type=%u: 0x%08x",
-             SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_ARP,  (L7_uint32) ipMapArpRecvIP);
+    PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapArpRecvIP related to type=%u, protocol_type=%u: %p",
+                SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_ARP, ipMapArpRecvIP);
 
     memset((void *)&snEntry, 0, sizeof(sysnetNotifyEntry_t)); 
     strcpy(snEntry.funcName, "ipMapArpRecvIP");
     snEntry.notify_pdu_receive = ipMapArpRecvIP;
     snEntry.type = SYSNET_ETHERTYPE_ENTRY;
     snEntry.u.protocol_type = L7_ETYPE_ARP;
@@ -642,14 +642,14 @@ L7_RC_t ipMapCnfgrRegisterCallbacks(L7_i
     }
   }
 
   /* Register with sysNET to receive IP packets */
   if (which == 2)
   {
-    PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapRecvIP related to type=%u, protocol_type=%u: 0x%08x",
-             SYSNET_ETHERTYPE_ENTRY,  L7_ETYPE_IP,  (L7_uint32) ipMapRecvIP);
+    PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register ipMapRecvIP related to type=%u, protocol_type=%u: %p",
+                SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_IP, ipMapRecvIP);
 
     memset((void *)&snEntry, 0, sizeof(sysnetNotifyEntry_t));
     strcpy(snEntry.funcName, "ipMapRecvIP");
     snEntry.notify_pdu_receive = ipMapRecvIP;
     snEntry.type = SYSNET_ETHERTYPE_ENTRY;
     snEntry.u.protocol_type = L7_ETYPE_IP;
Index: src/application/routing/mapping/ipmap/core/ipmap.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ipmap.c	(revision 7772)
+++ src/application/routing/mapping/ipmap/core/ipmap.c	(revision 7778)
@@ -113,15 +113,15 @@ the event times out (and bad things prob
 
 #ifdef L7_QOS_FLEX_PACKAGE_ACL
 #include "support_api.h"
 #endif
 
 
-L7_int32                ipMapForwardingTaskId = L7_NULL;
-L7_int32                ipMapProcessingTaskId = L7_NULL;
-ipMapInfo_t                 *pIpMapInfo                                 = L7_NULL;
+L7_uint64               ipMapForwardingTaskId = L7_NULL;
+L7_uint64               ipMapProcessingTaskId = L7_NULL;
+ipMapInfo_t             *pIpMapInfo                                 = L7_NULL;
 void *ipMapMsgQSema = L7_NULL;
 void *ipMapForwardQueue[L7_L3_FORWARD_QUEUE_COUNT];
 L7_uint32 ipMapForwardQueueHWMark[L7_L3_FORWARD_QUEUE_COUNT];
 void *ipMapProcess_Queue = L7_NULL;
 pIpRoutingEventNotifyList_t  pIpIntfStateNotifyList;
 L7_rtrIntfMap_t    rtrIntfMap[L7_RTR_MAX_RTR_INTERFACES+1];
@@ -976,13 +976,13 @@ L7_RC_t ipMapIntfDelete(L7_uint32 intIfN
 * @returns  void
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void ipMapStaleRouteTimerExp(L7_uint32 unused1, L7_uint32 unused2)
+void ipMapStaleRouteTimerExp(L7_uint64 unused1, L7_uint64 unused2)
 {
   ipMapMsg_t   Message;
   L7_RC_t rc;
 
   memset(&Message, 0, sizeof(ipMapMsg_t));
   Message.msgId = IPMAP_STALE_ROUTE_TIMER;
Index: src/application/routing/mapping/ipmap/core/ipmap_debug.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ipmap_debug.c	(revision 7772)
+++ src/application/routing/mapping/ipmap/core/ipmap_debug.c	(revision 7778)
@@ -78,14 +78,14 @@ L7_uint32 ipMapTraceFlags = 0x0;
 L7_uint32 ipMapTraceIntf = 0;
 
 /* ICMP Rate limiting Stats */
 ipMapDebugIcmpCtlStats_t icmpCtlStats;
 L7_BOOL ratelimitKicks = L7_FALSE;
 
-extern L7_int32 ipMapForwardingTaskId;
-extern L7_int32 ipMapProcessingTaskId;
+extern L7_uint64 ipMapForwardingTaskId;
+extern L7_uint64 ipMapProcessingTaskId;
 
 /*---------------------------------------*/
 /* Global Configuration Data Structures  */
 /*---------------------------------------*/
 extern L7_ipMapCfg_t            *ipMapCfg;
 extern L7_rtrStaticRouteCfg_t   *route;
@@ -1678,13 +1678,13 @@ void dbg_form_arp(L7_uchar8 *buf, L7_uin
 void dbg_arp_req(L7_uint32 intIfNum, L7_uint32 ipSa, L7_uint32 ipDa)
 {
     L7_uchar8 *buff = osapiMalloc(L7_IP_MAP_COMPONENT_ID, 100);
     L7_uchar8 sMac[6] = {0, 0, 0, 1, 2, 0};
     L7_uchar8 dMac[6] = {0, 0, 0, 4, 5, 0};
     sysnet_pdu_info_t pduInfo;
-    L7_uint32 bufHandle;
+    L7_uint64 bufHandle;
     L7_ushort16 pFlag = L7_LL_ENCAP_ENET | L7_LL_USE_L3_SRC_MAC;
 
     sMac[4] = (ipSa & 0xFF00)>>8;
     sMac[5] = (ipSa & 0xFF);
 
     dMac[4] = (ipDa & 0xFF00)>>8;
@@ -1702,13 +1702,13 @@ void dbg_arp_req(L7_uint32 intIfNum, L7_
 void dbg_arp_rep(L7_uint32 intIfNum, L7_uint32 ipSa, L7_uint32 ipDa)
 {
     L7_uchar8 *buff = osapiMalloc(L7_IP_MAP_COMPONENT_ID, 100);
     L7_uchar8 sMac[6] = {0, 0, 0, 1, 2, 0};
     L7_uchar8 dMac[6] = {0, 0, 0, 4, 5, 0};
     sysnet_pdu_info_t pduInfo;
-    L7_uint32 bufHandle;
+    L7_uint64 bufHandle;
     L7_ushort16 pFlag = L7_LL_ENCAP_ENET | L7_LL_USE_L3_SRC_MAC;
 
     sMac[4] = (ipSa & 0xFF00)>>8;
     sMac[5] = (ipSa & 0xFF);
 
     dMac[4] = (ipDa & 0xFF00)>>8;
@@ -1768,13 +1768,13 @@ void dbg_form_ip(L7_uchar8 *buff, L7_uin
 void dbg_ip_rcv(L7_uint32 intIfNum, L7_uint32 ipSa, L7_uint32 ipDa, L7_uint32 op)
 {
     L7_uchar8 *buff = osapiMalloc(L7_IP_MAP_COMPONENT_ID, 100);
     L7_uchar8 sMac[6] = {0, 0, 0, 1, 2, 0};
     L7_uchar8 dMac[6] = {0, 0, 0, 4, 5, 0};
     sysnet_pdu_info_t pduInfo;
-    L7_uint32 bufHandle;
+    L7_uint64 bufHandle;
     L7_ushort16 pFlag = L7_LL_ENCAP_ENET | L7_LL_USE_L3_SRC_MAC;
 
     sMac[4] = (ipSa & 0xFF00)>>8;
     sMac[5] = (ipSa & 0xFF);
 
     dMac[4] = (ipDa & 0xFF00)>>8;
Index: src/application/routing/mapping/ipmap/core/ip_api.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ip_api.c	(revision 7772)
+++ src/application/routing/mapping/ipmap/core/ip_api.c	(revision 7778)
@@ -5166,13 +5166,13 @@ L7_RC_t ipMapVlanRtrIntIfNumToVlanId(L7_
   if (nimGetIntfType(intIfNum, &sysIntfType) == L7_SUCCESS)
   {
     if (sysIntfType == L7_LOGICAL_VLAN_INTF)
     {
       if ( nimGetMacroPortAssignment(intIfNum, &macroPortIntf) == L7_SUCCESS)
       {
-        *vlanId    = (L7_uint32)macroPortIntf.macroInfo;
+        *vlanId    = PTR_TO_UINT32(macroPortIntf.macroInfo);
         return L7_SUCCESS;
       }
     }
   }
 
   return L7_FAILURE;
Index: src/application/routing/mapping/ipmap/core/include/ip_util.h
===================================================================
--- src/application/routing/mapping/ipmap/core/include/ip_util.h	(revision 7772)
+++ src/application/routing/mapping/ipmap/core/include/ip_util.h	(revision 7778)
@@ -875,13 +875,13 @@ L7_RC_t ipMapLockGive(e_ipMapLockType lo
 L7_RC_t ipMapStaticRejectRoutesAdd(void);
 L7_RC_t ipMapStaticRejectRoutesRemove(void);
 L7_RC_t ipMapSubnetStaticRoutesRemove(L7_uint32 intIfNum, L7_IP_ADDR_t ipAddr, L7_IP_MASK_t ipMask);
 L7_RC_t ipMapSubnetLocalRouteRemove(L7_uint32 ipAddr, L7_uint32 ipMask);
 L7_uchar8 *ipMapNsfProtocolName(L7_NSF_PROTOCOL_t protocol);
 L7_uchar8 *ipMapNsfRoutesPendingString(void);
-void ipMapStaleRouteTimerExp(L7_uint32 unused1, L7_uint32 unused2);
+void ipMapStaleRouteTimerExp(L7_uint64 unused1, L7_uint64 unused2);
 
 /*-------------------------------------------------------------*/
 /*                   ipmap_cnfgr.c                             */
 /*-------------------------------------------------------------*/
 L7_RC_t ipMapInit(L7_CNFGR_CMD_DATA_t *pCmdData);
 void ipMapInitUndo();
Index: src/application/routing/mapping/vrrpmap/vrrp_map.c
===================================================================
--- src/application/routing/mapping/vrrpmap/vrrp_map.c	(revision 7772)
+++ src/application/routing/mapping/vrrpmap/vrrp_map.c	(revision 7778)
@@ -53,13 +53,13 @@
 L7_int32                L7_vrrp_task_id;
 L7_vrrpMapCfg_t        *pVrrpMapCfgData = L7_NULL;
 
 /* Cannot hold this semaphore when calling an IP MAP API. IP MAP can call
  * ARP, which can call VRRP. Can get a deadlock. */
 void  *                 VrrpConfigSema;
-L7_int32                vrrpTaskDaemonId;
+L7_uint64               vrrpTaskDaemonId;
 L7_uint32              *vrrpIntfMapTbl;
 
 
 /*global variable*/
 extern vrrpList_t* paramHead_g;
 extern L7_short16 totalRouters_g;
@@ -1102,13 +1102,13 @@ void vrrpInfoShow(L7_uint32 intIfNum, L7
 
 
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\n+--------------------------------------------------------+");
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\n|                 VRRP CONFIGURATION DATA                |");
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\n+--------------------------------------------------------+");
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\nvrid..................................%d", (L7_uint32)vrrpInfo->object->vrrpCfgInfo.vrid);                  /* Virtual Router ID           */
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\ndescription..................................%s", (L7_uint32)vrrpInfo->object->vrrpCfgInfo.description);           /* Virtual Router ID  description   */
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\ndescription..................................%s", vrrpInfo->object->vrrpCfgInfo.description);           /* Virtual Router ID  description   */
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\npriority..............................%d", (L7_uint32)vrrpInfo->object->vrrpCfgInfo.priority);              /* Priority                    */
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\nadver_int.............................%d", (L7_uint32)vrrpInfo->object->vrrpCfgInfo.adver_int);             /* Advertisement Interval      */
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "\nauth_data.............................");
   for (i=0;i<L7_VRRP_MAX_AUTH_DATA;i++)
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_IPMAP,  "%c", vrrpInfo->object->vrrpCfgInfo.auth_data[i]);
 
Index: src/application/routing/mapping/vrrpmap/vrrp_cnfgr.c
===================================================================
--- src/application/routing/mapping/vrrpmap/vrrp_cnfgr.c	(revision 7772)
+++ src/application/routing/mapping/vrrpmap/vrrp_cnfgr.c	(revision 7778)
@@ -45,13 +45,13 @@ vrrpCnfgrState_t vrrpCnfgrState = VRRP_P
 
 extern L7_vrrpMapCfg_t   *pVrrpMapCfgData;
 extern L7_uint32         *vrrpIntfMapTbl;
 extern vrrpRouterBasicConfiguration_t  vrrpBasicConfig_g;
 extern void  *vrrp_Queue;
 extern void     *VrrpConfigSema;
-extern L7_int32  vrrpTaskDaemonId;
+extern L7_uint64 vrrpTaskDaemonId;
 extern vrrpList_t * listMemPool_g[L7_VRRP_INTF_MAX_COUNT + 1];
 extern vrrpRouterInfo_t * routersArray_g[L7_VRRP_INTF_MAX_COUNT + 1];
 extern vrrpIntfInformation_t * vrrpIntfInfoTbl;
 extern L7_uchar8 *  vrrpVRIdToIndexMapTbl[L7_MAX_INTERFACE_COUNT];
 extern osapiTimerDescr_t   *pVRRPAdTimerHolder;
 extern osapiTimerDescr_t   *pVRRPMasterTimerHolder;
Index: src/application/routing/mapping/ripmap/include/rip_util.h
===================================================================
--- src/application/routing/mapping/ripmap/include/rip_util.h	(revision 7772)
+++ src/application/routing/mapping/ripmap/include/rip_util.h	(revision 7778)
@@ -59,14 +59,14 @@
 /*  RIP MAP INFO STRUCTURES            */
 /*-------------------------------------*/
 
 typedef struct ripInfo_s     
 {
   L7_BOOL         ripInitialized;           /* indicates vendor RIP stack init'd */
-  L7_uint32       ripTaskId;                /* RIP vendor code task ID */
-  L7_uint32       ripMapProcessingTaskId;   /* RIP mapping layer task ID */
+  L7_uint64       ripTaskId;                /* RIP vendor code task ID */
+  L7_uint64       ripMapProcessingTaskId;   /* RIP mapping layer task ID */
 
   /* The RIP processing thread reads from two message queues. There is a separate
    * queue for redistribution events so that we can give priority to other events,
    * such as interface, router, and configuration events. */
   void           *ripMapProcessQueue;       /* main RIP mapping layer processing queue */
   void           *ripMapRedistQueue;        /* Queue for redistribution events */
Index: src/application/routing/mapping/ripmap/rip_map.c
===================================================================
--- src/application/routing/mapping/ripmap/rip_map.c	(revision 7772)
+++ src/application/routing/mapping/ripmap/rip_map.c	(revision 7778)
@@ -1746,14 +1746,14 @@ void ripMapDebugShow(void)
   ripMapSemaTake();
 
   RIP_MAP_PRT(RIP_MAP_MSGLVL_ON,
               "RIP Internal Debug Information\n");
 
   RIP_MAP_PRT(RIP_MAP_MSGLVL_ON,
-              "  RIP Control Ctx:  taskSemId=0x%8.8x  taskSemAvail=%d  msgLvl=%d\n",
-              (L7_uint32)ripMapCtrl_g.taskCtrl.semId, ripMapCtrl_g.taskCtrl.semAvail,
+              "  RIP Control Ctx:  taskSemId=0x%llx  taskSemAvail=%d  msgLvl=%d\n",
+              PTR_TO_UINT64(ripMapCtrl_g.taskCtrl.semId), ripMapCtrl_g.taskCtrl.semAvail,
               ripMapCtrl_g.msgLvl);
 
   RIP_MAP_PRT(RIP_MAP_MSGLVL_ON,
               "    traceMode=%d  RIP Initialized=%d  Task Id=0x%8.8x\n",
               ripMapCtrl_g.traceEnabled, pRipInfo->ripInitialized, pRipInfo->ripTaskId);
 
Index: src/application/routing/mapping/ripmap/rip_vend_ctrl.c
===================================================================
--- src/application/routing/mapping/ripmap/rip_vend_ctrl.c	(revision 7772)
+++ src/application/routing/mapping/ripmap/rip_vend_ctrl.c	(revision 7778)
@@ -1330,13 +1330,13 @@ static int ripRouteEntryDisplay(struct r
                ripMapVendRedistProtoStr[rts->rts_redist_proto]);
 
     if (RT->rt_ifp != 0)
       pIntName = RT->rt_ifp->int_name;
     else
       pIntName = "n/a";
-    RIP_MAP_PRT(RIP_MAP_MSGLVL_ON, "%s (0x%x)\n", pIntName, (L7_uint32)RT->rt_ifp);
+    RIP_MAP_PRT(RIP_MAP_MSGLVL_ON, "%s (0x%llx)\n", pIntName, PTR_TO_UINT64(RT->rt_ifp));
 
   } /* endfor */
 
   return 0;
 }
 
Index: src/application/routing/mapping/relaymap/relaymap.c
===================================================================
--- src/application/routing/mapping/relaymap/relaymap.c	(revision 7772)
+++ src/application/routing/mapping/relaymap/relaymap.c	(revision 7778)
@@ -442,21 +442,21 @@ void ihTraceFlagsSet(L7_uint32 traceFlag
 void ihDebugShow(void)
 {
   L7_PORT_EVENTS_t event;
 
   if (osapiSemaTake(ihInfo->ihLock, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
-    printf("\nFailed to take IP helper semaphore at %#x.", (L7_uint32) ihInfo->ihLock);
+    printf("\nFailed to take IP helper semaphore at %p.", ihInfo->ihLock);
     return;
   }
-  printf("\nIP helper thread ID:  %#x", ihInfo->dhcpRelayTaskId);
+  printf("\nIP helper thread ID:  %#llx", ihInfo->dhcpRelayTaskId);
   printf("\nMax number of relay entries:  %u", ihCfg->relayEntryList.maxEntries);
   printf("\nCurrent number of relay entries:  %u", ihRelayEntryCount());
   printf("\nServer addr pool ID:  %u", pDhcpRelayInfo->serverPoolId);
   printf("\nPacket pool ID:  %u", pDhcpRelayInfo->packetPoolId);
-  printf("\nIP helper semaphore: %#x", (L7_uint32) ihInfo->ihLock);
+  printf("\nIP helper semaphore: %p", ihInfo->ihLock);
   printf("\nSysnet intercept registered?:  %s", ihInfo->regWithSysnet ? "Yes" : "No");
   printf("\nCurrent trace flags:  %#x", ihInfo->ihTraceFlags);
 
   printf("\nIP Helper registered for the following NIM events:");
   for (event = L7_PORT_DISABLE; event < L7_LAST_PORT_EVENT; event++)
   {
Index: src/application/routing/mapping/relaymap/relay_main.c
===================================================================
--- src/application/routing/mapping/relaymap/relay_main.c	(revision 7772)
+++ src/application/routing/mapping/relaymap/relay_main.c	(revision 7778)
@@ -680,13 +680,13 @@ L7_RC_t ihUdpMessageForward(L7_ipHeader_
   L7_uint32 ipHeaderLen = 0x0F & ipPkt->iph_versLen;   /* 4 byte words */
   L7_udp_header_t *udpHeader;
   L7_ipHeader_t *newIpHeader;
   /* Always building a 14 byte MAC header here */
   L7_uint32 ethHeaderLen = 2 * L7_MAC_ADDR_LEN + sizeof(L7_ushort16);
   L7_ushort16 srcPort, destPort;   /* host byte order */
-  L7_uint32 alignmentShift;
+  L7_uint64 alignmentShift;
 
   /* IP MAP requires packet be in an mbuf. So allocate a new one. Not optimal, but 
    * better than rewriting all the sw forwarding code. */
   SYSAPI_NET_MBUF_GET(bufHandle);
   if (bufHandle == L7_NULL)
   {
@@ -697,13 +697,13 @@ L7_RC_t ihUdpMessageForward(L7_ipHeader_
   SYSAPI_NET_MBUF_SET_LOC(bufHandle, MBUF_LOC_UDP_RELAY_TX);
   SYSAPI_NET_MBUF_GET_DATASTART(bufHandle, dataStart);
 
   /* Be picky about alignment. We know we are going to use a 14-byte
    * ethernet header. Assuming dataStart is 4-byte aligned, this will
    * make the IP header not 4-byte aligned. So move dataStart by 2 bytes. */
-  alignmentShift = ((L7_uint32)dataStart) % 4; 
+  alignmentShift = PTR_TO_UINT64(dataStart) % 4; 
   dataStart += alignmentShift;
   SYSAPI_NET_MBUF_SET_DATASTART(bufHandle, dataStart);
 
   /* Work from the inside out. Copy payload and build UDP header. */
   payloadLength = osapiNtohs(ipPkt->iph_len) - (4 * ipHeaderLen + sizeof(L7_udp_header_t));
   udpHeader = (L7_udp_header_t*) (((L7_uint32*) ipPkt) + ipHeaderLen);
Index: src/application/routing/mapping/relaymap/include/relay_util.h
===================================================================
--- src/application/routing/mapping/relaymap/include/relay_util.h	(revision 7772)
+++ src/application/routing/mapping/relaymap/include/relay_util.h	(revision 7778)
@@ -169,13 +169,13 @@ typedef struct ihStats_s
 } ihStats_t;
 
 typedef struct dhcpRelayInfo_s
 {
     /* indicates whether DHCP_RELAY is initialized or not.*/
     L7_BOOL         dhcpRelayInitialized;
-    L7_uint32       dhcpRelayTaskId;
+    L7_uint64       dhcpRelayTaskId;
 
     /* L7_TRUE if sysnet intercept currently registered. */
     L7_BOOL regWithSysnet;
 
   /* IP helper code is run by multiple threads. Packets are 
    * intercepted on the IP MAP forwarding thread. Configuration changes 
Index: src/application/routing/mapping/rtrdisc/include/rtrdisc_util.h
===================================================================
--- src/application/routing/mapping/rtrdisc/include/rtrdisc_util.h	(revision 7772)
+++ src/application/routing/mapping/rtrdisc/include/rtrdisc_util.h	(revision 7778)
@@ -31,13 +31,13 @@
 #include "l7_cnfgr_api.h"
 
 
 /* Holds information required by the processing task */
 typedef struct rtrDiscInfo_s
 {
-    L7_uint32       rtrDiscProcessingTaskId;
+    L7_uint64       rtrDiscProcessingTaskId;
     void *          rtrDiscProcessingQueue;
 } rtrDiscInfo_t;
 
 extern rtrDiscInfo_t          *pRtrDiscInfo;
       
 
@@ -96,13 +96,13 @@ typedef struct rtrDiscIntfInfo_s
 * @returns  void
 *       
 * @notes    none
 *       
 * @end
 *********************************************************************/
-void rtrDiscTimerTick(void * parm1, L7_uint32 parm2);
+void rtrDiscTimerTick(L7_uint64 parm1, L7_uint64 parm2);
 
 /*********************************************************************
 * @purpose  Processes the timer tick messages
 *
 * @param    
 *
Index: src/application/routing/mapping/rtrdisc/rtrdisc_util.c
===================================================================
--- src/application/routing/mapping/rtrdisc/rtrdisc_util.c	(revision 7772)
+++ src/application/routing/mapping/rtrdisc/rtrdisc_util.c	(revision 7778)
@@ -62,13 +62,13 @@ extern osapiTimerDescr_t *pRtrDiscTimerH
 * @returns  void
 *
 * @notes    none
 *
 * @end
 *********************************************************************/
-void rtrDiscTimerTick(void * parm1, L7_uint32 parm2)
+void rtrDiscTimerTick(L7_uint64 parm1, L7_uint64 parm2)
 {
     L7_RC_t rc;
     rtrDiscMsg_t msg;
 
     if (pRtrDiscInfo->rtrDiscProcessingQueue == L7_NULLPTR)
     {
Index: src/application/routing/mapping/arpmap/core/ipmap_arp_exten.c
===================================================================
--- src/application/routing/mapping/arpmap/core/ipmap_arp_exten.c	(revision 7772)
+++ src/application/routing/mapping/arpmap/core/ipmap_arp_exten.c	(revision 7778)
@@ -762,13 +762,13 @@ void ipMapArpExtenAddrConflictStatsShow(
   L7_uint32 intIfNum = 0, tmpIp, ip;
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
   L7_uchar8 ipAddrStr[OSAPI_INET_NTOA_BUF_SIZE];
 
   for (addrEnt = p_A->addrEnt; addrEnt; addrEnt = addrEnt->next)
   {
-    if(ipMapArpExtenGetIntIfNum(addrEnt->intfNum, &intIfNum) == L7_SUCCESS)
+    if(ipMapArpExtenGetIntIfNum(addrEnt->intfNum, &intIfNum) == E_OK)
     {
       memset(ifName, 0, sizeof(ifName));
       nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
       memcpy(&tmpIp, addrEnt->ipAddr, sizeof(tmpIp));
       ip = osapiNtohl(tmpIp);
       osapiInetNtoa(ip, ipAddrStr);
@@ -796,13 +796,13 @@ void ipMapArpExtenAddrConflictStatsReset
   t_ARP *p_A = (t_ARP *)ipMapArpCtx_g.arpHandle;
   t_ADDREnt *addrEnt;
   L7_uint32 intIfNum = 0;
 
   for (addrEnt = p_A->addrEnt; addrEnt; addrEnt = addrEnt->next)
   {
-    if(ipMapArpExtenGetIntIfNum(addrEnt->intfNum, &intIfNum) == L7_SUCCESS)
+    if(ipMapArpExtenGetIntIfNum(addrEnt->intfNum, &intIfNum) == E_OK)
     {
       addrEnt->addrConflictStats.numOfConflictsDetected = 0;
     }
   }
 }
 
Index: src/application/routing/mapping/arpmap/core/ipmap_arp_table.c
===================================================================
--- src/application/routing/mapping/arpmap/core/ipmap_arp_table.c	(revision 7772)
+++ src/application/routing/mapping/arpmap/core/ipmap_arp_table.c	(revision 7778)
@@ -203,14 +203,14 @@ L7_RC_t ipMapArpGwTableDelete(void)
     {
       pArpCtx->gwTbl.treeData.semId = L7_NULLPTR;
     }
     else
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
-              "%s: Could not delete AVL tree semaphore, id=0x%8.8x\n",
-              routine_name, (L7_uint32)pArpCtx->gwTbl.treeData.semId);
+              "%s: Could not delete AVL tree semaphore, id=%p\n",
+              routine_name, pArpCtx->gwTbl.treeData.semId);
       /* keep going */
     }
   }
 
   /* free the data heap memory */
   if (pArpCtx->gwTbl.dataHeap != L7_NULLPTR)
@@ -326,13 +326,13 @@ L7_RC_t ipMapArpGwTableInsert(L7_uint32
 
       /* when the first gateway arp entry added, start the ARP request timer */
       if(avlTreeCount(&ipMapArpCtx_g.gwTbl.treeData) == 1)
       {
         if(TIMER_StartSec(ipMapArpCtx_g.gwArpRqstTimer, ARP_GW_RQSTTIME,
                           TRUE /* repetitive timer */, gwArpRequestTimeExp,
-                          (t_Handle)ipMapArpCtx_g.timerExp.taskId) != E_OK)
+                          (t_Handle) UINT_TO_PTR(ipMapArpCtx_g.timerExp.taskId)) != E_OK)
           L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_ARP_MAP_COMPONENT_ID,
                   "%s: Start ARP Gateway timer failed\n", routine_name);
       }
     }
   }
   else if (pNode != &gw)
@@ -619,15 +619,15 @@ void ipMapArpGwTableShow(void)
     L7_uchar8   ipStr[OSAPI_INET_NTOA_BUF_SIZE];
     /* store key for use in next search */
     gw.ipAddr = pNode->ipAddr;
     gw.intIfNum = pNode->intIfNum;
 
     osapiInetNtoa(gw.ipAddr, ipStr);
-    IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%6u    %-15s %8d %10d 0x%8.8x %5s %5s\n",
+    IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%6u    %-15s %8d %10d 0x%llx %5s %5s\n",
                 ++count, ipStr, pNode->intIfNum, pNode->refCnt,
-                (L7_uint32)pNode, (pNode->holdover == L7_TRUE) ? "Y" : "N",
+                PTR_TO_UINT64(pNode), (pNode->holdover == L7_TRUE) ? "Y" : "N",
                 pNode->staticRouteGw ? "Y" : "N");
   }
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "\n\n");
 }
 
 
@@ -734,14 +734,14 @@ L7_RC_t ipMapArpIpTableDelete(void)
     {
       pArpCtx->ipTbl.treeData.semId = L7_NULLPTR;
     }
     else
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
-              "%s: Could not delete AVL tree semaphore, id=0x%8.8x\n",
-              routine_name, (L7_uint32)pArpCtx->ipTbl.treeData.semId);
+              "%s: Could not delete AVL tree semaphore, id=%p\n",
+              routine_name, pArpCtx->ipTbl.treeData.semId);
       /* keep going */
     }
   }
 
   /* free the data heap memory */
   if (pArpCtx->ipTbl.dataHeap != L7_NULLPTR)
@@ -949,17 +949,17 @@ L7_RC_t ipMapArpIpTableInsert(ipMapArpIp
               "%s: Failure adding %s in device ARP table\n",
               routine_name, (char *)ipStr);
     }
 
     /* debug message */
     IPM_ARP_PRT(IPM_ARP_MSGLVL_LO,
-                "[%10.10u] IPM_ARP: inserted %s intf %d, pNode=0x%8.8x t_Age=0x%8.8x t_Rsp=0x%8.8x  (inDev=%1s)\n",
+                "[%10.10u] IPM_ARP: inserted %s intf %d, pNode=0x%llx t_Age=0x%llx t_Rsp=0x%llx  (inDev=%1s)\n",
                 osapiTimeMillisecondsGet64(), (L7_uchar8 *)ipStr,
-                pIpInfo->intIfNum, (L7_uint32)pNode,
-                (L7_uint32)pNode->arpEntry.arpAgeTimer,
-                (L7_uint32)pNode->arpEntry.arpRspTimer,
+                pIpInfo->intIfNum, PTR_TO_UINT64(pNode),
+                PTR_TO_UINT64(pNode->arpEntry.arpAgeTimer),
+                PTR_TO_UINT64(pNode->arpEntry.arpRspTimer),
                 (pNode->inDevice == L7_TRUE) ? "Y" : "N");
 
     rc = L7_SUCCESS;                    /* all went well */
 
   } while (0);  /* enddowhile one-pass control loop */
 
@@ -1038,17 +1038,17 @@ L7_RC_t ipMapArpIpTableUpdate(ipMapArpIp
               "%s: Failure updating %s intf %s in device ARP table\n",
               routine_name, (char *)ipStr, ifName);
     }
 
     /* debug message */
     IPM_ARP_PRT(IPM_ARP_MSGLVL_LO,
-                "[%10.10u] IPM_ARP: %s %s %d, pNode=0x%8.8x t_Age=0x%8.8x t_Rsp=0x%8.8x  (inDev=%1s)\n",
+                "[%10.10u] IPM_ARP: %s %s %d, pNode=0x%llx t_Age=0x%llx t_Rsp=0x%llx  (inDev=%1s)\n",
                 osapiTimeMillisecondsGet64(), (event == IPM_ARP_TABLE_UPDATE) ? "updated" : "reissued",
-                (L7_uchar8 *)ipStr, pIpInfo->intIfNum, (L7_uint32)pNode,
-                (L7_uint32)pNode->arpEntry.arpAgeTimer,
-                (L7_uint32)pNode->arpEntry.arpRspTimer,
+                (L7_uchar8 *)ipStr, pIpInfo->intIfNum, PTR_TO_UINT64(pNode),
+                PTR_TO_UINT64(pNode->arpEntry.arpAgeTimer),
+                PTR_TO_UINT64(pNode->arpEntry.arpRspTimer),
                 (pNode->inDevice == L7_TRUE) ? "Y" : "N");
 
     rc = L7_SUCCESS;                    /* all went well */
 
   } while (0);  /* enddowhile one-pass control loop */
 
@@ -1079,13 +1079,13 @@ L7_RC_t ipMapArpIpTableRemove(ipMapArpIp
 {
   static const char *routine_name = "ipMapArpIpTableRemove";
   L7_uchar8         ipStr[OSAPI_INET_NTOA_BUF_SIZE];
   ipMapArpIpNode_t  *pNode;
   L7_RC_t           rc = L7_FAILURE;
   L7_BOOL           inDeviceSaved;      /* save for debug msg */
-  L7_uint32         ageTimerId, rspTimerId;
+  L7_uint64         ageTimerId, rspTimerId;
 
 
   osapiInetNtoa(pIpInfo->key, ipStr);
 
   /* use one-pass loop for error exit control */
   do
@@ -1117,14 +1117,14 @@ L7_RC_t ipMapArpIpTableRemove(ipMapArpIp
       rc = L7_FAILURE;
       break;                            /* exit control loop */
     }
 
     /* save value of inDevice flag for debug msg before it is changed/deleted */
     inDeviceSaved = pNode->inDevice;
-    ageTimerId = (L7_uint32)pNode->arpEntry.arpAgeTimer;
-    rspTimerId = (L7_uint32)pNode->arpEntry.arpRspTimer;
+    ageTimerId = PTR_TO_UINT64(pNode->arpEntry.arpAgeTimer);
+    rspTimerId = PTR_TO_UINT64(pNode->arpEntry.arpRspTimer);
 
     /* delete the entry from the ARP table */
     if (ipMapArpIpTableRemoveCommon(pNode) != L7_SUCCESS)
     {
       L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
       nimGetIntfName(pNode->intIfNum, L7_SYSNAME, ifName);
@@ -1136,15 +1136,15 @@ L7_RC_t ipMapArpIpTableRemove(ipMapArpIp
       rc = L7_FAILURE;                  /* node not removed from table */
       break;                            /* exit control loop */
     }
 
     /* debug message */
     IPM_ARP_PRT(IPM_ARP_MSGLVL_LO,
-                "[%10.10u] IPM_ARP: removed %s, intf %d pNode=0x%8.8x t_Age=0x%8.8x t_Rsp=0x%8.8x  (inDev=%1s)\n",
+                "[%10.10u] IPM_ARP: removed %s, intf %d pNode=0x%llx t_Age=0x%llx t_Rsp=0x%llx  (inDev=%1s)\n",
                 osapiTimeMillisecondsGet64(), ipStr, pNode->intIfNum,
-                (L7_uint32)pNode, ageTimerId, rspTimerId,
+                PTR_TO_UINT64(pNode), ageTimerId, rspTimerId,
                 (inDeviceSaved == L7_TRUE) ? "Y" : "N");
 
     rc = L7_SUCCESS;                    /* all went well */
 
   } while (0);  /* enddowhile one-pass control loop */
 
@@ -1174,13 +1174,13 @@ L7_RC_t ipMapArpIpTableOldestRemove(L7_B
 {
   static const char *routine_name = "ipMapArpIpTableOldestRemove";
   L7_uchar8         ipStr[OSAPI_INET_NTOA_BUF_SIZE];
   ipMapArpIpNode_t  *pNode = L7_NULLPTR;
   L7_RC_t           rc = L7_FAILURE, rc2;
   L7_BOOL           inDeviceSaved;      /* save for debug msg */
-  L7_uint32         ageTimerId, rspTimerId;
+  L7_uint64         ageTimerId, rspTimerId;
 
 
   /* use one-pass loop for error exit control */
   do
   {
     /* find oldest entry in ARP table */
@@ -1200,14 +1200,14 @@ L7_RC_t ipMapArpIpTableOldestRemove(L7_B
     /* NOTE: pNode points to oldest dynamic (or gateway) entry to be removed */
 
     osapiInetNtoa(pNode->key, ipStr);
 
     /* save value of inDevice flag for debug msg before it is changed/deleted */
     inDeviceSaved = pNode->inDevice;
-    ageTimerId = (L7_uint32)pNode->arpEntry.arpAgeTimer;
-    rspTimerId = (L7_uint32)pNode->arpEntry.arpRspTimer;
+    ageTimerId = PTR_TO_UINT64(pNode->arpEntry.arpAgeTimer);
+    rspTimerId = PTR_TO_UINT64(pNode->arpEntry.arpRspTimer);
 
     /* delete the entry from the ARP table */
     if (ipMapArpIpTableRemoveCommon(pNode) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
               "%s: Failure to remove %s from ARP table\n",
@@ -1216,15 +1216,15 @@ L7_RC_t ipMapArpIpTableOldestRemove(L7_B
       rc = L7_FAILURE;                  /* node not removed from table */
       break;                            /* exit control loop */
     }
 
     /* debug message */
     IPM_ARP_PRT(IPM_ARP_MSGLVL_LO,
-                "[%10.10u] IPM_ARP: oldest removed %s intf %d, pNode=0x%8.8x t_Age=0x%8.8x t_Rsp=0x%8.8x  (inDev=%1s)\n",
+                "[%10.10u] IPM_ARP: oldest removed %s intf %d, pNode=0x%llx t_Age=0x%llx t_Rsp=0x%llx  (inDev=%1s)\n",
                 osapiTimeMillisecondsGet64(), ipStr, pNode->intIfNum,
-                (L7_uint32)pNode, ageTimerId, rspTimerId,
+                PTR_TO_UINT64(pNode), ageTimerId, rspTimerId,
                 (inDeviceSaved == L7_TRUE) ? "Y" : "N");
 
     rc = L7_SUCCESS;                    /* all went well */
 
   } while (0);  /* enddowhile one-pass control loop */
 
@@ -1776,16 +1776,16 @@ void ipMapArpIpTableShow(L7_uint32 intIf
       for (i = 0; i < L7_MAC_ADDR_LEN-1; i++)
       {
         IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%2.2x:", pNode->arpEntry.macAddr[i]);
       }
       IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%2.2x ", pNode->arpEntry.macAddr[i]);
 
-      IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, " %2.1u  %-8.8s %8u   %1s    %2u   0x%8.8x\n",
+      IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, " %2.1u  %-8.8s %8u   %1s    %2u   0x%llx\n",
                   pIntf->intIfNum, ipMapArpEntryTypeStr[entryType], ageTime,
                   (pNode->inDevice == L7_TRUE) ? "Y" : "N", pNode->failedDevAdds,
-                  (L7_uint32)pNode->arpEntry.pNode);
+                  PTR_TO_UINT64(pNode->arpEntry.pNode));
 
       numEnt--;
     }
 
   } /* endwhile */
 
@@ -1995,14 +1995,14 @@ void ipMapArpIpAgeListShow(L7_uint32 int
   L7_uint32         count, ipAddr, entryType;
   ulng              ageTime;
   ipMapArpIntf_t    *pIntf;
 
 
   /* display the head and tail pointers */
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "\nAge List head = 0x%8.8x  tail = 0x%8.8x\n",
-              (L7_uint32)pAgeList->head, (L7_uint32)pAgeList->tail);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "\nAge List head = 0x%llx  tail = 0x%llx\n",
+              PTR_TO_UINT64(pAgeList->head), PTR_TO_UINT64(pAgeList->tail));
 
   /* quick-scan the list to count the entries */
   for (pNode = pAgeList->head, count = 0;
        pNode != L7_NULLPTR;
        pNode = pNode->ageCtrl.next, count++);
 
@@ -2057,15 +2057,15 @@ void ipMapArpIpAgeListShow(L7_uint32 int
     if ((intIfNum == 0) || (intIfNum == pIntf->intIfNum))
     {
       osapiInetNtoa(ipAddr, ipStr);
       entryType = (L7_uint32)pNode->arpEntry.entryType;
       ipMapArpExtenEntryAgeCalc(pNode->arpEntry.timeStamp, (ulng *)&ageTime);
 
-      IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%6u   %-15.15s %-8.8s  %2.1u  %8u 0x%8.8x\n",
+      IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "%6u   %-15.15s %-8.8s  %2.1u  %8u 0x%llx\n",
                   ++count, ipStr, ipMapArpEntryTypeStr[entryType],
-                  pIntf->intIfNum, ageTime, (L7_uint32)pNode);
+                  pIntf->intIfNum, ageTime, PTR_TO_UINT64(pNode));
 
       numEnt--;
     }
 
     pNode = pNode->ageCtrl.next;
 
Index: src/application/routing/mapping/arpmap/core/ipmap_arp_api.c
===================================================================
--- src/application/routing/mapping/arpmap/core/ipmap_arp_api.c	(revision 7772)
+++ src/application/routing/mapping/arpmap/core/ipmap_arp_api.c	(revision 7778)
@@ -211,14 +211,14 @@ L7_RC_t ipMapArpInitPhase1Process(void)
 * @end
 *********************************************************************/
 L7_RC_t ipMapArpInitPhase2Process(void)
 {
   L7_RC_t rc;
 
-  PT_LOG_INFO(LOG_CTX_STARTUP, "Going to register function 0x%08x to family DTL_FAMILY_ROUTING_ARP_MGMT (%u)",
-           (L7_uint32) dtlIpv4ArpEntryCallback, DTL_FAMILY_ROUTING_ARP_MGMT);
+  PT_LOG_INFO(LOG_CTX_STARTUP, "Going to register function %p to family DTL_FAMILY_ROUTING_ARP_MGMT (%u)",
+              dtlIpv4ArpEntryCallback, DTL_FAMILY_ROUTING_ARP_MGMT);
 
   if ((rc = dtlCallbackRegistration(DTL_FAMILY_ROUTING_ARP_MGMT,
               dtlIpv4ArpEntryCallback)) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
             "IPM_ARP: Could not register ARP Query callback with DTL, rc=%d\n",
@@ -647,13 +647,13 @@ L7_RC_t ipMapArpIntfUnregister(L7_uint32
 *
 * @end
 *********************************************************************/
 L7_RC_t ipMapArpAddrResolve(L7_uint32 intIfNum, L7_uint32 ipAddr,
                             L7_uchar8 *pMacAddr,
                             ipMapArpResCallback_ft pCallbackFn,
-                            L7_uint32 cbParm1, L7_uint32 cbParm2)
+                            L7_uint64 cbParm1, L7_uint64 cbParm2)
 {
   L7_RC_t rc;
   IPM_ARP_SEMA_TAKE(&ipMapArpCtx_g.arpLock, L7_WAIT_FOREVER);
   rc = ipMapArpAddrResolveInternal(intIfNum, ipAddr,
                                    pMacAddr, pCallbackFn,
                                    cbParm1, cbParm2);
Index: src/application/routing/mapping/arpmap/core/include/ipmap_arp.h
===================================================================
--- src/application/routing/mapping/arpmap/core/include/ipmap_arp.h	(revision 7772)
+++ src/application/routing/mapping/arpmap/core/include/ipmap_arp.h	(revision 7778)
@@ -233,13 +233,13 @@ typedef struct ipMapArpIpNode_s
 
 /* IP Mapping layer ARP lock control info */
 #define ARP_LOCK_OWNER_LEN 20
 typedef struct ipMapArpLockCtrl_s
 {
   void            *semId;               /* semaphore id */
-  L7_int32        ownerTaskId;          /* current lock owner task */
+  L7_uint64       ownerTaskId;          /* current lock owner task */
   L7_int32        ownerLockCount;       /* nested lock count for current owner (signed value) */
   L7_uint32       lockTotal;            /* total number of times locked        */
   L7_uint32       unlockTotal;          /* total number of times unlocked      */
 
   /* additional debug */
   L7_char8        ownerFile[ARP_LOCK_OWNER_LEN+1];
@@ -306,13 +306,13 @@ typedef struct
   L7_ushort16               flags;
 
 } ipMapArpTimerExpMsg_t;
 
 typedef struct
 {
-  L7_int32        taskId;               /* system task identifier */
+  L7_uint64       taskId;               /* system task identifier */
   void            *pMsgQ;               /* task msg queue ptr */
   L7_uint32       totalCt;              /* total msgs processed by task */
   L7_uint32       peakCt;               /* peak msgs processed per task iteration */
   L7_uint32       maxCt;                /* max msgs avail in task msg queue */
   L7_uint32       fullQCt;              /* task msg queue full (when sending) */
   L7_uint32       failCt;               /* general failure (task-specific meaning) */
@@ -968,13 +968,13 @@ void ipMapArpAllShow(L7_uint32 amt);
 *       
 * @end
 *********************************************************************/
 L7_RC_t ipMapArpAddrResolveInternal(L7_uint32 intIfNum, L7_uint32 ipAddr,
                             L7_uchar8 *pMacAddr, 
                             ipMapArpResCallback_ft pCallbackFn,
-                            L7_uint32 cbParm1, L7_uint32 cbParm2);
+                            L7_uint64 cbParm1, L7_uint64 cbParm2);
 
 /*-----------------*/
 /* ipm_arp_table.c */
 /*-----------------*/
 
 /*********************************************************************
Index: src/application/routing/mapping/arpmap/core/ipmap_arp.c
===================================================================
--- src/application/routing/mapping/arpmap/core/ipmap_arp.c	(revision 7772)
+++ src/application/routing/mapping/arpmap/core/ipmap_arp.c	(revision 7778)
@@ -36,13 +36,13 @@
 #include "log.h"
 #include "l7utils_api.h"
 #include "arp_debug.h"
 #include "arp.h"
 
 /* External References */
-extern void osapiDebugStackTrace (L7_uint32 task_id, FILE *fp);
+extern void osapiDebugStackTrace (L7_uint64 task_id, FILE *fp);
 
 /* Global data */
 ipMapArpCtx_t   ipMapArpCtx_g;          /* IP Mapping layer ARP global context*/
 ipMapArpIntf_t  *ipMapArpIntfInUse_g[IPM_ARP_INTF_MAX]; /* not using entry 0 */
 L7_BOOL         ipMapRoutingStarted = L7_FALSE;          /* vendor subsystem was started */
 
@@ -65,13 +65,13 @@ extern L7_uchar8 ipMapArpBcastMac[L7_MAC
 #define ARP_HIST_FUNC_LEN 30
 #define ARP_HIST_ITEMS    200
 struct arpLockHistory_s
 {
   L7_char8  file[ARP_HIST_FILE_LEN+1];
   L7_uint32 line;
-  L7_uint32 tid;
+  L7_uint64 tid;
   L7_uint32 lockid;
   L7_char8  fname[ARP_HIST_FUNC_LEN+1];
   L7_uint32 ts;
 };
 
 static struct arpLockHistory_s arpLockHistory[ARP_HIST_ITEMS];
@@ -138,16 +138,16 @@ void arpLogLockAction(L7_char8 * fname,
 
 /* when a lock fails (suspected deadlock) this functions dumps the stack trace */
 void arpLockShowStack(L7_char8 * fname, L7_uint32 lockid, L7_char8 * file, L7_uint32 line)
 {
   osapiSleep(osapiTaskIdSelf() % 60);
   l7utilsFilenameStrip(&file);
-  sysapiPrintf("\n%s failed to lock 0x%x tsk 0x%x %s:%u",
+  sysapiPrintf("\n%s failed to lock 0x%x tsk 0x%llx %s:%u",
                fname, lockid, osapiTaskIdSelf(), file, line);
   L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
-          "\n%s failed tsk 0x%x %s:%u",
+          "\n%s failed tsk 0x%llx %s:%u",
                fname, osapiTaskIdSelf(), file, line);
   osapiSleep(90);
   if(!arpDeadlocked)
   {
     /* attempt to avoid multiple traces */
     arpDeadlocked = L7_TRUE;
@@ -404,14 +404,14 @@ e_Err ipMapArpSendCallback(t_Handle user
     }
     SYSAPI_NET_MBUF_GET_DATASTART(bufHandle, pDataBuf);
     if (F_Read(pDataBuf, pFrame, 0, (word)frameSize) != (word)frameSize)
     {
         IPM_ARP_PRT(IPM_ARP_MSGLVL_MED,
                     "IPM_ARP: ARP Send could not copy frame contents to msg block, "
-                    "pFrame=0x%8.8x intf=%d\n",
-                    (L7_uint32)pFrame, pIntf->index);
+                    "pFrame=0x%llx intf=%d\n",
+                    PTR_TO_UINT64(pFrame), pIntf->index);
         SYSAPI_NET_MBUF_FREE(bufHandle);
         break;
     }
     SYSAPI_NET_MBUF_SET_DATALENGTH(bufHandle, frameSize);
 
     /* invoke the interface raw send function (it now owns sysnet buffer) */
@@ -1420,25 +1420,25 @@ void ipMapArpCacheEventNotify(ipMapArpCa
 *
 * @end
 *************************************************************************/
 void ipMapArpSemaTake(ipMapArpLockCtrl_t *pLock, L7_int32 timeout,
                       char *file, L7_ulong32 line)
 {
-  L7_int32      taskId = osapiTaskIdSelf();
+  L7_uint64     taskId = osapiTaskIdSelf();
   L7_RC_t       rc;
 
   if(timeout == L7_WAIT_FOREVER)
     timeout = arpLockDebugTimeout;
 
   l7utilsFilenameStrip(&file);
 
   if ((rc = osapiSemaTake(pLock->semId, arpLockDebugTimeout)) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
-            "Semaphore take failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)pLock->semId);
+            "Semaphore take failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, pLock->semId);
     ARP_LOCK_DEBUG_DUMP(pLock->semId, file, line);
   }
 
   pLock->ownerTaskId = taskId;
   pLock->ownerLockCount++;
   pLock->lockTotal++;                 /* used for debug show function */
@@ -1481,14 +1481,14 @@ void ipMapArpSemaGive(ipMapArpLockCtrl_t
 
   l7utilsFilenameStrip(&file);
 
   if ((rc = osapiSemaGive(pLock->semId)) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ARP_MAP_COMPONENT_ID,
-            "Semaphore give failure for file %s:%lu, rc=%u, id=0x%8.8x\n",
-            file, line, rc, (L7_uint32)pLock->semId);
+            "Semaphore give failure for file %s:%lu, rc=%u, id=%p\n",
+            file, line, rc, pLock->semId);
   }
 
   ARP_LOCK_DEBUG_LOG(file, line, pLock->semId);
 }
 
 /*********************************************************************
@@ -1650,14 +1650,14 @@ void ipMapArpTraceShow(L7_uint32 amt)
 *********************************************************************/
 void ipMapArpLockShow(void)
 {
   ipMapArpLockCtrl_t  *pLock = &ipMapArpCtx_g.arpLock;
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  ARP Component Lock:\n");
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    lock info      semId=0x%x  owner task=0x%x  owner lock count=%ld  lkTot=%lu  unlkTot=%lu\n",
-        (L7_uint32)pLock->semId, (L7_uint32)pLock->ownerTaskId, pLock->ownerLockCount,
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    lock info      semId=0x%llx  owner task=0x%llx  owner lock count=%ld  lkTot=%lu  unlkTot=%lu\n",
+        PTR_TO_UINT64(pLock->semId), pLock->ownerTaskId, pLock->ownerLockCount,
         pLock->lockTotal, pLock->unlockTotal);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    owner at %s:%u\n", pLock->ownerFile, pLock->ownerLine);
 }
 
 
 /*********************************************************************
@@ -1675,53 +1675,53 @@ void ipMapArpCtxShow(void)
 {
   ipMapArpCtx_t *pCtx = &ipMapArpCtx_g;
   ipMapArpLockCtrl_t  *pLock;
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "\nIPMAP ARP Global Context Contents\n");
 
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  arpHandle       = 0x%8.8x\n",
-              (L7_uint32)pCtx->arpHandle);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  regUserId        = 0x%8.8x\n",
-              (L7_uint32)pCtx->regUserId);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  pIntfList        = 0x%8.8x\n",
-              (L7_uint32)pCtx->pIntfList);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  arpHandle       = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->arpHandle));
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  regUserId        = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->regUserId));
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  pIntfList        = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->pIntfList));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  Reissue Task:\n");
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%8.8x\n",
-              (L7_uint32)pCtx->reissue.taskId);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    pMsgQ          = 0x%8.8x\n",
-              (L7_uint32)pCtx->reissue.pMsgQ);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%llx\n",
+              pCtx->reissue.taskId);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    pMsgQ          = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->reissue.pMsgQ));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    totalCt        = %u\n",
               (L7_uint32)pCtx->reissue.totalCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    peakCt         = %u\n",
               (L7_uint32)pCtx->reissue.peakCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    maxCt          = %u\n",
               (L7_uint32)pCtx->reissue.maxCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    fullQCt        = %u\n",
               (L7_uint32)pCtx->reissue.fullQCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    failCt         = %u\n",
               (L7_uint32)pCtx->reissue.failCt);
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  Callback Task:\n");
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%8.8x\n",
-              (L7_uint32)pCtx->callback.taskId);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    pMsgQ          = 0x%8.8x\n",
-              (L7_uint32)pCtx->callback.pMsgQ);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%llx\n",
+              pCtx->callback.taskId);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    pMsgQ          = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->callback.pMsgQ));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    totalCt        = %u\n",
               (L7_uint32)pCtx->callback.totalCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    peakCt         = %u\n",
               (L7_uint32)pCtx->callback.peakCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    maxCt          = %u\n",
               (L7_uint32)pCtx->callback.maxCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    fullQCt        = %u\n",
               (L7_uint32)pCtx->callback.fullQCt);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    failCt         = %u\n",
               (L7_uint32)pCtx->callback.failCt);
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  Timer Expire (XX) Task:\n");
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%8.8x\n",
-              (L7_uint32)pCtx->timerExp.taskId);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    taskId         = 0x%llx\n",
+              pCtx->timerExp.taskId);
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  routingStarted      = %s\n",
               (ipMapRoutingStarted == L7_TRUE) ? "True" : "False");
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  msgLvl           = %u\n",
               pCtx->msgLvl);
 
@@ -1743,36 +1743,36 @@ void ipMapArpCtxShow(void)
               pCtx->inTgtDiscard);
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  Gateway Table:\n");
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    treeEntryMax   = %u\n",
               pCtx->gwTbl.treeEntryMax);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *treeHeap      = 0x%8.8x\n",
-              (L7_uint32)pCtx->gwTbl.treeHeap);
+              PTR_TO_UINT64(pCtx->gwTbl.treeHeap));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    treeHeapSize   = %u\n",
               pCtx->gwTbl.treeHeapSize);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *dataHeap      = 0x%8.8x\n",
-              (L7_uint32)pCtx->gwTbl.dataHeap);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *dataHeap      = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->gwTbl.dataHeap));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    dataHeapSize   = %u\n",
               pCtx->gwTbl.dataHeapSize);
 
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  IP Lookup Table:\n");
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    treeEntryMax   = %u\n",
               pCtx->ipTbl.treeEntryMax);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *treeHeap      = 0x%8.8x\n",
-              (L7_uint32)pCtx->ipTbl.treeHeap);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *treeHeap      = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->ipTbl.treeHeap));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    treeHeapSize   = %u\n",
               pCtx->ipTbl.treeHeapSize);
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *dataHeap      = 0x%8.8x\n",
-              (L7_uint32)pCtx->ipTbl.dataHeap);
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    *dataHeap      = 0x%llx\n",
+              PTR_TO_UINT64(pCtx->ipTbl.dataHeap));
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    dataHeapSize   = %u\n",
               pCtx->ipTbl.dataHeapSize);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "\n");
   pLock = &pCtx->arpLock;
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "  ARP Component Lock:\n");
-  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    lock info      semId=0x%x  owner task=0x%x  owner lock count=%ld  lkTot=%lu  unlkTot=%lu\n",
-              (L7_uint32)pLock->semId, (L7_uint32)pLock->ownerTaskId, pLock->ownerLockCount,
+  IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    lock info      semId=0x%llx  owner task=0x%llx  owner lock count=%ld  lkTot=%lu  unlkTot=%lu\n",
+              PTR_TO_UINT64(pLock->semId), pLock->ownerTaskId, pLock->ownerLockCount,
               pLock->lockTotal, pLock->unlockTotal);
   IPM_ARP_PRT(IPM_ARP_MSGLVL_ON, "    owner at %s:%u\n", pLock->ownerFile, pLock->ownerLine);
 
   ARP_ObjectInfoShow(ipMapArpCtx_g.arpHandle);
 }
 
@@ -1827,13 +1827,13 @@ void ipMapArpAllShow(L7_uint32 amt)
 *
 * @end
 *********************************************************************/
 L7_RC_t ipMapArpAddrResolveInternal(L7_uint32 intIfNum, L7_uint32 ipAddr,
                                     L7_uchar8 *pMacAddr,
                                     ipMapArpResCallback_ft pCallbackFn,
-                                    L7_uint32 cbParm1, L7_uint32 cbParm2)
+                                    L7_uint64 cbParm1, L7_uint64 cbParm2)
 {
   ipMapArpIntf_t  *pIntf;
   t_ARPResInfo  arpResInfo;
   ipMapArpResCallbackParms_t  *pCbInfo;
   L7_uint32 netOrderIpAddr = osapiHtonl(ipAddr);
   e_Err         erc;
Index: src/application/routing/mapping/ospfmap/core/ospf_vend_ctrl.c
===================================================================
--- src/application/routing/mapping/ospfmap/core/ospf_vend_ctrl.c	(revision 7772)
+++ src/application/routing/mapping/ospfmap/core/ospf_vend_ctrl.c	(revision 7778)
@@ -2666,13 +2666,13 @@ static e_Err sockReceive(t_Handle userId
 
 
 static void sockStatus( t_Handle userId,     /* User Id of connection */
                         t_Handle connId,     /* Connection Idreturned by TcpUdpBind_Open */
                         word status)         /* Connection status flags */
 {
-  OSPFMAP_TRACE("Socket 0x%8.8X status is %ld\n", (unsigned int)connId, (ulng)status);
+  OSPFMAP_TRACE("Socket 0x%llX status is %ld\n", PTR_TO_UINT64(connId), (ulng)status);
 }
 
 
 /*********************************************************************
 * @purpose  Creates the OSPF socket
 *
Index: src/application/routing/mapping/ospfmap/core/ospfmap_debug.c
===================================================================
--- src/application/routing/mapping/ospfmap/core/ospfmap_debug.c	(revision 7772)
+++ src/application/routing/mapping/ospfmap/core/ospfmap_debug.c	(revision 7778)
@@ -43,13 +43,13 @@ extern struct ospfMapCtrl_s  ospfMapCtrl
 /* Debug functions */
 extern L7_RC_t usmDbInetAton(L7_uchar8 *ipAddr, L7_uint32 *val);
 extern t_IFO * ifoPtrGet(L7_uint32 intIfNum);
 extern L7_RC_t ifoAuthKeyCfgGet(L7_uint32 intIfNum, t_OspfAuthKey *p_Auth);
 extern L7_RC_t virtIfAuthKeyCfgGet(t_Handle IFO_Id, t_OspfAuthKey *p_Auth);
 extern void XX_DisplayQueue(t_Handle threadID, ulng queueId, ulng resolveNames, long maxDepth);
-extern void osapiDebugStackTrace (L7_uint32 task_id, FILE *fp);
+extern void osapiDebugStackTrace (L7_uint64 task_id, FILE *fp);
 
 
 static void ospfRedistCfgBuildTestConfigData(ospfRedistCfg_t *redistCfg, L7_uint32 seed);
 static void ospfDefaultRouteCfgBuildTestConfigData(ospfDefRouteCfg_t *defRouteCfg);
 static void ospfAreaStubCfgDataShow(void);
 static void ospfAreaNssaCfgDataShow(void);
@@ -779,15 +779,15 @@ void ospfMapExtenIFOShow(L7_uint32 unit,
       else
       {
         SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTaken......................................false");
       }
       osapiInetNtoa((L7_uint32)p_IFO->IfoId, debug_buf);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIfoId......................................0x%x  (%-15.15s)", (L7_uint32)p_IFO->IfoId, debug_buf);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLowLayerId.................................0x%x", (L7_uint32)p_IFO->LowLayerId);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nARO_Id.....................................0x%x", (L7_uint32)p_IFO->ARO_Id);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.....................................0x%x", (L7_uint32)p_IFO->RTO_Id);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLowLayerId.................................%p", p_IFO->LowLayerId);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nARO_Id.....................................%p", p_IFO->ARO_Id);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.....................................%p", p_IFO->RTO_Id);
 
       memset(&ifoCfg, 0, sizeof(t_IFO_Cfg));
       memcpy(&ifoCfg, &p_IFO->Cfg, sizeof(t_IFO_Cfg));
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nIFO config Data:");
 
       osapiInetNtoa((L7_uint32)ifoCfg.IpAdr, debug_buf);
@@ -1137,25 +1137,25 @@ void ospfMapExtenIFOShow(L7_uint32 unit,
 
       osapiInetNtoa((L7_uint32)p_IFO->DrId, debug_buf);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nDrId.......................................%-15.15s", debug_buf);
 
       osapiInetNtoa((L7_uint32)p_IFO->BackupId, debug_buf);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nBackupId...................................%-15.15s", debug_buf);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTransitARO.................................0x%x", (L7_uint32)p_IFO->TransitARO);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTransitARO.................................%p", p_IFO->TransitARO);
 
       osapiInetNtoa((L7_uint32)p_IFO->VrtNgbIpAdr, debug_buf);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nVrtNgbIpAdr................................%-15.15s", debug_buf);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nVirtIfIndex................................%u", (L7_uint32)p_IFO->VirtIfIndex);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHelloTimer.................................0x%x", (L7_uint32)p_IFO->HelloTimer);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nWaitTimer..................................0x%x", (L7_uint32)p_IFO->WaitTimer);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNboHl......................................0x%x", (L7_uint32)p_IFO->NboHl);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsAck......................................0x%x", (L7_uint32)p_IFO->LsAck);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAckTimer...................................0x%x", (L7_uint32)p_IFO->AckTimer);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMetricHl...................................0x%x", (L7_uint32)p_IFO->MetricHl);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNbmaHl.....................................0x%x", (L7_uint32)p_IFO->NbmaHl);
-      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAuthKeyHl..................................0x%x", (L7_uint32)p_IFO->AuthKeyHl);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHelloTimer.................................%p", p_IFO->HelloTimer);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nWaitTimer..................................%p", p_IFO->WaitTimer);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNboHl......................................%p", p_IFO->NboHl);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsAck......................................%p", p_IFO->LsAck);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAckTimer...................................%p", p_IFO->AckTimer);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMetricHl...................................%p", p_IFO->MetricHl);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNbmaHl.....................................%p", p_IFO->NbmaHl);
+      SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAuthKeyHl..................................%p", p_IFO->AuthKeyHl);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTimeStamp..................................%u", (L7_uint32)p_IFO->TimeStamp);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nCfgMetric..................................%u", (L7_uint32)p_IFO->CfgMetric);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nPacket Statistics:");
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\tRxPackets....................%u", (L7_uint32)p_IFO->PckStats.RxPackets);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\tDiscardPackets...............%u", (L7_uint32)p_IFO->PckStats.DiscardPackets);
       SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\tBadVersion...................%u", (L7_uint32)p_IFO->PckStats.BadVersion);
@@ -1295,13 +1295,13 @@ void ospfMapExtenRTOShow(void)
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTaken......................................true");
   }
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTaken......................................false");
   }
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId......................................0x%x", (L7_uint32)p_RTO->MngId);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId......................................%p", p_RTO->MngId);
 
   memset(&rtrCfg, 0, sizeof(t_S_RouterCfg));
   memcpy(&rtrCfg, &p_RTO->Cfg, sizeof(t_S_RouterCfg));
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nRTO config Data:");
 
   osapiInetNtoa((L7_uint32)rtrCfg.RouterId, debug_buf);
@@ -1408,14 +1408,14 @@ void ospfMapExtenRTOShow(void)
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\tRouterStatus.....................rowModify");
     break;
   default:
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\tRouterStatus.....................unknown");
     break;
   }
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nOspfSysLabel...............................0x%x", (L7_uint32)p_RTO->OspfSysLabel.threadHndle);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfRtbThread..............................0x%x", (L7_uint32)p_RTO->OspfRtbThread.threadHndle);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\n\nOspfSysLabel...............................%p", p_RTO->OspfSysLabel.threadHndle);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfRtbThread..............................%p", p_RTO->OspfRtbThread.threadHndle);
   if (p_RTO->RtbOwnThread == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRtbOwnThread...............................true");
   }
   else
   {
@@ -1427,31 +1427,31 @@ void ospfMapExtenRTOShow(void)
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIsOverflowed...............................true");
   }
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIsOverflowed...............................false");
   }
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOverflowTimer..............................0x%x", (L7_uint32)p_RTO->OverflowTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOverflowTimer..............................%p", p_RTO->OverflowTimer);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nnonDefExtLsaCount..........................0x%x", (L7_uint32)p_RTO->NonDefExtLsaCount);
   
   if (p_RTO->LsdbOverload == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsdbOverload...............................true");
   }
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsdbOverload...............................false");
   }
   
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsExtRoutesHl..............................0x%x", (L7_uint32)p_RTO->AsExtRoutesHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsExternalLsaHl............................0x%x", (L7_uint32)p_RTO->AsExternalLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsOpaqueLsaHl..............................0x%x", (L7_uint32)p_RTO->AsOpaqueLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRtbHl......................................0x%x", (L7_uint32)p_RTO->RtbHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIfoIndexHl.................................0x%x", (L7_uint32)p_RTO->IfoIndexHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nFaIndexHl..................................0x%x", (L7_uint32)p_RTO->FaIndexHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAroHl......................................0x%x", (L7_uint32)p_RTO->AroHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsExtRoutesHl..............................%p", p_RTO->AsExtRoutesHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsExternalLsaHl............................%p", p_RTO->AsExternalLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsOpaqueLsaHl..............................%p", p_RTO->AsOpaqueLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRtbHl......................................%p", p_RTO->RtbHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIfoIndexHl.................................%p", p_RTO->IfoIndexHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nFaIndexHl..................................%p", p_RTO->FaIndexHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAroHl......................................%p", p_RTO->AroHl);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreasNum...................................%u", (L7_uint32)p_RTO->AreasNum);
 }
 
 /*********************************************************************
 * @purpose  debug function to dump the list of prefixes in AsExtRoutesHl
 *
@@ -1631,28 +1631,28 @@ void ospfMapExtenAROShow(L7_uint32 areaI
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOperationState...............................true");
   }
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOperationState...............................false");
   }
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.......................................0x%x", (L7_uint32)p_ARO->RTO_Id);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.......................................%p", p_ARO->RTO_Id);
 
   osapiInetNtoa((L7_uint32)p_ARO->AreaId, debug_buf);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaId.......................................%-15.15s", debug_buf);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId........................................0x%x", (L7_uint32)p_ARO->MngId);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIfoHl........................................0x%x", (L7_uint32)p_ARO->IfoHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAdrRangeHl...................................0x%x", (L7_uint32)p_ARO->AdrRangeHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHostHl.......................................0x%x", (L7_uint32)p_ARO->HostHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRouterLsaHl..................................0x%x", (L7_uint32)p_ARO->RouterLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNetworkLsaHl.................................0x%x", (L7_uint32)p_ARO->NetworkLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNetSummaryLsaHl..............................0x%x", (L7_uint32)p_ARO->NetSummaryLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsBoundSummaryLsaHl..........................0x%x", (L7_uint32)p_ARO->AsBoundSummaryLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNssaLsaHl....................................0x%x", (L7_uint32)p_ARO->NssaLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaOpaqueLsaHl..............................0x%x", (L7_uint32)p_ARO->AreaOpaqueLsaHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nSpfHl........................................0x%x", (L7_uint32)p_ARO->SpfHl);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nCandidateHl..................................0x%x", (L7_uint32)p_ARO->CandidateHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId........................................%p", p_ARO->MngId);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIfoHl........................................%p", p_ARO->IfoHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAdrRangeHl...................................%p", p_ARO->AdrRangeHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHostHl.......................................%p", p_ARO->HostHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRouterLsaHl..................................%p", p_ARO->RouterLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNetworkLsaHl.................................%p", p_ARO->NetworkLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNetSummaryLsaHl..............................%p", p_ARO->NetSummaryLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsBoundSummaryLsaHl..........................%p", p_ARO->AsBoundSummaryLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nNssaLsaHl....................................%p", p_ARO->NssaLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaOpaqueLsaHl..............................%p", p_ARO->AreaOpaqueLsaHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nSpfHl........................................%p", p_ARO->SpfHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nCandidateHl..................................%p", p_ARO->CandidateHl);
 
   if (p_ARO->TransitCapability == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nTransitCapability............................true");
   }
   else
@@ -1673,13 +1673,13 @@ void ospfMapExtenAROShow(L7_uint32 areaI
     break;
   default:
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nExternalRoutingCapability....................unknown");
     break;
   }
 
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nStubDefaultCostHl............................0x%x", (L7_uint32)p_ARO->StubDefaultCostHl);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nStubDefaultCostHl............................%p", p_ARO->StubDefaultCostHl);
 
   switch (p_ARO->ImportSummaries)
   {
   case TRUE:
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nImportSummaries..............................True");
     break;
@@ -1695,14 +1695,14 @@ void ospfMapExtenAROShow(L7_uint32 areaI
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nSpfRuns......................................%u", (L7_uint32)p_ARO->SpfRuns);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaBdrRtrCount..............................%u", (L7_uint32)p_ARO->AreaBdrRtrCount);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAsBdrRtrCount................................%u", (L7_uint32)p_ARO->AsBdrRtrCount);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaIntRtrCount..............................%u", (L7_uint32)p_ARO->AreaIntRtrCount);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaLsaCount.................................%u", (L7_uint32)p_ARO->AreaLsaCount);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nAreaLsaCksumSum..............................%u", (L7_uint32)p_ARO->AreaLsaCksumSum);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDelayedLsa...................................0x%x", (L7_uint32)p_ARO->DelayedLsa);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDlyLsaTimer..................................0x%x", (L7_uint32)p_ARO->DlyLsaTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDelayedLsa...................................%p", p_ARO->DelayedLsa);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDlyLsaTimer..................................%p", p_ARO->DlyLsaTimer);
   
 #if 0  
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMcSpfRuns....................................%u", (L7_uint32)p_ARO->McSpfRuns);
 
   switch (p_ARO->McInitCase)
   {
@@ -1724,13 +1724,13 @@ void ospfMapExtenAROShow(L7_uint32 areaI
   default:
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMcInitCase...................................unknown");
     break;
   }
 #endif
 
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfSysLabel.................................0x%x", (L7_uint32)p_ARO->OspfSysLabel.threadHndle);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfSysLabel.................................%p", p_ARO->OspfSysLabel.threadHndle);
 
   if (p_ARO->HasVirtLink == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHasVirtLink..................................true");
   }
   else
@@ -1875,21 +1875,21 @@ void ospfDebugNBOShowPtr(t_NBO * p_NBO)
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOperationState.............................false");
   }
 
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nState......................................%u", (L7_uint32)p_NBO->State);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIFO_Id.....................................0x%x", (L7_uint32)p_NBO->IFO_Id);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.....................................0x%x", (L7_uint32)p_NBO->RTO_Id);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nARO_Id.....................................0x%x", (L7_uint32)p_NBO->ARO_Id);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId......................................0x%x", (L7_uint32)p_NBO->MngId);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nInactivityTimer............................0x%x", (L7_uint32)p_NBO->InactivityTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIFO_Id.....................................%p", p_NBO->IFO_Id);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRTO_Id.....................................%p", p_NBO->RTO_Id);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nARO_Id.....................................%p", p_NBO->ARO_Id);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nMngId......................................%p", p_NBO->MngId);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nInactivityTimer............................%p", p_NBO->InactivityTimer);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nInactivityInterval.........................%u", (L7_uint32)p_NBO->InactivityInterval);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDdRxmtTimer................................0x%x", (L7_uint32)p_NBO->DdRxmtTimer);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRqRxmtTimer................................0x%x", (L7_uint32)p_NBO->RqRxmtTimer);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nSlaveLastDdTimer...........................0x%x", (L7_uint32)p_NBO->SlaveLastDdTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDdRxmtTimer................................%p", p_NBO->DdRxmtTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRqRxmtTimer................................%p", p_NBO->RqRxmtTimer);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nSlaveLastDdTimer...........................%p", p_NBO->SlaveLastDdTimer);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nRxmtInterval...............................%u", (L7_uint32)p_NBO->RxmtInterval);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nHloIntCount................................%u", (L7_uint32)p_NBO->HloIntCount);
 
   if (p_NBO->IsMaster == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nIsMaster...................................true");
@@ -1924,15 +1924,15 @@ void ospfDebugNBOShowPtr(t_NBO * p_NBO)
 
   osapiInetNtoa((L7_uint32)p_NBO->DrId, debug_buf);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDrId.......................................%-15.15s", debug_buf);
 
   osapiInetNtoa((L7_uint32)p_NBO->BackupId, debug_buf);
   SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nBackupId...................................%-15.15s", debug_buf);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLeReTx.....................................0x%x", (L7_uint32)p_NBO->LsReTx);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDbSum......................................0x%x", (L7_uint32)p_NBO->DbSum);
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsReq......................................0x%x", (L7_uint32)p_NBO->LsReq);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLeReTx.....................................%p", p_NBO->LsReTx);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nDbSum......................................%p", p_NBO->DbSum);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nLsReq......................................%p", p_NBO->LsReq);
 
   if (p_NBO->ExchOrLoadState == TRUE)
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nExchOrLoadState............................true");
   }
   else
@@ -1973,13 +1973,13 @@ void ospfDebugNBOShowPtr(t_NBO * p_NBO)
   }
   else
   {
     SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nInitDDSent.................................false");
   }
 
-  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfSysLabel...............................0x%x", (L7_uint32)p_NBO->OspfSysLabel.threadHndle);
+  SYSAPI_PRINTF( SYSAPI_APPLICATION_LOGGING_OSPFMAP,  "\nOspfSysLabel...............................%p", p_NBO->OspfSysLabel.threadHndle);
 }
 
 /*********************************************************************
 * @purpose  debug function to dump the specified NBO structure onto
 *           the screen
 *
@@ -2235,13 +2235,13 @@ void ospfMapNetworkAreaShow()
 *********************************************************************/
 void ospfMsgQLen(L7_uint32 detail)
 {
   L7_int32 i, msgQLen = 0;
   OS_Thread *threadId = (OS_Thread*) ospfMapCtrl_g.ospfThread;
 
-  printf("\nOSPF protocol thread ID:  %#x", (unsigned int) threadId);
+  printf("\nOSPF protocol thread ID: %p", threadId);
   for(i = 0; i < OSPF_NUM_QUEUES; i++)
   {
     if (osapiMsgQueueGetNumMsgs((void*)threadId->QueueID[i], &msgQLen) == L7_SUCCESS)
     {
       SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_OSPFMAP, 
                     "\nOSPF %s (Q%d) length:  %d", 
@@ -2692,13 +2692,13 @@ void ospfOpaqueCapabilitySet(void)
 }
 
 void ospfStackTrace(void)
 {
   OS_Thread		*pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-	osapiDebugStackTrace((L7_int32) pThreadGlobal->TaskID, NULL);
+	osapiDebugStackTrace(pThreadGlobal->TaskID, NULL);
 }
 
 
 /*============================================================================*/
 /*========================  END OF CONFIG MIGRATION DEBUG CHANGES ============*/
 /*============================================================================*/
Index: src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c
===================================================================
--- src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c	(revision 7772)
+++ src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c	(revision 7778)
@@ -1615,19 +1615,19 @@ static e_Err ospfMapExtenIntfAreaIdSet(v
 * @end
 *********************************************************************/
 L7_RC_t ospfMapExtenIntfAreaIdPack(L7_uint32 intIfNum, L7_uint32 area)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     PACKET_INIT(xxci, ospfMapExtenIntfAreaIdSet, 0, 0, 3, (ulng)intIfNum);
     PACKET_PUT(xxci, (ulng)area);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -1655,13 +1655,13 @@ L7_RC_t ospfMapExtenIntfAreaIdPack(L7_ui
     {
         PACKET_PUT(xxci, (ulng) 0);
         e = ospfMapExtenIntfAreaIdSet(xxci);
         XX_Free(xxci);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread !=  pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return L7_SUCCESS;
 }
@@ -7328,21 +7328,21 @@ L7_RC_t ospfMapExtenAreaStubAreaSet(L7_u
 e_Err ospfAbrEntry_Lookup_Pack(L7_uint32 destinationIp,
                                L7_RtbEntryInfo_t *p_rtbEntry)
 {
   t_XXCallInfo  *xxci;      /* XX_Call info */
   e_Err         e;
   L7_RC_t       rc = L7_FAILURE;
-  L7_int32      currThread = osapiTaskIdSelf();
+  L7_uint64      currThread = osapiTaskIdSelf();
   OS_Thread     *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   if(p_rtbEntry == NULL)
   {
     return E_FAILED;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -7370,13 +7370,13 @@ e_Err ospfAbrEntry_Lookup_Pack(L7_uint32
   }
   else
   {
     rc = ospfAbrEntry_Lookup(destinationIp, p_rtbEntry);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -7399,21 +7399,21 @@ e_Err ospfAbrEntry_Lookup_Pack(L7_uint32
 e_Err ospfAsbrEntry_Lookup_Pack(L7_uint32 destinationIp,
                                 L7_RtbEntryInfo_t *p_rtbEntry)
 {
   t_XXCallInfo  *xxci;      /* XX_Call info */
   e_Err         e;
   L7_RC_t       rc = L7_FAILURE;
-  L7_int32      currThread = osapiTaskIdSelf();
+  L7_uint64     currThread = osapiTaskIdSelf();
   OS_Thread     *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   if(p_rtbEntry == NULL)
   {
     return E_FAILED;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -7441,13 +7441,13 @@ e_Err ospfAsbrEntry_Lookup_Pack(L7_uint3
   }
   else
   {
     rc = ospfAsbrEntry_Lookup(destinationIp, p_rtbEntry);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -7648,30 +7648,30 @@ L7_RC_t ospfMapExtenAsbrEntryGet ( L7_ui
 e_Err ospfAbrEntryNext_Pack(L7_uint32 *destinationIp,
                             L7_RtbEntryInfo_t *p_rtbEntry)
 {
   t_XXCallInfo  *xxci;      /* XX_Call info */
   e_Err         e;
   L7_RC_t       rc = L7_FAILURE;
-  L7_int32      currThread = osapiTaskIdSelf();
+  L7_uint64     currThread = osapiTaskIdSelf();
   OS_Thread     *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   if(p_rtbEntry == NULL)
   {
     return E_FAILED;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
     }
 
-    PACKET_INIT(xxci, ospfAbrEntryNext_UnPack, 0, 0, 3, (L7_uint32)destinationIp);
+    PACKET_INIT(xxci, ospfAbrEntryNext_UnPack, 0, 0, 3, PTR_TO_UINT32(destinationIp));
     PACKET_PUT(xxci, (L7_RtbEntryInfo_t *)p_rtbEntry);
     PACKET_PUT(xxci, (L7_RC_t *)&rc);
     e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
 
     if (e != E_OK)
     {
@@ -7690,13 +7690,13 @@ e_Err ospfAbrEntryNext_Pack(L7_uint32 *d
   }
   else
   {
     rc = ospfAbrEntryNext(destinationIp, p_rtbEntry);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -7719,30 +7719,30 @@ e_Err ospfAbrEntryNext_Pack(L7_uint32 *d
 e_Err ospfAsbrEntryNext_Pack(L7_uint32 *destinationIp,
                              L7_RtbEntryInfo_t *p_rtbEntry)
 {
   t_XXCallInfo  *xxci;      /* XX_Call info */
   e_Err         e;
   L7_RC_t       rc = L7_FAILURE;
-  L7_int32      currThread = osapiTaskIdSelf();
+  L7_uint64     currThread = osapiTaskIdSelf();
   OS_Thread     *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   if(p_rtbEntry == NULL)
   {
     return E_FAILED;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
     }
 
-    PACKET_INIT(xxci, ospfAsbrEntryNext_UnPack, 0, 0, 3, (L7_uint32)destinationIp);
+    PACKET_INIT(xxci, ospfAsbrEntryNext_UnPack, 0, 0, 3, PTR_TO_UINT32(destinationIp));
     PACKET_PUT(xxci, (L7_RtbEntryInfo_t *)p_rtbEntry);
     PACKET_PUT(xxci, (L7_RC_t *)&rc);
     e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
 
     if (e != E_OK)
     {
@@ -7761,13 +7761,13 @@ e_Err ospfAsbrEntryNext_Pack(L7_uint32 *
   }
   else
   {
     rc = ospfAsbrEntryNext(destinationIp, p_rtbEntry);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -12113,26 +12113,26 @@ e_Err RTO_Config_Pack(t_Handle RTO_Id, t
 {
     t_S_RouterCfg   *p_rtoCfg;  /* ospf router object configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     void            *p_info;
     int             numOfMsgs = 0, i;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the router configuration info */
     p_rtoCfg = XX_Malloc(sizeof(t_S_RouterCfg));
     if (!p_rtoCfg)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_rtoCfg, p_Cfg, sizeof(t_S_RouterCfg));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_rtoCfg);
@@ -12186,13 +12186,13 @@ e_Err RTO_Config_Pack(t_Handle RTO_Id, t
     }
   }
 
     memcpy(p_Cfg, p_rtoCfg, sizeof(t_S_RouterCfg));
     XX_Free(p_rtoCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -12258,13 +12258,13 @@ static e_Err IFO_Config_Unpack(void *p_I
 *********************************************************************/
 e_Err IFO_Config_Pack(t_Handle IFO_Id, t_IFO_Cfg *p_Cfg)
 {
     t_IFO_Cfg       *p_ifoCfg;  /* interface configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the interface configuration info */
     p_ifoCfg = XX_Malloc(sizeof(t_IFO_Cfg));
 
     if (!p_ifoCfg)
@@ -12272,13 +12272,13 @@ e_Err IFO_Config_Pack(t_Handle IFO_Id, t
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_ifoCfg, p_Cfg, sizeof(t_IFO_Cfg));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_ifoCfg);
@@ -12310,13 +12310,13 @@ e_Err IFO_Config_Pack(t_Handle IFO_Id, t
         e = IFO_Config(IFO_Id, p_ifoCfg);
     }
 
     memcpy(p_Cfg, p_ifoCfg, sizeof(t_IFO_Cfg));
     XX_Free(p_ifoCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -12367,26 +12367,26 @@ static e_Err ARO_Config_Unpack(void *p_I
 *********************************************************************/
 e_Err ARO_Config_Pack(t_Handle ARO_Id, t_S_AreaCfg *p_Cfg)
 {
     t_S_AreaCfg     *p_aroCfg;  /* ospf area configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the area configuration info */
     p_aroCfg = XX_Malloc(sizeof(t_S_AreaCfg));
     if (!p_aroCfg)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_aroCfg, p_Cfg, sizeof(t_S_AreaCfg));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_aroCfg);
@@ -12418,13 +12418,13 @@ e_Err ARO_Config_Pack(t_Handle ARO_Id, t
         e = ARO_Config(ARO_Id, p_aroCfg);
     }
 
     memcpy(p_Cfg, p_aroCfg, sizeof(t_S_AreaCfg));
     XX_Free(p_aroCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -12558,22 +12558,22 @@ e_Err ospfLsdbAdvertisement_Lookup_Pack(
                                         L7_ospfLsdbEntry_t *p_Lsa,
                                         L7_char8 **p_LsdbAdvertisement)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(p_Lsa == NULL)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -12609,13 +12609,13 @@ e_Err ospfLsdbAdvertisement_Lookup_Pack(
         rc = ospfLsdbAdvertisement_Lookup(LsdbAreaId, LsdbType,
                           LsdbId, LsdbRouterId,
                           p_Lsa,
                           p_LsdbAdvertisement);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -12643,22 +12643,22 @@ e_Err ospfLsdbTable_Lookup_Pack(L7_uint3
                                 L7_uint32 LsdbRouterId,
                                 L7_ospfLsdbEntry_t *p_Lsa)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(p_Lsa == NULL)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -12689,13 +12689,13 @@ e_Err ospfLsdbTable_Lookup_Pack(L7_uint3
     }
     else
     {
         rc = ospfLsdbTable_Lookup(LsdbAreaId, LsdbType, LsdbId, LsdbRouterId, p_Lsa);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -12755,31 +12755,31 @@ e_Err ospfLsdbTable_GetNext_Pack(L7_uint
                                  L7_uint32 *RouterId,
                                  L7_ospfLsdbEntry_t *p_Lsa)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(p_Lsa == NULL)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
         }
 
-        PACKET_INIT(xxci, ospfLsdbTable_GetNext_Unpack, 0, 0, 6, (L7_uint32)areaId);
+        PACKET_INIT(xxci, ospfLsdbTable_GetNext_Unpack, 0, 0, 6, PTR_TO_UINT32(areaId));
         PACKET_PUT(xxci, (L7_uint32 *)Type);
         PACKET_PUT(xxci, (L7_uint32 *)Lsid);
         PACKET_PUT(xxci, (L7_uint32 *)RouterId);
         PACKET_PUT(xxci, (L7_ospfLsdbEntry_t *)p_Lsa);
         PACKET_PUT(xxci, (L7_RC_t *)&rc);
         e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
@@ -12801,13 +12801,13 @@ e_Err ospfLsdbTable_GetNext_Pack(L7_uint
     }
     else
     {
         rc = ospfLsdbTable_GetNext(areaId, Type, Lsid, RouterId, p_Lsa);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -12867,22 +12867,22 @@ e_Err ospfExtLsdbAdvertisement_Lookup_Pa
                                            L7_ospfLsdbEntry_t *p_Lsa,
                                            L7_char8 **p_LsdbAdvertisement)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(p_Lsa == NULL)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -12916,13 +12916,13 @@ e_Err ospfExtLsdbAdvertisement_Lookup_Pa
     {
         rc = ospfExtLsdbAdvertisement_Lookup(LsdbType, LsdbId, LsdbRouterId,
                                  p_Lsa,
                              p_LsdbAdvertisement);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -12946,22 +12946,22 @@ e_Err ospfExtLsdbTable_Lookup_Pack(L7_ui
                                    L7_uint32 LsdbRouterId,
                                    L7_ospfLsdbEntry_t *p_Lsa)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(p_Lsa == NULL)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -12991,13 +12991,13 @@ e_Err ospfExtLsdbTable_Lookup_Pack(L7_ui
     }
     else
     {
         rc = ospfExtLsdbTable_Lookup(LsdbType, LsdbId, LsdbRouterId, p_Lsa);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -13055,31 +13055,31 @@ e_Err ospfExtLsdbTable_GetNext_Pack(L7_u
                                     L7_uint32 *RouterId,
                                     L7_ospfLsdbEntry_t *p_Lsa)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
     L7_RC_t         rc = L7_FAILURE;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
     L7_ospfLsdbEntry_t  temp_Lsa;
 
     if(! p_Lsa)
     {
         p_Lsa = &temp_Lsa;
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
         }
 
-        PACKET_INIT(xxci, ospfExtLsdbTable_GetNext_Unpack, 0, 0, 5, (L7_uint32)Type);
+        PACKET_INIT(xxci, ospfExtLsdbTable_GetNext_Unpack, 0, 0, 5, PTR_TO_UINT32(Type));
         PACKET_PUT(xxci, (L7_uint32 *)Lsid);
         PACKET_PUT(xxci, (L7_uint32 *)RouterId);
         PACKET_PUT(xxci, (L7_ospfLsdbEntry_t *)p_Lsa);
         PACKET_PUT(xxci, (L7_RC_t *)&rc);
         e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
 
@@ -13100,13 +13100,13 @@ e_Err ospfExtLsdbTable_GetNext_Pack(L7_u
     }
     else
     {
         rc = ospfExtLsdbTable_GetNext(Type, Lsid, RouterId, p_Lsa);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -13157,26 +13157,26 @@ static e_Err NBO_Config_Unpack(void *p_I
 *********************************************************************/
 e_Err NBO_Config_Pack(t_Handle NBO_Id, t_S_NeighborCfg *p_Cfg)
 {
     t_S_NeighborCfg *p_nboCfg;  /* ospf neighbor configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the neighbor configuration info */
     p_nboCfg = XX_Malloc(sizeof(t_S_NeighborCfg));
     if (!p_nboCfg)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_nboCfg, p_Cfg, sizeof(t_S_NeighborCfg));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_nboCfg);
@@ -13208,13 +13208,13 @@ e_Err NBO_Config_Pack(t_Handle NBO_Id, t
         e = NBO_Config(NBO_Id, p_nboCfg);
     }
 
     memcpy(p_Cfg, p_nboCfg, sizeof(t_S_NeighborCfg));
     XX_Free(p_nboCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13265,13 +13265,13 @@ static e_Err RTO_AsExternalCfg_Unpack(vo
 *********************************************************************/
 e_Err RTO_AsExternalCfg_Pack(t_Handle RTO_Id, t_S_AsExternalCfg *p_Cfg)
 {
   t_S_AsExternalCfg *p_asExtCfg;  /* ospf router object configuration info */
   t_XXCallInfo      *xxci;        /* XX_Call info */
   e_Err             e;
-  L7_int32          currThread = osapiTaskIdSelf();
+  L7_uint64         currThread = osapiTaskIdSelf();
   OS_Thread         *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   /* Fill in the router configuration info */
   p_asExtCfg = XX_Malloc(sizeof(t_S_AsExternalCfg));
   if(!p_asExtCfg)
     return E_NOMEMORY;
@@ -13283,13 +13283,13 @@ e_Err RTO_AsExternalCfg_Pack(t_Handle RT
   Due to a callback for RTO, this function can be called
   on the main OSPF thread.  If this happens, the sync
   semaphore should not be used, AND the call to
   RTO_AsExternalCfg should happen inline
   */
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if(osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
           XX_Free(p_asExtCfg);
@@ -13320,13 +13320,13 @@ e_Err RTO_AsExternalCfg_Pack(t_Handle RT
     e = RTO_AsExternalCfg(RTO_Id, p_asExtCfg);
   }
 
   memcpy(p_Cfg, p_asExtCfg, sizeof(t_S_AsExternalCfg));
   XX_Free(p_asExtCfg);
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
       osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return E_OK;
 }
@@ -13374,16 +13374,16 @@ static e_Err RTO_PurgeExternalLsas_Unpac
 * @end
 *********************************************************************/
 e_Err RTO_PurgeExternalLsas_Pack(t_Handle RTO_Id)
 {
     t_XXCallInfo      *xxci;        /* XX_Call info */
     e_Err             e;
-    L7_int32        currThread = osapiTaskIdSelf();
-    OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
+    L7_uint64         currThread = osapiTaskIdSelf();
+    OS_Thread         *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -13409,13 +13409,13 @@ e_Err RTO_PurgeExternalLsas_Pack(t_Handl
     }
     else
     {
         e = RTO_PurgeExternalLsas(RTO_Id);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13466,26 +13466,26 @@ static e_Err ARO_StubMetric_Unpack(void
 *********************************************************************/
 e_Err ARO_StubMetric_Pack(t_Handle ARO_Id, t_S_StubAreaEntry *p_Cfg)
 {
     t_S_StubAreaEntry   *p_stubCfg;  /* ospf area configuration info */
     t_XXCallInfo        *xxci;      /* XX_Call info */
     e_Err               e;
-    L7_int32            currThread = osapiTaskIdSelf();
+    L7_uint64           currThread = osapiTaskIdSelf();
     OS_Thread           *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the area configuration info */
     p_stubCfg = XX_Malloc(sizeof(t_S_StubAreaEntry));
     if (!p_stubCfg)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_stubCfg, p_Cfg, sizeof(t_S_StubAreaEntry));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_stubCfg);
@@ -13517,13 +13517,13 @@ e_Err ARO_StubMetric_Pack(t_Handle ARO_I
         e = ARO_StubMetric(ARO_Id, p_stubCfg);
     }
 
     memcpy(p_Cfg, p_stubCfg, sizeof(t_S_StubAreaEntry));
     XX_Free(p_stubCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13602,13 +13602,13 @@ static e_Err ARO_AddressRange_Unpack(voi
 *********************************************************************/
 e_Err ARO_AddressRange_Pack(t_S_AreaAggregateEntry *p_Cfg)
 {
     t_S_AreaAggregateEntry  *p_adrRange; /* ospf area configuration info */
     t_XXCallInfo            *xxci;       /* XX_Call info */
     e_Err                   e;
-    L7_int32                currThread = osapiTaskIdSelf();
+    L7_uint64               currThread = osapiTaskIdSelf();
     OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the area configuration info */
     p_adrRange = XX_Malloc(sizeof(t_S_AreaAggregateEntry));
     if (!p_adrRange)
     {
@@ -13616,13 +13616,13 @@ e_Err ARO_AddressRange_Pack(t_S_AreaAggr
     }
 
     /* copy user supplied configuration info */
     memcpy(p_adrRange, p_Cfg, sizeof(t_S_AreaAggregateEntry));
     PACKET_INIT(xxci, ARO_AddressRange_Unpack, 0, 0, 2, (ulng)p_adrRange);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_adrRange);
@@ -13655,13 +13655,13 @@ e_Err ARO_AddressRange_Pack(t_S_AreaAggr
         XX_Free(xxci);
     }
 
     memcpy(p_Cfg, p_adrRange, sizeof(t_S_AreaAggregateEntry));
     XX_Free(p_adrRange);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13712,26 +13712,26 @@ static e_Err ARO_HostConfig_Unpack(void
 *********************************************************************/
 e_Err ARO_HostConfig_Pack(t_Handle ARO_Id, t_S_HostRouteCfg *p_Cfg)
 {
     t_S_HostRouteCfg    *p_hosts;  /* ospf area configuration info */
     t_XXCallInfo        *xxci;      /* XX_Call info */
     e_Err               e;
-    L7_int32            currThread = osapiTaskIdSelf();
+    L7_uint64           currThread = osapiTaskIdSelf();
     OS_Thread           *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the area configuration info */
     p_hosts = XX_Malloc(sizeof(t_S_HostRouteCfg));
     if (!p_hosts)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_hosts, p_Cfg, sizeof(t_S_HostRouteCfg));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_hosts);
@@ -13763,13 +13763,13 @@ e_Err ARO_HostConfig_Pack(t_Handle ARO_I
         e = ARO_HostConfig(ARO_Id, p_hosts);
     }
 
     memcpy(p_Cfg, p_hosts, sizeof(t_S_HostRouteCfg));
     XX_Free(p_hosts);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13819,16 +13819,16 @@ static e_Err ARO_Delete_Unpack(void *p_I
 * @end
 *********************************************************************/
 e_Err ARO_Delete_Pack(t_Handle ARO_Id, ulng flag)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -13855,13 +13855,13 @@ e_Err ARO_Delete_Pack(t_Handle ARO_Id, u
     }
     else
     {
         e = ARO_Delete(ARO_Id, flag);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -13918,16 +13918,16 @@ static e_Err IFO_Delete_Unpack(void *p_I
 * @end
 *********************************************************************/
 e_Err IFO_Delete_Pack(t_Handle IFO_Id, ulng flag, L7_uint32 intIfNum)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -13955,13 +13955,13 @@ e_Err IFO_Delete_Pack(t_Handle IFO_Id, u
     }
     else
     {
         e = IFO_Delete(IFO_Id, flag);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14009,16 +14009,16 @@ static e_Err IFO_Up_Unpack(void *p_Info)
 * @end
 *********************************************************************/
 e_Err IFO_Up_Pack(t_Handle IFO_Id)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -14044,13 +14044,13 @@ e_Err IFO_Up_Pack(t_Handle IFO_Id)
     }
     else
     {
         e = IFO_Up(IFO_Id);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14098,16 +14098,16 @@ static e_Err IFO_Down_Unpack(void *p_Inf
 * @end
 *********************************************************************/
 e_Err IFO_Down_Pack(t_Handle IFO_Id)
 {
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             return E_FAILED;
@@ -14133,13 +14133,13 @@ e_Err IFO_Down_Pack(t_Handle IFO_Id)
     }
     else
     {
         e = IFO_Down(IFO_Id);
     }
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14190,26 +14190,26 @@ static e_Err IFO_MetricConfig_Unpack(voi
 *********************************************************************/
 e_Err IFO_MetricConfig_Pack(t_Handle IFO_Id, t_S_IfMetric *p_Cfg)
 {
     t_S_IfMetric    *p_metric;  /* interface configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the interface configuration info */
     p_metric = XX_Malloc(sizeof(t_S_IfMetric));
     if (!p_metric)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_metric, p_Cfg, sizeof(t_S_IfMetric));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_metric);
@@ -14241,13 +14241,13 @@ e_Err IFO_MetricConfig_Pack(t_Handle IFO
         e = IFO_MetricConfig(IFO_Id, p_metric);
     }
 
     memcpy(p_Cfg, p_metric, sizeof(t_S_IfMetric));
     XX_Free(p_metric);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14298,26 +14298,26 @@ static e_Err IFO_AuthKeyConfig_Unpack(vo
 *********************************************************************/
 e_Err IFO_AuthKeyConfig_Pack(t_Handle IFO_Id, t_OspfAuthKey *p_Cfg)
 {
     t_OspfAuthKey   *p_authKeyCfg;  /* auth key configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the auth key configuration info */
     p_authKeyCfg = XX_Malloc(sizeof(t_OspfAuthKey));
     if (!p_authKeyCfg)
     {
         return E_NOMEMORY;
     }
 
     /* copy user supplied configuration info */
     memcpy(p_authKeyCfg, p_Cfg, sizeof(t_OspfAuthKey));
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_authKeyCfg);
@@ -14349,13 +14349,13 @@ e_Err IFO_AuthKeyConfig_Pack(t_Handle IF
         e = IFO_AuthKeyConfig(IFO_Id, p_authKeyCfg);
     }
 
     memcpy(p_Cfg, p_authKeyCfg, sizeof(t_OspfAuthKey));
     XX_Free(p_authKeyCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14426,13 +14426,13 @@ static e_Err NSSA_Config_Unpack(void *p_
 *********************************************************************/
 e_Err NSSA_Config_Pack(L7_uint32 areaId, t_S_NssaCfg *p_Cfg)
 {
     t_S_NssaCfg     *p_nssaCfg;  /* ospf area configuration info */
     t_XXCallInfo    *xxci;      /* XX_Call info */
     e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
+    L7_uint64       currThread = osapiTaskIdSelf();
     OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
     /* Fill in the NSSA configuration info */
     p_nssaCfg = XX_Malloc(sizeof(t_S_NssaCfg));
     if (!p_nssaCfg)
     {
@@ -14441,13 +14441,13 @@ e_Err NSSA_Config_Pack(L7_uint32 areaId,
 
     /* copy user supplied configuration info */
     memcpy(p_nssaCfg, p_Cfg, sizeof(t_S_NssaCfg));
     PACKET_INIT(xxci, NSSA_Config_Unpack, 0, 0, 3, (ulng)areaId);
     PACKET_PUT(xxci, (ulng)p_nssaCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
         {
             L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
                     "Failed to take OSPF sync semaphore\n");
             XX_Free(p_nssaCfg);
@@ -14488,13 +14488,13 @@ e_Err NSSA_Config_Pack(L7_uint32 areaId,
         XX_Free(xxci);
     }
 
     memcpy(p_Cfg, p_nssaCfg, sizeof(t_S_NssaCfg));
     XX_Free(p_nssaCfg);
 
-    if (currThread != (L7_int32) pThreadGlobal->TaskID)
+    if (currThread != pThreadGlobal->TaskID)
     {
         osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
     }
 
     return E_OK;
 }
@@ -14625,28 +14625,28 @@ static e_Err IFO_Stats_Unpack(void *p_In
 *
 * @end
 *********************************************************************/
 e_Err IFO_Stats_Pack(t_IFO *p_IFO, t_PCK_Stats *intfStats)
 {
   t_XXCallInfo  *xxci;      /* XX_Call info */
-    e_Err           e;
-    L7_int32        currThread = osapiTaskIdSelf();
-    OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
+    e_Err       e;
+    L7_uint64   currThread = osapiTaskIdSelf();
+    OS_Thread   *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
   /* Should never be called on OSPF protocol thread */
-    if (currThread == (L7_int32) pThreadGlobal->TaskID)
+    if (currThread == pThreadGlobal->TaskID)
     return E_FAILED;
 
   if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
             "Failed to take OSPF sync semaphore\n");
     return E_FAILED;
   }
 
-  PACKET_INIT(xxci, IFO_Stats_Unpack, 0, 0, 2, (L7_uint32)p_IFO);
+  PACKET_INIT(xxci, IFO_Stats_Unpack, 0, 0, 2, PTR_TO_UINT32(p_IFO));
   PACKET_PUT(xxci, intfStats);
   e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
 
   if (e != E_OK)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
@@ -14741,16 +14741,16 @@ static e_Err RTO_OpaqueCapability_Get_Un
  * @end
  *********************************************************************/
 e_Err RTO_OpaqueCapability_Get_Pack(t_Handle RTO_Id, L7_uint32 *opaqueEnabled)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -14777,13 +14777,13 @@ e_Err RTO_OpaqueCapability_Get_Pack(t_Ha
   }
   else
   {
     e = RTO_OpaqueCapability_Get(RTO_Id, opaqueEnabled);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return e;
 }
@@ -14861,16 +14861,16 @@ static e_Err RTO_OpaqueCapability_Set_Un
  * @end
  *********************************************************************/
 e_Err RTO_OpaqueCapability_Set_Pack(t_Handle RTO_Id, L7_BOOL opaqueEnabled)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -14897,13 +14897,13 @@ e_Err RTO_OpaqueCapability_Set_Pack(t_Ha
   }
   else
   {
     e = RTO_OpaqueCapability_Set(RTO_Id, opaqueEnabled);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return E_OK;
 }
@@ -15050,24 +15050,24 @@ static e_Err ospfAreaOpaqueLsdbTable_Loo
 e_Err ospfAreaOpaqueLsdbTable_Lookup_Pack(L7_uint32 lsdbAreaId,
     L7_uint32 lsdbType, L7_uint32 lsdbId,
     L7_uint32 lsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
-  e_Err                   e;
-  L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
-  OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
+  e_Err           e;
+  L7_RC_t         rc;
+  L7_uint64       currThread = osapiTaskIdSelf();
+  OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -15098,13 +15098,13 @@ e_Err ospfAreaOpaqueLsdbTable_Lookup_Pac
   }
   else
   {
     rc = ospfAreaOpaqueLsdbTable_Lookup(lsdbAreaId, lsdbType, lsdbId, lsdbRouterId, p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -15254,31 +15254,31 @@ e_Err ospfAreaOpaqueLsdbTable_NextLookup
     L7_uint32 *LsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
     }
 
-    PACKET_INIT(xxci, ospfAreaOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 6, (L7_uint32)LsdbAreaId);
+    PACKET_INIT(xxci, ospfAreaOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 6, PTR_TO_UINT32(LsdbAreaId));
     PACKET_PUT(xxci, (L7_int32*)LsdbType);
     PACKET_PUT(xxci, (L7_uint32*)LsdbId);
     PACKET_PUT(xxci, (L7_uint32*)LsdbRouterId);
     PACKET_PUT(xxci, (L7_ospfOpaqueLsdbEntry_t *)p_Lsa);
     PACKET_PUT(xxci, (L7_RC_t *)&rc);
     e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
@@ -15300,13 +15300,13 @@ e_Err ospfAreaOpaqueLsdbTable_NextLookup
   }
   else
   {
     rc = ospfAreaOpaqueLsdbTable_NextLookup(LsdbAreaId, LsdbType, LsdbId, LsdbRouterId, p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -15595,22 +15595,22 @@ e_Err ospfAreaOpaqueAdvertisement_Lookup
     L7_ospfOpaqueLsdbEntry_t *p_Lsa,
     L7_char8 **p_LsdbAdvertisement)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t      temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -15646,13 +15646,13 @@ e_Err ospfAreaOpaqueAdvertisement_Lookup
     rc = ospfType10Advertisement_Lookup(LsdbAreaId, LsdbType,
         LsdbId, LsdbRouterId,
         p_Lsa,
         p_LsdbAdvertisement);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -15823,22 +15823,22 @@ e_Err ospfLinkOpaqueLsdbTable_Lookup_Pac
     L7_uint32 LsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -15871,13 +15871,13 @@ e_Err ospfLinkOpaqueLsdbTable_Lookup_Pac
   else
   {
     rc = ospfLinkOpaqueLsdbTable_Lookup(ipAddr,ifIndex,LsdbType,
         LsdbId,LsdbRouterId,p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -16059,31 +16059,31 @@ e_Err ospfLinkOpaqueLsdbTable_NextLookup
     L7_uint32 *LsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
     }
 
-    PACKET_INIT(xxci, ospfLinkOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 7, (L7_uint32)ipAddr);
+    PACKET_INIT(xxci, ospfLinkOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 7, PTR_TO_UINT32(ipAddr));
     PACKET_PUT(xxci, (L7_int32*)ifIndex);
     PACKET_PUT(xxci, (L7_int32*)LsdbType);
     PACKET_PUT(xxci, (L7_uint32*)LsdbId);
     PACKET_PUT(xxci, (L7_uint32*)LsdbRouterId);
     PACKET_PUT(xxci, (L7_ospfOpaqueLsdbEntry_t *)p_Lsa);
     PACKET_PUT(xxci, (L7_RC_t *)&rc);
@@ -16107,13 +16107,13 @@ e_Err ospfLinkOpaqueLsdbTable_NextLookup
   else
   {
     rc = ospfLinkOpaqueLsdbTable_NextLookup(ipAddr,ifIndex,LsdbType,
         LsdbId,LsdbRouterId,p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -16426,22 +16426,22 @@ e_Err ospfLinkOpaqueAdvertisement_Lookup
     L7_ospfOpaqueLsdbEntry_t *p_Lsa,
     L7_char8 **p_LsdbAdvertisement)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t      temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -16476,13 +16476,13 @@ e_Err ospfLinkOpaqueAdvertisement_Lookup
   else
   {
     rc = ospfType9Advertisement_Lookup(ipAddr,ifIndex,LsdbType,LsdbId,
         LsdbRouterId,p_Lsa,p_LsdbAdvertisement);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -16636,22 +16636,22 @@ e_Err ospfAsOpaqueLsdbTable_Lookup_Pack(
     L7_uint32 LsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -16681,13 +16681,13 @@ e_Err ospfAsOpaqueLsdbTable_Lookup_Pack(
   }
   else
   {
     rc = ospfAsOpaqueLsdbTable_Lookup(LsdbType,LsdbId,LsdbRouterId,p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -16823,31 +16823,31 @@ e_Err ospfAsOpaqueLsdbTable_NextLookup_P
     L7_uint32 *LsdbRouterId,
     L7_ospfOpaqueLsdbEntry_t *p_Lsa)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t  temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
     }
 
-    PACKET_INIT(xxci, ospfAsOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 5, (L7_uint32)LsdbType);
+    PACKET_INIT(xxci, ospfAsOpaqueLsdbTable_NextLookup_Unpack, 0, 0, 5, PTR_TO_UINT32(LsdbType));
     PACKET_PUT(xxci, (L7_uint32*)LsdbId);
     PACKET_PUT(xxci, (L7_uint32*)LsdbRouterId);
     PACKET_PUT(xxci, (L7_ospfOpaqueLsdbEntry_t *)p_Lsa);
     PACKET_PUT(xxci, (L7_RC_t *)&rc);
     e = XX_Call(ospfMapCtrl_g.ospfThread, xxci);
 
@@ -16868,13 +16868,13 @@ e_Err ospfAsOpaqueLsdbTable_NextLookup_P
   }
   else
   {
     rc = ospfAsOpaqueLsdbTable_NextLookup(LsdbType,LsdbId,LsdbRouterId,p_Lsa);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -17148,22 +17148,22 @@ e_Err ospfAsOpaqueAdvertisement_Lookup_P
     L7_ospfOpaqueLsdbEntry_t *p_Lsa,
     L7_char8 **p_LsdbAdvertisement)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err                   e;
   L7_RC_t                 rc;
-  L7_int32                currThread = osapiTaskIdSelf();
+  L7_uint64               currThread = osapiTaskIdSelf();
   OS_Thread               *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
   L7_ospfOpaqueLsdbEntry_t      temp_Lsa;
 
   if(p_Lsa == NULL)
   {
     p_Lsa = &temp_Lsa;
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -17196,13 +17196,13 @@ e_Err ospfAsOpaqueAdvertisement_Lookup_P
   else
   {
     rc = ospfType11Advertisement_Lookup(LsdbType,LsdbId,
         LsdbRouterId,p_Lsa,p_LsdbAdvertisement);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return (rc == L7_SUCCESS)? E_OK: E_FAILED;
 }
@@ -17296,16 +17296,16 @@ static e_Err ospfASOpaqueCksumSum_Get_Un
  * @end
  *********************************************************************/
 e_Err ospfASOpaqueCksumSum_Get_Pack(t_Handle RTO_Id, L7_uint32 *opaqueCksumSum)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -17332,13 +17332,13 @@ e_Err ospfASOpaqueCksumSum_Get_Pack(t_Ha
   }
   else
   {
     e = RTO_ASOpaqueCksumSum_Get(RTO_Id, opaqueCksumSum);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return e;
 }
@@ -17411,16 +17411,16 @@ static e_Err ospfIsStubRtr_Get_Unpack(vo
  * @end
  *********************************************************************/
 e_Err ospfIsStubRtr_Get_Pack(t_Handle RTO_Id, L7_BOOL *isStubRtr)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -17447,13 +17447,13 @@ e_Err ospfIsStubRtr_Get_Pack(t_Handle RT
   }
   else
   {
     e = RTO_IsStubRtr_Get(RTO_Id, isStubRtr);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return e;
 }
@@ -17527,16 +17527,16 @@ static e_Err ospfExtLsdbOverflow_Get_Unp
  * @end
  *********************************************************************/
 e_Err ospfExtLsdbOverflow_Get_Pack(t_Handle RTO_Id, L7_BOOL *extLsdbOverflow)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     if (osapiSemaTake(ospfMapCtrl_g.ospfSyncSema, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
               "Failed to take OSPF sync semaphore\n");
       return E_FAILED;
@@ -17563,13 +17563,13 @@ e_Err ospfExtLsdbOverflow_Get_Pack(t_Han
   }
   else
   {
     e = RTO_ExtLsdbOverflow_Get(RTO_Id, extLsdbOverflow);
   }
 
-  if (currThread != (L7_int32) pThreadGlobal->TaskID)
+  if (currThread != pThreadGlobal->TaskID)
   {
     osapiSemaGive(ospfMapCtrl_g.ospfSyncSema);
   }
 
   return e;
 }
@@ -17641,16 +17641,16 @@ static e_Err ospfGlobalStatus_Unpack(voi
 * @end
 *********************************************************************/
 e_Err ospfGlobalStatus_Pack(t_Handle RTO_Id, L7_ospfStatus_t *status)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* This is for UI to get OSPFv2 status. Should never be called
      * on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
@@ -17727,16 +17727,16 @@ L7_RC_t ospfMapExtenStatusGet(L7_ospfSta
 * @end
 *********************************************************************/
 e_Err ospfNeighborClear_Pack(t_Handle RTO_Id, t_IFO *p_IFO, L7_uint32 routerId)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* This is for UI to get OSPFv2 status. Should never be called
      * on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
@@ -17846,16 +17846,16 @@ L7_RC_t ospfMapExtenNeighborClear(L7_uin
 * @end
 *********************************************************************/
 e_Err ospfCountersClear_Pack(t_Handle RTO_Id)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* Should never be called on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
   PACKET_INIT(xxci, ospfCountersClear_Unpack, 0, 0, 3, (ulng)RTO_Id);
@@ -17901,16 +17901,16 @@ e_Err ospfCountersClear_Pack(t_Handle RT
 * @end
 *********************************************************************/
 e_Err ospfStubRouterClear_Pack(t_Handle RTO_Id)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* Should never be called on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
   PACKET_INIT(xxci, ospfStubRouterClear_Unpack, 0, 0, 3, (ulng)RTO_Id);
@@ -18051,16 +18051,16 @@ L7_RC_t ospfMapExtenStubRouterClear(void
 * @end
 *********************************************************************/
 e_Err ospfBeginGr_Pack(t_Handle RTO_Id)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* Should never be called on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
   PACKET_INIT(xxci, ospfBeginGr_Unpack, 0, 0, 3, (ulng)RTO_Id);
@@ -18155,16 +18155,16 @@ L7_RC_t ospfMapExtenBeginGracefulRestart
 * @end
 *********************************************************************/
 e_Err ospfStartupDone_Pack(t_Handle RTO_Id)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* Should never be called on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
   PACKET_INIT(xxci, ospfStartupDone_Unpack, 0, 0, 3, (ulng)RTO_Id);
@@ -18349,16 +18349,16 @@ static e_Err ospfHelpfulNbrStatus_Unpack
 e_Err ospfHelpfulNbrStatus_Pack(t_Handle RTO_Id, L7_uint32 intIfNum,
                                 L7_uint32 nbrIpAddr,
                                 L7_ospfHelpfulNbrStatus_t *status)
 {
   t_XXCallInfo    *xxci;      /* XX_Call info */
   e_Err           e;
-  L7_int32        currThread = osapiTaskIdSelf();
+  L7_uint64       currThread = osapiTaskIdSelf();
   OS_Thread       *pThreadGlobal = (OS_Thread *)ospfMapCtrl_g.ospfThread;
 
-  if (currThread == (L7_int32) pThreadGlobal->TaskID)
+  if (currThread == pThreadGlobal->TaskID)
   {
     /* This is for UI to get OSPFv2 status. Should never be called
      * on OSPFv2 protocol thread. */
     return E_FAILED;
   }
 
Index: src/application/routing/mapping/ospfmap/core/ospf_cnfgr.c
===================================================================
--- src/application/routing/mapping/ospfmap/core/ospf_cnfgr.c	(revision 7772)
+++ src/application/routing/mapping/ospfmap/core/ospf_cnfgr.c	(revision 7778)
@@ -58,13 +58,13 @@
 #include "ospf_ckpt.h"
 #endif
 
 static L7_BOOL traceConfigState = L7_FALSE;
 
 ospfMapCnfgrState_t ospfMapCnfgrState = OSPFMAP_PHASE_INIT_0;
-L7_int32 ospfProcTaskHandle = 0;
+L7_uint64 ospfProcTaskHandle = 0;
 
 /* The OSPF processing thread reads events from two message queues. msgQSema
  * is a counting semaphore to indicate whether data is available in
  * one of the message queues. Ospf_Proc_Queue contains all events other than
  * redistribution events. Ospf_Redist_Queue contains the redistribution events.
  * There can be many redistribution events all at once, and we don't want
Index: src/application/routing/vendor/freebsd/forwarding/rtip_input.c
===================================================================
--- src/application/routing/vendor/freebsd/forwarding/rtip_input.c	(revision 7772)
+++ src/application/routing/vendor/freebsd/forwarding/rtip_input.c	(revision 7778)
@@ -249,13 +249,13 @@ ip_input(struct rtmbuf *m)
   if (m->rtm_pkthdr.len < sizeof(struct ip))
     goto tooshort;
 
   if (m->rtm_len < sizeof (struct ip))
   {
     L7_ipstat.ips_toosmall++;
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle));
     rtm_freem(m);
     return;
   }
   ip = rtmtod(m, struct ip *);
 
   if (IP_VHL_V(ip->ip_vhl) != IPVERSION)
@@ -419,19 +419,19 @@ ip_input(struct rtmbuf *m)
   ** is freed here if the caller consumes it.  So, the interceptor should make a copy of the
   ** frame if processing is done on another task.
   */
   memset(&pduInfo, 0, sizeof(sysnet_pdu_info_t));
   pduInfo.intIfNum = m->rtm_pkthdr.rcvif->if_index;
 
-  if (SYSNET_PDU_INTERCEPT(L7_AF_INET, SYSNET_INET_VALID_IN, (L7_netBufHandle)m->rtm_bufhandle,
+  if (SYSNET_PDU_INTERCEPT(L7_AF_INET, SYSNET_INET_VALID_IN, (L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle),
                            &pduInfo, L7_NULLPTR, &hookVerdict) == L7_TRUE)
   {
     /* If freed by intercept call, don't free it again */
     if (hookVerdict != SYSNET_PDU_RC_DISCARD)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle));
     }
       rtm_freem(m);
       if (hookVerdict == SYSNET_PDU_RC_DISCARD)
         SYSAPI_IP_STATS_INCREMENT(FD_CNFGR_NIM_MIN_CPU_INTF_NUM,
                                   L7_PLATFORM_CTR_RX_IP_IN_DISCARDS);
       return;
@@ -497,13 +497,13 @@ ip_input(struct rtmbuf *m)
      * ip_mforward() returns a non-zero value, the packet
      * must be discarded, else it may be accepted below.
      */
 
       if (mfcIpv4PktRecv(ip, m->rtm_pkthdr.rcvif, m, 0) != L7_FALSE) {
           L7_ipstat.ips_cantforward++;
-          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+          SYSAPI_NET_MBUF_FREE((L7_netBufHandle) PTR_TO_UINT64(m->rtm_bufhandle));
           rtm_freem(m);
           return;
       }
   }
 #endif /* L7_MCAST_PACKAGE */
 
@@ -572,24 +572,24 @@ ip_input(struct rtmbuf *m)
   /*
    * Not for us; forward if possible and desirable.
    */
   if (rtipforwarding == 0)
   {
     L7_ipstat.ips_cantforward++;
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
     rtm_freem(m);
 
   }
   else
     ip_forward(m, 0);
   return;
 
   ours:
 
   intIfNum = m->rtm_pkthdr.rcvif->if_index;
-  if (ipmRecvLocal((L7_netBufHandle)m->rtm_bufhandle,intIfNum) != L7_SUCCESS)
+  if (ipmRecvLocal((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle),intIfNum) != L7_SUCCESS)
   {
     SYSAPI_IP_STATS_INCREMENT(FD_CNFGR_NIM_MIN_CPU_INTF_NUM,
                               L7_PLATFORM_CTR_RX_IP_IN_DISCARDS);
   }
 
   /* The corresponding sysapi network buffer (m->rtm_bufhandle) does not need to be
@@ -597,13 +597,13 @@ ip_input(struct rtmbuf *m)
   ** wrapper function.
    */
   rtm_freem(m);
     return;
 
   bad:
-  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
   rtm_freem(m);
 
 }
 
 /*
  * Do option processing on a datagram,
@@ -768,13 +768,13 @@ struct rtmbuf *m;
         else
         {
           /*
            * Not acting as a router, so silently drop.
            */
           L7_ipstat.ips_cantforward++;
-          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
           rtm_freem(m);
           return(1);
         }
       }
 
       /*
@@ -1033,13 +1033,13 @@ struct rtmbuf *m;
       mcopy->rtm_pkthdr.rcvif = m->rtm_pkthdr.rcvif;
       rtcreateIcmpErrPckt(m, mcopy);
       icmp_error(mcopy, type, code, 0, 0);
     }
   }
 
-  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
   rtm_freem(m);
   return(1);
 }
 
 /*
  * Save incoming source route for use in replies,
@@ -1247,19 +1247,19 @@ int srcrt;
   ** is freed here if the caller consumes it.  So, the interceptor should make a copy of the
   ** frame if processing is done on another task.
   */
   memset(&pduInfo, 0, sizeof(sysnet_pdu_info_t));
   pduInfo.intIfNum = m->rtm_pkthdr.rcvif->if_index;
 
-  if (SYSNET_PDU_INTERCEPT(L7_AF_INET, SYSNET_INET_FORWARD_IN, (L7_netBufHandle)m->rtm_bufhandle,
+  if (SYSNET_PDU_INTERCEPT(L7_AF_INET, SYSNET_INET_FORWARD_IN, (L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle),
                            &pduInfo, L7_NULLPTR, &hookVerdict) == L7_TRUE)
   {
     /* If freed by intercept call, don't free it again */
     if (hookVerdict != SYSNET_PDU_RC_DISCARD)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
     }
     rtm_freem(m);
     return;
   }
 
   dest = 0;
@@ -1313,13 +1313,13 @@ int srcrt;
   if (((m->rtm_flags & M_MCAST) && ((m->rtm_flags & M_BCAST) != M_BCAST)) ||
       ((m->rtm_flags & M_BCAST) && ntohl(ip->ip_dst.s_addr) == 0xffffffff) ||
       rtin_canforward(ip->ip_dst) == 0)
 #endif /* L7_ORIGINAL_VENDOR_CODE */
   {
     L7_ipstat.ips_cantforward++;
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
     rtm_freem(m);
     return;
   }
 
     if (ip->ip_ttl <= IPTTLDEC)
     {
@@ -1332,13 +1332,13 @@ int srcrt;
         memset(mcopy, 0, sizeof( *mcopy));
         mcopy->rtm_pkthdr.rcvif = m->rtm_pkthdr.rcvif;
         rtcreateIcmpErrPckt(m, mcopy);
         icmp_error(mcopy, ICMP_TIMXCEED, ICMP_TIMXCEED_INTRANS, dest, 0);
       }
 
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
       rtm_freem(m);
       /* lvl7_@ip_forward end*/
       return;
     }
 
   /* lvl7_@ip_forward start*/
@@ -1384,13 +1384,13 @@ int srcrt;
           icmp_error(mcopy, ICMP_UNREACH, ICMP_UNREACH_TOSNET, dest, 0);
         else
           icmp_error(mcopy, ICMP_UNREACH, ICMP_UNREACH_NET, dest, 0);
       }
     }
 
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
     rtm_freem(m);
     return;
   }
 
   /* Type 2 and type 3 differentiation is done here. Check the note at the
      begining of this function. Type 3 should be dropped here.
@@ -1405,13 +1405,13 @@ int srcrt;
     if ((osapiNtohl(ip->ip_dst.s_addr) & (~netMask)) != (~netMask))
 #else /* L7_ORIGINAL_VENDOR_CODE */
     if ((ntohl(ip->ip_dst.s_addr) & (~netMask)) != (~netMask))
 #endif /* L7_ORIGINAL_VENDOR_CODE */
     {
       L7_ipstat.ips_cantforward++;
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
       rtm_freem(m);
       return;
     }
   }
 
 #ifndef L7_ORIGINAL_VENDOR_CODE
@@ -1430,41 +1430,41 @@ int srcrt;
         /* Get an mbuf to make a copy of the packet to be forwarded. Receive
          * mbuf will be consumed locally. */
         SYSAPI_NET_MBUF_GET(netMbufHandle);
         if (netMbufHandle == L7_NULL)
         {
           /* Cant forward. Can still consume locally */
-          SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)m->rtm_bufhandle, olddataStart);
+          SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), olddataStart);
           memcpy(&olddataStart[0], (L7_char8 *)rtetherbroadcastaddr, 6);
-          ipmRecvLocal((L7_netBufHandle)m->rtm_bufhandle,MyLocalIfIndex);
+          ipmRecvLocal((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle),MyLocalIfIndex);
 
-          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
           rtm_freem(m);
           return ;
         }
         SYSAPI_NET_MBUF_GET_DATASTART(netMbufHandle, pdataStart);
-        SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)m->rtm_bufhandle, olddataStart);
-        SYSAPI_NET_MBUF_GET_DATALENGTH((L7_netBufHandle)m->rtm_bufhandle, datalen);
+        SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), olddataStart);
+        SYSAPI_NET_MBUF_GET_DATALENGTH((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), datalen);
         memcpy(&pdataStart[0], &olddataStart[0], datalen);
 
         SYSAPI_NET_MBUF_SET_DATALENGTH(netMbufHandle, datalen);
 
       }
 
-      SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)m->rtm_bufhandle, olddataStart);
+      SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle), olddataStart);
       memcpy(&olddataStart[0], (L7_char8 *)rtetherbroadcastaddr, 6);
-      ipmRecvLocal((L7_netBufHandle)m->rtm_bufhandle,MyLocalIfIndex);
+      ipmRecvLocal((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle),MyLocalIfIndex);
 
       if (netDirectBCastsEnable != L7_ENABLE)
       {
         L7_ipstat.ips_noroute++;
         rtm_freem(m);
         return;
       }
       else
-        m->rtm_bufhandle = (void *)netMbufHandle;
+        m->rtm_bufhandle = (void *)UINT_TO_PTR(netMbufHandle);
     }
 
   }
   else
   {
     if (~netMask)
@@ -1476,13 +1476,13 @@ int srcrt;
 #endif /* L7_ORIGINAL_VENDOR_CODE */
       {
         netDirectBCastsEnable = ipMapRtrIntfNetDirectBcastsGet(MyLocalIfIndex);
         if (netDirectBCastsEnable != L7_ENABLE)
         {
           L7_ipstat.ips_noroute++;
-          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+          SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
           rtm_freem(m);
           return;
         }
 
       }
     }
@@ -1500,13 +1500,13 @@ int srcrt;
   if ((netMask != L7_NULL_IP_MASK) && (netMask != 0xffffffff) &&
       ((ntohl(ip->ip_dst.s_addr) & (~netMask)) == L7_NULL_IP_ADDR))
 #endif /* L7_ORIGINAL_VENDOR_CODE */
   {
     /* Discard the packet. */
     L7_ipstat.ips_cantforward++;
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
     rtm_freem(m);
     return;
   }
 
   /* lvl7_@ip_forward end*/
 
@@ -1594,24 +1594,24 @@ if ((MyLocalIfIndex == m->rtm_pkthdr.rcv
   if (icmpSendRedirectMode == L7_DISABLE || icmpIfSendRedirectMode == L7_DISABLE)
   {
     icmpCtlStats.totalSuppressedRedirects++;
   }
 }
 error = 0;
-  if ((sysapiNetMbufGetRxReasonCode((L7_netBufHandle)m->rtm_bufhandle)&
+  if ((sysapiNetMbufGetRxReasonCode((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle))&
               L7_MBUF_RX_REASON_ICMP_REDIR) == 0 )
   {
 #endif /* L7_ORIGINAL_VENDOR_CODE */
     error = rtip_output(m, (struct rtmbuf *)0, routerIP, netMask, MyLocalIfIndex,
                       IP_FORWARDING, 0, srcrt);
 #ifndef L7_ORIGINAL_VENDOR_CODE
   }
   else
   {
      if (m->rtm_bufhandle != NULL)
-                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
         rtm_freem(m);
   }
 #endif /* L7_ORIGINAL_VENDOR_CODE */
 
   if (error && error != EARPINPROGRESS)
     /* lvl7_@ip_forward end*/
Index: src/application/routing/vendor/freebsd/forwarding/rtin_cksum.c
===================================================================
--- src/application/routing/vendor/freebsd/forwarding/rtin_cksum.c	(revision 7772)
+++ src/application/routing/vendor/freebsd/forwarding/rtin_cksum.c	(revision 7778)
@@ -121,13 +121,13 @@ rtin_cksum(m, len)
 		if (len < mlen)
 			mlen = len;
 		len -= mlen;
 		/*
 		 * Force to even boundary.
 		 */
-		if ((1 & (int) w) && (mlen > 0)) {
+		if ((1 & PTR_TO_UINT32(w)) && (mlen > 0)) {
 			REDUCE;
 			sum <<= 8;
 			s_util.c[0] = *(u_char *)w;
 			w = (u_short *)((char *)w + 1);
 			mlen--;
 			byte_swapped = 1;
Index: src/application/routing/vendor/freebsd/forwarding/rtip_output.c
===================================================================
--- src/application/routing/vendor/freebsd/forwarding/rtip_output.c	(revision 7772)
+++ src/application/routing/vendor/freebsd/forwarding/rtip_output.c	(revision 7778)
@@ -93,13 +93,13 @@ rtip_output(m0, opt, routerIP, netMask,
   */
   memset(&pduInfo, 0, sizeof(sysnet_pdu_info_t));
   if (m->rtm_pkthdr.rcvif != (struct rtm_ifnet *)0)
     pduInfo.intIfNum = m->rtm_pkthdr.rcvif->if_index;
   pduInfo.destIntIfNum = intIfNum;
   if (SYSNET_PDU_INTERCEPT(L7_AF_INET, SYSNET_INET_RECV_OUT,
-                           (L7_netBufHandle)m->rtm_bufhandle,
+                           (L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle),
                            &pduInfo, L7_NULLPTR, &hookVerdict) == L7_TRUE)
   {
     if (hookVerdict == SYSNET_PDU_RC_DISCARD)
       SYSAPI_IP_STATS_INCREMENT(FD_CNFGR_NIM_MIN_CPU_INTF_NUM, 
                                 L7_PLATFORM_CTR_TX_IP_OUT_DISCARDS);
     rtm_freem(m);
@@ -209,13 +209,13 @@ rtip_output(m0, opt, routerIP, netMask,
 		 * are not sent -- the above call to ip_mloopback() will
 		 * loop back a copy if this host actually belongs to the
 		 * destination group on the loopback interface.
 		 */
 		if (ip->ip_ttl == 0 || ifp->if_flags & IFF_LOOPBACK) {
             if (m->rtm_bufhandle != NULL)
-                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
 			rtm_freem(m);
             goto done;
 		}
 
 		goto sendit;
 	}
@@ -257,13 +257,13 @@ sendit:
                                 L7_PLATFORM_CTR_TX_IP_OUT_DISCARDS);
 	 goto bad;
 done:
 	return (error);
 bad:
     if (m->rtm_bufhandle != NULL)
-                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)m->rtm_bufhandle);
+                SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(m->rtm_bufhandle));
 	rtm_freem(m0);
     goto done;
 }
 
 
 
Index: src/application/security/captive_portal/core/cpim/captive_portal_main.c
===================================================================
--- src/application/security/captive_portal/core/cpim/captive_portal_main.c	(revision 7772)
+++ src/application/security/captive_portal/core/cpim/captive_portal_main.c	(revision 7778)
@@ -75,13 +75,13 @@ extern L7_RC_t cpimIntfFinishWork(void);
 extern void    cpdmMonitorSessions(void);
 extern L7_BOOL captivePortalCnfgrComplete(void);
 
 
 static int       captive_portal_exitflag   = 0; /* may need to be volatile? */
 
-static L7_int32  cpTaskId                  = L7_ERROR;
+static L7_uint64 cpTaskId                  = L7_ERROR;
 static char      *captive_portal_task_name = "tCptvPrtl";
 
 void             *pCaptivePortalMsgQueue   = L7_NULLPTR;
 
 void             *pCPStatsQ                = L7_NULLPTR;
 
@@ -973,16 +973,17 @@ static L7_RC_t captive_portal_init()
 * @end
 *********************************************************************/
 
 static int
 captive_portal_main(char *argv[], int argc)
 {
-  int rc = 0, my_pid;
+  int rc = 0;
+  L7_uint64 my_pid;
 
   osapiTaskInitDone(L7_CAPTIVE_PORTAL_TASK_SYNC);
-  my_pid = (int) osapiTaskIdSelf();
+  my_pid = osapiTaskIdSelf();
 
   do
   {
     /* Try to initialize the task's internal data */
     if (L7_SUCCESS != captive_portal_init())
     {
@@ -994,13 +995,13 @@ captive_portal_main(char *argv[], int ar
   } while ( 0 );
 
   if (0 == rc) {
     captive_portal_dolisten(); /* Wait for new business. */
   }
 
-  CP_DLOG(CPD_LEVEL_LOG, "%s: task 0x%08x exiting (rc=%d)\n", __FUNCTION__, my_pid, rc);
+  CP_DLOG(CPD_LEVEL_LOG, "%s: task 0x%llx exiting (rc=%d)\n", __FUNCTION__, my_pid, rc);
   L7_LOG_ERROR(0xDEADBEEF); /* We should NEVER get here */
   return rc;
 }
 
 /*********************************************************************
 * @purpose  This function starts the captive portal task once it has
Index: src/application/security/dot1x/core/dot1x_txrx.c
===================================================================
--- src/application/security/dot1x/core/dot1x_txrx.c	(revision 7772)
+++ src/application/security/dot1x/core/dot1x_txrx.c	(revision 7778)
@@ -41,14 +41,14 @@ static L7_uchar8 temp[DOT1X_MAX_PDU_SIZE
 *************************************************************************/
 L7_RC_t dot1xTxRxInit(void)
 {
   L7_RC_t rc;
   sysnetNotifyEntry_t snEntry;
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register dot1xPduReceive related to type=%u, protocol_type=%u: 0x%08x",
-           SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_EAPOL, (L7_uint32) dot1xPduReceive);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register dot1xPduReceive related to type=%u, protocol_type=%u: 0x%llx",
+           SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_EAPOL, PTR_TO_UINT64(dot1xPduReceive));
 
   memset(&snEntry, 0x00, sizeof(snEntry));
   /*Register the pdu receive function with sysnet utility*/
   osapiStrncpy(snEntry.funcName, "dot1xPduReceive", sizeof(snEntry.funcName));
   snEntry.notify_pdu_receive = dot1xPduReceive;
   snEntry.type = SYSNET_ETHERTYPE_ENTRY;
Index: src/application/security/dot1x/core/dot1x_cnfgr.c
===================================================================
--- src/application/security/dot1x/core/dot1x_cnfgr.c	(revision 7772)
+++ src/application/security/dot1x/core/dot1x_cnfgr.c	(revision 7778)
@@ -31,13 +31,13 @@
 #include "ms_api.h"
 
 extern void *dot1xQueue;
 dot1xCnfgrState_t dot1xCnfgrState = DOT1X_PHASE_INIT_0;
 L7_tlvHandle_t    dot1xTlvHandle;
 
-extern L7_int32 dot1xTaskId;
+extern L7_uint64 dot1xTaskId;
 extern dot1xCfg_t *dot1xCfg;
 L7_VLAN_MASK_t dot1xVlanMask;
 L7_ushort16 *dot1xVlanIntfCount;
 L7_VLAN_MASK_t dot1xGuestVlanMask;
 L7_ushort16 *dot1xGuestVlanIntfCount;
 static L7_BOOL warmRestart;
Index: src/application/security/dot1x/core/dot1x_sm.c
===================================================================
--- src/application/security/dot1x/core/dot1x_sm.c	(revision 7772)
+++ src/application/security/dot1x/core/dot1x_sm.c	(revision 7778)
@@ -292,13 +292,13 @@ L7_RC_t dot1xApmMachine(L7_uint32 dot1xE
   case APM_CONNECTING:
     rc = dot1xApmConnectingAction(logicalPortInfo);
     rc = dot1xApmGenerateEvents(logicalPortInfo, L7_NULLPTR);
     break;
   case APM_AUTHENTICATING:
     rc = dot1xApmAuthenticatingAction(logicalPortInfo);
-    rc = dot1xApmGenerateEvents(logicalPortInfo, (void *)bufHandle);
+    rc = dot1xApmGenerateEvents(logicalPortInfo, UINT_TO_PTR(bufHandle));
     freeBuffer = L7_FALSE;
     break;
   case APM_AUTHENTICATED:
     rc = dot1xApmAuthenticatedAction(logicalPortInfo);
     /* No need to generate events here */
     break;
@@ -931,13 +931,13 @@ L7_RC_t dot1xApmGenerateEvents(dot1xLogi
   if (logicalPortInfo->apmState == APM_CONNECTING &&
       logicalPortInfo->reAuthCount > dot1xPortInfo[physPort].reAuthMax)
       (void) dot1xStateMachineClassifier(apmReAuthCountGreaterThanReAuthMax, lIntIfNum,
                                        L7_NULL, L7_NULLPTR);
 
   if (logicalPortInfo->apmState == APM_AUTHENTICATING)
-      (void) dot1xStateMachineClassifier(bamAuthStart, lIntIfNum,(L7_netBufHandle)msg, L7_NULLPTR);
+      (void) dot1xStateMachineClassifier(bamAuthStart, lIntIfNum,(L7_netBufHandle)PTR_TO_UINT64(msg), L7_NULLPTR);
 
   if (logicalPortInfo->apmState == APM_ABORTING)
       (void) dot1xStateMachineClassifier(bamAuthAbort, lIntIfNum, L7_NULL, L7_NULLPTR);
 
   return L7_SUCCESS;
 }
Index: src/application/security/dot1x/core/dot1x_control.c
===================================================================
--- src/application/security/dot1x/core/dot1x_control.c	(revision 7772)
+++ src/application/security/dot1x/core/dot1x_control.c	(revision 7778)
@@ -32,14 +32,14 @@
 #include "usmdb_util_api.h"
 #include "voice_vlan_api.h"
 
 void *dot1xTaskSyncSema;
 static L7_uint32 dot1xTimerHandle;
 void *dot1xQueue;      /* reference to the dot1x message queue */
-L7_uint32 dot1xTaskId;
-L7_uint32 dot1xTimerTaskId;
+L7_uint64 dot1xTaskId;
+L7_uint64 dot1xTimerTaskId;
 extern dot1xCnfgrState_t dot1xCnfgrState;
 extern L7_VLAN_MASK_t dot1xVlanMask;
 extern L7_ushort16 *dot1xVlanIntfCount;
 extern L7_VLAN_MASK_t dot1xGuestVlanMask;
 extern L7_ushort16 *dot1xGuestVlanIntfCount;
 extern L7_tlvHandle_t    dot1xTlvHandle;
@@ -80,16 +80,16 @@ L7_RC_t dot1xStartTasks()
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1X_COMPONENT_ID,
             "Unable to create dot1x task semaphore\n");
     return L7_FAILURE;
   }
 
   /* create dotxTask - to service dot1x message queue */
-  dot1xTaskId = (L7_uint32)osapiTaskCreate("dot1xTask", (void *)dot1xTask, 0, 0,
-                                           dot1xSidDefaultStackSize(),
-                                           dot1xSidDefaultTaskPriority(),
-                                           dot1xSidDefaultTaskSlice());
+  dot1xTaskId = osapiTaskCreate("dot1xTask", (void *)dot1xTask, 0, 0,
+                                dot1xSidDefaultStackSize(),
+                                dot1xSidDefaultTaskPriority(),
+                                dot1xSidDefaultTaskSlice());
 
   if (dot1xTaskId == L7_ERROR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1X_COMPONENT_ID,
             "Failed to create dot1x task\n");
     return L7_FAILURE;
@@ -101,16 +101,16 @@ L7_RC_t dot1xStartTasks()
             "Unable to initialize dot1xTask()\n");
     return L7_FAILURE;
   }
 
 
   /* create dotxTimerTask - to service Timer queue */
-  dot1xTimerTaskId = (L7_uint32)osapiTaskCreate("dot1xTimerTask", (void *)dot1xTimerTask, 0, 0,
-                                                dot1xSidDefaultStackSize(),
-                                                dot1xSidDefaultTaskPriority(),
-                                                dot1xSidDefaultTaskSlice());
+  dot1xTimerTaskId = osapiTaskCreate("dot1xTimerTask", (void *)dot1xTimerTask, 0, 0,
+                                     dot1xSidDefaultStackSize(),
+                                     dot1xSidDefaultTaskPriority(),
+                                     dot1xSidDefaultTaskSlice());
 
   if (dot1xTimerTaskId == L7_ERROR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1X_COMPONENT_ID,
             "Failed to create dot1x timer task\n");
     return L7_FAILURE;
Index: src/application/security/cpwio/wio_cnfgr.c
===================================================================
--- src/application/security/cpwio/wio_cnfgr.c	(revision 7772)
+++ src/application/security/cpwio/wio_cnfgr.c	(revision 7778)
@@ -520,13 +520,13 @@ L7_RC_t wioCnfgrUconfigPhase2(L7_CNFGR_R
 * @notes
 *
 * @end
 *********************************************************************/
 static L7_RC_t wioThreadCreate(void)
 {
-  L7_int32 wioTaskHandle;
+  L7_uint64 wioTaskHandle;
 
   wioInfo = (wioInfo_t*) osapiMalloc(L7_CP_WIO_COMPONENT_ID, sizeof(wioInfo_t));
   if (!wioInfo)
   {
     return L7_FAILURE;
   }
Index: src/application/security/mgmt_acal/macal_cnfgr.c
===================================================================
--- src/application/security/mgmt_acal/macal_cnfgr.c	(revision 7772)
+++ src/application/security/mgmt_acal/macal_cnfgr.c	(revision 7778)
@@ -31,17 +31,17 @@
 #include "nvstoreapi.h"
 #include "macal.h"
 #include "macal_cnfgr.h"
 
 macalCnfgrState_t macalCnfgrState = MACAL_PHASE_INIT_0;
 
-extern L7_int32       macalTaskId;
-extern void          *macalQueue;
+extern L7_uint64       macalTaskId;
+extern void           *macalQueue;
 extern macalCfgData_t *macalCfgData;
-/*extern void          *macalSemaphore;*/
-extern osapiRWLock_t    macalRwLock;
+/*extern void         *macalSemaphore;*/
+extern osapiRWLock_t   macalRwLock;
 
 /*********************************************************************
 *
 * @purpose  CNFGR System Initialization for Management Access Control and Administration List component
 *
 * @param    L7_CNFGR_CMD_DATA_t  *pCmdData    Data structure for this
Index: src/application/security/mgmt_acal/macal.c
===================================================================
--- src/application/security/mgmt_acal/macal.c	(revision 7772)
+++ src/application/security/mgmt_acal/macal.c	(revision 7778)
@@ -37,13 +37,13 @@
 #include "sysnet_api_ipv4.h"
 
 #include "usmdb_trapmgr_api.h"
 #include "sslt_exports.h"
 #include "acl_exports.h"
 
-L7_int32              macalTaskId;
+L7_uint64             macalTaskId;
 extern void           *macalQueue;
 extern macalCfgData_t *macalCfgData;
 osapiRWLock_t         macalRwLock;
 L7_uint32             macalDebugLevel;
 
 /*********************************************************************
Index: src/application/base/dos/dos_cnfgr.c
===================================================================
--- src/application/base/dos/dos_cnfgr.c	(revision 7772)
+++ src/application/base/dos/dos_cnfgr.c	(revision 7778)
@@ -29,13 +29,13 @@
 
 extern osapiRWLock_t       doSCfgRWLock;
 extern doSCfgData_t  *doSCfgData;
 doSCnfgrState_t doSCnfgrState = DOS_PHASE_INIT_0;
 PORTEVENT_MASK_t dosPortEventMask_g;
 extern void *dosQueue;
-extern L7_int32                   dosTaskId;
+extern L7_uint64                   dosTaskId;
 extern L7_uint32                  *dosMapTbl;
 
 /*********************************************************************
 *
 * @purpose  CNFGR System Initialization for DoS component
 *
Index: src/application/base/dos/dos.c
===================================================================
--- src/application/base/dos/dos.c	(revision 7772)
+++ src/application/base/dos/dos.c	(revision 7778)
@@ -33,13 +33,13 @@
 #include "dos_util.h"
 #include "l7_cnfgr_api.h"
 #include "l7_icmp.h"
 extern doSCfgData_t *doSCfgData;
 extern doSCnfgrState_t doSCnfgrState;
 osapiRWLock_t       doSCfgRWLock;
-L7_int32            dosTaskId;
+L7_uint64           dosTaskId;
 void *dosQueue = L7_NULLPTR;
 L7_uint32 *dosMapTbl = L7_NULLPTR;
 
 /*********************************************************************
 * @purpose  Build default DoS config data
 *
Index: src/application/base/dot1ab/core/lldp_cnfgr.c
===================================================================
--- src/application/base/dot1ab/core/lldp_cnfgr.c	(revision 7772)
+++ src/application/base/dot1ab/core/lldp_cnfgr.c	(revision 7778)
@@ -360,14 +360,14 @@ L7_RC_t lldpCnfgrInitPhase2Process(L7_CN
 
     *pResponse  = 0;
     *pReason    = L7_CNFGR_ERR_RC_FATAL;
     return L7_ERROR;
   }
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register lldpPduReceiveCallback related to type=%u, protocol_type=%u: 0x%08x",
-           SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_LLDP, (L7_uint32) lldpPduReceiveCallback);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register lldpPduReceiveCallback related to type=%u, protocol_type=%u: %p",
+           SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_LLDP, lldpPduReceiveCallback);
 
   /* register with sysnet for LLDP packets, no packets
      will actually be sent to the application until
      we configure the driver to accept them on the
      physical port, we do that when the receive
      function is enabled and port is up */
Index: src/application/base/dot1ab/core/lldp_med.c
===================================================================
--- src/application/base/dot1ab/core/lldp_med.c	(revision 7772)
+++ src/application/base/dot1ab/core/lldp_med.c	(revision 7778)
@@ -79,13 +79,13 @@ L7_RC_t lldpXMedNotificationRegister(L7_
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
             "LLDP-MED registrar ID %u greater than Last Component ID\n", component_ID);
     return(L7_FAILURE);
   }
 
-  if ((L7_uint32)lldpXMedNotifyList[component_ID].notify_med_intf != L7_NULL)
+  if (PTR_TO_UINT64(lldpXMedNotifyList[component_ID].notify_med_intf) != L7_NULL)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
             "LLDP-MED registrar ID %u, %s already registered\n", component_ID, name);
     return(L7_FAILURE);
   }
   (void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
Index: src/application/base/dot1ab/core/lldp.c
===================================================================
--- src/application/base/dot1ab/core/lldp.c	(revision 7772)
+++ src/application/base/dot1ab/core/lldp.c	(revision 7778)
@@ -35,13 +35,13 @@
 #ifdef L7_NSF_PACKAGE
 #include "lldp_ckpt.h"
 #endif /* L7_NSF_PACKAGE */
 
 extern lldpCfgData_t  *lldpCfgData;
 extern void           *lldpQueue;
-L7_int32               lldpTaskId;
+L7_uint64              lldpTaskId;
 
 /*********************************************************************
 * @purpose  Start 802.1AB task
 *
 * @param    none
 *
Index: src/application/base/sflow/include/sflow_mib.h
===================================================================
--- src/application/base/sflow/include/sflow_mib.h	(revision 7772)
+++ src/application/base/sflow/include/sflow_mib.h	(revision 7778)
@@ -138,13 +138,13 @@ typedef struct SFLOW_poller_DataKey_s
   L7_uint32 sFlowInstance;
 } SFLOW_poller_DataKey_t;
 
 typedef struct SFLOW_poller_timerData_s
 {
   L7_APP_TMR_HNDL_t      ctrPollTimer;
-  L7_uint32              ctrPollTimerHandle;
+  L7_uint64              ctrPollTimerHandle;
 } SFLOW_poller_timerData_t;
 
 typedef struct SFLOW_poller_s
 {
   SFLOW_poller_DataKey_t key;
   SFLOW_poller_mib_t    *pollerCfg;
@@ -194,13 +194,13 @@ typedef struct SFLOW_agent_s
 
 /* agent information */
   SFLOW_agent_mib_t    agentGroup;
 
 /* Buffer pools, Semaphores, msgQueues, 
    sockets, taskIDs, timerCBs...*/
-  L7_uint32            sFlowTaskHandle;
+  L7_uint64            sFlowTaskHandle;
 
 /* The sFlow thread reads from two queues. sFlow_Event_Queue
  * holds events to be processed. sFlow_Packet_Queue holds incoming
  * sFlow packets. */
   void                *sFlowMsgQSema;
   void                *sFlowEventQueue;
Index: src/application/base/sflow/sflow_cnfgr.c
===================================================================
--- src/application/base/sflow/sflow_cnfgr.c	(revision 7772)
+++ src/application/base/sflow/sflow_cnfgr.c	(revision 7778)
@@ -619,14 +619,14 @@ L7_RC_t sFlowCnfgrInitPhase2Process(L7_C
     *pResponse  = 0;
     *pReason    = L7_CNFGR_ERR_RC_FATAL;
     sFlowRC     = L7_ERROR;
     return sFlowRC;
   }
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register sFlowPduReceive related to type=%u, rx_reason=%u: 0x%08x",
-           SYSNET_PKT_RX_REASON, SFLOW_SAMPLE_INGRESS_REASON_CODE, (L7_uint32) sFlowPduReceive);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register sFlowPduReceive related to type=%u, rx_reason=%u: %p",
+              SYSNET_PKT_RX_REASON, SFLOW_SAMPLE_INGRESS_REASON_CODE, sFlowPduReceive);
 
   /* register with sysnet for sampled packets */
   bzero((char *)&snEntry, sizeof(sysnetNotifyEntry_t));
   strncpy(snEntry.funcName, "sFlowPduReceive", sizeof(snEntry.funcName));
   snEntry.notify_pdu_receive = sFlowPduReceive;
   snEntry.type = SYSNET_PKT_RX_REASON;
Index: src/application/base/sflow/sflow.c
===================================================================
--- src/application/base/sflow/sflow.c	(revision 7772)
+++ src/application/base/sflow/sflow.c	(revision 7778)
@@ -78,13 +78,13 @@ L7_RC_t sFlowPduReceive(L7_netBufHandle
   {
     pSampler->sample_pool++;
     /* obtain a buffer from the bufferpool */
     msg.msgId      = SFLOW_SAMPLE_RX;
     msg.dsIndex    = dsIndex;
     msg.instance   = FD_SFLOW_INSTANCE;
-    msg.direction  = ((SYSAPI_NET_MBUF_HEADER_t *)netBufHandle)->rxCode;
+    msg.direction  = ((SYSAPI_NET_MBUF_HEADER_t *) UINT_TO_PTR(netBufHandle))->rxCode;
     /* Get start and length of incoming frame */
     SYSAPI_NET_MBUF_GET_DATASTART(netBufHandle, data);
     SYSAPI_NET_MBUF_GET_DATALENGTH(netBufHandle, dataLength);
 
 
     msg.dataLength = dataLength;
Index: src/application/base/sflow/sflow_timer.c
===================================================================
--- src/application/base/sflow/sflow_timer.c	(revision 7772)
+++ src/application/base/sflow/sflow_timer.c	(revision 7778)
@@ -22,13 +22,13 @@
 #include "datatypes.h"
 
 #include "sflow_mib.h"
 #include "sflow_ctrl.h"
 #include "sflow_debug.h"
 extern SFLOW_agent_t agent;
-static L7_RC_t  sFlowTimerDestroy(L7_APP_TMR_HNDL_t *timer, L7_uint32 *handle);
+static L7_RC_t  sFlowTimerDestroy(L7_APP_TMR_HNDL_t *timer, L7_uint64 *handle);
 /*************************************************************************
 * @purpose  Starts the specified poll timer with specified time period
 *           and allocates related timer nodes
 *
 * @param    pPoller        @b{(input)}  reference to poller object
 * @param    interval       @b{(input)}  Timer period of the timer
@@ -39,18 +39,20 @@ static L7_RC_t  sFlowTimerDestroy(L7_APP
 * @comments none
 *
 * @end
 *************************************************************************/
 L7_RC_t sFlowPollerTimerStart(SFLOW_poller_t *pPoller, L7_uint32 interval)
 {
-  if (pPoller->timerData.ctrPollTimer != L7_NULL)
+  if (pPoller->timerData.ctrPollTimer != L7_NULLPTR)
   {
-    if (appTimerUpdate(agent.timerCB, &pPoller->timerData.ctrPollTimer,
+    if (appTimerUpdate(agent.timerCB,
+                       &pPoller->timerData.ctrPollTimer,
                        (void *)sFlowPollerTimerExpiry,
-                       (void *)pPoller->timerData.ctrPollTimerHandle, interval,
-                        "sFlowPollerTimerExpiry")
+                       UINT_TO_PTR(pPoller->timerData.ctrPollTimerHandle),
+                       interval,
+                       "sFlowPollerTimerExpiry")
                        != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_SFLOW_COMPONENT_ID,
               "sFlowPollerTimerStart: Timer could not be updated for dsIndex %u instance %u interval %u\n",
              pPoller->key.dsIndex, pPoller->key.sFlowInstance, interval);
     }
@@ -65,14 +67,14 @@ L7_RC_t sFlowPollerTimerStart(SFLOW_poll
          " Timer list is full and no more new timer creations are possible.");
     return L7_FAILURE;
   }
 
   if ((pPoller->timerData.ctrPollTimer
         = appTimerAdd(agent.timerCB, sFlowPollerTimerExpiry,
-                      (void *)pPoller->timerData.ctrPollTimerHandle,
-                       interval, "sFlowPollerTimerExpiry"))
+                      UINT_TO_PTR(pPoller->timerData.ctrPollTimerHandle),
+                      interval, "sFlowPollerTimerExpiry"))
         == L7_NULL)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_SFLOW_COMPONENT_ID,
             "sFlowPollerTimerStart: Could not start poller timer for dsIndex %u instance %u\n",
              pPoller->key.dsIndex, pPoller->key.sFlowInstance);
     return L7_FAILURE;
@@ -126,13 +128,13 @@ L7_RC_t sFlowPollerTimerStop(SFLOW_polle
 * @end
 *************************************************************************/
 void sFlowPollerTimerExpiry(void *param)
 {
   SFLOW_poller_t *pPoller;
 
-  pPoller = (SFLOW_poller_t *)handleListNodeRetrieve((L7_uint32)param);
+  pPoller = (SFLOW_poller_t *)handleListNodeRetrieve(PTR_TO_UINT64(param));
   if (pPoller == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_SFLOW_COMPONENT_ID,
             "sFlowPollerTimerExpiry: Failed to retrieve handle \n");
     return;
   }
@@ -166,13 +168,13 @@ void sFlowPollerTimerExpiry(void *param)
 * @returns  L7_FAILURE
 *
 * @comments none
 *
 * @end
 *************************************************************************/
-static L7_RC_t  sFlowTimerDestroy(L7_APP_TMR_HNDL_t *timer, L7_uint32 *handle)
+static L7_RC_t  sFlowTimerDestroy(L7_APP_TMR_HNDL_t *timer, L7_uint64 *handle)
 {
   /* Delete the apptimer node */
   (void)appTimerDelete(agent.timerCB, *timer);
   *timer = NULL;
 
   /* Delete the handle we had created */
Index: src/application/base/rmon/rmon_cnfgr.c
===================================================================
--- src/application/base/rmon/rmon_cnfgr.c	(revision 7772)
+++ src/application/base/rmon/rmon_cnfgr.c	(revision 7778)
@@ -51,13 +51,13 @@ rmonHistoryControlEntry_t *rmonHistoryCo
 /*Allocate Memory for Alarm Table */
 rmonAlarmEntry_t *rmonAlarmEntryArray;
 
 /* Allocate Memory for Event Table */
 rmonEventEntry_t *rmonEventEntryArray;
 
-L7_int32 L7_rmon_task_id;
+L7_uint64 L7_rmon_task_id;
 
 /* Bit mask of NIM events that RMON is registered to receive */
 PORTEVENT_MASK_t rmonNimEventMask;
 
 /* Semaphore to protect the rmon tables.
 */
Index: src/application/base/isdp/isdp_txrx.c
===================================================================
--- src/application/base/isdp/isdp_txrx.c	(revision 7772)
+++ src/application/base/isdp/isdp_txrx.c	(revision 7778)
@@ -196,14 +196,14 @@ L7_RC_t isdpPduReceive(L7_netBufHandle b
 *************************************************************************/
 L7_RC_t isdpTxRxInit(void)
 {
   L7_RC_t             rc      = L7_SUCCESS;
   sysnetNotifyEntry_t snEntry;
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register isdpPduReceive related to type=%u, protocol_type=%u: 0x%08x",
-           SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_ISDP, (L7_uint32) isdpPduReceive);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register isdpPduReceive related to type=%u, protocol_type=%u: %p",
+              SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_ISDP, isdpPduReceive);
 
   memset(&snEntry, 0, sizeof(snEntry));
 
   /*Register the pdu receive function with sysnet utility*/
   osapiStrncpy(snEntry.funcName, "isdpPduReceive", sizeof(snEntry.funcName));
   snEntry.notify_pdu_receive = isdpPduReceive;
Index: src/application/base/isdp/isdp_util.c
===================================================================
--- src/application/base/isdp/isdp_util.c	(revision 7772)
+++ src/application/base/isdp/isdp_util.c	(revision 7778)
@@ -24,13 +24,13 @@
 #include "cli_web_exports.h"
 #include "cli_web_mgr_api.h"
 #include "mirror_api.h"
 
 extern isdpStats_t        *isdpStats;
 extern isdpEntryTree_t    *isdpEntryTree;
-extern L7_uint32          isdpTaskId;
+extern L7_uint64          isdpTaskId;
 
 extern isdpCnfgrState_t   isdpCnfgrState;
 extern void               *isdpProcessQueue;
 extern isdpCfg_t          *isdpCfg;
 extern L7_uint32          *isdpMapTbl;
 extern isdpIntfInfoData_t *isdpIntfTbl;
Index: src/application/base/isdp/isdp_cfg.c
===================================================================
--- src/application/base/isdp/isdp_cfg.c	(revision 7772)
+++ src/application/base/isdp/isdp_cfg.c	(revision 7778)
@@ -26,13 +26,13 @@ extern isdpCfg_t        *isdpCfg;
 extern isdpCnfgrState_t isdpCnfgrState;
 
 void                    *isdpTaskSyncSema   = L7_NULLPTR;
 void                    *isdpProcessQueue   = L7_NULLPTR;
 void                    *isdpPduQueue       = L7_NULLPTR;
 void                    *isdpSemaphore      = L7_NULLPTR;
-L7_uint32               isdpTaskId          = 0;
+L7_uint64               isdpTaskId          = 0;
 L7_uint32               isdpIpAddrPoolId    = 0;
 isdpDebugCfg_t          isdpDebugCfg;
 
 /*********************************************************************
 * @purpose  Saves isdp configuration
 *
@@ -160,16 +160,16 @@ L7_RC_t isdpInit(L7_CNFGR_CMD_DATA_t *pC
     cbData.asyncResponse.rc = L7_FAILURE;
     cbData.asyncResponse.u.reason = L7_CNFGR_ERR_RC_LACK_OF_RESOURCES;
     cnfgrApiCallback(&cbData);
     return L7_FAILURE;
   }
 
-  isdpTaskId = (L7_uint32)osapiTaskCreate("isdpTask", (void *)isdpTask, 0, 0,
-                                             L7_ISDP_STACK_SIZE,
-                                             L7_ISDP_DEFAULT_ISDP_TASK_PRI,
-                                             L7_DEFAULT_TASK_SLICE);
+  isdpTaskId = osapiTaskCreate("isdpTask", (void *)isdpTask, 0, 0,
+                               L7_ISDP_STACK_SIZE,
+                               L7_ISDP_DEFAULT_ISDP_TASK_PRI,
+                               L7_DEFAULT_TASK_SLICE);
   if (isdpTaskId == L7_ERROR)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ISDP_COMPONENT_ID,
             "isdpInit: task creation error.\n");
     cbData.correlator = pCmdData->correlator;
     cbData.asyncResponse.rc = L7_FAILURE;
Index: src/application/base/isdp/isdp_control.c
===================================================================
--- src/application/base/isdp/isdp_control.c	(revision 7772)
+++ src/application/base/isdp/isdp_control.c	(revision 7778)
@@ -594,13 +594,13 @@ L7_RC_t isdpDataPduRead(L7_uint32 intIfN
 *
 * @returns    L7_SUCCESS or L7_FAILURE
 *
 * @end
 *
 *************************************************************************/
-L7_RC_t isdpTimerExpired(L7_uint32 arg1, L7_uint32 arg2)
+L7_RC_t isdpTimerExpired(L7_uint64 arg1, L7_uint64 arg2)
 {
   L7_RC_t   rc = L7_SUCCESS;
   isdpMsg_t msg;
 
   osapiTimerAdd((void*)isdpTimerExpired, 0, 0, ISDP_BASE_TIMEOUT, &isdpBaseTimer);
 
Index: src/application/base/isdp/include/isdp_control.h
===================================================================
--- src/application/base/isdp/include/isdp_control.h	(revision 7772)
+++ src/application/base/isdp/include/isdp_control.h	(revision 7778)
@@ -61,13 +61,13 @@ typedef struct isdpMsg_s
  ***************************************************************************
  */
 void isdpDispatchCmd(isdpMsg_t msg);
 void isdpTask();
 L7_RC_t isdpPduReceiveQueue( L7_uint32 intIfNum, L7_netBufHandle bufHandle);
 L7_RC_t isdpProcessMsgQueue(isdpMsg_t msg);
-L7_RC_t isdpTimerExpired(L7_uint32 arg1, L7_uint32 arg2);
+L7_RC_t isdpTimerExpired(L7_uint64 arg1, L7_uint64 arg2);
 L7_RC_t isdpPduReceiveProcess(L7_uint32 intIfNum, L7_netBufHandle bufHandle);
 L7_RC_t isdpPduSend(void);
 L7_RC_t isdpTimerProcess(void);
 L7_RC_t isdpDataPduRead(L7_uint32 intIfNum, L7_uchar8 *data, L7_uint32 length,
     isdpPacket_t* isdpPacket);
 L7_RC_t isdpCtlApplyConfigData(void);
Index: src/application/base/dhcps/dhcps_map.c
===================================================================
--- src/application/base/dhcps/dhcps_map.c	(revision 7772)
+++ src/application/base/dhcps/dhcps_map.c	(revision 7778)
@@ -1995,13 +1995,13 @@ void dhcpsCfgDataShow(int showAll)
     default:
       sysapiPrintf("\npoolType..........................UNKNOWN (%d)",
                    pDhcpsMapCfgData->pool[index].poolType);
       break;
     }
 
-    sysapiPrintf("\npoolName..........................%s", (L7_uint32)pDhcpsMapCfgData->pool[index].poolName);
+    sysapiPrintf("\npoolName..........................%s", pDhcpsMapCfgData->pool[index].poolName);
     sysapiPrintf("\nleaseTime.........................%d", (L7_uint32)pDhcpsMapCfgData->pool[index].leaseTime);
 
     for(i = 0; i < L7_DHCPS_DNS_SERVER_MAX; i++)
     {
       if ((showAll == 0) && (pDhcpsMapCfgData->pool[index].DNSServerAddrs[i] == 0))
       {
Index: src/application/base/dhcps/dhcps_main.c
===================================================================
--- src/application/base/dhcps/dhcps_main.c	(revision 7772)
+++ src/application/base/dhcps/dhcps_main.c	(revision 7778)
@@ -1934,70 +1934,70 @@ L7_ushort16 dhcpsCheckSum( L7_ushort16 *
 L7_RC_t dhcpsTransitionLeaseState(dhcpsLeaseNode_t * pLease, L7_int32 newState)
 {
   /* exit old state */
   switch(LEASE_DATA(pLease)->state)
   {
   case FREE_LEASE:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%u) exiting FREE state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%p) exiting FREE state\n", pLease);
     break;
 
   case EXPIRED_LEASE:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%u) exiting EXPIRED state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%p) exiting EXPIRED state\n", pLease);
     break;
 
   case OFFERED_LEASE:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%u) exiting OFFERED state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%p) exiting OFFERED state\n", pLease);
     dhcpsUnscheduleLease(pLease);
     break;
 
   case ACTIVE_LEASE:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%u) exiting ACTIVE state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%p) exiting ACTIVE state\n", pLease);
     dhcpsUnscheduleLease(pLease);
     break;
 
   case ABANDONED_LEASE:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%u) exiting ABANDONED state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%p) exiting ABANDONED state\n", pLease);
     /* reset ticks */
     pLease->leaseStartTime = 0;
     break;
 
   default:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_MED,"Lease (%u) exiting UNKNOWN state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_MED,"Lease (%p) exiting UNKNOWN state\n", pLease);
   }
 
   LEASE_DATA(pLease)->state = newState;
 
   /* enter new state */
   switch(LEASE_DATA(pLease)->state)
   {
   case FREE_LEASE:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%u) entering FREE state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%p) entering FREE state\n", pLease);
     break;
 
   case EXPIRED_LEASE:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%u) entering EXPIRED state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%p) entering EXPIRED state\n", pLease);
     break;
 
   case OFFERED_LEASE:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%u) entering OFFERED state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%p) entering OFFERED state\n", pLease);
     dhcpsScheduleLease(pLease, DHCPS_OFFER_VALIDITY_DURATION_SECS);
     break;
 
   case ACTIVE_LEASE:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%u) entering ACTIVE state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%p) entering ACTIVE state\n", pLease);
     dhcpsScheduleLease(pLease, LEASE_DATA(pLease)->leaseTime);
     break;
 
   case ABANDONED_LEASE:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%u) entering ABANDONED state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_LO,"Lease (%p) entering ABANDONED state\n", pLease);
     /* set ticks at which abandoned */
     pLease->leaseStartTime = simSystemUpTimeGet();
     break;
 
   default:
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_MED,"Lease (%u) entering UNKNOWN state\n", (L7_uint32)pLease);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_MED,"Lease (%p) entering UNKNOWN state\n", pLease);
   }
 
   return L7_SUCCESS;
 }
 
 /*********************************************************************
Index: src/application/base/dhcps/dhcps_map_util.c
===================================================================
--- src/application/base/dhcps/dhcps_map_util.c	(revision 7772)
+++ src/application/base/dhcps/dhcps_map_util.c	(revision 7778)
@@ -272,14 +272,14 @@ L7_RC_t dhcpsListDebugPrint(dhcpsLink_t
   dhcpsLink_t * tempLink;
 
   dhcpsListGetHead(link, &tempLink);
 
   while(tempLink != L7_NULLPTR)
   {
-    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_MED, "Node %d\tobj  %d\nprev %d\tnext %d\n\n",
-      (int)tempLink, (int)tempLink->object, (int)tempLink->prev, (int)tempLink->next);
+    DHCPS_MAP_PRT(DHCPS_MAP_MSGLVL_MED, "Node %p\tobj %p\nprev %p\tnext %p\n\n",
+      tempLink, tempLink->object, tempLink->prev, tempLink->next);
 
     tempLink = tempLink->next;
   }
 
   return L7_SUCCESS;
 }
Index: src/application/ip_mcast/mapping/mgmdmap/mgmdmap_map.c
===================================================================
--- src/application/ip_mcast/mapping/mgmdmap/mgmdmap_map.c	(revision 7772)
+++ src/application/ip_mcast/mapping/mgmdmap/mgmdmap_map.c	(revision 7778)
@@ -54,13 +54,13 @@ static void mgmdMapMcastCommonEventProce
 static L7_RC_t mgmdIntfCreate(mgmdMapCB_t *mgmdMapCbPtr, L7_uint32 intIfNum);
 
 static L7_RC_t mgmdIntfDelete(mgmdMapCB_t *mgmdMapCbPtr, L7_uint32 intIfNum);
 
 static L7_RC_t mgmdResetCleanUp(mgmdMapCB_t *mgmdMapCbPtr);
 
-static void mgmdMapStartupTimerExpireCallback(L7_uint32 familyType, L7_uint32 arg2);
+static void mgmdMapStartupTimerExpireCallback(L7_uint64 familyType, L7_uint64 arg2);
 
 /*********************************************************************
 *
 * @purpose task to handle all MGMD Mapping messages
 *
 * @param    none
@@ -1981,20 +1981,20 @@ L7_RC_t mgmdMapAdminScopeEventChangeCall
 {
   return mgmdMapComponentCallback(L7_AF_INET,eventType,
                                   msgLen, eventMsg);
 
 }
 
-void mgmdMapStartupTimerExpireCallback(L7_uint32 familyType, L7_uint32 arg2)
+void mgmdMapStartupTimerExpireCallback(L7_uint64 familyType, L7_uint64 arg2)
 {
   mgmdMapCB_t *mgmdMapCbPtr;
   L7_uint32    cbIndex;
   L7_uint32    protoMax;
   L7_BOOL      restartInProgress;
 
-  MGMD_MAP_DEBUG (MGMD_MAP_DEBUG_EVENTS, "Startup timer expired for familyType = %d", familyType);
+  MGMD_MAP_DEBUG (MGMD_MAP_DEBUG_EVENTS, "Startup timer expired for familyType = %d", (L7_uchar8) familyType);
 
   if (mgmdMapCtrlBlockGet((L7_uchar8) familyType, &mgmdMapCbPtr) != L7_SUCCESS)
   {
     /* Failed to get control block */
     MGMD_MAP_DEBUG (MGMD_MAP_DEBUG_FAILURES, "Failed to get Control Block");
     return;
Index: src/application/ip_mcast/mapping/mgmdmap/mgmdmap_vend_exten.c
===================================================================
--- src/application/ip_mcast/mapping/mgmdmap/mgmdmap_vend_exten.c	(revision 7772)
+++ src/application/ip_mcast/mapping/mgmdmap/mgmdmap_vend_exten.c	(revision 7778)
@@ -2331,13 +2331,13 @@ L7_RC_t mgmdMapProtocolMRPMembershipEven
 *
 * @comments This heapID is to be used for all the memory allocations for the
 *           given IP address family within the MGMD module
 *
 * @end
 *********************************************************************/
-L7_uint32 mgmdMapHeapIdGet (L7_uint32 family)
+L7_uint64 mgmdMapHeapIdGet (L7_uint32 family)
 {
   mgmdMapCB_t *mgmdMapCbPtr = L7_NULLPTR;
 
   if (mgmdMapCtrlBlockGet(family, &mgmdMapCbPtr) == L7_SUCCESS)
   {
     return (mgmdMapCbPtr->mgmdHeapId);
Index: src/application/ip_mcast/mapping/mgmdmap/include/mgmdmap_util.h
===================================================================
--- src/application/ip_mcast/mapping/mgmdmap/include/mgmdmap_util.h	(revision 7772)
+++ src/application/ip_mcast/mapping/mgmdmap/include/mgmdmap_util.h	(revision 7778)
@@ -102,13 +102,13 @@ typedef struct mgmdMapGblVars_s
   mgmdQueue_t        mgmdQueue[MGMD_MAX_Q];
 
   /* Counting semaphore. Semaphore is given every time a message is added to the
      mgmdMapMsgQueue or mgmdMapPktQueue or Apptimer Queue. The processing task waits
      on this semaphore before reading from the queues. */
   void              *mgmdMapMsgQSema;
-  L7_int32           mgmdMapTaskId;
+  L7_uint64          mgmdMapTaskId;
   mgmdCnfgrState_t   mgmdCnfgrState;
   L7_BOOL            warmRestart; /* L7_TRUE if last restart was a warm restart */
 } mgmdMapGblVars_t;
 
 
 
@@ -124,13 +124,13 @@ typedef struct mgmdMapCB_s
   L7_mgmdMapCfg_t  *pMgmdMapCfgData;
   L7_uchar8         familyType;
   L7_BOOL           warmRestartInProgress;       /* L7_TRUE if operating in warm Restart mode */
   osapiTimerDescr_t *mgmdMapStartupTimer;
   MCAST_CB_HNDL_t   cbHandle;
   MCAST_CB_HNDL_t   proxyCbHandle;
-  L7_uint32         mgmdHeapId;
+  L7_uint64         mgmdHeapId;
   mgmdMapGblVars_t *gblVars;
 } mgmdMapCB_t;
 
 extern mgmdMapGblVars_t mgmdMapGblVariables_g;
 extern mgmdMapCB_t     *mgmdMapCB_g;
 
Index: src/application/ip_mcast/mapping/mgmdmap/include/mgmdmap_vend_exten.h
===================================================================
--- src/application/ip_mcast/mapping/mgmdmap/include/mgmdmap_vend_exten.h	(revision 7772)
+++ src/application/ip_mcast/mapping/mgmdmap/include/mgmdmap_vend_exten.h	(revision 7778)
@@ -1115,9 +1115,9 @@ L7_RC_t mgmdMapProtocolMRPMembershipEven
 *
 * @comments This heapID is to be used for all the memory allocations for the
 *           given IP address family within the Multicast module
 *
 * @end
 *********************************************************************/
-L7_uint32 mgmdMapHeapIdGet (L7_uint32 family);
+L7_uint64 mgmdMapHeapIdGet (L7_uint32 family);
 
 #endif
Index: src/application/ip_mcast/mapping/pimsmmap/include/pimsm_map_util.h
===================================================================
--- src/application/ip_mcast/mapping/pimsmmap/include/pimsm_map_util.h	(revision 7772)
+++ src/application/ip_mcast/mapping/pimsmmap/include/pimsm_map_util.h	(revision 7778)
@@ -121,13 +121,13 @@ typedef struct pimsmGblVariables_s
   void                      *tempBuffer; /* TBD: To temporarily resolve the PIM-SM MsgQ Memory Corruption */
 
   pimsmMapQueue_t            pimsmQueue[PIMSM_MAX_Q];
   void                       *queueCountersSemId;
   void                       *msgQSema;
   pimsmCnfgrState_t          pimsmCnfgrState;
-  L7_uint32                  pimsmMapTaskId;
+  L7_uint64                  pimsmMapTaskId;
   void                       *eventCountersSemId;
   L7_uint32                  eventCounters[PIMSM_MAP_COUNTERS_TYPE_MAX];
   L7_BOOL                    warmRestart; /* L7_TRUE if last restart was a warm restart */
 } pimsmGblVariables_t;
 
 typedef struct pimsmMapCB_s
Index: src/application/ip_mcast/mapping/pimsmmap/pimsm_map.c
===================================================================
--- src/application/ip_mcast/mapping/pimsmmap/pimsm_map.c	(revision 7772)
+++ src/application/ip_mcast/mapping/pimsmmap/pimsm_map.c	(revision 7778)
@@ -34,13 +34,13 @@
 pimsmGblVariables_t pimsmGblVariables_g;
 pimsmMapCB_t        *pimsmMapCB;
 
 
 pimsmDebugCfg_t pimsmDebugCfg;
 
-static void pimsmMapStartupTimerExpireCallback(L7_uint32 familyType, L7_uint32 arg2);
+static void pimsmMapStartupTimerExpireCallback(L7_uint64 familyType, L7_uint64 arg2);
 static void pimsmMapStartupTimerExpireProcess(pimsmMapCB_t *pimsmMapCbPtr);
 static void pimsmMapRtrStartupDoneProcess(pimsmMapCB_t *pimsmMapCbPtr);
 
 /*********************************************************************
 * @purpose  Save PIM-SM user config file to NVStore
 *
@@ -1844,17 +1844,17 @@ void pimsmMapStartupTimerExpireProcess(p
   {
     (void)cnfgrApiComponentHwUpdateDone(L7_FLEX_PIMSM_MAP_COMPONENT_ID, L7_CNFGR_HW_APPLY_IPMCAST);
   }
   return;
 }
 
-void pimsmMapStartupTimerExpireCallback(L7_uint32 familyType, L7_uint32 arg2)
+void pimsmMapStartupTimerExpireCallback(L7_uint64 familyType, L7_uint64 arg2)
 {
   pimsmMapCB_t *pimsmMapCbPtr;
 
-  PIMSM_MAP_DEBUG (PIMSM_MAP_DEBUG_NSF, "Startup timer expired for familyType = %d", familyType);
+  PIMSM_MAP_DEBUG (PIMSM_MAP_DEBUG_NSF, "Startup timer expired for familyType = %d", (L7_uchar8) familyType);
 
   if (pimsmMapCtrlBlockGet((L7_uchar8) familyType, &pimsmMapCbPtr) != L7_SUCCESS)
   {
     /* Failed to get control block */
     PIMSM_MAP_DEBUG (PIMSM_MAP_DEBUG_FAILURES, "Failed to get Control Block");
     return;
Index: src/application/ip_mcast/mapping/pimdmmap/include/pimdm_map_util.h
===================================================================
--- src/application/ip_mcast/mapping/pimdmmap/include/pimdm_map_util.h	(revision 7772)
+++ src/application/ip_mcast/mapping/pimdmmap/include/pimdm_map_util.h	(revision 7778)
@@ -98,13 +98,13 @@ typedef enum
 typedef struct pimdmGblVars_s
 {
   void                      *msgQSema;
   pimdmMapQueue_t            pimdmQueue[PIMDM_MAX_Q];
   void                       *queueCountersSemId;
   pimdmCnfgrState_t          pimdmCnfgrState;
-  L7_int32                   pimdmMapTaskId;
+  L7_uint64                  pimdmMapTaskId;
   void                       *eventCountersSemId;
   L7_uint32                  eventCounters[PIMDM_MAP_COUNTERS_TYPE_MAX];
   L7_BOOL                    warmRestart; /* L7_TRUE if last restart was a warm restart */
 }pimdmGblVars_t;
 
 typedef struct pimdmMapCB_s
Index: src/application/ip_mcast/mapping/pimdmmap/pimdm_map.c
===================================================================
--- src/application/ip_mcast/mapping/pimdmmap/pimdm_map.c	(revision 7772)
+++ src/application/ip_mcast/mapping/pimdmmap/pimdm_map.c	(revision 7778)
@@ -61,13 +61,13 @@ static L7_BOOL pimdmMapIntfConfigEntryGe
 static void pimdmMapMcastCommonEventProcess(L7_uint32 event,
                                             pimdmMapCB_t *pimdmMapCbPtr);
 
 static L7_RC_t pimdmIntfCreate(L7_uint32 intIfNum, 
                                             pimdmMapCB_t *pimdmMapCbPtr); 
 
-static void pimdmMapStartupTimerExpireCallback(L7_uint32 familyType, L7_uint32 arg2);
+static void pimdmMapStartupTimerExpireCallback(L7_uint64 familyType, L7_uint64 arg2);
 
 static void pimdmMapRtrStartupDoneProcess(pimdmMapCB_t *pimdmMapCbPtr);
 
 /*********************************************************************
 *
 * @purpose task to handle all PIM-DM Mapping messages
@@ -1735,20 +1735,20 @@ L7_RC_t pimdmMapUIEventSend (pimdmMapCB_
   }
 
   return L7_SUCCESS;
 }
 
 
-void pimdmMapStartupTimerExpireCallback(L7_uint32 familyType, L7_uint32 arg2)
+void pimdmMapStartupTimerExpireCallback(L7_uint64 familyType, L7_uint64 arg2)
 {
   pimdmMapCB_t *pimdmMapCbPtr;
   L7_uint32    cbIndex;
   L7_uint32    protoMax;
   L7_BOOL      restartInProgress;
 
-  PIMDM_MAP_DEBUG (PIMDM_MAP_DEBUG_EVENTS, "Startup timer expired for familyType = %d", familyType);
+  PIMDM_MAP_DEBUG (PIMDM_MAP_DEBUG_EVENTS, "Startup timer expired for familyType = %d", (L7_uchar8) familyType);
 
   if (pimdmMapCtrlBlockGet((L7_uchar8) familyType, &pimdmMapCbPtr) != L7_SUCCESS)
   {
     /* Failed to get control block */
     PIMDM_MAP_DEBUG (PIMDM_MAP_DEBUG_FAILURES, "Failed to get Control Block");
     return;
Index: src/application/ip_mcast/mapping/mcastmap/include/mcast_util.h
===================================================================
--- src/application/ip_mcast/mapping/mcastmap/include/mcast_util.h	(revision 7772)
+++ src/application/ip_mcast/mapping/mcastmap/include/mcast_util.h	(revision 7778)
@@ -94,21 +94,21 @@ typedef struct mcastGblVar_s
   L7_uint32            *pMcastMapCfgMapTbl;
   L7_mcastMapCfg_t      mcastMapCfgData;     /* Configuration for IPv4 MCAST */
   L7_mcastMapCfg_t      *mcastMapV6CfgData;  /* Configuration for IPv6 MCAST */
   L7_uint32             mcastV4CtrlPktPoolId;
   L7_uint32             mcastV6CtrlPktPoolId;
   L7_uint32             mcastV6DataPktPoolId;
-  L7_uint32             mcastV4HeapId;
-  L7_uint32             mcastV6HeapId;
+  L7_uint64             mcastV4HeapId;
+  L7_uint64             mcastV6HeapId;
   L7_uint32             mcastAppTimerBufPoolId;
   void                  *mcastHandleListMemHndl;
   void                  *mcastV6HandleListMemHndl;
   L7_uint32             mcastV4MgmdEventsPoolId;
   L7_uint32             mcastV6MgmdEventsPoolId;
-  L7_int32              mcastMapTaskId;
-  L7_int32              pktRcvrTaskId;
+  L7_uint64             mcastMapTaskId;
+  L7_uint64             pktRcvrTaskId;
   L7_PktRcvr_t*         pktRcvr;
  /* Three message queues are created to prioritize the timer events and control msg events ahead of
     data packet reception events so that the operational control events are still
     handled irrespective of packets flowing at high data rate */
 
    mcastMapQueue_t            mcastMapQueue[MCASTMAP_MAX_Q];
Index: src/application/ip_mcast/mapping/mcastmap/core/mcast_map.c
===================================================================
--- src/application/ip_mcast/mapping/mcastmap/core/mcast_map.c	(revision 7772)
+++ src/application/ip_mcast/mapping/mcastmap/core/mcast_map.c	(revision 7778)
@@ -1757,13 +1757,13 @@ L7_RC_t mcastMapGetHandleListHandle (L7_
 *
 * @comments This heapID is to be used for all the memory allocations for the
 *           given IP address family within the Multicast module
 *
 * @end
 *********************************************************************/
-L7_uint32 mcastMapHeapIdGet (L7_uint32 family)
+L7_uint64 mcastMapHeapIdGet (L7_uint32 family)
 {
   if(family == L7_AF_INET)
   {
     return mcastGblVariables_g.mcastV4HeapId;
   }
   else if(family == L7_AF_INET6)
Index: src/application/ip_mcast/mapping/mcastmap/core/mcast_debug.c
===================================================================
--- src/application/ip_mcast/mapping/mcastmap/core/mcast_debug.c	(revision 7772)
+++ src/application/ip_mcast/mapping/mcastmap/core/mcast_debug.c	(revision 7778)
@@ -1085,13 +1085,13 @@ void mcastMapDebugRegisteredMulticastInf
 * @notes
 *
 * @end
 *********************************************************************/
 void mcastMapDebugHeapShow(L7_uchar8 addrFamily)
 {
-  L7_uint32 heapId;
+  L7_uint64 heapId;
 
   /* Basic validations */
   if ((addrFamily != L7_AF_INET) && (addrFamily != L7_AF_INET6))
   {
     sysapiPrintf ("Bad Address Family Specified.\n");
     return;
Index: src/application/ip_mcast/mapping/dvmrpmap/include/dvmrp_map_util.h
===================================================================
--- src/application/ip_mcast/mapping/dvmrpmap/include/dvmrp_map_util.h	(revision 7772)
+++ src/application/ip_mcast/mapping/dvmrpmap/include/dvmrp_map_util.h	(revision 7778)
@@ -93,13 +93,13 @@ typedef struct dvmrpGblVaribles_s
 
   dvmrpQueue_t              dvmrpQueue[DVMRP_MAX_Q];
   void                      *queueCountersSemId;
   L7_uint32                 eventCounters[DVMRP_MAP_COUNTERS_TYPE_MAX];
   void                      *eventCountersSemId;
   void                      *msgQSema;
-  L7_int32                  dvmrpMapTaskId;
+  L7_uint64                 dvmrpMapTaskId;
   dvmrpCnfgrState_t         dvmrpCnfgrState;
   MCAST_CB_HNDL_t           dvmrpCb;
   L7_uchar8                 family;
   L7_BOOL                   heapAlloc; 
 } dvmrpGblVaribles_t;
 
Index: src/application/ip_mcast/util/heapmgr/heap.h
===================================================================
--- src/application/ip_mcast/util/heapmgr/heap.h	(revision 7772)
+++ src/application/ip_mcast/util/heapmgr/heap.h	(revision 7778)
@@ -42,13 +42,13 @@
 
 /* This structure needs to have a aligned memory size or else add padding */
 typedef struct heapDebugInfo_s
 {
   L7_uchar8 fileName[HEAP_FILENAME_SIZE];
   L7_uint32 lineNumber;
-  L7_uint32 taskId;
+  L7_uint64 taskId;
   L7_uint32 sizeRequest;
 }heapDebugInfo_t;
 
 /* This structure would be prefixed and suffixed for every buffer allocated */
 typedef struct heapDebugMemGuard_s
 {
@@ -69,21 +69,21 @@ typedef struct heapStats_s
 typedef struct buffPool_s
 {
   L7_uint32   buffSize;        /* Adjusted user available size per buffer */
   L7_uint32   buffCount;       /* Number of buffers in this pool */
   L7_uchar8   descr[HEAP_POOLNAME_SIZE]; /* Name of the pool */
   L7_uint32   flags;           /* Flags defining extra properties of the pool */
-  L7_uint32   startLoc;        /* Start location (absolute address) */
-  L7_uint32   endLoc;          /* End location (absolute address) */
+  L7_uint64   startLoc;        /* Start location (absolute address) */
+  L7_uint64   endLoc;          /* End location (absolute address) */
   heapStats_t stats;           /* Buffer pool statistics */
   void        *freeList;       /* Singly linked free buffers in the pool */
 }buffPool_t;
 
 typedef struct heap_s
 {
-  L7_uint32          validateMem;     /* Need to be first item always */
+  L7_uint64          validateMem;     /* Need to be first item always */
   L7_COMPONENT_IDS_t compId;
   L7_uint32          heapSize;        /* Size of heap, excluding the heap node */
   L7_uint32          inUse;           /* Size of heap initialized; 0 if un-initialized*/
   buffPool_t         *buffPool;       /* would be the sorted list */
   L7_uint32          buffPoolCount;   /* number of buffer pools configured */
   L7_uint32          headerSize;      /* Size of headers, if any */
Index: src/application/ip_mcast/util/heapmgr/heap_api.h
===================================================================
--- src/application/ip_mcast/util/heapmgr/heap_api.h	(revision 7772)
+++ src/application/ip_mcast/util/heapmgr/heap_api.h	(revision 7778)
@@ -60,13 +60,13 @@ typedef struct heapBuffPool_s
 * @returns  L7_NULL on failure.
 *
 * @notes
 *
 * @end
 *********************************************************************/
-L7_uint32 heapCreate(L7_COMPONENT_IDS_t compId,
+L7_uint64 heapCreate(L7_COMPONENT_IDS_t compId,
                      size_t             size);
 
 /*********************************************************************
 *
 * @purpose  Initialize a Heap
 *
@@ -78,13 +78,13 @@ L7_uint32 heapCreate(L7_COMPONENT_IDS_t
 * @returns  L7_FAILURE
 *
 * @notes
 *
 * @end
 *********************************************************************/
-L7_RC_t heapInit(L7_uint32      heapId,
+L7_RC_t heapInit(L7_uint64      heapId,
                  heapBuffPool_t bList[],
                  heapFlags_t    flags);
 
 /*********************************************************************
 *
 * @purpose  De-initialize a Heap
@@ -96,13 +96,13 @@ L7_RC_t heapInit(L7_uint32      heapId,
 * @returns  L7_FAILURE
 *
 * @notes
 *
 * @end
 *********************************************************************/
-L7_RC_t heapDeInit(L7_uint32 heapId,
+L7_RC_t heapDeInit(L7_uint64 heapId,
 				   L7_BOOL   bForced);
 
 /*********************************************************************
 *
 * @purpose  Destroy a Heap
 *
@@ -113,13 +113,13 @@ L7_RC_t heapDeInit(L7_uint32 heapId,
 * @returns  L7_FAILURE
 *
 * @notes
 *
 * @end
 *********************************************************************/
-L7_RC_t heapDestroy(L7_uint32 heapId,
+L7_RC_t heapDestroy(L7_uint64 heapId,
 					L7_BOOL   bForced);
 
 /*********************************************************************
 *
 * @purpose  Allocation from the heap
 *
@@ -132,13 +132,13 @@ L7_RC_t heapDestroy(L7_uint32 heapId,
 * @returns  L7_NULLPTR on failure
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void *heapAlloc(L7_uint32 heapId,
+void *heapAlloc(L7_uint64 heapId,
                 size_t    size,
                 L7_uchar8 *fileName,
                 L7_uint32 lineNumber);
 
 /*********************************************************************
 *
@@ -150,13 +150,13 @@ void *heapAlloc(L7_uint32 heapId,
 * @returns  None
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void heapFree(L7_uint32 heapId,
+void heapFree(L7_uint64 heapId,
               void      *pMem);
 
 /*********************************************************************
 *
 * @purpose  Check if a buffer is valid in a heap context
 *
@@ -167,13 +167,13 @@ void heapFree(L7_uint32 heapId,
 * @returns  L7_FAILURE
 *
 * @notes
 *
 * @end
 *********************************************************************/
-L7_RC_t heapBuffValidate(L7_uint32 heapId,
+L7_RC_t heapBuffValidate(L7_uint64 heapId,
                          void      *pMem);
 
 /*********************************************************************
 *
 * @purpose  To display the basic statistics for a heap
 *
@@ -182,13 +182,13 @@ L7_RC_t heapBuffValidate(L7_uint32 heapI
 * @returns  None
 *
 * @notes    memShow equivalent data output
 *
 * @end
 *********************************************************************/
-void  heapShow(L7_uint32 heapId);
+void  heapShow(L7_uint64 heapId);
 
 /*********************************************************************
 *
 * @purpose  Enable/disable debug prints for a heap
 *
 * @param    heapId   @b{(input)} Heap ID
@@ -197,13 +197,13 @@ void  heapShow(L7_uint32 heapId);
 * @returns  None
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void heapDbgPrintSet(L7_uint32 heapId,
+void heapDbgPrintSet(L7_uint64 heapId,
                      L7_uint32 dbgPrint);
 
 /*********************************************************************
 *
 * @purpose  To display the status for a heap
 *
@@ -212,13 +212,13 @@ void heapDbgPrintSet(L7_uint32 heapId,
 * @returns  None
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void heapDbgStatsDisplay(L7_uint32 heapId);
+void heapDbgStatsDisplay(L7_uint64 heapId);
 
 /*********************************************************************
 *
 * @purpose  Display available information on a heap allocated buffer
 *
 * @param    heapId  @b{(input)} Heap ID
@@ -227,12 +227,12 @@ void heapDbgStatsDisplay(L7_uint32 heapI
 * @returns  None
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void heapDbgBuffInfo(L7_uint32 heapId,
+void heapDbgBuffInfo(L7_uint64 heapId,
                      void      *pMem);
 
 #endif /* HEAP_API_INCLUDE_H */
 
 
Index: src/application/ip_mcast/util/heapmgr/heap.c
===================================================================
--- src/application/ip_mcast/util/heapmgr/heap.c	(revision 7772)
+++ src/application/ip_mcast/util/heapmgr/heap.c	(revision 7778)
@@ -219,26 +219,27 @@ L7_RC_t heapInitialize(heap_t         *h
                        heapFlags_t    flags,
                        L7_uint32      heapSize,
                        L7_uint32      buffPoolCount)
 {
   heapBuffPool_t  *tmpBuffPool= (heapBuffPool_t*)bList;
   buffPool_t      *heapBuffPool, *freeBuffPool, *buffPool;
-  L7_uint32       dataPtr, buffOverhead, i, j, buffSize;
+  L7_uint32       buffOverhead, i, j, buffSize;
+  L7_uint64       dataPtr;
 
   /* Simple validations */
   if((heap == L7_NULLPTR) || (tmpBuffPool == L7_NULLPTR) ||
      (heapSize == 0) || (buffPoolCount == 0))
   {
     HEAP_TRACE(HEAP_PRINT_ALWAYS,"\n[%s:%u]Error: Invalid Params - heap %x, bList %x, heapSize %u, buffPoolCount %u\n",
                __FUNCTION__,__LINE__,heap,tmpBuffPool,heapSize,buffPoolCount);
     return L7_FAILURE;
   }
 
   /* Set-up the heap structure */
-  memset((void *)((L7_uint32)heap + sizeof(heap_t)), 0, heapSize);
-  heap->buffPool = (buffPool_t *)((L7_uint32)heap + sizeof(heap_t));
+  memset(UINT_TO_PTR(PTR_TO_UINT64(heap) + sizeof(heap_t)), 0, heapSize);
+  heap->buffPool = (buffPool_t *)UINT_TO_PTR(PTR_TO_UINT64(heap) + sizeof(heap_t));
   heap->buffPoolCount = buffPoolCount;
   heap->flags = flags;
   heap->dbgPrint = 0;  /* Turn-off debug prints by default */
   if((flags & HEAP_DEBUG_FILE_INFO) != 0)
   {
     heap->headerSize += sizeof(heapDebugInfo_t);
@@ -308,25 +309,25 @@ L7_RC_t heapInitialize(heap_t         *h
       freeBuffPool->flags = tmpBuffPool->flags;
     }
     freeBuffPool++;
   }
 
   /* Populate the free list and the start & end locs */
-  dataPtr = (L7_uint32)(heap->buffPool) + buffPoolCount * sizeof(buffPool_t);
+  dataPtr = PTR_TO_UINT64(heap->buffPool) + buffPoolCount * sizeof(buffPool_t);
   buffOverhead = heap->headerSize +
                  (((flags & HEAP_DEBUG_MEMORY_GUARD) != 0) ?
                   sizeof(heapDebugMemGuard_t) : 0);
   for(i = 0, buffPool = heap->buffPool; i < buffPoolCount; i++, buffPool++)
   {
     buffPool->startLoc = dataPtr;
     buffPool->endLoc = dataPtr +
       (buffPool->buffSize + buffOverhead) * buffPool->buffCount - 1;
     for(j = 0; j < buffPool->buffCount; j++)
     {
-      *(L7_uint32 *)(dataPtr + heap->headerSize) = (L7_uint32)(buffPool->freeList);
-      buffPool->freeList = (void *)(dataPtr + heap->headerSize);
+      PTR_SET_VALUE(UINT_TO_PTR(dataPtr + heap->headerSize)) = PTR_TO_UINT64(buffPool->freeList);
+      buffPool->freeList = UINT_TO_PTR(dataPtr + heap->headerSize);
       dataPtr += buffPool->buffSize + buffOverhead;
     }
   }
   /* All OK; set the heap to be in use */
   heapSizeUpdate(heap, heapSize);
   return L7_SUCCESS;
@@ -349,16 +350,17 @@ L7_RC_t heapInitialize(heap_t         *h
 *********************************************************************/
 static
 L7_RC_t heapBuffPoolGet(heap_t     *heap,
                         void       *pMem,
                         buffPool_t **buffPool)
 {
-  L7_uint32 pBuff, i;
+  L7_uint64 pBuff;
+  L7_uint32 i;
 
   /* Get the pointer to the whole buffer (including the debug header info) */
-  pBuff =  (L7_uint32)pMem - heap->headerSize;
+  pBuff =  PTR_TO_UINT64(pMem) - heap->headerSize;
 
   /* Iterate through the various pools and see which pool does this buffer belong */
   *buffPool = heap->buffPool;
   for(i = 0; (i < heap->buffPoolCount) && (*buffPool != L7_NULLPTR);
      i++, (*buffPool)++)
   {
@@ -408,13 +410,13 @@ L7_RC_t heapBuffPoolGet(heap_t     *heap
 * @returns  L7_NULL on failure.
 *
 * @notes
 *
 * @end
 *********************************************************************/
-L7_uint32 heapCreate(L7_COMPONENT_IDS_t compId,
+L7_uint64 heapCreate(L7_COMPONENT_IDS_t compId,
                      size_t             size)
 {
   L7_uint32 heapSize, usrSize;
   heap_t    *heap = L7_NULL;
 
   /* Basic sanity checks */
@@ -434,13 +436,13 @@ L7_uint32 heapCreate(L7_COMPONENT_IDS_t
                __FUNCTION__,__LINE__,heapSize);
     return L7_NULL;
   }
 
   /* Initialize the heap structure and return the heapID */
   memset(heap, 0, sizeof(heap_t));
-  heap->validateMem = (L7_uint32)heap;
+  heap->validateMem = PTR_TO_UINT64(heap);
   heap->compId = compId;
   heap->heapSize = usrSize;
   heap->inUse = 0;
   heap->heapSemId = osapiSemaBCreate(OSAPI_SEM_Q_FIFO, OSAPI_SEM_FULL);
   if(heap->heapSemId == L7_NULLPTR)
   {
@@ -453,13 +455,13 @@ L7_uint32 heapCreate(L7_COMPONENT_IDS_t
   if(heap->semId == L7_NULLPTR)
   {
     HEAP_TRACE(HEAP_PRINT_ALWAYS,"\n[%s:%u]Error: Semaphore creation failed\n",
                __FUNCTION__,__LINE__);
     return L7_FAILURE;
   }
-  return (L7_uint32)heap;
+  return PTR_TO_UINT64(heap);
 }
 
 /*********************************************************************
 *
 * @purpose  Initialize a Heap
 *
@@ -471,34 +473,34 @@ L7_uint32 heapCreate(L7_COMPONENT_IDS_t
 * @returns  L7_FAILURE
 *
 * @notes
 *
 * @end
 *********************************************************************/
-L7_RC_t heapInit(L7_uint32      heapId,
+L7_RC_t heapInit(L7_uint64      heapId,
                  heapBuffPool_t bList[],
                  heapFlags_t    flags)
 {
-  heap_t    *heap = (heap_t*)heapId;
+  heap_t    *heap = (heap_t*) UINT_TO_PTR(heapId);
   L7_uint32 heapSize, buffPoolCount;
 
   /* Basic sanity checks */
-  if(heap == L7_NULLPTR || (*((L7_uint32*)heapId) != heapId))
+  if(heap == L7_NULLPTR || (PTR_GET_VALUE(UINT_TO_PTR(heapId)) != heapId))
   {
     HEAP_TRACE(HEAP_PRINT_ALWAYS,
-               "[%s:%u] ERROR: Heap Initialization failed for heapId - %x\n",
+               "[%s:%u] ERROR: Heap Initialization failed for heapId - %llx\n",
                __FUNCTION__,__LINE__,heapId);
     return L7_FAILURE;
   }
   if(heapIsInUse(heap) == L7_TRUE)
   {
     /* While changing one MRP to other MRP, very fast
        we dont want this message on the console
      */
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_FLEX_MCAST_MAP_COMPONENT_ID,
-            "[%s:%u] Heap with ID 0x%x is already in use\n",
+            "[%s:%u] Heap with ID 0x%llx is already in use\n",
                __FUNCTION__,__LINE__,heapId);
 
     return L7_FAILURE;
   }
 
   /* Validate the params & Compute the heap size */
@@ -529,41 +531,41 @@ L7_RC_t heapInit(L7_uint32      heapId,
 * @returns  L7_FAILURE
 *
 * @notes
 *
 * @end
 *********************************************************************/
-L7_RC_t heapDeInit(L7_uint32 heapId,
+L7_RC_t heapDeInit(L7_uint64 heapId,
                    L7_BOOL   bForced)
 {
-  heap_t     *heap = (heap_t*)heapId;
+  heap_t     *heap = (heap_t*)UINT_TO_PTR(heapId);
   L7_uint32  i;
   buffPool_t *buffPool;
 
   /* Validate the heap */
-  if(heap == L7_NULLPTR || (*((L7_uint32*)heapId) != heapId))
+  if(heap == L7_NULLPTR || (PTR_GET_VALUE(UINT_TO_PTR(heapId)) != heapId))
   {
     HEAP_TRACE(HEAP_PRINT_ALWAYS,
-               "[%s:%u] ERROR: Invalid Heap ID %x. De-Init failed\n",
+               "[%s:%u] ERROR: Invalid Heap ID %llx. De-Init failed\n",
                __FUNCTION__,__LINE__,heapId);
     return L7_FAILURE;
   }
   if(heapIsInUse(heap) == L7_FALSE)
   {
     HEAP_TRACE(HEAP_PRINT_ALWAYS,
-               "[%s:%u] ERROR: Heap %x is not inited yet; De-Init failed.\n",
+               "[%s:%u] ERROR: Heap %llx is not inited yet; De-Init failed.\n",
                __FUNCTION__,__LINE__,heapId);
     return L7_FAILURE;
   }
   /* Lock Heap accesses, if needed */
   if((heap->flags & HEAP_LOCK_GUARD) != 0)
   {
     if(osapiSemaTake(heap->semId, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
       HEAP_TRACE(HEAP_PRINT_ALWAYS,
-                 "[%s:%u] ERROR: Semaphore acquisition failed for heap 0x%x.\n",
+                 "[%s:%u] ERROR: Semaphore acquisition failed for heap 0x%llx.\n",
                  __FUNCTION__,__LINE__,heapId);
       return L7_FAILURE;
     }
   }
 
   /* Check if any outstanding allocations */
@@ -572,13 +574,13 @@ L7_RC_t heapDeInit(L7_uint32 heapId,
     for(i = 0, buffPool = heap->buffPool; i < heap->buffPoolCount; i++, buffPool++)
     {
       if(buffPool->stats.allocCount != 0)
       {
         /* Outstanding allocated buffers */
         HEAP_TRACE(HEAP_PRINT_ALWAYS,
-                   "[%s:%u] Outstanding buffers (%u) allocated in buffpool %s, heap 0x%x. De-Init failed.\n",
+                   "[%s:%u] Outstanding buffers (%u) allocated in buffpool %s, heap 0x%llx. De-Init failed.\n",
                    __FUNCTION__,__LINE__,buffPool->stats.allocCount,buffPool->descr,heapId);
         /* Unlock access */
         if((heap->flags & HEAP_LOCK_GUARD) != 0)
         {
           osapiSemaGive(heap->semId);
         }
@@ -610,37 +612,37 @@ L7_RC_t heapDeInit(L7_uint32 heapId,
 * @returns  L7_FAILURE
 *
 * @notes
 *
 * @end
 *********************************************************************/
-L7_RC_t heapDestroy(L7_uint32 heapId,
+L7_RC_t heapDestroy(L7_uint64 heapId,
                     L7_BOOL   bForced)
 {
-  heap_t     *heap = (heap_t*)heapId;
+  heap_t     *heap = (heap_t*)UINT_TO_PTR(heapId);
 
   /* Validate the heap */
-  if(heap == L7_NULLPTR || (*((L7_uint32*)heapId) != heapId))
+  if(heap == L7_NULLPTR || (PTR_GET_VALUE(UINT_TO_PTR(heapId)) != heapId))
   {
     HEAP_TRACE(HEAP_PRINT_ALWAYS,
-               "FAILED to destroy the heap with ID - %x. Invalid heapID\n",
+               "FAILED to destroy the heap with ID - %llx. Invalid heapID\n",
                heapId);
     return L7_FAILURE;
   }
   /* Check if any outstanding allocations */
   if((bForced != L7_TRUE) && heapIsInUse(heap) == L7_TRUE)
   {
     /* Still in use */
     HEAP_TRACE(HEAP_PRINT_ALWAYS,
-               "FAILED to destroy the heap with ID - %x. Heap in use\n",
+               "FAILED to destroy the heap with ID - %llx. Heap in use\n",
                heapId);
     return L7_FAILURE;
   }
 
   /* Invalidate the heap and then free-up the resources */
-  heap->validateMem = (L7_uint32)L7_NULL;
+  heap->validateMem = (L7_uint64)L7_NULL;
   heapSizeUpdate(heap, 0);
 
   osapiSemaDelete(heap->heapSemId);
   heap->semId = L7_NULLPTR;
 
   osapiSemaDelete(heap->semId);
@@ -664,26 +666,26 @@ L7_RC_t heapDestroy(L7_uint32 heapId,
 * @returns  L7_NULLPTR on failure
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void *heapAlloc(L7_uint32 heapId,
+void *heapAlloc(L7_uint64 heapId,
                 size_t    size,
                 L7_uchar8 *fileName,
                 L7_uint32 lineNumber)
 {
-  heap_t     *heap = (heap_t*)heapId;
+  heap_t     *heap = (heap_t*) UINT_TO_PTR(heapId);
   buffPool_t *buffPool;
   void       *output = L7_NULLPTR;
   L7_uint32  i;
 
   l7utilsFilenameStrip((L7_char8 **)&fileName);
 
   /* Basic sanity checks */
-  if((heap == L7_NULL) || (*((L7_uint32*)heapId) != heapId) || (size == 0))
+  if((heap == L7_NULL) || (PTR_GET_VALUE(UINT_TO_PTR(heapId)) != heapId) || (size == 0))
   {
     HEAP_TRACE(HEAP_PRINT_ALWAYS,"Failed to allocate memory -Invalid Params\n");
     return L7_NULLPTR;
   }
   if(heapIsInUse(heap) == L7_FALSE)
   {
@@ -715,34 +717,34 @@ void *heapAlloc(L7_uint32 heapId,
     if(buffPool->freeList != L7_NULLPTR)
     {
       void *wholeBuff;
 
       /* Extract the free buffer from the freeList */
       output = (void *)buffPool->freeList;
-      buffPool->freeList = (void *)(*(L7_uint32 *)output);
-      *(L7_uint32 *)output = 0;
+      buffPool->freeList = UINT_TO_PTR(PTR_GET_VALUE(output));
+      PTR_SET_VALUE(output) = 0;
 
       /* Setup the debug information */
-      wholeBuff = (void *)((L7_uint32)(output) - heap->headerSize);
+      wholeBuff = (void *)UINT_TO_PTR(PTR_TO_UINT64(output) - heap->headerSize);
       if((heap->flags & HEAP_DEBUG_FILE_INFO) != 0)
       {
         heapDebugInfo_t *dbgInfo = (heapDebugInfo_t *)wholeBuff;
         osapiStrncpy(dbgInfo->fileName, fileName, sizeof(dbgInfo->fileName));
         dbgInfo->lineNumber = lineNumber;
         if(osapiTaskIDSelfGet(&(dbgInfo->taskId)) != L7_SUCCESS)
         {
           dbgInfo->taskId = 0;
         }
         dbgInfo->sizeRequest = size;
-        wholeBuff = (void *)((L7_uint32)(wholeBuff) + sizeof(heapDebugInfo_t));
+        wholeBuff = (void *)UINT_TO_PTR(PTR_TO_UINT64(wholeBuff) + sizeof(heapDebugInfo_t));
       }
       if((heap->flags & HEAP_DEBUG_MEMORY_GUARD) != 0)
       {
         heapDebugMemGuard_t *dbgInfo = (heapDebugMemGuard_t *)wholeBuff;
         dbgInfo->guardWord = HEAP_GUARD_WORD_HEADER;
-        dbgInfo = (heapDebugMemGuard_t *)((L7_uint32)(output) + buffPool->buffSize);
+        dbgInfo = (heapDebugMemGuard_t *)UINT_TO_PTR(PTR_TO_UINT64(output) + buffPool->buffSize);
         dbgInfo->guardWord = HEAP_GUARD_WORD_TRAILER;
       }
 
       /* Update stats and exit */
       buffPool->stats.allocSuccess++;
       buffPool->stats.allocCount++;
@@ -767,13 +769,13 @@ void *heapAlloc(L7_uint32 heapId,
   /* If system mallocs are allowed, then try and satisfy the request using mallocs */
   if((i == heap->buffPoolCount) || (buffPool == L7_NULLPTR))
   {
     if((heap->flags & HEAP_MALLOC_ENABLE) != 0)
     {
       HEAP_TRACE(heap->dbgPrint,
-                 "Allocating from system memory for heapID - %x and size -%d \n",
+                 "Allocating from system memory for heapID - 0x%llx and size -%d \n",
                  heapId, size);
       output = (void*)osapiMalloc(heap->compId, size);
       if(output != L7_NULLPTR)
       {
         heap->sysMemStats.allocCount++;
         heap->sysMemStats.allocSuccess++;
@@ -787,13 +789,13 @@ void *heapAlloc(L7_uint32 heapId,
         heap->sysMemStats.allocFail++;
       }
     }
     else
     {
       HEAP_TRACE(heap->dbgPrint,
-                 "Failed: to allocate memory for heapID - %x and size -%d \n",
+                 "Failed: to allocate memory for heapID - 0x%llx and size -%d \n",
                  heapId,size);
       heap->sysMemStats.allocFail++;
     }
   }
 
   /* Unlock access */
@@ -815,21 +817,21 @@ void *heapAlloc(L7_uint32 heapId,
 * @returns  None
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void heapFree(L7_uint32 heapId,
+void heapFree(L7_uint64 heapId,
               void      *pMem)
 {
-  heap_t     *heap = (heap_t*)heapId;
+  heap_t     *heap = (heap_t*)UINT_TO_PTR(heapId);
   buffPool_t *buffPool;
 
   /* Basic sanity checks */
   if((heap == L7_NULL) || (pMem == L7_NULLPTR) ||
-     (*((L7_uint32*)heapId) != heapId))
+     (PTR_GET_VALUE(UINT_TO_PTR(heapId)) != heapId))
   {
     HEAP_TRACE(HEAP_PRINT_ALWAYS,"Failed to free to heap - Invalid Params\n");
     return;
   }
   if(heapIsInUse(heap) == L7_FALSE)
   {
@@ -848,13 +850,13 @@ void heapFree(L7_uint32 heapId,
   }
 
   /* Retrieve the buffer pool structure associated with the given buffer */
   if(heapBuffPoolGet(heap, pMem, &buffPool) == L7_SUCCESS)
   {
     /* Valid buffer to be freed-up */
-    *(L7_uint32 *)pMem = (L7_uint32)(buffPool->freeList);
+    PTR_SET_VALUE(pMem) = PTR_TO_UINT64(buffPool->freeList);
     buffPool->freeList = pMem;
 
     /* Update stats */
     buffPool->stats.allocCount--;
     buffPool->stats.cumFreeCount++;
   }
@@ -889,22 +891,22 @@ void heapFree(L7_uint32 heapId,
 * @returns  L7_FAILURE
 *
 * @notes
 *
 * @end
 *********************************************************************/
-L7_RC_t heapBuffValidate(L7_uint32 heapId,
+L7_RC_t heapBuffValidate(L7_uint64 heapId,
                          void      *pMem)
 {
-  heap_t     *heap = (heap_t*)heapId;
+  heap_t     *heap = (heap_t*)UINT_TO_PTR(heapId);
   buffPool_t *buffPool;
   L7_RC_t    retVal = L7_FAILURE;
 
   /* Basic sanity checks */
   if((heap == L7_NULL) || (pMem == L7_NULLPTR) ||
-     (*((L7_uint32*)heapId) != heapId))
+     (PTR_GET_VALUE(UINT_TO_PTR(heapId)) != heapId))
   {
     return retVal;
   }
   if(heapIsInUse(heap) == L7_FALSE)
   {
     /* Un-initialized heap access */
@@ -942,18 +944,18 @@ L7_RC_t heapBuffValidate(L7_uint32 heapI
 * @returns  None
 *
 * @notes    memShow equivalent data output
 *
 * @end
 *********************************************************************/
-void  heapShow(L7_uint32 heapId)
+void  heapShow(L7_uint64 heapId)
 {
-  heap_t *heap = (heap_t *)heapId;
+  heap_t *heap = (heap_t *)UINT_TO_PTR(heapId);
 
   /* validate heap ID */
-  if((heap == L7_NULLPTR) || (*((L7_uint32*)heapId) != heapId))
+  if((heap == L7_NULLPTR) || (PTR_GET_VALUE(UINT_TO_PTR(heapId)) != heapId))
   {
     sysapiPrintf("Invalid Heap ID : 0x%x\n", heapId);
     return;
   }
   /* First dump the heap structure info */
   sysapiPrintf(" \n *********************** HEAP INFORMATION ********************** \n");
@@ -990,19 +992,19 @@ void  heapShow(L7_uint32 heapId)
 * @returns  None
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void heapDbgPrintSet(L7_uint32 heapId,
+void heapDbgPrintSet(L7_uint64 heapId,
                      L7_uint32 dbgPrint)
 {
-  heap_t *heap = (heap_t*)heapId;
+  heap_t *heap = (heap_t*)UINT_TO_PTR(heapId);
 
   /* validate heap ID */
-  if((heap == L7_NULLPTR) || (*((L7_uint32*)heapId) != heapId))
+  if((heap == L7_NULLPTR) || (PTR_GET_VALUE(UINT_TO_PTR(heapId)) != heapId))
   {
     return;
   }
   heap->dbgPrint = dbgPrint;
 }
 
@@ -1015,28 +1017,28 @@ void heapDbgPrintSet(L7_uint32 heapId,
 * @returns  None
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void heapDbgStatsDisplay(L7_uint32 heapId)
+void heapDbgStatsDisplay(L7_uint64 heapId)
 {
-  heap_t     *heap = (heap_t*)heapId;
+  heap_t     *heap = (heap_t*)UINT_TO_PTR(heapId);
   buffPool_t *tempPool;
   L7_uint32  i;
 
   /* Basic sanity checks */
-  if(heap == L7_NULLPTR || (*((L7_uint32*)heapId) != heapId))
+  if(heap == L7_NULLPTR || (PTR_GET_VALUE(UINT_TO_PTR(heapId)) != heapId))
   {
-    sysapiPrintf(" \n Invalid Heap ID : 0x%x\n", heapId);
+    sysapiPrintf(" \n Invalid Heap ID : 0x%llx\n", heapId);
     return;
   }
 
   /* First dump the heap structure info */
   sysapiPrintf(" \n *********************** HEAP INFORMATION ********************** \n");
-  sysapiPrintf(" Heap ID                        - 0x%x\n",heapId);
+  sysapiPrintf(" Heap ID                        - 0x%llx\n",heapId);
   sysapiPrintf(" Component ID                   - %u\n",heap->compId);
   sysapiPrintf(" Total heap size                - %u\n",heap->heapSize);
   if(heapIsInUse(heap) == L7_FALSE)
   {
     sysapiPrintf(" Heap Not In Use\n");
   }
@@ -1058,14 +1060,14 @@ void heapDbgStatsDisplay(L7_uint32 heapI
     {
       sysapiPrintf(" \n ******** Buffer Pool #%d Stats :\n", i + 1);
       sysapiPrintf("   Buffer Size                - %u\n",tempPool->buffSize);
       sysapiPrintf("   Number of buffers          - %u\n",tempPool->buffCount);
       sysapiPrintf("   Description of the pool    - %s\n",tempPool->descr);
       sysapiPrintf("   Flags                      - 0x%x\n",tempPool->flags);
-      sysapiPrintf("   Starting Memory Address    - 0x%x\n",tempPool->startLoc);
-      sysapiPrintf("   Ending Memory Address      - 0x%x\n",tempPool->endLoc);
+      sysapiPrintf("   Starting Memory Address    - 0x%llx\n",tempPool->startLoc);
+      sysapiPrintf("   Ending Memory Address      - 0x%llx\n",tempPool->endLoc);
       sysapiPrintf("   Current outstanding allocs - %u\n",tempPool->stats.allocCount);
       sysapiPrintf("   Total successful allocs    - %u\n",tempPool->stats.allocSuccess);
       sysapiPrintf("   Total failed allocs        - %u\n",tempPool->stats.allocFail);
       sysapiPrintf("   Cummulative frees          - %u\n",tempPool->stats.cumFreeCount);
       sysapiPrintf("   Usage maximum watermark    - %u\n",tempPool->stats.maxWaterLevel);
       sysapiPrintf("   Total request overflows    - %u\n",tempPool->stats.overflowCount);
@@ -1083,22 +1085,22 @@ void heapDbgStatsDisplay(L7_uint32 heapI
 * @returns  None
 *
 * @notes
 *
 * @end
 *********************************************************************/
-void heapDbgBuffInfo(L7_uint32 heapId,
+void heapDbgBuffInfo(L7_uint64 heapId,
                      void      *pMem)
 {
-  heap_t         *heap = (heap_t*)heapId;
+  heap_t         *heap = (heap_t*)UINT_TO_PTR(heapId);
   buffPool_t     *buffPool;
 
   /* Basic sanity checks */
-  if((heap == L7_NULLPTR) || (*((L7_uint32*)heapId) != heapId))
+  if((heap == L7_NULLPTR) || (PTR_GET_VALUE(UINT_TO_PTR(heapId)) != heapId))
   {
-    sysapiPrintf(" \n Invalid Heap ID : 0x%x\n", heapId);
+    sysapiPrintf(" \n Invalid Heap ID : 0x%llx\n", heapId);
     return;
   }
   if(pMem == L7_NULLPTR)
   {
     sysapiPrintf(" \n Invalid Buffer Pointer of NULL\n");
     return;
@@ -1112,46 +1114,46 @@ void heapDbgBuffInfo(L7_uint32 heapId,
 
   /* Lock the access, if needed */
   if((heap->flags & HEAP_LOCK_GUARD) != 0)
   {
     if(osapiSemaTake(heap->semId, L7_WAIT_FOREVER) != L7_SUCCESS)
     {
-      sysapiPrintf(" \n Failed to acquire heap semaphore for heapId 0x%x\n", heapId);
+      sysapiPrintf(" \n Failed to acquire heap semaphore for heapId 0x%llx\n", heapId);
       return;
     }
   }
 
   /* Retrieve the buffer pool structure associated with the given buffer */
   if(heapBuffPoolGet(heap, pMem, &buffPool) != L7_SUCCESS)
   {
-    sysapiPrintf(" \n Buffer at 0x%x is not a valid buffer for heapId 0x%x\n",
-           (L7_uint32)pMem, heapId);
+    sysapiPrintf(" \n Buffer at %p is not a valid buffer for heapId 0x%x\n",
+                 pMem, heapId);
   }
   else
   {
-    L7_uint32 wholeBuffAddress;
+    L7_uint64 wholeBuffAddress;
 
-    wholeBuffAddress = (L7_uint32)pMem - heap->headerSize;
+    wholeBuffAddress = PTR_TO_UINT64(pMem) - heap->headerSize;
 
     /* display the info */
     sysapiPrintf(" \n ************************** Memory Details ****************************** \n");
-    sysapiPrintf(" Buffer/memory 0x%x resides in Buffer Pool - %s \n",
-           (L7_uint32)pMem, buffPool->descr);
+    sysapiPrintf(" Buffer/memory %p resides in Buffer Pool - %s \n",
+                 pMem, buffPool->descr);
     if((heap->flags & HEAP_DEBUG_FILE_INFO) != 0)
     {
-      heapDebugInfo_t *pDbgInfo = (heapDebugInfo_t *)wholeBuffAddress;
+      heapDebugInfo_t *pDbgInfo = (heapDebugInfo_t *)UINT_TO_PTR(wholeBuffAddress);
       sysapiPrintf(" Last allocated at File - %s:%d in task - %d and for size - %d \n",
              pDbgInfo->fileName,pDbgInfo->lineNumber,pDbgInfo->taskId,
              pDbgInfo->sizeRequest);
     }
     if((heap->flags & HEAP_DEBUG_MEMORY_GUARD) != 0)
     {
       heapDebugMemGuard_t *pDbgInfo =
-        (heapDebugMemGuard_t *)((L7_uint32)pMem - sizeof(heapDebugMemGuard_t));
+        (heapDebugMemGuard_t *)UINT_TO_PTR(PTR_TO_UINT64(pMem) - sizeof(heapDebugMemGuard_t));
       sysapiPrintf(" Header Guard Word - 0x%x\n", pDbgInfo->guardWord);
-      pDbgInfo = (heapDebugMemGuard_t *)((L7_uint32)pMem + buffPool->buffSize);
+      pDbgInfo = (heapDebugMemGuard_t *)UINT_TO_PTR(PTR_TO_UINT64(pMem) + buffPool->buffSize);
       sysapiPrintf(" Footer Guard Word - 0x%x\n", pDbgInfo->guardWord);
     }
   }
 
   /* Unlock access */
   if((heap->flags & HEAP_LOCK_GUARD) != 0)
Index: src/application/ip_mcast/util/mcast_rtmbuf.c
===================================================================
--- src/application/ip_mcast/util/mcast_rtmbuf.c	(revision 7772)
+++ src/application/ip_mcast/util/mcast_rtmbuf.c	(revision 7778)
@@ -51,13 +51,13 @@ L7_uint32 rtmMbufAllocFailed =0;
 *
 * @end
 *********************************************************************/
 struct rtmbuf *rtm_dup(struct rtmbuf *pBuf)
 {
   struct rtmbuf *pDupBuf = L7_NULLPTR;
-  L7_uint32     frameHdl;
+  L7_uint64     frameHdl;
   L7_uchar8     *bufferAddr = L7_NULLPTR;
   L7_uint32     bufferPoolId;
   L7_uint32     dataLen;
   L7_uchar8     *pDataStart = L7_NULLPTR;
   L7_uchar8     *pOldDataStart = L7_NULLPTR;
 
@@ -100,23 +100,23 @@ struct rtmbuf *rtm_dup(struct rtmbuf *pB
    /* LOG_MSG("\n %s, %d : Failed to get free MBuf ", __FUNCTION__, __LINE__);*/
     return L7_NULLPTR;
   }
 
   /* Copy the data from the old data frame over to the new one
      and assign it to the duplicate buffer */
-  pDupBuf->rtm_bufhandle = (void *)frameHdl;
-  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)(pDupBuf->rtm_bufhandle), pDataStart);
-  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)(pBuf->rtm_bufhandle), pOldDataStart);
-  SYSAPI_NET_MBUF_GET_DATALENGTH((L7_netBufHandle)(pBuf->rtm_bufhandle), dataLen);
+  pDupBuf->rtm_bufhandle = UINT_TO_PTR(frameHdl);
+  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(pDupBuf->rtm_bufhandle), pDataStart);
+  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle), pOldDataStart);
+  SYSAPI_NET_MBUF_GET_DATALENGTH((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle), dataLen);
   memcpy(pDataStart, pOldDataStart, dataLen);
-  SYSAPI_NET_MBUF_SET_DATALENGTH((L7_netBufHandle)(pDupBuf->rtm_bufhandle), dataLen);
+  SYSAPI_NET_MBUF_SET_DATALENGTH((L7_netBufHandle)PTR_TO_UINT64(pDupBuf->rtm_bufhandle), dataLen);
 
   /* If the packet is vlan tagged then it needs to be stripped for application to process.
      If the outgoing ports are tagged then the lower layer should tag the packets again */
-  if (sysNetDataStripVlanTag((L7_uint32)(pDupBuf->rtm_bufhandle)) == L7_SUCCESS)
-    SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)(pDupBuf->rtm_bufhandle), pDataStart);
+  if (sysNetDataStripVlanTag(PTR_TO_UINT64(pDupBuf->rtm_bufhandle)) == L7_SUCCESS)
+    SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(pDupBuf->rtm_bufhandle), pDataStart);
 
   /* Setup the data length and start and return to caller */
   pDupBuf->rtm_data = (caddr_t)(pDataStart + sysNetDataOffsetGet(pDataStart));
   pDupBuf->rtm_len  = dataLen - sysNetDataOffsetGet(pDataStart);
   pDupBuf->rtm_pkthdr.len = pDupBuf->rtm_len;
 
Index: src/application/ip_mcast/vendor/mgmd/mgmd.h
===================================================================
--- src/application/ip_mcast/vendor/mgmd/mgmd.h	(revision 7772)
+++ src/application/ip_mcast/vendor/mgmd/mgmd.h	(revision 7778)
@@ -181,13 +181,13 @@ typedef struct ipv6pkt_s
 
 typedef struct mgmd_query_req_s
 {
   L7_sll_member_t  *next;
   L7_inet_addr_t    group;
   L7_APP_TMR_HNDL_t timer;
-  L7_uint32         query_timer_handle; /* to safeguard timeout functions */    
+  L7_uint64         query_timer_handle; /* to safeguard timeout functions */    
   L7_int32          count;
   L7_inet_addr_t    *qSrcs[MGMD_MAX_QUERY_SOURCES];
   L7_int32          numSrcs;
   void             *mgmdCB;  /* mgmd control block stored to retrieve info 
                                 while destroying the node itself */
 }mgmd_query_req_t; 
@@ -224,19 +224,19 @@ typedef enum
 
 typedef struct mgmd_info_s 
 {
   flags_t             flags;              
   L7_uint32           ifIndex;            /* Router interface index */
   L7_APP_TMR_HNDL_t   mgmd_query_timer;
-  L7_uint32           mgmd_query_timer_handle; /* to safeguard timeout functions */    
+  L7_uint64           mgmd_query_timer_handle; /* to safeguard timeout functions */    
   int                 mgmd_query_count;
   L7_inet_addr_t      mgmd_querierIP;
   L7_uint32           querierQueryInterval;  /* Stores querier's query interval when existing 
                                                 router is non-querier */
   L7_APP_TMR_HNDL_t   mgmd_querier_timer;
-  L7_uint32           mgmd_querier_timer_handle; /* to safeguard timeout functions */    
+  L7_uint64           mgmd_querier_timer_handle; /* to safeguard timeout functions */    
   L7_sll_t            ll_query_reqs;      /* Nodes are of the type mgmd_query_req_t */ 
   int                 numOfJoins;         /* The number of times a group membership has been added on this interface*/
   int                 numOfGroups;        /* The current number of groups registered for this interface. */
   int                 Wrongverqueries;    /* The number of queries received whose IGMP/MLD version does not match Interface Version*/
   int                 querierUpTime;      /* time since Querier was last changed.*/
   int                 querierExpiryTime;  /* The amount of time remaining before the Other Querier Present Timer expires.*/
@@ -330,13 +330,13 @@ typedef struct mgmd_cb_s
 
      This timer expires every 5 seconds and searches for all the group nodes which are all not informed to MRP during the regular 
      packet processing and infomrs them to MRP.In this way, even if the the group udate event is lost because of queue failures
      it will again infomred latter after 5 secs.
    */  
   L7_APP_TMR_HNDL_t      mgmd_mrp_timer;                  
-  L7_uint32              mgmd_mrp_timer_handle; /* to safeguard timeout functions */    
+  L7_uint64              mgmd_mrp_timer_handle; /* to safeguard timeout functions */    
   L7_APP_TMR_CTRL_BLK_t  timerHandle;     /* MGMD App Timer Control Block */
   handle_list_t          *handle_list;
   void                   *handleListMem;
   L7_mgmdv3Report_t      v3Report;
   L7_uchar8              pktRxBuf[MGMD_PKT_SIZE_MAX+L7_IP6_HEADER_LEN]; /* Buffer used to Receive PIM-SM Packets */
   L7_uchar8              pktTxBuf[MGMD_PKT_SIZE_MAX]; /* Buffer used to Transmit PIM-SM Packets */
@@ -370,16 +370,16 @@ typedef struct mgmd_group_s
   L7_sll_t              sourceRecords;   /* Nodes of Type mgmd_source_record_t */
   L7_APP_TMR_HNDL_t     v1HostTimer;
   L7_int32              v1HostPresentFlag;
   L7_APP_TMR_HNDL_t     v2HostTimer;
   L7_int32              v2HostPresentFlag;
   L7_APP_TMR_HNDL_t     groupTimer;    /* group timeout */  
-  L7_uint32             grp_timer_handle; /* to safeguard timeout functions */
+  L7_uint64             grp_timer_handle; /* to safeguard timeout functions */
 
-  L7_uint32             v2host_timer_handle; /* to safeguard timeout functions */  
-  L7_uint32             v1host_timer_handle; /* to safeguard timeout functions */  
+  L7_uint64             v2host_timer_handle; /* to safeguard timeout functions */  
+  L7_uint64             v1host_timer_handle; /* to safeguard timeout functions */  
   mgmd_group_timer_data_t  timerData;
   mgmd_timer_event_info_t  *grpQueryData;        /* pointer for timer data for grp-specific query*/
   mgmd_timer_event_info_t  *grpSrcQueryData;    /* pointer for timer data for grp-n-src-specific query*/  
   void *                dummy;           /* required by the AVL tree implementation */
 } mgmd_group_t;
 typedef struct mgmd_source_timer_data_s
@@ -392,13 +392,13 @@ typedef struct mgmd_source_record_s
 {
   L7_sll_member_t     *next;
   L7_inet_addr_t      sourceAddress;
   time_t              sourceCtime;
   L7_int32            sourceInterval;
   L7_APP_TMR_HNDL_t   sourceTimer;    /* source  timeout */  
-  L7_uint32           src_timer_handle; /* to safeguard timeout functions */
+  L7_uint64           src_timer_handle; /* to safeguard timeout functions */
   void                *mgmdCB;        /* mgmd control block stored to retrieve info 
                                          while destroying the node itself */
   mgmd_source_timer_data_t timerData;
 
 } mgmd_source_record_t;
 
Index: src/application/ip_mcast/vendor/mgmd/mgmd_proxy.h
===================================================================
--- src/application/ip_mcast/vendor/mgmd/mgmd_proxy.h	(revision 7772)
+++ src/application/ip_mcast/vendor/mgmd/mgmd_proxy.h	(revision 7778)
@@ -100,13 +100,13 @@ typedef L7_uint32  (*router_timer_events
 
 typedef struct mgmd_proxy_unsolicited_rpt_s
 {
   L7_sll_member_t   *next;
   L7_inet_addr_t    group;
   L7_APP_TMR_HNDL_t timer;
-  L7_uint32         timer_handle; /* to safeguard timeout functions */  
+  L7_uint64         timer_handle; /* to safeguard timeout functions */  
   L7_uint32         retryCount;
   L7_uint32         reportId;
   L7_inet_addr_t    srcList[MGMD_MAX_QUERY_SOURCES];
   L7_uint32         numSrcs;
   L7_uint32         grpRecType;
   void              *mgmdCB;     /* mgmd control block stored to retrieve info 
@@ -150,13 +150,13 @@ typedef struct mgmd_host_group_s
 {
   L7_inet_addr_t     group;          /* group address */
   time_t             uptime;         /* time received  */ 
   L7_inet_addr_t     last_reporter;  /* last reporter group address */
   MGMD_FILTER_MODE_T filterMode;     /* Source Filter Mode */
   L7_APP_TMR_HNDL_t  grp_rsp_timer;  /* Timer respond to group queries */
-  L7_uint32          grp_rsp_timer_handle; /* to safeguard timeout functions */  
+  L7_uint64          grp_rsp_timer_handle; /* to safeguard timeout functions */  
   interface_bitset_t grpPortList;    /* (GPL) Mask of interfaces configured for this Group Address */
   L7_sll_t           sourceRecords;  /* list of source records for each group */
   MGMD_HOST_STATE_T  hostState;
   L7_BOOL            grpSuppressed;
   L7_BOOL            sendReportUponQuery; /* Introduced for Rate-Limiting IGMP
                                            * Group Membership Reports.
@@ -485,13 +485,13 @@ void mgmd_proxy_querier_update_event_sen
 *
 * @notes    
 *
 * @end
 *********************************************************************/
 
-L7_RC_t  mgmdProxyUtilAppTimerHandleDelete(mgmd_cb_t *mgmdCB,L7_APP_TMR_HNDL_t *timer, L7_uint32 *handle);
+L7_RC_t  mgmdProxyUtilAppTimerHandleDelete(mgmd_cb_t *mgmdCB,L7_APP_TMR_HNDL_t *timer, L7_uint64 *handle);
 
 /*********************************************************************
 *
 * @purpose  Handles the group mode change
 *
 * @param    mgmdCB            @b{ (input) }   MGMD Control Block
Index: src/application/ip_mcast/vendor/mgmd/mgmd_mrp.c
===================================================================
--- src/application/ip_mcast/vendor/mgmd/mgmd_mrp.c	(revision 7772)
+++ src/application/ip_mcast/vendor/mgmd/mgmd_mrp.c	(revision 7778)
@@ -120,13 +120,13 @@ void mgmd_frame_event_info_and_notify(mg
   mgmd_group->mrpUpdated &= ~MGMD_MRP_REQUESTED_GROUP;
     mgmd_group->mrpUpdated &= ~MGMD_MRP_INFORM_FAILED;    
   }
   else
   {
     mgmd_group->mrpUpdated |= MGMD_MRP_INFORM_FAILED;
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void *)mgmdCB->mgmd_mrp_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void *)UINT_TO_PTR(mgmdCB->mgmd_mrp_timer_handle),
                             &mgmdCB->mgmd_mrp_timer, MGMD_MRP_INFORM_TIMEOUT,
                             L7_MGMD_MRP_INFORM_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not Start the L7_MGMD_MRP_INFORM_TIMER \n"); 
       return;
     }
Index: src/application/ip_mcast/vendor/mgmd/mgmd.c
===================================================================
--- src/application/ip_mcast/vendor/mgmd/mgmd.c	(revision 7772)
+++ src/application/ip_mcast/vendor/mgmd/mgmd.c	(revision 7778)
@@ -124,13 +124,13 @@ static L7_RC_t mgmdUtilAppTimerLower (mg
                       void *pParam,
                       L7_APP_TMR_HNDL_t *tmrHandle,
                       L7_uint32 lowerTimeOut,
                       MGMD_TIMER_t timerType);
 static L7_RC_t  mgmdUtilAppTimerHandleDelete(mgmd_cb_t *mgmdCB,
                                              L7_APP_TMR_HNDL_t *timer,
-                                             L7_uint32 *handle);
+                                             L7_uint64 *handle);
 static L7_RC_t  mgmdUtilAppTimerDelete(mgmd_cb_t *mgmdCB,
                                        L7_APP_TMR_HNDL_t *timer);
 
 static
 L7_RC_t mgmd_global_mode_set(mgmd_cb_t *mgmdCB, L7_uint32 gblAdminMode);
 
@@ -172,14 +172,17 @@ void mgmdSourceTimerUpdate(mgmd_cb_t *mg
 {
   qSrcs[*srcCount] = srcRec->sourceAddress;
   (*srcCount)++;
   srcRec->sourceInterval = lastMemQueryCount * lastMemQueryInterval;
 
   if ((srcRec->sourceTimer != L7_NULLPTR) &&
-      (appTimerUpdate(mgmdCB->timerHandle,&srcRec->sourceTimer, mgmd_timeout_sources_event_handler,
-                     (void*)srcRec->src_timer_handle, srcRec->sourceInterval,
+      (appTimerUpdate(mgmdCB->timerHandle,
+                      &srcRec->sourceTimer, 
+                      (void *) mgmd_timeout_sources_event_handler,
+                      UINT_TO_PTR(srcRec->src_timer_handle), 
+                      srcRec->sourceInterval,
                      "MGMD Source Timer2") != L7_SUCCESS))
   {
     MGMD_DEBUG_ADDR(MGMD_DEBUG_APIS, "Src Node Timer Updation Failed for src = \n",
                     &srcRec->sourceAddress);
     return;
   }
@@ -618,14 +621,17 @@ static void mgmd_v3_is_in_process (mgmd_
         mgmd_src_info_for_mrp_add(&group_info, srcRec->sourceAddress, MGMD_FILTER_MODE_INCLUDE, MGMD_SOURCE_ADD);
       }
 
     }
     /* 6.4.1: (A)=GMI */
     srcRec->sourceInterval = ((robustnessvar * queryInterval) + (responseInterval));
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)srcRec->src_timer_handle,
-                            &srcRec->sourceTimer,srcRec->sourceInterval,
+    if (mgmdUtilAppTimerSet(mgmdCB,
+                            L7_NULL,
+                            (void*) UINT_TO_PTR(srcRec->src_timer_handle),
+                            &srcRec->sourceTimer,
+                            srcRec->sourceInterval,
                             L7_MGMD_SRC_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not Start the Source timer \n");
       return;
     }
   }/*End-of-For-Loop*/
@@ -694,13 +700,13 @@ static void mgmd_v3_is_ex_process(mgmd_i
   /* Initialize */
   group_info.numSrcs = 0;
   /* 6.4.1: Group Timer=GMI */
   mgmd_group->interval = ((robustnessvar * queryInterval) + (responseInterval));
 
   MGMD_DEBUG (MGMD_DEBUG_APIS, " Grp timer = %p", mgmd_group->groupTimer);
-  if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_group->grp_timer_handle,
+  if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*) UINT_TO_PTR(mgmd_group->grp_timer_handle),
                           &mgmd_group->groupTimer,  mgmd_group->interval,
                           L7_MGMD_GRP_TIMER) != L7_SUCCESS)
   {
     MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not update the Grp Timer\n");
     return;
   }
@@ -721,13 +727,13 @@ static void mgmd_v3_is_ex_process(mgmd_i
         if((srcRec =mgmd_source_create(mgmdCB,mgmd_group,temp_src_ptr.sourceAddress ))== L7_NULLPTR)
         {
           MGMD_DEBUG (MGMD_DEBUG_FAILURE, " MGMD:Error in creating the Source node \n");
           return;
         }
         srcRec->sourceInterval = ((robustnessvar * queryInterval) + (responseInterval));
-        if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)srcRec->src_timer_handle,
+        if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*) UINT_TO_PTR(srcRec->src_timer_handle),
                             &srcRec->sourceTimer,srcRec->sourceInterval,
                             L7_MGMD_SRC_TIMER) != L7_SUCCESS)
         {
           MGMD_FREE(mgmdCB->proto,(srcRec));
           MGMD_DEBUG (MGMD_DEBUG_FAILURE, " MGMD:Could not Start the Source timer \n");
           return;
@@ -938,13 +944,13 @@ static void mgmd_v3_to_in_process (mgmd_
       }
     }
 
     /* 6.4.2: (A/B)=GMI */
     srcRec->sourceInterval = ((robustnessvar * queryInterval) + (responseInterval));
 
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL,(void*) srcRec->src_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL,(void*) UINT_TO_PTR(srcRec->src_timer_handle),
                             &srcRec->sourceTimer,srcRec->sourceInterval,
                             L7_MGMD_SRC_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not Start the Source timer \n");
       return;
     }
@@ -1088,13 +1094,13 @@ static void mgmd_v3_to_ex_process(mgmd_i
   /* Initialize local variables */
   group_info.numSrcs = 0;
 
   /* 6.4.2: Group Timer=GMI */
   mgmd_group->interval = ((robustnessvar * queryInterval) + (responseInterval));
 
-  if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_group->grp_timer_handle,
+  if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_group->grp_timer_handle),
                           &mgmd_group->groupTimer, mgmd_group->interval,
                           L7_MGMD_GRP_TIMER) != L7_SUCCESS)
   {
     MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the Grp Timer\n");
     return;
   }
@@ -1223,13 +1229,13 @@ static void mgmd_v3_to_ex_process(mgmd_i
         if((srcRec =mgmd_source_create(mgmdCB,mgmd_group,temp_src_ptr.sourceAddress ))== L7_NULLPTR)
         {
           MGMD_DEBUG (MGMD_DEBUG_FAILURE, " MGMD:Error in creating the Source node \n");
           return;
         }
         srcRec->sourceInterval = grpTimeLeft;
-        if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)srcRec->src_timer_handle,
+        if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(srcRec->src_timer_handle),
                                 &srcRec->sourceTimer,srcRec->sourceInterval,
                                 L7_MGMD_SRC_TIMER) != L7_SUCCESS)
         {
           MGMD_FREE(mgmdCB->proto,(srcRec));
           MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not Start the Source timer \n");
           return;
@@ -1400,13 +1406,13 @@ static void mgmd_v3_allow_process(mgmd_i
       }
     }
 
     /* 6.4.2: (A/B)=GMI */
     srcRec->sourceInterval = ((robustnessvar * queryInterval) + (responseInterval));
 
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void *)srcRec->src_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void *)UINT_TO_PTR(srcRec->src_timer_handle),
                             &srcRec->sourceTimer,srcRec->sourceInterval,
                             L7_MGMD_SRC_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not Start the Source timer \n");
       return;
     }
@@ -1526,13 +1532,13 @@ static void mgmd_v3_block_process (mgmd_
         {
           MGMD_DEBUG (MGMD_DEBUG_FAILURE, " MGMD:Error in creating the Source node \n");
           return;
         }
 
         srcRec->sourceInterval = grpTimeLeft;
-        if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)srcRec->src_timer_handle,
+        if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(srcRec->src_timer_handle),
                                 &srcRec->sourceTimer,srcRec->sourceInterval,
                                 L7_MGMD_SRC_TIMER) != L7_SUCCESS)
         {
           MGMD_FREE(mgmdCB->proto,(srcRec));
           MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not Start the Source timer \n");
           return;
@@ -1968,21 +1974,21 @@ void mgmd_v2membership_report(mgmd_info_
     }
 
     mgmd_group->interval = mgmd_group_membership_interval1;
 
     mgmd_info->numOfJoins++;
 
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_group->grp_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_group->grp_timer_handle),
                             &mgmd_group->groupTimer, mgmd_group->interval,
                             L7_MGMD_GRP_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not update the Grp Timer\n");
       return;
     }
 
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_group->v2host_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_group->v2host_timer_handle),
                             &mgmd_group->v2HostTimer, mgmd_group_membership_interval1,
                             L7_MGMD_V2HOST_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the V2 host Timer\n");
       return;
     }
@@ -1992,13 +1998,13 @@ void mgmd_v2membership_report(mgmd_info_
   {
     inetAddrHtop(&group, groupStr);
     MGMD_DEBUG (MGMD_DEBUG_REPORTS, "TR_TRACE: group %s on %d updated\n", groupStr, mgmd_info->ifIndex);
 
     mgmd_group->v2HostPresentFlag = L7_TRUE;
 
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_group->v2host_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_group->v2host_timer_handle),
                             &mgmd_group->v2HostTimer, mgmd_group_membership_interval1,
                             L7_MGMD_V2HOST_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the V2 host Timer\n");
       return;
     }
@@ -2036,13 +2042,13 @@ void mgmd_v2membership_report(mgmd_info_
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Copy operation Failed \n");
       return;
     }
     mgmd_group->interval = mgmd_group_membership_interval1;
 
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_group->grp_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_group->grp_timer_handle),
                             &mgmd_group->groupTimer, mgmd_group->interval,
                             L7_MGMD_GRP_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not update the Grp Timer\n");
       return;
     }
@@ -2128,26 +2134,26 @@ static void mgmd_v1membership_report (mg
     mgmd_group->v1HostPresentFlag = L7_TRUE;
     mgmd_group->groupCompatMode = L7_MGMD_VERSION_1;
 
     inetAddrHtop(&group, groupStr);
     MGMD_DEBUG (MGMD_DEBUG_REPORTS, "TR_TRACE: group %s on %d joined\n",groupStr, mgmd_info->ifIndex);
 
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL,(void*) mgmd_group->grp_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL,(void*)UINT_TO_PTR(mgmd_group->grp_timer_handle),
                             &mgmd_group->groupTimer, mgmd_group->interval,
                             L7_MGMD_GRP_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not update the Grp Timer\n");
       return;
     }
 
     if ((!MCAST_BITX_TEST (mgmd_info->flags.bits, IGMP_QUERIER)) &&
       (mgmd_info->querierQueryInterval != MGMD_ZERO))
     {
       queryInterval = mgmd_info->querierQueryInterval;
     }
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL,(void*) mgmd_group->v1host_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL,(void*)UINT_TO_PTR(mgmd_group->v1host_timer_handle),
                             &mgmd_group->v1HostTimer, mgmd_group_membership_interval1,
                             L7_MGMD_V1HOST_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the V1 host Timer\n");
       return;
     }
@@ -2180,23 +2186,23 @@ static void mgmd_v1membership_report (mg
 
     inetAddrHtop(&group, groupStr);
     MGMD_DEBUG (MGMD_DEBUG_REPORTS, "MGMD:TR_TRACE: group %s on %d updated\n",
                 groupStr, mgmd_info->ifIndex);
     mgmd_group->v1HostPresentFlag = L7_TRUE;
 
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_group->v1host_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_group->v1host_timer_handle),
                             &mgmd_group->v1HostTimer, mgmd_group_membership_interval1,
                             L7_MGMD_V1HOST_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the V1 host Timer\n");
       return;
     }
 
     mgmd_group->interval = mgmd_group_membership_interval1;
 
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL,(void*)mgmd_group->grp_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL,(void*)UINT_TO_PTR(mgmd_group->grp_timer_handle),
                             &mgmd_group->groupTimer, mgmd_group->interval,
                             L7_MGMD_GRP_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not update the Grp Timer\n");
       return;
     }
@@ -2373,13 +2379,13 @@ static void mgmd_group_src_specific_q_se
       SLLNodeDelete(&(mgmd_info->ll_query_reqs), (L7_sll_member_t *)qreq);
       mgmd_group->grpSrcQueryData =  L7_NULLPTR;
       MGMD_DEBUG (MGMD_DEBUG_FAILURE, " MGMD:Could not get the handle node to store the timer data.\n");
       return;
     }
 
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)qreq->query_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(qreq->query_timer_handle),
                             &qreq->timer, lastMemQueryInterval,
                             L7_MGMD_GRP_QUERY_TIMER) != L7_SUCCESS)
     {
       for (index = 0; index < numSrcs; index++)
       {
         srcAddrBuff = qreq->qSrcs[index];
@@ -2515,25 +2521,25 @@ static void mgmd_group_specific_q_send(m
       SLLNodeDelete(&(mgmd_info->ll_query_reqs), (L7_sll_member_t *)qreq);
       mgmd_group->grpQueryData =  L7_NULLPTR;
       MGMD_DEBUG (MGMD_DEBUG_FAILURE, " MGMD:Could not get the handle node to store the timer data.\n");
       return;
     }
 
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)qreq->query_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(qreq->query_timer_handle),
                             &qreq->timer, lastMemQueryInterval,
                             L7_MGMD_GRP_QUERY_TIMER) != L7_SUCCESS)
     {
       MGMD_FREE(family,(info));
       SLLNodeDelete(&(mgmd_info->ll_query_reqs), (L7_sll_member_t *)qreq);
       mgmd_group->grpQueryData =  L7_NULLPTR;
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the Grp Timer\n");
       return;
     }
   }
 
-  if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_group->grp_timer_handle,
+  if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_group->grp_timer_handle),
                           &mgmd_group->groupTimer, mgmd_group->interval,
                           L7_MGMD_GRP_TIMER) != L7_SUCCESS)
   {
     MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not update the Grp Timer\n");
     return;
   }
@@ -2822,13 +2828,13 @@ static void mgmd_group_query_timeout_eve
   L7_inet_addr_t *srcsLeLmqt[MGMD_MAX_QUERY_SOURCES];
   L7_uint32       numGtLmqt, numLeLmqt;
   L7_uint32       lastMemQueryInterval;
   L7_uint32       lastMemQueryCount;
   L7_uchar8       family;
   void *info;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
 
   MGMD_DEBUG (MGMD_DEBUG_APIS, " Entered");
 
   info= (void*)handleListNodeRetrieve(handle);
   if(info == L7_NULLPTR)
   {
@@ -2934,13 +2940,13 @@ static void mgmd_group_query_timeout_eve
     {
       mgmd_group->grpQueryData =  L7_NULLPTR;
     }
   }
   else
   {
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)qreq->query_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(qreq->query_timer_handle),
                             &qreq->timer, lastMemQueryInterval,
                             L7_MGMD_GRP_QUERY_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the Grp Timer\n");
       return;
     }
@@ -3033,24 +3039,24 @@ void mgmd_v3membership_query(mgmd_info_t
   mgmdCB = mgmd_info->mgmdCB;
 
   result = L7_INET_ADDR_COMPARE(&(mgmd_info->mgmd_querierIP), &source);
   if (result == 0)
   {
     /* Reset other querier present timer */
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_info->mgmd_querier_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_info->mgmd_querier_timer_handle),
                             &mgmd_info->mgmd_querier_timer,
                             mgmd_other_querier_present_interval, L7_MGMD_QUERIER_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Failed to update Querier timer\n");
       return;
     }
   }
   else if (result > 0)
   {
     /* This querier has lower ip address than the current */
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_info->mgmd_querier_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_info->mgmd_querier_timer_handle),
                             &mgmd_info->mgmd_querier_timer,
                             mgmd_other_querier_present_interval,
                             L7_MGMD_QUERIER_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the Querier Timer\n");
       return;
@@ -3131,13 +3137,13 @@ void mgmd_v3membership_query(mgmd_info_t
 
         MGMD_DEBUG (MGMD_DEBUG_QUERY, " Group found , lmqt = %d, numSrcs = %d",
                     lmqt, numSrcs);
 
         if (numSrcs == 0)
         {
-          if (mgmdUtilAppTimerLower(mgmdCB, L7_NULL, (void*)mgmd_group->grp_timer_handle,
+          if (mgmdUtilAppTimerLower(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_group->grp_timer_handle),
                                     &mgmd_group->groupTimer, lmqt, L7_MGMD_GRP_TIMER) != L7_SUCCESS)
           {
             MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not lower the Group timer  \n");
             return;
           }
           mgmd_group->interval = lmqt;
@@ -3152,13 +3158,13 @@ void mgmd_v3membership_query(mgmd_info_t
             srcRecSrch.sourceAddress = srcs[index];;
 
             srcRec = (mgmd_source_record_t *)SLLFind(&(mgmd_group->sourceRecords),
                                                      (L7_sll_member_t *)&srcRecSrch);
             if (srcRec != L7_NULLPTR)
             {
-              if (mgmdUtilAppTimerLower(mgmdCB, L7_NULL,(void*)srcRec->src_timer_handle,
+              if (mgmdUtilAppTimerLower(mgmdCB, L7_NULL,(void*)UINT_TO_PTR(srcRec->src_timer_handle),
                                         &srcRec->sourceTimer, lmqt, L7_MGMD_SRC_TIMER) != L7_SUCCESS)
               {
                 MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not lower the Source timer  \n");
                 return;
               }
               srcRec->sourceInterval = lmqt;
@@ -3219,13 +3225,13 @@ void mgmd_membership_query (mgmd_info_t
   mgmdCB = mgmd_info->mgmdCB;
 
   result = L7_INET_ADDR_COMPARE(&(mgmd_info->mgmd_querierIP), &source);
   if (result == 0)
   {
     /* Reset other querier present timer */
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_info->mgmd_querier_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_info->mgmd_querier_timer_handle),
                             &mgmd_info->mgmd_querier_timer,
                             mgmd_other_querier_present_interval,
                             L7_MGMD_QUERIER_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Querier Timer Updation Failed \n");
       return;
@@ -3233,13 +3239,13 @@ void mgmd_membership_query (mgmd_info_t
     MGMD_DEBUG (MGMD_DEBUG_QUERY, "TR_INFO: Update querier on %d\n", mgmd_info->ifIndex);
     MGMD_DEBUG_ADDR (MGMD_DEBUG_QUERY, "Querier is ", &source);
   }
   else if (result > 0)
   {
     /* This querier has lower ip address than the current */
-    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_info->mgmd_querier_timer_handle,
+    if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_info->mgmd_querier_timer_handle),
                             &mgmd_info->mgmd_querier_timer,
                             mgmd_other_querier_present_interval,
                             L7_MGMD_QUERIER_TIMER) != L7_SUCCESS)
     {
       MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the Querier Timer\n");
       return;
@@ -3299,13 +3305,13 @@ void mgmd_membership_query (mgmd_info_t
     {
       L7_uint32 newTime;
 
       MGMD_DEBUG_ADDR (MGMD_DEBUG_QUERY, "Found group ", &(mgmd_group->group));
 
       newTime = ((lastMemQueryCount * max_resp_time) );
-      if (mgmdUtilAppTimerLower(mgmdCB, L7_NULL, (void*)mgmd_group->grp_timer_handle,
+      if (mgmdUtilAppTimerLower(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_group->grp_timer_handle),
                                 &mgmd_group->groupTimer, newTime, L7_MGMD_GRP_TIMER)
                                 != L7_SUCCESS)
       {
         MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not update the Group timer  \n");
         return;
       }
@@ -4032,13 +4038,13 @@ static void mgmd_timeout_groups_event_ha
   mgmd_host_info_t     *mgmd_host_info;
   mgmdGroupInfo_t       group_info;
   L7_uint32             rtrIfNum;
   mgmd_info_t  *mgmd_info;
   mgmd_group_t *mgmd_group = L7_NULLPTR;
 
-  L7_int32      handle = (L7_int32)param;
+  L7_uint64 handle = PTR_TO_UINT64(param);
   mgmd_group_timer_data_t *timerData;
   L7_uint32             proxy_status;
 
   MGMD_DEBUG (MGMD_DEBUG_TIMERS,"Entered ");
 
   timerData = (void*)handleListNodeRetrieve(handle);
@@ -4221,13 +4227,13 @@ static void mgmd_timeout_sources_event_h
   L7_inet_addr_t        tmpSrc;
   mgmd_host_info_t     *mgmd_host_info ;
   mgmdGroupInfo_t       group_info;
   L7_uint32             rtrIfNum;
   mgmd_info_t          *mgmd_info;
   mgmd_group_t         *mgmd_group = L7_NULLPTR;
-  L7_int32      handle = (L7_int32)param;
+  L7_uint64             handle = PTR_TO_UINT64(param);
   mgmd_source_timer_data_t *timerData;
   L7_uint32             proxy_status;
 
   MGMD_DEBUG (MGMD_DEBUG_TIMERS,"Entered ");
 
 
@@ -4350,13 +4356,13 @@ static void mgmd_querier_timeout_event_h
   mgmd_info_t   *mgmd_info;
   mgmd_cb_t     *mgmdCB;
   L7_uint32      rtrIfNum;
   L7_uint32      timeLeft;
   L7_uchar8      inetAddrStr[IPV6_DISP_ADDR_LEN];
   L7_uint32      queryInterval;
-  L7_int32      handle = (L7_int32)param;
+  L7_uint64      handle = PTR_TO_UINT64(param);
 
   MGMD_DEBUG (MGMD_DEBUG_APIS, " Entered");
 
   mgmd_info= (void*)handleListNodeRetrieve(handle);
 
 
@@ -4407,13 +4413,13 @@ static void mgmd_querier_timeout_event_h
   queryInterval = mgmd_info->intfConfig.queryInterval;
 
   mgmd_info->mgmd_query_timer = L7_NULLPTR;
   mgmd_info->querierQueryInterval = 0; /* when the router itself is querier, reset it
                                           so that the default value is used */
 
-  if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_info->mgmd_query_timer_handle,
+  if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_info->mgmd_query_timer_handle),
                           &mgmd_info->mgmd_query_timer,
                           queryInterval, L7_MGMD_QUERY_TIMER) != L7_SUCCESS)
   {
     MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the Query Timer\n");
     return;
   }
@@ -4443,13 +4449,13 @@ static void mgmd_query_timeout_event_han
   mgmd_cb_t   *mgmdCB;
   L7_uint32    rtrIfNum;
   L7_uint32    timeLeft;
   L7_uint32    startupQueryCount;
   L7_uint32    startupQueryInterval;
   L7_uint32    queryInterval;
-  L7_int32      handle = (L7_int32)param;
+  L7_uint64    handle = PTR_TO_UINT64(param);
 
   MGMD_DEBUG (MGMD_DEBUG_APIS, " Entered");
 
   mgmd_info= (void*)handleListNodeRetrieve(handle);
 
 
@@ -4480,26 +4486,26 @@ static void mgmd_query_timeout_event_han
     mgmd_info->mgmd_query_timer= L7_NULLPTR;
 
     if (mgmd_info->mgmd_query_count >= startupQueryCount)
     {
       queryInterval = mgmd_info->intfConfig.queryInterval;
 
-      if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_info->mgmd_query_timer_handle,
+      if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_info->mgmd_query_timer_handle),
                               &mgmd_info->mgmd_query_timer,
                               queryInterval, L7_MGMD_QUERY_TIMER) != L7_SUCCESS)
       {
         MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the Query Timer\n");
         return;
       }
 
 
     }
     else if (mgmd_info->mgmd_query_count < startupQueryCount)
     {
       startupQueryInterval = mgmd_info->intfConfig.startupQueryInterval;
-      if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_info->mgmd_query_timer_handle,
+      if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_info->mgmd_query_timer_handle),
                               &mgmd_info->mgmd_query_timer,
                               startupQueryInterval, L7_MGMD_QUERY_TIMER) != L7_SUCCESS)
       {
         MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the Grp Timer\n");
         return;
       }
@@ -4810,13 +4816,13 @@ static L7_RC_t mgmd_router_interface(mgm
     MGMD_DEBUG (MGMD_DEBUG_EVENTS, "TR_INFO: new querier %s on %d", inetAddrStr, mgmd_info->ifIndex);
 
     mgmd_info->mgmd_query_count = 0;
 
     if (mgmd_info->mgmd_query_count < startupQueryCount)
     {
-      if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)mgmd_info->mgmd_query_timer_handle,
+      if (mgmdUtilAppTimerSet(mgmdCB, L7_NULL, (void*)UINT_TO_PTR(mgmd_info->mgmd_query_timer_handle),
                               &mgmd_info->mgmd_query_timer,
                               MGMD_STARTUP_QUERY_DELAY, L7_MGMD_QUERY_TIMER) != L7_SUCCESS)
       {
         MGMD_DEBUG (MGMD_DEBUG_APIS, "Could not start the Query Timer\n");
         return L7_FAILURE;
       }
@@ -4921,13 +4927,13 @@ L7_RC_t mgmd_interface_version_set(mgmd_
 * @notes
 *
 * @end
 *********************************************************************/
 static void mgmd_v1host_timeout_event_handler(void *param)
 {
-  L7_int32      handle = (L7_int32)param;
+  L7_uint64 handle = PTR_TO_UINT64(param);
   mgmd_group_t *mgmd_group;
 
   MGMD_DEBUG (MGMD_DEBUG_TIMERS,"Entered ");
 
   mgmd_group= (mgmd_group_t *)handleListNodeRetrieve(handle);
 
@@ -4958,14 +4964,13 @@ static void mgmd_v1host_timeout_event_ha
 * @notes
 *
 * @end
 *********************************************************************/
 static void mgmd_v2host_timeout_event_handler(void *param)
 {
-
-  L7_int32      handle = (L7_int32)param;
+  L7_uint64 handle = PTR_TO_UINT64(param);
   mgmd_group_t *mgmd_group;
 
   MGMD_DEBUG (MGMD_DEBUG_TIMERS,"Entered ");
 
   mgmd_group= (mgmd_group_t *)handleListNodeRetrieve(handle);
 
@@ -5270,13 +5275,13 @@ L7_RC_t  mgmd_start_timer(mgmd_cb_t *mgm
 *
 * @notes
 *
 * @end
 *********************************************************************/
 
-L7_RC_t  mgmdUtilAppTimerHandleDelete(mgmd_cb_t *mgmdCB,L7_APP_TMR_HNDL_t *timer, L7_uint32 *handle)
+L7_RC_t  mgmdUtilAppTimerHandleDelete(mgmd_cb_t *mgmdCB,L7_APP_TMR_HNDL_t *timer, L7_uint64 *handle)
 {
   MGMD_DEBUG (MGMD_DEBUG_APIS, " Entered, timer = %d", timer);
 
   if (*timer != L7_NULLPTR)
   {
     if (appTimerDelete(mgmdCB->timerHandle, *timer ) != L7_SUCCESS)
@@ -5631,13 +5636,14 @@ L7_RC_t mgmdMRPGroupInfoGet(mgmd_cb_t *m
 *
 * @end
 *********************************************************************/
 void mgmd_mrp_timeout_handler(void *param)
 {
   mgmd_cb_t   *mgmdCB ;
-  L7_uint32    handle = (L7_uint32)param, timeLeft = 0;
+  L7_uint64    handle = PTR_TO_UINT64(param);
+  L7_uint32    timeLeft = 0;
   mgmd_group_t dummyGroup, *mgmdGroup;
 
   mgmdCB = (void*)handleListNodeRetrieve(handle);
 
   if (mgmdCB == L7_NULLPTR)
   {
Index: src/application/ip_mcast/vendor/mgmd/mgmd_proxy.c
===================================================================
--- src/application/ip_mcast/vendor/mgmd/mgmd_proxy.c	(revision 7772)
+++ src/application/ip_mcast/vendor/mgmd/mgmd_proxy.c	(revision 7778)
@@ -2460,13 +2460,13 @@ void mgmd_proxy_v3membership_query_proce
         grpTime = selectedDelay;
         if (selectedDelay > IGMP_PROXY_GROUP_TIMER)
         {
           grpTime = IGMP_PROXY_GROUP_TIMER;
         }
         if (mgmdProxyUtilAppTimerSet(mgmdCB, L7_NULL, 
-                                     (void*)mgmd_host_group->grp_rsp_timer_handle,
+                                     (void*) UINT_TO_PTR(mgmd_host_group->grp_rsp_timer_handle),
                                      &mgmd_host_group->grp_rsp_timer,
                                      grpTime, 
                                      L7_MGMD_GRP_RSP_TIMER) != L7_SUCCESS)
         {
           MGMD_PROXY_DEBUG(MGMD_PROXY_DEBUG_APIS, "Could not start the Group Response timer  \n");
           return;
@@ -2501,13 +2501,13 @@ void mgmd_proxy_v3membership_query_proce
           if ((srcRec = (mgmd_host_source_record_t *)SLLFind(&(mgmd_host_group->sourceRecords), (L7_sll_member_t *)&srcRecSrchKey)))
           {
             srcRec->sendQueryReport = L7_TRUE;
           }
         } /*End-of-FOR-Loop*/
       }
-      if (mgmdProxyUtilAppTimerLower(mgmdCB, L7_NULL, (void *)mgmd_host_group->grp_rsp_timer_handle,
+      if (mgmdProxyUtilAppTimerLower(mgmdCB, L7_NULL, (void *)UINT_TO_PTR(mgmd_host_group->grp_rsp_timer_handle),
                                      &mgmd_host_group->grp_rsp_timer,selectedDelay, 
                                      L7_MGMD_GRP_RSP_TIMER) != L7_SUCCESS)
       {
         MGMD_PROXY_DEBUG(MGMD_PROXY_DEBUG_APIS, "Could not update the Group Response timer with delay(%d)\n",
                          selectedDelay);
         return;
@@ -2778,18 +2778,18 @@ void mgmd_proxy_membership_query_process
         }
       }
 
       if (mgmd_host_group != L7_NULL)
       {
         /* reset the group response timer */
-        if (mgmdProxyUtilAppTimerLower(mgmdCB, L7_NULL, (void *)mgmd_host_group->grp_rsp_timer_handle,
+        if (mgmdProxyUtilAppTimerLower(mgmdCB, L7_NULL, (void *)UINT_TO_PTR(mgmd_host_group->grp_rsp_timer_handle),
                                        &mgmd_host_group->grp_rsp_timer,selectedDelay, 
                                        L7_MGMD_GRP_RSP_TIMER) != L7_SUCCESS)
         {
           if (mgmdProxyUtilAppTimerSet(mgmdCB, L7_NULL, 
-                                     (void*)mgmd_host_group->grp_rsp_timer_handle,
+                                     (void*)UINT_TO_PTR(mgmd_host_group->grp_rsp_timer_handle),
                                      &mgmd_host_group->grp_rsp_timer,
                                      selectedDelay, 
                                      L7_MGMD_GRP_RSP_TIMER) != L7_SUCCESS)
           {
             MGMD_PROXY_DEBUG(MGMD_PROXY_DEBUG_APIS, "Could not start the Group Response timer  \n");
             return;
@@ -4219,13 +4219,13 @@ static void mgmd_proxy_unsolicited_timer
   {
     MGMD_DEBUG (MGMD_DEBUG_FAILURE,   "Could not get the handle node to store the timer data.\n");                    
     MGMD_PROXY_FREE(mgmdCB->proto, (rreq));       
     return;
   }
   if (mgmdProxyUtilAppTimerSet(mgmdCB, L7_NULL, 
-                               (void*)rreq->timer_handle,
+                               (void*)UINT_TO_PTR(rreq->timer_handle),
                                &rreq->timer,
                                unsolicitedReportInterval, 
                                L7_MGMD_UNSOLICITED_REPORT_TIMER) != L7_SUCCESS)
   {
      MGMD_PROXY_DEBUG(MGMD_PROXY_DEBUG_APIS, "Could not start the unsolicited report timer  \n");
     MGMD_PROXY_FREE(mgmdCB->proto, (rreq));       
@@ -4840,13 +4840,13 @@ void mgmd_proxy_group_response_timer_exp
   mgmd_host_group_t         *mgmd_host_group = L7_NULLPTR;
   mgmd_host_source_record_t *hostSrcRec = L7_NULL;
   L7_uint32                  i = 0, numSrcs = 0, grpRecType = 0;
   L7_BOOL                    grpSrcReport = L7_FALSE, srcTmrFlag;
   L7_inet_addr_t            *sourceSet[MGMD_MAX_QUERY_SOURCES];
   mgmd_host_info_t          *mgmd_host_info; 
-  L7_int32      handle = (L7_int32)param; 
+  L7_uint64                  handle = PTR_TO_UINT64(param);
 
   MGMD_PROXY_DEBUG(MGMD_PROXY_DEBUG_APIS," Entered , handle = %d", handle);
 
   mgmd_host_group = (mgmd_host_group_t *)handleListNodeRetrieve(handle); 
   MGMD_PROXY_DEBUG(MGMD_PROXY_DEBUG_APIS," mgmd_host_group = %p ",mgmd_host_group);
 
@@ -4941,14 +4941,14 @@ void mgmd_proxy_unsolicited_timer_expiry
   mgmd_cb_t                    *mgmdCB = L7_NULLPTR;
   L7_uint32                     reportIndex, index;
   mgmd_host_group_t            *mgmd_host_group = L7_NULL, mgmd_host_group_srchKey;
   mgmd_proxy_unsolicited_rpt_t *rreq = L7_NULL;
   mgmd_host_info_t             *mgmd_host_info;
   L7_uint32                     unsolicitedReportInterval;
-  L7_int32      handle = (L7_int32)param; 
-  L7_inet_addr_t              *srcList[MGMD_MAX_QUERY_SOURCES];
+  L7_uint64                     handle = PTR_TO_UINT64(param);
+  L7_inet_addr_t               *srcList[MGMD_MAX_QUERY_SOURCES];
 
   MGMD_PROXY_DEBUG(MGMD_PROXY_DEBUG_APIS," Entered ");
 
   rreq = (mgmd_proxy_unsolicited_rpt_t *)handleListNodeRetrieve(handle);   
 
   if (rreq == L7_NULLPTR)
@@ -5018,13 +5018,13 @@ void mgmd_proxy_unsolicited_timer_expiry
       return ;
     }
   }
   else
   {
     if (mgmdProxyUtilAppTimerSet(mgmdCB, L7_NULL, 
-                                 (void*)rreq->timer_handle,
+                                 (void*)UINT_TO_PTR(rreq->timer_handle),
                                  &rreq->timer,
                                  unsolicitedReportInterval, 
                                  L7_MGMD_UNSOLICITED_REPORT_TIMER) != L7_SUCCESS)
     {
       MGMD_PROXY_DEBUG(MGMD_PROXY_DEBUG_APIS, "Could not start the unsolicited report timer  \n");
       return;
@@ -5067,13 +5067,13 @@ void mgmd_proxy_querier_update_event_sen
 *
 * @notes    
 *
 * @end
 *********************************************************************/
 
-L7_RC_t  mgmdProxyUtilAppTimerHandleDelete(mgmd_cb_t *mgmdCB,L7_APP_TMR_HNDL_t *timer, L7_uint32 *handle)
+L7_RC_t  mgmdProxyUtilAppTimerHandleDelete(mgmd_cb_t *mgmdCB,L7_APP_TMR_HNDL_t *timer, L7_uint64 *handle)
 {
   MGMD_PROXY_DEBUG(MGMD_PROXY_DEBUG_APIS,"\n  Entered ");
   if (timer != L7_NULL && *timer != L7_NULLPTR)
   {
     if (appTimerDelete(mgmdCB->timerHandle, *timer ) != L7_SUCCESS)
     {
Index: src/application/ip_mcast/vendor/mfc/mfc_rxtx.c
===================================================================
--- src/application/ip_mcast/vendor/mfc/mfc_rxtx.c	(revision 7772)
+++ src/application/ip_mcast/vendor/mfc/mfc_rxtx.c	(revision 7778)
@@ -763,13 +763,13 @@ static L7_RC_t mfcIpPktDtlTransmit(L7_uc
 
   if ((family != L7_AF_INET) && (family != L7_AF_INET6))
   {
     MFC_DEBUG(MFC_DEBUG_FAILURES, "Wrong family type");
     if ((pBuf->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(pBuf->rtm_bufhandle));
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle));
     }
     rtm_freem(pBuf);
     return L7_FAILURE;
   }
 
   /* Prepare packet to be sent */
@@ -784,21 +784,21 @@ static L7_RC_t mfcIpPktDtlTransmit(L7_uc
     MFC_DEBUG(MFC_DEBUG_FAILURES,"failed to tranmit packet over oif = %d ", rtrIfNum); 
     MFC_DEBUG(MFC_DEBUG_TX,
               "\n failed to tranmit packet through DTL over oif = %d",
               rtrIfNum);
     if ((pBuf->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(pBuf->rtm_bufhandle));
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle));
     }
     rtm_freem(pBuf);
     return L7_FAILURE;
 
   }
   if ((pBuf->rtm_bufhandle) != L7_NULLPTR)
   {
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(pBuf->rtm_bufhandle));
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle));
   }
   rtm_freem(pBuf);
   return L7_SUCCESS;
 
 }
 
@@ -1100,13 +1100,13 @@ L7_BOOL mfcIpv4PktRecv(struct ip *pIp,
     return L7_FALSE;
   }
         
   /* Verify that MAC address in the packet is correctly formatted
      with respect to the destination multicast IP address.
      If the packet is malformed, then discard it. */
-  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)pBuf->rtm_bufhandle, pData);
+  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle), pData);
 
   if(mcastMacAddressCheck(L7_AF_INET,((L7_uchar8 *)(&(pIp->ip_dst))),pData)== L7_FAILURE)
   {
     return L7_TRUE;
   }
 
@@ -1137,13 +1137,13 @@ L7_BOOL mfcIpv4PktRecv(struct ip *pIp,
      and rtmbuf will be freed by the caller of this function. */
 
   memset(&sysnetPduInfo, 0, sizeof(sysnet_pdu_info_t));
   sysnetPduInfo.intIfNum = pBuf->rtm_pkthdr.rcvif->if_index;
   if (SYSNET_PDU_INTERCEPT(AF_INET,
                            SYSNET_INET_MFORWARD_IN,
-                           (L7_netBufHandle)(pBuf->rtm_bufhandle),
+                           (L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle),
                            &sysnetPduInfo,
                            L7_NULLPTR,
                            &hookVerdict) == L7_TRUE)
   {
     MFC_DEBUG(MFC_DEBUG_FAILURES,"\n SYSNET_PDU_INTERCEPT failed");
     return L7_FALSE;
Index: src/application/ip_mcast/vendor/mfc/mfc_v6.c
===================================================================
--- src/application/ip_mcast/vendor/mfc/mfc_v6.c	(revision 7772)
+++ src/application/ip_mcast/vendor/mfc/mfc_v6.c	(revision 7778)
@@ -259,13 +259,13 @@ L7_RC_t mfcIpv6PktTransmit(L7_uint32 rtr
   /* Compute the internal interface number for the given outgoing interface */
   if (ip6MapRtrIntfToIntIfNum(rtrIfNum, &intIfNum) != L7_SUCCESS)
   {
     MFC_DEBUG(MFC_DEBUG_FAILURES,
              " Failed to convert to internal interface number for rtrIfNum : %d",
              rtrIfNum);
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(pBuf->rtm_bufhandle));
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle));
     rtm_freem(pBuf);
     return L7_FAILURE;
   }
 
   pIp6Hdr = rtmtod(pBuf, L7_ip6Header_t *);
 
@@ -294,18 +294,18 @@ L7_RC_t mfcIpv6PktTransmit(L7_uint32 rtr
                               L7_FALSE, L7_FALSE, L7_FALSE)) != L7_SUCCESS)
   {
     MFC_DEBUG(MFC_DEBUG_FAILURES,
              " Failed to transmit pkt from socket = %d",mfcIp6SendSockId);   
     MFC_DEBUG(MFC_DEBUG_TX,"\n Failed to transmit pkt from socket = %d",
               mfcIp6SendSockId);
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(pBuf->rtm_bufhandle));
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle));
     rtm_freem(pBuf);
     return L7_FAILURE;
   }
 
-  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(pBuf->rtm_bufhandle));
+  SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle));
   rtm_freem(pBuf);
 
   return L7_SUCCESS;
 }
 #endif
 
@@ -326,13 +326,13 @@ L7_RC_t mfcIpv6PktTransmit(L7_uint32 rtr
   {
     MFC_DEBUG(MFC_DEBUG_FAILURES,
              " Failed to convert to internal interface number for rtrIfNum : %d",
              rtrIfNum);
     if ((pBuf->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(pBuf->rtm_bufhandle));
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle));
     }
     rtm_freem(pBuf);
     return L7_FAILURE;
   }
 
   pIp6Hdr = (L7_ip6Header_t *)&pBuf->m_hdr.mh_data;
@@ -363,13 +363,13 @@ L7_RC_t mfcIpv6PktTransmit(L7_uint32 rtr
              intIfNum);  
     MFC_DEBUG(MFC_DEBUG_FAILURES,
               "\n Failed to convert to stack interface number for intIfNum = %d ", 
               intIfNum);  
     if ((pBuf->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(pBuf->rtm_bufhandle));
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle));
     }
     rtm_freem(pBuf);
     return L7_FAILURE;
   }
 
   if ((ret = osapiPktInfoSend(mfcIp6SendSockId, pBuf->rtm_data + L7_IP6_HEADER_LEN,
@@ -382,20 +382,20 @@ L7_RC_t mfcIpv6PktTransmit(L7_uint32 rtr
     MFC_DEBUG(MFC_DEBUG_FAILURES,
              " Failed to transmit pkt from socket = %d",mfcIp6SendSockId);   
     MFC_DEBUG(MFC_DEBUG_TX,"\n Failed to transmit pkt from socket = %d",
               mfcIp6SendSockId);
     if ((pBuf->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(pBuf->rtm_bufhandle));
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle));
     }
     rtm_freem(pBuf);
     return L7_FAILURE;
   }
   if ((pBuf->rtm_bufhandle) != L7_NULLPTR)
   {
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(pBuf->rtm_bufhandle));
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(pBuf->rtm_bufhandle));
   }
   rtm_freem(pBuf);
 
   return L7_SUCCESS;
 }
 
@@ -489,13 +489,13 @@ L7_RC_t mfcIpv6PktRecv(void  *pktMsg)
     MFC_DEBUG(MFC_DEBUG_FAILURES,"\n Failed to get free MBuf ");
     bufferPoolFree(bufferPoolId, bufferAddr);
     return L7_FAILURE;
   }
   recvBuf->rtm_bufhandle = (void *)recvFrame;
 
-  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)(recvBuf->rtm_bufhandle),
+  SYSAPI_NET_MBUF_GET_DATASTART((L7_netBufHandle)PTR_TO_UINT64(recvBuf->rtm_bufhandle),
                                 pDataStart); 
   
   memset(pDataStart, 0, L7_ENET_HDR_SIZE + 2);
   memcpy(pDataStart + L7_ENET_HDR_SIZE, &protoType, sizeof(protoType));
 
  /* inBytes = L7_PORT_ENET_ENCAP_MAX_MTU;*/
@@ -503,13 +503,13 @@ L7_RC_t mfcIpv6PktRecv(void  *pktMsg)
 
   memcpy((pDataStart + L7_ENET_HDR_SIZE + 2), buffer, inBytes);
 
   recvBuf->rtm_type = MT_DATA;  
   recvBuf->rtm_data = pDataStart + sysNetDataOffsetGet(pDataStart);
   /* this set the rtm_len */
-  SYSAPI_NET_MBUF_SET_DATALENGTH((L7_netBufHandle)(recvBuf->rtm_bufhandle), 
+  SYSAPI_NET_MBUF_SET_DATALENGTH((L7_netBufHandle)PTR_TO_UINT64(recvBuf->rtm_bufhandle), 
                                     inBytes+ L7_ENET_HDR_SIZE + 2);
 
   recvBuf->rtm_pkthdr.rcvif = L7_NULLPTR;
 
   /* Extract the IP Header from the packet and fill-up the internal structure */
   pTmpPtr = recvBuf->rtm_data;
@@ -524,49 +524,49 @@ L7_RC_t mfcIpv6PktRecv(void  *pktMsg)
 
   /* Set-up the Cache Info structure */
   if (inetAddressSet(L7_AF_INET6, &(ip6Hdr.src), &(mfcEntry.source)) != L7_SUCCESS)
   {
     if ((recvBuf->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(recvBuf->rtm_bufhandle));
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(recvBuf->rtm_bufhandle));
     }
     bufferPoolFree(bufferPoolId, bufferAddr);  
     return L7_FAILURE;
   }
 
   /* Validity check for source address */
   if (inetIpAddressValidityCheck(L7_AF_INET6, &mfcEntry.source) != L7_SUCCESS)
   {
     MFC_DEBUG (MFC_DEBUG_FAILURES,"Source Address - %s is invalid",
                inetAddrPrint(&(mfcEntry.source),src));
     if ((recvBuf->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(recvBuf->rtm_bufhandle));
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(recvBuf->rtm_bufhandle));
     } 
     bufferPoolFree(bufferPoolId, bufferAddr);
     return L7_FAILURE;
   }
    
   if (inetAddressSet(L7_AF_INET6, &(ip6Hdr.dst), &(mfcEntry.group)) != L7_SUCCESS)
   {
     if ((recvBuf->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(recvBuf->rtm_bufhandle));
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(recvBuf->rtm_bufhandle));
     }
     bufferPoolFree(bufferPoolId, bufferAddr);  
     return L7_FAILURE;
   }
   MFC_DEBUG_ADDR(MFC_DEBUG_RX, "Rx'ed pkt for group : ", &mfcEntry.group);
   MFC_DEBUG_ADDR(MFC_DEBUG_RX, "Rx'ed pkt for source: ", &mfcEntry.source);
   MFC_DEBUG(MFC_DEBUG_RX, "Rx'ed pkt on iface  :  %d", rtrIfNum);
   if (inetIsInMulticast(&mfcEntry.group) != L7_TRUE)
   {
     MFC_DEBUG_ADDR(MFC_DEBUG_RX, "Rx'ed pkt for non- multicast group : ", &mfcEntry.group);
     if ((recvBuf->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(recvBuf->rtm_bufhandle));
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(recvBuf->rtm_bufhandle));
     }
     bufferPoolFree(bufferPoolId, bufferAddr);  
     return L7_FAILURE;
   }
 
   mfcEntry.iif = rtrIfNum;
@@ -575,31 +575,31 @@ L7_RC_t mfcIpv6PktRecv(void  *pktMsg)
   mfcEntry.m   = recvBuf;
   if (L7_IP6_IS_ADDR_MULTICAST_LOC_SCOPE(&(mfcEntry.group.addr.ipv6)))
   {
     MFC_DEBUG(MFC_DEBUG_RX,"\n Received link local multicast packet,ignoring it");
     if ((recvBuf->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(recvBuf->rtm_bufhandle));
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(recvBuf->rtm_bufhandle));
     }
     bufferPoolFree(bufferPoolId, bufferAddr);
     return L7_FAILURE;
   }
 
   if (mfcMroutePktForward(&mfcEntry) != L7_SUCCESS)
   {
     MFC_DEBUG(MFC_DEBUG_FAILURES,"\n Failed to forward packet ");
     if ((recvBuf->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(recvBuf->rtm_bufhandle));
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(recvBuf->rtm_bufhandle));
     }
     bufferPoolFree(bufferPoolId, bufferAddr);
     return L7_FAILURE;
   }
   if ((recvBuf->rtm_bufhandle) != L7_NULLPTR)
   {
-    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(recvBuf->rtm_bufhandle));
+    SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(recvBuf->rtm_bufhandle));
   }
   bufferPoolFree(bufferPoolId, bufferAddr);
   return L7_SUCCESS;
 }  
 
 /*********************************************************************
Index: src/application/ip_mcast/vendor/mfc/mfc.c
===================================================================
--- src/application/ip_mcast/vendor/mfc/mfc.c	(revision 7772)
+++ src/application/ip_mcast/vendor/mfc/mfc.c	(revision 7778)
@@ -1569,14 +1569,13 @@ L7_RC_t mfcMroutePktForward(mfcEntry_t *
          * packet arrival events are used to set up the control plane; however there is no valid data
          * to forward via the software forwarding plane
          */
         if (pData->m->rtm_bufhandle != L7_NULLPTR)
         {
           /* Attempt to forward the packet */
-          SYSAPI_NET_MBUF_GET_DATALENGTH(
-                                        (L7_netBufHandle)(pData->m->rtm_bufhandle), len);
+          SYSAPI_NET_MBUF_GET_DATALENGTH((L7_netBufHandle)PTR_TO_UINT64(pData->m->rtm_bufhandle), len);
           outEntry.iif = tempEntry.iif;
           if (mfcPktTransmit(pData->m, &outEntry) == L7_SUCCESS)
           {
             txStatus = L7_SUCCESS;
             /* Update the stats */
             tempEntry.numForwardedPkts++;
Index: src/application/ip_mcast/vendor/pimsm/pimsmstargassertfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmstargassertfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmstargassertfsm.c	(revision 7778)
@@ -347,13 +347,13 @@ static L7_RC_t  pimsmPerIntfStarGAssertA
   pTimerData = &pStarGIEntry->pimsmStarGIAssertTimerParam;
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr2, &pStarGNode->pimsmStarGEntry.pimsmStarGGrpAddress);
   pTimerData->rtrIfNum = rtrIfNum;
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarGIAssertTimerExpiresHandler,
-                            (void*)pStarGIEntry->pimsmStarGIAssertTimerHandle,
+                            UINT_TO_PTR(pStarGIEntry->pimsmStarGIAssertTimerHandle),
                             PIMSM_DEFAULT_ASSERT_TIME - PIMSM_DEFAULT_ASSERT_OVERRIDE_INTERVAL,
                             &(pStarGIEntry->pimsmStarGIAssertTimer),
                             "xGI-AT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_ASSERT_FSM, PIMSM_TRACE_ERROR,
@@ -428,13 +428,13 @@ static L7_RC_t  pimsmPerIntfStarGAssertA
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr2, &pStarGNode->pimsmStarGEntry.pimsmStarGGrpAddress);
   pTimerData->rtrIfNum = rtrIfNum;
   pTimerData->pimsmCb = pimsmCb;
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarGIAssertTimerExpiresHandler,
-                            (void*)pStarGIEntry->pimsmStarGIAssertTimerHandle,
+                            UINT_TO_PTR(pStarGIEntry->pimsmStarGIAssertTimerHandle),
                             PIMSM_DEFAULT_ASSERT_TIME,
                             &(pStarGIEntry->pimsmStarGIAssertTimer),
                             "xGI-AT2")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_ASSERT_FSM, PIMSM_TRACE_ERROR,
@@ -506,13 +506,13 @@ static L7_RC_t  pimsmPerIntfStarGAssertA
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr2, &pStarGNode->pimsmStarGEntry.pimsmStarGGrpAddress);
   pTimerData->rtrIfNum = rtrIfNum;
   pTimerData->pimsmCb = pimsmCb;
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarGIAssertTimerExpiresHandler,
-                            (void*)pStarGIEntry->pimsmStarGIAssertTimerHandle,
+                            UINT_TO_PTR(pStarGIEntry->pimsmStarGIAssertTimerHandle),
                             (PIMSM_DEFAULT_ASSERT_TIME - PIMSM_DEFAULT_ASSERT_OVERRIDE_INTERVAL),
                             &(pStarGIEntry->pimsmStarGIAssertTimer),
                             "xGI-AT3")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_ASSERT_FSM, PIMSM_TRACE_ERROR,
@@ -663,13 +663,13 @@ static void  pimsmStarGIAssertTimerExpir
   pimsmPerIntfStarGAssertEventInfo_t perIntfStarGAssertEventInfo;
   pimsmStarGNode_t *pStarGNode;
   pimsmStarGIEntry_t *pStarGIEntry = L7_NULLPTR;
   L7_uint32 rtrIfNum;
   pimsmCB_t  * pimsmCb;
   pimsmTimerData_t *pTimerData;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64    handle = PTR_TO_UINT64(pParam);
   L7_inet_addr_t *pGrpAddr;
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_ASSERT_FSM, PIMSM_TRACE_NORMAL, "pTimerData == L7_NULLPTR");
Index: src/application/ip_mcast/vendor/pimsm/pimsmapi.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmapi.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmapi.c	(revision 7778)
@@ -76,13 +76,13 @@ L7_RC_t pimsmWholePacketEventQueue(L7_uc
                                sizeof(mfcEntry_t),
                                (L7_VOIDPTR)pMfcEntry) != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_MFC_INTERACTION, PIMSM_TRACE_INFO,"PIMSM message Queue Send  failed");
     if ((pMfcEntry->m->rtm_bufhandle) != L7_NULLPTR)
     {
-      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)(pMfcEntry->m)->rtm_bufhandle);
+      SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64((pMfcEntry->m)->rtm_bufhandle));
     }
     rtm_freem(pMfcEntry->m);
     /*restore original buf pointer */
     pMfcEntry->m = mbuf;
     return L7_FAILURE;
   }
Index: src/application/ip_mcast/vendor/pimsm/pimsmcontrol.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmcontrol.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmcontrol.c	(revision 7778)
@@ -1548,13 +1548,13 @@ L7_RC_t pimsmGlobalAdminModeProcess(MCAS
     pTimerData = &pimsmCb->pimsmJPBundleTimerParam;
     memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
     pTimerData->pimsmCb = pimsmCb;
   
     timer = appTimerAdd(pimsmCb->timerCb,
                         pimsmJPBundleTimerExpiryHandler,
-                        (void*)pimsmCb->pimsmJPBundleTimerHandle,
+                        UINT_TO_PTR(pimsmCb->pimsmJPBundleTimerHandle),
                         PIMSM_DEFAULT_JP_BUNDLE_TIME,
                         "SM-JPB");
     if(timer != L7_NULLPTR)
     {
       pimsmCb->pimsmJPBundleTimer = timer;
     }
@@ -1565,13 +1565,13 @@ L7_RC_t pimsmGlobalAdminModeProcess(MCAS
     pTimerData = &pimsmCb->pimsmSPTTimerParam;
     memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
     pTimerData->pimsmCb = pimsmCb;
  
     timer = appTimerAdd(pimsmCb->timerCb,
                         pimsmSPTTimerExpiresHandler,
-                        (void*)pimsmCb->pimsmSPTTimerHandle,
+                        UINT_TO_PTR(pimsmCb->pimsmSPTTimerHandle),
                         PIMSM_DEFAULT_CHECK_INTERVAL,
                         "SM-SPT");
     if(timer != L7_NULLPTR)
     {
       pimsmCb->pimsmSPTTimer = timer;
     }
Index: src/application/ip_mcast/vendor/pimsm/pimsmsgregisterfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmsgregisterfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmsgregisterfsm.c	(revision 7778)
@@ -308,13 +308,13 @@ static L7_RC_t   pimsmRegStopTimerSet (p
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
   pTimerData->pimsmCb = pimsmCb;
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGDRRegisterStopTimerExpiresHandler,
-                            (void*)pSGNode->pimsmSGEntry.pimsmSGDRRegisterStopTimerHandle,
+                            UINT_TO_PTR(pSGNode->pimsmSGEntry.pimsmSGDRRegisterStopTimerHandle),
                             regStopTime,
                             &(pSGNode->pimsmSGEntry.pimsmSGDRRegisterStopTimer),
                             "SM-RST")
                          != L7_SUCCESS)
   {
      PIMSM_TRACE(PIMSM_DEBUG_BIT_REG_RX_TX_FSM,  PIMSM_TRACE_ERROR,
@@ -482,13 +482,13 @@ static L7_RC_t pimsmPerSGRegisterNullReg
   pTimerData = &pSGNode->pimsmSGEntry.pimsmSGDRRegisterStopTimerParam;
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGDRRegisterStopTimerExpiresHandler,
-                            (void*)pSGNode->pimsmSGEntry.pimsmSGDRRegisterStopTimerHandle,
+                            UINT_TO_PTR(pSGNode->pimsmSGEntry.pimsmSGDRRegisterStopTimerHandle),
                             regStopTime,
                             &(pSGNode->pimsmSGEntry.pimsmSGDRRegisterStopTimer),
                             "SM-RST2")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_REG_RX_TX_FSM,  PIMSM_TRACE_ERROR,
@@ -590,13 +590,13 @@ static L7_RC_t pimsmPerSGRegisterErrorRe
 static void pimsmSGDRRegisterStopTimerExpiresHandler(void *pParam)
 {
   pimsmSGNode_t *pSGNode;
   pimsmPerSGRegisterEventInfo_t perSGRegisterEventInfo;
   pimsmSGEntry_t *pSGEntry= L7_NULLPTR;
   pimsmCB_t   *pimsmCb;
-  L7_int32     handle = (L7_int32)pParam;
+  L7_uint64     handle = PTR_TO_UINT64(pParam);
   pimsmTimerData_t *pTimerData;
   L7_inet_addr_t *pGrpAddr, *pSrcAddr;
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
   {
Index: src/application/ip_mcast/vendor/pimsm/pimsmupstrmstarstarrpfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmupstrmstarstarrpfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmupstrmstarstarrpfsm.c	(revision 7778)
@@ -266,13 +266,13 @@ static L7_RC_t  pimsmUpStrmPerIntfStarSt
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr1,
     &pStarStarRpNode->pimsmStarStarRpEntry.pimsmStarStarRpRPAddress);
 
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarStarRpUpstreamJoinTimerExpiresHandler,
-                            (void*)pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimerHandle,
+                            UINT_TO_PTR(pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimerHandle),
                             jpInterval,
                             &(pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimer),
                             "xR-JT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_STAR_RP,  PIMSM_TRACE_ERROR, "Failed to add (*,*,Rp) upstrm join timer");
@@ -404,13 +404,13 @@ static L7_RC_t pimsmUpStrmPerIntfStarSta
     memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
     inetCopy(&pTimerData->addr1,
       &pStarStarRpNode->pimsmStarStarRpEntry.pimsmStarStarRpRPAddress);
 
     pTimerData->pimsmCb = pimsmCb;
     if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarStarRpUpstreamJoinTimerExpiresHandler,
-                              (void*)pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimerHandle,
+                              UINT_TO_PTR(pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimerHandle),
                               joinSuppress,
                               &(pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimer),
                               "xR-JT2")
                            != L7_SUCCESS)
     {
       PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_STAR_RP,  PIMSM_TRACE_ERROR, "Failed to update (*,*,Rp) upstrm join timer");
@@ -468,13 +468,13 @@ static L7_RC_t  pimsmUpStrmPerIntfStarSt
     memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
     inetCopy(&pTimerData->addr1,
       &pStarStarRpNode->pimsmStarStarRpEntry.pimsmStarStarRpRPAddress);
     pTimerData->pimsmCb = pimsmCb;
 
     if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarStarRpUpstreamJoinTimerExpiresHandler,
-                              (void*)pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimerHandle,
+                              UINT_TO_PTR(pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimerHandle),
                               jpOverrideInterval,
                               &(pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimer),
                               "xR-JT3")
                            != L7_SUCCESS)
     {
       PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_STAR_RP,  PIMSM_TRACE_ERROR, "Failed to update (*,*,Rp) upstrm join timer");
@@ -603,13 +603,13 @@ static L7_RC_t  pimsmUpStrmPerIntfStarSt
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr1,
     &pStarStarRpNode->pimsmStarStarRpEntry.pimsmStarStarRpRPAddress);
 
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarStarRpUpstreamJoinTimerExpiresHandler,
-                            (void*)pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimerHandle,
+                            UINT_TO_PTR(pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimerHandle),
                             jpInterval,
                             &(pStarStarRpEntry->pimsmStarStarRpUpstreamJoinTimer),
                             "xR-JT4")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_STAR_RP,  PIMSM_TRACE_ERROR, "Failed to add (*,*,Rp) upstrm join timer");;
@@ -656,14 +656,14 @@ static L7_RC_t pimsmUpStrmPerIntfStarSta
 ******************************************************************************/
 static void pimsmStarStarRpUpstreamJoinTimerExpiresHandler(void *pParam)
 {
   pimsmUpStrmStarStarRPEventInfo_t pUpStrmStarStarRpEventInfo;
   pimsmStarStarRpNode_t *pStarStarRpNode;
   pimsmTimerData_t *pTimerData;
-  pimsmCB_t  * pimsmCb;
-  L7_int32      handle = (L7_int32)pParam;
+  pimsmCB_t      *pimsmCb;
+  L7_uint64      handle = PTR_TO_UINT64(pParam);
   L7_inet_addr_t *pRpAddr;
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_STAR_RP,  PIMSM_TRACE_NORMAL,
Index: src/application/ip_mcast/vendor/pimsm/pimsmdebug.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmdebug.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmdebug.c	(revision 7778)
@@ -1274,17 +1274,17 @@ void pimsmDebugCtrlBlockShow ( pimsmCB_t
   PIMSM_DEBUG_PRINTF( "pimsmRegRateBytes: %d \n", pimsmCb->pimsmRegRateBytes );
   PIMSM_DEBUG_PRINTF( "pimsmRateCheckInterval: %d \n", pimsmCb->pimsmRateCheckInterval );
   PIMSM_DEBUG_PRINTF( "family: %d \n", pimsmCb->family );  
   PIMSM_DEBUG_PRINTF( "isPimsmEnabled: %d \n", pimsmCb->isPimsmEnabled );  
   PIMSM_DEBUG_PRINTF( "isPimsmEnabled: %d \n", pimsmCb->isPimsmEnabled );  
   PIMSM_DEBUG_PRINTF( "pimsmRestartInProgress: %d \n", pimsmCb->pimsmRestartInProgress );  
-  PIMSM_DEBUG_PRINTF( "pimsmSPTTimerHandle: %d \n", 
+  PIMSM_DEBUG_PRINTF( "pimsmSPTTimerHandle: 0x%llx \n", 
                       pimsmCb->pimsmSPTTimerHandle );  
   PIMSM_DEBUG_PRINTF( "pimsmSPTTimerParam Addr: %p \n", 
                       &pimsmCb->pimsmSPTTimerParam );
-  PIMSM_DEBUG_PRINTF( "pimsmJPBundleTimerHandle: %d \n", 
+  PIMSM_DEBUG_PRINTF( "pimsmJPBundleTimerHandle: 0x%llx \n", 
                       pimsmCb->pimsmJPBundleTimerHandle );  
   PIMSM_DEBUG_PRINTF( "pimsmJPBundleTimerParam Addr: %p \n", 
                       &pimsmCb->pimsmJPBundleTimerParam );
   PIMSM_DEBUG_PRINTF( "timerCb: %p \n", 
                       (pimsmCb->timerCb));  
   PIMSM_DEBUG_PRINTF( "handleList: %p \n", 
@@ -1298,13 +1298,13 @@ void pimsmDebugCtrlBlockShow ( pimsmCB_t
                 pimsmCb->pimsmStarGNextHopUpdateCnt);
   PIMSM_DEBUG_PRINTF( "pimsmSGRptNextHopUpdateCnt: %d\n",
                 pimsmCb->pimsmSGRptNextHopUpdateCnt);
   PIMSM_DEBUG_PRINTF( "maxNumOfTimers: %d\n",
                 pimsmCb->maxNumOfTimers);
 
-  PIMSM_DEBUG_PRINTF( "mcastHeapId: 0x%x \n", mcastMapHeapIdGet(pimsmCb->family));
+  PIMSM_DEBUG_PRINTF( "mcastHeapId: 0x%llx \n", mcastMapHeapIdGet(pimsmCb->family));
 }
 
 /******************************************************************************
 * @purpose  Help command: show all debug APIs
 *
 * @param
Index: src/application/ip_mcast/vendor/pimsm/pimsmsgtree.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmsgtree.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmsgtree.c	(revision 7778)
@@ -339,17 +339,17 @@ L7_RC_t pimsmSGDelete(pimsmCB_t * pimsmC
                   "Deleting (S,G,%d) entry",index); 
       pimsmSGIEntryDelete(pimsmCb,pSGNodeDelete, index);
     }
   }
 
   handleListNodeDelete(pimsmCb->handleList,
-                       &pSGNodeDelete->pimsmSGEntry.pimsmSGDRRegisterStopTimerHandle);
+                       (L7_uint64 *) &pSGNodeDelete->pimsmSGEntry.pimsmSGDRRegisterStopTimerHandle);
   handleListNodeDelete(pimsmCb->handleList,
-                       &pSGNodeDelete->pimsmSGEntry.pimsmSGKeepaliveTimerHandle);
+                       (L7_uint64 *) &pSGNodeDelete->pimsmSGEntry.pimsmSGKeepaliveTimerHandle);
   handleListNodeDelete(pimsmCb->handleList,
-                       &pSGNodeDelete->pimsmSGEntry.pimsmSGUpstreamJoinTimerHandle);
+                       (L7_uint64 *) &pSGNodeDelete->pimsmSGEntry.pimsmSGUpstreamJoinTimerHandle);
 
   pimsmSGMFCUpdate(pimsmCb, pSGNodeDelete, MFC_DELETE_ENTRY, L7_FALSE);
   pSGNodeDelete->pimsmSGEntry.pimsmSGSPTBit = L7_FALSE;  
   pSGNode = avlDeleteEntry(&pimsmCb->pimsmSGTree, pSGNodeDelete);
   if(osapiSemaGive(pimsmCb->pimsmSGTree.semId) != L7_SUCCESS)
   {
@@ -697,13 +697,13 @@ L7_RC_t pimsmSGNodeCreate(pimsmCB_t * pi
       inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
      /* As per the draft, keepAliveTimer should be started only when
       then data-traffic is startedi, not when (S,G) entry is created */
       if(bStartKAT == L7_TRUE)
       {
         if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGKeepaliveTimerExpiresHandler,
-                                  (void*) pSGNode->pimsmSGEntry.pimsmSGKeepaliveTimerHandle,
+                                  UINT_TO_PTR(pSGNode->pimsmSGEntry.pimsmSGKeepaliveTimerHandle),
                                   PIMSM_DEFAULT_KEEPALIVE_PERIOD,
                                   &(pSGNode->pimsmSGEntry.pimsmSGKeepaliveTimer),
                                   "SM-KAT2")
                                != L7_SUCCESS)
         {
           PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G, PIMSM_TRACE_ERROR, 
@@ -888,17 +888,17 @@ L7_RC_t pimsmSGIEntryDelete(pimsmCB_t *p
   }
 
   pimsmUtilAppTimerCancel (pimsmCb, &(pSGIEntry->pimsmSGIPrunePendingTimer));
   pimsmUtilAppTimerCancel (pimsmCb, &(pSGIEntry->pimsmSGIJoinExpiryTimer));
   pimsmUtilAppTimerCancel (pimsmCb, &(pSGIEntry->pimsmSGIAssertTimer));
   handleListNodeDelete(pimsmCb->handleList,
-                       &pSGIEntry->pimsmSGIPrunePendingTimerHandle);     
+                       (L7_uint64 *) &pSGIEntry->pimsmSGIPrunePendingTimerHandle);     
   handleListNodeDelete(pimsmCb->handleList,
-                       &pSGIEntry->pimsmSGIJoinExpiryTimerHandle);     
+                       (L7_uint64 *) &pSGIEntry->pimsmSGIJoinExpiryTimerHandle);     
   handleListNodeDelete(pimsmCb->handleList,
-                       &pSGIEntry->pimsmSGIAssertTimerHandle);  
+                       (L7_uint64 *) &pSGIEntry->pimsmSGIAssertTimerHandle);  
   PIMSM_FREE (pimsmCb->family, (void*) pSGIEntry);
 
   pSGNode->pimsmSGIEntry[rtrIfNum] = L7_NULLPTR;
   return L7_SUCCESS;
 }
 /*********************************************************************
@@ -930,17 +930,17 @@ L7_RC_t pimsmSGTreePurge(pimsmCB_t * pim
     pSGEntry = &pSGNode->pimsmSGEntry;
 
     pimsmUtilAppTimerCancel (pimsmCb, &(pSGEntry->pimsmSGKeepaliveTimer));
     pimsmUtilAppTimerCancel (pimsmCb, &(pSGEntry->pimsmSGDRRegisterStopTimer));
     pimsmUtilAppTimerCancel (pimsmCb, &(pSGEntry->pimsmSGUpstreamJoinTimer));
     handleListNodeDelete(pimsmCb->handleList,
-                         &pSGEntry->pimsmSGDRRegisterStopTimerHandle);
+                         (L7_uint64 *) &pSGEntry->pimsmSGDRRegisterStopTimerHandle);
     handleListNodeDelete(pimsmCb->handleList,
-                         &pSGEntry->pimsmSGKeepaliveTimerHandle);
+                         (L7_uint64 *) &pSGEntry->pimsmSGKeepaliveTimerHandle);
     handleListNodeDelete(pimsmCb->handleList,
-                         &pSGEntry->pimsmSGUpstreamJoinTimerHandle);    
+                         (L7_uint64 *) &pSGEntry->pimsmSGUpstreamJoinTimerHandle);    
 
     for(rtrIfNum = 0; rtrIfNum < MCAST_MAX_INTERFACES; rtrIfNum++)
     {
       pimsmSGIEntryDelete(pimsmCb, pSGNode, rtrIfNum);
     }
     rc = pimsmSGNextGet( pimsmCb, pSGNode, &pSGNode );
Index: src/application/ip_mcast/vendor/pimsm/pimsmnoncandbsrfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmnoncandbsrfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmnoncandbsrfsm.c	(revision 7778)
@@ -169,13 +169,13 @@ L7_RC_t pimsmPerScopeZoneNonCandBSRExecu
 * @comments
 *
 * @end
 ******************************************************************************/
 void pimsmBsrNonCandidateBootStrapTimerExpiresHandler(void *pParam)
 {
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
   pimsmBsrPerScopeZone_t  *bsr_node;
   pimsmPerScopeZoneNonCandBSREventInfo_t       nonCandEventInfo;
 
   bsr_node = (pimsmBsrPerScopeZone_t*)handleListNodeRetrieve(handle);
 
   if(bsr_node == L7_NULLPTR)
@@ -210,13 +210,13 @@ void pimsmBsrNonCandidateBootStrapTimerE
 * @comments
 *
 * @end
 ******************************************************************************/
 void pimsmBsrNonCandidateScopeZoneTimerExpiresHandler(void *pParam)
 {
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
   pimsmBsrPerScopeZone_t  *bsr_node;
   pimsmPerScopeZoneNonCandBSREventInfo_t       nonCandEventInfo;
 
   bsr_node = (pimsmBsrPerScopeZone_t *)handleListNodeRetrieve(handle);
 
   if(bsr_node == L7_NULLPTR)
@@ -268,13 +268,13 @@ L7_RC_t pimsmPerScopeZoneNonCandBSRRpSet
                      nonCandBsrEventInfo->pBsrNode,
                      nonCandBsrEventInfo->pimsmPktInfo.pimHeader,
                      nonCandBsrEventInfo->pimsmPktInfo.pimPktLen);
 
   /* set the Bootstrap Timer */
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmBsrNonCandidateBootStrapTimerExpiresHandler,
-                            (void*)nonCandBsrEventInfo->pBsrNode->pimsmBSRTimerHandle,
+                            UINT_TO_PTR(nonCandBsrEventInfo->pBsrNode->pimsmBSRTimerHandle),
                             PIMSM_DEFAULT_BOOTSTRAP_TIMEOUT,
                             &(nonCandBsrEventInfo->pBsrNode->pimsmBSRTimer),
                             "NC-BSR")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_BSR_FSM,  PIMSM_TRACE_ERROR,"bsrCandidateBSRBootstrapTimer Add Failed");
Index: src/application/ip_mcast/vendor/pimsm/pimsmneighbor.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmneighbor.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmneighbor.c	(revision 7778)
@@ -172,13 +172,13 @@ L7_RC_t pimsmNeighborDeInit(pimsmCB_t *
   pCurrNbrEntry = (pimsmNeighborEntry_t *)SLLFirstGet(pNbrList);
   while(pCurrNbrEntry != ( pimsmNeighborEntry_t * )L7_NULLPTR)
   {
     pimsmJPWorkingBuffReturn(pimsmCb, pCurrNbrEntry);
     pimsmUtilAppTimerCancel (pimsmCb, &(pCurrNbrEntry->pimsmNeighborExpiryTimer));
     handleListNodeDelete(pimsmCb->handleList,
-                         &pCurrNbrEntry->pimsmNeighborExpiryTimerHandle);
+                         (L7_uint64 *) &pCurrNbrEntry->pimsmNeighborExpiryTimerHandle);
     pCurrNbrEntry = (pimsmNeighborEntry_t *)SLLNextGet(pNbrList,
                         (L7_sll_member_t *)pCurrNbrEntry);
   }
   rc = SLLDestroy(L7_FLEX_PIMSM_MAP_COMPONENT_ID,
                       &(pIntfEntry->pimsmNbrList));
   if(osapiSemaGive(pimsmCb->pimsmNbrLock) != L7_SUCCESS)
@@ -350,13 +350,13 @@ L7_RC_t pimsmNeighborDelete(pimsmCB_t *
   {
     updateDR = L7_TRUE;
   }
 
   pimsmUtilAppTimerCancel (pimsmCb, &(pNbrEntry->pimsmNeighborExpiryTimer));
   handleListNodeDelete(pimsmCb->handleList,
-                       &pNbrEntry->pimsmNeighborExpiryTimerHandle);
+                       (L7_uint64 *) &pNbrEntry->pimsmNeighborExpiryTimerHandle);
   /* Lock the Table */
   if(osapiSemaTake(pimsmCb->pimsmNbrLock, L7_WAIT_FOREVER)
      != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_INTF_NEIGHBOR,  PIMSM_TRACE_ERROR, "osapiSemaTake() failed");
     return L7_FAILURE;
@@ -795,13 +795,13 @@ static L7_RC_t pimsmNLTExpiresPostEvent(
 *
 * @end
 ******************************************************************************/
 static void pimsmNeighborTimerExpiresHandler(void *pParam)
 {
   L7_uint32 rtrIfNum;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
   pimsmTimerData_t *pTimerData;
   pimsmCB_t * pimsmCb;
   pimsmInterfaceEntry_t * pIntfEntry = L7_NULLPTR;
   pimsmNeighborEntry_t  *pCurrNbrEntry;
   L7_RC_t rc = L7_FAILURE;
   L7_inet_addr_t *pNbrAddr;
@@ -1073,13 +1073,13 @@ L7_RC_t pimsmNeighborCreate(pimsmCB_t *
     memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
     inetCopy(&pTimerData->addr1,
       &pNbrEntry->pimsmNeighborAddrList.pimsmPrimaryAddress);
     pTimerData->rtrIfNum = rtrIfNum;
     pTimerData->pimsmCb = pimsmCb;
     if (pimsmUtilAppTimerSet (pimsmCb, pimsmNeighborTimerExpiresHandler,
-                              (void*)pNbrEntry->pimsmNeighborExpiryTimerHandle,
+                              UINT_TO_PTR(pNbrEntry->pimsmNeighborExpiryTimerHandle),
                               holdtime,
                               &(pNbrEntry->pimsmNeighborExpiryTimer),
                               "SM-NLT")
                            != L7_SUCCESS)
     {
       PIMSM_TRACE(PIMSM_DEBUG_BIT_INTF_NEIGHBOR,  PIMSM_TRACE_ERROR, "RegRate TimerAdd Failed");
@@ -1339,13 +1339,13 @@ L7_RC_t pimsmNeighborUpdate(pimsmCB_t *
     inetCopy(&pTimerData->addr1,
       &pNbrEntry->pimsmNeighborAddrList.pimsmPrimaryAddress);
     pTimerData->pimsmCb = pimsmCb;
     pTimerData->rtrIfNum = rtrIfNum;
 
     if (pimsmUtilAppTimerSet (pimsmCb, pimsmNeighborTimerExpiresHandler,
-                              (void*)pNbrEntry->pimsmNeighborExpiryTimerHandle,
+                              UINT_TO_PTR(pNbrEntry->pimsmNeighborExpiryTimerHandle),
                               pHelloParams->holdtime,
                               &(pNbrEntry->pimsmNeighborExpiryTimer),
                               "SM-NLT2")
                            != L7_SUCCESS)
     {
       PIMSM_TRACE(PIMSM_DEBUG_BIT_INTF_NEIGHBOR,  PIMSM_TRACE_ERROR,
Index: src/application/ip_mcast/vendor/pimsm/pimsmintf.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmintf.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmintf.c	(revision 7778)
@@ -380,13 +380,13 @@ L7_RC_t pimsmIntfDeInit(pimsmCB_t *pimsm
 *
 * @end
 ******************************************************************************/
 static void pimsmIntfHelloTimerExpiresHandler(void *pParam)
 {
   L7_uint32 rtrIfNum;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64  handle = PTR_TO_UINT64(pParam);
   pimsmTimerData_t *pTimerData;
   pimsmCB_t * pimsmCb;
   pimsmInterfaceEntry_t  * pIntfEntry = L7_NULLPTR;
   L7_RC_t rc;
 
   PIMSM_TRACE(PIMSM_DEBUG_BIT_INTF_NEIGHBOR,  PIMSM_TRACE_DEBUG,"Enter ");
@@ -440,13 +440,13 @@ static void pimsmIntfHelloTimerExpiresHa
 
   pTimerData = &pIntfEntry->pimsmHelloTimerParams;
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   pTimerData->pimsmCb = pimsmCb;
   pTimerData->rtrIfNum = rtrIfNum;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmIntfHelloTimerExpiresHandler,
-                            (void*)pIntfEntry->pimsmHelloTimerHandle,
+                            UINT_TO_PTR(pIntfEntry->pimsmHelloTimerHandle),
                             pIntfEntry->pimsmInterfaceHelloInterval,
                             &(pIntfEntry->pimsmHelloTimer),
                             "SM-HT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_INTF_NEIGHBOR,  PIMSM_TRACE_ERROR, "Inteface pimsmHelloTimer TimerAdd Failed");
@@ -583,13 +583,13 @@ L7_RC_t pimsmIntfUp(pimsmCB_t *pimsmCb,
   PIMSM_TRACE(PIMSM_DEBUG_BIT_INTF_NEIGHBOR,  PIMSM_TRACE_DEBUG,"rtrIfNum =%d",rtrIfNum);
   pTimerData = &pIntfEntry->pimsmHelloTimerParams;
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   pTimerData->rtrIfNum = rtrIfNum;
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmIntfHelloTimerExpiresHandler,
-                            (void*)pIntfEntry->pimsmHelloTimerHandle,
+                            UINT_TO_PTR(pIntfEntry->pimsmHelloTimerHandle),
                             helloIntvl,
                             &(pIntfEntry->pimsmHelloTimer),
                             "SM-HT2")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_INTF_NEIGHBOR,  PIMSM_TRACE_ERROR,
@@ -638,13 +638,13 @@ L7_RC_t pimsmIntfUp(pimsmCB_t *pimsmCb,
 * @end
 ******************************************************************************/
 static L7_RC_t pimsmIntfCleanup(pimsmCB_t *pimsmCb, L7_uint32 rtrIfNum)
 {
   pimsmInterfaceEntry_t *pIntfEntry  = L7_NULLPTR;
   L7_RC_t  rc;
-  L7_uint32 timerHandle;
+  L7_uint64 timerHandle;
 
   PIMSM_TRACE(PIMSM_DEBUG_BIT_INTF_NEIGHBOR,  PIMSM_TRACE_DEBUG,"Enter ");
 
   if(pimsmCb == L7_NULLPTR)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_INTF_NEIGHBOR,  PIMSM_TRACE_ERROR,
@@ -696,13 +696,13 @@ static L7_RC_t pimsmIntfCleanup(pimsmCB_
   timerHandle = pIntfEntry->pimsmHelloTimerHandle;
   memset(pIntfEntry, 0 , sizeof(pimsmInterfaceEntry_t));
   pIntfEntry->pimsmHelloTimerHandle = timerHandle;
   pIntfEntry->pimsmInterfaceIfIndex = MCAST_MAX_INTERFACES;
 
   handleListNodeDelete(pimsmCb->handleList,
-                         &pIntfEntry->pimsmHelloTimerHandle);
+                       (L7_uint64 *) &pIntfEntry->pimsmHelloTimerHandle);
 
   PIMSM_TRACE(PIMSM_DEBUG_BIT_INTF_NEIGHBOR,  PIMSM_TRACE_DEBUG,"Exit ");
   return L7_SUCCESS;
 }
 
 /******************************************************************************
Index: src/application/ip_mcast/vendor/pimsm/pimsmupstrmstargfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmupstrmstargfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmupstrmstargfsm.c	(revision 7778)
@@ -261,13 +261,13 @@ static L7_RC_t  pimsmUpStrmStarGJoinSend
   /*Set Join Timer to t_periodic;*/
   pTimerData = &pStarGEntry->pimsmStarGUpstreamJoinTimerParam;
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr2, &pStarGNode->pimsmStarGEntry.pimsmStarGGrpAddress);
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarGUpstreamJoinTimerExpiresHandler,
-                            (void*)pStarGEntry->pimsmStarGUpstreamJoinTimerHandle,
+                            UINT_TO_PTR(pStarGEntry->pimsmStarGUpstreamJoinTimerHandle),
                             jpInterval,
                             &(pStarGEntry->pimsmStarGUpstreamJoinTimer),
                             "xG-JT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_G, PIMSM_TRACE_ERROR, "Failed to add (*,G) upstrm join timer");
@@ -403,13 +403,13 @@ static L7_RC_t  pimsmUpStrmStarGJoinTime
     pTimerData = &pStarGEntry->pimsmStarGUpstreamJoinTimerParam;
     memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
     inetCopy(&pTimerData->addr2, &pStarGNode->pimsmStarGEntry.pimsmStarGGrpAddress);
 
     pTimerData->pimsmCb = pimsmCb;
     if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarGUpstreamJoinTimerExpiresHandler,
-                              (void*)pStarGEntry->pimsmStarGUpstreamJoinTimerHandle,
+                              UINT_TO_PTR(pStarGEntry->pimsmStarGUpstreamJoinTimerHandle),
                               joinSuppress,
                               &(pStarGEntry->pimsmStarGUpstreamJoinTimer),
                               "xG-JT2")
                            != L7_SUCCESS)
     {
       PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_G, PIMSM_TRACE_ERROR, "Failed to update (*,G) upstrm join timer");
@@ -462,13 +462,13 @@ static L7_RC_t  pimsmUpStrmStarGJoinTime
     pTimerData = &pStarGEntry->pimsmStarGUpstreamJoinTimerParam;
     memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
     inetCopy(&pTimerData->addr2, &pStarGNode->pimsmStarGEntry.pimsmStarGGrpAddress);
     pTimerData->pimsmCb = pimsmCb;
 
     if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarGUpstreamJoinTimerExpiresHandler,
-                              (void*)pStarGEntry->pimsmStarGUpstreamJoinTimerHandle,
+                              UINT_TO_PTR(pStarGEntry->pimsmStarGUpstreamJoinTimerHandle),
                               jpOverrideInterval,
                               &(pStarGEntry->pimsmStarGUpstreamJoinTimer),
                               "xG-JT3")
                            != L7_SUCCESS)
     {
       PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_G, PIMSM_TRACE_ERROR, "Failed to update (*,G) upstrm join timer");
@@ -605,13 +605,13 @@ static L7_RC_t  pimsmUpStrmStarGJoinPrun
   pTimerData = &pStarGEntry->pimsmStarGUpstreamJoinTimerParam;
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr2, &pStarGNode->pimsmStarGEntry.pimsmStarGGrpAddress);
 
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarGUpstreamJoinTimerExpiresHandler,
-                            (void*)pStarGEntry->pimsmStarGUpstreamJoinTimerHandle,
+                            UINT_TO_PTR(pStarGEntry->pimsmStarGUpstreamJoinTimerHandle),
                             jpInterval,
                             &(pStarGEntry->pimsmStarGUpstreamJoinTimer),
                             "xG-JT4")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_G, PIMSM_TRACE_ERROR, "Failed to add (*,G) upstrm join timer");
@@ -656,15 +656,15 @@ static L7_RC_t pimsmUpStrmStarGErrorRetu
 ******************************************************************************/
 static void pimsmStarGUpstreamJoinTimerExpiresHandler(void *pParam)
 {
   pimsmUpStrmStarGEventInfo_t upStrmStarGEventInfo;
   pimsmStarGNode_t *pStarGNode;
   pimsmCB_t * pimsmCb;
-  L7_inet_addr_t *pGrpAddr;
-  L7_int32      handle = (L7_int32)pParam;
-  pimsmTimerData_t *pTimerData;
+  L7_inet_addr_t    *pGrpAddr;
+  L7_uint64         handle = PTR_TO_UINT64(pParam);
+  pimsmTimerData_t  *pTimerData;
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_G, PIMSM_TRACE_NORMAL, "pTimerData == L7_NULLPTR");
     return ;
Index: src/application/ip_mcast/vendor/pimsm/pimsmdnstrmsgfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmdnstrmsgfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmdnstrmsgfsm.c	(revision 7778)
@@ -222,13 +222,13 @@ static L7_RC_t  pimsmDnStrmPerIntfSGExpi
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   pTimerData->rtrIfNum = rtrIfNum;
   inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGIJoinTimerExpiresHandler,
-                            (void*)pSGIEntry->pimsmSGIJoinExpiryTimerHandle,
+                            UINT_TO_PTR(pSGIEntry->pimsmSGIJoinExpiryTimerHandle),
                             holdtime,
                             &(pSGIEntry->pimsmSGIJoinExpiryTimer),
                             "SGI-JT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G, PIMSM_TRACE_ERROR,
@@ -291,13 +291,13 @@ static L7_RC_t  pimsmDnStrmPerIntfSGExpi
                            &timeLeft) == L7_SUCCESS)
   {
     holdtime = max (timeLeft, holdtime);
   }
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGIJoinTimerExpiresHandler,
-                            (void*)pSGIEntry->pimsmSGIJoinExpiryTimerHandle,
+                            UINT_TO_PTR(pSGIEntry->pimsmSGIJoinExpiryTimerHandle),
                             holdtime,
                             &(pSGIEntry->pimsmSGIJoinExpiryTimer),
                             "SGI-JT2")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G, PIMSM_TRACE_ERROR,
@@ -361,13 +361,13 @@ static L7_RC_t  pimsmDnStrmPerIntfSGPrun
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   pTimerData->rtrIfNum = rtrIfNum;
   inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGIPrunePendingTimerExpiresHandler,
-                            (void*)pSGIEntry->pimsmSGIPrunePendingTimerHandle,
+                            UINT_TO_PTR(pSGIEntry->pimsmSGIPrunePendingTimerHandle),
                             timeOut,
                             &(pSGIEntry->pimsmSGIPrunePendingTimer),
                             "SGI-PPT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G, PIMSM_TRACE_ERROR,
@@ -516,13 +516,13 @@ static L7_RC_t pimsmDnStrmPerIntfSGError
 * @end
 ******************************************************************************/
 static void pimsmSGIPrunePendingTimerExpiresHandler(void *pParam)
 {
   pimsmCB_t               *pimsmCb;
   pimsmTimerData_t        *pTimerData;
-  L7_int32                 handle = (L7_int32)pParam;
+  L7_uint64                handle = PTR_TO_UINT64(pParam);
   pimsmSGNode_t           *pSGNode;
   pimsmSGIEntry_t         *pSGIEntry = L7_NULLPTR;
   L7_uint32                rtrIfNum;
   L7_BOOL                  joinDesired;
   pimsmDnStrmPerIntfSGEventInfo_t dnStrmPerIntfSGEventInfo;
   pimsmUpStrmSGEventInfo_t upStrmSGEventInfo;
@@ -619,13 +619,13 @@ static void pimsmSGIPrunePendingTimerExp
 * @end
 ******************************************************************************/
 static void pimsmSGIJoinTimerExpiresHandler(void *pParam)
 {
   pimsmTimerData_t   *pTimerData;
   pimsmCB_t          *pimsmCb;
-  L7_int32            handle = (L7_int32)pParam;
+  L7_uint64           handle = PTR_TO_UINT64(pParam);
   pimsmSGNode_t      *pSGNode;
   pimsmSGIEntry_t    *pSGIEntry = L7_NULLPTR;
   L7_uint32           rtrIfNum;
   L7_BOOL             joinDesired;
   pimsmDnStrmPerIntfSGEventInfo_t dnStrmPerIntfSGEventInfo;
   pimsmUpStrmSGEventInfo_t upStrmSGEventInfo;
Index: src/application/ip_mcast/vendor/pimsm/pimsmdnstrmstargfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmdnstrmstargfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmdnstrmstargfsm.c	(revision 7778)
@@ -225,13 +225,13 @@ static L7_RC_t pimsmDnStrmPerIntfStarGEx
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr2, &pStarGNode->pimsmStarGEntry.pimsmStarGGrpAddress);
   pTimerData->rtrIfNum = rtrIfNum;
 
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarGIJoinExpiryTimerExpiresHandler,
-                            (void*)pStarGIEntry->pimsmStarGIJoinExpiryTimerHandle,
+                            UINT_TO_PTR(pStarGIEntry->pimsmStarGIJoinExpiryTimerHandle),
                             holdtime,
                             &(pStarGIEntry->pimsmStarGIJoinExpiryTimer),
                             "xGI-JT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_G, PIMSM_TRACE_ERROR,
@@ -294,13 +294,13 @@ static L7_RC_t pimsmDnStrmPerIntfStarGEx
                            &timeLeft) == L7_SUCCESS)
   {
     holdtime = max (timeLeft, holdtime);
   }
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarGIJoinExpiryTimerExpiresHandler,
-                            (void*)pStarGIEntry->pimsmStarGIJoinExpiryTimerHandle,
+                            UINT_TO_PTR(pStarGIEntry->pimsmStarGIJoinExpiryTimerHandle),
                             holdtime,
                             &(pStarGIEntry->pimsmStarGIJoinExpiryTimer),
                             "xGI-JT2")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_G, PIMSM_TRACE_ERROR,
@@ -362,13 +362,13 @@ static L7_RC_t pimsmDnStrmPerIntfStarGPr
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr2, &pStarGNode->pimsmStarGEntry.pimsmStarGGrpAddress);
   pTimerData->rtrIfNum = rtrIfNum;
 
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarGIPrunePendingTimerExpiresHandler,
-                            (void*)pStarGIEntry->pimsmStarGIPrunePendingTimerHandle,
+                            UINT_TO_PTR(pStarGIEntry->pimsmStarGIPrunePendingTimerHandle),
                             timeOut,
                             &(pStarGIEntry->pimsmStarGIPrunePendingTimer),
                             "xGI-PPT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_G, PIMSM_TRACE_ERROR,
@@ -522,13 +522,13 @@ static void pimsmStarGIPrunePendingTimer
   pimsmDnStrmPerIntfStarGEventInfo_t dnStrmPerIntfStarGEventInfo;
   pimsmTimerData_t   *pTimerData;
   pimsmStarGNode_t   *pStarGNode;
   pimsmStarGIEntry_t *pStarGIEntry = L7_NULLPTR;
   L7_uint32           rtrIfNum;
   pimsmCB_t          *pimsmCb;
-  L7_int32            handle = (L7_int32)pParam;
+  L7_uint32           handle = PTR_TO_UINT64(pParam);
   pimsmUpStrmStarGEventInfo_t UpStrmStarGEventInfo;
   L7_BOOL  joinDesired =L7_FALSE;
   L7_BOOL couldAssert;
   pimsmPerIntfStarGAssertEventInfo_t  starGAssertEventInfo;
   L7_inet_addr_t *pGrpAddr;
 
@@ -637,13 +637,13 @@ static void pimsmStarGIJoinExpiryTimerEx
 
   pimsmTimerData_t *pTimerData ;
   pimsmStarGNode_t * pStarGNode;
   pimsmStarGIEntry_t *pimsmStarGIEntry =L7_NULLPTR;
   L7_uint32 rtrIfNum;
   pimsmCB_t * pimsmCb;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint32 handle = PTR_TO_UINT64(pParam);
   pimsmUpStrmStarGEventInfo_t starGUpStrmEvData;
   L7_BOOL  joinDesired =L7_FALSE;
   L7_inet_addr_t *pGrpAddr;
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
Index: src/application/ip_mcast/vendor/pimsm/pimsmsgrpttree.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmsgrpttree.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmsgrpttree.c	(revision 7778)
@@ -300,13 +300,13 @@ L7_RC_t pimsmSGRptDelete(pimsmCB_t * pim
                              pSGRptNodeDelete,index);
     }
   }
 
   pimsmUtilAppTimerCancel (pimsmCb, &(pSGRptNodeDelete->pimsmSGRptEntry.pimsmSGRptUpstreamOverrideTimer));
   handleListNodeDelete(pimsmCb->handleList,
-                       &pSGRptNodeDelete->pimsmSGRptEntry.pimsmSGRptUpstreamOverrideTimerHandle);
+                       (L7_uint64 *) &pSGRptNodeDelete->pimsmSGRptEntry.pimsmSGRptUpstreamOverrideTimerHandle);
   pimsmSGRptMFCUpdate(pimsmCb, pSGRptNodeDelete, MFC_DELETE_ENTRY, L7_FALSE);
   pSGRptNode = avlDeleteEntry(&pimsmCb->pimsmSGRptTree,pSGRptNodeDelete);
   if(osapiSemaGive(pimsmCb->pimsmSGRptTree.semId) != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G_RPT, PIMSM_TRACE_ERROR, "Failed to give semaphore"); 
     return L7_FAILURE;
@@ -768,17 +768,17 @@ L7_RC_t pimsmSGRptIEntryDelete(pimsmCB_t
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G_RPT, PIMSM_TRACE_DEBUG,
          " (S,G,Rpt,%d) already deleted ",rtrIfNum);
    return L7_SUCCESS;
   }   
   pimsmUtilAppTimerCancel (pimsmCb, &(pSGRptIEntry->pimsmSGRptIPrunePendingTimer));
   handleListNodeDelete(pimsmCb->handleList,
-                       &pSGRptIEntry->pimsmSGRptIPrunePendingTimerHandle);
+                       (L7_uint64 *) &pSGRptIEntry->pimsmSGRptIPrunePendingTimerHandle);
 
   pimsmUtilAppTimerCancel (pimsmCb, &(pSGRptIEntry->pimsmSGRptIPruneExpiryTimer));
   handleListNodeDelete(pimsmCb->handleList,
-                       &pSGRptIEntry->pimsmSGRptIPruneExpiryTimerHandle);
+                       (L7_uint64 *) &pSGRptIEntry->pimsmSGRptIPruneExpiryTimerHandle);
 
   PIMSM_FREE (pimsmCb->family, (void*) pSGRptIEntry);
   pSGRptNode->pimsmSGRptIEntry[rtrIfNum] = L7_NULLPTR;
   return L7_SUCCESS;
 }
 
@@ -808,13 +808,13 @@ L7_RC_t pimsmSGRptTreePurge(pimsmCB_t *
   while(rc == L7_SUCCESS)
   {
     pimsmSGRptMFCUpdate(pimsmCb, pSGRptNode, MFC_DELETE_ENTRY, L7_FALSE);
     pSGRptEntry = &pSGRptNode->pimsmSGRptEntry;  
     pimsmUtilAppTimerCancel (pimsmCb, &(pSGRptEntry->pimsmSGRptUpstreamOverrideTimer));
     handleListNodeDelete(pimsmCb->handleList,
-                         &pSGRptEntry->pimsmSGRptUpstreamOverrideTimerHandle);
+                         (L7_uint64 *) &pSGRptEntry->pimsmSGRptUpstreamOverrideTimerHandle);
 
     for(rtrIfNum = 0; rtrIfNum < MCAST_MAX_INTERFACES; rtrIfNum++)
     {
       pimsmSGRptIEntryDelete(pimsmCb, pSGRptNode,rtrIfNum);
     }    
    rc = pimsmSGRptNextGet( pimsmCb, pSGRptNode, &pSGRptNode );
Index: src/application/ip_mcast/vendor/pimsm/pimsmupstrmsgrptfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmupstrmsgrptfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmupstrmsgrptfsm.c	(revision 7778)
@@ -499,13 +499,13 @@ static L7_RC_t  pimsmUpStrmSGRptOverride
   inetCopy(&pTimerData->addr1,
         &pSGRptNode->pimsmSGRptEntry.pimsmSGRptSrcAddress);
   inetCopy(&pTimerData->addr2,
         &pSGRptNode->pimsmSGRptEntry.pimsmSGRptGrpAddress);
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmUpStrmSGRptOverrideTimerExpiresHandler,
-                            (void*)pSGRptEntry->pimsmSGRptUpstreamOverrideTimerHandle,
+                            UINT_TO_PTR(pSGRptEntry->pimsmSGRptUpstreamOverrideTimerHandle),
                             timeout,
                             &(pSGRptEntry->pimsmSGRptUpstreamOverrideTimer),
                             "SGr-OT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G_RPT,PIMSM_TRACE_ERROR, "Failed to add (S,G,Rpt) upstrm Override timer");
@@ -572,16 +572,16 @@ static L7_RC_t pimsmUpStrmSGRptErrorRetu
 * @end
 ******************************************************************************/
 static void pimsmUpStrmSGRptOverrideTimerExpiresHandler(void *pParam)
 {
   pimsmUpStrmSGRptEventInfo_t upStrmSGRptEventInfo;
   pimsmSGRptNode_t *pSGRptNode;
-  pimsmCB_t * pimsmCb;
-  L7_int32    handle = (L7_int32)pParam;
+  pimsmCB_t        *pimsmCb;
+  L7_uint64        handle = PTR_TO_UINT64(pParam);
   pimsmTimerData_t *pTimerData;
-  L7_inet_addr_t *pGrpAddr, *pSrcAddr;
+  L7_inet_addr_t   *pGrpAddr, *pSrcAddr;
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G_RPT,PIMSM_TRACE_NORMAL, "pTimerData == L7_NULLPTR");
     return ;
   }
Index: src/application/ip_mcast/vendor/pimsm/pimsmtimer.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmtimer.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmtimer.c	(revision 7778)
@@ -84,16 +84,16 @@ void pimsmSPTTimerExpiresHandler(void *p
   pimsmStarGNode_t  *pStarGNode;
   L7_RC_t rc;
   pimsmCache_t  kernelRouteData, *kernelCacheNode;
   L7_inet_addr_t   *pSrcAddr;
   L7_inet_addr_t   *pGrpAddr;
   pimsmTimerData_t *pTimerData;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64         handle = PTR_TO_UINT64(pParam);
   pimsmCB_t *pimsmCb = L7_NULLPTR;
 
-  PIMSM_TRACE(PIMSM_DEBUG_BIT_MISC,PIMSM_TRACE_DEBUG, "handle = %d",
+  PIMSM_TRACE(PIMSM_DEBUG_BIT_MISC,PIMSM_TRACE_DEBUG, "handle = %llu",
               handle);
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if(L7_NULLPTR == pTimerData)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_MISC,PIMSM_TRACE_ERROR,"Invalid input parameter");
@@ -135,13 +135,13 @@ void pimsmSPTTimerExpiresHandler(void *p
                                    kernelCacheNode, &kernelCacheNode);
     }
      rc = pimsmStarGNextGet(pimsmCb, pStarGNode, &pStarGNode);
   }
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSPTTimerExpiresHandler,
-                            (void*)pimsmCb->pimsmSPTTimerHandle,
+                            UINT_TO_PTR(pimsmCb->pimsmSPTTimerHandle),
                             PIMSM_DEFAULT_CHECK_INTERVAL,
                             &(pimsmCb->pimsmSPTTimer),
                             "SM-SPT2")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_MISC,PIMSM_TRACE_ERROR, "pimsmSPTTimer appTimerAdd Failed");
Index: src/application/ip_mcast/vendor/pimsm/pimsmrp.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmrp.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmrp.c	(revision 7778)
@@ -173,13 +173,13 @@ L7_RC_t pimsmRpGrpAddrNodeDelete(L7_sll_
     addrListNode->pimsmRpGrpExpiryTimer = L7_NULLPTR;
   }
   /* delete the handle */
   if (addrListNode->pimsmRpGrpExpireTimerHandle != L7_NULL)
   {
    handleListNodeDelete(addrListNode->pimsmCb->handleList,
-                       &addrListNode->pimsmRpGrpExpireTimerHandle);
+                        (L7_uint64 *) &addrListNode->pimsmRpGrpExpireTimerHandle);
    addrListNode->pimsmRpGrpExpireTimerHandle = L7_NULL;
   }
   /* remove it from the buffer pool */
   PIMSM_FREE (addrListNode->pimsmCb->family, (void*) addrListNode);
 
   return L7_SUCCESS;
@@ -1729,13 +1729,13 @@ L7_RC_t pimsmRpCandRpAdvCreate(pimsmCB_t
 *
 * @end
 ******************************************************************************/
 static
 void pimsmRpGrpMappingTimerExpiresHandler(void *pParam)
 {
-  L7_int32                 handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
   pimsmAddrList_t         *pAddrListNode = L7_NULLPTR;
   pimsmCandRpConfigInfo_t  rpConfigInfo;
   pimsmRpGrpNode_t  *pRpGrpNode;
 
   pAddrListNode = (pimsmAddrList_t*)handleListNodeRetrieve(handle);
 
@@ -2221,13 +2221,13 @@ void pimsmRprGrpMappingExpireTimerSet(pi
   {
     rc = pimsmRpGrpListGrpNodeFind(pimsmCb, pRpGrpNode, grpAddr,
                                    grpMaskLen,origin, &pAddrGrpNode);
     if (rc == L7_SUCCESS)
     {
       if (pimsmUtilAppTimerSet (pimsmCb, pimsmRpGrpMappingTimerExpiresHandler,
-                                (void*)pAddrGrpNode->pimsmRpGrpExpireTimerHandle,
+                                UINT_TO_PTR(pAddrGrpNode->pimsmRpGrpExpireTimerHandle),
                                 timeout,
                                 &(pAddrGrpNode->pimsmRpGrpExpiryTimer),
                                 "RPG-ET")
                              != L7_SUCCESS)
       {
         PIMSM_TRACE(PIMSM_DEBUG_BIT_RP, PIMSM_TRACE_ERROR," Unable to start pimsmRpGrpExpiryTimer");
@@ -2858,13 +2858,13 @@ void pimsmRpGrpMappingPurge(pimsmCB_t *p
   {
     pAddrListNode = (pimsmAddrList_t *)SLLFirstGet(&(pRpGrpNode->pimsmGrpList));
     while(pAddrListNode != L7_NULLPTR)
     {
       pimsmUtilAppTimerCancel (pimsmCb, &(pAddrListNode->pimsmRpGrpExpiryTimer));
       handleListNodeDelete(pimsmCb->handleList,
-                           &pAddrListNode->pimsmRpGrpExpireTimerHandle);
+                           (L7_uint64 *) &pAddrListNode->pimsmRpGrpExpireTimerHandle);
       pAddrListNodeDelete = pAddrListNode;
       pAddrListNode = (pimsmAddrList_t*)SLLNextGet(&(pRpGrpNode->pimsmGrpList),
                                         (L7_sll_member_t*)pAddrListNode);
       SLLNodeDelete(&(pRpGrpNode->pimsmGrpList),
                     (L7_sll_member_t *) pAddrListNodeDelete);
     }
Index: src/application/ip_mcast/vendor/pimsm/pimsmcandbsrfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmcandbsrfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmcandbsrfsm.c	(revision 7778)
@@ -152,13 +152,13 @@ L7_RC_t pimsmPerScopeZoneCandBSRExecute(
 * @comments
 *
 * @end
 ******************************************************************************/
 void pimsmBsrCandidateBootStrapTimerExpiresHandler (void *pParam)
 {
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
   pimsmBsrPerScopeZone_t                *bsrNode;
   pimsmPerScopeZoneCandBSREventInfo_t    candEventInfo;
 
   bsrNode = (pimsmBsrPerScopeZone_t *)handleListNodeRetrieve(handle);
 
   if(bsrNode == L7_NULLPTR)
@@ -218,13 +218,13 @@ L7_RC_t  pimsmPerScopeZoneCandBSRAction1
                      bsrNode,
                      candBsrEventInfo->pimsmPktInfo.pimHeader,
                      candBsrEventInfo->pimsmPktInfo.pimPktLen);
 
   /*Set Bootstrap Timer to BS_timeout;*/
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmBsrCandidateBootStrapTimerExpiresHandler,
-                            (void*)bsrNode->pimsmBSRTimerHandle,
+                            UINT_TO_PTR(bsrNode->pimsmBSRTimerHandle),
                             PIMSM_DEFAULT_BOOTSTRAP_TIMEOUT,
                             &(bsrNode->pimsmBSRTimer),
                             "SM-BSR2")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_BSR_FSM,  PIMSM_TRACE_ERROR, "bsrCandidateBSRBootstrapTimer Add Failed");
@@ -259,13 +259,13 @@ L7_RC_t  pimsmPerScopeZoneCandBSRAction2
   pimsmBsrPacketForward (pimsmCb, bsrNode, candBsrEventInfo->pimsmPktInfo.pimHeader,
                          candBsrEventInfo->pimsmPktInfo.pimPktLen,
                          candBsrEventInfo->pimsmPktInfo.rtrIfNum);
 
   /*Set Bootstrap Timer to BS_timeout;*/
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmBsrCandidateBootStrapTimerExpiresHandler,
-                            (void*)bsrNode->pimsmBSRTimerHandle,
+                            UINT_TO_PTR(bsrNode->pimsmBSRTimerHandle),
                             pimsmBsrRandOverrideIntervalGet(pimsmCb,bsrNode),
                             &(bsrNode->pimsmBSRTimer),
                             "SM-BSR3")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_BSR_FSM,  PIMSM_TRACE_ERROR,"bsrCandidateBSRBootstrapTimer Add Failed");
@@ -306,13 +306,13 @@ L7_RC_t  pimsmPerScopeZoneCandBSRAction3
                 pimsmCb->pimsmBsrInfo->pimsmCandBSRInfo.pimsmBSRCandidateBSRHashMaskLength;
   pimsmBsrCandRpToRpGrpListGet(pimsmCb,bsrNode);
   pimsmBsrPacketOriginate(pimsmCb,bsrNode,L7_NULLPTR,0);
 
   /*Set Bootstrap Timer to BS_period;*/
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmBsrCandidateBootStrapTimerExpiresHandler,
-                            (void*)bsrNode->pimsmBSRTimerHandle,
+                            UINT_TO_PTR(bsrNode->pimsmBSRTimerHandle),
                             PIMSM_DEFAULT_BOOTSTRAP_PERIOD,
                             &(bsrNode->pimsmBSRTimer),
                             "SM-BSR4")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_BSR_FSM,  PIMSM_TRACE_ERROR,"bsrCandidateBSRBootstrapTimer Add Failed");
Index: src/application/ip_mcast/vendor/pimsm/pimsmmacros.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmmacros.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmmacros.c	(revision 7778)
@@ -3661,13 +3661,13 @@ void pimsmRestartKeepaliveTimer(pimsmCB_
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   pTimerData->pimsmCb = pimsmCb;
   inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
     
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGKeepaliveTimerExpiresHandler,
-                            (void*)pSGNode->pimsmSGEntry.pimsmSGKeepaliveTimerHandle,
+                            UINT_TO_PTR(pSGNode->pimsmSGEntry.pimsmSGKeepaliveTimerHandle),
                             timeout,
                             &(pSGNode->pimsmSGEntry.pimsmSGKeepaliveTimer),
                             "SM-KAT")
                          != L7_SUCCESS)
   {
      PIMSM_TRACE(PIMSM_DEBUG_BIT_MACROS, PIMSM_TRACE_ERROR, 
Index: src/application/ip_mcast/vendor/pimsm/pimsmmain.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmmain.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmmain.c	(revision 7778)
@@ -341,25 +341,25 @@ MCAST_CB_HNDL_t pimsmCtrlBlockInit(L7_uc
     pimsmCtrlBlockCleanUp(pimsmCb);
     return L7_NULLPTR;
   }
   pimsmCb->pimsmSPTTimerHandle = 
   handleListNodeStore(pimsmCb->handleList,
                       (void*)&pimsmCb->pimsmSPTTimerParam); 
-  PIMSM_TRACE(PIMSM_DEBUG_BIT_MISC,PIMSM_TRACE_DEBUG, "pimsmCb->pimsmSPTTimerHandle= %d",
+  PIMSM_TRACE(PIMSM_DEBUG_BIT_MISC,PIMSM_TRACE_DEBUG, "pimsmCb->pimsmSPTTimerHandle= 0x%llx",
               pimsmCb->pimsmSPTTimerHandle);   
   /*Initialize the timer */
   pimsmCb->pimsmRateCheckInterval = PIMSM_DEFAULT_CHECK_INTERVAL;
   pimsmCb->pimsmDataRateBytes = (L7_PIMSM_DATA_THRESHOLD_RATE * 1000 *
                                   PIMSM_DEFAULT_CHECK_INTERVAL)/10;
   pimsmCb->pimsmRegRateBytes = (L7_PIMSM_REG_THRESHOLD_RATE * 1000 *
                                  PIMSM_DEFAULT_CHECK_INTERVAL)/10;
 
   pimsmCb->pimsmJPBundleTimerHandle= 
   handleListNodeStore(pimsmCb->handleList,
                       (void*)&pimsmCb->pimsmJPBundleTimerParam); 
-  PIMSM_TRACE(PIMSM_DEBUG_BIT_MISC,PIMSM_TRACE_DEBUG, "pimsmCb->pimsmJPBundleTimerHandle= %d",
+  PIMSM_TRACE(PIMSM_DEBUG_BIT_MISC,PIMSM_TRACE_DEBUG, "pimsmCb->pimsmJPBundleTimerHandle= 0x%llx",
               pimsmCb->pimsmJPBundleTimerHandle);   
   if(pimsmRouteChangeBufMemAlloc(pimsmCb) != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_MISC,PIMSM_TRACE_ERROR,"PIMSM: RTO change buffer allocation failed\n");
     pimsmCtrlBlockCleanUp(pimsmCb);
     return L7_NULLPTR;
@@ -538,13 +538,13 @@ L7_RC_t pimsmEventProcess(L7_uchar8 fami
       pMfcEntry = (mfcEntry_t*) pMsg;
       mbuf = (struct rtmbuf *)pMfcEntry->m;
       pData = rtmtod(mbuf, L7_uchar8 *);
       rc = pimsmMfcWholePktProcess(pimsmCb, pData);
       if ((mbuf->rtm_bufhandle) != L7_NULLPTR)
       {
-        SYSAPI_NET_MBUF_FREE((L7_netBufHandle)mbuf->rtm_bufhandle);
+        SYSAPI_NET_MBUF_FREE((L7_netBufHandle)PTR_TO_UINT64(mbuf->rtm_bufhandle));
       }
       rtm_freem(mbuf);
       break;
 
     case MCAST_EVENT_MGMD_GROUP_UPDATE:
       mgmdMrpGrpInfo = (mgmdMrpEventInfo_t *) pMsg;
Index: src/application/ip_mcast/vendor/pimsm/pimsmstarstarrptree.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmstarstarrptree.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmstarstarrptree.c	(revision 7778)
@@ -264,13 +264,13 @@ L7_RC_t pimsmStarStarRpDelete(pimsmCB_t
   }
 
   PIMSM_TRACE_ADDR(PIMSM_DEBUG_BIT_STAR_STAR_RP, PIMSM_TRACE_ERROR, "Addr to delete is :",
                &pStarStarRpNode->pimsmStarStarRpEntry.pimsmStarStarRpRPAddress);   
   pimsmUtilAppTimerCancel (pimsmCb, &(pStarStarRpNode->pimsmStarStarRpEntry.pimsmStarStarRpUpstreamJoinTimer));
   handleListNodeDelete(pimsmCb->handleList,
-  &pStarStarRpNode->pimsmStarStarRpEntry.pimsmStarStarRpUpstreamJoinTimerHandle);
+                       (L7_uint64 *) &pStarStarRpNode->pimsmStarStarRpEntry.pimsmStarStarRpUpstreamJoinTimerHandle);
 
   for(rtrIfNum = 0; rtrIfNum < MCAST_MAX_INTERFACES; rtrIfNum++)
   {
     pimsmStarStarRpIEntryDelete(pimsmCb, pStarStarRpNode, rtrIfNum);
   }
 
@@ -763,15 +763,15 @@ L7_RC_t pimsmStarStarRpIEntryDelete(pims
    return L7_SUCCESS;
   }     
 
   pimsmUtilAppTimerCancel (pimsmCb, &(pStarStarRpIEntry->pimsmStarStarRpIPrunePendingTimer));
   pimsmUtilAppTimerCancel (pimsmCb, &(pStarStarRpIEntry->pimsmStarStarRpIJoinExpiryTimer));
   handleListNodeDelete(pimsmCb->handleList,
-                       &pStarStarRpIEntry->pimsmStarStarRpIPrunePendingTimerHandle);     
+                       (L7_uint64 *) &pStarStarRpIEntry->pimsmStarStarRpIPrunePendingTimerHandle);     
   handleListNodeDelete(pimsmCb->handleList,
-                       &pStarStarRpIEntry->pimsmStarStarRpIJoinExpiryTimerHandle);     
+                       (L7_uint64 *) &pStarStarRpIEntry->pimsmStarStarRpIJoinExpiryTimerHandle);     
 
   PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_STAR_RP, PIMSM_TRACE_DEBUG,"Address of pointer to be freed is %p\r\n",
               pStarStarRpIEntry);
   PIMSM_FREE (pimsmCb->family, (void*) pStarStarRpIEntry);
 
   pStarStarRpNode->pimsmStarStarRpIEntry[rtrIfNum] = L7_NULLPTR;
Index: src/application/ip_mcast/vendor/pimsm/pimsmbsr.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmbsr.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmbsr.c	(revision 7778)
@@ -145,13 +145,13 @@ L7_RC_t pimsmBsrNodeDelete(pimsmCB_t *pi
     PIMSM_TRACE(PIMSM_DEBUG_BIT_BSR, PIMSM_TRACE_INFO,"BSR Scope zone timer deleted ");
     pimsmUtilAppTimerCancel (pimsmCb, &(bsrEntry->zone.nbsr.pimsmBSRScopeZoneExpireTimer));
   }
 
   /* remove the handle */
   handleListNodeDelete(bsrEntry->pimsmCb->handleList,
-                         &bsrEntry->pimsmBSRTimerHandle);
+                       (L7_uint64 *) &bsrEntry->pimsmBSRTimerHandle);
   /* Delete the entry */
   memset(bsrEntry, 0, sizeof(pimsmBsrPerScopeZone_t));
   inetAddressZeroSet(pimsmCb->family, &bsrEntry->pimsmBSRAddr);
   inetAddressZeroSet(pimsmCb->family, &bsrEntry->pimsmBSRGroupRange);
   inetAddressZeroSet(pimsmCb->family, 
                        &bsrEntry->zone.cbsr.pimsmElectedBSRAddress);  
@@ -451,13 +451,13 @@ static L7_RC_t pimsmBsrInfoNodeAdd(pimsm
       bsrNode->zone.cbsr.pimsmCandBSRState = 
       PIMSM_CANDIDATE_BSR_SM_STATE_PENDING_BSR;
       bsrNode->zone.cbsr.pimsmElectedBSRPriority= bsrPriority;
       bsrNode->zone.cbsr.pimsmElectedBSRHashMaskLen = bsrHashMasklen;
       inetCopy(&(bsrNode->zone.cbsr.pimsmElectedBSRAddress), &bsrAddr);
       if (pimsmUtilAppTimerSet (pimsmCb, pimsmBsrCandidateBootStrapTimerExpiresHandler,
-                                (void*)bsrNode->pimsmBSRTimerHandle,
+                                UINT_TO_PTR(bsrNode->pimsmBSRTimerHandle),
                                 pimsmBsrRandOverrideIntervalGet(pimsmCb,bsrNode),
                                 &(bsrNode->pimsmBSRTimer),
                                 "SM-BSR") != L7_SUCCESS)
       {
         PIMSM_TRACE(PIMSM_DEBUG_BIT_BSR,  PIMSM_TRACE_ERROR, "BSR Timer Add Failed");
       }
@@ -475,13 +475,13 @@ static L7_RC_t pimsmBsrInfoNodeAdd(pimsm
         /* set the state to accept any */
         bsrNode->zone.nbsr.pimsmNonCandBSRState = 
         PIM_NON_CANDIDATE_BSR_SM_STATE_ACCEPT_ANY;
 
         /*  start the scope zone timer */
         if (pimsmUtilAppTimerSet (pimsmCb, pimsmBsrNonCandidateScopeZoneTimerExpiresHandler,
-                                  (void*)bsrNode->pimsmBSRTimerHandle,
+                                  UINT_TO_PTR(bsrNode->pimsmBSRTimerHandle),
                                   PIMSM_DEFAULT_BOOTSTRAP_SZ_TIMEOUT,
                                   &(bsrNode->zone.nbsr.pimsmBSRScopeZoneExpireTimer),
                                   "SM-SZT")
                                != L7_SUCCESS)
         {
           PIMSM_TRACE(PIMSM_DEBUG_BIT_BSR,  PIMSM_TRACE_ERROR, "pimsmBSRScopeZoneExpireTimer Timer Add Failed");
@@ -1168,13 +1168,13 @@ L7_uint32 pimsmBsrPacketGrpInfoExtract(L
   pGrpNode->pimsmGrpMaskLength = encodGrpAddr.masklen;
   MCAST_GET_BYTE(pGrpNode->pimsmRpCnt,pDataTemp);
   MCAST_GET_BYTE(pGrpNode->pimsmFragRpCnt,pDataTemp);
   MCAST_GET_SHORT(reserved, pDataTemp);
   MCAST_UNUSED_PARAM (reserved);
 
-  return((L7_uint32)pDataTemp - (L7_uint32)pData);
+  return (L7_uint32) (PTR_TO_UINT64(pDataTemp) - PTR_TO_UINT64(pData));
 }
 
 /******************************************************************************
 * @purpose  To extract the RP info from the BSM packet
 *
 * @param    pimPkt   @b{(input)} the pointer to the pim message.
@@ -1201,13 +1201,13 @@ L7_uint32 pimsmBsrPacketRpInfoExtract(L7
   inetAddressSet(encodRpAddr.addr_family,&encodRpAddr.addr,&pRpNode->pimsmRpAddr);
   MCAST_GET_SHORT(pRpNode->pimsmRpHoldtime,pDataTemp);
   MCAST_GET_BYTE(pRpNode->pimsmRpPriority,pDataTemp);
   MCAST_GET_BYTE(reserved,pDataTemp);
   MCAST_UNUSED_PARAM (reserved);
 
-  return((L7_uint32)pDataTemp - (L7_uint32)pData);
+  return (L7_uint32) (PTR_TO_UINT64(pDataTemp) - PTR_TO_UINT64(pData));
 }
 
 /******************************************************************************
 * @purpose  To store the grp-rp mappings in the fragment list 
 *
 * @param    pimsmCb      @b{(input)} pointer to the pimsm control block.
@@ -1327,13 +1327,13 @@ static L7_uint32 pimsmBsrPacketFragListS
       }
       /* delete the frag node belonging to this group afterwards */
       SLLDelete(&(pBsrNode->pimsmBSRFragInfo.pimsmGrpRpList),
                 (L7_sll_member_t*)pFragGrpNode);
     }
   }
-  return((L7_uint32)pDataTemp - (L7_uint32)pData);
+  return (L7_uint32) (PTR_TO_UINT64(pDataTemp) - PTR_TO_UINT64(pData));
 }
 
 
 /******************************************************************************
 * @purpose  To store the RP-Group mapping obtained from the BSR packet 
 *
@@ -1371,13 +1371,13 @@ void pimsmBsrPacketRpGrpMappingStore(pim
   MCAST_GET_BYTE(bsrHashMaskLen,pData);
   MCAST_GET_BYTE(bsrPriority,pData);
   MCAST_UNUSED_PARAM (bsrPriority); /* NOTE: TBD: Looks like bsrPriority processing is not implemented. */
   PIM_GET_EUADDR_INET( &encodBsrAddr,pData);
   inetAddressSet(encodBsrAddr.addr_family,&encodBsrAddr.addr,&bsrAddr);
 
-  while (((L7_uint32)pData - (L7_uint32)pimHeader) < pimPktLen)
+  while (((L7_uint32) (PTR_TO_UINT64(pData) - PTR_TO_UINT64(pimHeader))) < pimPktLen)
   {
     L7_uint32 count;
     pimsmBSMMsgGrpNode_t    grpNode;
 
     /* get each of the group address */
     len = pimsmBsrPacketGrpInfoExtract(pData,&grpNode);
@@ -1385,13 +1385,13 @@ void pimsmBsrPacketRpGrpMappingStore(pim
 
     /* check if the fragment contains all the rp's */
     if (grpNode.pimsmRpCnt == grpNode.pimsmFragRpCnt)
     {
       count=0 ;
       while (count < grpNode.pimsmFragRpCnt && 
-             ((L7_uint32)pData - (L7_uint32)pimHeader) < pimPktLen)
+             ((L7_uint32) (PTR_TO_UINT64(pData) - PTR_TO_UINT64(pimHeader))) < pimPktLen)
       {
         pimsmBSMMsgRpNode_t   bsrRpNode;
         pimsmCandRpConfigInfo_t   rpConfigInfo;
 
         len = pimsmBsrPacketRpInfoExtract(pData,&bsrRpNode);
         pData +=len;
@@ -1762,13 +1762,13 @@ void pimsmBsrPacketOriginate(pimsmCB_t
   MCAST_PUT_BYTE(pBsrNode->pimsmBSRPriority, pDataTemp);
 
   /* fillup the BSR address in encoded unicast format*/
   PIM_PUT_EUADDR_INET(&pBsrNode->pimsmBSRAddr, pDataTemp);
 
   /* calculate the header offset */
-  bsrHeaderOffset = (L7_uint32)pData - (L7_uint32)pDataTemp;
+  bsrHeaderOffset = (L7_uint32) (PTR_TO_UINT64(pData) - PTR_TO_UINT64(pDataTemp));
 
   inetMaskLenToMask(pimsmCb->family,(L7_uchar8)pBsrNode->pimsmBSRGroupMask,
                     &bsrGrpMask);
 
   rc = pimsmRpSetTreeGrpNodeFind(pimsmCb,pBsrNode->pimsmBSRGroupRange,
                                  bsrGrpMask,&pRpSetNode);
@@ -1853,13 +1853,13 @@ void pimsmBsrPacketOriginate(pimsmCB_t
             if (pRpNode->pimsmOrigin == PIMSM_RP_GRP_MAPPING_ORIGIN_TYPE_CONFIG ||
                 pRpNode->pimsmOrigin == PIMSM_RP_GRP_MAPPING_ORIGIN_TYPE_BSR)
             {
               pimsmRpGrpNode_t     *pRpGrpNode;
               pRpGrpNode = (pimsmRpGrpNode_t*)pRpNode->pimsmRpGrpNode;
 
-              dataLen = (L7_uint32)pDataTemp - (L7_uint32)pData;
+              dataLen = (L7_uint32) (PTR_TO_UINT64(pDataTemp) - PTR_TO_UINT64(pData));
               /* fill the rp details */
               if (dataLen < PIMSM_PKT_SIZE_MAX)
               {
                 PIM_PUT_EUADDR_INET(&(pRpGrpNode->pimsmRpAddr), pDataTemp);
                 fragRpCnt++;
                 MCAST_PUT_SHORT(pRpGrpNode->pimsmRpHoldTime, pDataTemp);
@@ -1903,13 +1903,13 @@ void pimsmBsrPacketOriginate(pimsmCB_t
 
     if (pRpSetNode == L7_NULLPTR)
     {
       noMoreInfo = L7_FALSE;
     }
 
-    dataLen = (L7_uint32)pDataTemp - (L7_uint32)pData;
+    dataLen = (L7_uint32) (PTR_TO_UINT64(pDataTemp) - PTR_TO_UINT64(pData));
     /* send the packet */
     if (rtrIfNum == 0)
     {
       pimsmBsrPacketInterfaceSend(pimsmCb, pBsrNode, pData, dataLen);
     }
     else
@@ -2240,13 +2240,13 @@ L7_RC_t pimsmBsrCandRpAdvRecv(pimsmCB_t
   pData = (L7_uchar8*)(pimHeader + PIM_HEARDER_SIZE);
 
   /* Parse the CRP message */
   MCAST_GET_BYTE(prefixCount,pData);
   MCAST_GET_BYTE(rpPriority,pData);
   MCAST_GET_SHORT(rpHoldtime,pData);
-  dataLen = (L7_uint32)pData - (L7_uint32)pimHeader;
+  dataLen = (L7_uint32) (PTR_TO_UINT64(pData) - PTR_TO_UINT64(pimHeader));
 
   if (pimPktLen <= dataLen)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_BSR, PIMSM_TRACE_ERROR,
                 "data pkt length for CRP Adverisement is less than expected ");
     return L7_FAILURE;
Index: src/application/ip_mcast/vendor/pimsm/pimsmupstrmsgfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmupstrmsgfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmupstrmsgfsm.c	(revision 7778)
@@ -273,13 +273,13 @@ static L7_RC_t  pimsmUpStrmSGJoinSend(pi
   pTimerData = &pSGEntry->pimsmSGUpstreamJoinTimerParam ;
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGUpstreamJoinTimerExpiresHandler,
-                            (void*)pSGEntry->pimsmSGUpstreamJoinTimerHandle,
+                            UINT_TO_PTR(pSGEntry->pimsmSGUpstreamJoinTimerHandle),
                             jpInterval,
                             &(pSGEntry->pimsmSGUpstreamJoinTimer),
                             "SG-JT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G,PIMSM_TRACE_ERROR, "Failed to add (S,G) upstrm join timer");
@@ -433,13 +433,13 @@ static L7_RC_t  pimsmUpStrmSGJoinTimerIn
     pTimerData = &pSGEntry->pimsmSGUpstreamJoinTimerParam;
     memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
     inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
     inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
     pTimerData->pimsmCb = pimsmCb;
     if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGUpstreamJoinTimerExpiresHandler,
-                              (void*)pSGEntry->pimsmSGUpstreamJoinTimerHandle,
+                              UINT_TO_PTR(pSGEntry->pimsmSGUpstreamJoinTimerHandle),
                               joinSuppress,
                               &(pSGEntry->pimsmSGUpstreamJoinTimer),
                               "SG-JT2")
                            != L7_SUCCESS)
     {
       PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G,PIMSM_TRACE_ERROR, "Failed to update (S,G) upstrm join timer");
@@ -496,13 +496,13 @@ static L7_RC_t  pimsmUpStrmSGJoinTimerDe
     pTimerData = &pSGEntry->pimsmSGUpstreamJoinTimerParam;
     memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
     inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
     inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
     pTimerData->pimsmCb = pimsmCb;
     if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGUpstreamJoinTimerExpiresHandler,
-                              (void*)pSGEntry->pimsmSGUpstreamJoinTimerHandle,
+                              UINT_TO_PTR(pSGEntry->pimsmSGUpstreamJoinTimerHandle),
                               joinPruneOverrideInterval,
                               &(pSGEntry->pimsmSGUpstreamJoinTimer),
                               "SG-JT3")
                            != L7_SUCCESS)
     {
       PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G,PIMSM_TRACE_ERROR, "Failed to update (S,G) upstrm join timer");
@@ -638,13 +638,13 @@ static L7_RC_t  pimsmUpStrmSGJoinPruneSe
   pTimerData = &pSGEntry->pimsmSGUpstreamJoinTimerParam;
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGUpstreamJoinTimerExpiresHandler,
-                            (void*)pSGEntry->pimsmSGUpstreamJoinTimerHandle,
+                            UINT_TO_PTR(pSGEntry->pimsmSGUpstreamJoinTimerHandle),
                             jpInterval,
                             &(pSGEntry->pimsmSGUpstreamJoinTimer),
                             "SG-JT4")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G,PIMSM_TRACE_ERROR, "Failed to add (S,G) upstrm join timer");
@@ -689,14 +689,14 @@ static L7_RC_t pimsmUpStrmSGErrorReturn(
 * @end
 ******************************************************************************/
 static void pimsmSGUpstreamJoinTimerExpiresHandler(void *pParam)
 {
   pimsmUpStrmSGEventInfo_t upStrmSGEventInfo;
   pimsmSGNode_t *pSGNode;
-  pimsmCB_t   * pimsmCb;
-  L7_int32      handle = (L7_int32)pParam;
+  pimsmCB_t     *pimsmCb;
+  L7_uint64      handle = PTR_TO_UINT64(pParam);
   L7_inet_addr_t *pGrpAddr, *pSrcAddr;
   pimsmTimerData_t *pTimerData;
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
   {
@@ -752,15 +752,15 @@ void pimsmSGKeepaliveTimerExpiresHandler
   pimsmSGNode_t *pSGNode;
   L7_BOOL        rc;
   L7_RC_t        rc2;
   pimsmPerSGRegisterEventInfo_t perSGRegisterEventInfo;
   pimsmUpStrmSGEventInfo_t upStrmSGEventInfo;
   L7_BOOL joinDesired;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64        handle = PTR_TO_UINT64(pParam);
   pimsmTimerData_t *pTimerData ;
-  pimsmSGEntry_t  *pSGEntry;
+  pimsmSGEntry_t   *pSGEntry;
   pimsmCB_t * pimsmCb;
   L7_inet_addr_t  rpAddr;
   mfcEntry_t mfcEntry;
   L7_inet_addr_t *pGrpAddr, *pSrcAddr;
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
@@ -798,13 +798,13 @@ void pimsmSGKeepaliveTimerExpiresHandler
 
   if (mfcIsEntryInUse(&mfcEntry) == L7_TRUE)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G, PIMSM_TRACE_INFO, "MFC Entry is active" );
 
     if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGKeepaliveTimerExpiresHandler,
-                              (void*) pSGNode->pimsmSGEntry.pimsmSGKeepaliveTimerHandle,
+                              UINT_TO_PTR(pSGNode->pimsmSGEntry.pimsmSGKeepaliveTimerHandle),
                               PIMSM_DEFAULT_KEEPALIVE_PERIOD,
                               &(pSGNode->pimsmSGEntry.pimsmSGKeepaliveTimer),
                               "SM-KAT3")
                            != L7_SUCCESS)
     {
       PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G,PIMSM_TRACE_ERROR,"Failed to add (S,G)KeepaliveTimer ");
Index: src/application/ip_mcast/vendor/pimsm/include/pimsmstarstarrptree.h
===================================================================
--- src/application/ip_mcast/vendor/pimsm/include/pimsmstarstarrptree.h	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/include/pimsmstarstarrptree.h	(revision 7778)
@@ -28,43 +28,43 @@
 #include "pimsmcache.h"
 #include "pimsmdefs.h"
 #include "pimsmtimer.h"
 
 typedef struct pimsmStarStarRpEntry_s
 {
-  L7_inet_addr_t pimsmStarStarRpRPAddress;
+  L7_inet_addr_t    pimsmStarStarRpRPAddress;
   PIMSM_RP_GRP_MAPPING_ORIGIN_TYPE pimsmStarStarRpRPOrigin;
-  L7_uint32      pimsmStarStarRpCreateTime;
-  pimMode_t      pimsmStarStarRpPimMode;
+  L7_uint32         pimsmStarStarRpCreateTime;
+  pimMode_t         pimsmStarStarRpPimMode;
   pimsmUpStrmStarStarRPStates_t pimsmStarStarRpUpstreamJoinState;
-  L7_APP_TMR_HNDL_t      pimsmStarStarRpUpstreamJoinTimer;
-  L7_uint32      pimsmStarStarRpUpstreamJoinTimerHandle;
-  pimsmTimerData_t pimsmStarStarRpUpstreamJoinTimerParam;    
-  L7_inet_addr_t pimsmStarStarRpUpstreamNeighbor;
-  L7_uint32      pimsmStarStarRpRPFIfIndex;
-  L7_inet_addr_t pimsmStarStarRpRPFNextHop;
+  L7_APP_TMR_HNDL_t pimsmStarStarRpUpstreamJoinTimer;
+  L7_uint64         pimsmStarStarRpUpstreamJoinTimerHandle;
+  pimsmTimerData_t  pimsmStarStarRpUpstreamJoinTimerParam;    
+  L7_inet_addr_t    pimsmStarStarRpUpstreamNeighbor;
+  L7_uint32         pimsmStarStarRpRPFIfIndex;
+  L7_inet_addr_t    pimsmStarStarRpRPFNextHop;
   L7_RTO_PROTOCOL_INDICES_t pimsmStarStarRpRPFRouteProtocol;
-  L7_inet_addr_t pimsmStarStarRpRPFRouteAddress;
-  L7_uint32       pimsmStarStarRpRPFRoutePrefixLength;
-  L7_uint32      pimsmStarStarRpRPFRouteMetricPref;
-  L7_uint32      pimsmStarStarRpRPFRouteMetric;
-  L7_short16     flags;
+  L7_inet_addr_t    pimsmStarStarRpRPFRouteAddress;
+  L7_uint32         pimsmStarStarRpRPFRoutePrefixLength;
+  L7_uint32         pimsmStarStarRpRPFRouteMetricPref;
+  L7_uint32         pimsmStarStarRpRPFRouteMetric;
+  L7_short16        flags;
   interface_bitset_t  immediateOlist;
 } pimsmStarStarRpEntry_t;
 
 typedef struct pimsmStarStarRpIEntry_s
 {
-  L7_uint32   pimsmStarStarRpIIfIndex;
-  L7_uint32      pimsmStarStarRpICreateTime;
+  L7_uint32         pimsmStarStarRpIIfIndex;
+  L7_uint32         pimsmStarStarRpICreateTime;
 /*  L7_BOOL             pimsmStarStarRpILocalMembership; */
   pimsmDnStrmPerIntfStarStarRPStates_t      pimsmStarStarRpIJoinPruneState;
-  L7_APP_TMR_HNDL_t       pimsmStarStarRpIPrunePendingTimer;
-  L7_uint32      pimsmStarStarRpIPrunePendingTimerHandle;    
-  pimsmTimerData_t pimsmStarStarRpIPrunePendingTimerParam;   
-  L7_APP_TMR_HNDL_t       pimsmStarStarRpIJoinExpiryTimer;
-  L7_uint32      pimsmStarStarRpIJoinExpiryTimerHandle;    
+  L7_APP_TMR_HNDL_t pimsmStarStarRpIPrunePendingTimer;
+  L7_uint64         pimsmStarStarRpIPrunePendingTimerHandle;    
+  pimsmTimerData_t  pimsmStarStarRpIPrunePendingTimerParam;   
+  L7_APP_TMR_HNDL_t pimsmStarStarRpIJoinExpiryTimer;
+  L7_uint64         pimsmStarStarRpIJoinExpiryTimerHandle;    
   pimsmTimerData_t pimsmStarStarRpIJoinExpiryTimerParam;    
 } pimsmStarStarRpIEntry_t;
 
 /* Following data struct and APIs represents data and operations on Tree-A */
 
 typedef struct pimsmStarStarRpNode_s 
Index: src/application/ip_mcast/vendor/pimsm/include/pimsmbsr.h
===================================================================
--- src/application/ip_mcast/vendor/pimsm/include/pimsmbsr.h	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/include/pimsmbsr.h	(revision 7778)
@@ -93,13 +93,13 @@ typedef struct pimsmBsrPerScopeZone_s
   L7_uchar8            pimsmBSRGroupMask;    
   L7_inet_addr_t       pimsmBSRAddr; /* ipaddr of the bsr */
   L7_uint32            pimsmBSRPriority; 
   L7_ushort16          pimsmBSRHashMasklen; 
   pimsmBSMPacketNode_t pimsmLastBSMPktNode[PIMSM_BSM_PKT_FRAGMENT_COUNT_MAX];
   L7_APP_TMR_HNDL_t    pimsmBSRTimer;    /* the bootstrap timer */
-  L7_uint32            pimsmBSRTimerHandle; /* to safeguard timeout functions */
+  L7_uint64            pimsmBSRTimerHandle; /* to safeguard timeout functions */
   L7_uint32            ctime;        /* creation time */
   pimsmBsrFragmentInfo_t pimsmBSRFragInfo;
 
   union 
   {
     struct 
Index: src/application/ip_mcast/vendor/pimsm/include/pimsmstargtree.h
===================================================================
--- src/application/ip_mcast/vendor/pimsm/include/pimsmstargtree.h	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/include/pimsmstargtree.h	(revision 7778)
@@ -32,50 +32,50 @@
 #include "pimsmtimer.h"
 
 
 typedef struct pimsmStarGEntry_s
 {
   L7_inet_addr_t    pimsmStarGGrpAddress;
-  L7_uint32       pimsmStarGCreateTime;
-  pimMode_t       pimsmStarGPimMode;
+  L7_uint32         pimsmStarGCreateTime;
+  pimMode_t         pimsmStarGPimMode;
   L7_inet_addr_t    pimsmStarGRPAddress;
   PIMSM_RP_GRP_MAPPING_ORIGIN_TYPE pimsmStarGRPOrigin;
-  L7_BOOL       pimsmStarGRPIsLocal;
+  L7_BOOL           pimsmStarGRPIsLocal;
   pimsmUpStrmStarGStates_t pimsmStarGUpstreamJoinState;
   L7_APP_TMR_HNDL_t pimsmStarGUpstreamJoinTimer;
-  L7_uint32 pimsmStarGUpstreamJoinTimerHandle;
-  pimsmTimerData_t        pimsmStarGUpstreamJoinTimerParam;
+  L7_uint64         pimsmStarGUpstreamJoinTimerHandle;
+  pimsmTimerData_t  pimsmStarGUpstreamJoinTimerParam;
   L7_inet_addr_t    pimsmStarGUpstreamNeighbor;
-  L7_uint32       pimsmStarGRPFIfIndex;
+  L7_uint32         pimsmStarGRPFIfIndex;
   L7_inet_addr_t    pimsmStarGRPFNextHop;
   L7_RTO_PROTOCOL_INDICES_t pimsmStarGRPFRouteProtocol;
   L7_inet_addr_t    pimsmStarGRPFRouteAddress;
-  L7_uint32       pimsmStarGRPFRoutePrefixLength;
-  L7_uint32       pimsmStarGRPFRouteMetricPref;
-  L7_uint32       pimsmStarGRPFRouteMetric;
+  L7_uint32         pimsmStarGRPFRoutePrefixLength;
+  L7_uint32         pimsmStarGRPFRouteMetricPref;
+  L7_uint32         pimsmStarGRPFRouteMetric;
 } pimsmStarGEntry_t;
 
 typedef struct pimsmStarGIEntry_s
 {
-  L7_uint32     pimsmStarGIIfIndex;
-  L7_uint32       pimsmStarGICreateTime;  
-  L7_BOOL       pimsmStarGILocalMembership;
+  L7_uint32         pimsmStarGIIfIndex;
+  L7_uint32         pimsmStarGICreateTime;  
+  L7_BOOL           pimsmStarGILocalMembership;
   pimsmDnStrmPerIntfStarGStates_t     pimsmStarGIJoinPruneState;
   L7_APP_TMR_HNDL_t pimsmStarGIPrunePendingTimer;
-  L7_uint32 pimsmStarGIPrunePendingTimerHandle;
+  L7_uint64         pimsmStarGIPrunePendingTimerHandle;
   pimsmTimerData_t  pimsmStarGIPrunePendingTimerParam;
   L7_APP_TMR_HNDL_t pimsmStarGIJoinExpiryTimer;
-  L7_uint32 pimsmStarGIJoinExpiryTimerHandle;
-  pimsmTimerData_t pimsmStarGIJoinExpiryTimerParam;
+  L7_uint64         pimsmStarGIJoinExpiryTimerHandle;
+  pimsmTimerData_t  pimsmStarGIJoinExpiryTimerParam;
   pimsmPerIntfStarGAssertStates_t       pimsmStarGIAssertState;
   L7_APP_TMR_HNDL_t pimsmStarGIAssertTimer;
-  L7_uint32 pimsmStarGIAssertTimerHandle;   
-  pimsmTimerData_t pimsmStarGIAssertTimerParam;
+  L7_uint64         pimsmStarGIAssertTimerHandle;   
+  pimsmTimerData_t  pimsmStarGIAssertTimerParam;
   L7_inet_addr_t    pimsmStarGIAssertWinnerAddress;
-  L7_uint32       pimsmStarGIAssertWinnerMetricPref;
-  L7_uint32       pimsmStarGIAssertWinnerMetric;
+  L7_uint32         pimsmStarGIAssertWinnerMetricPref;
+  L7_uint32         pimsmStarGIAssertWinnerMetric;
 } pimsmStarGIEntry_t;
 
 /* Following data struct and APIs represents data and operations on Tree-B */
 
 typedef struct pimsmStarGNode_s
 {
Index: src/application/ip_mcast/vendor/pimsm/include/pimsmsgtree.h
===================================================================
--- src/application/ip_mcast/vendor/pimsm/include/pimsmsgtree.h	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/include/pimsmsgtree.h	(revision 7778)
@@ -40,53 +40,53 @@ typedef struct pimsmSGEntry_s
   L7_inet_addr_t  pimsmSGSrcAddress;
   L7_uint32       pimsmSGCreateTime;
   pimMode_t       pimsmSGPimMode;
   pimsmUpStrmSGStates_t 
   pimsmSGUpstreamJoinState;
   L7_APP_TMR_HNDL_t pimsmSGUpstreamJoinTimer;
-  L7_uint32  pimsmSGUpstreamJoinTimerHandle;
+  L7_uint64         pimsmSGUpstreamJoinTimerHandle;
   pimsmTimerData_t  pimsmSGUpstreamJoinTimerParam;
   L7_inet_addr_t    pimsmSGUpstreamNeighbor;
-  L7_uint32     pimsmSGRPFIfIndex;
+  L7_uint32         pimsmSGRPFIfIndex;
   L7_inet_addr_t    pimsmSGRPFNextHop;
   L7_RTO_PROTOCOL_INDICES_t     
   pimsmSGRPFRouteProtocol;
   L7_inet_addr_t    pimsmSGRPFRouteAddress;
   L7_uint32     pimsmSGRPFRoutePrefixLength;   
   L7_uint32     pimsmSGRPFRouteMetricPref;
   L7_uint32     pimsmSGRPFRouteMetric;
   L7_BOOL       pimsmSGSPTBit;
   L7_APP_TMR_HNDL_t pimsmSGKeepaliveTimer;
-  pimsmTimerData_t pimsmSGKeepaliveTimerParam;
-  L7_uint32 pimsmSGKeepaliveTimerHandle;
+  pimsmTimerData_t  pimsmSGKeepaliveTimerParam;
+  L7_uint64         pimsmSGKeepaliveTimerHandle;
   pimsmRegPerSGStates_t    
   pimsmSGDRRegisterState;
   L7_APP_TMR_HNDL_t pimsmSGDRRegisterStopTimer;
-  pimsmTimerData_t pimsmSGDRRegisterStopTimerParam; 
-  L7_uint32  pimsmSGDRRegisterStopTimerHandle;
+  pimsmTimerData_t  pimsmSGDRRegisterStopTimerParam; 
+  L7_uint64         pimsmSGDRRegisterStopTimerHandle;
   L7_inet_addr_t    pimsmSGRPRegisterPMBRAddress;
 } pimsmSGEntry_t;
 
 typedef struct pimsmSGIEntry_s
 {
   L7_uint32     pimsmSGIIfIndex;
   L7_uint32       pimsmSGICreateTime;
   L7_BOOL       pimsmSGILocalMembership;
   pimsmDnStrmPerIntfSGStates_t    
   pimsmSGIJoinPruneState;
   L7_APP_TMR_HNDL_t pimsmSGIPrunePendingTimer;
-  L7_uint32  pimsmSGIPrunePendingTimerHandle;   
-  pimsmTimerData_t pimsmSGIPrunePendingTimerParam;  
+  L7_uint64         pimsmSGIPrunePendingTimerHandle;   
+  pimsmTimerData_t  pimsmSGIPrunePendingTimerParam;  
   L7_APP_TMR_HNDL_t pimsmSGIJoinExpiryTimer;
-  L7_uint32  pimsmSGIJoinExpiryTimerHandle;
+  L7_uint64         pimsmSGIJoinExpiryTimerHandle;
   pimsmTimerData_t pimsmSGIJoinExpiryTimerParam;  
   pimsmPerIntfSGAssertStates_t      
   pimsmSGIAssertState;
   L7_APP_TMR_HNDL_t pimsmSGIAssertTimer;
-  L7_uint32 pimsmSGIAssertTimerHandle;
-  pimsmTimerData_t pimsmSGIAssertTimerParam;  
+  L7_uint64         pimsmSGIAssertTimerHandle;
+  pimsmTimerData_t  pimsmSGIAssertTimerParam;  
   L7_inet_addr_t    pimsmSGIAssertWinnerAddress;
   L7_uint32     pimsmSGIAssertWinnerMetricPref;
   L7_uint32     pimsmSGIAssertWinnerMetric;
 } pimsmSGIEntry_t;
 
 typedef struct pimsmSGNode_s 
Index: src/application/ip_mcast/vendor/pimsm/include/pimsmneighbor.h
===================================================================
--- src/application/ip_mcast/vendor/pimsm/include/pimsmneighbor.h	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/include/pimsmneighbor.h	(revision 7778)
@@ -62,21 +62,21 @@ typedef struct pimsmNeighborAddrList_s
   L7_BOOL  pimsmSecondaryAddrActive[PIMSM_MAX_NBR_SECONDARY_ADDR];
 }pimsmNeighborAddrList_t;
 
 typedef struct pimsmNeighborEntry_s
 {
   L7_sll_member_t * next;
-  L7_uint32   pimsmNeighborIfIndex;
+  L7_uint32     pimsmNeighborIfIndex;
   pimsmNeighborAddrList_t pimsmNeighborAddrList;
   /*L7_uint32      pimsmNeighborUpTime;*/
-  L7_uint32   pimsmNeighborCreateTime;
+  L7_uint32     pimsmNeighborCreateTime;
   L7_APP_TMR_HNDL_t pimsmNeighborExpiryTimer;
-  L7_uint32 pimsmNeighborExpiryTimerHandle;
+  L7_uint64     pimsmNeighborExpiryTimerHandle;
   pimsmTimerData_t  pimsmNeighborExpiryTimerParam;
-  L7_uint32   pimsmNeighborGenerationIDValue;
-  L7_uint32   pimsmNeighborDRPriority;    
+  L7_uint32     pimsmNeighborGenerationIDValue;
+  L7_uint32     pimsmNeighborDRPriority;    
   pimsmJPMsgStoreBuff_t pimsmBuildJPMsg; /* A structure for fairly
                      * complicated Join/Prune
                      * message construction.
                      */
   L7_BOOL     pimsmNeighborLANPruneDelayPresent;                     
   L7_BOOL     pimsmNeighborTrackingSupportPresent;  
Index: src/application/ip_mcast/vendor/pimsm/include/pimsmintf.h
===================================================================
--- src/application/ip_mcast/vendor/pimsm/include/pimsmintf.h	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/include/pimsmintf.h	(revision 7778)
@@ -77,15 +77,15 @@ typedef struct pimsmInterfaceEntry_s
   L7_uint32     pimsmInterfaceJoinPruneHoldtime;
   L7_sll_t        pimsmNbrList;
   L7_uint32     pimsmNbrCount;
   L7_BOOL       pimsmLANPruneDelayPresent;
   L7_uint32     pimsmPropagationDelay;
   L7_uint32     pimsmOverrideInterval;
-  L7_APP_TMR_HNDL_t  pimsmHelloTimer;
-  pimsmTimerData_t   pimsmHelloTimerParams;
-  L7_uint32  pimsmHelloTimerHandle;   
+  L7_APP_TMR_HNDL_t pimsmHelloTimer;
+  pimsmTimerData_t  pimsmHelloTimerParams;
+  L7_uint64         pimsmHelloTimerHandle;   
 }pimsmInterfaceEntry_t;
 
 
 struct pimsmNeighborEntry_s;
 struct pimsmCB_s;
 
Index: src/application/ip_mcast/vendor/pimsm/include/pimsmsgrpttree.h
===================================================================
--- src/application/ip_mcast/vendor/pimsm/include/pimsmsgrpttree.h	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/include/pimsmsgrpttree.h	(revision 7778)
@@ -35,35 +35,35 @@ struct pimsmCB_s;
 
 typedef struct pimsmSGRptEntry_s
 {
   L7_inet_addr_t  pimsmSGRptGrpAddress;
   L7_inet_addr_t  pimsmSGRptSrcAddress;
   L7_uint32     pimsmSGRptCreateTime;
-  pimsmUpStrmSGRptStates_t pimsmSGRptUpstreamPruneInitState; 
+  pimsmUpStrmSGRptStates_t  pimsmSGRptUpstreamPruneInitState; 
       /* used to initialize pimsmSGRptUpstreamPruneState */
-  pimsmUpStrmSGRptStates_t pimsmSGRptUpstreamPruneState; 
-  L7_APP_TMR_HNDL_t   pimsmSGRptUpstreamOverrideTimer;
-  L7_uint32   pimsmSGRptUpstreamOverrideTimerHandle;
-  pimsmTimerData_t pimsmSGRptUpstreamOverrideTimerParam; 
-  L7_uint32   pimsmSGRptRPFIfIndex; /* = RPF_interface(RP(G))*/
-  L7_inet_addr_t    pimsmSGRptUpstreamNeighbor;   /*RPFDash */
+  pimsmUpStrmSGRptStates_t  pimsmSGRptUpstreamPruneState; 
+  L7_APP_TMR_HNDL_t         pimsmSGRptUpstreamOverrideTimer;
+  L7_uint64                 pimsmSGRptUpstreamOverrideTimerHandle;
+  pimsmTimerData_t          pimsmSGRptUpstreamOverrideTimerParam; 
+  L7_uint32                 pimsmSGRptRPFIfIndex; /* = RPF_interface(RP(G))*/
+  L7_inet_addr_t            pimsmSGRptUpstreamNeighbor;   /*RPFDash */
 } pimsmSGRptEntry_t;
 
 typedef struct pimsmSGRptIEntry_s
 {
   /*L7_ushort16         flags;*/
-  L7_uint32           pimsmSGRptIIfIndex;
-  L7_uint32     pimsmSGRptICreateTime;
-  L7_BOOL           pimsmSGRptILocalMembership;
+  L7_uint32                 pimsmSGRptIIfIndex;
+  L7_uint32                 pimsmSGRptICreateTime;
+  L7_BOOL                   pimsmSGRptILocalMembership;
   pimsmDnStrmPerIntfSGRptStates_t     pimsmSGRptIJoinPruneState;
-  L7_APP_TMR_HNDL_t       pimsmSGRptIPrunePendingTimer;
-  L7_uint32   pimsmSGRptIPrunePendingTimerHandle;   
-  pimsmTimerData_t pimsmSGRptIPrunePendingTimerParam; 
-  L7_APP_TMR_HNDL_t       pimsmSGRptIPruneExpiryTimer;
-  L7_uint32   pimsmSGRptIPruneExpiryTimerHandle;      
-  pimsmTimerData_t pimsmSGRptIPruneExpiryTimerParam;
+  L7_APP_TMR_HNDL_t         pimsmSGRptIPrunePendingTimer;
+  L7_uint64                 pimsmSGRptIPrunePendingTimerHandle;   
+  pimsmTimerData_t          pimsmSGRptIPrunePendingTimerParam; 
+  L7_APP_TMR_HNDL_t         pimsmSGRptIPruneExpiryTimer;
+  L7_uint64                 pimsmSGRptIPruneExpiryTimerHandle;
+  pimsmTimerData_t          pimsmSGRptIPruneExpiryTimerParam;
 } pimsmSGRptIEntry_t;
 typedef struct pimsmSGRptNode_s
 {
   L7_ushort16     flags;  /*Uses flags PIMSM_XXX*/
   pimsmSGRptEntry_t   pimsmSGRptEntry;
   pimsmSGRptIEntry_t * pimsmSGRptIEntry[MCAST_MAX_INTERFACES]; 
Index: src/application/ip_mcast/vendor/pimsm/include/pimsmrp.h
===================================================================
--- src/application/ip_mcast/vendor/pimsm/include/pimsmrp.h	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/include/pimsmrp.h	(revision 7778)
@@ -60,13 +60,13 @@ typedef struct pimsmAddrList_s
   L7_uchar8          pimsmMaskLen;     /* used by group-rp mapping */
   L7_APP_TMR_HNDL_t  pimsmRpGrpExpiryTimer;  /* used by the rp-grp mapping */
   L7_uint32          pimsmAddrListPoolId;  
   L7_BOOL            pimsmOriginFlag;  /* used when originating BSMs,if there is RP with more than one origin */
   void              *pimsmRpGrpNode; /* this is used as pointer to rp details for the grp-rp mapping to get rp details 
                                  this is to point to the bsr when candidate rp advertisement needs to be done */    
-  L7_uint32          pimsmRpGrpExpireTimerHandle; /* This is used to keep track of not deleting 
+  L7_uint64          pimsmRpGrpExpireTimerHandle; /* This is used to keep track of not deleting 
                                                the node when giving this pointer to timeout functions */
   pimsmCB_t     *pimsmCb;  /* pointer to back track*/
 }pimsmAddrList_t;
 
 
 /*This structure is used to store the RP information -it also contains the rp-grp mapping*/
Index: src/application/ip_mcast/vendor/pimsm/include/pimsmmain.h
===================================================================
--- src/application/ip_mcast/vendor/pimsm/include/pimsmmain.h	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/include/pimsmmain.h	(revision 7778)
@@ -54,17 +54,17 @@ struct pimsmTimerData_s;
 
 typedef struct pimsmCB_s
 {
   struct pimsmBSRBlock_s   *pimsmBsrInfo; /* BSR info. */
   struct pimsmRpBlock_s    *pimsmRpInfo;  /* node type is pimsm_rp_block_t   */ 
 
-  L7_APP_TMR_HNDL_t          pimsmSPTTimer;
-  L7_uint32          pimsmSPTTimerHandle;
-  struct pimsmTimerData_s        pimsmSPTTimerParam; 
-  L7_APP_TMR_HNDL_t          pimsmJPBundleTimer;
-  L7_uint32          pimsmJPBundleTimerHandle;    
+  L7_APP_TMR_HNDL_t         pimsmSPTTimer;
+  L7_uint64                 pimsmSPTTimerHandle;
+  struct pimsmTimerData_s   pimsmSPTTimerParam; 
+  L7_APP_TMR_HNDL_t         pimsmJPBundleTimer;
+  L7_uint64                 pimsmJPBundleTimerHandle;    
   struct pimsmTimerData_s           pimsmJPBundleTimerParam; 
   L7_sll_t             pimsmStarStarRpList;
   /* Semaphore to lock StarStarRpList*/
   void       *pimsmStarStarRpListLock;
   avlTreeTables_t        *pimsmStarGTreeHeap; /* space for tree nodes */
   struct pimsmStarGNode_s    *pimsmStarGDataHeap; /* space for data */
Index: src/application/ip_mcast/vendor/pimsm/pimsmdnstrmsgrptfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmdnstrmsgrptfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmdnstrmsgrptfsm.c	(revision 7778)
@@ -273,13 +273,13 @@ static L7_RC_t pimsmDnStrmPerIntfSGRptPr
   inetCopy(&pTimerData->addr1, &pSGRptNode->pimsmSGRptEntry.pimsmSGRptSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGRptNode->pimsmSGRptEntry.pimsmSGRptGrpAddress);
   pTimerData->pimsmCb = pimsmCb;
 
   PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G_RPT, PIMSM_TRACE_INFO,"Adding Expire timer ");
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGRptIPruneExpireTimerExpiresHandler,
-                            (void*)pSGRptIEntry ->pimsmSGRptIPruneExpiryTimerHandle,
+                            UINT_TO_PTR(pSGRptIEntry ->pimsmSGRptIPruneExpiryTimerHandle),
                             holdtime,
                             &(pSGRptIEntry->pimsmSGRptIPruneExpiryTimer),
                             "SGr-PT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G_RPT, PIMSM_TRACE_ERROR,
@@ -304,13 +304,13 @@ static L7_RC_t pimsmDnStrmPerIntfSGRptPr
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   pTimerData->rtrIfNum = rtrIfNum;
   inetCopy(&pTimerData->addr1, &pSGRptNode->pimsmSGRptEntry.pimsmSGRptSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGRptNode->pimsmSGRptEntry.pimsmSGRptGrpAddress);
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGRptIPrunePendingTimerExpiresHandler,
-                            (void*)pSGRptIEntry ->pimsmSGRptIPrunePendingTimerHandle,
+                            UINT_TO_PTR(pSGRptIEntry ->pimsmSGRptIPrunePendingTimerHandle),
                             timeOut,
                             &(pSGRptIEntry ->pimsmSGRptIPrunePendingTimer),
                             "SGr-PPT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G_RPT, PIMSM_TRACE_ERROR,
@@ -376,13 +376,13 @@ static L7_RC_t pimsmDnStrmPerIntfSGRptPr
   pTimerData->rtrIfNum = rtrIfNum;
   inetCopy(&pTimerData->addr1, &pSGRptNode->pimsmSGRptEntry.pimsmSGRptSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGRptNode->pimsmSGRptEntry.pimsmSGRptGrpAddress);
   pTimerData->pimsmCb = pimsmCb;
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGRptIPruneExpireTimerExpiresHandler,
-                            (void*)pSGRptIEntry ->pimsmSGRptIPruneExpiryTimerHandle,
+                            UINT_TO_PTR(pSGRptIEntry ->pimsmSGRptIPruneExpiryTimerHandle),
                             holdtime,
                             &(pSGRptIEntry->pimsmSGRptIPruneExpiryTimer),
                             "SGr-PT2")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_S_G_RPT, PIMSM_TRACE_ERROR,
@@ -455,13 +455,13 @@ static void pimsmSGRptIPrunePendingTimer
   pimsmDnStrmPerIntfSGRptEventInfo_t pDnStrmPerIntfSGRptEventInfo;
   pimsmSGRptNode_t   *pSGRptNode;
   pimsmSGRptIEntry_t *pSGRptIEntry= L7_NULLPTR;
   L7_uint32           rtrIfNum;
   pimsmTimerData_t   *pTimerData;
   pimsmCB_t          *pimsmCb;
-  L7_int32            handle = (L7_int32)pParam;
+  L7_uint64           handle = PTR_TO_UINT64(pParam);
   pimsmUpStrmSGRptEventInfo_t upStrmSGRptEventInfo;
   L7_BOOL pruneDesired;
   L7_inet_addr_t *pGrpAddr, *pSrcAddr;
   pimsmStarGNode_t * pStarGNode;
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
@@ -550,13 +550,13 @@ static void  pimsmSGRptIPruneExpireTimer
   pimsmDnStrmPerIntfSGRptEventInfo_t pDnStrmPerIntfSGRptEventInfo;
   pimsmSGRptNode_t    *pSGRptNode;
   pimsmSGRptIEntry_t  *pSGRptIEntry= L7_NULLPTR;
   L7_uint32            rtrIfNum;
   pimsmTimerData_t    *pTimerData;
   pimsmCB_t           *pimsmCb;
-  L7_int32             handle = (L7_int32)pParam;
+  L7_uint64            handle = PTR_TO_UINT64(pParam);
   pimsmUpStrmSGRptEventInfo_t upStrmSGRptEventInfo;
   L7_BOOL pruneDesired;
   L7_inet_addr_t *pGrpAddr, *pSrcAddr;
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
Index: src/application/ip_mcast/vendor/pimsm/pimsmstargtree.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmstargtree.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmstargtree.c	(revision 7778)
@@ -278,13 +278,13 @@ L7_RC_t pimsmStarGDelete(pimsmCB_t * pim
     }
     return L7_SUCCESS;
   }
 
   pimsmUtilAppTimerCancel (pimsmCb, &(pStarGNode->pimsmStarGEntry.pimsmStarGUpstreamJoinTimer));
   handleListNodeDelete(pimsmCb->handleList,
-                       &pStarGNode->pimsmStarGEntry.pimsmStarGUpstreamJoinTimerHandle);
+                       (L7_uint64 *) &pStarGNode->pimsmStarGEntry.pimsmStarGUpstreamJoinTimerHandle);
 
   for(index = 0; index < MCAST_MAX_INTERFACES; index++)
   {
     if(pStarGNode->pimsmStarGIEntry[index] != L7_NULLPTR)
     {
       pimsmStarGIEntryDelete(pimsmCb, pStarGNode,index);
@@ -798,19 +798,19 @@ L7_RC_t pimsmStarGIEntryDelete(pimsmCB_t
             " (*,G,%d) already deleted ",rtrIfNum);
    return L7_SUCCESS;
   }
 
   pimsmUtilAppTimerCancel (pimsmCb, &(pStarGIEntry->pimsmStarGIPrunePendingTimer));
   handleListNodeDelete(pimsmCb->handleList,
-                         &pStarGIEntry->pimsmStarGIPrunePendingTimerHandle);     
+                       (L7_uint64 *) &pStarGIEntry->pimsmStarGIPrunePendingTimerHandle);     
   pimsmUtilAppTimerCancel (pimsmCb, &(pStarGIEntry->pimsmStarGIJoinExpiryTimer));
   handleListNodeDelete(pimsmCb->handleList,
-                         &pStarGIEntry->pimsmStarGIJoinExpiryTimerHandle);
+                       (L7_uint64 *) &pStarGIEntry->pimsmStarGIJoinExpiryTimerHandle);
   pimsmUtilAppTimerCancel (pimsmCb, &(pStarGIEntry->pimsmStarGIAssertTimer));
   handleListNodeDelete(pimsmCb->handleList,
-                         &pStarGIEntry->pimsmStarGIAssertTimerHandle);
+                       (L7_uint64 *) &pStarGIEntry->pimsmStarGIAssertTimerHandle);
 
   PIMSM_FREE (pimsmCb->family, (void*) pStarGIEntry);
 
   pStarGNode->pimsmStarGIEntry[rtrIfNum] = L7_NULLPTR;
   return L7_SUCCESS;
 }
@@ -847,13 +847,13 @@ L7_RC_t pimsmStarGTreePurge(pimsmCB_t *
            "Failed to delete (*,G) from MFC");
     }
     pStarGEntry = &pStarGNode->pimsmStarGEntry;
 
     pimsmUtilAppTimerCancel (pimsmCb, &(pStarGEntry->pimsmStarGUpstreamJoinTimer));
     handleListNodeDelete(pimsmCb->handleList,
-                         &pStarGEntry->pimsmStarGUpstreamJoinTimerHandle);
+                         (L7_uint64 *) &pStarGEntry->pimsmStarGUpstreamJoinTimerHandle);
 
     for(rtrIfNum = 0; rtrIfNum < MCAST_MAX_INTERFACES; rtrIfNum++)
     {
       pimsmStarGIEntryDelete(pimsmCb, pStarGNode, rtrIfNum);
       pStarGNode->pimsmStarGIEntry[rtrIfNum] = L7_NULLPTR;
     }  
Index: src/application/ip_mcast/vendor/pimsm/pimsmsgassertfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmsgassertfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmsgassertfsm.c	(revision 7778)
@@ -358,13 +358,13 @@ static L7_RC_t  pimsmPerIntfSGAssertActi
   inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
 
   pTimerData->rtrIfNum = rtrIfNum;
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGIAssertTimerExpiresHandler,
-                            (void*)pSGIEntry->pimsmSGIAssertTimerHandle,
+                            UINT_TO_PTR(pSGIEntry->pimsmSGIAssertTimerHandle),
                             PIMSM_DEFAULT_ASSERT_TIME - PIMSM_DEFAULT_ASSERT_OVERRIDE_INTERVAL,
                             &(pSGIEntry->pimsmSGIAssertTimer),
                             "SGI-AT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_ASSERT_FSM, PIMSM_TRACE_ERROR,
@@ -445,13 +445,13 @@ static L7_RC_t  pimsmPerIntfSGAssertActi
   pTimerData->pimsmCb = pimsmCb;
   inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
   pTimerData->rtrIfNum = rtrIfNum;
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGIAssertTimerExpiresHandler,
-                            (void*)pSGIEntry->pimsmSGIAssertTimerHandle,
+                            UINT_TO_PTR(pSGIEntry->pimsmSGIAssertTimerHandle),
                             PIMSM_DEFAULT_ASSERT_TIME,
                             &(pSGIEntry->pimsmSGIAssertTimer),
                             "SGI-AT2")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_ASSERT_FSM, PIMSM_TRACE_ERROR,
@@ -551,13 +551,13 @@ static L7_RC_t  pimsmPerIntfSGAssertActi
   pTimerData->pimsmCb = pimsmCb;
   inetCopy(&pTimerData->addr1, &pSGNode->pimsmSGEntry.pimsmSGSrcAddress);
   inetCopy(&pTimerData->addr2, &pSGNode->pimsmSGEntry.pimsmSGGrpAddress);
   pTimerData->rtrIfNum = rtrIfNum;
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmSGIAssertTimerExpiresHandler,
-                            (void*)pSGIEntry->pimsmSGIAssertTimerHandle,
+                            UINT_TO_PTR(pSGIEntry->pimsmSGIAssertTimerHandle),
                             PIMSM_DEFAULT_ASSERT_TIME - PIMSM_DEFAULT_ASSERT_OVERRIDE_INTERVAL,
                             &(pSGIEntry->pimsmSGIAssertTimer),
                             "SGI-AT3")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_ASSERT_FSM, PIMSM_TRACE_ERROR,
@@ -752,13 +752,13 @@ static void pimsmSGIAssertTimerExpiresHa
   pimsmPerIntfSGAssertEventInfo_t perIntfSGAssertEventInfo;
   pimsmSGNode_t *pSGNode;
   pimsmSGIEntry_t *pSGIEntry= L7_NULLPTR;
   L7_uint32 rtrIfNum;
   pimsmCB_t * pimsmCb;
   pimsmTimerData_t *pTimerData;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64      handle = PTR_TO_UINT64(pParam);
   L7_inet_addr_t *pGrpAddr, *pSrcAddr;
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_ASSERT_FSM, PIMSM_TRACE_NORMAL, "pTimerData == L7_NULLPTR");
Index: src/application/ip_mcast/vendor/pimsm/pimsmproto.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmproto.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmproto.c	(revision 7778)
@@ -1499,13 +1499,13 @@ void pimsmJPBundleTimerExpiryHandler(voi
   L7_uint32 rtrIfNum;
   pimsmTimerData_t *pTimerData;
   pimsmCB_t *pimsmCb = L7_NULLPTR;
   pimsmInterfaceEntry_t *   pIntfEntry = L7_NULLPTR;
   pimsmNeighborEntry_t *    pCurrentNbrEntry;
   L7_RC_t rc;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if(L7_NULLPTR == pTimerData)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_JOIN_RX_TX, PIMSM_TRACE_ERROR,"Invalid input parameter");
     return;
@@ -1542,13 +1542,13 @@ void pimsmJPBundleTimerExpiryHandler(voi
          &pCurrentNbrEntry );
     }
 
   }
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmJPBundleTimerExpiryHandler,
-                            (void*)pimsmCb->pimsmJPBundleTimerHandle,
+                            UINT_TO_PTR(pimsmCb->pimsmJPBundleTimerHandle),
                             PIMSM_DEFAULT_JP_BUNDLE_TIME,
                             &(pimsmCb->pimsmJPBundleTimer),
                             "SM-JPB2")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_JOIN_RX_TX, PIMSM_TRACE_ERROR, "pimsmJPBundleTimer appTimerAdd Failed");
Index: src/application/ip_mcast/vendor/pimsm/pimsmdnstrmstarstarrpfsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmdnstrmstarstarrpfsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimsm/pimsmdnstrmstarstarrpfsm.c	(revision 7778)
@@ -231,13 +231,13 @@ static L7_RC_t pimsmDnSmPerIntfStartStar
   memset(pTimerData, 0 , sizeof(pimsmTimerData_t));
   inetCopy(&pTimerData->addr1,
       &pStarStarRpNode->pimsmStarStarRpEntry.pimsmStarStarRpRPAddress);
   pTimerData->rtrIfNum = rtrIfNum;
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarStarRpIJoinExpiryTimerExpiresHandler,
-                            (void*)pStarStarRPIEntry->pimsmStarStarRpIJoinExpiryTimerHandle,
+                            UINT_TO_PTR(pStarStarRPIEntry->pimsmStarStarRpIJoinExpiryTimerHandle),
                             holdtime,
                             &(pStarStarRPIEntry->pimsmStarStarRpIJoinExpiryTimer),
                             "xRI-JT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_STAR_RP,  PIMSM_TRACE_ERROR,
@@ -303,13 +303,13 @@ static L7_RC_t pimsmDnSmPerIntfStartStar
                            &timeLeft) == L7_SUCCESS)
   {
     holdtime = max (timeLeft, holdtime);
   }
 
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarStarRpIJoinExpiryTimerExpiresHandler,
-                            (void*)pStarStarRPIEntry->pimsmStarStarRpIJoinExpiryTimerHandle,
+                            UINT_TO_PTR(pStarStarRPIEntry->pimsmStarStarRpIJoinExpiryTimerHandle),
                             holdtime,
                             &(pStarStarRPIEntry->pimsmStarStarRpIJoinExpiryTimer),
                             "xRI-JT2")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_STAR_RP,  PIMSM_TRACE_ERROR,
@@ -376,13 +376,13 @@ static L7_RC_t pimsmDnSmPerIntfStartStar
 
   PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_STAR_RP,  PIMSM_TRACE_INFO," J/P Override intvl = %d ",
         pimsmJoinPruneOverrideIntervalGet(pimsmCb,rtrIfNum));
 
   pTimerData->pimsmCb = pimsmCb;
   if (pimsmUtilAppTimerSet (pimsmCb, pimsmStarStarRpIPrunePendingTimerExpiresHandler,
-                            (void*)pStarStarRPIEntry->pimsmStarStarRpIPrunePendingTimerHandle,
+                            UINT_TO_PTR(pStarStarRPIEntry->pimsmStarStarRpIPrunePendingTimerHandle),
                             timeOut,
                             &(pStarStarRPIEntry->pimsmStarStarRpIPrunePendingTimer),
                             "xRI-PPT")
                          != L7_SUCCESS)
   {
     PIMSM_TRACE(PIMSM_DEBUG_BIT_STAR_STAR_RP,  PIMSM_TRACE_ERROR,
@@ -534,13 +534,13 @@ static void pimsmStarStarRpIPrunePending
   pimsmDnStrmPerIntfStarStarRPEventInfo_t dnStrmPerIntfStarStarRpEventInfo;
   pimsmTimerData_t *pTimerData;
   pimsmStarStarRpNode_t * pStarStarRpNode;
   pimsmStarStarRpIEntry_t *pimsmStarStarRpIEntry = L7_NULLPTR;
   L7_uint32  rtrIfNum;
   pimsmCB_t *pimsmCb;
-  L7_int32   handle = (L7_int32)pParam;
+  L7_uint64  handle = PTR_TO_UINT64(pParam);
   pimsmUpStrmStarStarRPEventInfo_t upStrmStarStarRpEventInfo;
   L7_BOOL joinDesired = L7_FALSE;
   L7_inet_addr_t *pRpAddr;
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
@@ -619,13 +619,13 @@ static void pimsmStarStarRpIJoinExpiryTi
   pimsmDnStrmPerIntfStarStarRPEventInfo_t dnStrmPerIntfStarStarRpEventInfo;
   pimsmTimerData_t *pTimerData;
   pimsmStarStarRpNode_t *pStarStarRpNode;
   pimsmStarStarRpIEntry_t *pimsmStarStarRpIEntry = L7_NULLPTR;
   L7_uint32 rtrIfNum;
   pimsmCB_t *pimsmCb;
-  L7_int32   handle = (L7_int32)pParam;
+  L7_uint64  handle = PTR_TO_UINT64(pParam);
   pimsmUpStrmStarStarRPEventInfo_t upStrmStarStarRpEventInfo;
   L7_BOOL joinDesired = L7_FALSE;
   L7_inet_addr_t *pRpAddr;
 
   pTimerData = (pimsmTimerData_t*)handleListNodeRetrieve(handle);
   if (pTimerData  == L7_NULLPTR)
Index: src/application/ip_mcast/vendor/pimdm/pimdm_mrt.c
===================================================================
--- src/application/ip_mcast/vendor/pimdm/pimdm_mrt.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimdm/pimdm_mrt.c	(revision 7778)
@@ -830,18 +830,18 @@ pimdmMrtEntryDelete (pimdmCB_t *pimdmCB,
     return L7_FAILURE;
   }
 
   /* Delete the Upstream Handle List Param */
   if (mrtEntry->mrtEntryUpstrmTmrHndlParam != L7_NULL)
   {
-    handleListNodeDelete (handleList,&mrtEntry->mrtEntryUpstrmTmrHndlParam);
+    handleListNodeDelete (handleList, (L7_uint64 *) &mrtEntry->mrtEntryUpstrmTmrHndlParam);
   }
   /* Delete the Entry Expiry Timer Handle List Param */
   if (mrtEntry->mrtEntryExpiryTimerHandle != L7_NULL)
   {
-    handleListNodeDelete (handleList, &mrtEntry->mrtEntryExpiryTimerHandle);
+    handleListNodeDelete (handleList, (L7_uint64 *) &mrtEntry->mrtEntryExpiryTimerHandle);
   }
 
   /* Cancel the Entry expiry timer */
   if (mrtEntry->mrtEntryExpiryTimer != L7_NULLPTR)
   {
     pimdmUtilAppTimerCancel (pimdmCB, &(mrtEntry->mrtEntryExpiryTimer));
@@ -984,13 +984,13 @@ pimdmMrtEntryAdd (pimdmCB_t *pimdmCB,
     osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                    "MRT Entry Expiry Timer Set Success for Src - %s Grp - %s ",
                    inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
     if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                               pimdmMrtEntryExpiryTimerHandler,
-                              (void*) mrtEntry->mrtEntryExpiryTimerHandle,
+                              UINT_TO_PTR(mrtEntry->mrtEntryExpiryTimerHandle),
                               PIMDM_MRT_ENTRY_TIMER_TIMEOUT,
                               errMsgBuf, sucMsgBuf,
                               &mrtEntry->mrtEntryExpiryTimer,
                               "DM-ET")
                            != L7_SUCCESS)
     {
@@ -2891,13 +2891,13 @@ pimdmMrtUpstreamAssertProcess (pimdmMrtE
   osapiSnprintf (sucMsgBuf, PIMDM_MAX_DBG_ADDR_SIZE,
                  "Upstream AT (S,G,I) Set Success for Src - %s Grp - %s Intf - %d ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp), rtrIfNum);
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmUpstreamAssertTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_DEFAULT_ASSERT_TIMEOUT, errMsgBuf, sucMsgBuf,
                             &upstrmNbrInfo->assertTimer,
                             "DM-AT")
                          != L7_SUCCESS)
   {
     PIMDM_TRACE(PIMDM_DEBUG_FAILURE,
@@ -3477,13 +3477,13 @@ static void pimdmMrtEntryExpiryTimerHand
   L7_uchar8 src[PIMDM_MAX_DBG_ADDR_SIZE];
   L7_uchar8 grp[PIMDM_MAX_DBG_ADDR_SIZE];
   mfcEntry_t mfcEntry;
 
   PIMDM_TRACE (PIMDM_DEBUG_API, "Entry");
 
-  mrtEntry  = (pimdmMrtEntry_t*)handleListNodeRetrieve((L7_uint32)handle);
+  mrtEntry  = (pimdmMrtEntry_t*)handleListNodeRetrieve(PTR_TO_UINT64(handle));
   if (mrtEntry == L7_NULLPTR)
   {
     PIMDM_TRACE(PIMDM_DEBUG_FAILURE,
                "Failed to retrive the MRT entry from the given handle");
     return;
   }
@@ -3520,13 +3520,13 @@ static void pimdmMrtEntryExpiryTimerHand
                  "MRT Entry Expiry Timer Set Success for Src - %s Grp - %s ",
                  inetAddrPrint(&mrtEntry->srcAddr,src),
                  inetAddrPrint(&mrtEntry->grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmMrtEntryExpiryTimerHandler,
-                            (void*) mrtEntry->mrtEntryExpiryTimerHandle,
+                            UINT_TO_PTR(mrtEntry->mrtEntryExpiryTimerHandle),
                             PIMDM_MRT_ENTRY_TIMER_TIMEOUT,
                             errMsgBuf, sucMsgBuf,
                             &mrtEntry->mrtEntryExpiryTimer,
                             "DM-ET2")
                          != L7_SUCCESS)
   {
Index: src/application/ip_mcast/vendor/pimdm/pimdm_init.c
===================================================================
--- src/application/ip_mcast/vendor/pimdm/pimdm_init.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimdm/pimdm_init.c	(revision 7778)
@@ -492,13 +492,13 @@ pimdmCtrlBlockMembersShow (pimdmCB_t* pi
   PIMDM_DEBUG_PRINTF ("Address of PIM-DM Control Block : 0x%x.\n", pimdmCB);
   PIMDM_DEBUG_PRINTF ("General Information ....\n");
   PIMDM_DEBUG_PRINTF ("    addrFamily         - %s.\n", ((pimdmCB->addrFamily == L7_AF_INET) ? ("IPv4") : ("IPv6")));
   PIMDM_DEBUG_PRINTF ("    operMode           - %s.\n", ((pimdmCB->operMode == L7_TRUE) ? ("Operational") : ("Not Operational")));
   PIMDM_DEBUG_PRINTF ("    sockFD             - %d.\n", pimdmCB->sockFD);
   PIMDM_DEBUG_PRINTF ("    allRoutersAddr     - %s.\n", inetAddrPrint (&(pimdmCB->allRoutersAddr), addr));
-  PIMDM_DEBUG_PRINTF ("    heapID             - 0x%x.\n", mcastMapHeapIdGet (pimdmCB->addrFamily));
+  PIMDM_DEBUG_PRINTF ("    heapID             - 0x%llx.\n", mcastMapHeapIdGet (pimdmCB->addrFamily));
   PIMDM_DEBUG_PRINTF ("Interface/Neighbor related Information ....\n");
   PIMDM_DEBUG_PRINTF ("    intfInfo           - 0x%x.\n", pimdmCB->intfInfo);
   PIMDM_DEBUG_PRINTF ("    nbrBitmap          - ");
   for (index = 1; index <= PIMDM_INTF_BIT_SIZE; index++)
     if (BITX_TEST (&pimdmCB->nbrBitmap, index) != 0)
       PIMDM_DEBUG_PRINTF (" %02d ", index);
Index: src/application/ip_mcast/vendor/pimdm/pimdm_strfr_fsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimdm/pimdm_strfr_fsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimdm/pimdm_strfr_fsm.c	(revision 7778)
@@ -196,13 +196,13 @@ void pimdmStateRefreshTimerExpiryHandler
 {
   pimdmMrtEntry_t *mrtEntry = L7_NULLPTR;
 
   PIMDM_TRACE (PIMDM_DEBUG_FSM_STRFR, "Entry");
 
   if ((mrtEntry  = (pimdmMrtEntry_t*)
-                   handleListNodeRetrieve ((L7_uint32)mrtEntryUpstrmTmrHndlParam))
+                   handleListNodeRetrieve (PTR_TO_UINT64(mrtEntryUpstrmTmrHndlParam)))
                 == L7_NULLPTR)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE, "Handle Node retrieval Failed");
     return;
   }
 
@@ -244,13 +244,13 @@ void pimdmSourceActiveTimerExpiryHandler
   L7_inet_addr_t *srcAddr = L7_NULLPTR;
   L7_inet_addr_t *grpAddr = L7_NULLPTR;
 
   PIMDM_TRACE (PIMDM_DEBUG_FSM_STRFR, "Entry");
 
   if ((mrtEntry  = (pimdmMrtEntry_t*)
-                   handleListNodeRetrieve ((L7_uint32)mrtEntryUpstrmTmrHndlParam))
+                   handleListNodeRetrieve (PTR_TO_UINT64(mrtEntryUpstrmTmrHndlParam)))
                 == L7_NULLPTR)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE, "Handle Node retrieval Failed");
     return;
   }
 
@@ -284,13 +284,13 @@ void pimdmSourceActiveTimerExpiryHandler
     osapiSnprintf (sucMsgBuf, PIMDM_MAX_DBG_MSG_SIZE,
                    "SAT (S,G) ReSet Success for Src - %s Grp - %s ",
                    inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
     if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                               pimdmSourceActiveTimerExpiryHandler,
-                              (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                              UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                               PIMDM_DEFAULT_SOURCE_LIFETIME,
                               errMsgBuf, sucMsgBuf,
                               &(mrtEntry->origStateInfo.srcActiveTimer),
                               "DM-SAT2")
                            != L7_SUCCESS)
     {
@@ -344,13 +344,13 @@ static L7_RC_t pimdmStateRfrFsmActionSet
   osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "SRT (S,G) Set Success for Src - %s Grp - %s ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmStateRefreshTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_DEFAULT_REFRESH_INTERVAL,
                             errMsgBuf, sucMsgBuf,
                             &(mrtEntry->origStateInfo.stateRfrTimer),
                             "DM-SRT")
                          != L7_SUCCESS)
   {
@@ -367,13 +367,13 @@ static L7_RC_t pimdmStateRfrFsmActionSet
   osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "SAT (S,G) Set Success for Src - %s Grp - %s ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmSourceActiveTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_DEFAULT_SOURCE_LIFETIME,
                             errMsgBuf, sucMsgBuf,
                             &(mrtEntry->origStateInfo.srcActiveTimer),
                             "DM-SAT")
                          != L7_SUCCESS)
   {
@@ -427,13 +427,13 @@ static L7_RC_t pimdmStateRfrFsmActionRes
   osapiSnprintf (sucMsgBuf, PIMDM_MAX_DBG_MSG_SIZE,
                  "SAT (S,G) ReSet Success for Src - %s Grp - %s ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmSourceActiveTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_DEFAULT_SOURCE_LIFETIME,
                             errMsgBuf, sucMsgBuf,
                             &(mrtEntry->origStateInfo.srcActiveTimer),
                             "DM-SAT3")
                          != L7_SUCCESS)
   {
@@ -506,13 +506,13 @@ static L7_RC_t pimdmStateRfrFsmActionSen
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
   osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "SRT (S,G) ReSet Success for Src - %s Grp - %s ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (pimdmCB, pimdmStateRefreshTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_DEFAULT_REFRESH_INTERVAL,
                             errMsgBuf, sucMsgBuf,
                             &(mrtEntry->origStateInfo.stateRfrTimer),
                             "DM-SRT2")
                          != L7_SUCCESS)
   {
@@ -707,13 +707,13 @@ static L7_RC_t pimdmStateRfrFsmActionRep
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
   osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "SRT (S,G) ReSet Success for Src - %s Grp - %s ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (pimdmCB, pimdmStateRefreshTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_DEFAULT_REFRESH_INTERVAL,
                             errMsgBuf, sucMsgBuf,
                             &(mrtEntry->origStateInfo.stateRfrTimer),
                             "DM-SRT2")
                          != L7_SUCCESS)
   {
Index: src/application/ip_mcast/vendor/pimdm/include/pimdm_intf.h
===================================================================
--- src/application/ip_mcast/vendor/pimdm/include/pimdm_intf.h	(revision 7772)
+++ src/application/ip_mcast/vendor/pimdm/include/pimdm_intf.h	(revision 7778)
@@ -63,13 +63,13 @@ typedef struct pimdmInterface_s
 
   /* Neighbor related parameters */
   L7_APP_TMR_HNDL_t helloTimer;     /* Hello Timer handle */
   L7_uchar8 nbrBitmap[MCAST_BITX_NUM_BITS(PIMDM_MAX_NEIGHBORS)];
                                     /* Bitmap of neighbors on this interface */
   L7_uint32 numNbrs;                /* Total number of neighbors on this interface */
-  L7_uint32 intfTmrHandle;          /* Handle List Timer Handle for the Interface Block */
+  L7_uint64 intfTmrHandle;          /* Handle List Timer Handle for the Interface Block */
 
   L7_uint32  intfStats[PIMDM_CTRL_PKT_MAX][PIMDM_STATS_TYPE_MAX];
 
   pimdmCB_t *pimdmCB;               /* Back pointer to the PIM-DM Control Block */
 } pimdmInterface_t;
 
@@ -130,13 +130,13 @@ typedef struct pimdmNeighbor_s
   L7_uint32      stateRefreshIntvl; /* State Refresh interval in seconds */
   L7_uint32      genID;             /* Generation ID */
   L7_APP_TMR_HNDL_t livenessTimer;  /* Expiry Timer to consider this neighbor */
   L7_uint32      livenessTimerGenId; /* Generation ID of the liveness timer */
   L7_uint32      createTime;        /* Time reference when created */
   L7_uint32      rtrIfNum;        /* Router interface index of the associated interface */
-  L7_uint32      nbrTmrHandle;      /* Handle List Timer Handle for the Neighbor Block */
+  L7_uint64      nbrTmrHandle;      /* Handle List Timer Handle for the Neighbor Block */
   pimdmCB_t      *pimdmCB;          /* Back pointer to the PIM-DM Control Block */
   pimdmJPMsgStoreBuff_t pimdmBuildJPMsg; /* A structure for fairly
                      * complicated Join/Prune
                      * message construction.
                      */
 } pimdmNeighbor_t;
Index: src/application/ip_mcast/vendor/pimdm/include/pimdm_mrt.h
===================================================================
--- src/application/ip_mcast/vendor/pimdm/include/pimdm_mrt.h	(revision 7772)
+++ src/application/ip_mcast/vendor/pimdm/include/pimdm_mrt.h	(revision 7778)
@@ -158,13 +158,13 @@ typedef struct pimdmDownstrmIntfInfo_s
   L7_uint32            maxPruneHoldTime;  /* The max prune hold time */ 
 
   /* Assert State info */
   pimdmAssertInfo_t    downstrmAssertInfo; 
 
   /*Timer handle */
-  L7_uint32            mrtEntryDnstrmTmrHndlParam; /* Timer Handle Param for the MRT Entry's Downstream Timers */
+  L7_uint64            mrtEntryDnstrmTmrHndlParam; /* Timer Handle Param for the MRT Entry's Downstream Timers */
 
   pimdmStRfrMsg_t      stRfrMsg; /* Storage for the recently relayed State Refresh
                                   * message that will be used to replay when the
                                   * Gen-Id of the Neighbor on the Downstream
                                   * interface is changed.
                                   */
@@ -212,15 +212,15 @@ typedef struct pimdmMrtEntry_s
   interface_bitset_t boundaryGMask;     /* Adminscope Boundary bitmask for a Group */
   interface_bitset_t pimIncludeStarG;   /* Include <*,G> local membership bitmap */
   interface_bitset_t pimIncludeSG;      /* Include <S,G> local membership bitmap */
   interface_bitset_t pimExcludeSG;      /* Exclude <S,G> local membership bitmap */
 
   /* Entry's Timer/Handle related Information */
-  L7_uint32         mrtEntryUpstrmTmrHndlParam; /* Timer Handle Param for the MRT Entry's Upstream Timers */
+  L7_uint64         mrtEntryUpstrmTmrHndlParam; /* Timer Handle Param for the MRT Entry's Upstream Timers */
   L7_APP_TMR_HNDL_t mrtEntryExpiryTimer;        /* MRT Entry Expiry Timer */
-  L7_uint32         mrtEntryExpiryTimerHandle;  /* Timer Handle for the MRT Entry's Expiry Timer */
+  L7_uint64         mrtEntryExpiryTimerHandle;  /* Timer Handle for the MRT Entry's Expiry Timer */
   L7_uint32         entryUpTime;                /* Entry's Create Time */
 
   /* Additional Information */
   pimdmCB_t *pimdmCB; /* Pointer to the PIM-DM Control Block. */
 
   void *avlData; /* AVL TREE requires this as last */
Index: src/application/ip_mcast/vendor/pimdm/pimdm_dnstrm_fsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimdm/pimdm_dnstrm_fsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimdm/pimdm_dnstrm_fsm.c	(revision 7778)
@@ -257,13 +257,13 @@ static void pimdmDnstrmPrunePendingTimer
   pimdmDownstrmIntfInfo_t *dnstrmIntfInfo =L7_NULLPTR;
   pimdmDnstrmEventInfo_t dnstrmFsmEventInfo;
 
   PIMDM_TRACE (PIMDM_DEBUG_FSM_DNSTRM, "Entry");
 
   if ((dnstrmIntfInfo = (pimdmDownstrmIntfInfo_t*)
-                         handleListNodeRetrieve ((L7_uint32)mrtEntryDnstrmTmrHndlParam))
+                         handleListNodeRetrieve (PTR_TO_UINT64(mrtEntryDnstrmTmrHndlParam)))
                       == L7_NULLPTR)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE, "Handle Node retrieval Failed");
     return;
   }
 
@@ -312,13 +312,13 @@ static void pimdmDnstrmPruneTimerExpiryH
   pimdmDownstrmIntfInfo_t *dnstrmIntfInfo = L7_NULLPTR;
   pimdmDnstrmEventInfo_t dnstrmFsmEventInfo;
 
   PIMDM_TRACE (PIMDM_DEBUG_FSM_DNSTRM, "Entry");
 
   if ((dnstrmIntfInfo = (pimdmDownstrmIntfInfo_t*)
-                         handleListNodeRetrieve ((L7_uint32)mrtEntryDnstrmTmrHndlParam))
+                         handleListNodeRetrieve (PTR_TO_UINT64(mrtEntryDnstrmTmrHndlParam)))
                       == L7_NULLPTR)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE, "Handle Node retrieval Failed");
     return;
   }
 
@@ -416,13 +416,13 @@ L7_RC_t pimdmDnstrmFsmActionSetPPT(pimdm
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp), rtrIfNum);
 
   /*Converting oiTimeout and lpdTimeout in seconds and ceil the value */
   timeout = ((oiTimeout + lpdTimeout) + 999)/1000;
 
   if (pimdmUtilAppTimerSet (pimdmCB, pimdmDnstrmPrunePendingTimerExpiryHandler,
-                            (void*) dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam,
+                            UINT_TO_PTR(dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam),
                             timeout, errMsgBuf, sucMsgBuf,
                             &dnstrmIntfInfo->prunePndTimer,
                             "DM-PPT")
                          != L7_SUCCESS)
   {
     PIMDM_TRACE(PIMDM_DEBUG_FAILURE,
@@ -493,13 +493,13 @@ L7_RC_t pimdmDnstrmFsmActionResetPT (pim
   osapiSnprintf (sucMsgBuf, PIMDM_MAX_DBG_MSG_SIZE,
                  "PT (S,G,I) ReSet Success for Src - %s Grp - %s Intf - %d ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp),
                  rtrIfNum);
 
   if (pimdmUtilAppTimerSet (pimdmCB, pimdmDnstrmPruneTimerExpiryHandler,
-                            (void*) dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam,
+                            UINT_TO_PTR(dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam),
                             dnstrmEventInfo->holdTime, errMsgBuf, sucMsgBuf,
                             &dnstrmIntfInfo->pruneTimer,
                             "DM-DnPT")
                          != L7_SUCCESS)
   {
     PIMDM_TRACE(PIMDM_DEBUG_FAILURE, "Resetting Prune Timer Failed on rtrIfNum %d",
@@ -750,13 +750,13 @@ L7_RC_t pimdmDnstrmFsmActionSetPT(pimdmM
   osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "PT (S,G,I) Set Success for Src - %s Grp - %s Intf - %d ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp),
                  rtrIfNum);
 
   if (pimdmUtilAppTimerSet (pimdmCB, pimdmDnstrmPruneTimerExpiryHandler,
-                            (void*) dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam,
+                            UINT_TO_PTR(dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam),
                             timeout, errMsgBuf, sucMsgBuf,
                             &dnstrmIntfInfo->pruneTimer,
                             "DM-DnPT2")
                          != L7_SUCCESS)
   {
     PIMDM_TRACE(PIMDM_DEBUG_FAILURE,
Index: src/application/ip_mcast/vendor/pimdm/pimdm_asrt_fsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimdm/pimdm_asrt_fsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimdm/pimdm_asrt_fsm.c	(revision 7778)
@@ -285,13 +285,13 @@ static void pimdmDnstrmAssertTimerExpiry
   pimdmAssertEventInfo_t asrtFsmEventInfo;
   pimdmAssertInfo_t *asrtIntfInfo = L7_NULLPTR;
 
   PIMDM_TRACE (PIMDM_DEBUG_API, "Entry");
 
   if ((dnstrmIntfInfo = (pimdmDownstrmIntfInfo_t*)
-                         handleListNodeRetrieve ((L7_uint32)mrtEntryDnstrmTmrHndlParam))
+                         handleListNodeRetrieve (PTR_TO_UINT64(mrtEntryDnstrmTmrHndlParam)))
                       == L7_NULLPTR)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE, "Handle Node retrieval Failed");
     return;
   }
 
@@ -408,13 +408,13 @@ pimdmAssertFsmActionSendAsrtSetAT (pimdm
                  "AT (S,G,I) Set Success for Src - %s Grp - %s Intf - %d ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp),
                  rtrIfNum);
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmDnstrmAssertTimerExpiryHandler,
-                            (void*) dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam,
+                            UINT_TO_PTR(dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam),
                             assertEventInfo->interval,
                             errMsgBuf, sucMsgBuf,
                             &asrtIntfInfo->assertTimer,
                             "DM-AT2")
                          != L7_SUCCESS)
   {
@@ -568,13 +568,13 @@ L7_RC_t pimdmAssertFsmActionSendPrnSetAT
                  "AT (S,G,I) Set Success for Src - %s Grp - %s Intf - %d ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp),
                  assertEventInfo->rtrIfNum);
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmDnstrmAssertTimerExpiryHandler,
-                            (void*) dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam,
+                            UINT_TO_PTR(dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam),
                             assertEventInfo->interval,
                             errMsgBuf, sucMsgBuf,
                             &asrtIntfInfo->assertTimer,
                             "DM-AT3")
                          != L7_SUCCESS)
   {
@@ -647,13 +647,13 @@ L7_RC_t pimdmAssertFsmActionSetAT(pimdmM
                  "AT (S,G,I) Set Success for Src - %s Grp - %s Intf - %d ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp),
                  assertEventInfo->rtrIfNum);
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmDnstrmAssertTimerExpiryHandler,
-                            (void*) dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam,
+                            UINT_TO_PTR(dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam),
                             assertEventInfo->interval,
                             errMsgBuf, sucMsgBuf,
                             &asrtIntfInfo->assertTimer,
                             "DM-AT4")
                          != L7_SUCCESS)
   {
@@ -737,13 +737,13 @@ L7_RC_t  pimdmAssertFsmActionResetAT (pi
                  "AT (S,G,I) ReSet Success for Src - %s Grp - %s Intf - %d ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp),
                  assertEventInfo->rtrIfNum);
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmDnstrmAssertTimerExpiryHandler,
-                            (void*) dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam,
+                            UINT_TO_PTR(dnstrmIntfInfo->mrtEntryDnstrmTmrHndlParam),
                             assertEventInfo->interval, errMsgBuf, sucMsgBuf,
                             &asrtIntfInfo->assertTimer,
                             "DM-AT5")
                          != L7_SUCCESS)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE,
Index: src/application/ip_mcast/vendor/pimdm/pimdm_upstrm_fsm.c
===================================================================
--- src/application/ip_mcast/vendor/pimdm/pimdm_upstrm_fsm.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimdm/pimdm_upstrm_fsm.c	(revision 7778)
@@ -352,13 +352,13 @@ L7_RC_t pimdmUpstrmFsmExecute (PIMDM_UPS
 static void pimdmUpstrmOverrideTimerExpiryHandler (void *mrtEntryUpstrmTmrHndlParam)
 {
   pimdmMrtEntry_t *mrtEntry = L7_NULLPTR;
   pimdmUpstrmEventInfo_t upstrmFsmEventInfo;
 
   if ((mrtEntry  = (pimdmMrtEntry_t*)
-                   handleListNodeRetrieve ((L7_uint32)mrtEntryUpstrmTmrHndlParam))
+                   handleListNodeRetrieve (PTR_TO_UINT64(mrtEntryUpstrmTmrHndlParam)))
                 == L7_NULLPTR)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE, "Handle Node retrieval Failed");
     return;
   }
 
@@ -400,13 +400,13 @@ static void pimdmUpstrmOverrideTimerExpi
 static void pimdmUpstrmGraftRetryTimerExpiryHandler (void *mrtEntryUpstrmTmrHndlParam)
 {
   pimdmMrtEntry_t *mrtEntry = L7_NULLPTR;
   pimdmUpstrmEventInfo_t upstrmFsmEventInfo;
 
   if ((mrtEntry  = (pimdmMrtEntry_t*)
-                   handleListNodeRetrieve ((L7_uint32)mrtEntryUpstrmTmrHndlParam))
+                   handleListNodeRetrieve (PTR_TO_UINT64(mrtEntryUpstrmTmrHndlParam)))
                 == L7_NULLPTR)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE, "Handle Node retrieval Failed");
     return;
   }
 
@@ -448,13 +448,13 @@ static void pimdmUpstrmPruneLimitTimerEx
 {
   pimdmMrtEntry_t *mrtEntry =L7_NULLPTR;
   L7_BOOL isEmpty = L7_FALSE;
   pimdmUpstrmEventInfo_t upstrmFsmEventInfo;
 
   if ((mrtEntry  = (pimdmMrtEntry_t*)
-                   handleListNodeRetrieve ((L7_uint32)mrtEntryUpstrmTmrHndlParam))
+                   handleListNodeRetrieve (PTR_TO_UINT64(mrtEntryUpstrmTmrHndlParam)))
                 == L7_NULLPTR)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE, "Handle Node retrieval Failed");
     return;
   }
 
@@ -509,13 +509,13 @@ pimdmUpstreamAssertTimerExpiryHandler (v
   pimdmMrtEntry_t *mrtEntry = L7_NULLPTR;
   pimdmAssertInfo_t *upstrmNbrInfo = L7_NULLPTR;
   pimdmUpstrmEventInfo_t upstrmFsmEventInfo;
   L7_BOOL isNull = L7_FALSE;
 
   if ((mrtEntry  = (pimdmMrtEntry_t*)
-                   handleListNodeRetrieve ((L7_uint32)mrtEntryUpstrmTmrHndlParam))
+                   handleListNodeRetrieve (PTR_TO_UINT64(mrtEntryUpstrmTmrHndlParam)))
                 == L7_NULLPTR)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE, "Handle Node retrieval Failed");
     return;
   }
 
@@ -610,13 +610,13 @@ L7_RC_t pimdmUpstrmFsmActionSendPrnSetPL
   osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "PLT (S,G) Set Success for Src - %s Grp - %s ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmUpstrmPruneLimitTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_PRUNE_LIMIT_TIMER_TIMEOUT,
                             errMsgBuf, sucMsgBuf,
                             &mrtEntry->upstrmGraftPruneStateInfo.prnLmtTimer,
                             "DM-PLT")
                          != L7_SUCCESS)
   {
@@ -711,13 +711,13 @@ L7_RC_t pimdmUpstrmFsmActionSetOT (pimdm
     osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                    "OT (S,G) Set Success for Src - %s Grp - %s ",
                    inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
     if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                               pimdmUpstrmOverrideTimerExpiryHandler,
-                              (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                              UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                               timeout, errMsgBuf, sucMsgBuf,
                               &mrtEntry->upstrmGraftPruneStateInfo.overrideTimer,
                               "DM-OT")
                            != L7_SUCCESS)
     {
       PIMDM_TRACE(PIMDM_DEBUG_FAILURE,"Failed to set Override Timer");
@@ -804,13 +804,13 @@ L7_RC_t pimdmUpstrmFsmActionResetPLT (pi
   osapiSnprintf (sucMsgBuf, PIMDM_MAX_DBG_MSG_SIZE,
                  "PLT (S,G) ReSet Success for Src - %s Grp - %s ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmUpstrmPruneLimitTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_PRUNE_LIMIT_TIMER_TIMEOUT,
                             errMsgBuf, sucMsgBuf,
                             &mrtEntry->upstrmGraftPruneStateInfo.prnLmtTimer,
                             "DM-PLT2")
                          != L7_SUCCESS)
   {
@@ -869,13 +869,13 @@ L7_RC_t pimdmUpstrmFsmActionSendPruneRes
   osapiSnprintf (sucMsgBuf, PIMDM_MAX_DBG_MSG_SIZE,
                  "PLT (S,G) ReSet Success for Src - %s Grp - %s ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmUpstrmPruneLimitTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_PRUNE_LIMIT_TIMER_TIMEOUT,
                             errMsgBuf, sucMsgBuf,
                             &mrtEntry->upstrmGraftPruneStateInfo.prnLmtTimer,
                             "DM-PLT3")
                          != L7_SUCCESS)
   {
@@ -966,13 +966,13 @@ L7_RC_t pimdmUpstrmFsmActionSendPrnSetPL
   osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "PLT (S,G) Set Success for Src - %s Grp - %s ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmUpstrmPruneLimitTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_PRUNE_LIMIT_TIMER_TIMEOUT,
                             errMsgBuf, sucMsgBuf,
                             &mrtEntry->upstrmGraftPruneStateInfo.prnLmtTimer,
                             "DM-PLT4")
                          != L7_SUCCESS)
   {
@@ -1040,13 +1040,13 @@ static L7_RC_t pimdmUpstrmFsmActionCance
   osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "GRT (S,G) Set Success for Src - %s Grp - %s ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmUpstrmGraftRetryTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_GRAFT_RETRY_TIMER_TIMEOUT, errMsgBuf,
                             sucMsgBuf,
                             &mrtEntry->upstrmGraftPruneStateInfo.grftRetryTimer,
                             "DM-GRT")
                          != L7_SUCCESS)
   {
@@ -1104,13 +1104,13 @@ static L7_RC_t pimdmUpstrmFsmActionSendG
   osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "GRT (S,G) Set Success for Src - %s Grp - %s ",
                  inetAddrPrint(srcAddr,src), inetAddrPrint(grpAddr,grp));
 
   if (pimdmUtilAppTimerSet (mrtEntry->pimdmCB,
                             pimdmUpstrmGraftRetryTimerExpiryHandler,
-                            (void*) mrtEntry->mrtEntryUpstrmTmrHndlParam,
+                            UINT_TO_PTR(mrtEntry->mrtEntryUpstrmTmrHndlParam),
                             PIMDM_GRAFT_RETRY_TIMER_TIMEOUT, errMsgBuf,
                             sucMsgBuf,
                             &mrtEntry->upstrmGraftPruneStateInfo.grftRetryTimer,
                             "DM-GRT2")
                          != L7_SUCCESS)
   {
Index: src/application/ip_mcast/vendor/pimdm/pimdm_intf.c
===================================================================
--- src/application/ip_mcast/vendor/pimdm/pimdm_intf.c	(revision 7772)
+++ src/application/ip_mcast/vendor/pimdm/pimdm_intf.c	(revision 7778)
@@ -374,13 +374,13 @@ pimdmIntfHelloTimerExpiryHandler (void *
   L7_uint32 rtrIfNum;
   L7_uchar8 errMsgBuf[PIMDM_MAX_DBG_MSG_SIZE];
   L7_uchar8 sucMsgBuf[PIMDM_MAX_DBG_MSG_SIZE];
 
   PIMDM_TRACE (PIMDM_DEBUG_API, "Entry");
 
-  if ((pIf = (pimdmInterface_t*) handleListNodeRetrieve ((L7_uint32) pParam))
+  if ((pIf = (pimdmInterface_t*) handleListNodeRetrieve (PTR_TO_UINT64(pParam)))
           == L7_NULLPTR)
   {
     PIMDM_TRACE(PIMDM_DEBUG_FAILURE,
                "Invalid interface info [NULL] in Hello Timer expiry Handle\n");
     return;
   }
@@ -419,20 +419,20 @@ pimdmIntfHelloTimerExpiryHandler (void *
   osapiSnprintf (errMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "Hello timer refresh failed on rtrIfNum %d", rtrIfNum);
   osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "Hello timer refresh success on rtrIfNum %d", rtrIfNum);
   /* Restart the Hello Timer */
   if (pimdmUtilAppTimerSet (pimdmCB, pimdmIntfHelloTimerExpiryHandler,
-                            (void*) pIf->intfTmrHandle, pIf->helloInterval,
+                            UINT_TO_PTR(pIf->intfTmrHandle), pIf->helloInterval,
                             errMsgBuf, sucMsgBuf, &(pIf->helloTimer),
                             "DM-HT")
                          != L7_SUCCESS)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE,
                  "Failed to start the Hello Timer for rtrIfNum %d", rtrIfNum);
-    handleListNodeDelete (pimdmCB->handleList, &(pIf->intfTmrHandle));
+    handleListNodeDelete (pimdmCB->handleList, (L7_uint64 *) &(pIf->intfTmrHandle));
     return;
   }
 
   PIMDM_TRACE (PIMDM_DEBUG_API, "Exit.");
 }
 
@@ -455,13 +455,13 @@ pimdmIntfNbrTimerExpiryHandler (void *pP
   pimdmNeighbor_t *pNbr = L7_NULLPTR;
   L7_int32 nbrIndex,numNbrs=-1;
   L7_uint32 rtrIfNum = 0;
 
   PIMDM_TRACE (PIMDM_DEBUG_API, "Entry");
 
-  if ((pNbr = (pimdmNeighbor_t*) handleListNodeRetrieve ((L7_uint32) pParam))
+  if ((pNbr = (pimdmNeighbor_t*) handleListNodeRetrieve (PTR_TO_UINT64(pParam)))
           == L7_NULLPTR)
   {
     PIMDM_TRACE(PIMDM_DEBUG_FAILURE,
                "Invalid neighbor info [NULL] in NLT expiry Handle");
     return;
   }
@@ -1775,13 +1775,13 @@ pimdmIntfHelloMsgProcess (pimdmCB_t
         pimdmIntfNeighborClear(pimdmCB, rtrIfNum, nbrIndex);
         return L7_FAILURE;
       }
 
       /* Start the NLT */
       if (pimdmUtilAppTimerSet (pimdmCB, pimdmIntfNbrTimerExpiryHandler,
-                                (void*) pNbr->nbrTmrHandle,
+                                UINT_TO_PTR(pNbr->nbrTmrHandle),
                                 pNbrInfo->holdTime, L7_NULLPTR, L7_NULLPTR,
                                 &(pNbr->livenessTimer),
                                 "DM-NLT")
                              != L7_SUCCESS)
       {
         PIMDM_TRACE (PIMDM_DEBUG_FAILURE,
@@ -1807,13 +1807,13 @@ pimdmIntfHelloMsgProcess (pimdmCB_t
                  "Hello timer Fastening failed on rtrIfNum %d", rtrIfNum);
           osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                  "Hello timer Fastening success on rtrIfNum %d", rtrIfNum);
 
           /* Update the Hello Timer */
           if (pimdmUtilAppTimerSet (pimdmCB, pimdmIntfHelloTimerExpiryHandler,
-                                    (void*) pIf->intfTmrHandle,
+                                    UINT_TO_PTR(pIf->intfTmrHandle),
                                     nextDelay, errMsgBuf, sucMsgBuf,
                                     &(pIf->helloTimer),
                                     "DM-HT2")
                                  != L7_SUCCESS)
           {
             PIMDM_TRACE (PIMDM_DEBUG_FAILURE,"Hello Timer Updation Failed");
@@ -1846,13 +1846,13 @@ pimdmIntfHelloMsgProcess (pimdmCB_t
     {
       /* Remove the neighbor */
       /* First : Stop the liveness timer */
       if(pNbr->livenessTimer != L7_NULLPTR)
       {
         pimdmUtilAppTimerCancel (pimdmCB, &(pNbr->livenessTimer));
-        handleListNodeDelete (pimdmCB->handleList, &(pNbr->nbrTmrHandle));
+        handleListNodeDelete (pimdmCB->handleList, (L7_uint64 *) &(pNbr->nbrTmrHandle));
       }
 
       /* Second : Update the interface parameters */
       /*pimdmIntfParamsCompute(pCB, pNbr, PIMDM_INTF_NBR_DELETE, pIf);*/
 
       pimdmMrtNLTExpiryProcess(pimdmCB,&pNbr->addr,rtrIfNum,pIf->numNbrs);
@@ -1905,20 +1905,20 @@ pimdmIntfHelloMsgProcess (pimdmCB_t
          osapiSnprintf (errMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                         "Hello timer refresh failed on rtrIfNum %d", rtrIfNum);
          osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
                         "Hello timer refresh success on rtrIfNum %d", rtrIfNum);
          /* Restart the Hello Timer */
          if (pimdmUtilAppTimerSet (pimdmCB, pimdmIntfHelloTimerExpiryHandler,
-                                   (void*) pIf->intfTmrHandle, pIf->helloInterval,
+                                   UINT_TO_PTR(pIf->intfTmrHandle), pIf->helloInterval,
                                    errMsgBuf, sucMsgBuf, &(pIf->helloTimer),
                                    "DM-HT")
                                 != L7_SUCCESS)
          {
            PIMDM_TRACE (PIMDM_DEBUG_FAILURE,
                         "Failed to start the Hello Timer for rtrIfNum %d", rtrIfNum);
-           handleListNodeDelete (pimdmCB->handleList, &(pIf->intfTmrHandle));
+           handleListNodeDelete (pimdmCB->handleList, (L7_uint64 *) &(pIf->intfTmrHandle));
          }
 
         /* Handle the Router Failure scenario by invoking the MRT to send
          * Prunes Upstream, if necessary - Section 4.3.4.
          */
         pimdmMrtNbrGenIDChangeProcess (pimdmCB, rtrIfNum, &pNbr->addr);
@@ -1928,22 +1928,22 @@ pimdmIntfHelloMsgProcess (pimdmCB_t
       pimdmIntfParamsCompute(pimdmCB, pNbr, PIMDM_INTF_NBR_UPDATE, pIf);
 
       /* Start, Stop or update the liveness timer as necessary */
       if(pNbrInfo->holdTime == PIMDM_INFINITE_HOLDTIME)
       {
         pimdmUtilAppTimerCancel (pimdmCB, &(pNbr->livenessTimer));
-        handleListNodeDelete (pimdmCB->handleList, &(pNbr->nbrTmrHandle));
+        handleListNodeDelete (pimdmCB->handleList, (L7_uint64 *) &(pNbr->nbrTmrHandle));
       }
       else
       {
         L7_BOOL bNewTimerNeeded = L7_FALSE;
 
         if(pNbr->livenessTimer != L7_NULLPTR)
         {
           if (pimdmUtilAppTimerSet (pimdmCB, pimdmIntfNbrTimerExpiryHandler,
-                                    (void*) pNbr->nbrTmrHandle,
+                                    UINT_TO_PTR(pNbr->nbrTmrHandle),
                                     pNbrInfo->holdTime, L7_NULLPTR, L7_NULLPTR,
                                     &(pNbr->livenessTimer),
                                     "DM-NLT2")
                                  != L7_SUCCESS)
           {
             bNewTimerNeeded = L7_TRUE;
@@ -1966,20 +1966,20 @@ pimdmIntfHelloMsgProcess (pimdmCB_t
                          "Failed to Store node in the Timer Handle List");
             pNbr->livenessTimer = L7_NULLPTR;
           }
           else
           {
             if (pimdmUtilAppTimerSet (pimdmCB, pimdmIntfNbrTimerExpiryHandler,
-                                      (void*) pNbr->nbrTmrHandle,
+                                      UINT_TO_PTR(pNbr->nbrTmrHandle),
                                       pNbrInfo->holdTime, L7_NULLPTR, L7_NULLPTR,
                                       &(pNbr->livenessTimer),
                                       "DM-NLT3")
                                    != L7_SUCCESS)
             {
               /* Could not start a liveness timer. Purge the neighbor */
-              handleListNodeDelete (pimdmCB->handleList, &(pNbr->nbrTmrHandle));
+              handleListNodeDelete (pimdmCB->handleList, (L7_uint64 *) &(pNbr->nbrTmrHandle));
               /*pimdmIntfParamsCompute(pCB, pNbr, PIMDM_INTF_NBR_DELETE, pIf);*/
               bChange = pimdmIntfNeighborClear(pimdmCB, rtrIfNum, nbrIndex);
             }
           }
         }
       }
@@ -2143,13 +2143,13 @@ pimdmIntfUp (pimdmCB_t      *pimdmCB,
   osapiSnprintf (errMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
          "Initial Hello timer set failed on rtrIfNum %d", rtrIfNum);
   osapiSnprintf (sucMsgBuf,PIMDM_MAX_DBG_MSG_SIZE,
          "Initial Hello timer set success on rtrIfNum %d", rtrIfNum);
 
   if (pimdmUtilAppTimerSet (pimdmCB, pimdmIntfHelloTimerExpiryHandler,
-                            (void*) pIf->intfTmrHandle, initialDelay, errMsgBuf,
+                            UINT_TO_PTR(pIf->intfTmrHandle), initialDelay, errMsgBuf,
                             sucMsgBuf, &(pIf->helloTimer),
                             "DM-HT4")
                          != L7_SUCCESS)
   {
     PIMDM_TRACE (PIMDM_DEBUG_FAILURE,
                 "Hello Timer start failed for rtrIfNum %d", rtrIfNum);
@@ -2272,13 +2272,13 @@ pimdmIntfDown (pimdmCB_t *pimdmCB,
   /* Stop the Hello timer */
   PIMDM_TRACE (PIMDM_DEBUG_API, " Deleting Hello timer of TimerNode : %p",
                pIf->helloTimer);
   PIMDM_TRACE (PIMDM_DEBUG_API, " Deleting Hello timer of Timerhandle : %p",
                pIf->intfTmrHandle);
   pimdmUtilAppTimerCancel (pimdmCB, &(pIf->helloTimer));
-  handleListNodeDelete (pimdmCB->handleList, &(pIf->intfTmrHandle));
+  handleListNodeDelete (pimdmCB->handleList, (L7_uint64 *) &(pIf->intfTmrHandle));
 
   /* Notify PIM-DM MGMD Database of the interface going down */
   if (pimdmMgmdIntfDownUpdate (pimdmCB, rtrIfNum) != L7_SUCCESS)
   {
     PIMDM_TRACE(PIMDM_DEBUG_FAILURE,
                 "MGMD Database updation failure on interface %d Down", rtrIfNum);
@@ -2312,13 +2312,13 @@ pimdmIntfDown (pimdmCB_t *pimdmCB,
 
         pNbr = &(pInfo->nbrs[i]);
         if (L7_INET_ADDR_COMPARE (&zeroInet, &(pNbr->addr)) != 0)
         {
           /* Clean-up the neighbor structure */
           pimdmUtilAppTimerCancel (pimdmCB, &(pNbr->livenessTimer));
-          handleListNodeDelete (pimdmCB->handleList, &(pNbr->nbrTmrHandle));
+          handleListNodeDelete (pimdmCB->handleList, (L7_uint64 *) &(pNbr->nbrTmrHandle));
           pimdmJPWorkingBuffReturn (pimdmCB, pNbr);
           tmpGenId = pNbr->genID;
           memset(pNbr, 0, sizeof(pimdmNeighbor_t));
           pNbr->genID = tmpGenId;
         }
       }
@@ -2422,13 +2422,13 @@ pimdmIntfPurge (pimdmCB_t *pimdmCB,
     return L7_FAILURE;  /* Inconsistancy in the interface list */
 
   pInfo->intIfNum[rtrIfNum] = 0;
 
   /* Stop the Hello timer */
   pimdmUtilAppTimerCancel (pimdmCB, &(pIf->helloTimer));
-  handleListNodeDelete (pimdmCB->handleList, &(pIf->intfTmrHandle));
+  handleListNodeDelete (pimdmCB->handleList, (L7_uint64 *) &(pIf->intfTmrHandle));
 
   /* Clean-up the interface entry itself */
   tmpGenId = pIf->genID;
   memset(pIf, 0, sizeof(pimdmInterface_t));
   pIf->genID = tmpGenId;
 
Index: src/application/ip_mcast/vendor/dvmrp/dvmrp_debug.c
===================================================================
--- src/application/ip_mcast/vendor/dvmrp/dvmrp_debug.c	(revision 7772)
+++ src/application/ip_mcast/vendor/dvmrp/dvmrp_debug.c	(revision 7778)
@@ -47,13 +47,13 @@ void dvmrpDebugIntfShow(L7_uint32 addrFa
   L7_uint32 uiIntf = 0;
   dvmrp_t *dvmrpcb=L7_NULLPTR;      
   L7_uint32 s_addr;  
   L7_int32 timeLeft;    
   L7_ulong32 probeExpTime;    
 
-  DVMRP_DEBUG_PRINTF("\n\nMCAST Heap-ID - 0x%x", mcastMapHeapIdGet(addrFamily));
+  DVMRP_DEBUG_PRINTF("\n\nMCAST Heap-ID - 0x%llx", (L7_uint64) mcastMapHeapIdGet(addrFamily));
 
 
   if ((dvmrpcb = dvmrpMapProtocolCtrlBlockGet (addrFamily)) == L7_NULLPTR)
   {
     DVMRP_DEBUG_PRINTF("\n\ndvmrpcb Pointer is NULL!!!!!!!!! \n\n");
     return;
@@ -1072,15 +1072,15 @@ void dvmrpDebugMRTTableShow(L7_uint32 ad
     }
     else
     {
       DVMRP_DEBUG_PRINTF("cahce remove timer not running\n");
     }
 
-    DVMRP_DEBUG_PRINTF("cache remove handle :%x\n",entry->cacheRemoveHandle);
-    DVMRP_DEBUG_PRINTF("prune Retransmitimer Handle:%x\n",entry->pruneRetransmitimerHandle);
-    DVMRP_DEBUG_PRINTF("graft Timeout Handle:%x\n",entry->graftTimeoutHandle);
+    DVMRP_DEBUG_PRINTF("cache remove handle :0x%llx\n",entry->cacheRemoveHandle);
+    DVMRP_DEBUG_PRINTF("prune Retransmitimer Handle:0x%llx\n",entry->pruneRetransmitimerHandle);
+    DVMRP_DEBUG_PRINTF("graft Timeout Handle:0x%llx\n",entry->graftTimeoutHandle);
     DVMRP_DEBUG_PRINTF("\n");      
 
     memcpy(&tmpEntry, entry, sizeof(dvmrp_cache_entry_t));
     entry = L7_NULLPTR;
     if (L7_SUCCESS != dvmrpCacheTableCacheNextGet(dvmrpcb,&tmpEntry, &entry))
     {
Index: src/application/ip_mcast/vendor/dvmrp/dvmrp_routing.c
===================================================================
--- src/application/ip_mcast/vendor/dvmrp/dvmrp_routing.c	(revision 7772)
+++ src/application/ip_mcast/vendor/dvmrp/dvmrp_routing.c	(revision 7778)
@@ -161,13 +161,13 @@ void dvmrp_route_del (dvmrp_route_t *rou
     if (entry->graft_sent != L7_NULLPTR)
     {
       appTimerDelete(dvmrpcb->timerHandle, entry->graft_timer);
       if (entry->graftTimeoutHandle != L7_NULL)
       {
         handleListNodeDelete(dvmrpcb->handle_list,
-                             &entry->graftTimeoutHandle);
+                             (L7_uint64 *) &entry->graftTimeoutHandle);
       }
       DVMRP_FREE (L7_AF_INET, (void*) entry->graft_sent);        
       entry->graft_sent = L7_NULLPTR;      
       entry->graft_timer=L7_NULLPTR;
 
     }
@@ -855,13 +855,13 @@ L7_int32 dvmrp_update_fn_call(L7_int32 c
           DVMRP_DEBUG(DVMRP_DEBUG_GROUP,"%s: Successfully removed the timer grp=%s,src=%s on index=%d\n",
                       __FUNCTION__,grp,src,entry->parent->index);
         }
         if (entry->cacheRemoveHandle != L7_NULL)
         {
           handleListNodeDelete(dvmrpcb->handle_list,
-                               &entry->cacheRemoveHandle);
+                               (L7_uint64 *) &entry->cacheRemoveHandle);
         }
         entry->cacheRemove_timer=L7_NULLPTR;
       }
       if (entry->data)
       {
         route = entry->data;
@@ -964,13 +964,13 @@ L7_int32 dvmrp_update_fn_call(L7_int32 c
             DVMRP_DEBUG(DVMRP_DEBUG_GROUP,"%s: Successfully removed the timer grp=%s,src=%s on index=%d\n",
                         __FUNCTION__,grp,src,entry->parent->index);
           }
           if (entry->cacheRemoveHandle != L7_NULL)
           {
             handleListNodeDelete(dvmrpcb->handle_list,
-                                 &entry->cacheRemoveHandle);
+                                 (L7_uint64 *) &entry->cacheRemoveHandle);
           }
           entry->cacheRemove_timer=L7_NULLPTR;
         }
         interface = &dvmrpcb->dvmrp_interfaces[ifindex];
         if (dvmrpMemberShipTest (dvmrpcb,&entry->group, &entry->source, 
                                  ifindex) == L7_SUCCESS)
Index: src/application/ip_mcast/vendor/dvmrp/include/dvmrp_common.h
===================================================================
--- src/application/ip_mcast/vendor/dvmrp/include/dvmrp_common.h	(revision 7772)
+++ src/application/ip_mcast/vendor/dvmrp/include/dvmrp_common.h	(revision 7778)
@@ -215,13 +215,13 @@ typedef struct _dvmrp_interface_t
   L7_int32 dlist_out;   /* list num for output filtering */
   L7_int32 nbr_count;
   L7_APP_TMR_HNDL_t probe; /* neighbor probe */
   void *global; 
   L7_int32 igmp_querier;    
 
-  L7_uint32 probePeriodicTimerHandle;
+  L7_uint64 probePeriodicTimerHandle;
   dvmrp_timer_event_t timerBlock;
 } dvmrp_interface_t;
 
 typedef struct _dvmrp_neighbor_t
 {
   L7_sll_member_t *next;
@@ -235,13 +235,13 @@ typedef struct _dvmrp_neighbor_t
   L7_ulong32 flags;
   L7_ulong32 versionSupport;
   L7_int32 index;
   L7_APP_TMR_HNDL_t timeout;/* neighbor timeout */
   L7_int32 state;
 
-  L7_uint32 nbrTimeoutHandle;
+  L7_uint64 nbrTimeoutHandle;
 } dvmrp_neighbor_t;
 
 typedef struct _desg_fwd_t
 {
   L7_ulong32 status;  
   L7_int32 metric;
@@ -291,15 +291,15 @@ typedef struct dvmrp_cache_entry_s
   L7_uint32 firstPrune;                           /* prune retransmission*/
   L7_uint32 lastPrune;                            /* prune retransmission*/
   L7_uint32 prune_retry_interval;          /* prune retransmission*/
   L7_APP_TMR_HNDL_t prune_retry_timer; /* Prune retry timer  */
   L7_APP_TMR_HNDL_t cacheRemove_timer; /* cacheRemove timer  */
 
-  L7_uint32  cacheRemoveHandle;
-  L7_uint32  pruneRetransmitimerHandle;
-  L7_uint32  graftTimeoutHandle;
+  L7_uint64  cacheRemoveHandle;
+  L7_uint64  pruneRetransmitimerHandle;
+  L7_uint64  graftTimeoutHandle;
   /* AVL TREE requires this as last */  
   void *avlData;
 } dvmrp_cache_entry_t;
 
 typedef struct dvmrp_src_grp_entry_s 
 {
@@ -406,16 +406,16 @@ typedef struct _dvmrp_t
   L7_uint32 radix_entries;
 
   osapiRWLock_t    dvmrpRwLock;  /* read-write lock protects all DVMRP data. */
   L7_BOOL          dvmrpOperFlag; /* DVMRP Current operational flag */
   handle_list_t    *handle_list;     /* create the handle list */
 
-  L7_uint32  updateTimerHandle;
-  L7_uint32  routesTimeoutHandle;
-  L7_uint32  pruneExpireHandle;
-  L7_uint32  flashrUpdateTimerHandle;
+  L7_uint64  updateTimerHandle;
+  L7_uint64  routesTimeoutHandle;
+  L7_uint64  pruneExpireHandle;
+  L7_uint64  flashrUpdateTimerHandle;
 } dvmrp_t;
 
 typedef struct _dvmrp_prune_t 
 {
   L7_sll_member_t *next;
   dvmrp_neighbor_t *neighbor;
Index: src/application/ip_mcast/vendor/dvmrp/dvmrp_interface.c
===================================================================
--- src/application/ip_mcast/vendor/dvmrp/dvmrp_interface.c	(revision 7772)
+++ src/application/ip_mcast/vendor/dvmrp/dvmrp_interface.c	(revision 7778)
@@ -232,13 +232,13 @@ L7_RC_t dvmrp_interface_activate (dvmrp_
     interface->timerBlock.data4 = dvmrpcb;    
     interface->probePeriodicTimerHandle =
     handleListNodeStore(dvmrpcb->handle_list, (void*)&interface->timerBlock);
 
     if (L7_NULLPTR == (interface->probe = appTimerAdd(dvmrpcb->timerHandle,
                                                       dvmrp_probe_sendHandler,
-                                                      (void *)interface->probePeriodicTimerHandle,
+                                                      UINT_TO_PTR(interface->probePeriodicTimerHandle),
                                                       DVMRP_NEIGHBOR_PROBE_INTERVAL,
                                                       "DV-PRB")))
     {
       DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,
                   "%s : %d Timer creation failed\n",__FUNCTION__,__LINE__);
       return L7_FAILURE;
@@ -273,13 +273,13 @@ L7_RC_t dvmrp_interface_activate (dvmrp_
     dvmrp_direct_route_delete(interface);
 
     appTimerDelete(dvmrpcb->timerHandle, interface->probe);
     if (interface->probePeriodicTimerHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &interface->probePeriodicTimerHandle);
+                           (L7_uint64 *) &interface->probePeriodicTimerHandle);
     }
     interface->probe=L7_NULLPTR;
 
     for (nbr = (dvmrp_neighbor_t *)SLLFirstGet(&(interface->ll_neighbors));
         nbr != L7_NULLPTR; nbr = nbrNext)
     {
@@ -291,13 +291,13 @@ L7_RC_t dvmrp_interface_activate (dvmrp_
         dvmrp_neighbor_cleanup(nbr);
 
         appTimerDelete(dvmrpcb ->timerHandle, nbr->timeout);
         if (nbr->nbrTimeoutHandle != L7_NULL)
         {
           handleListNodeDelete(dvmrpcb ->handle_list,
-                               &nbr->nbrTimeoutHandle);
+                               (L7_uint64 *) &nbr->nbrTimeoutHandle);
         }
         nbr->timeout=L7_NULLPTR;
       }
       if (osapiWriteLockTake(dvmrpcb->dvmrpRwLock, L7_WAIT_FOREVER) == L7_FAILURE)
       {
         DVMRP_DEBUG(DVMRP_DEBUG_FAILURES, "%s:%d Could Not Access the semaphore.\n\n",
Index: src/application/ip_mcast/vendor/dvmrp/dvmrp_protocol.c
===================================================================
--- src/application/ip_mcast/vendor/dvmrp/dvmrp_protocol.c	(revision 7772)
+++ src/application/ip_mcast/vendor/dvmrp/dvmrp_protocol.c	(revision 7778)
@@ -104,22 +104,22 @@ L7_RC_t dvmrp_probe_recv (dvmrp_interfac
     if (timeLeft >= L7_NULL)
     {
       appTimerDelete(dvmrpcb->timerHandle, nbr->timeout);
       if (nbr->nbrTimeoutHandle != L7_NULL)
       {
         handleListNodeDelete(dvmrpcb->handle_list,
-                             &nbr->nbrTimeoutHandle);
+                             (L7_uint64 *) &nbr->nbrTimeoutHandle);
       }
       nbr->timeout=L7_NULLPTR;
     }
     nbr->nbrTimeoutHandle =
     handleListNodeStore(dvmrpcb->handle_list, (void*)nbr);
 
     if (L7_NULLPTR == (nbr->timeout = appTimerAdd(dvmrpcb->timerHandle,
                                                   dvmrp_neighbor_timeout,
-                                                  (void *)nbr->nbrTimeoutHandle,
+                                                  UINT_TO_PTR(nbr->nbrTimeoutHandle),
                                                   DVMRP_NEIGHBOR_EXPIRE_TIME,
                                                   "DV-NLT3")))
     {
       DVMRP_DEBUG(DVMRP_DEBUG_FAILURES, "%s:%d timer instantiation failed \n", 
                   __FUNCTION__, __LINE__);
       DVMRP_DEBUG(DVMRP_DEBUG_ROUTE, "%s:%d timer instantiation failed \n", 
@@ -387,22 +387,22 @@ L7_RC_t dvmrp_probe_recv (dvmrp_interfac
     if (timeLeft >= L7_NULL)
     {
       appTimerDelete(dvmrpcb->timerHandle, nbr->timeout);
       if (nbr->nbrTimeoutHandle != L7_NULL)
       {
         handleListNodeDelete(dvmrpcb->handle_list,
-                             &nbr->nbrTimeoutHandle);
+                             (L7_uint64 *) &nbr->nbrTimeoutHandle);
       }
       nbr->timeout = L7_NULLPTR;
     }
     nbr->nbrTimeoutHandle =
     handleListNodeStore(dvmrpcb->handle_list, (void*)nbr);
 
     if (L7_NULLPTR == (nbr->timeout = appTimerAdd(dvmrpcb->timerHandle,
                                                   dvmrp_neighbor_timeout,
-                                                  (void *)nbr->nbrTimeoutHandle,
+                                                  UINT_TO_PTR(nbr->nbrTimeoutHandle),
                                                   DVMRP_NEIGHBOR_EXPIRE_TIME,
                                                   "DV-NLT4")))
     {
       DVMRP_DEBUG(DVMRP_DEBUG_FAILURES, "%s:%d timer instantiation failed \n", 
                   __FUNCTION__, __LINE__);
       DVMRP_DEBUG(DVMRP_DEBUG_ROUTE, "%s:%d timer instantiation failed \n", 
@@ -1621,13 +1621,13 @@ L7_RC_t dvmrp_graft_ack_recv(dvmrp_inter
     entry->cacheRemove_timer = L7_NULLPTR;
   }
 
   if (entry->cacheRemoveHandle != L7_NULL)
   {
     handleListNodeDelete(dvmrpcb ->handle_list,
-                         &entry->cacheRemoveHandle);
+                         (L7_uint64 *) &entry->cacheRemoveHandle);
   }
 
   }
   DVMRP_DEBUG(DVMRP_DEBUG_APIS,"%s: LEAVING \n",__FUNCTION__);
 
   return L7_SUCCESS;  
@@ -1797,13 +1797,13 @@ L7_int32 dvmrp_graft_send (dvmrp_cache_e
   if (entry->cacheRemove_timer != L7_NULLPTR)
   {
     appTimerDelete(dvmrpcb->timerHandle, entry->cacheRemove_timer);
     if (entry->cacheRemoveHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &entry->cacheRemoveHandle);
+                           (L7_uint64 *) &entry->cacheRemoveHandle);
     }
     entry->cacheRemove_timer=L7_NULLPTR;    
   }
   
   if (entry->prune_retry_timer != L7_NULLPTR)
   {
@@ -1811,13 +1811,13 @@ L7_int32 dvmrp_graft_send (dvmrp_cache_e
     entry->prune_retry_timer=L7_NULLPTR;
   }
 
     if (entry->pruneRetransmitimerHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &entry->pruneRetransmitimerHandle);
+                           (L7_uint64 *) &entry->pruneRetransmitimerHandle);
     }
 
  
   entry->holdtime = DVMRP_CACHE_EXPIRE_TIME;
   entry->expire = now + DVMRP_CACHE_EXPIRE_TIME;
   if (inetAddrHtop(&nbr->nbrAddr.addr, nbrAddr) != L7_SUCCESS)
@@ -1885,26 +1885,26 @@ L7_int32 dvmrp_graft_send (dvmrp_cache_e
     graft->expire = now + graft->holdtime;
     entry->graft_sent = graft;  
 
     if(timerRunning == L7_TRUE)
     {
       if (appTimerUpdate(dvmrpcb->timerHandle, entry->graft_timer, dvmrp_graft_timeout, 
-                         (void *)entry->graftTimeoutHandle, graft->holdtime,
+                         UINT_TO_PTR(entry->graftTimeoutHandle), graft->holdtime,
                          "DVMRP Graft Timer4") != L7_SUCCESS)
       {
         DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"%s : %d Timer Updation failed\n",__FUNCTION__,__LINE__);
         return L7_FAILURE;
       }
     }
     else
     {
       entry->graftTimeoutHandle =
       handleListNodeStore(dvmrpcb->handle_list, (void*)entry);
       if (L7_NULLPTR == (entry->graft_timer = appTimerAdd(dvmrpcb->timerHandle,
                                                           dvmrp_graft_timeout,
-                                                          (void *)entry->graftTimeoutHandle,
+                                                          UINT_TO_PTR(entry->graftTimeoutHandle),
                                                           graft->holdtime,
                                                           "DV-GT")))
       {
         DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"%s : %d Timer creation failed\n",__FUNCTION__,__LINE__);
         DVMRP_DEBUG(DVMRP_DEBUG_GRAFT,"%s : %d Timer creation failed\n",__FUNCTION__,__LINE__);
         return L7_FAILURE;
@@ -2110,13 +2110,13 @@ L7_int32 dvmrp_probe_send(dvmrp_interfac
 *********************************************************************/
 void dvmrp_probe_sendHandler(void *pParam)
 {
   dvmrp_timer_event_t *timerBlock = L7_NULLPTR;
   dvmrp_interface_t *interface = L7_NULLPTR;
   L7_dvmrp_inet_addr_t *addr = L7_NULLPTR;
-  L7_int32  handle = (L7_int32)pParam;
+  L7_int64 handle = PTR_TO_UINT64(pParam);
   L7_int32 rtrIfNum;
   dvmrp_t *dvmrpcb; 
 
   DVMRP_DEBUG(DVMRP_DEBUG_APIS, "%s: ENTERED \n", __FUNCTION__);
 
   timerBlock = (dvmrp_timer_event_t *)handleListNodeRetrieve(handle);
@@ -2164,13 +2164,14 @@ void dvmrp_probe_sendHandler(void *pPara
              " As a result of this, the DVMRP neighborship"
              " could be lost in the neighboring DVMRP routers.",
              interface->index);
   }
 
   if (L7_NULLPTR == (interface->probe = appTimerAdd(dvmrpcb->timerHandle,
-                                                    dvmrp_probe_sendHandler, (void *)interface->probePeriodicTimerHandle, 
+                                                    dvmrp_probe_sendHandler,
+                                                    UINT_TO_PTR(interface->probePeriodicTimerHandle), 
                                                     DVMRP_NEIGHBOR_PROBE_INTERVAL,
                                                     "DV-PRB2")))
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES, "%s:%d timer instantiation failed \n", 
                 __FUNCTION__, __LINE__);
     return;
@@ -2296,13 +2297,13 @@ L7_int32 dvmrp_prune_send(dvmrp_interfac
        */
       entry->pruneRetransmitimerHandle =
       handleListNodeStore(dvmrpcb->handle_list, (void*)entry);
 
       entry->prune_retry_timer = appTimerAdd(dvmrpcb->timerHandle,
                                              dvmrp_prune_retransmit_timer_expire,
-                                             (void *)entry->pruneRetransmitimerHandle,
+                                             UINT_TO_PTR(entry->pruneRetransmitimerHandle),
                                              entry->prune_retry_interval,
                                              "DV-PRxT");
     }
     else
     {
       L7_uint32 timeLeft = 0;
@@ -2320,23 +2321,23 @@ L7_int32 dvmrp_prune_send(dvmrp_interfac
       if (timeLeft >= L7_NULL)
       {
         appTimerDelete(dvmrpcb->timerHandle, entry->prune_retry_timer);
         if (entry->pruneRetransmitimerHandle != L7_NULL)
         {
           handleListNodeDelete(dvmrpcb->handle_list,
-                               &entry->pruneRetransmitimerHandle);
+                               (L7_uint64 *) &entry->pruneRetransmitimerHandle);
         }
         entry->prune_retry_timer=0;
       }
       entry->pruneRetransmitimerHandle =
       handleListNodeStore(dvmrpcb->handle_list, (void*)entry);
 
       if (L7_NULLPTR == (entry->prune_retry_timer = 
                          appTimerAdd(dvmrpcb->timerHandle, 
                                      dvmrp_prune_retransmit_timer_expire,
-                                     (void *)entry->pruneRetransmitimerHandle,
+                                     UINT_TO_PTR(entry->pruneRetransmitimerHandle),
                                      entry->prune_retry_interval,
                                       "DV-PRxT2")))
       {
         DVMRP_DEBUG(DVMRP_DEBUG_FAILURES, 
                     "%s:%d timer instantiation failed \n", 
                     __FUNCTION__, __LINE__);
@@ -2353,13 +2354,13 @@ L7_int32 dvmrp_prune_send(dvmrp_interfac
       entry->graft_sent=L7_NULLPTR;   
       entry->graft_timer=L7_NULLPTR;
     }
       if (entry->graftTimeoutHandle != L7_NULL)
       {
         handleListNodeDelete(dvmrpcb->handle_list,
-                             &entry->graftTimeoutHandle);
+                             (L7_uint64 *) &entry->graftTimeoutHandle);
       }
     
   }
   assert (neighbor);
   if (BIT_TEST (neighbor->flags, DVMRP_NEIGHBOR_DELETE))
   {
Index: src/application/ip_mcast/vendor/dvmrp/dvmrp_mfc.c
===================================================================
--- src/application/ip_mcast/vendor/dvmrp/dvmrp_mfc.c	(revision 7772)
+++ src/application/ip_mcast/vendor/dvmrp/dvmrp_mfc.c	(revision 7778)
@@ -346,13 +346,13 @@ void dvmrp_cache_mfc_update (dvmrp_cache
     if (entry->prune_retry_timer)
     {
       appTimerDelete(dvmrpcb->timerHandle, entry->prune_retry_timer);
       if (entry->pruneRetransmitimerHandle != L7_NULL)
       {
         handleListNodeDelete(dvmrpcb->handle_list,
-                             &entry->pruneRetransmitimerHandle);
+                             (L7_uint64 *) &entry->pruneRetransmitimerHandle);
       }
       entry->prune_retry_timer=0;      
 
       /* reinitialize the prune retry back-off mechanism */
       entry->count = 0;
       entry->firstPrune = 0;
Index: src/application/ip_mcast/vendor/dvmrp/dvmrp_cache_table.c
===================================================================
--- src/application/ip_mcast/vendor/dvmrp/dvmrp_cache_table.c	(revision 7772)
+++ src/application/ip_mcast/vendor/dvmrp/dvmrp_cache_table.c	(revision 7778)
@@ -267,25 +267,25 @@ L7_RC_t dvmrpCacheTableCacheDelete(dvmrp
   if (entry->prune_retry_timer)
   {
     appTimerDelete(dvmrpcb->timerHandle, entry->prune_retry_timer);
     if (entry->pruneRetransmitimerHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &entry->pruneRetransmitimerHandle);
+                           (L7_uint64 *) &entry->pruneRetransmitimerHandle);
     }
     entry->prune_retry_timer=L7_NULLPTR;
 
   }
 
   if (entry->graft_sent)
   {
     appTimerDelete(dvmrpcb->timerHandle, entry->graft_timer);
     if (entry->graftTimeoutHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &entry->graftTimeoutHandle);
+                           (L7_uint64 *) &entry->graftTimeoutHandle);
     }
     DVMRP_FREE (L7_AF_INET, (void*) entry->graft_sent);        
     entry->graft_sent=L7_NULLPTR;   
     entry->graft_timer=L7_NULLPTR;
 
   }
@@ -293,13 +293,13 @@ L7_RC_t dvmrpCacheTableCacheDelete(dvmrp
   if (entry->cacheRemove_timer != L7_NULLPTR)
   {
     appTimerDelete(dvmrpcb->timerHandle, entry->cacheRemove_timer);
     if (entry->cacheRemoveHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &entry->cacheRemoveHandle);
+                           (L7_uint64 *) &entry->cacheRemoveHandle);
     }
     entry->cacheRemove_timer=L7_NULLPTR;    
   }
   
 
   for (prune = (dvmrp_prune_t*)SLLFirstGet(&(entry->ll_prunes));
Index: src/application/ip_mcast/vendor/dvmrp/dvmrp_timer.c
===================================================================
--- src/application/ip_mcast/vendor/dvmrp/dvmrp_timer.c	(revision 7772)
+++ src/application/ip_mcast/vendor/dvmrp/dvmrp_timer.c	(revision 7778)
@@ -45,13 +45,13 @@ void dvmrp_graft_timeout (void *pParam)
 {
   L7_uint32 now;
   dvmrp_graft_t *graft = L7_NULLPTR;
   dvmrp_neighbor_t *nbr = L7_NULLPTR;
   dvmrp_route_t *route = L7_NULLPTR;
   dvmrp_cache_entry_t *entry = L7_NULLPTR;
-  L7_int32  handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
   dvmrp_t *dvmrpcb = L7_NULLPTR;  
 
   DVMRP_DEBUG(DVMRP_DEBUG_APIS,"%s: ENTERED \n",__FUNCTION__);
 
   entry = (dvmrp_cache_entry_t *)handleListNodeRetrieve(handle);
   if (L7_NULLPTR == entry)
@@ -79,13 +79,13 @@ void dvmrp_graft_timeout (void *pParam)
         BIT_TEST (graft->entry->flags, DVMRP_CACHE_DELETE))
     {
       appTimerDelete(dvmrpcb->timerHandle, entry->graft_timer);
       if (entry->graftTimeoutHandle != L7_NULL)
       {
         handleListNodeDelete(dvmrpcb->handle_list,
-                             &entry->graftTimeoutHandle);
+                             (L7_uint64 *) &entry->graftTimeoutHandle);
       }
       DVMRP_FREE (L7_AF_INET, (void*) graft);        
       entry->graft_sent =L7_NULLPTR;     
       entry->graft_timer=L7_NULLPTR;
       return; 
     }
@@ -116,13 +116,13 @@ void dvmrp_graft_timeout (void *pParam)
       graft->expire = now;
       BIT_SET(graft->entry->flags, DVMRP_CACHE_DVMRP_GRAFT);
     }
 
     if (L7_NULLPTR == (entry->graft_timer = appTimerAdd(dvmrpcb->timerHandle,
                                                         dvmrp_graft_timeout,
-                                                        (void *)entry->graftTimeoutHandle,
+                                                        UINT_TO_PTR(entry->graftTimeoutHandle),
                                                         graft->holdtime,
                                                         "DV-GT2")))
     {
       DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,
                   "%s : %d Timer creation failed\n",__FUNCTION__,__LINE__);
       return;
@@ -144,13 +144,13 @@ void dvmrp_graft_timeout (void *pParam)
 * @end
 *********************************************************************/
 void dvmrp_neighbor_timeout (void *pParam)
 {
   dvmrp_neighbor_t *nbr = L7_NULLPTR;
   dvmrp_t *dvmrpcb = L7_NULLPTR;     
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
 
   DVMRP_DEBUG(DVMRP_DEBUG_APIS,"%s: ENTERED \n",__FUNCTION__);
   
   nbr = (dvmrp_neighbor_t *)handleListNodeRetrieve(handle);
   if (L7_NULLPTR == nbr)
   {
@@ -187,13 +187,13 @@ void dvmrp_prune_expire (void *pParam)
 {
   dvmrp_cache_entry_t tmpEntry, *entry = L7_NULLPTR;
   dvmrp_prune_t *prune = L7_NULLPTR;
   dvmrp_t *dvmrpcb = L7_NULLPTR; 
   L7_uint32 min_prune_interval = 1/*DVMRP_PRUNE_TIMEOUT_INTERVAL*/;
   L7_uint32 now;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
 
   dvmrpcb = (dvmrp_t *)handleListNodeRetrieve(handle);
   if (L7_NULLPTR == dvmrpcb)
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"\n\nINVALID : dvmrpcb is NULL!\n\n");
     return;  
@@ -272,13 +272,13 @@ void dvmrp_prune_expire (void *pParam)
       break;
     }
   }
 
   if (L7_NULLPTR == (dvmrpcb->expire = appTimerAdd(dvmrpcb->timerHandle,
                                                    dvmrp_prune_expire,
-                                                   (void *)dvmrpcb->pruneExpireHandle,
+                                                   UINT_TO_PTR(dvmrpcb->pruneExpireHandle),
                                                    min_prune_interval,
                                                    "DV-PT3")))
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"%s:%d timer instantiation failed \n", 
                 __FUNCTION__,__LINE__);
     DVMRP_DEBUG(DVMRP_DEBUG_TIMERS,"%s:%d timer instantiation failed \n",
@@ -308,13 +308,13 @@ void dvmrpRestartRoutesTimeoutHandler(dv
               "%s:%d\n\nRestart dvmrp_routes_timeout every (140sec)\n\n",
               __FUNCTION__,__LINE__);
 
 
   if (L7_NULLPTR == (dvmrpcb->age = appTimerAdd(dvmrpcb->timerHandle,
                                                 dvmrp_routes_timeout,
-                                                (void *)dvmrpcb->routesTimeoutHandle, t,
+                                                UINT_TO_PTR(dvmrpcb->routesTimeoutHandle), t,
                                                 "DV-RT3")))
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"%s:%d timer instantiation failed \n",
                 __FUNCTION__,__LINE__);
     DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,"%s:%d timer instantiation failed \n",
                 __FUNCTION__,__LINE__);
@@ -338,13 +338,13 @@ void dvmrp_routes_timeout (void *pParam)
   L7_uint32 now, t;
   L7_uint32 nexttime = 0;
   dvmrpRouteData_t *pData = L7_NULLPTR;
   dvmrp_cache_entry_t tmpEntry, *entry = L7_NULLPTR;
   dvmrpRouteData_t *pNextData = L7_NULLPTR;
   dvmrp_route_t *route = L7_NULLPTR;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
   dvmrp_t *dvmrpcb = L7_NULLPTR;
 
   DVMRP_DEBUG(DVMRP_DEBUG_APIS,"%s: ENTERED \n",__FUNCTION__);
   DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,"%s: ENTERED \n",__FUNCTION__);
 
   dvmrpcb = (dvmrp_t *)handleListNodeRetrieve(handle);
@@ -511,13 +511,13 @@ void dvmrp_routes_timeout (void *pParam)
 *
 * @end
 *********************************************************************/
 void dvmrp_Cache_Remove (void *pParam)
 {
   dvmrp_cache_entry_t *entry = L7_NULLPTR;
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
   dvmrp_t *dvmrpcb=L7_NULLPTR;  
 
   entry = (dvmrp_cache_entry_t *)handleListNodeRetrieve(handle);
   if (L7_NULLPTR == entry)
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"Invalid input parameter");
@@ -549,13 +549,13 @@ void dvmrp_Cache_Remove (void *pParam)
     entry->prune_retry_timer = L7_NULLPTR;
   }
   
   if (entry->pruneRetransmitimerHandle != L7_NULL)
   {
     handleListNodeDelete(dvmrpcb ->handle_list,
-                         &entry->pruneRetransmitimerHandle);
+                         (L7_uint64 *) &entry->pruneRetransmitimerHandle);
   }
 
   dvmrpCacheRemove(dvmrpcb ,entry);
 }
 
 /*********************************************************************
@@ -569,13 +569,13 @@ void dvmrp_Cache_Remove (void *pParam)
 * @notes    Route reports are sent on all the interfaces
 *       
 * @end
 *********************************************************************/
 void dvmrp_timer_update (void *pParam )
 {
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
   dvmrp_t *dvmrpcb = L7_NULLPTR;
 
   /* DVMRP_DEBUG(DVMRP_DEBUG_APIS,"%s: ENTERED \n",__FUNCTION__); */
 
   dvmrpcb = (dvmrp_t *)handleListNodeRetrieve(handle);
   if (L7_NULLPTR == dvmrpcb)
@@ -595,13 +595,13 @@ void dvmrp_timer_update (void *pParam )
   DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,
               "%s:%d\n\nRestart dvmrp_timer_update every (60sec)\n\n",
               __FUNCTION__,__LINE__);
 
   if (L7_NULLPTR == (dvmrpcb->timer = appTimerAdd(dvmrpcb->timerHandle,
                                                   dvmrp_timer_update,
-                                                  (void *)dvmrpcb->updateTimerHandle,
+                                                  UINT_TO_PTR(dvmrpcb->updateTimerHandle),
                                                   DVMRP_UPDATE_INTERVAL,
                                                   "DV-UPD2")))
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"%s:%d timer instantiation failed \n",
                 __FUNCTION__,__LINE__);
     DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,"%s:%d timer instantiation failed \n", 
@@ -621,13 +621,13 @@ void dvmrp_timer_update (void *pParam )
 * @notes    only the updated routes are sent
 *       
 * @end
 *********************************************************************/
 void dvmrp_flash_update (void *pParam)
 {
-  L7_int32      handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
   dvmrp_t *dvmrpcb = L7_NULLPTR;
 
   DVMRP_DEBUG(DVMRP_DEBUG_APIS,"%s: ENTERED \n",__FUNCTION__);
   DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,"%s: ENTERED \n",__FUNCTION__);
 
   dvmrpcb = (dvmrp_t *)handleListNodeRetrieve(handle);
@@ -653,13 +653,13 @@ void dvmrp_flash_update (void *pParam)
                 "dvmrp_route_advertise\n",__FUNCTION__,__LINE__);
   }
 
   if(dvmrpcb->flashrUpdateTimerHandle != L7_NULL)
   {
     handleListNodeDelete(dvmrpcb ->handle_list,
-                         &dvmrpcb->flashrUpdateTimerHandle);
+                         (L7_uint64 *) &dvmrpcb->flashrUpdateTimerHandle);
 
   }
   
   DVMRP_DEBUG(DVMRP_DEBUG_APIS,"%s: LEAVING \n",__FUNCTION__);
   DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,"%s: LEAVING \n",__FUNCTION__);
 }
@@ -692,13 +692,13 @@ void dvmrp_flash_timer_set (dvmrp_t *dvm
 
   dvmrpcb->flashrUpdateTimerHandle =
   handleListNodeStore(dvmrpcb->handle_list, (void*)dvmrpcb);
 
   if (L7_NULLPTR == (dvmrpcb->flash = appTimerAdd(dvmrpcb->timerHandle,
                                                   dvmrp_flash_update,
-                                                  (void *)dvmrpcb->flashrUpdateTimerHandle,
+                                                  UINT_TO_PTR(dvmrpcb->flashrUpdateTimerHandle),
                                                   DVMRP_FLASH_INTERVAL,
                                                   "DV-FT")))
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"%s:%d Timer creation failed\n",
                 __FUNCTION__,__LINE__);
     DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,"%s:%d Timer creation failed\n",
@@ -724,13 +724,13 @@ void dvmrp_flash_timer_set (dvmrp_t *dvm
 *       
 * @end
 *********************************************************************/
 void dvmrp_prune_retransmit_timer_expire(void * pParam)
 {
   dvmrp_cache_entry_t *entry = L7_NULLPTR;
-  L7_int32  handle = (L7_int32)pParam;
+  L7_uint64 handle = PTR_TO_UINT64(pParam);
   dvmrp_t           *dvmrpcb = L7_NULLPTR;
 
   entry= (dvmrp_cache_entry_t *)handleListNodeRetrieve(handle);
   if (L7_NULLPTR == entry)
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"Invalid input parameter");
@@ -775,13 +775,13 @@ void dvmrp_prune_retransmit_timer_expire
        entry->cacheRemoveHandle =
            handleListNodeStore(dvmrpcb->handle_list, (void*)entry);
 
     if (L7_NULLPTR == (entry->cacheRemove_timer =
                            appTimerAdd(dvmrpcb->timerHandle,
                                        dvmrp_Cache_Remove,
-                                       (void *)entry->cacheRemoveHandle,
+                                       UINT_TO_PTR(entry->cacheRemoveHandle),
                                        expiryTime,
                                        "DV-CT")))
     {
           DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,
                       "%s:%d timer instantiation failed \n",
                       __FUNCTION__,__LINE__);
Index: src/application/ip_mcast/vendor/dvmrp/dvmrp_nbr.c
===================================================================
--- src/application/ip_mcast/vendor/dvmrp/dvmrp_nbr.c	(revision 7772)
+++ src/application/ip_mcast/vendor/dvmrp/dvmrp_nbr.c	(revision 7778)
@@ -282,13 +282,13 @@ dvmrp_neighbor_t *dvmrp_neighbor_registe
     }
 
     nbr->nbrTimeoutHandle =
     handleListNodeStore(dvmrpcb->handle_list, (void*)nbr);
 
     nbr->timeout = appTimerAdd(dvmrpcb->timerHandle, dvmrp_neighbor_timeout, 
-                               (void *)nbr->nbrTimeoutHandle, expire_interval,
+                               UINT_TO_PTR(nbr->nbrTimeoutHandle), expire_interval,
                                "DV-NLT");
     if (L7_NULLPTR == nbr->timeout)
     {
       DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"%s : %d Timer creation failed\n",
                   __FUNCTION__,__LINE__);
       return L7_NULLPTR;
@@ -365,21 +365,22 @@ void dvmrp_neighbor_recover (dvmrp_inter
   if (timeLeft >= L7_NULL)
   {
     appTimerDelete(dvmrpcb->timerHandle, nbr->timeout);
     if (nbr->nbrTimeoutHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &nbr->nbrTimeoutHandle);
+                           (L7_uint64 *) &nbr->nbrTimeoutHandle);
     }
     nbr->timeout=L7_NULLPTR;
   }
   nbr->nbrTimeoutHandle =
   handleListNodeStore(dvmrpcb->handle_list, (void*)nbr);
 
   if (L7_NULLPTR == (nbr->timeout = appTimerAdd(dvmrpcb->timerHandle, 
-                                                dvmrp_neighbor_timeout, (void *)nbr->nbrTimeoutHandle,
+                                                dvmrp_neighbor_timeout,
+                                                UINT_TO_PTR(nbr->nbrTimeoutHandle),
                                                 expire_interval,
                                                 "DV-NLT2")))
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"%s:%d timer instantiation failed \n",
                 __FUNCTION__,__LINE__);
     DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,"%s:%d timer instantiation failed \n", 
@@ -593,13 +594,13 @@ void dvmrp_neighbor_cleanup (dvmrp_neigh
       if(graft->neighbor == nbr)
       {
       appTimerDelete(dvmrpcb->timerHandle, entry->graft_timer);
       if (entry->graftTimeoutHandle != L7_NULL)
       {
         handleListNodeDelete(dvmrpcb->handle_list,
-                             &entry->graftTimeoutHandle);
+                             (L7_uint64 *) &entry->graftTimeoutHandle);
       }
       DVMRP_FREE (L7_AF_INET, (void*) entry->graft_sent);        
       entry->graft_sent=L7_NULLPTR;
       entry->graft_timer=L7_NULLPTR;
       }
 
@@ -655,13 +656,13 @@ void dvmrp_neighbor_cleanup (dvmrp_neigh
                     __FUNCTION__,__LINE__);
         dvmrpcb->routesTimeoutHandle =
         handleListNodeStore(dvmrpcb->handle_list, (void*)dvmrpcb);
 
         if (L7_NULLPTR == (dvmrpcb->age = appTimerAdd(dvmrpcb->timerHandle,
                                                       dvmrp_routes_timeout,
-                                                      (void *)dvmrpcb->routesTimeoutHandle,
+                                                      UINT_TO_PTR(dvmrpcb->routesTimeoutHandle),
                                                       DVMRP_ROUTE_HOLD_TIME,
                                                       "DV-RT2")))
         {
           DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,
                       "%s:%d timer instantiation failed returning\n",
                       __FUNCTION__,__LINE__);
@@ -679,24 +680,24 @@ void dvmrp_neighbor_cleanup (dvmrp_neigh
                     __FUNCTION__,__LINE__);
 
         appTimerDelete(dvmrpcb->timerHandle, dvmrpcb->age);
         if (dvmrpcb->routesTimeoutHandle != L7_NULL)
         {
           handleListNodeDelete(dvmrpcb->handle_list,
-                               &dvmrpcb->routesTimeoutHandle);
+                               (L7_uint64 *) &dvmrpcb->routesTimeoutHandle);
         }
         dvmrpcb->age=L7_NULL;
         DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,
                     "%s:%d\n\nStarted dvmrp_routes_timeout every (120sec)\n\n",
                     __FUNCTION__,__LINE__);
         dvmrpcb->routesTimeoutHandle =
         handleListNodeStore(dvmrpcb->handle_list, (void*)dvmrpcb);
 
         if (L7_NULLPTR == (dvmrpcb->age = appTimerAdd(dvmrpcb->timerHandle,
                                                       dvmrp_routes_timeout,
-                                                      (void *)dvmrpcb->routesTimeoutHandle,
+                                                      UINT_TO_PTR(dvmrpcb->routesTimeoutHandle),
                                                       DVMRP_ROUTE_HOLD_TIME,
                                                       "DV-RT3")))
         {
           DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,
                       "%s:%d timer instantiation failed \n", __FUNCTION__,__LINE__);
           DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,
@@ -914,13 +915,13 @@ void dvmrp_neighbor_cleanup (dvmrp_neigh
     pData = pNextData;     
   }
 
   if (nbr->nbrTimeoutHandle != L7_NULL)
   {
     handleListNodeDelete(dvmrpcb->handle_list,
-                         &nbr->nbrTimeoutHandle);
+                         (L7_uint64 *) &nbr->nbrTimeoutHandle);
   }
   
   nbr->timeout =L7_NULLPTR;
   
 
   
Index: src/application/ip_mcast/vendor/dvmrp/dvmrp_main.c
===================================================================
--- src/application/ip_mcast/vendor/dvmrp/dvmrp_main.c	(revision 7772)
+++ src/application/ip_mcast/vendor/dvmrp/dvmrp_main.c	(revision 7778)
@@ -59,13 +59,13 @@ L7_int32 dvmrpAdminModeSet(dvmrp_t *dvmr
               __FUNCTION__,__LINE__);
   dvmrpcb->updateTimerHandle =
   handleListNodeStore(dvmrpcb->handle_list, (void*)dvmrpcb);
 
   if (L7_NULLPTR == (dvmrpcb->timer = appTimerAdd(dvmrpcb->timerHandle,
                                                   dvmrp_timer_update,
-                                                  (void *)dvmrpcb->updateTimerHandle,
+                                                  UINT_TO_PTR(dvmrpcb->updateTimerHandle),
                                                   DVMRP_UPDATE_INTERVAL,
                                                   "DV-UPD")))
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"%s:%d timer instantiation failed \n", 
                 __FUNCTION__,__LINE__);
     DVMRP_DEBUG(DVMRP_DEBUG_TIMERS,"%s:%d timer instantiation failed \n",
@@ -73,13 +73,13 @@ L7_int32 dvmrpAdminModeSet(dvmrp_t *dvmr
     DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,"%s:%d timer instantiation failed \n", 
                 __FUNCTION__,__LINE__);
     appTimerDelete(dvmrpcb->timerHandle, dvmrpcb->timer);
     if (dvmrpcb->updateTimerHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &dvmrpcb->updateTimerHandle);
+                           (L7_uint64 *) &dvmrpcb->updateTimerHandle);
       dvmrpcb->updateTimerHandle = L7_NULL;
     }
     return L7_FAILURE;
   }
 
   DVMRP_DEBUG(DVMRP_DEBUG_ROUTE,
@@ -87,71 +87,71 @@ L7_int32 dvmrpAdminModeSet(dvmrp_t *dvmr
               __FUNCTION__,__LINE__);
   dvmrpcb->routesTimeoutHandle =
   handleListNodeStore(dvmrpcb->handle_list, (void*)dvmrpcb);
 
   if (L7_NULLPTR == (dvmrpcb->age = appTimerAdd(dvmrpcb->timerHandle,
                                                 dvmrp_routes_timeout,
-                                                (void *)dvmrpcb->routesTimeoutHandle,
+                                                UINT_TO_PTR(dvmrpcb->routesTimeoutHandle),
                                                 DVMRP_TIMEOUT_INTERVAL,
                                                 "DV-RT")))
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"%s:%d timer instantiation failed \n", 
                 __FUNCTION__,__LINE__);
     DVMRP_DEBUG(DVMRP_DEBUG_TIMERS,"%s:%d timer instantiation failed \n", 
                 __FUNCTION__,__LINE__);
     appTimerDelete(dvmrpcb->timerHandle, dvmrpcb->age);
     if (dvmrpcb->routesTimeoutHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &dvmrpcb->routesTimeoutHandle);
+                           (L7_uint64 *) &dvmrpcb->routesTimeoutHandle);
       dvmrpcb->routesTimeoutHandle = L7_NULL;
     }
     appTimerDelete(dvmrpcb->timerHandle, dvmrpcb->timer);
     if (dvmrpcb->updateTimerHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &dvmrpcb->updateTimerHandle);
+                           (L7_uint64 *) &dvmrpcb->updateTimerHandle);
       dvmrpcb->updateTimerHandle = L7_NULL;
     }
     dvmrpcb->timer=L7_NULLPTR;
     return L7_FAILURE;
   }
 
   dvmrpcb->pruneExpireHandle =
   handleListNodeStore(dvmrpcb->handle_list, (void*)dvmrpcb);
 
   if (L7_NULLPTR == (dvmrpcb->expire = appTimerAdd(dvmrpcb->timerHandle,
                                                    dvmrp_prune_expire,
-                                                   (void *)dvmrpcb->pruneExpireHandle,
+                                                   UINT_TO_PTR(dvmrpcb->pruneExpireHandle),
                                                    DVMRP_PRUNE_TIMEOUT_INTERVAL,
                                                    "DV-PT")))
   {
     DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,"%s:%d timer instantiation failed \n", 
                 __FUNCTION__,__LINE__);
     DVMRP_DEBUG(DVMRP_DEBUG_TIMERS,"%s:%d prune timer instantiation failed \n",
                 __FUNCTION__,__LINE__);
     appTimerDelete(dvmrpcb->timerHandle, dvmrpcb->age);
     if (dvmrpcb->routesTimeoutHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &dvmrpcb->routesTimeoutHandle);
+                           (L7_uint64 *) &dvmrpcb->routesTimeoutHandle);
       dvmrpcb->routesTimeoutHandle = L7_NULL;
     }
     appTimerDelete(dvmrpcb->timerHandle, dvmrpcb->expire);
     if (dvmrpcb->pruneExpireHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &dvmrpcb->pruneExpireHandle);
+                           (L7_uint64 *) &dvmrpcb->pruneExpireHandle);
       dvmrpcb->pruneExpireHandle = L7_NULL;
     }
     dvmrpcb->expire=L7_NULLPTR;
     appTimerDelete(dvmrpcb->timerHandle, dvmrpcb->timer);
     if (dvmrpcb->updateTimerHandle != L7_NULL)
     {
       handleListNodeDelete(dvmrpcb->handle_list,
-                           &dvmrpcb->updateTimerHandle);
+                           (L7_uint64 *) &dvmrpcb->updateTimerHandle);
       dvmrpcb->updateTimerHandle = L7_NULL;
     }
     dvmrpcb->timer=L7_NULLPTR;
     return L7_FAILURE;
   }
   DVMRP_DEBUG(DVMRP_DEBUG_TIMERS,"%s:%d prune timer instantiation successful\n",
@@ -201,36 +201,36 @@ L7_int32 dvmrpAdminModeReset(dvmrp_t *dv
     dvmrpcb->expire = L7_NULLPTR;
   }
 
   if (dvmrpcb->pruneExpireHandle != L7_NULL)
   {
     handleListNodeDelete(dvmrpcb->handle_list,
-                         &dvmrpcb->pruneExpireHandle);
+                         (L7_uint64 *) &dvmrpcb->pruneExpireHandle);
   }
   
   if(dvmrpcb->age != L7_NULLPTR)
   {
     appTimerDelete(dvmrpcb->timerHandle, dvmrpcb->age);
     dvmrpcb->age = L7_NULLPTR;  
   }
   if (dvmrpcb->routesTimeoutHandle != L7_NULL)
   {
     handleListNodeDelete(dvmrpcb->handle_list,
-                         &dvmrpcb->routesTimeoutHandle);
+                         (L7_uint64 *) &dvmrpcb->routesTimeoutHandle);
   }
   
   if(dvmrpcb->timer != L7_NULLPTR)
   {
     appTimerDelete(dvmrpcb->timerHandle, dvmrpcb->timer);
     dvmrpcb->timer = L7_NULLPTR;  
   }
 
   if (dvmrpcb->updateTimerHandle != L7_NULL)
   {
     handleListNodeDelete(dvmrpcb->handle_list,
-                         &dvmrpcb->updateTimerHandle);
+                         (L7_uint64 *) &dvmrpcb->updateTimerHandle);
   }
   
   DVMRP_DEBUG(DVMRP_DEBUG_APIS,"%s: LEAVING \n",__FUNCTION__);
   return(ret);
 }
 
@@ -371,13 +371,13 @@ L7_RC_t dvmrpEventProcess(L7_uchar8 fami
         entry->cacheRemoveHandle =
         handleListNodeStore(dvmrpcb->handle_list, (void*)entry);
 
         if (L7_NULLPTR == (entry->cacheRemove_timer = 
                            appTimerAdd(dvmrpcb->timerHandle,
                                        dvmrp_Cache_Remove,
-                                       (void *)entry->cacheRemoveHandle,
+                                       UINT_TO_PTR(entry->cacheRemoveHandle),
                                        expiryTime,
                                        "DV-CT")))
         {
           DVMRP_DEBUG(DVMRP_DEBUG_FAILURES,
                       "%s:%d timer instantiation failed \n",
                       __FUNCTION__,__LINE__);
Index: src/application/switching/snooping/core/snooping_ptin_proxytimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_proxytimer.c	(revision 7772)
+++ src/application/switching/snooping/core/snooping_ptin_proxytimer.c	(revision 7778)
@@ -384,35 +384,33 @@ void timerCallback(void *param)
   L7_uint8                  robustnessVariable;
   L7_BOOL                   isInterface;
   L7_uint8                  reportType;
   L7_uint32                 noOfRecords;
   void*                     groupData;
 
-  L7_uint32               timerHandle;
+  L7_uint64               timerHandle;
   snoopPTinProxyTimer_t *pTimerData;  
-  timerHandle = (L7_uint32) param;
+  timerHandle = PTR_TO_UINT64(param);
   osapiSemaTake(timerSem, L7_WAIT_FOREVER);
 
   /* Get timer handler */
   pTimerData = (snoopPTinProxyTimer_t*) handleListNodeRetrieve(timerHandle);
   if (pTimerData == L7_NULLPTR)
   {
     PT_LOG_DEBUG(LOG_CTX_IGMP,"Failed to retrieve handle");
     osapiSemaGive(timerSem);
     return;
   }
 
-  
   /* Check if our handle is OK*/
   if (timerHandle != pTimerData->timerHandle)
   {
     PT_LOG_ERR(LOG_CTX_IGMP,"timerHandle and pTimerData->timerHandle do not match!");
     return;
   }
-    
-
+  
   if (pTimerData->isInterface)
   {
     PT_LOG_TRACE(LOG_CTX_IGMP,"Proxy Interface timer expired (vlan:%u)",
             ((snoopPTinProxyInterface_t *) pTimerData->groupData)->key.vlanId);    
     interfacePtr    = (snoopPTinProxyInterface_t *) pTimerData->groupData;
   }
@@ -532,13 +530,13 @@ L7_RC_t snoop_ptin_proxytimer_start(snoo
     PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
     return L7_FAILURE;
   }
 
   /* Add a new timer */
   pTimer->timer = appTimerAdd(cbTimer, timerCallback,
-                              (void *) pTimer->timerHandle, timeout,
+                              UINT_TO_PTR(pTimer->timerHandle), timeout,
                               "PTIN_TIMER");
   if (pTimer->timer == NULL)
   {
     handleListNodeDelete(handleList, &pTimer->timerHandle);
     pTimer->timerHandle = 0;
     osapiSemaGive(timerSem);
Index: src/application/switching/snooping/core/snooping_timer.c
===================================================================
--- src/application/switching/snooping/core/snooping_timer.c	(revision 7772)
+++ src/application/switching/snooping/core/snooping_timer.c	(revision 7778)
@@ -44,13 +44,13 @@
 * @returns  void
 *
 * @notes    This function is called every timer interval, which is 1 second
 *
 * @end
 *********************************************************************/
-void snoopTimerProcess(L7_uint32 timerCBHandle, snoop_eb_t *pSnoopEB)
+void snoopTimerProcess(L7_uint64 timerCBHandle, snoop_eb_t *pSnoopEB)
 {
   if (timerCBHandle == L7_NULL)
 {
   /* Invoke all the expired timers here */
   appTimerProcess(pSnoopEB->timerCB);
 }
@@ -134,13 +134,13 @@ void snoopTimerUpdate(snoopInfoData_t *s
     }
 
     pTimerData->timerType = SNOOP_GROUP_MEMBERSHIP;
 
     if (appTimerUpdate(snoopEntry->timerCB, &pTimerData->grpTimer,
                        (void *)snoopGroupMembershipExpiry,
-                       (void *)pTimerData->grpTimerHandle, timerValue,
+                       UINT_TO_PTR(pTimerData->grpTimerHandle), timerValue,
                        "snoopGroupMembershipExpiry")
                        != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
              "snoopTimerUpdate: Failed to update group membership timer");
     }
@@ -187,13 +187,13 @@ void snoopTimerUpdate(snoopInfoData_t *s
     }
 
     pTimerData->timerType = SNOOP_MAX_RESPONSE;
 
     if (appTimerUpdate(snoopEntry->timerCB, &pTimerData->grpTimer,
                        (void *)snoopGroupMembershipExpiry,
-                       (void *)pTimerData->grpTimerHandle, timerValue,
+                       UINT_TO_PTR(pTimerData->grpTimerHandle), timerValue,
                        "snoopGroupMembershipExpiry") != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
              "snoopTimerUpdate: Failed to update group membership timer");
     }
 
@@ -217,13 +217,13 @@ void snoopTimerUpdate(snoopInfoData_t *s
                       avlSearchLVL7(&pSnoopCB->snoopMrtrTimerAvlTree, &key,
                                      L7_MATCH_EXACT);
     if (pmrtrTimerData != L7_NULLPTR)
     {
       if (appTimerUpdate(pSnoopCB->snoopExec->timerCB, &pmrtrTimerData->mrtrTimer,
                          (void *)snoopMrtrExpiry,
-                         (void *)pmrtrTimerData->mrtrTimerHandle, timerValue,
+                         UINT_TO_PTR(pmrtrTimerData->mrtrTimerHandle), timerValue,
                          "snoopMrtrExpiry") != L7_SUCCESS)
       {
         L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
                "snoopTimerUpdate: Failed to update mrtr timer ");
       }
       SNOOP_TRACE(SNOOP_DEBUG_TIMER, pSnoopCB->family, \
@@ -318,15 +318,15 @@ void snoopTimerStop(snoopInfoData_t *sno
 
     if (pSnoopMrtrTimerData != L7_NULLPTR)
     {
       if (pSnoopMrtrTimerData->mrtrTimer != L7_NULL)
       {
         if (snoopTimerDestroy(pSnoopCB->snoopExec->timerCB,
-                               &pSnoopMrtrTimerData->mrtrTimer,
-                                &pSnoopMrtrTimerData->mrtrTimerHandle)
-                                != L7_SUCCESS)
+                              &pSnoopMrtrTimerData->mrtrTimer,
+                              &pSnoopMrtrTimerData->mrtrTimerHandle)
+                              != L7_SUCCESS)
         {
            L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
                   "snoopTimerStop: Failed to stop mrtr timer");
         }
       } /* timer running ? */
       if (avlDeleteEntry(&pSnoopCB->snoopMrtrTimerAvlTree, pSnoopMrtrTimerData)
@@ -403,14 +403,14 @@ L7_RC_t snoopTimerStart(snoopInfoData_t
        bufferPoolFree(pSnoopCB->snoopExec->snoopTimerBufferPoolId, (L7_uchar8 *)pTimerData);
        L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
               "snoopTimerStart: Could not get the handle node to store the timer data.");
        return L7_FAILURE;
      }
      pTimerData->grpTimer = appTimerAdd(snoopEntry->timerCB, snoopGroupMembershipExpiry,
-                                     (void *)pTimerData->grpTimerHandle, timerValue,
-                                     "SN-GME");
+                                        UINT_TO_PTR(pTimerData->grpTimerHandle), timerValue,
+                                        "SN-GME");
      if(pTimerData->grpTimer == NULL)
      {
         /* Free the previously allocated bufferpool */
         bufferPoolFree(pSnoopCB->snoopExec->snoopTimerBufferPoolId, (L7_uchar8 *)pTimerData);
         L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
                "snoopTimerStart: Could not Start the Group timer.");
@@ -487,14 +487,14 @@ L7_RC_t snoopTimerStart(snoopInfoData_t
       L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
              "snoopTimerStart: Could not get the handle node to store the mrtr timer data.");
       return L7_FAILURE;
     }
 
     pData->mrtrTimer = appTimerAdd(pSnoopCB->snoopExec->timerCB, snoopMrtrExpiry,
-                               (void *)pData->mrtrTimerHandle, timerValue,
-                               "SN-MRTE");
+                                   UINT_TO_PTR(pData->mrtrTimerHandle), timerValue,
+                                   "SN-MRTE");
     if(pData->mrtrTimer == NULL)
     {
       /* Free the previously allocated tree node */
       (void)avlDeleteEntry(&pSnoopCB->snoopMrtrTimerAvlTree, pData);
       L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
              "snoopTimerStart: Could not Start the mrtr timer.");
@@ -522,13 +522,13 @@ L7_RC_t snoopTimerStart(snoopInfoData_t
 *
 * @end
 *************************************************************************/
 void snoopMrtrExpiry(void *param)
 {
   snoopMrtrTimerData_t *pTimerData;
-  L7_uint32             handle = (L7_uint32)param;
+  L7_uint64             handle = PTR_TO_UINT64(param);
   snoop_cb_t           *pSnoopCB = L7_NULLPTR;
   snoopOperData_t      *pSnoopOperEntry  = L7_NULLPTR;
 
   pTimerData = (snoopMrtrTimerData_t *)handleListNodeRetrieve(handle);
   if (pTimerData == L7_NULLPTR)
   {
@@ -577,13 +577,13 @@ void snoopMrtrExpiry(void *param)
 *
 * @end
 *************************************************************************/
 void snoopGroupMembershipExpiry(void *param)
 {
   snoopGrpTimerData_t *pTimerData;
-  L7_uint32          handle = (L7_uint32)param;
+  L7_uint64          handle = PTR_TO_UINT64(param);
   L7_ushort16        shortVid;
   L7_uchar8          mac[L7_MAC_ADDR_LEN];
   snoop_cb_t        *pSnoopCB;
 
   pTimerData = (snoopGrpTimerData_t *)handleListNodeRetrieve(handle);
   if (pTimerData == L7_NULLPTR)
@@ -718,13 +718,13 @@ L7_int32 snoopTimerDataCmp(void *p, void
 *
 * @comments none
 *
 * @end
 *************************************************************************/
 L7_RC_t  snoopTimerDestroy(L7_APP_TMR_CTRL_BLK_t timerCB,
-                           L7_APP_TMR_HNDL_t *timer, L7_uint32 *handle)
+                           L7_APP_TMR_HNDL_t *timer, L7_uint64 *handle)
 {
   snoop_eb_t  *pSnoopEB;
 
   pSnoopEB = snoopEBGet();
   /* Delete the apptimer node */
   (void)appTimerDelete(timerCB, *timer);
@@ -824,15 +824,15 @@ L7_RC_t snoopQuerierTimerStart(snoopOper
              "snoopQuerierTimerStart: Could not get the handle node to store the expiry timer data.");
       return L7_FAILURE;
     }
 
     if ((snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.querierExpiryTimer
           = appTimerAdd(pSnoopCB->snoopExec->timerCB, snoopQuerierExpiry,
-                        (void *)snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.querierExpiryTimerHandle,
-                         interval,
-                         "SN-QRE"))
+                        UINT_TO_PTR(snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.querierExpiryTimerHandle),
+                        interval,
+                        "SN-QRE"))
           == L7_NULL)
     {
       L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
              "snoopQuerierTimerStart: could not start Querier Expiry timer for vlan %d family %d\n",
               snoopOperEntry->vlanId, pSnoopCB->family);
     }
@@ -858,13 +858,13 @@ L7_RC_t snoopQuerierTimerStart(snoopOper
              "snoopQuerierTimerStart: Could not get the handle node to store the expiry timer data.");
       return L7_FAILURE;
     }
 
     if ((snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.queryIntervalTimer
           = appTimerAdd(pSnoopCB->snoopExec->timerCB, snoopQuerierQueryExpiry,
-                        (void *)snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.queryIntervalTimerHandle,
+                        UINT_TO_PTR(snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.queryIntervalTimerHandle),
                         interval,
                         "SN-QQE")) == L7_NULL
         )
     {
       L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
              "snoopQuerierTimerStart: could not start Query interval for vlan %d family %d",
@@ -919,13 +919,13 @@ L7_RC_t snoopQuerierTimerUpdate(snoopOpe
              "snoopQuerierTimerUpdate: Querier Expiry Timer not running");
     }
 
     if (appTimerUpdate(pSnoopCB->snoopExec->timerCB,
                        &snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.querierExpiryTimer,
                        (void *)snoopQuerierExpiry,
-                       (void *)snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.querierExpiryTimerHandle,
+                       UINT_TO_PTR(snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.querierExpiryTimerHandle),
                        interval,
                        "snoopQuerierExpiry") != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
              "snoopQuerierTimerUpdate: Failed to update Querier Expiry timer for vlan %d family %d",
               snoopOperEntry->vlanId, pSnoopCB->family);
@@ -943,13 +943,13 @@ L7_RC_t snoopQuerierTimerUpdate(snoopOpe
              "snoopQuerierTimerUpdate: Query Interval Timer not running\n");
     }
 
     if (appTimerUpdate(pSnoopCB->snoopExec->timerCB,
                        &snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.queryIntervalTimer,
                       (void *)snoopQuerierQueryExpiry,
-                      (void *)snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.queryIntervalTimerHandle,
+                      UINT_TO_PTR(snoopOperEntry->snoopQuerierInfo.snoopQuerierTimerData.queryIntervalTimerHandle),
                       interval,
                       "snoopQuerierQueryExpiry") != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
              "snoopQuerierTimerUpdate: Failed to update Query interval for vlan %d family %d\n",
               snoopOperEntry->vlanId, pSnoopCB->family);
@@ -1061,13 +1061,13 @@ L7_RC_t snoopQuerierTimerStop(snoopOperD
 *************************************************************************/
 void snoopQuerierExpiry(void *param)
 {
   snoopOperData_t *pSnoopOperEntry;
   snoop_cb_t      *pSnoopCB = L7_NULLPTR;
 
-  pSnoopOperEntry = (snoopOperData_t *)handleListNodeRetrieve((L7_uint32)param);
+  pSnoopOperEntry = (snoopOperData_t *)handleListNodeRetrieve(PTR_TO_UINT64(param));
   if (pSnoopOperEntry == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
            "snoopQuerierExpiry: Failed to retrieve handle");
     return;
   }
@@ -1117,13 +1117,13 @@ void snoopQuerierExpiry(void *param)
 *************************************************************************/
 void snoopQuerierQueryExpiry(void *param)
 {
   snoopOperData_t *pSnoopOperEntry;
   snoop_cb_t      *pSnoopCB = L7_NULLPTR;
 
-  pSnoopOperEntry = (snoopOperData_t *)handleListNodeRetrieve((L7_uint32)param);
+  pSnoopOperEntry = (snoopOperData_t *)handleListNodeRetrieve(PTR_TO_UINT64(param));
   if (pSnoopOperEntry == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
            "snoopQuerierQueryExpiry: Failed to retrieve handle");
     return;
   }
Index: src/application/switching/snooping/core/include/snooping_util.h
===================================================================
--- src/application/switching/snooping/core/include/snooping_util.h	(revision 7772)
+++ src/application/switching/snooping/core/include/snooping_util.h	(revision 7778)
@@ -99,13 +99,13 @@ void snoopNotifyL3Mcast(L7_uchar8 *destM
 void snoopVlanNotifyL3Mcast(L7_uint32 vlanId, L7_BOOL snoopVlanOperState);
 L7_BOOL snoopVlanOperationalStateGet(L7_uint32 vlanId, L7_uchar8 family);
 L7_uchar8 snoopGetEndianess(void);
 /*********************************************************************
   Timer Routines
 *********************************************************************/
-void snoopTimerProcess(L7_uint32 timerCBHandle, snoop_eb_t *pSnoopEB);
+void snoopTimerProcess(L7_uint64 timerCBHandle, snoop_eb_t *pSnoopEB);
 void snoopTimerUpdate(snoopInfoData_t *snoopEntry, L7_uint32 intIfNum,
                          L7_uint32 vlanId, snoop_interface_type_t timerType,
                          L7_uint32 timerValue, struct snoop_cb_s *pSnoopCB);
 void     snoopTimerStop(snoopInfoData_t *snoopEntry, L7_uint32 intIfNum,
                          L7_uint32 vlanId, snoop_interface_type_t timerType,
                          struct snoop_cb_s *pSnoopCB);
@@ -114,13 +114,13 @@ L7_RC_t  snoopTimerStart(snoopInfoData_t
                          struct snoop_cb_s *pSnoopCB);
 void     snoopGroupMembershipExpiry(void *param);
 void     snoopMrtrExpiry(void *param);
 L7_RC_t  snoopTimerDataDestroy(L7_sll_member_t *ll_member);
 L7_int32 snoopTimerDataCmp(void *p, void *q, L7_uint32 key);
 L7_RC_t  snoopTimerDestroy(L7_APP_TMR_CTRL_BLK_t timerCB, L7_APP_TMR_HNDL_t *timer, 
-                           L7_uint32 *handle);
+                           L7_uint64 *handle);
 L7_BOOL snoop_is_timer_running(snoopInfoData_t *snoopEntry, L7_uint32 intIfNum,
                                L7_uint32 vlanId, snoop_interface_type_t timerType,
                                snoop_cb_t *pSnoopCB);
 void     snoopMacToString(L7_uchar8 *macAddr, L7_uchar8 *macAddrStr);
 /*************************************************************** 
  IGMP Statistics  
Index: src/application/switching/snooping/core/include/snooping.h
===================================================================
--- src/application/switching/snooping/core/include/snooping.h	(revision 7772)
+++ src/application/switching/snooping/core/include/snooping.h	(revision 7778)
@@ -170,17 +170,17 @@ typedef enum
 
 /* Dynamically learnt querier information */
 typedef struct snoopQuerierTimerData_s
 {
   /* Querier Expiry Timer */
   L7_APP_TMR_HNDL_t      querierExpiryTimer;
-  L7_uint32              querierExpiryTimerHandle;
+  L7_uint64              querierExpiryTimerHandle;
 
   /* Query Interval Timer */
   L7_APP_TMR_HNDL_t      queryIntervalTimer;
-  L7_uint32              queryIntervalTimerHandle;
+  L7_uint64              queryIntervalTimerHandle;
 } snoopQuerierTimerData_t;
 
 typedef struct snoopQuerierInfo_s
 {
   snoopQuerierState_t snoopQuerierOperState; /* Snooping querier state */
   /* True Querier information. When the snooping querier is in
@@ -229,13 +229,13 @@ typedef struct snoopGrpTimerData_s
   L7_sll_member_t          *next;
   struct snoopInfoData_s   *snoopEntry; /* To reference vidmac and snoopMemberList
                                     */
   L7_uint32                 intIfNum;
   L7_uchar8                 timerType;
   L7_APP_TMR_HNDL_t         grpTimer;
-  L7_uint32                 grpTimerHandle;
+  L7_uint64                 grpTimerHandle;
 } snoopGrpTimerData_t;
 
 /* Mrouter Timer Node Structure */
 typedef struct snoopMrtrTimerDataKey_s
 {
 #ifndef L7_PRODUCT_SMARTPATH
@@ -249,13 +249,13 @@ typedef struct snoopMrtrTimerDataKey_s
 
 typedef struct snoopMrtrTimerData_s
 {
   snoopMrtrTimerDataKey_t  snoopMrtrTimerDataKey;
   void                    *cbHandle;
   L7_APP_TMR_HNDL_t        mrtrTimer;
-  L7_uint32                mrtrTimerHandle;
+  L7_uint64                mrtrTimerHandle;
   void                    *next;
 } snoopMrtrTimerData_t;
 
 /* PTin added: IGMP snooping */
 #if 1
 #define PTIN_SNOOP_CLIENT_MASK_UNIT              (sizeof(L7_uint32) * 8)
@@ -337,13 +337,13 @@ typedef struct
 
   L7_uint16             interfaceIdx;
   snoopPTinL3InfoData_t *groupData;
 
   L7_uchar8         timerType;
   L7_APP_TMR_HNDL_t timer;
-  L7_uint32         timerHandle;
+  L7_uint64         timerHandle;
 } snoopPTinL3Querytimer_t;
 
 typedef struct
 {
   L7_sll_member_t       *next;
 
@@ -352,25 +352,25 @@ typedef struct
   snoopPTinL3InfoData_t *groupData;
 
   L7_uint8              isRunning;
 
   L7_uchar8             timerType;
   L7_APP_TMR_HNDL_t     timer;
-  L7_uint32             timerHandle;
+  L7_uint64             timerHandle;
 } snoopPTinL3Sourcetimer_t;
 
 typedef struct
 {
   L7_sll_member_t       *next;
 
   L7_uint16             interfaceIdx;
   snoopPTinL3InfoData_t *groupData;
 
   L7_uchar8             timerType;
   L7_APP_TMR_HNDL_t     timer;
-  L7_uint32             timerHandle;
+  L7_uint64             timerHandle;
 } snoopPTinL3Grouptimer_t;
 
 typedef struct
 {
   L7_uint32                clients[PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE];
   L7_inet_addr_t           sourceAddr;
@@ -452,13 +452,13 @@ typedef struct snoopPTinProxyTimer_s
   L7_BOOL                            isRunning;
 
   L7_BOOL                            isInterface;
 
   L7_uchar8                          timerType;
   L7_APP_TMR_HNDL_t                  timer;
-  L7_uint32                          timerHandle;
+  L7_uint64                          timerHandle;
   
 } snoopPTinProxyTimer_t;
 
 typedef struct snoopPTinProxySourceKey_s
 {  
 #if 0
@@ -906,13 +906,13 @@ typedef struct snoopL3McastChangeParms_s
   L7_int32       srcIntfVlan; /* -1 if it is port based rtr interface */
   L7_VLAN_MASK_t outVlanRtrIntfMask;
 } snoopL3McastChangeParms_t;
 
 typedef struct snoopTimerParams_s
 {
-  L7_uint32 timerCBHandle;
+  L7_uint64 timerCBHandle;
 } snoopTimerParams_t;
 #define SNOOP_TIMER_MSG_SIZE         sizeof(snoopTimerParams_t)
 
 /* Snoop Event Message format */
 typedef struct snoopMgmtMsg_s
 {
Index: src/application/switching/snooping/core/snooping_ptin_grouptimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_grouptimer.c	(revision 7772)
+++ src/application/switching/snooping/core/snooping_ptin_grouptimer.c	(revision 7778)
@@ -360,28 +360,24 @@ void timerCallback(void *param)
 {
   char                    debug_buf[46];
   snoopPTinL3Interface_t  *interfacePtr;
   L7_uint32               intIfNum;
 //L7_uint32               vlanId;
 //L7_inet_addr_t          mcastGroupAddr;
-
-  L7_uint32               timerHandle;
+  L7_uint64               timerHandle;
   snoopPTinL3Grouptimer_t *pTimerData;
   snoopPTinL3Source_t     *sourcePtr;
   snoopPTinL3InfoData_t*  groupData;
-  
 #if 0
   L7_uint8              recordType=L7_IGMP_BLOCK_OLD_SOURCES;
   snoopPTinProxyGroup_t* groupPtr=L7_NULLPTR;       
   snoopPTinProxyInterface_t* proxyInterfacePtr=L7_NULLPTR;
   L7_uint32 noOfRecords=0;
 #endif
 
-
-
-  timerHandle = (L7_uint32) param;
+  timerHandle = PTR_TO_UINT64(param);
   osapiSemaTake(timerSem, L7_WAIT_FOREVER);
 
   /* Get timer handler */
   pTimerData = (snoopPTinL3Grouptimer_t*) handleListNodeRetrieve(timerHandle);
   if (pTimerData == L7_NULLPTR)
   {
@@ -573,13 +569,13 @@ L7_RC_t snoop_ptin_grouptimer_start(snoo
     PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
     return L7_FAILURE;
   }
 
   /* Add a new timer */
   pTimer->timer = appTimerAdd(cbTimer, timerCallback,
-                              (void *) pTimer->timerHandle, timeout,
+                              UINT_TO_PTR(pTimer->timerHandle), timeout,
                               "PTIN_TIMER");
   if (pTimer->timer == NULL)
   {
     handleListNodeDelete(handleList, &pTimer->timerHandle);
     pTimer->timerHandle = 0;
     osapiSemaGive(timerSem);
Index: src/application/switching/snooping/core/snooping_ptin_sourcetimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_sourcetimer.c	(revision 7772)
+++ src/application/switching/snooping/core/snooping_ptin_sourcetimer.c	(revision 7778)
@@ -364,39 +364,35 @@ L7_RC_t timerDataDestroy (L7_sll_member_
  *************************************************************************/
 void timerCallback(void *param)
 {
   L7_uint32                intIfNum, sourceIdx;
   char                     debug_buf[IPV6_DISP_ADDR_LEN],debug_buf2[IPV6_DISP_ADDR_LEN];
   snoopPTinL3Interface_t   *interfacePtr;
-  L7_uint32                timerHandle;
+  L7_uint64                timerHandle;
   snoopPTinL3Sourcetimer_t *pTimerData;
   snoopPTinL3Source_t      *sourcePtr;
   snoopPTinL3InfoData_t*   groupData;
-
-
 #if 0
   L7_uint8            recordType=L7_IGMP_BLOCK_OLD_SOURCES;
   snoopPTinProxyGroup_t* groupPtr=L7_NULLPTR;
   snoopPTinProxyInterface_t* proxyInterfacePtr=L7_NULLPTR;
   L7_uint32 noOfRecords=0;
 #endif
 
-  timerHandle = (L7_uint32) param;
+  timerHandle = PTR_TO_UINT64(param);
   osapiSemaTake(timerSem, L7_WAIT_FOREVER);
 
   /* Get timer handler */
   pTimerData = (snoopPTinL3Sourcetimer_t*) handleListNodeRetrieve(timerHandle);
   if (pTimerData == L7_NULLPTR)
   {
     PT_LOG_DEBUG(LOG_CTX_IGMP,"Failed to retrieve handle");
     osapiSemaGive(timerSem);
     return;
   }
 
-
-
   //Save grouptimer's internal data
   groupData    = pTimerData->groupData;
   intIfNum     = pTimerData->interfaceIdx;
   sourceIdx    = pTimerData->sourceIdx;
   interfacePtr = &groupData->interfaces[intIfNum];
   sourcePtr    = &groupData->interfaces[intIfNum].sources[sourceIdx];
@@ -571,13 +567,13 @@ L7_RC_t snoop_ptin_sourcetimer_start(sno
     PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
     return L7_FAILURE;
   }
 
   /* Add a new timer */
   pTimer->timer = appTimerAdd(cbTimer, timerCallback,
-                              (void *) pTimer->timerHandle, timeout,
+                              UINT_TO_PTR(pTimer->timerHandle), timeout,
                               "PTIN_TIMER");
   if (pTimer->timer == NULL)
   {
     handleListNodeDelete(handleList, &pTimer->timerHandle);
     pTimer->timerHandle = 0;
     osapiSemaGive(timerSem);
Index: src/application/switching/snooping/core/snooping_cnfgr.c
===================================================================
--- src/application/switching/snooping/core/snooping_cnfgr.c	(revision 7772)
+++ src/application/switching/snooping/core/snooping_cnfgr.c	(revision 7778)
@@ -1669,14 +1669,14 @@ L7_RC_t snoopEBInit(void)
   }
 
   for (idx = 0; idx < SNOOP_ENTRY_TIMER_BLOCKS_COUNT; idx++)
   {
     /* Use 1 to SNOOP_ENTRY_TIMER_BLOCKS_COUNT for snoopEntryCBs and 0 for snoopEB->timerCB */
     pSnoopEB->snoopEntryTimerCBList[idx].timerCB = appTimerInit(L7_SNOOPING_COMPONENT_ID, snoopTimerExpiryHdlr,
-                                                       (void *)(idx + 1), SNOOP_TIMER_INTERVAL,
-                                                        pSnoopEB->appTimerBufferPoolId);
+                                                                UINT_TO_PTR(idx + 1), SNOOP_TIMER_INTERVAL,
+                                                                pSnoopEB->appTimerBufferPoolId);
     if (pSnoopEB->snoopEntryTimerCBList[idx].timerCB == L7_NULLPTR)
     {
       L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_SNOOPING_COMPONENT_ID,
              "snoopEBInit: snoopEntry App Timer[%d] Initialization Failed.\n", idx);
       return L7_FAILURE;
     }
Index: src/application/switching/snooping/core/snooping_ptin_querytimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_querytimer.c	(revision 7772)
+++ src/application/switching/snooping/core/snooping_ptin_querytimer.c	(revision 7778)
@@ -341,18 +341,18 @@ L7_RC_t timerDataDestroy (L7_sll_member_
  *************************************************************************/
 void timerCallback(void *param)
 {
   char                    debug_buf[46];
   snoopPTinL3Interface_t  *interfacePtr;
   L7_uint32               interfaceIdx;
-  L7_uint32               timerHandle;
+  L7_uint64               timerHandle;
   snoopPTinL3Querytimer_t *pTimerData;
   snoopPTinL3Source_t     *sourcePtr;
   snoopPTinL3InfoData_t*  groupData;
 
-  timerHandle = (L7_uint32) param;
+  timerHandle = PTR_TO_UINT64(param);
   osapiSemaTake(timerSem, L7_WAIT_FOREVER);
 
   /* Get timer handler */
   pTimerData = (snoopPTinL3Querytimer_t*) handleListNodeRetrieve(timerHandle);
   if (pTimerData == L7_NULLPTR)
   {
@@ -476,13 +476,13 @@ L7_RC_t snoop_ptin_querytimer_start(snoo
     PT_LOG_ERR(LOG_CTX_IGMP,"Could not get the handle node to store the timer data.");
     return L7_FAILURE;
   }
 
   /* Add a new timer */
   pTimer->timer = appTimerAdd(cbTimer, timerCallback,
-                              (void *) pTimer->timerHandle, timeout,
+                              UINT_TO_PTR(pTimer->timerHandle), timeout,
                               "PTIN_TIMER");
   if (pTimer->timer == NULL)
   {
     handleListNodeDelete(handleList, &pTimer->timerHandle);
     pTimer->timerHandle = 0;
     osapiSemaGive(timerSem);
Index: src/application/switching/snooping/core/snooping_ctrl.c
===================================================================
--- src/application/switching/snooping/core/snooping_ctrl.c	(revision 7772)
+++ src/application/switching/snooping/core/snooping_ctrl.c	(revision 7778)
@@ -2119,13 +2119,13 @@ void snoopTimerExpiryHdlr(L7_APP_TMR_CTR
 {
   L7_int32       rc = L7_SUCCESS;
   snoopTimerParams_t msg;
   snoop_eb_t    *pSnoopEB = L7_NULLPTR;
 
   pSnoopEB = snoopEBGet();
-  msg.timerCBHandle = (L7_uint32)ptrData;
+  msg.timerCBHandle = PTR_TO_UINT64(ptrData);
 
 #if 0
   if ((pSnoopEB = (snoop_eb_t *)ptrData) == L7_NULLPTR)
     return;
 #endif
 #if (!PTIN_SNOOP_USE_MGMD)
Index: src/application/switching/snooping/core/snooping_ptin_util.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_util.c	(revision 7772)
+++ src/application/switching/snooping/core/snooping_ptin_util.c	(revision 7778)
@@ -45,13 +45,13 @@ static L7_RC_t snoopPTinReportSend(L7_ui
 static snoopPTinProxyGroup_t* snoopPTinGroupRecordIncrementTransmissions(L7_uint32 noOfRecords,snoopPTinProxyGroup_t* groupPtr, L7_uint32* newNoOfRecords);
 
 static L7_RC_t snoopPTinGroupRecordSourceIncrementTransmissions(snoopPTinProxyGroup_t* groupPtr);
 
 static snoopPTinProxyGroup_t* snoopPTinBuildCSR(snoopPTinProxyInterface_t *interfacePtr, L7_uint32 *noOfRecords,L7_uint8 robustnessVariable);
 
-void     snoopPTinQuerySend        (L7_uint32 arg1);
+void     snoopPTinQuerySend(L7_uint64 arg1);
 
 /*********************************************************************
  * @purpose Add a new client to the L2 tables
  *
  * @returns  L7_SUCCESS
  * @returns  L7_FAILURE
@@ -850,24 +850,24 @@ L7_RC_t snoopPTinPacketBuild(L7_uint32 v
 /*********************************************************************
  * @purpose Send LMQC Group or Group/Source Speficic Queries
  *
  * @param   arg1  Pointer to a snoopPTinQueryData_t structure
  *
  *********************************************************************/
-void snoopPTinQuerySend(L7_uint32 arg1)
+void snoopPTinQuerySend(L7_uint64 arg1)
 {
   L7_uchar8             igmpFrame[L7_MAX_FRAME_SIZE]={0};
   L7_uint32             igmpFrameLength=0;
   snoopOperData_t       *pSnoopOperEntry;
   L7_RC_t               rc = L7_SUCCESS;
   mgmdSnoopControlPkt_t mcastPacket;
   snoopPTinQueryData_t  *queryData;
   snoop_cb_t            *pSnoopCB;
   ptin_IgmpProxyCfg_t   igmpCfg;
 
-  queryData = (snoopPTinQueryData_t *) arg1;
+  queryData = (snoopPTinQueryData_t *) UINT_TO_PTR(arg1);
 
   /* Validate arguments */
   if (queryData->vlanId < PTIN_VLAN_MIN || queryData->vlanId > PTIN_VLAN_MAX)
   {
     PT_LOG_DEBUG(LOG_CTX_IGMP, "Invalid arguments");
     return;
@@ -944,13 +944,13 @@ void snoopPTinQuerySend(L7_uint32 arg1)
   --queryData->retransmissions;
 
   /* If retransmissions > 0, schedule another Group-Specific Query message. Otherwise free the position in the query buffer */
   if (queryData->retransmissions > 0)
   {
     osapiTimerAdd((void *) snoopPTinQuerySend,
-                  (L7_uint32) queryData,
+                  PTR_TO_UINT64(queryData),
                   0,
                   SNOOP_MAXRESP_INTVL_ROUND(igmpCfg.querier.last_member_query_interval * 1000, SNOOP_IGMP_FP_DIVISOR),
                   &queryData->queryTimer);
   }
   else
   {
Index: src/application/switching/spanning_tree/dot1s/core/dot1s_transport.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/core/dot1s_transport.c	(revision 7772)
+++ src/application/switching/spanning_tree/dot1s/core/dot1s_transport.c	(revision 7778)
@@ -38,13 +38,13 @@ dot1s_helper_msg_t *dot1sTransportPduDb
 
 L7_INTF_MASK_t dot1sPduChangedMask;
 
 
 /* Global copy for the message . At any time we are going to use only one*/
 static dot1s_helper_data_msg_t txMsg;
-static L7_uint32 dot1s_transport_task_id = 0;
+static L7_uint64 dot1s_transport_task_id = 0;
 
 /*********************************************************************
 * @purpose  Initializes the dot1s transport subsystem.
 *
 * @param    None
 *
Index: src/application/switching/spanning_tree/dot1s/core/dot1s_cfg.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/core/dot1s_cfg.c	(revision 7772)
+++ src/application/switching/spanning_tree/dot1s/core/dot1s_cfg.c	(revision 7778)
@@ -53,14 +53,14 @@ const L7_uchar8 dot1sConfigDigSigKey[] =
 {0x13,0xAC,0x06,0xA6,0x2E,0x47,0xFD,0x51,0xF9,0x5D,0x2B,0xA2,0x43,0xCD,0x03,0x46
 };
 void *dot1sTaskSyncSema = L7_NULLPTR;
 void *dot1s_queue = L7_NULLPTR;  /* reference to the dot1s message queue */
 void *dot1s_stateCB_queue = L7_NULLPTR;
 void *dot1s_signal_queue = L7_NULLPTR;
-static L7_uint32 dot1s_task_id = 0;
-static L7_uint32 dot1s_timer_task_id = 0;
+static L7_uint64 dot1s_task_id = 0;
+static L7_uint64 dot1s_timer_task_id = 0;
 extern dot1sCnfgrState_t dot1sCnfgrState;
 static nimConfigID_t dot1sConfigId[L7_DOT1S_MAX_INTERFACE_COUNT];
 
 /*********************************************************************
 * @purpose  Saves dot1s configuration
 *
Index: src/application/switching/spanning_tree/dot1s/core/dot1s_helper.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/core/dot1s_helper.c	(revision 7772)
+++ src/application/switching/spanning_tree/dot1s/core/dot1s_helper.c	(revision 7778)
@@ -19,13 +19,13 @@
 #include "dot1s_debug.h"
 #include "sim_pts_api.h"
 #include "dtl_helper.h"
 
 dot1s_helper_msg_t *dot1sHelperLocalDb = L7_NULLPTR;
 void *dot1s_helper_queue; /* reference to the helper message queue */
-static L7_uint32 dot1s_helper_task_id = 0;
+static L7_uint64 dot1s_helper_task_id = 0;
 L7_uint32 dot1sUserHandle = ~0;
 
 L7_BOOL dot1sIsPortLag(nimUSP_t *usp)
 {
   return (usp->slot == L7_LAG_SLOT_NUM);
 }
@@ -104,17 +104,17 @@ L7_RC_t dot1sHelperInit()
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1S_COMPONENT_ID,
             "dot1sInit: msgQueue creation error.\n");
     return L7_FAILURE;
   }
 
   /* task create*/
-  dot1s_helper_task_id = (L7_uint32)osapiTaskCreate("dot1s_helper_task",
-                                                    (void *)dot1sHelperTask, 0, 0,
-                                                    L7_DEFAULT_STACK_SIZE,
-                                                    L7_DOT1S_DEFAULT_DOT1S_TIMER_TASK_PRI,
-                                                    L7_DEFAULT_TASK_SLICE);
+  dot1s_helper_task_id = osapiTaskCreate("dot1s_helper_task",
+                                         (void *)dot1sHelperTask, 0, 0,
+                                         L7_DEFAULT_STACK_SIZE,
+                                         L7_DOT1S_DEFAULT_DOT1S_TIMER_TASK_PRI,
+                                         L7_DEFAULT_TASK_SLICE);
 
   if (dot1s_helper_task_id == L7_ERROR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1S_COMPONENT_ID,
             "dot1sInit: timer task creation error.\n");
     return L7_FAILURE;
Index: src/application/switching/spanning_tree/dot1s/core/dot1s_ih.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/core/dot1s_ih.c	(revision 7772)
+++ src/application/switching/spanning_tree/dot1s/core/dot1s_ih.c	(revision 7778)
@@ -2312,15 +2312,15 @@ L7_BOOL dot1sIsPortDiscarding(L7_uint32
 *            The critical section with in the semaphore protection must be
 *            short
 *           
 *
 * @end
 *********************************************************************/
-void dot1sStateSetTimerExpired(L7_uint32 intIfNum, L7_uint32 state)
+void dot1sStateSetTimerExpired(L7_uint64 intIfNum, L7_uint64 state)
 {
-  dot1sIssueCmd(dot1sStateSetError, intIfNum, L7_NULL, L7_NULLPTR);
+  dot1sIssueCmd(dot1sStateSetError, (L7_int32) intIfNum, L7_NULL, L7_NULLPTR);
 }
 
 /*********************************************************************
 * @purpose  The dot1s state set timer has expired disable the affected interface
 *           
 *          
Index: src/application/switching/spanning_tree/dot1s/core/dot1s_txrx.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/core/dot1s_txrx.c	(revision 7772)
+++ src/application/switching/spanning_tree/dot1s/core/dot1s_txrx.c	(revision 7778)
@@ -202,14 +202,14 @@ L7_RC_t dot1sBpduReceive(L7_netBufHandle
 *************************************************************************/
 L7_RC_t dot1sTxRxInit(void)
 {
   L7_RC_t rc;
   sysnetNotifyEntry_t snEntry;
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register dot1sBpduReceive related to type=%u: 0x%08x",
-           SYSNET_MAC_ENTRY, (L7_uint32) dot1sBpduReceive);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register dot1sBpduReceive related to type=%u: %p",
+              SYSNET_MAC_ENTRY, dot1sBpduReceive);
 
   /*Register the pdu receive function with sysnet utility*/
   strcpy(snEntry.funcName, "dot1sPduReceive");
   snEntry.notify_pdu_receive = dot1sBpduReceive;
   snEntry.type = SYSNET_MAC_ENTRY;
   memcpy(snEntry.u.macAddr, dot1sBpduMulticastMacAddr, L7_MAC_ADDR_LEN);
Index: src/application/switching/spanning_tree/dot1s/core/dot1s_debug.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/core/dot1s_debug.c	(revision 7772)
+++ src/application/switching/spanning_tree/dot1s/core/dot1s_debug.c	(revision 7778)
@@ -1874,13 +1874,13 @@ L7_RC_t dot1sDebugEventsTrace(DOT1S_PORT
     if (dot1sEventTraceHdl != ~0)
     {
 
       TRACE_BEGIN(dot1sEventTraceHdl, L7_DOT1S_COMPONENT_ID);
       TRACE_ENTER_2BYTE(osapiHtons(traceId));
       TRACE_ENTER_4BYTE(osapiHtonl((L7_ulong32)osapiTimeMillisecondsGet()));
-      TRACE_ENTER_4BYTE(osapiHtonl(osapiTaskIdSelf()));
+      TRACE_ENTER_4BYTE(osapiHtonl((L7_uint32) osapiTaskIdSelf()));
      /* End Trace Header*/
 
 
 
       TRACE_ENTER_4BYTE(osapiHtonl((L7_ulong32)depth));
       TRACE_ENTER_4BYTE(osapiHtonl((L7_ulong32)dot1sEvent));
@@ -2152,13 +2152,13 @@ L7_RC_t dot1sNsfTrace(L7_uchar8 *pString
   if (dot1sNsfTraceHdl != ~0)
   {
 
     TRACE_BEGIN(dot1sNsfTraceHdl, L7_DOT1S_COMPONENT_ID);
     TRACE_ENTER_2BYTE(osapiHtons(traceId));
     TRACE_ENTER_4BYTE(osapiHtonl((L7_ulong32)osapiTimeMillisecondsGet()));
-    TRACE_ENTER_4BYTE(osapiHtonl(osapiTaskIdSelf()));
+    TRACE_ENTER_4BYTE(osapiHtonl((L7_uint32) osapiTaskIdSelf()));
    /* End Trace Header*/
 
     max = strlen(pString);
     /* make sure strlen is no bigger than the max - header + null term */
     if (max > (dot1sNsfTraceWidth - (sizeof(do1sTraceHeader_t) + 1)))
       max = (dot1sNsfTraceWidth - (sizeof(do1sTraceHeader_t) + 1));
Index: src/application/switching/spanning_tree/dot1s/core/dot1s_api.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/core/dot1s_api.c	(revision 7772)
+++ src/application/switching/spanning_tree/dot1s/core/dot1s_api.c	(revision 7778)
@@ -2754,13 +2754,13 @@ L7_RC_t dot1sRegisterIntfChange( L7_COMP
   {
     L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_DOT1S_COMPONENT_ID,
             "Dot1s registrar ID %u, %s greater than Last Component ID\n", registrar_ID, name);
     return(L7_FAILURE);
   }
 
-  if ((L7_uint32)dot1sNotifyList[registrar_ID].notify_intf_change != L7_NULL)
+  if (dot1sNotifyList[registrar_ID].notify_intf_change != L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_DOT1S_COMPONENT_ID,
             "Dot1s registrar ID %u, %s already registered\n", registrar_ID, name);
     return(L7_FAILURE);
   }
 
Index: src/application/switching/spanning_tree/dot1s/include/dot1s_ih.h
===================================================================
--- src/application/switching/spanning_tree/dot1s/include/dot1s_ih.h	(revision 7772)
+++ src/application/switching/spanning_tree/dot1s/include/dot1s_ih.h	(revision 7778)
@@ -60,13 +60,13 @@ L7_RC_t dot1sIntfDetach(L7_uint32 intIfN
 L7_BOOL dot1sMapIntfIsConfigurable(L7_uint32 intIfNum, DOT1S_PORT_COMMON_CFG_t **pCfg);
 L7_RC_t dot1sIntfCfgToPortCopy(DOT1S_PORT_COMMON_CFG_t *pPortCfg);
 L7_BOOL dot1sIsPortForwarding(L7_uint32 intIfNum, L7_uint32 instIndex);
 L7_BOOL dot1sIsPortDiscarding(L7_uint32 intIfNum, L7_uint32 instIndex);
 L7_RC_t dot1sDiagDisablePort(L7_uint32 errIntIfNum);
 void dot1sIhStateSet(L7_uint32 mstID, L7_uint32 intIfNum, L7_uint32 state);
-void dot1sStateSetTimerExpired(L7_uint32 intIfNum, L7_uint32 state);
+void dot1sStateSetTimerExpired(L7_uint64 intIfNum, L7_uint64 state);
 void dot1sStateSetTimerExpiredProcess(L7_uint32 intIfNum);
 L7_RC_t dot1sStateSetCallback(L7_uint32 intIfNum, 
 							  L7_uint32 instance, 
 							  L7_uint32 state, 
 							  dot1s_stateCB_t stateStatus);
 L7_RC_t dot1sStateSetCallbackProcess(L7_uint32 intIfNum, 
Index: src/application/switching/spanning_tree/dot1s/nsf/dot1s_reconcile.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/nsf/dot1s_reconcile.c	(revision 7772)
+++ src/application/switching/spanning_tree/dot1s/nsf/dot1s_reconcile.c	(revision 7778)
@@ -237,15 +237,15 @@ L7_RC_t dot1sNsfReconcileFailed()
   }/* while*/
 
   return rc;
 
 }
 
-void dot1sReconcileTimerCallback(L7_uint32 intf, L7_uint32 state)
+void dot1sReconcileTimerCallback(L7_uint64 intf, L7_uint64 state)
 {
-  dot1sIssueCmd(dot1sReconError, intf, L7_NULL, L7_NULLPTR);
+  dot1sIssueCmd(dot1sReconError, (L7_uint32) intf, L7_NULL, L7_NULLPTR);
 }
 /*********************************************************************
 * @purpose  Handle the timer callback
 *
 * @param    intIfNum  @b{(input)}   internal intf of the lag
 * @param    state  @b{(input)}
Index: src/application/switching/vlan/dot1q/dot1q_cnfgr.c
===================================================================
--- src/application/switching/vlan/dot1q/dot1q_cnfgr.c	(revision 7772)
+++ src/application/switching/vlan/dot1q/dot1q_cnfgr.c	(revision 7778)
@@ -56,13 +56,13 @@ extern dot1qVidList_t      *pVidList;
 
 
 dot1qCnfgrState_t   dot1qCnfgrState; 
 osapiRWLock_t       dot1qCfgRWLock;
 void *dot1qMsgQueue = L7_NULLPTR;
 
-static L7_uint32 dot1qTaskId = 0;
+static L7_uint64 dot1qTaskId = 0;
 
 
 /*********************************************************************
 *
 * @purpose  Initialize the dot1q task and create message queue
 *
@@ -86,16 +86,16 @@ L7_RC_t dot1qInit(L7_CNFGR_CMD_DATA_t *p
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1Q_COMPONENT_ID,"dot1qInit: msgQueue creation error.\n");
       return L7_FAILURE;
     }
 
     /* create dot1qTask - to service dot1q message queue */
-    dot1qTaskId = (L7_uint32)osapiTaskCreate("dot1qTask", (void *)dot1qTask, 0, 0,
-                                           dot1qSidTaskStackSizeGet(),
-                                           dot1qSidTaskPriorityGet(),
-                                           dot1qSidTaskSliceGet());
+    dot1qTaskId = osapiTaskCreate("dot1qTask", (void *)dot1qTask, 0, 0,
+                                  dot1qSidTaskStackSizeGet(),
+                                  dot1qSidTaskPriorityGet(),
+                                  dot1qSidTaskSliceGet());
 
     if (dot1qTaskId == L7_ERROR)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1Q_COMPONENT_ID,"Failed to create dot1q task\n");
       return L7_FAILURE;
     }
Index: src/application/switching/vlan/dot1q/dot1q_intf.c
===================================================================
--- src/application/switching/vlan/dot1q/dot1q_intf.c	(revision 7772)
+++ src/application/switching/vlan/dot1q/dot1q_intf.c	(revision 7778)
@@ -797,13 +797,13 @@ L7_RC_t dot1qVlanIntfCreateInNim(L7_uint
 
     memset((void*)&intfDescr.macroPort,0,sizeof(nimMacroPort_t));
     intfDescr.macroPort.macroPort = 0;            /* This port is the macro port  */
     intfDescr.macroPort.macroType = L7_LOGICAL_VLAN_INTF;
     intfDescr.macroPort.macroMtu  = FD_DOT1Q_DEFAULT_VLAN_INTF_IP_MTU;
     intfDescr.macroPort.macroMaxFrame = FD_DOT1Q_DEFAULT_VLAN_INTF_CFG_MAX_FRAME_SIZE;
-    intfDescr.macroPort.macroInfo = (void *)vlanId;  /* Overload the data */
+    intfDescr.macroPort.macroInfo = UINT_TO_PTR(vlanId);  /* Overload the data */
 
 
     if (dot1qVlanIntfIndexGet(vlanId,&vlanIfIndex) != L7_SUCCESS)
     {
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1Q_COMPONENT_ID,
                 "Cannot get intfIndex for the vlan %d \n", vlanId);
Index: src/application/switching/pppoe/pppoe_cnfgr.c
===================================================================
--- src/application/switching/pppoe/pppoe_cnfgr.c	(revision 7772)
+++ src/application/switching/pppoe/pppoe_cnfgr.c	(revision 7778)
@@ -412,14 +412,14 @@ L7_RC_t pppoeCnfgrInitPhase2Process(L7_C
   L7_RC_t rc = L7_SUCCESS;
   sysnetNotifyEntry_t snEntry;
 
   *pResponse  = L7_CNFGR_CMD_COMPLETE;
   *pReason    = 0;
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register pppoePduReceive related to type=%u, protocol_type=%u: 0x%08x",
-           SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_PPPOE, (L7_uint32) pppoePduReceive);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register pppoePduReceive related to type=%u, protocol_type=%u: %p",
+              SYSNET_ETHERTYPE_ENTRY, L7_ETYPE_PPPOE, pppoePduReceive);
 
   memset(&snEntry, 0x00, sizeof(snEntry));
   strcpy(snEntry.funcName, "pppoePduReceive");
   snEntry.notify_pdu_receive = pppoePduReceive;
   snEntry.type = SYSNET_ETHERTYPE_ENTRY;
   snEntry.u.protocol_type = L7_ETYPE_PPPOE;
Index: src/application/switching/link_aggregation/core/dot3ad_lacpm.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_lacpm.c	(revision 7772)
+++ src/application/switching/link_aggregation/core/dot3ad_lacpm.c	(revision 7778)
@@ -614,14 +614,14 @@ L7_RC_t dot3adLacpmTransmit(L7_uint32 in
 *************************************************************************/
 L7_RC_t dot3adLacpmInit(void)
 {
   L7_RC_t rc;
   sysnetNotifyEntry_t snEntry;
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register dot3adPduReceive related to type=%u: 0x%08x",
-           SYSNET_MAC_ENTRY, (L7_uint32) dot3adPduReceive);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register dot3adPduReceive related to type=%u: %p",
+              SYSNET_MAC_ENTRY, dot3adPduReceive);
 
   /*Register the pdu receive function with sysnet utility*/
   strcpy(snEntry.funcName, "dot3adPduReceive");
   snEntry.notify_pdu_receive = dot3adPduReceive;
   snEntry.type = SYSNET_MAC_ENTRY;
   memcpy(snEntry.u.macAddr, dot3adSlowProtocolsMulticastMacAddr, L7_MAC_ADDR_LEN);
Index: src/application/switching/link_aggregation/core/dot3ad_transport.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_transport.c	(revision 7772)
+++ src/application/switching/link_aggregation/core/dot3ad_transport.c	(revision 7778)
@@ -31,13 +31,13 @@
 void *dot3adTransSema = L7_NULLPTR;
 void *dot3adTransSyncSema = L7_NULLPTR;
 void *dot3ad_transportQueue = L7_NULLPTR;
 dot3adHelperMsg_t *dot3adTransportPduDb = L7_NULLPTR;
 L7_INTF_MASK_t pduChangedMask;
 
-static L7_uint32 dot3ad_core_tx_task_id = L7_ERROR;
+static L7_uint64 dot3ad_core_tx_task_id = L7_ERROR;
 /* Global copy for the message . At any time we are going to use only one*/
 static dot3ad_helper_data_msg_t txMsg;
 
 /*********************************************************************
 * @purpose  Initializes the dot3ad transport subsystem.
 *
@@ -83,17 +83,17 @@ L7_RC_t dot3adTransportInit()
 
   memset(dot3adTransportPduDb, 0, sizeof(dot3adHelperMsg_t)*(L7_MAX_PORT_COUNT + 1));
   memset(&pduChangedMask,0,sizeof(L7_INTF_MASK_t));
   memset(&txMsg,0,sizeof(txMsg));
 
 
-  dot3ad_core_tx_task_id = (L7_uint32)osapiTaskCreate( "dot3ad_core_tx_task",
-                                                       (void *)dot3ad_transport_task, 0, 0,
-                                                       dot3adSidTimerTaskStackSizeGet(),
-                                                       dot3adSidTimerTaskPriorityGet(),
-                                                       dot3adSidTimerTaskSliceGet());
+  dot3ad_core_tx_task_id = osapiTaskCreate( "dot3ad_core_tx_task",
+                                            (void *)dot3ad_transport_task, 0, 0,
+                                            dot3adSidTimerTaskStackSizeGet(),
+                                            dot3adSidTimerTaskPriorityGet(),
+                                            dot3adSidTimerTaskSliceGet());
 
   if (osapiWaitForTaskInit (L7_DOT3AD_CORE_TX_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ALERT, L7_DOT3AD_COMPONENT_ID,
            "Failed to initialize dot3ad core task");
     return L7_FAILURE;
Index: src/application/switching/link_aggregation/core/dot3ad_cnfgr.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_cnfgr.c	(revision 7772)
+++ src/application/switching/link_aggregation/core/dot3ad_cnfgr.c	(revision 7778)
@@ -75,14 +75,14 @@ void      dot3adPhaseThreeFini(void);
 L7_RC_t   dot3adPhaseExecuteInit(void);
 L7_BOOL dot3adCnfgrIsHelperPresent();
 
 /* The last phase that was completed */
 static L7_CNFGR_STATE_t dot3adState = L7_CNFGR_STATE_NULL;
 
-static L7_uint32 dot3ad_core_task_id = L7_ERROR;
-static L7_uint32 dot3ad_timer_task_id = L7_ERROR;
+static L7_uint64 dot3ad_core_task_id = L7_ERROR;
+static L7_uint64 dot3ad_timer_task_id = L7_ERROR;
 
 
 static NIM_NOTIFY_CB_INFO_t dot3adLastIntfDeleted;
 static L7_CNFGR_CORRELATOR_t dot3adUnconfigureInProcess = L7_CNFGR_NO_HANDLE;
 static L7_BOOL globalWarmRestart = L7_FALSE;
 dot3ad_nsfFuncPtr_t dot3adNsfFuncTable;
@@ -928,28 +928,28 @@ L7_RC_t   dot3adPhaseOneInit(void)
   }
 
 
 
   /* create the tasks */
   /* create dot3ad_lac_task - to service queue*/
-  dot3ad_timer_task_id = (L7_uint32)osapiTaskCreate( "dot3ad_timer_task", (void *)dot3ad_timer_task, 0, 0,
-                                                     dot3adSidTimerTaskStackSizeGet(),
-                                                     dot3adSidTimerTaskPriorityGet(),
-                                                     dot3adSidTimerTaskSliceGet());
+  dot3ad_timer_task_id = osapiTaskCreate( "dot3ad_timer_task", (void *)dot3ad_timer_task, 0, 0,
+                                          dot3adSidTimerTaskStackSizeGet(),
+                                          dot3adSidTimerTaskPriorityGet(),
+                                          dot3adSidTimerTaskSliceGet());
 
   if (osapiWaitForTaskInit (L7_DOT3AD_TIMER_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ALERT, L7_DOT3AD_COMPONENT_ID,
             "Unable to initialize dot3ad_timer_task()\n");
     return(L7_FAILURE);
   }
 
-  dot3ad_core_task_id = (L7_uint32)osapiTaskCreate( "dot3ad_core_lac_task", (void *)dot3ad_lac_task, 0, 0,
-                                                   dot3adSidLacTaskStackSizeGet(),
-                                                   dot3adSidLacTaskPriorityGet(),
-                                                   dot3adSidLacTaskSliceGet());
+  dot3ad_core_task_id = osapiTaskCreate( "dot3ad_core_lac_task", (void *)dot3ad_lac_task, 0, 0,
+                                         dot3adSidLacTaskStackSizeGet(),
+                                         dot3adSidLacTaskPriorityGet(),
+                                         dot3adSidLacTaskSliceGet());
 
   if (osapiWaitForTaskInit (L7_DOT3AD_CORE_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ALERT, L7_DOT3AD_COMPONENT_ID,
             "Unable to initialize dot3ad_lac_task()\n");
     return(L7_FAILURE);
Index: src/application/switching/link_aggregation/core/dot3ad_lac.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_lac.c	(revision 7772)
+++ src/application/switching/link_aggregation/core/dot3ad_lac.c	(revision 7778)
@@ -4549,26 +4549,26 @@ void dot3adTablesLastChangedRecord(void)
 *           immediately to the timer task that called this routine. This will 
 *           avoid any processing on the timer thread.
 *
 * @end
 *
 *************************************************************************/ 
-void dot3adCurrentWhileTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm)
+void dot3adCurrentWhileTimerExpiredToQueue(L7_uint64 portNum, L7_uint64 nullParm)
 {
   dot3adTimerMsg_t Message;
   L7_RC_t rc;
 
-  PT_LOG_WARN(LOG_CTX_TRUNKS, "LACP RX expired event generated for portNum %u", portNum);
+  PT_LOG_WARN(LOG_CTX_TRUNKS, "LACP RX expired event generated for portNum %llu", portNum);
 
   Message.msgId = CURRENT_EXPIRED;
-  Message.parm1 = portNum;
+  Message.parm1 = (L7_uint32) portNum;
   Message.parm2 = nullParm;
 
   rc = osapiMessageSend(dot3ad_timer_queue,&Message, (L7_uint32)sizeof(dot3adTimerMsg_t),L7_NO_WAIT, L7_MSG_PRIORITY_NORM);
 
-  PT_LOG_DEBUG(LOG_CTX_TRUNKS,"LACP RX expired event for portNum %u sent (rc=%d)", portNum, rc);
+  PT_LOG_DEBUG(LOG_CTX_TRUNKS,"LACP RX expired event for portNum %llu sent (rc=%d)", portNum, rc);
 
   if (rc == L7_ERROR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
             "dot3adTimerTask: Failed to put msg in timer queue....\n");
   }
@@ -4587,19 +4587,19 @@ void dot3adCurrentWhileTimerExpiredToQue
 *           immediately to the timer task that called this routine. This will 
 *           avoid any processing on the timer thread.
 *
 * @end
 *
 *************************************************************************/
-void dot3adPeriodicTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm)
+void dot3adPeriodicTimerExpiredToQueue(L7_uint64 portNum, L7_uint64 nullParm)
 {
   dot3adTimerMsg_t Message;
   L7_RC_t rc;
 
   Message.msgId = PERIODIC_EXPIRED;
-  Message.parm1 = portNum;
+  Message.parm1 = (L7_uint32) portNum;
   Message.parm2 = nullParm;
 
   rc = osapiMessageSend(dot3ad_timer_queue,&Message,(L7_uint32)sizeof(dot3adTimerMsg_t),L7_NO_WAIT, L7_MSG_PRIORITY_NORM);
 
   if (rc == L7_ERROR)
   {
@@ -4620,19 +4620,19 @@ void dot3adPeriodicTimerExpiredToQueue(L
 * @notes   	Put this timer expiry message on a timer queue, thus returning
 *           immediately to the timer task that called this routine. This will 
 *           avoid any processing on the timer thread.
 * @end
 *
 *************************************************************************/
-void dot3adWaitWhileTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm)
+void dot3adWaitWhileTimerExpiredToQueue(L7_uint64 portNum, L7_uint64 nullParm)
 {
   dot3adTimerMsg_t Message;
   L7_RC_t rc;
 
   Message.msgId = WAIT_EXPIRED;
-  Message.parm1 = portNum;
+  Message.parm1 = (L7_uint32) portNum;
   Message.parm2 = nullParm;
 
   rc = osapiMessageSend(dot3ad_timer_queue,&Message, (L7_uint32)sizeof(dot3adTimerMsg_t),L7_NO_WAIT, L7_MSG_PRIORITY_NORM);
 
   if (rc == L7_ERROR)
   {
@@ -4654,19 +4654,19 @@ void dot3adWaitWhileTimerExpiredToQueue(
 *           immediately to the timer task that called this routine. This will 
 *           avoid any processing on the timer thread.
 *
 * @end
 *
 *************************************************************************/
-void dot3adNttTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm)
+void dot3adNttTimerExpiredToQueue(L7_uint64 portNum, L7_uint64 nullParm)
 {
   dot3adTimerMsg_t Message;
   L7_RC_t rc;
 
   Message.msgId = NTT_EXPIRED;
-  Message.parm1 = portNum;
+  Message.parm1 = (L7_uint32) portNum;
   Message.parm2 = nullParm;
 
   rc = osapiMessageSend(dot3ad_timer_queue,&Message, (L7_uint32)sizeof(dot3adTimerMsg_t),L7_NO_WAIT, L7_MSG_PRIORITY_NORM);
 
   if (rc == L7_ERROR)
   {
Index: src/application/switching/link_aggregation/core/include/dot3ad_lac.h
===================================================================
--- src/application/switching/link_aggregation/core/include/dot3ad_lac.h	(revision 7772)
+++ src/application/switching/link_aggregation/core/include/dot3ad_lac.h	(revision 7778)
@@ -1793,13 +1793,13 @@ void dot3adTablesLastChangedRecord(void)
 *           immediately to the timer task that called this routine. This will
 *           avoid any processing on the timer thread.
 *
 * @end
 *
 *************************************************************************/
-void dot3adCurrentWhileTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm);
+void dot3adCurrentWhileTimerExpiredToQueue(L7_uint64 portNum, L7_uint64 nullParm);
 
 /**************************************************************************
 *
 * @purpose    Actions to be performed when the periodic timer expires
 *
 * @param      portNum      internal interface number of the port
@@ -1810,13 +1810,13 @@ void dot3adCurrentWhileTimerExpiredToQue
 *           immediately to the timer task that called this routine. This will
 *           avoid any processing on the timer thread.
 *
 * @end
 *
 *************************************************************************/
-void dot3adPeriodicTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm);
+void dot3adPeriodicTimerExpiredToQueue(L7_uint64 portNum, L7_uint64 nullParm);
 
 /**************************************************************************
 *
 * @purpose    Actions to be performed when the Wait While timer expires
 *
 * @param      portNum      internal interface number of the port
@@ -1826,13 +1826,13 @@ void dot3adPeriodicTimerExpiredToQueue(L
 * @notes    Put this timer expiry message on a timer queue, thus returning
 *           immediately to the timer task that called this routine. This will
 *           avoid any processing on the timer thread.
 * @end
 *
 *************************************************************************/
-void dot3adWaitWhileTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm);
+void dot3adWaitWhileTimerExpiredToQueue(L7_uint64 portNum, L7_uint64 nullParm);
 
 /**************************************************************************
 *
 * @purpose    Sets the txCount to zero
 *
 * @param      portNum      internal interface number of the port
@@ -1843,13 +1843,13 @@ void dot3adWaitWhileTimerExpiredToQueue(
 *           immediately to the timer task that called this routine. This will
 *           avoid any processing on the timer thread.
 *
 * @end
 *
 *************************************************************************/
-void dot3adNttTimerExpiredToQueue(L7_uint32 portNum, L7_uint32 nullParm);
+void dot3adNttTimerExpiredToQueue(L7_uint64 portNum, L7_uint64 nullParm);
 
 /*********************************************************************
 * @purpose  dot3ad timer task which serves the expired timers
 *
 * @param
 *
Index: src/application/switching/link_aggregation/core/dot3ad_helper.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_helper.c	(revision 7772)
+++ src/application/switching/link_aggregation/core/dot3ad_helper.c	(revision 7778)
@@ -25,13 +25,13 @@
 
 /*#include "sysnet_api.h"*/
 
 dot3adHelperMsg_t *dot3adHelperLocalDb;
 
 static dot3ad_helper_states_t dot3adHelperStates[L7_MAX_PHYSICAL_PORTS_PER_UNIT + 1];
-static L7_uint32 dot3ad_helper_task_id = L7_ERROR;
+static L7_uint64 dot3ad_helper_task_id = L7_ERROR;
 
 void *dot3ad_helper_queue; /* reference to the helper message queue */
 L7_uint32 dot3adHelperUsrHandle = ~0;
 
 L7_RC_t dot3adHelperGetPortIndexFromUsp(nimUSP_t *usp, L7_uint32 *portIndex)
 {
@@ -89,17 +89,17 @@ L7_RC_t dot3adHelperInit()
   }
 
   memset(dot3adHelperLocalDb, 0,
          sizeof(dot3adHelperMsg_t)*(L7_MAX_PHYSICAL_PORTS_PER_UNIT + 1 ));
   memset(dot3adHelperStates, 0, sizeof(dot3adHelperStates));
 
-  dot3ad_helper_task_id = (L7_uint32)osapiTaskCreate( "dot3ad_helper_task",
-                                                      (void *)dot3ad_helper_task, 0, 0,
-                                                      dot3adSidTimerTaskStackSizeGet(),
-                                                      dot3adSidTimerTaskPriorityGet(),
-                                                      dot3adSidTimerTaskSliceGet());
+  dot3ad_helper_task_id = osapiTaskCreate( "dot3ad_helper_task",
+                                           (void *)dot3ad_helper_task, 0, 0,
+                                           dot3adSidTimerTaskStackSizeGet(),
+                                           dot3adSidTimerTaskPriorityGet(),
+                                           dot3adSidTimerTaskSliceGet());
 
   if (osapiWaitForTaskInit (L7_DOT3AD_HELPER_TASK_SYNC, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ALERT, L7_DOT3AD_COMPONENT_ID,
            "Unable to initialize dot3ad_helper_task");
     return L7_FAILURE;
Index: src/application/switching/link_aggregation/core/dot3ad_debug.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_debug.c	(revision 7772)
+++ src/application/switching/link_aggregation/core/dot3ad_debug.c	(revision 7778)
@@ -753,13 +753,13 @@ void dot3adIntfEventTrace(L7_uint32 intI
     return;
   }
 
   TRACE_BEGIN(dot3adSystem.traceHandle, L7_DOT3AD_COMPONENT_ID);
   TRACE_ENTER_2BYTE(osapiHtons(DOT3AD_NIMEVENTS_TRACEID));
   TRACE_ENTER_4BYTE(osapiHtonl((L7_ulong32)osapiTimeMillisecondsGet()));
-  TRACE_ENTER_4BYTE(osapiHtonl(osapiTaskIdSelf()));
+  TRACE_ENTER_4BYTE(osapiHtonl((L7_uint32) osapiTaskIdSelf()));
 
   TRACE_ENTER_4BYTE(event);
   TRACE_ENTER_4BYTE(intIfNum);
 
   TRACE_END();
 
@@ -775,13 +775,13 @@ void dot3adAggTrace(L7_uint32 aggId, L7_
   {
     return;
   }
   TRACE_BEGIN(dot3adSystem.traceHandle, L7_DOT3AD_COMPONENT_ID);
   TRACE_ENTER_2BYTE(osapiHtons(DOT3AD_AGG_TRACEID));
   TRACE_ENTER_4BYTE(osapiHtonl((L7_ulong32)osapiTimeMillisecondsGet()));
-  TRACE_ENTER_4BYTE(osapiHtonl(osapiTaskIdSelf()));
+  TRACE_ENTER_4BYTE(osapiHtonl((L7_uint32) osapiTaskIdSelf()));
 
   TRACE_ENTER_4BYTE(traceCode);
   TRACE_ENTER_4BYTE(aggId);
 
   TRACE_END();
 }
@@ -798,13 +798,13 @@ void dot3adPortTrace(dot3ad_port_t *p, L
     return;
   }
 
   TRACE_BEGIN(dot3adSystem.traceHandle, L7_DOT3AD_COMPONENT_ID);
   TRACE_ENTER_2BYTE(osapiHtons(DOT3AD_PORT_TRACEID));
   TRACE_ENTER_4BYTE(osapiHtonl((L7_ulong32)osapiTimeMillisecondsGet()));
-  TRACE_ENTER_4BYTE(osapiHtonl(osapiTaskIdSelf()));
+  TRACE_ENTER_4BYTE(osapiHtonl((L7_uint32) osapiTaskIdSelf()));
 
 
   TRACE_ENTER_2BYTE(traceCode);
   TRACE_ENTER_2BYTE(p->actorPortAggId);
   TRACE_ENTER_2BYTE(p->actorPortNum);
   TRACE_ENTER_2BYTE(p->partnerOperPortNumber);
Index: src/application/switching/filtering_db/fdb/fdb.c
===================================================================
--- src/application/switching/filtering_db/fdb/fdb.c	(revision 7772)
+++ src/application/switching/filtering_db/fdb/fdb.c	(revision 7778)
@@ -54,14 +54,14 @@ L7_BOOL fdbIsValidIntf(L7_uint32 intIfNu
 static avlTreeTables_t   *fdbTreeHeap;
 static dot1dTpFdbData_t  *fdbDataHeap;
 static avlTree_t         fdbTreeData;
 static fdb_stats_t       fdb_stats;
 static void       *fdbQueue;
 static fdbCfgData_t fdbCfgData;
-static L7_int32          fdb_task_id;
-static L7_FDB_TYPE_t        fdbType;
+static L7_uint64         fdb_task_id;
+static L7_FDB_TYPE_t     fdbType;
 
 static fdbIdTable_s      *fdbIdTable;
 static L7_uint32         *fdbIdUsed;
 static L7_uint32         numberOfFDBIdUsed;
 
 extern L7_BOOL           fdbWarmStart;
@@ -2029,14 +2029,14 @@ L7_RC_t fdbPhaseTwoInit(void)
   notifyFunctionList.notifySave     = fdbSave;
   notifyFunctionList.hasDataChanged = fdbHasDataChanged;
   notifyFunctionList.resetDataChanged = fdbResetDataChanged;
 
   eventMask = VLAN_ADD_NOTIFY | VLAN_DELETE_NOTIFY | VLAN_ADD_PORT_NOTIFY | VLAN_DELETE_PORT_NOTIFY;
 
-  PT_LOG_INFO(LOG_CTX_STARTUP, "Going to register function 0x%08x to family DTL_FAMILY_ADDR_MGMT (%u)",
-           (L7_uint32) dtlFdbReceiveCallback, DTL_FAMILY_ADDR_MGMT);
+  PT_LOG_INFO(LOG_CTX_STARTUP, "Going to register function %p to family DTL_FAMILY_ADDR_MGMT (%u)",
+              dtlFdbReceiveCallback, DTL_FAMILY_ADDR_MGMT);
 
   if ((rc = nvStoreRegister(notifyFunctionList)) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_FDB_COMPONENT_ID,
             "FDB: Unable to register to NVRAM routines\n");
     rc = L7_FAILURE;
@@ -2325,13 +2325,13 @@ L7_RC_t fdbIntfAttachProcess(L7_uint32 i
   else if (intfType == L7_LOGICAL_VLAN_INTF)
   {
     if (nimGetIntfL3MacAddress(intIfNum,L7_NULL,fdbMemberInfo.macAddr ) == L7_SUCCESS)
     {
       if ( nimGetMacroPortAssignment(intIfNum, &macroPortIntf) == L7_SUCCESS)
       {
-        fdbMemberInfo.vlanId    = (L7_uint32)macroPortIntf.macroInfo;
+        fdbMemberInfo.vlanId    = PTR_TO_UINT32(macroPortIntf.macroInfo);
         fdbMemberInfo.entryType = L7_FDB_ADDR_FLAG_L3_MANAGEMENT;
         fdbMemberInfo.intIfNum  = intIfNum;
         (void)fdbAddEntry(&fdbMemberInfo);
       }
     }
   }
@@ -2472,13 +2472,13 @@ L7_RC_t fdbIntfChangeCallback(L7_uint32
     {
       /* Note: The L3 router MAC address is being reserved by adding it to the FDB */
       if (nimGetIntfL3MacAddress(intIfNum,L7_NULL,fdbMemberInfo.macAddr ) == L7_SUCCESS)
       {
         if ( nimGetMacroPortAssignment(intIfNum, &macroPortIntf) == L7_SUCCESS)
         {
-          fdbMemberInfo.vlanId    = (L7_uint32)macroPortIntf.macroInfo;
+          fdbMemberInfo.vlanId    = PTR_TO_UINT32(macroPortIntf.macroInfo);
           fdbMemberInfo.entryType = L7_FDB_ADDR_FLAG_L3_MANAGEMENT;
           fdbMemberInfo.intIfNum  = intIfNum;
           (void)fdbDelEntry(&fdbMemberInfo);
         }
       }
     }
Index: src/application/switching/garp/garp_cnfgr.c
===================================================================
--- src/application/switching/garp/garp_cnfgr.c	(revision 7772)
+++ src/application/switching/garp/garp_cnfgr.c	(revision 7778)
@@ -556,28 +556,28 @@ L7_RC_t garpCnfgrInitPhase2Process(L7_CN
 
   eventMask = VLAN_ADD_NOTIFY | VLAN_ADD_PORT_NOTIFY | VLAN_DELETE_PENDING_NOTIFY |
               VLAN_DELETE_PORT_NOTIFY | VLAN_RESTORE_NOTIFY;
   /*register with vlan to get notifications for vlan create/delete and port added/deleted*/
   rc = vlanRegisterForChange(garpVlanChangeCallback, L7_GARP_COMPONENT_ID, eventMask);
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register GarpRecvPkt related to type=%u: 0x%08x",
-           SYSNET_MAC_ENTRY, (L7_uint32) GarpRecvPkt);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register GarpRecvPkt related to type=%u: %p",
+              SYSNET_MAC_ENTRY, GarpRecvPkt);
 
   strcpy(snEntry.funcName, "GvrpRecvPkt");
   snEntry.notify_pdu_receive = GarpRecvPkt;
   snEntry.type = SYSNET_MAC_ENTRY;
   memcpy(snEntry.u.macAddr, Garp_gvrp_mac_address, L7_MAC_ADDR_LEN);
   if (sysNetRegisterPduReceive(&snEntry) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_GARP_COMPONENT_ID,
             "Unable to register Gvrp pdu receive callback\n");
     return L7_FAILURE;
   }
 
-  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register GarpRecvPkt related to type=%u: 0x%08x",
-           SYSNET_MAC_ENTRY, (L7_uint32) GarpRecvPkt);
+  PT_LOG_INFO(LOG_CTX_STARTUP,"Going to register GarpRecvPkt related to type=%u: %p",
+              SYSNET_MAC_ENTRY, GarpRecvPkt);
 
   strcpy(snEntry.funcName, "GmrpRecvPkt");
   snEntry.notify_pdu_receive = GarpRecvPkt;
   snEntry.type = SYSNET_MAC_ENTRY;
   memcpy(snEntry.u.macAddr, Garp_gmrp_mac_address, L7_MAC_ADDR_LEN);
   if (sysNetRegisterPduReceive(&snEntry) != L7_SUCCESS)
Index: src/application/switching/port_mac_locking/pml_cnfgr.c
===================================================================
--- src/application/switching/port_mac_locking/pml_cnfgr.c	(revision 7772)
+++ src/application/switching/port_mac_locking/pml_cnfgr.c	(revision 7778)
@@ -28,13 +28,13 @@
 #include "pml_util.h"
 
 pmlCnfgrState_t          pmlCnfgrState = PML_PHASE_INIT_0;
 L7_BOOL                  pmlWarmStart = L7_FALSE;
 extern void             *pmlQueue;
 extern L7_uint32        *pmlMapTbl;
-extern L7_int32          pmlTaskId;
+extern L7_uint64         pmlTaskId;
 extern pmlCfgData_t     *pmlCfgData;
 extern pmlIntfOprData_t *pmlIntfOprData;
 extern PORTEVENT_MASK_t  pmlPortEventMask_g;
 
 
 /*********************************************************************
Index: src/application/switching/port_mac_locking/pml.c
===================================================================
--- src/application/switching/port_mac_locking/pml.c	(revision 7772)
+++ src/application/switching/port_mac_locking/pml.c	(revision 7778)
@@ -32,13 +32,13 @@
 #include "pml_util.h"
 #include "pml_sid.h"
 
 
 extern pmlCfgData_t *pmlCfgData;
 extern void         *pmlQueue;
-L7_int32             pmlTaskId;
+L7_uint64            pmlTaskId;
 pmlIntfOprData_t    *pmlIntfOprData = L7_NULLPTR;
 
 /*********************************************************************
 * @purpose  Start Port MAC Locking task
 *
 * @param    none
