diff -rpN --unified=5 esw_original/base/base/broad_base_mmu.c esw/base/base/broad_base_mmu.c
--- esw_original/base/base/broad_base_mmu.c	2013-06-26 00:04:28.395542556 +0100
+++ esw/base/base/broad_base_mmu.c	2013-07-22 20:05:50.653056903 +0100
@@ -855,11 +855,13 @@ hapiBroadPgInit(int unit, pg_cosmap_t *c
       case 6:
         soc_reg_field_set(unit, PORT_PRI_GRP0r, &rval0, PRI6_GRPf, cosmap[i].pg);
         break;
       case 7:
         /* PTin updated: platform */
-        if (SOC_IS_APOLLO(unit) || SOC_IS_TRIUMPH2(unit) || SOC_IS_VALKYRIE2(unit) || SOC_IS_TRIDENT(unit)) {
+        if (SOC_IS_APOLLO(unit) || SOC_IS_TRIUMPH2(unit) || SOC_IS_VALKYRIE2(unit) || SOC_IS_TRIDENT(unit) ||
+            SOC_IS_TRIUMPH3(unit))        /* PTin added: new switch BCM56643 */
+        {
             soc_reg_field_set(unit, PORT_PRI_GRP0r, &rval1, PRI7_GRPf, cosmap[i].pg);
         } else {
             soc_reg_field_set(unit, PORT_PRI_GRP1r, &rval1, PRI7_GRPf, cosmap[i].pg);
         }
         break;
@@ -1397,11 +1399,12 @@ int hapiBroadMmuTriumphPauseSet(int unit
 
     /* Input port shared space */
     cell_rval = 0;
     pkt_rval = 0;
     /* PTin updated: platform */
-    if (SOC_IS_APOLLO(unit) || SOC_IS_TRIUMPH2(unit) || SOC_IS_VALKYRIE2(unit) || SOC_IS_TRIDENT(unit)) 
+    if (SOC_IS_APOLLO(unit) || SOC_IS_TRIUMPH2(unit) || SOC_IS_VALKYRIE2(unit) || SOC_IS_TRIDENT(unit) ||
+        SOC_IS_TRIUMPH3(unit))        /* PTin added: new switch BCM56643 */
     { /* Everything in service pool 0 */
         soc_reg_field_set(unit, BUFFER_CELL_LIMIT_SPr, &cell_rval, LIMITf,
                           total_cells - in_reserved_cells - out_reserved_cells - num_ports);
         SOC_IF_ERROR_RETURN(WRITE_BUFFER_CELL_LIMIT_SPr(unit, 0, cell_rval));
         soc_reg_field_set(unit, BUFFER_PACKET_LIMIT_SPr, &pkt_rval, LIMITf,
@@ -1535,11 +1538,12 @@ L7_RC_t hapiBroadTrVlMmuModify(L7_uint32
     int                 num_ports = NUM_ALL_PORT(unit);
 
     hapiBroadMmuCellLimits(unit, &total_cells, &total_pkts, &in_reserved_cells, 
                            &in_reserved_pkts, &out_reserved_cells, &out_reserved_pkts);
     /* PTin updated: platform */
-    triumph2_family = SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit);
+    triumph2_family = SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit) ||
+                      SOC_IS_TRIUMPH3(unit);        /* PTin added: new switch BCM56643 */
 
     /* Ports with 8PG (1PG for other ports) */
     SOC_PBMP_CLEAR(pbmp_2pg);
     SOC_PBMP_CLEAR(pbmp_8pg);
     if (triumph2_family) {
@@ -4315,25 +4319,31 @@ L7_RC_t hapiBroadMmuConfigModify(L7_uint
   {
     rc = hapiBroadScorpionMmuModify(unit); 
   }
 #endif /* SCORPION */
 #ifdef BCM_TRIUMPH_SUPPORT
-  else if (SOC_IS_TR_VL(unit) && !SOC_IS_ENDURO(unit) && !SOC_IS_TRIDENT(unit))  /* PTin modified */
+  else if (SOC_IS_TR_VL(unit) && !SOC_IS_ENDURO(unit) && !SOC_IS_TRIDENT(unit) && !SOC_IS_TRIUMPH3(unit))  /* PTin modified */
   { 
     rc = hapiBroadTrVlMmuModify(unit);
   }
-  else if (SOC_IS_ENDURO(unit) && !SOC_IS_TRIDENT(unit))  /* PTin modified */
+  else if (SOC_IS_ENDURO(unit) && !SOC_IS_TRIDENT(unit) && !SOC_IS_TRIUMPH3(unit))  /* PTin modified */
   {
     rc = hapiBroadEnduroMmuModify(unit);
   }
   /* PTin added */
   else if (SOC_IS_TRIDENT(unit))
   {
     // TODO
     LOG_WARNING(LOG_CTX_MISC, "hapiBroadTridentMmuModify() is NOT IMPLEMENTED!");
     //rc = hapiBroadTridentMmuModify(unit);
   }
+  else if (SOC_IS_TRIUMPH3(unit))
+  {
+    // TODO
+    LOG_WARNING(LOG_CTX_MISC, "hapiBroadTriumph3MmuModify() is NOT IMPLEMENTED!");
+    //rc = hapiBroadTridentMmuModify(unit);
+  }
   /* PTin end */
 #endif /* TRIUMPH */
 #ifdef BCM_RAVEN_SUPPORT
   else if (SOC_IS_RAVEN(unit))
   {
@@ -4404,19 +4414,23 @@ int hapiBroadMmuPauseSet(int unit,int mo
 #ifdef BCM_TRIUMPH_SUPPORT
   else if (SOC_IS_ENDURO(unit))
   {
     rc=  hapiBroadMmuEnduroPauseSet(unit, mode);
   }
-  else if (SOC_IS_TR_VL(unit) && !SOC_IS_TRIDENT(unit)) /* PTin modified: new switch BCM56843 */
+  else if (SOC_IS_TR_VL(unit) && !SOC_IS_TRIDENT(unit) && !SOC_IS_TRIUMPH3(unit)) /* PTin modified: new switch BCM56843 */
   {
     rc = hapiBroadMmuTriumphPauseSet(unit, mode);
   }
   /* PTin added: new switch BCM56843 */
   else if (SOC_IS_TRIDENT(unit))
   {
     LOG_WARNING(LOG_CTX_MISC, "hapiBroadMmuTridentPauseSet() is not implemented!");
   }
+  else if (SOC_IS_TRIUMPH3(unit))
+  {
+    LOG_WARNING(LOG_CTX_MISC, "hapiBroadMmuTriumph3PauseSet() is not implemented!");
+  }
   /* PTin end */
 #endif
   else
   {
     rc = BCM_E_NONE;
diff -rpN --unified=5 esw_original/base/base/broad_debug.c esw/base/base/broad_debug.c
--- esw_original/base/base/broad_debug.c	2013-03-08 12:34:35.720941450 +0000
+++ esw/base/base/broad_debug.c	2013-07-22 20:05:50.657058795 +0100
@@ -45,11 +45,17 @@
 #include "soc/cmic.h"
 #include "soc/error.h"
 #include "soc/mem.h"
 #include "soc/hash.h"
 #include "soc/l2x.h"
+/* PTin removed: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No include */
+#else
 #include "bcm_int/esw/draco.h"
+#endif
 #include "bcm_int/control.h"
 #include "appl/diag/diag.h"
 #include "appl/diag/system.h"
 #include "appl/diag/cmdlist.h"
 #include "bcm/debug.h"
@@ -372,12 +378,14 @@ void hapiBroadDebugHelp()
   printf ("hapiBroadDebugBcmTrace(enable) - Enables tracing of bcm logging to dapiTrace\n");
 }
 
 void hapiBroadDebugSpecial(L7_ushort16 unit)
 {
-  // PTin added: new switch => SOC_IS_VALKYRIE2
-  if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit)) {
+  /* PTin updated: platform */
+  if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit) ||
+      SOC_IS_TRIUMPH3(unit))      /* PTin added: new switch BCM56643 */
+  {
       uint64 egr_val_64;
       uint32 bitmap;
       int rv;
       /*uint32 egr_val;*/
 
@@ -1167,10 +1175,14 @@ L7_RC_t hapiBroadDebugUCMemDump(L7_int32
 
 #ifdef BCM_ESW_SUPPORT
 /* The following functions are useful for XGS since table entries are hashed */
 int hapiBroadDebugHash(L7_uint32 unit, L7_uint32 keyType, L7_uint32 key63_32, L7_uint32 key31_0)
 {
+  /* PTin removed: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  return L7_SUCCESS;
+  #else
   hashinput_entry_t   hent;
   uint32              key[2];
   uint32              result = -1;
 
   key[0] = key31_0;
@@ -1184,10 +1196,11 @@ int hapiBroadDebugHash(L7_uint32 unit, L
   SOC_IF_ERROR_RETURN(soc_mem_write(unit, HASHINPUTm, 0, 0, &hent));
 
   SOC_IF_ERROR_RETURN(READ_HASH_OUTPUTr(unit, &result));
 
   return(int)result;
+  #endif
 }
 
 int hapiBroadDebugFindL2(L7_uint32 unit, L7_uint32 vidMacHi, L7_uint32 macLo)
 {
   int rc;
@@ -1206,10 +1219,14 @@ int hapiBroadDebugFindL2(L7_uint32 unit,
   return 0;
 }
 
 int hapiBroadDebugFindL3(L7_uint32 unit, L7_uint32 ipAddr)
 {
+  /* PTin removed: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  /* Nothing done */
+  #else
   int rc;
 
   rc = hapiBroadDebugHash(unit, XGS_HASH_KEY_TYPE_L3UC, 0, ipAddr);
 
   if (rc > 0)
@@ -1218,11 +1235,11 @@ int hapiBroadDebugFindL3(L7_uint32 unit,
   }
   else
   {
     printf("Entry not found\n");
   }
-
+  #endif
   return 0;
 }
 #endif
 
 /*********************************************************************
@@ -1780,10 +1797,14 @@ L7_RC_t hapiBroadDebugMmuSet(int unit,
                              int holcoscellset,
                              int holcoscellset_higig,
                              int ibpcellset,
                              int ibpdiscardset)
 {
+  /* PTin removed: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  /* Nothing done */
+  #else
   soc_port_t            port;
   uint32                cos, val;
 
   /* if all ports */
   if (port_num == -1)
@@ -1852,10 +1873,11 @@ L7_RC_t hapiBroadDebugMmuSet(int unit,
     val = 0;
     soc_reg_field_set(unit, IBPDISCARDSETLIMITr, &val,
                       DISCARDSETLIMITf, ibpdiscardset);
     SOC_IF_ERROR_RETURN(WRITE_IBPDISCARDSETLIMITr(unit, port, val));
   }
+  #endif
   return L7_SUCCESS;
 }
 
 
 int hapiBroadDebugPktSendEnabled = 0;
@@ -2103,10 +2125,14 @@ int hapiBroadDebugDuplexAdvertSet(int un
 
 /* Test Filter Reinstall Functionality.
 */
 int hapiBroadDebugFltInst1 (void)
 {
+  /* PTin removed: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  /* Nothing done */
+  #else
   bcm_filterid_t test_flt;
   int rv;
   int unit;
 
   unit = 0;
@@ -2138,18 +2164,22 @@ int hapiBroadDebugFltInst1 (void)
   rv = bcm_filter_destroy(unit, test_flt);
   if (rv != BCM_E_NONE)
   {
     LOG_ERROR (rv);
   }
-
+  #endif
   return 0;
 }
 
 /* Reinstalls the same filter.
 */
 int hapiBroadDebugFltReInst1 (void)
 {
+  /* PTin removed: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  /* Nothing done */
+  #else
   bcm_filterid_t test_flt;
   int rv;
   int unit;
   pbmp_t port_list;
 
@@ -2192,11 +2222,11 @@ int hapiBroadDebugFltReInst1 (void)
   rv = bcm_filter_destroy(unit, test_flt);
   if (rv != BCM_E_NONE)
   {
     LOG_ERROR (rv);
   }
-
+  #endif
   return 0;
 }
 
 /*****************************************************
 ** Test timed osapiSemaTake and osapiMessageReceive
diff -rpN --unified=5 esw_original/base/base/broad_hpc_drv.c esw/base/base/broad_hpc_drv.c
--- esw_original/base/base/broad_hpc_drv.c	2013-07-18 23:20:16.111538627 +0100
+++ esw/base/base/broad_hpc_drv.c	2013-07-22 20:05:50.661045667 +0100
@@ -64,11 +64,17 @@
 #include "soc/l2x.h"
 
 #include "bcmx/bcmx.h"
 #include "bcmx/bcmx_int.h"
 #include "bcm_int/rpc/rlink.h"
+/* PTin modified: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No included */
+#else
 #include "bcmx/filter.h"
+#endif
 #include "bcmx/l3.h"
 #include "bcm/vlan.h"
 
 #include "soc/debug.h"
 #include "soc/drv.h"
@@ -86,11 +92,11 @@
 #include "soc/phy/phynull.h"
 #include "soc/phy/phyreg.h"
 #include "soc/phyreg.h"
 #endif
 
-/* PTin added: init */
+/* PTin added: includes */
 #if 1
 #include "logger.h" /* PTin added */
 #define PTIN_TRAP_TO_CPU  0
 #endif
 
@@ -599,13 +605,15 @@ int hapiBroadCpuCosqRateSet(int unit, in
        * packet rate limits for lower cos queues.
        */
       if (soc_feature(unit, soc_feature_packet_rate_limit)) {
 #ifdef BCM_TRX_SUPPORT
         extern int _bcm_tr_cosq_port_packet_bandwidth_set(int unit, bcm_port_t port, bcm_cos_queue_t cosq, int pps, int burst);
-#ifdef BCM_TRIUMPH2_SUPPORT
-        // PTin added: new switch => SOC_IS_VALKYRIE2
-        if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit) /*|| SOC_IS_TRIDENT(unit)*/) {
+#if defined (BCM_TRIUMPH2_SUPPORT) || defined (BCM_TRIUMPH3_SUPPORT)
+        /* PTin updated: platform */
+        if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit) /*|| SOC_IS_TRIDENT(unit)*/ ||
+            SOC_IS_TRIUMPH3(unit))        /* PTin added: new switch BCM56643 */
+        {
           extern int bcm_tr2_cosq_port_pps_set(int unit, bcm_port_t port,
                                                bcm_cos_queue_t cosq, int pps);   
           rv = bcm_tr2_cosq_port_pps_set(unit, CMIC_PORT(unit), cosq, rate);
         }
         else
@@ -1304,11 +1312,16 @@ void hpcHardwareDefaultConfigApply(void)
     if (rv != BCM_E_NONE)
     {
       LOG_ERROR (i);
     }
 #endif
+    /* PTin modified: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    rv = bcm_custom_register(i, custom_bcmx_port_handler, (void *) 0);
+    #else
     rv = bcm_custom_register(i, custom_bcmx_port_handler);
+    #endif
      if (rv != BCM_E_NONE)
      {
        LOG_ERROR (rv);
      }
 
@@ -1324,12 +1337,13 @@ void hpcHardwareDefaultConfigApply(void)
       for (priority = 0; priority < 8; priority++)
       {
 
 #ifdef L7_STACKING_PACKAGE
         static int xgs_stack_cos_map[] = {0,1,2,3,4,5,6,6};
-        // PTin added: new switch => SOC_IS_VALKYRIE2
-        if (SOC_IS_FB_FX_HX(i) || SOC_IS_TR_VL(i) || SOC_IS_TRIUMPH2(i) || SOC_IS_APOLLO(i) || SOC_IS_VALKYRIE2(i) || SOC_IS_TRIDENT(i))
+        /* PTin updated: platform */
+        if (SOC_IS_FB_FX_HX(i) || SOC_IS_TR_VL(i) || SOC_IS_TRIUMPH2(i) || SOC_IS_APOLLO(i) || SOC_IS_VALKYRIE2(i) || SOC_IS_TRIDENT(i) ||
+            SOC_IS_TRIUMPH3(i))       /* PTin added: new switch BCM56643 */
         {
           /* 
            * XGS3 does not suffer from the same problem that caused us to map 7 -> 6
            * in XGS2 devices.  Remarking 7 does not cause the packet to use cos 7 in this
            * scenario
@@ -1563,12 +1577,13 @@ void hpcHardwareDefaultConfigApply(void)
         }
         else if (SOC_IS_BRADLEY(i))
         {
           rv = bcm_switch_control_set (i, bcmSwitchCpuProtoBpduPriority, HAPI_BROAD_INGRESS_BPDU_COS);
         }
-        // PTin added: new switch => SOC_IS_VALKYRIE2
-        else if (SOC_IS_TR_VL(i) || SOC_IS_SCORPION(i) || SOC_IS_TRIUMPH2(i) || SOC_IS_APOLLO(i) || SOC_IS_VALKYRIE2(i) /*|| SOC_IS_TRIDENT(i)*/)
+        /* PTin updated: platform */
+        else if (SOC_IS_TR_VL(i) || SOC_IS_SCORPION(i) || SOC_IS_TRIUMPH2(i) || SOC_IS_APOLLO(i) || SOC_IS_VALKYRIE2(i) /*|| SOC_IS_TRIDENT(i)*/ ||
+                 SOC_IS_TRIUMPH3(i))        /* PTin added: new switch BCM56643 */
         {
           bcm_rx_reasons_t reason, no_reason;
           int              internal_priority;
 
           index = 0;
@@ -1642,12 +1657,13 @@ void hpcHardwareDefaultConfigApply(void)
         if (rv != BCM_E_NONE)
         {
           LOG_ERROR (rv);
         }
 
-        // PTin added: new switch => SOC_IS_VALKYRIE2
-        if (!SOC_IS_TR_VL(i) && !SOC_IS_SCORPION(i) && !SOC_IS_TRIUMPH2(i) && !SOC_IS_APOLLO(i) && !SOC_IS_VALKYRIE2(i) && !SOC_IS_TRIDENT(i))
+        /* PTin updated: platform */
+        if (!SOC_IS_TR_VL(i) && !SOC_IS_SCORPION(i) && !SOC_IS_TRIUMPH2(i) && !SOC_IS_APOLLO(i) && !SOC_IS_VALKYRIE2(i) && !SOC_IS_TRIDENT(i) &&
+            !SOC_IS_TRIUMPH3(i))        /* PTin added: new switch BCM56643 */
         {
           /* This priority is used for packets that are copied to the CPU with a classifier, 
           ** and for IP traffic destined to the CPU due to IP address in the frames or
           ** IP header errors.
           */
@@ -1691,12 +1707,13 @@ void hpcHardwareDefaultConfigApply(void)
           {
             LOG_ERROR (rv);
           }
         }
 
-        // PTin added: new switch => SOC_IS_VALKYRIE2
-        if (!SOC_IS_TR_VL(i) && !SOC_IS_SCORPION(i) && !SOC_IS_TRIUMPH2(i) && !SOC_IS_APOLLO(i) && !SOC_IS_VALKYRIE2(i) && !SOC_IS_TRIDENT(i))
+        /* PTin updated: platform */
+        if (!SOC_IS_TR_VL(i) && !SOC_IS_SCORPION(i) && !SOC_IS_TRIUMPH2(i) && !SOC_IS_APOLLO(i) && !SOC_IS_VALKYRIE2(i) && !SOC_IS_TRIDENT(i) &&
+            !SOC_IS_TRIUMPH3(i))        /* PTin added: new switch BCM56643 */
         {
           /* Send unknown SA frames to the CPU with priority 0.
           */
           rv = bcm_switch_control_set (i, bcmSwitchCpuUnknownPrio, 0);
           if (rv != BCM_E_NONE)
@@ -1770,61 +1787,76 @@ void hpcHardwareDefaultConfigApply(void)
     /* Enable dual hashing on all devices that support this feature 
      * Dual hashing reduces the probability of hash collision and 
      * there is no reason not to use this feature when supported 
      * (hence treat this as default config whereever applicable). 
      */
-     
+
     if (soc_feature(i, soc_feature_dual_hash))
     {
        int hashControl;
 
        /* The key is to select the a different hashing algorithm 
         * than L2/L3 hash. (default CRC32L).
         */
+
        rv = bcm_switch_control_get(i, bcmSwitchHashL2, &hashControl);
-       if (rv != BCM_E_NONE)
+       if (rv != BCM_E_NONE && rv != BCM_E_UNAVAIL)     /* PTin modified: BCM56643 */
        {
           LOG_ERROR (rv);
        }
-
-       if (hashControl == BCM_HASH_CRC32L)
-          rv = bcm_switch_control_set(i, bcmSwitchHashL2Dual, BCM_HASH_CRC32U);
-       else if (hashControl == BCM_HASH_CRC32U)
-          rv = bcm_switch_control_set(i, bcmSwitchHashL2Dual, BCM_HASH_CRC32L);
-       else if (hashControl == BCM_HASH_CRC16L)
-          rv = bcm_switch_control_set(i, bcmSwitchHashL2Dual, BCM_HASH_CRC16U);
-       else if (hashControl == BCM_HASH_CRC16U)
-           rv = bcm_switch_control_set(i, bcmSwitchHashL2Dual, BCM_HASH_CRC16L);
-  
-       if (rv != BCM_E_NONE)
+       /* PTin added: (BCM56643) Execute, only if success */
+       if (rv == BCM_E_NONE)
        {
-          LOG_ERROR (rv);
+         if (hashControl == BCM_HASH_CRC32L)
+            rv = bcm_switch_control_set(i, bcmSwitchHashL2Dual, BCM_HASH_CRC32U);
+         else if (hashControl == BCM_HASH_CRC32U)
+            rv = bcm_switch_control_set(i, bcmSwitchHashL2Dual, BCM_HASH_CRC32L);
+         else if (hashControl == BCM_HASH_CRC16L)
+            rv = bcm_switch_control_set(i, bcmSwitchHashL2Dual, BCM_HASH_CRC16U);
+         else if (hashControl == BCM_HASH_CRC16U)
+             rv = bcm_switch_control_set(i, bcmSwitchHashL2Dual, BCM_HASH_CRC16L);
+    
+         if (rv != BCM_E_NONE)
+         {
+            LOG_ERROR (rv);
+         }
        }
-
-       if (soc_feature(i, soc_feature_l3))
-       {
-       rv = bcm_switch_control_get(i, bcmSwitchHashL3, &hashControl);
-       if (rv != BCM_E_NONE)
+       else
        {
-          LOG_ERROR (rv);
+         LOG_WARNING(LOG_CTX_PTIN_HAPI,"Dual Hash was not configured for L2");
        }
 
-       if (hashControl == BCM_HASH_CRC32L)
-          rv = bcm_switch_control_set(i, bcmSwitchHashL3Dual, BCM_HASH_CRC32U);
-       else if (hashControl == BCM_HASH_CRC32U)
-          rv = bcm_switch_control_set(i, bcmSwitchHashL3Dual, BCM_HASH_CRC32L);
-       else if (hashControl == BCM_HASH_CRC16L)
-          rv = bcm_switch_control_set(i, bcmSwitchHashL3Dual, BCM_HASH_CRC16U);
-       else if (hashControl == BCM_HASH_CRC16U)
-          rv = bcm_switch_control_set(i, bcmSwitchHashL3Dual, BCM_HASH_CRC16L);
-
-       if (rv != BCM_E_NONE)
+       if (soc_feature(i, soc_feature_l3))
        {
-          LOG_ERROR (rv);
+         rv = bcm_switch_control_get(i, bcmSwitchHashL3, &hashControl);
+         if (rv != BCM_E_NONE && rv != BCM_E_UNAVAIL)   /* PTin modified: BCM56643 */
+         {
+            LOG_ERROR (rv);
+         }
+         /* PTin added: (BCM56643) Execute, only if success */
+         if (rv == BCM_E_NONE)
+         {
+           if (hashControl == BCM_HASH_CRC32L)
+              rv = bcm_switch_control_set(i, bcmSwitchHashL3Dual, BCM_HASH_CRC32U);
+           else if (hashControl == BCM_HASH_CRC32U)
+              rv = bcm_switch_control_set(i, bcmSwitchHashL3Dual, BCM_HASH_CRC32L);
+           else if (hashControl == BCM_HASH_CRC16L)
+              rv = bcm_switch_control_set(i, bcmSwitchHashL3Dual, BCM_HASH_CRC16U);
+           else if (hashControl == BCM_HASH_CRC16U)
+              rv = bcm_switch_control_set(i, bcmSwitchHashL3Dual, BCM_HASH_CRC16L);
+
+           if (rv != BCM_E_NONE)
+           {
+              LOG_ERROR (rv);
+           }
+         }
+         else
+         {
+           LOG_WARNING(LOG_CTX_PTIN_HAPI,"Dual Hash was not configured for L3");
+         }
        }
     }
-    }
 
     if (SOC_IS_RAPTOR(i) || SOC_IS_HAWKEYE(i)) 
     {
       rv = bcm_switch_control_set(i, bcmSwitchCpuProtoIgmpPriority, HAPI_BROAD_INGRESS_MED_PRIORITY_COS);
       if (rv != BCM_E_NONE)
@@ -2270,10 +2302,14 @@ L7_RC_t hpcHardwareDriverAsfEnable(void)
   }
 
   return rc;
 }
 
+/* PTin TODO: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* None */
+#else
 /*********************************************************************
 * @purpose  Qualifies BCMX filter with non-stack ports.
 *
 * @param    void
 *                                       
@@ -2361,10 +2397,11 @@ void hpcBcmxFilterStackPortRemove(bcm_fi
    LOG_ERROR (rv);
  }
 
  bcmx_lplist_free(&portList);
 }
+#endif
 
 /* The following code is a patch to support Ax-B0 XGS3 parts 
  *  It addresses the Higig Problem Opcode 0 issue
  */
 #ifdef BCM_FIELD_SUPPORT
diff -rpN --unified=5 esw_original/base/base/broad_init.c esw/base/base/broad_init.c
--- esw_original/base/base/broad_init.c	2013-07-03 00:02:26.897039592 +0100
+++ esw/base/base/broad_init.c	2013-07-22 20:24:37.831598668 +0100
@@ -81,11 +81,17 @@
 #include "bcm/cosq.h"
 #include "bcm/ipmc.h"
 #include "bcm/stack.h"
 #include "bcmx/lport.h"
 #include "bcmx/link.h"
+/* PTin modified: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No include */
+#else
 #include "bcmx/filter.h"
+#endif
 #include "bcmx/switch.h"
 #include "ibde.h"
 #include "l7_usl_api.h"
 #include "l7_usl_sm.h"
 #include "l7_usl_port_db.h"
diff -rpN --unified=5 esw_original/base/base/broad_system.c esw/base/base/broad_system.c
--- esw_original/base/base/broad_system.c	2013-07-19 11:35:44.311553114 +0100
+++ esw/base/base/broad_system.c	2013-07-22 20:05:50.665046517 +0100
@@ -39,11 +39,17 @@
 
 #include "bcm/port.h"
 #include "bcm/l2.h"
 #include "bcm/rate.h"
 #include "bcm/mirror.h"
+/* PTin modified: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No include */
+#else
 #include "bcm/filter.h"
+#endif
 #include "soc/cmic.h"
 #include "soc/drv.h"
 #include "soc/macipadr.h"
 #include "soc/mem.h"
 #include "soc/cm.h"
@@ -52,14 +58,24 @@
 #include "bcmx/l2.h"
 #include "bcmx/port.h"
 #include "bcmx/lport.h"
 #include "bcmx/mirror.h"
 #include "bcmx/rate.h"
+/* PTin removed: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No include */
+#else
 #include "bcmx/filter.h"
+#endif
 #include "bcmx/switch.h"
 #include "bcmx/bcmx_int.h"
+/* TODO: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+//#include "soc/ea/tk371x/igmp.h"
+#else
 #include "bcmx/igmp.h"
+#endif
 #include "bcmx/custom.h"
 #include "bcm_int/esw/mbcm.h"
 #include "l7_usl_bcmx_l2.h"
 #include "l7_usl_api.h"
 #include "l7_usl_bcmx_port.h"
@@ -68,13 +84,12 @@
 #include "unitmgr_api.h"
 #include "broad_mmu.h"
 #include "platform_config.h"
 #include "l7_usl_port_db.h"
 
-/* PTin added: IGMP snooping */
+/* PTin added: includes */
 #if 1
-#include "ptin_globaldefs.h"
 #include "logger.h"
 #endif
 
 #ifdef PC_LINUX_HOST
 #include "bcmx/bcmx_int.h"
@@ -264,11 +279,16 @@ void hapiBroadMirrorEnable (void)
     if (L7_BCMX_OK(rv) != L7_TRUE)
     {
        LOG_ERROR (rv);
     }
 
+    /* TODO: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    rv = BCM_E_NONE;    /* Always enabled */
+    #else
     rv = bcmx_mirror_pfmt_set(1);
+    #endif
     if (L7_BCMX_OK(rv) != L7_TRUE)
     {
       LOG_ERROR (rv);
     }
   }
@@ -307,11 +327,11 @@ static void hapiBroadMirrorDisable (void
 *
 * @end
 *********************************************************************/
 L7_BOOL hapiBroadSystemTrueEgrMirroring(void)
 {
-#ifdef BCM_TRIUMPH2_SUPPORT
+#if defined (BCM_TRIUMPH2_SUPPORT) || defined (BCM_TRIUMPH3_SUPPORT)
   L7_short16 bcm_unit;
    
   for (bcm_unit=0; bcm_unit < soc_ndev; bcm_unit++)
   {
     if (soc_feature(bcm_unit, soc_feature_egr_mirror_true))
@@ -2306,10 +2326,11 @@ L7_RC_t hapiBroadGetSystemBoardFamily(bc
 
   /* Based on the board, return the family */
 
   switch (board_info->npd_id)
   {
+    /* PTin updated: new platform */
     case __BROADCOM_56214_ID:
     case __BROADCOM_56218_ID:
     case __BROADCOM_56224_ID:
     case __BROADCOM_56228_ID:
     case __BROADCOM_56304_ID:
@@ -2328,11 +2349,12 @@ L7_RC_t hapiBroadGetSystemBoardFamily(bc
       *board_family = BCM_FAMILY_TRIUMPH;
       break;
     case __BROADCOM_56634_ID:
     case __BROADCOM_56524_ID:
     case __BROADCOM_56636_ID:
-    case __BROADCOM_56685_ID:  /* PTin added: new switch */
+    case __BROADCOM_56685_ID:   /* PTin added: new switch */
+    case __BROADCOM_56643_ID:   /* PTin added: new switch 56643 */
       *board_family = BCM_FAMILY_TRIUMPH2;
       break;
     case __BROADCOM_56820_ID:
       *board_family = BCM_FAMILY_SCORPION;
       break;
@@ -3226,11 +3248,16 @@ L7_RC_t hapiBroadConfigIgmpFilter(L7_BOO
     result = hapiBroadConfigIgmpFilterRaptor(enableFilter);
     return result;
   }
   if (hapiBroadRoboCheck() == L7_TRUE)
   {
+    /* TODO: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    /* Nothing to be done */
+    #else
     bcmx_igmp_snooping_enable_set(enableFilter);
+    #endif
   }
 
   /* If vlan value is valid, Find igmp index */
   if (vlanId >= PTIN_VLAN_MIN && vlanId <= PTIN_VLAN_MAX)
   {
@@ -5792,11 +5819,16 @@ L7_RC_t hapiBroadSystemCardPortsAdminMod
 
     /* Time to send the message */
     if (numElems == maxElems) 
     {
       *(L7_uint32 *)&msg[0] = numElems;
+      /* PTin modified: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      rv = bcmx_custom_port_set(dummyLport, USL_BCMX_PORT_ADMIN_MODE_SET, (sizeof(L7_uint32)+sizeof(element)*numElems)/sizeof(L7_uint32), args);
+      #else
       rv = bcmx_custom_port_set(dummyLport, USL_BCMX_PORT_ADMIN_MODE_SET, args);
+      #endif
       if (L7_BCMX_OK(rv) != L7_TRUE)
       {
         result = L7_FAILURE;
         SYSAPI_PRINTF(SYSAPI_LOGGING_ALWAYS,
                       "Failed to set admin mode for ports in unit/slot %d/%d rv %d\n", usp.unit, usp.slot, rv);
@@ -5811,11 +5843,16 @@ L7_RC_t hapiBroadSystemCardPortsAdminMod
 
   /* Send the remaining elements */
   if (numElems > 0) 
   {
     *(L7_uint32 *)&msg[0] = numElems;
+    /* PTin modified: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    rv = bcmx_custom_port_set(dummyLport, USL_BCMX_PORT_ADMIN_MODE_SET, (sizeof(L7_uint32)+sizeof(element)*numElems)/sizeof(L7_uint32), args);
+    #else
     rv = bcmx_custom_port_set(dummyLport, USL_BCMX_PORT_ADMIN_MODE_SET, args);
+    #endif
     if (L7_BCMX_OK(rv) != L7_TRUE)
     {
       result = L7_FAILURE;
       SYSAPI_PRINTF(SYSAPI_LOGGING_ALWAYS,
                     "Failed to set admin mode for ports in unit/slot %d/%d rv %d\n", usp.unit, usp.slot, rv);
diff -rpN --unified=5 esw_original/base/base/broad_topo.c esw/base/base/broad_topo.c
--- esw_original/base/base/broad_topo.c	2013-03-08 12:34:35.720941450 +0000
+++ esw/base/base/broad_topo.c	2013-07-22 20:20:03.163582304 +0100
@@ -33,10 +33,16 @@
 #include <soc/drv.h>
 #include <bcm_int/control.h>
 #include <dapi_trace.h>
 #include <sal/appl/config.h>
 
+/* PTin added: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+#include "bcm_int/common/trunk.h"
+#endif
+
 /* Trunk-id for the internal trunk used on dual xgs3 design. SDK stack trunk
  * handling code will avoid destroying this trunk-id when creating stack trunks
  */
 L7_int32 lvl7_internal_hg_trunkid = -1;
 
@@ -109,11 +115,18 @@ static int lvl7_48g_topo(topo_cpu_t *tp_
     int sp_idx, m_idx;
     int mod_id;
     int src_unit,dst_unit;
     cpudb_entry_t *l_entry;
     int iter;
+    /* PTin modified: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    L7_uint32          number_of_members;
+    bcm_trunk_info_t   trunk_info;
+    bcm_trunk_member_t member_array[BCM_TRUNK_MAX_PORTCNT];
+    #else
     bcm_trunk_add_info_t        trunk;
+    #endif
     bcm_trunk_chip_info_t       ti;
     bcm_port_config_t   config;
     const bcm_sys_board_t       *board_info;
 
     board_info = hpcBoardGet();
@@ -125,10 +138,42 @@ static int lvl7_48g_topo(topo_cpu_t *tp_
 
     l_entry = &tp_cpu->local_entry;
 
     /* setup the modids and trunks for the interconnect */
     for (src_unit = 0; src_unit < l_entry->base.num_units; src_unit++) {
+      /* PTin modified: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      memset(&trunk_info,0,sizeof(trunk_info));
+      memset(member_array,0,sizeof(member_array));
+      number_of_members = 0;
+
+      trunk_info.psc        = BCM_TRUNK_PSC_SRCDSTMAC;
+      trunk_info.dlf_index  = -1;
+      trunk_info.mc_index   = -1;
+      trunk_info.ipmc_index = -1;
+
+      for (dst_unit = 0; dst_unit < l_entry->base.num_units; dst_unit++) {
+        for (iter = 0; iter < board_info->num_interconnects;iter++) {
+          if ((src_unit == board_info->interconnect_list[iter].from_unit) &&
+              (dst_unit == board_info->interconnect_list[iter].to_unit))
+          {
+              /* add to trunk */
+              member_array[number_of_members].flags = 0;
+              BCM_GPORT_LOCAL_SET(member_array[number_of_members].gport,
+                                  board_info->interconnect_list[iter].from_port);
+          }
+        }
+      }
+
+      if (number_of_members > 0) {
+        BCM_IF_ERROR_RETURN(bcm_trunk_chip_info_get(src_unit, &ti));
+        bcm_trunk_destroy(src_unit, ti.trunk_fabric_id_max);
+        lvl7_internal_hg_trunkid = ti.trunk_fabric_id_max;
+        BCM_IF_ERROR_RETURN(bcm_trunk_create(src_unit, BCM_TRUNK_FLAG_WITH_ID, &ti.trunk_fabric_id_max));
+        BCM_IF_ERROR_RETURN(bcm_trunk_set(src_unit, ti.trunk_fabric_id_max, &trunk_info, number_of_members, member_array));
+      }
+      #else
       memset(&trunk,0,sizeof(trunk));
       trunk.psc        = BCM_TRUNK_PSC_SRCDSTMAC;
       trunk.dlf_index  = -1;
       trunk.mc_index   = -1;
       trunk.ipmc_index = -1;
@@ -147,10 +192,11 @@ static int lvl7_48g_topo(topo_cpu_t *tp_
         bcm_trunk_destroy(src_unit, ti.trunk_fabric_id_max);
         lvl7_internal_hg_trunkid = ti.trunk_fabric_id_max;
         BCM_IF_ERROR_RETURN(bcm_trunk_create_id(src_unit, ti.trunk_fabric_id_max));
         BCM_IF_ERROR_RETURN(bcm_trunk_set(src_unit, ti.trunk_fabric_id_max, &trunk));
       }
+      #endif
       BCM_IF_ERROR_RETURN(bcm_stk_my_modid_set(src_unit, l_entry->mod_ids[src_unit]));
     }
 
     /* setup the externally accessible modid map */
     /* Gets the MODIDs accessible via external stack ports */
diff -rpN --unified=5 esw_original/base/broad_common.h esw/base/broad_common.h
--- esw_original/base/broad_common.h	2013-07-19 11:35:44.307560603 +0100
+++ esw/base/broad_common.h	2013-07-22 20:24:37.831598668 +0100
@@ -42,11 +42,17 @@
 #include <sal/appl/config.h>
 #include <sal/appl/io.h>
 #include <appl/cpudb/cpudb.h>
 
 #include <bcm/error.h>
+/* PTIn modified: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No include */
+#else
 #include <bcm/filter.h>
+#endif
 #include <bcm/stg.h>
 #include <bcm/port.h>
 #include <bcm/link.h>
 
 #include "bcm_int/esw/mbcm.h"
@@ -1037,11 +1043,14 @@ L7_BOOL hpcIsBcmPortStacking (L7_uint32 
 *       
 * @end
 *********************************************************************/
 void hpcStackPortEnable (L7_BOOL enable);
 
-
+/* PTin removed: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No filter functions */
+#else
 /*********************************************************************
 * @purpose  Qualifies BCMX filter with non-stack ports.
 *
 * @param    void
 *                                       
@@ -1054,10 +1063,11 @@ void hpcStackPortEnable (L7_BOOL enable)
 * @comments with front panel ports which are not configured for stacking.
 *       
 * @end
 *********************************************************************/
 void hpcBcmxFilterStackPortRemove(bcm_filterid_t *bcmx_filter);
+#endif
 
 /*********************************************************************
 *
 * @purpose Re-initialize multicast global data.
 *
diff -rpN --unified=5 esw_original/base/broad_mmu.h esw/base/broad_mmu.h
--- esw_original/base/broad_mmu.h	2013-03-08 12:34:35.724941790 +0000
+++ esw/base/broad_mmu.h	2013-07-22 20:05:50.685047477 +0100
@@ -145,11 +145,12 @@ typedef struct {
 int hapiBroadPgInit(int unit, pg_cosmap_t *cosmap,int num_cos, 
                     pg_vals_t *pg_vals,int num_pg_vals);
 
 #endif /* TRIUMPH ONLY */
 
-#ifdef BCM_ENDURO_SUPPORT
+/* PTin updated: new platform TRIUMP3 */
+#if defined (BCM_ENDURO_SUPPORT) || defined (BCM_TRIUMPH_SUPPORT)
 /*New Macros for enduro*/
 #define EN_MMU_IN_PORT_MIN_CELLS                72
 #define EN_MMU_PG_HDRM_LIMIT_CELLS              216 /*(3 * mtu number of cells)*/
 #define EN_MMU_GLOBAL_HDRM_LIMIT_CELLS          348
 #define EN_MMU_IN_PORT_MIN_PKTS                 1
diff -rpN --unified=5 esw_original/base/broad_policy_types.h esw/base/broad_policy_types.h
--- esw_original/base/broad_policy_types.h	2013-03-08 12:34:35.724941790 +0000
+++ esw/base/broad_policy_types.h	2013-07-22 20:39:45.057308785 +0100
@@ -612,31 +612,42 @@ typedef struct BROAD_POLICY_RULE_ENTRY_s
     BROAD_POLICY_RULE_PRIORITY_t  priority;
     BROAD_FIELD_ENTRY_t           fieldInfo;
     BROAD_ACTION_ENTRY_t          actionInfo;
 
     /* Counters and meters are mutually exclusive. */
+    /* PTin removed: SDK 6.3.0 */
+    #if 0
     union
     {
       struct
       {
         BROAD_METER_ENTRY_t           meterInfo;
       } meter;
-
-      /* PTin added: support for bcm_policer apis */
-      struct
-      {
-        BROAD_METER_ENTRY_t           policerInfo;
-        L7_int                        policer_id;
-      } policer;
-
       struct
       {
         BROAD_COUNTER_ENTRY_t         counterInfo;
       } counter;
     } u;
+    #else
+    /* PTin added: SDK 6.3.0 (support for bcm_policer apis) */
+    struct
+    {
+      BROAD_METER_ENTRY_t           policerInfo;
+      L7_int                        policer_id;
+    } policer;
+    struct
+    {
+      BROAD_COUNTER_ENTRY_t         counterInfo;
+      L7_int                        counter_id;   /* PTin added: SDK 6.3.0 (support for bcm_field_stat apis) */
+    } counter;
+    #endif
+
     L7_uint32                     meterSrcEntry;  /* src rule number for shared meters/counters */
 
+    L7_int                        src_policerId;    /* PTin added: SDK 6.3.0 (support for bcm_policer apis) */
+    L7_int                        src_counterId;    /* PTin added: SDK 6.3.0 (support for bcm_field_stat apis) */
+
     struct BROAD_POLICY_RULE_ENTRY_s *next;
 }
 BROAD_POLICY_RULE_ENTRY_t;
 
 
diff -rpN --unified=5 esw_original/ip_mcast/broad_l3_mcast_debug.c esw/ip_mcast/broad_l3_mcast_debug.c
--- esw_original/ip_mcast/broad_l3_mcast_debug.c	2013-03-08 12:34:34.592449726 +0000
+++ esw/ip_mcast/broad_l3_mcast_debug.c	2013-07-22 20:30:27.774587132 +0100
@@ -25,10 +25,15 @@
 #include "broad_common.h"
 #include "broad_l3_mcast.h"
 #include "broad_l3_mcast_debug.h"
 
 #include "bcmx/ipmc.h"
+/* PTin added: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+#include "bcmx/multicast.h"
+#endif
 
 #define MCAST_PRINT(fmt,args...)  {printf("\n%s [%d]: ", __FUNCTION__,__LINE__);printf(fmt,##args);}
 
 extern DAPI_t    *dapi_g;
 
@@ -200,18 +205,32 @@ L7_RC_t hapiBroadDebugL3McastRepl(ip_add
 
     hapiPortPtr = HAPI_PORT_GET(&usp, dapi_g);
 
     memset (&ipmc_data, 0, sizeof (ipmc_data));
 
+    /* PTin modified: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    ipmc_data.vid         = vid;
+    ipmc_data.s_ip_addr   = srcAddr;
+    ipmc_data.mc_ip_addr  = groupIp;
+    rv = bcmx_ipmc_find(&ipmc_data);
+    #else
     rv = bcmx_ipmc_get(srcAddr, groupIp, vid, &ipmc_data);
+    #endif
     if (L7_BCMX_OK(rv) != L7_TRUE)
     {
       bcmx_ipmc_addr_free(&ipmc_data);
       return L7_SUCCESS;
-    }       
+    }
+    /* PTin modified: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    rv = bcmx_multicast_repl_get(ipmc_data.ipmc_index, hapiPortPtr->bcmx_lport,
+                                 ipmc_vlan_vec);
+    #else
     rv = bcmx_ipmc_repl_get(ipmc_data.ipmc_index, hapiPortPtr->bcmx_lport,
                             ipmc_vlan_vec);
+    #endif
     if (rv != BCM_E_UNAVAIL)
     {
       if (L7_BCMX_OK(rv) != L7_TRUE)
       {
         bcmx_ipmc_addr_free(&ipmc_data);
@@ -227,10 +246,11 @@ L7_RC_t hapiBroadDebugL3McastRepl(ip_add
         }
       }
     }
     printf("\n");
     bcmx_ipmc_addr_free(&ipmc_data);
+
     return L7_SUCCESS;
 }
 
 /*********************************************************************
 *
diff -rpN --unified=5 esw_original/policy/broad_cfp_bcm.c esw/policy/broad_cfp_bcm.c
--- esw_original/policy/broad_cfp_bcm.c	2013-03-08 12:34:34.680447344 +0000
+++ esw/policy/broad_cfp_bcm.c	2013-07-22 20:39:45.059582869 +0100
@@ -35,11 +35,12 @@
 
 typedef struct
 {
     BROAD_GROUP_t        group;
     BROAD_ENTRY_t        entry[BROAD_MAX_RULES_PER_POLICY];
-    L7_int               policer_id[BROAD_MAX_RULES_PER_POLICY];    /* PTin added: policer */
+    int                  policer_id[BROAD_MAX_RULES_PER_POLICY];    /* PTin added: SDK 6.3.0 */
+    int                  counter_id[BROAD_MAX_RULES_PER_POLICY];    /* PTin added: SDK 6.3.0 */
     bcm_pbmp_t           pbm;
     bcm_pbmp_t           pbmMask;
     unsigned char        flags;
     BROAD_POLICY_STAGE_t policyStage;
     unsigned char        portClass; /* Used for LOOKUP and EGRESS port classes */
@@ -340,12 +341,13 @@ int l7_bcm_cfp_policy_create(int unit, B
     BROAD_ENTRY_t       entry;
     policy_map_table_t *policyPtr = L7_NULL;
     int                 savePbm = FALSE;
     bcm_pbmp_t          savedPbm, savedPbmMask;
     int                 rv = BCM_E_NONE;
-    L7_short16           policyIdx;
+    L7_short16          policyIdx;
     BROAD_POLICY_RULE_ENTRY_t *rulePtr;
+    L7_int              policer_id = 0, counter_id = 0;  /* PTin added: SDK 6.3.0 */
 
     CHECK_UNIT(unit);
     CHECK_POLICY(policy);
 
     _cfp_policy_sem_take();
@@ -461,21 +463,29 @@ int l7_bcm_cfp_policy_create(int unit, B
 
           /* convert srcEntry from rule to entry number so lower layer understands */
           srcRule = rulePtr->meterSrcEntry;
           rulePtr->meterSrcEntry = policyPtr->entry[srcRule];
 
-          rv = policy_cfp_group_add_rule(unit, policyPtr->policyStage, group, rulePtr, policyPtr->pbm, &entry);
+          /* PTin modified: SDK 6.3.0 */
+          policer_id = counter_id = 0;
+          rv = policy_cfp_group_add_rule(unit, policyPtr->policyStage, group, rulePtr, policyPtr->pbm, &entry,
+                                         &policer_id, &counter_id);     /* PTin modified: SDK 6.3.0 */
           if (BCM_E_NONE != rv)
           {
               if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
                   sysapiPrintf("- add rule failed\n");
 
               /* If entry is not invalid, then the rule has been created
                * but the add failed during a subsequent phase. The entry 
                * must be saved in order to ensure proper removal. */
               if(entry != BROAD_ENTRY_INVALID)
               {
+                /* PTin added: SDK 6.3.0 */
+                #if 1
+                policyPtr->policer_id[i] = policer_id;
+                policyPtr->counter_id[i] = counter_id;
+                #endif
                 policyPtr->entry[i] = entry;
                 policyPtr->entryCount++;
               }
 
               _cfp_policy_sem_give();
@@ -580,11 +590,17 @@ int l7_bcm_cfp_policy_destroy(int unit, 
     /* remove each group entry used by policy */
     if (policyPtr->group != BROAD_GROUP_INVALID)
     {
       for (i = policyPtr->entryCount - 1; i >= 0 ; --i)
       {
-          tmprv = policy_cfp_group_delete_rule(unit, policyPtr->policyStage, policyPtr->group, policyPtr->entry[i]);
+          tmprv = policy_cfp_group_delete_rule(unit, policyPtr->policyStage, policyPtr->group, policyPtr->entry[i],
+                                               policyPtr->policer_id[i], policyPtr->counter_id[i]);   /* PTin modified: SDK 6.3.0 */
+          /* PTin added: SDK 6.3.0 */
+          #if 1
+          policyPtr->policer_id[i] = 0;
+          policyPtr->counter_id[i] = 0;
+          #endif
           if (BCM_E_NONE != tmprv)
               rv = tmprv;
       }
 
       /* Determine if any other policy is using this group. If not, then destroy it. */
diff -rpN --unified=5 esw_original/policy/broad_cfp_robo.c esw/policy/broad_cfp_robo.c
--- esw_original/policy/broad_cfp_robo.c	2013-03-08 12:34:34.680447344 +0000
+++ esw/policy/broad_cfp_robo.c	2013-07-22 20:52:34.411551185 +0100
@@ -22,10 +22,16 @@
 #include "bcm/field.h"
 #include "ibde.h"
 #include "sal/core/libc.h"
 #include "osapi_support.h"
 
+/* PTin added: includes */
+#if 1
+#include "ptin_globaldefs.h"
+#include "logger.h"
+#endif
+
 /* used for the Higig B0 workaround */
 #include <soc/drv.h>
 #include <bcm_int/control.h>
 
 extern L7_int32 hpcBroadMasterCpuModPortGet(L7_int32 *modid, L7_int32 *cpuport);
@@ -67,11 +73,16 @@ static bcm_field_qualify_t field_map[BRO
     bcmFieldQualifyDstIp6,         /* Destination IPv6 Address */ /*NOT SUPPORTED*/
     bcmFieldQualifyIp6FlowLabel,   /* IPv6 Flow Label */
     bcmFieldQualifyIp6TrafficClass,/* IPv6 Traffic Class */
     customFieldQualifyIcmpMsgType, /* ICMP Message Type   */
     //bcmFieldQualifyLookupClass0,    /* Class ID from VFP, to be used in IFP */
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifySrcClassL2,
+#else
     bcmFieldQualifySrcMacGroup,     /* Class ID from L2X, to be used in IFP */
+#endif
     0,                              /* iSCSI opcode: NOT SUPPORTED */
     0,                              /* iSCSI opcode, TCP options: NOT SUPPORTED */
     bcmFieldQualifyTcpControl,
     bcmFieldQualifyVlanFormat,     /* VLAN Format */
     bcmFieldQualifyIpType,         /* IP Type */
@@ -1437,92 +1448,95 @@ static int _policy_group_delete_group(in
 /* Group Management Functions */
 static void _policy_group_lookupstatus_convert(L7_ushort16 hapiStatus, L7_ushort16 *bcmStatus, L7_BOOL isMask)
 {
   *bcmStatus = 0;
 
+  /* PTin modified: SDK 6.3.0 */
+  #if 1
   if (hapiStatus & BROAD_LOOKUPSTATUS_DOS_ATTACK_PKT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_DOS_ATTACK;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_DOS_ATTACK_PKT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_UNRESOLVED_SA)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L2_MISS;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_UNRESOLVED_SA;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_LPM_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3_LPM_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_LPM_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_STARGV_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3MC_SGV_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_STARGV_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L3_DST_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3UC_DA_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L3_DST_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L3_UC_SRC_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3UC_SA_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L3_UC_SRC_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L2_USER_ENTRY_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L2_CACHE_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L2_USER_ENTRY_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L2_TABLE_DST_L3)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3_ROUTABLE;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L2_TABLE_DST_L3;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L2_DST_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L2_DA_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L2_DST_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L2_SRC_STATIC)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L2_SA_STATIC;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L2_SRC_STATIC;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L2_SRC_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L2_SA_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L2_SRC_HIT;
   }
   if (isMask)
   {
     if (hapiStatus & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK)
     {
-      *bcmStatus |= BCM_FIELD_LOOKUP_ING_STP_MASK;
+      *bcmStatus |= BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK;
     }
   }
   else
   {
     if ((hapiStatus & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK) == BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_DIS)
     {
-      *bcmStatus |= BCM_FIELD_LOOKUP_ING_STP_DIS;
+      *bcmStatus |= BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_DIS;
     }
     if ((hapiStatus & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK) == BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_BLK)
     {
-      *bcmStatus |= BCM_FIELD_LOOKUP_ING_STP_BLK;
+      *bcmStatus |= BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_BLK;
     }
     if ((hapiStatus & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK) == BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_LRN)
     {
-      *bcmStatus |= BCM_FIELD_LOOKUP_ING_STP_LRN;
+      *bcmStatus |= BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_LRN;
     }
     if ((hapiStatus & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK) == BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_FWD)
     {
-      *bcmStatus |= BCM_FIELD_LOOKUP_ING_STP_FWD;
+      *bcmStatus |= BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_FWD;
     }
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_FB_VLAN_ID_VALID)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_VLAN_VALID;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_FB_VLAN_ID_VALID;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_VXLT_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_VXLT_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_VXLT_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_TUNNEL_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3_TUN_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_TUNNEL_HIT;
   }
+  #endif
 }
 
 static int _policy_group_add_std_field(int                   unit,
                                        BROAD_POLICY_STAGE_t  policyStage,
                                        bcm_field_entry_t     eid,
@@ -1577,11 +1591,16 @@ static int _policy_group_add_std_field(i
            two tags before reaching CFP. So, there is no need to check for tagged status
            of the packet for IVID field.*/
         if(hapiBroadRoboVariantCheck() != __BROADCOM_53115_ID)
         {
           if ((BCM_E_NONE == rv) && ((*((bcm_vlan_t*)value) != 0) || (*((bcm_vlan_t*)mask) != 0)))
+            /* PTin modified: SDK 6.3.0 */
+            #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+            rv = bcm_field_qualify_VlanFormat(unit, eid, BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED | BCM_FIELD_VLAN_FORMAT_INNER_TAGGED, 0xff);
+            #else
             rv = bcm_field_qualify_VlanFormat(unit, eid, BCM_FIELD_PKT_FMT_INNER_TAGGED, BCM_FIELD_PKT_FMT_INNER_TAGGED);
+            #endif
         }
         break;
     case BROAD_FIELD_DSCP:
         rv = bcm_field_qualify_DSCP(unit, eid, *((uint8*)value), *((uint8*)mask));
         break;
@@ -1635,16 +1654,27 @@ static int _policy_group_add_std_field(i
         break;
 //  case BROAD_FIELD_CLASS_ID:
 //      rv = bcm_field_qualify_LookupClass0(unit, eid, *((uint8*)value), 0xF);
 //      break;
     case BROAD_FIELD_L2_CLASS_ID:
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        rv = bcm_field_qualify_SrcClassL2(unit, eid, *((uint8*)value), 0xF);
+        #else
         rv = bcm_field_qualify_SrcMacGroup(unit, eid, *((uint8*)value), 0xF);
+        #endif
         break;
     case BROAD_FIELD_LOOKUP_STATUS:
         _policy_group_lookupstatus_convert(*((uint16*)value), &lookupStatus,     L7_FALSE);
         _policy_group_lookupstatus_convert(*((uint16*)mask),  &lookupStatusMask, L7_TRUE);
+        /* TODO: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        rv = BCM_E_UNAVAIL;
+        LOG_ERR(LOG_CTX_PTIN_HAPI,"bcm_field_qualify_LookupStatus is not supported!");
+        #else
         rv = bcm_field_qualify_LookupStatus(unit, eid, lookupStatus, lookupStatusMask);
+        #endif
         break;
     case BROAD_FIELD_VLAN_FORMAT:
         {
            uint32 vlanFormat=0;
            uint32 vlanFormatMask =0;
@@ -1944,17 +1974,163 @@ static int _policy_group_add_actions(int
   }
 
   return rv;
 }
 
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+static int _policy_group_add_policer(int unit, bcm_field_entry_t eid, bcm_field_group_t gid, BROAD_POLICY_RULE_ENTRY_t *rulePtr)
+{
+    int                   rv = BCM_E_NONE;
+    BROAD_METER_ENTRY_t  *meterPtr;
+    bcm_policer_t         src_policer_id, policer_id;
+    bcm_policer_config_t  policer_cfg;
+
+    //printf("%s(%d) I was here!",__FUNCTION__,__LINE__);
+
+    meterPtr = &rulePtr->policer.policerInfo;
+
+    bcm_policer_config_t_init(&policer_cfg);
+    policer_cfg.flags = /*BCM_POLICER_REPLACE | BCM_POLICER_DROP_RED |*/ 0;
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    //policer_cfg.flags |= BCM_POLICER_MODE_BYTES;
+  #endif
+    policer_cfg.mode  = bcmPolicerModeTrTcm;  /* RFC 2698 */
+    policer_cfg.ckbits_sec    = meterPtr->cir;
+    policer_cfg.ckbits_burst  = meterPtr->cbs;
+    policer_cfg.pkbits_sec    = meterPtr->pir;
+    policer_cfg.pkbits_burst  = meterPtr->pbs;
+    policer_cfg.action_id     = bcmPolicerActionRpDrop;
+    policer_cfg.sharing_mode  = 0;
+
+    if (meterPtr->colorMode == BROAD_METER_COLOR_BLIND)
+      policer_cfg.flags |= BCM_POLICER_COLOR_BLIND;
+
+    if (rulePtr->ruleFlags & BROAD_METER_SHARED)
+    {
+        bcm_field_entry_t src_eid;
+
+        src_eid = BROAD_ENTRY_TO_BCM_ENTRY(rulePtr->meterSrcEntry);
+
+        src_policer_id = rulePtr->src_policerId;
+
+        rv = bcm_field_entry_policer_attach(unit, eid, 0, src_policer_id);
+
+        if (BCM_E_NONE != rv)
+        {
+          printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+          return rv;
+        }
+
+        rulePtr->policer.policer_id = src_policer_id;
+    }
+    else
+    {
+        /* Create policer */
+        rv = bcm_policer_create(unit, &policer_cfg, &policer_id);
+        if (BCM_E_NONE != rv)
+        {
+          printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+            return rv;
+        }
+
+        /* Attach policer to field entry */
+        rv = bcm_field_entry_policer_attach(unit, eid, 0, policer_id);
+        if (BCM_E_NONE != rv)
+        {
+          printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+            return rv;
+        }
+
+        rulePtr->policer.policer_id = policer_id;
+        rulePtr->src_policerId = policer_id;
+    }
+
+    printf("%s(%d) I was here! rv=%d",__FUNCTION__,__LINE__,rv);
+
+    return rv;
+}
+
+static int _policy_group_add_stat(int unit, bcm_field_entry_t eid, bcm_field_group_t gid, BROAD_POLICY_RULE_ENTRY_t *rulePtr)
+{
+    int                    rv = BCM_E_NONE;
+    uint64                 zero64;
+    BROAD_COUNTER_ENTRY_t *counterPtr;
+    bcm_field_stat_t       stat[2];
+    int                    src_stat_id, stat_id;
+
+    printf("%s(%d) gid=%u, eid=%u",__FUNCTION__,__LINE__,gid,eid);
+
+    counterPtr = &rulePtr->counter.counterInfo;
+
+    if (rulePtr->ruleFlags & BROAD_COUNTER_SHARED)
+    {
+      src_stat_id = rulePtr->src_counterId;
+
+      rv = bcm_field_entry_stat_attach(unit, eid, src_stat_id);
+
+      if (BCM_E_NONE != rv)
+      {
+        printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+          return rv;
+      }
+
+      rulePtr->counter.counter_id = src_stat_id;
+    }
+    else
+    {
+      /* add counter to support stats */
+      if (BROAD_COUNT_PACKETS == counterPtr->mode)
+      {
+        stat[0] = bcmFieldStatPackets;
+      }
+      else
+      {
+        stat[0] = bcmFieldStatBytes;
+      }
+
+      rv = bcm_field_stat_create(unit, gid, 1, stat, &stat_id);
+      if (BCM_E_NONE != rv)
+      {
+        printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+          return rv;
+      }
+
+      rv = bcm_field_entry_stat_attach(unit, eid, stat_id);
+      if (BCM_E_NONE != rv)
+      {
+        printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+          return rv;
+      }
+
+      rulePtr->counter.counter_id = stat_id;
+      rulePtr->src_counterId = stat_id;
+    }
+
+    /* zero values prior to first use */
+    COMPILER_64_ZERO(zero64);
+    rv = bcm_field_stat_all_set(unit, stat_id, zero64);
+    if (BCM_E_NONE != rv)
+    {
+      printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+        return rv;
+    }
+
+    printf("%s(%d) Success! rv=%d",__FUNCTION__,__LINE__,rv);
+
+    return rv;
+}
+
+#else
+
 static int _policy_group_add_meter(int unit, bcm_field_entry_t eid, BROAD_POLICY_RULE_ENTRY_t *rulePtr)
 {
     int                  rv = BCM_E_NONE;
     uint64               zero64;
     BROAD_METER_ENTRY_t *meterPtr;
 
-    meterPtr = &rulePtr->u.meter.meterInfo;
+    meterPtr = &rulePtr->policer.policerInfo;     /* PTin modified: SDK 6.3.0 */
 
     if (rulePtr->ruleFlags & BROAD_METER_SHARED)
     {
         bcm_field_entry_t src_eid;
 
@@ -2004,11 +2180,11 @@ static int _policy_group_add_counter(int
     int                    rv = BCM_E_NONE;
     uint32                 flags;
     uint64                 zero64;
     BROAD_COUNTER_ENTRY_t *counterPtr;
 
-    counterPtr = &rulePtr->u.counter.counterInfo;
+    counterPtr = &rulePtr->counter.counterInfo;   /* PTin modified: SDK 6.3.0 */
 
     if (rulePtr->ruleFlags & BROAD_COUNTER_SHARED)
     {
         bcm_field_entry_t src_eid;
 
@@ -2038,10 +2214,11 @@ static int _policy_group_add_counter(int
     else
         flags |= BCM_FIELD_COUNTER_MODE_BYTES;
 
     return rv;
 }
+#endif
 
 static int _policy_group_alloc_init(int unit, BROAD_POLICY_STAGE_t policyStage, int groups)
 {
 
     if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
@@ -2245,19 +2422,22 @@ int policy_cfp_group_create(int unit, BR
 
     return rv;
 }
  
 int policy_cfp_group_add_rule(int                        unit,
-                          BROAD_POLICY_STAGE_t       policyStage,
-                          BROAD_GROUP_t              group,
-                          BROAD_POLICY_RULE_ENTRY_t *rulePtr,
-                          bcm_pbmp_t                 pbm,
-                          BROAD_ENTRY_t             *entry)
+                              BROAD_POLICY_STAGE_t       policyStage,
+                              BROAD_GROUP_t              group,
+                              BROAD_POLICY_RULE_ENTRY_t *rulePtr,
+                              bcm_pbmp_t                 pbm,
+                              BROAD_ENTRY_t             *entry,
+                              int                       *policer_id,      /* PTin added: SDK 6.3.0 */
+                              int                       *counter_id)
+
 {
     BROAD_POLICY_FIELD_t f;
     group_table_t       *groupPtr;
-    bcm_field_entry_t    eid;
+    bcm_field_entry_t    gid, eid;
     int                  rv = BCM_E_NONE;
     BROAD_ACTION_ENTRY_t *actionPtr;
 
     if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
                 sysapiPrintf("- enter policy_cfp_group_add_rule \n");
@@ -2267,10 +2447,12 @@ int policy_cfp_group_add_rule(int       
     groupPtr = &group_table[unit][policyStage][group];
 
     if (!(groupPtr->flags & GROUP_USED))
         return BCM_E_NOT_FOUND;
 
+    gid = groupPtr->gid;
+
     rv = bcm_field_entry_create(unit, groupPtr->gid, &eid);
     if (BCM_E_NONE != rv)
         return rv;
 
     *entry = BCM_ENTRY_TO_BROAD_ENTRY(eid);
@@ -2303,31 +2485,55 @@ int policy_cfp_group_add_rule(int       
     if (rulePtr->ruleFlags & BROAD_METER_SPECIFIED)
     {
         if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_MED)
             sysapiPrintf("- adding a meter\n");
 
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+        rv = _policy_group_add_policer(unit, eid, gid, rulePtr);
+        #else
         rv = _policy_group_add_meter(unit, eid, rulePtr);
+        #endif
         if (BCM_E_NONE != rv)
             return rv;
     }
     else if (rulePtr->ruleFlags & BROAD_COUNTER_SPECIFIED)
     {
         if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_MED)
             sysapiPrintf("- adding a counter\n");
         
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+        rv = _policy_group_add_stat(unit, eid, gid, rulePtr);
+        #else
         rv = _policy_group_add_counter(unit, eid, rulePtr);
+        #endif
         if (BCM_E_NONE != rv)
             return rv;
     }
 
+    /* Ptin added: SDK 6.3.0 */
+    #if 1
+    if (policer_id!=L7_NULLPTR)   *policer_id = rulePtr->policer.policer_id;
+    if (counter_id!=L7_NULLPTR)   *counter_id = rulePtr->counter.counter_id;
+    #endif
+
     /* Only install to HW if we expect any ports to match this rule. This is mostly because
        for LOOKUP and EGRESS policies, the portClass doesn't really provide a mechanism to
        never match rule (as a NULL pbmp would do for ingress) */
     if ((policyStage == BROAD_POLICY_STAGE_INGRESS) || (BCM_PBMP_NOT_NULL(pbm)))
     {
-      
       rv = bcm_field_entry_install(unit, eid);
+
+      /* PTin added: SDK 6.3.0 */
+      #if 1
+      if ( rv != BCM_E_NONE)
+      { 
+        /* Destroy rule */
+        (void) policy_cfp_group_delete_rule(unit, policyStage, gid, eid, rulePtr->policer.policer_id, rulePtr->counter.counter_id);
+      }
+      #endif
     }
 
     if (rv == BCM_E_NONE)
     {
       groupPtr->availableRules--;
@@ -2478,11 +2684,16 @@ int policy_cfp_group_set_portclass(int  
                 return rv;
           }
           break;
         }
 
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        rv = bcm_field_qualify_InterfaceClassPort(unit, eid, 0, 0);
+        #else
         rv = bcm_field_qualify_PortClass(unit, eid, 0, 0);
+        #endif
         if (BCM_E_NONE != rv)
             return rv;
       }
       else
       {
@@ -2496,11 +2707,16 @@ int policy_cfp_group_set_portclass(int  
         {
           rv = bcm_field_qualify_OutPort(unit, eid, 0, 0);
           if (BCM_E_NONE != rv)
               return rv;
         }
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        rv = bcm_field_qualify_InterfaceClassPort(unit, eid, portClass, classMask);
+        #else
         rv = bcm_field_qualify_PortClass(unit, eid, portClass, classMask);
+        #endif
         if (BCM_E_NONE != rv)
             return rv;
       }
 
       rv = bcm_field_entry_install(unit, eid);
@@ -2567,13 +2783,15 @@ int policy_cfp_group_rule_priority_set(i
 
     return rv;
 }
 
 int policy_cfp_group_delete_rule(int                  unit,
-                             BROAD_POLICY_STAGE_t policyStage,
-                             BROAD_GROUP_t        group,
-                             BROAD_ENTRY_t        entry)
+                                 BROAD_POLICY_STAGE_t policyStage,
+                                 BROAD_GROUP_t        group,
+                                 BROAD_ENTRY_t        entry,
+                                 int                  policer_id,   /* PTin added: SDK 6.3.0 */
+                                 int                  counter_id)
 {
     int               rv;
     group_table_t    *groupPtr;
     bcm_field_entry_t eid;
 
@@ -2591,10 +2809,32 @@ int policy_cfp_group_delete_rule(int    
      * a rule that is not installed in the hardware. So, continue with the
      * destroy. */ 
     if((BCM_E_UNAVAIL != rv) && (BCM_E_NONE != rv))
         return rv;
 
+    /* PTin added: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+    if (policer_id>0)
+    {
+      rv = bcm_field_entry_policer_detach(unit, eid, 0);
+      if (BCM_E_NONE != rv)
+          return rv;
+      rv = bcm_policer_destroy(unit, policer_id);
+      if (BCM_E_NONE != rv)
+          return rv;
+    }
+    if (counter_id>0)
+    {
+      rv = bcm_field_entry_stat_detach(unit, eid, counter_id);
+      if (BCM_E_NONE != rv)
+          return rv;
+      rv = bcm_field_stat_destroy(unit, counter_id);
+      if (BCM_E_NONE != rv)
+          return rv;
+    }
+    #endif
+
     rv = bcm_field_entry_destroy(unit, eid);
     if (BCM_E_NONE != rv)
         return rv;
 
     groupPtr->availableRules++;
@@ -2640,30 +2880,68 @@ int policy_cfp_group_get_stats(int      
     group_table_t     *groupPtr;
     bcm_field_entry_t  eid;
 
     CHECK_GROUP(unit,policyStage,group);
 
-    COMPILER_64_ZERO(*val1);
-    COMPILER_64_ZERO(*val2);
+    /* PTin modified: SDK 6.3.0 */
+    #if 1
+    if (val1!=NULL) COMPILER_64_ZERO(*val1);
+    if (val2!=NULL) COMPILER_64_ZERO(*val2);
+    #endif
 
     groupPtr = &group_table[unit][policyStage][group];
 
     if (!(groupPtr->flags & GROUP_USED))
         return BCM_E_NOT_FOUND;
 
     eid = BROAD_ENTRY_TO_BCM_ENTRY(entry);
 
+    /* PTin added: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+    int stat_size, stat_id;
+    bcm_field_stat_t stat_type[2];
+    uint64 values[2];
+
+    /* Get stat id for this entry */
+    rv = bcm_field_entry_stat_get(unit, entry, &stat_id);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        return rv;
+
+    /* Get number of counters */
+    rv = bcm_field_stat_size(unit, stat_id, &stat_size);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        return rv;
+    /* Limit number of counters to 2 */
+    if (stat_size>2)  stat_size = 2;
+
+    if (stat_size==0)
+      return BCM_E_EMPTY;
+
+    /* Get collection of counters */
+    rv = bcm_field_stat_config_get(unit, stat_id, stat_size, stat_type);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        return rv;
+
+    /* Get counters values */
+    rv = bcm_field_stat_multi_get(unit, stat_id, stat_size, stat_type, values);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        return rv;
+
+    if (stat_size>=1 && val1!=NULL)  *val1 = values[0];
+    if (stat_size>=2 && val2!=NULL)  *val2 = values[1];
+    #else
     rv = bcm_field_counter_get(unit, eid, 0, val1);
     if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
         return rv;
 
     if (policyStage != BROAD_POLICY_STAGE_EGRESS)
     {
       rv = bcm_field_counter_get(unit, eid, 1, val2);  /* empty means no counter */
       if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
           return rv;
     }
+    #endif
 
     return BCM_E_NONE;
 }
 
 int policy_cfp_group_stats_clear(int                  unit,
@@ -2676,20 +2954,36 @@ int policy_cfp_group_stats_clear(int    
 
     COMPILER_64_ZERO(val1);
 
     eid = BROAD_ENTRY_TO_BCM_ENTRY(entry);
 
+     /* PTin modified: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+    int                stat_id;   /* PTin added: SDK 6.3.0 */
+
+    /* Get stat id for this entry */
+    rv = bcm_field_entry_stat_get(unit, entry, &stat_id);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        return rv;
+
+    /* Reset counters */
+    rv = bcm_field_stat_all_set(unit, stat_id, val1);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
+        return rv;
+
+    #else
     rv = bcm_field_counter_set(unit, eid, 0, val1);
     if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
         return rv;
 
     if (policyStage != BROAD_POLICY_STAGE_EGRESS)
     {
       rv = bcm_field_counter_set(unit, eid, 1, val1);  /* empty means no counter */
       if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
           return rv;
     }
+    #endif
 
     return BCM_E_NONE;
 }
 
 void policy_cfp_group_dataplane_cleanup(int                  unit,
@@ -2742,14 +3036,20 @@ void policy_cfp_group_dataplane_cleanup(
 
 /* Debug */
 
 void debug_cfp_group_stats(int unit)
 {
+    int groups_max;
     int rv, i;
-    bcm_field_status_t       stats;
     bcm_field_group_status_t gstats;
 
+    #if 1
+    sysapiPrintf("\nUnit %d Stats\n", unit);
+    groups_max = _policy_group_total_slices(unit, BROAD_POLICY_STAGE_INGRESS);
+    #else
+    bcm_field_status_t       stats;
+
     sysapiPrintf("\nUnit %d Stats\n", unit);
 
     rv = bcm_field_status_get(unit, &stats);
     if (BCM_E_NONE == rv)
         sysapiPrintf("Groups free %d, total %d", stats.group_free, stats.group_total);
@@ -2759,12 +3059,15 @@ void debug_cfp_group_stats(int unit)
         return;
     }
 
     sysapiPrintf("\n\n");
 
+    groups_max = stats.group_total;
+    #endif
+
     sysapiPrintf("Group  Prio   Entries   Counters   Meters\n");
-    for (i = 1; i <= stats.group_total; i++)
+    for (i = 1; i <= groups_max; i++)
     {
         sysapiPrintf("[%2d]   ", i);
 
         rv = bcm_field_group_status_get(unit, i, &gstats);
         if (BCM_E_NONE == rv)
@@ -2853,10 +3156,65 @@ void debug_cfp_sqset_table(int unit)
 }
 
 void debug_cfp_entry_counter(int unit, bcm_field_entry_t eid)
 {
     int    rv;
+
+    /* PTin modified: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+    int    i;
+    int    stat_id;
+    int    stat_size;
+    bcm_field_stat_t stat_type[4];
+    uint64 values[4];
+
+    /* Get stat id for this entry */
+    rv = bcm_field_entry_stat_get(unit, eid, &stat_id);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+    {
+      sysapiPrintf("Error with bcm_field_entry_stat_get\n");
+      return;
+    }
+
+    /* Get number of counters */
+    rv = bcm_field_stat_size(unit, stat_id, &stat_size);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+    {
+      sysapiPrintf("Error with bcm_field_stat_size\n");
+      return;
+    }
+    /* Limit number of counters to 2 */
+    if (stat_size>4)  stat_size = 4;
+
+    if (stat_size==0)
+    {
+      sysapiPrintf("No counters\n");
+      return;
+    }
+
+    /* Get collection of counters */
+    rv = bcm_field_stat_config_get(unit, stat_id, stat_size, stat_type);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+    {
+      sysapiPrintf("Error with bcm_field_stat_config_get\n");
+      return;
+    }
+
+    /* Get counters values */
+    rv = bcm_field_stat_multi_get(unit, stat_id, stat_size, stat_type, values);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+    {
+      sysapiPrintf("Error with bcm_field_stat_multi_get\n");
+      return;
+    }
+
+    /* Print counters */
+    for (i=0; i<stat_size; i++)
+    {
+      sysapiPrintf("Counter %d: %08x %08x\n", i, u64_H(values[i]), u64_L(values[i]));
+    }
+    #else
     uint64 val64;
 
     rv = bcm_field_counter_get(unit, eid, 0, &val64);
     if (BCM_E_NONE == rv)
         sysapiPrintf("Counter 0: %08x %08x\n", u64_H(val64), u64_L(val64));
@@ -2866,7 +3224,8 @@ void debug_cfp_entry_counter(int unit, b
     rv = bcm_field_counter_get(unit, eid, 1, &val64);
     if (BCM_E_NONE == rv)
         sysapiPrintf("Counter 1: %08x %08x\n", u64_H(val64), u64_L(val64));
     else
         sysapiPrintf("error code = %d\n", rv);
+    #endif
 }
 
diff -rpN --unified=5 esw_original/policy/broad_cfp_robo.h esw/policy/broad_cfp_robo.h
--- esw_original/policy/broad_cfp_robo.h	2013-03-08 12:34:34.680447344 +0000
+++ esw/policy/broad_cfp_robo.h	2013-07-22 20:39:45.069311960 +0100
@@ -34,20 +34,25 @@ int policy_cfp_group_create(int         
                         BROAD_POLICY_STAGE_t  policyStage,
                         BROAD_POLICY_ENTRY_t *policyData,
                         BROAD_GROUP_t        *group);
 
 int policy_cfp_group_add_rule(int                        unit,
-                          BROAD_POLICY_STAGE_t       policyStage,
-                          BROAD_GROUP_t              group,
-                          BROAD_POLICY_RULE_ENTRY_t *ruleInfo,
-                          bcm_pbmp_t                 pbm,
-                          BROAD_ENTRY_t             *entry);
+                              BROAD_POLICY_STAGE_t       policyStage,
+                              BROAD_GROUP_t              group,
+                              BROAD_POLICY_RULE_ENTRY_t *ruleInfo,
+                              bcm_pbmp_t                 pbm,
+                              BROAD_ENTRY_t             *entry,
+                              int                       *policer_id,      /* PTin added: SDK 6.3.0 */
+                              int                       *counter_id);
 
 int policy_cfp_group_delete_rule(int                  unit,
-                             BROAD_POLICY_STAGE_t policyStage,
-                             BROAD_GROUP_t        group,
-                             BROAD_ENTRY_t        entry);
+                                 BROAD_POLICY_STAGE_t policyStage,
+                                 BROAD_GROUP_t        group,
+                                 BROAD_ENTRY_t        entry,
+                                 int                  policer_id,   /* PTin added: SDK 6.3.0 */
+                                 int                  counter_id);
+
 
 int policy_cfp_group_rule_priority_set(int                          unit,
                                    BROAD_POLICY_STAGE_t         policyStage,
                                    BROAD_GROUP_t                group,
                                    BROAD_ENTRY_t                entry,
diff -rpN --unified=5 esw_original/policy/broad_group_bcm.c esw/policy/broad_group_bcm.c
--- esw_original/policy/broad_group_bcm.c	2013-03-08 12:34:34.684443967 +0000
+++ esw/policy/broad_group_bcm.c	2013-07-22 20:39:45.069311960 +0100
@@ -25,10 +25,16 @@
 #include "bcm/custom.h"
 
 #include "l7_usl_policy_db.h"
 #include "l7_usl_common.h"
 
+/* PTin added: includes */
+#if 1
+#include "logger.h"
+#include "ptin_globaldefs.h"
+#endif
+
 /* Policy Group Map Table Definitions */
 
 
 static policy_map_table_t *policy_map_table[SOC_MAX_NUM_DEVICES] = {0};     /* This structure only holds data for the policies local to a BCM unit. */
 static L7_short16         *policy_map_index_map[SOC_MAX_NUM_DEVICES] = {0}; /* This structure maps global policy IDs to an index into policy_map_table. */
@@ -203,11 +209,16 @@ static void _policy_group_set_default_pb
     case BROAD_POLICY_TYPE_STAT_EVC:    /* Ptin added: stats */
     case BROAD_POLICY_TYPE_STAT_CLIENT: /* Ptin added: stats */
     case BROAD_POLICY_TYPE_ISCSI:
         /* by default applies to all non-stacking ports */
         SOC_PBMP_OR(tempPbm, PBMP_E_ALL(unit));
+        /* TODO: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        LOG_WARNING(LOG_CTX_PTIN_HAPI, "TODO: LB ports not considered!");
+        #else
         SOC_PBMP_OR(tempPbm, PBMP_LB(unit));
+        #endif
         SOC_PBMP_ASSIGN(policyPtr->pbm, tempPbm);
         break;
     case BROAD_POLICY_TYPE_PORT:
     case BROAD_POLICY_TYPE_DOT1AD:
     case BROAD_POLICY_TYPE_IPSG:
@@ -314,11 +325,12 @@ static void _policy_table_init(int unit)
  * @param policer_id 
  * 
  * @return L7_RC_t : L7_SUCCESS / L7_FAILURE
  */
 L7_RC_t l7_bcm_policy_hwInfo_get(int unit, BROAD_POLICY_t policy_id, L7_uint rule_id,
-                                 BROAD_GROUP_t *group_id, BROAD_ENTRY_t *entry_id, L7_int *policer_id)
+                                 BROAD_GROUP_t *group_id, BROAD_ENTRY_t *entry_id,
+                                 int *policer_id, int *counter_id)    /* PTin added: SDK 6.3.0 */
 {
   L7_short16 policyIdx;
   policy_map_table_t  *policyPtr;
 
   /* Validate arguments */
@@ -342,10 +354,11 @@ L7_RC_t l7_bcm_policy_hwInfo_get(int uni
   }
 
   if (group_id!=L7_NULLPTR)   *group_id = policyPtr->group;
   if (entry_id!=L7_NULLPTR)   *entry_id = policyPtr->entry[rule_id];
   if (policer_id!=L7_NULLPTR) *policer_id = policyPtr->policer_id[rule_id];
+  if (counter_id!=L7_NULLPTR) *counter_id = policyPtr->counter_id[rule_id];
 
   return L7_SUCCESS;
 }
 /* PTin end */
 
@@ -697,11 +710,11 @@ static int _policy_apply_egress_mask(int
 
   /* Add the global default rule */
   if (globalPolicyPtr->entry != BROAD_ENTRY_INVALID)
   {
       /* PTin modified: policer */
-      policy_group_delete_rule(unit, BROAD_POLICY_STAGE_INGRESS, policyPtr->group, globalPolicyPtr->entry, 0);
+      policy_group_delete_rule(unit, BROAD_POLICY_STAGE_INGRESS, policyPtr->group, globalPolicyPtr->entry, 0, 0); /* PTin modified: SDK 6.3.0 */
       globalPolicyPtr->entry = BROAD_ENTRY_INVALID;
   }
 
   if (BCM_PBMP_NOT_NULL(globalPolicyPtr->unitEpbm))
   {
@@ -729,11 +742,11 @@ int l7_bcm_policy_create(int unit, BROAD
   BROAD_POLICY_RULE_ENTRY_t   *rulePtr;
   L7_uint32                    actions, actionMask;
   L7_ushort16                  ethType;
   policy_efp_on_ifp_table_t   *globalPolicyPtr;
   BROAD_ACTION_ENTRY_t        *actionPtr;
-  L7_int                       policer_id = 0;
+  L7_int                       policer_id = 0, counter_id = 0;  /* PTin added: SDK 6.3.0 */
 
   L7_ushort16 vlanId;
   L7_ushort16 mask;
 
   CHECK_UNIT(unit);
@@ -794,14 +807,17 @@ int l7_bcm_policy_create(int unit, BROAD
   }
 
   if (policyData->ruleCount > 0)
   {
     policyPtr->entry = osapiMalloc(L7_DRIVER_COMPONENT_ID, policyData->ruleCount * sizeof(policyPtr->entry[0]));
-    /* PTin added: policer */
+    /* PTin added: SDK 6.3.0 */
+    #if 1
     policyPtr->policer_id = osapiMalloc(L7_DRIVER_COMPONENT_ID, policyData->ruleCount * sizeof(policyPtr->policer_id[0]));
-    memset(policyPtr->policer_id,0x00,sizeof(policyPtr->policer_id[0]));
-    /* PTin end */
+    policyPtr->counter_id = osapiMalloc(L7_DRIVER_COMPONENT_ID, policyData->ruleCount * sizeof(policyPtr->counter_id[0]));
+    memset(policyPtr->policer_id, 0x00, policyData->ruleCount * sizeof(policyPtr->policer_id[0]));
+    memset(policyPtr->counter_id, 0x00, policyData->ruleCount * sizeof(policyPtr->counter_id[0]));
+    #endif
     if (policyPtr->entry == L7_NULL)
     {
       _policy_sem_give();
       if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
         sysapiPrintf("couldn't allocate memory for policy entries\n");
@@ -918,12 +934,11 @@ int l7_bcm_policy_create(int unit, BROAD
     {
       /* Delete the default deny rule now. It will be added back later after this policy's rules
          are put in HW. */
       if (globalPolicyPtr->entry != BROAD_ENTRY_INVALID)
       {
-        /* PTin modified: policer */
-        policy_group_delete_rule(unit, policyPtr->policyStage, policyPtr->group, globalPolicyPtr->entry, 0);
+        policy_group_delete_rule(unit, policyPtr->policyStage, policyPtr->group, globalPolicyPtr->entry, 0, 0); /* PTin modified: SDK 6.3.0 */
         globalPolicyPtr->entry = BROAD_ENTRY_INVALID;
       }
     }
 
     /* add new rules to policy */
@@ -1003,17 +1018,22 @@ int l7_bcm_policy_create(int unit, BROAD
 
       /* convert srcEntry from rule to entry number so lower layer understands */
       srcRule = rulePtr->meterSrcEntry;
       rulePtr->meterSrcEntry = policyPtr->entry[srcRule];
 
-      /* PTin modified: policer */
-      policer_id = 0;
-      rv = policy_group_add_rule(unit, policyPtr->policyStage, policyData->policyType, group, rulePtr, policyPtr->pbm, policyPtr->flags & GROUP_MAP_EFP_ON_IFP, &entry, &policer_id);
+      /* PTin modified: SDK 6.3.0 */
+      policer_id = counter_id = 0;
+      rv = policy_group_add_rule(unit, policyPtr->policyStage, policyData->policyType, group, rulePtr, policyPtr->pbm, policyPtr->flags & GROUP_MAP_EFP_ON_IFP,
+                                 &entry, &policer_id, &counter_id);
 
       if (entry != BROAD_ENTRY_INVALID)
       {
+        /* PTin added: SDK 6.3.0 */
+        #if 1
         policyPtr->policer_id[i] = policer_id;
+        policyPtr->counter_id[i] = counter_id;
+        #endif
         policyPtr->entry[i] = entry;
         policyPtr->entryCount++;
       }
       if (BCM_E_NONE != rv)
       {
@@ -1186,13 +1206,17 @@ int l7_bcm_policy_destroy(int unit, BROA
     /* remove each group entry used by policy */
     if (policyPtr->group != BROAD_GROUP_INVALID)
     {
       for (i = policyPtr->entryCount - 1; i >= 0 ; --i)
       {
-          /* PTin modified: policer */
-          tmprv = policy_group_delete_rule(unit, policyPtr->policyStage, policyPtr->group, policyPtr->entry[i], policyPtr->policer_id[i]);
-          policyPtr->policer_id[i] = 0;     /* PTin added: policer */
+          tmprv = policy_group_delete_rule(unit, policyPtr->policyStage, policyPtr->group, policyPtr->entry[i],
+                                           policyPtr->policer_id[i], policyPtr->counter_id[i]);     /* PTin added: SDK 6.3.0 */
+          /* PTin added: SDK 6.3.0 */
+          #if 1
+          policyPtr->policer_id[i] = 0;
+          policyPtr->counter_id[i] = 0;
+          #endif
           if (BCM_E_NONE != tmprv)
               rv = tmprv;
       }
 
       /* Determine if any other policy is using this group. If not, then destroy it. */
@@ -1215,12 +1239,11 @@ int l7_bcm_policy_destroy(int unit, BROA
         {
           /* If this policy was EFP on IFP, then we need to destroy the global rule. */
           globalPolicyPtr = &policy_efp_on_ifp_table[unit];
           if (globalPolicyPtr->entry != BROAD_ENTRY_INVALID)
           {
-              /* PTin modified: policer */
-              policy_group_delete_rule(unit, BROAD_POLICY_STAGE_INGRESS, policyPtr->group, globalPolicyPtr->entry,0);
+              policy_group_delete_rule(unit, BROAD_POLICY_STAGE_INGRESS, policyPtr->group, globalPolicyPtr->entry, 0, 0); /* PTin modified: SDK 6.3.0 */
               globalPolicyPtr->entry = BROAD_ENTRY_INVALID;
           }
         }
         tmprv = policy_group_destroy(unit, policyPtr->policyStage, policyPtr->group);
         if (BCM_E_NONE != tmprv)
@@ -1233,17 +1256,23 @@ int l7_bcm_policy_destroy(int unit, BROA
     if (policyPtr->entry != L7_NULL)
     {
       osapiFree(L7_DRIVER_COMPONENT_ID, policyPtr->entry);
     }
     policyPtr->entry = L7_NULL;
-    /* PTin added: policer */
+    /* PTin added: SDK 6.3.0 */
+    #if 1
     if (policyPtr->policer_id != L7_NULL)
     {
       osapiFree(L7_DRIVER_COMPONENT_ID, policyPtr->policer_id);
     }
     policyPtr->policer_id = L7_NULL;
-    /* PTin end*/
+    if (policyPtr->counter_id != L7_NULL)
+    {
+      osapiFree(L7_DRIVER_COMPONENT_ID, policyPtr->counter_id);
+    }
+    policyPtr->counter_id = L7_NULL;
+    #endif
 
     policyPtr->entryCount = 0;
     _policy_sem_give();
 
     if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
@@ -1784,12 +1813,11 @@ int l7_bcm_policy_stats(int unit, BROAD_
     memcpy(&val2_lo, &buffer[12], sizeof(val2_lo));
     COMPILER_64_SET(tmpVal1, val1_hi, val1_lo);
     COMPILER_64_SET(tmpVal2, val2_hi, val2_lo);
 
     /* query stats for entry -- in case of error this routine returns 0 */
-    tmprv = policy_group_get_stats(unit, policyPtr->policyStage, policyPtr->group, policyPtr->entry[ruleId],
-                                   &val1, &val2);
+    tmprv = policy_group_get_stats(unit, policyPtr->policyStage, policyPtr->group, policyPtr->entry[ruleId], &val1, &val2);
 
     if (tmprv < rv)
       rv = tmprv;     /* just get the worst error code */
 
     /* Accumulate the stats. */
diff -rpN --unified=5 esw_original/policy/broad_group_bcm.h esw/policy/broad_group_bcm.h
--- esw_original/policy/broad_group_bcm.h	2013-03-08 12:34:34.684443967 +0000
+++ esw/policy/broad_group_bcm.h	2013-07-22 20:39:45.073308743 +0100
@@ -111,11 +111,15 @@ typedef struct
 
 typedef struct
 {
     BROAD_GROUP_t                  group;
     BROAD_ENTRY_t                 *entry;
-    L7_int                        *policer_id;    /* PTin added: policer */
+    /* PTin added: SDK 6.3.0 */
+    #if 1
+    int                           *policer_id;
+    int                           *counter_id;
+    #endif
     bcm_pbmp_t                     pbm;
     unsigned char                  flags;
     BROAD_POLICY_TYPE_t            policyType;
     BROAD_POLICY_STAGE_t           policyStage;
     unsigned char                  portClass; /* Used for LOOKUP and EGRESS port classes */
@@ -140,11 +144,12 @@ policy_map_table_t;
  * @param policer_id 
  * 
  * @return L7_RC_t : L7_SUCCESS / L7_FAILURE
  */
 L7_RC_t l7_bcm_policy_hwInfo_get(int unit, BROAD_POLICY_t policy_id, L7_uint rule_id,
-                                 BROAD_GROUP_t *group_id, BROAD_ENTRY_t *entry_id, L7_int *policer_id);
+                                 BROAD_GROUP_t *group_id, BROAD_ENTRY_t *entry_id,
+                                 int *policer_id, int *counter_id);   /* PTin added: SDK 6.3.0 */
 /* PTin end */
 
 int l7_bcm_policy_init();
 
 int l7_bcm_policy_create(int unit, BROAD_POLICY_t policy, BROAD_POLICY_ENTRY_t *policyData, L7_BOOL shuffleAllowed);
diff -rpN --unified=5 esw_original/policy/broad_group_shuffle.c esw/policy/broad_group_shuffle.c
--- esw_original/policy/broad_group_shuffle.c	2013-03-08 12:34:34.684443967 +0000
+++ esw/policy/broad_group_shuffle.c	2013-07-22 20:39:45.073308743 +0100
@@ -22,10 +22,16 @@
 #include "broad_group_sqset.h"
 #include "broad_policy_types.h"
 #include "broad_group_xgs3.h"
 #include "l7_usl_policy_db.h"
 
+/* PTin added: includes */
+#if 1
+#include "logger.h"
+#include "ptin_globaldefs.h"
+#endif
+
 /* Group Definitions */
 
 #define GROUP_NONE               0
 #define GROUP_USED               1
 #define GROUP_EFP_ON_IFP         2
@@ -945,22 +951,30 @@ static int _policy_policy_destroy_with_c
       {
         COMPILER_64_ZERO(val1);
         COMPILER_64_ZERO(val2);
 
         rv = BCM_E_EMPTY;
-        if (policyInfo.policyStage == BROAD_POLICY_STAGE_EGRESS)
-        {
-          rv = bcm_field_counter_get(unit, policyInfo.entry[ruleId], 0, &val2);
-        }
-        else
-        {
-          rv = bcm_field_counter_get(unit, policyInfo.entry[ruleId], 0, &val1);
-          if (rv == BCM_E_NONE)
+
+        /* TODO: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+          LOG_WARNING(LOG_CTX_PTIN_HAPI,"Shuffle counters not supported!");
+          rv = BCM_E_UNAVAIL;
+        #else
+          if (policyInfo.policyStage == BROAD_POLICY_STAGE_EGRESS)
           {
-            rv = bcm_field_counter_get(unit, policyInfo.entry[ruleId], 1, &val2);
+            rv = bcm_field_counter_get(unit, policyInfo.entry[ruleId], 0, &val2);
           }
-        }
+          else
+          {
+            rv = bcm_field_counter_get(unit, policyInfo.entry[ruleId], 0, &val1);
+            if (rv == BCM_E_NONE)
+            {
+              rv = bcm_field_counter_get(unit, policyInfo.entry[ruleId], 1, &val2);
+            }
+          }
+        #endif
+
         if (rv == BCM_E_NONE)
         {
           counterPtr = osapiMalloc(L7_DRIVER_COMPONENT_ID, sizeof(*counterPtr));
           if (counterPtr != L7_NULL)
           {
@@ -1027,35 +1041,41 @@ static int _policy_counters_restore(int 
   {
     if (_policy_map_get_info(unit, counterPtr->policy, &policyInfo) == BCM_E_NONE)
     {
       if (counterPtr->ruleId < policyInfo.entryCount)
       {
-        if (policyInfo.policyStage == BROAD_POLICY_STAGE_EGRESS)
-        {
-          rv = bcm_field_counter_set(unit, policyInfo.entry[counterPtr->ruleId], 0, counterPtr->val2);
-          if (rv != BCM_E_NONE)
+        /* TODO: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+          LOG_WARNING(LOG_CTX_PTIN_HAPI,"Shuffle counters not supported!");
+          rv = BCM_E_UNAVAIL;
+        #else
+          if (policyInfo.policyStage == BROAD_POLICY_STAGE_EGRESS)
           {
-            if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
-              sysapiPrintf("- bcm_field_counter_set() returned %d\n", rv);
-          }
-        }
-        else
-        {
-          rv = bcm_field_counter_set(unit, policyInfo.entry[counterPtr->ruleId], 0, counterPtr->val1);
-          if (rv != BCM_E_NONE)
-          {
-            if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
-              sysapiPrintf("- bcm_field_counter_set() returned %d\n", rv);
+            rv = bcm_field_counter_set(unit, policyInfo.entry[counterPtr->ruleId], 0, counterPtr->val2);
+            if (rv != BCM_E_NONE)
+            {
+              if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
+                sysapiPrintf("- bcm_field_counter_set() returned %d\n", rv);
+            }
           }
-  
-          rv = bcm_field_counter_set(unit, policyInfo.entry[counterPtr->ruleId], 1, counterPtr->val2);
-          if (rv != BCM_E_NONE)
+          else
           {
-            if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
-              sysapiPrintf("- bcm_field_counter_set() returned %d\n", rv);
+            rv = bcm_field_counter_set(unit, policyInfo.entry[counterPtr->ruleId], 0, counterPtr->val1);
+            if (rv != BCM_E_NONE)
+            {
+              if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
+                sysapiPrintf("- bcm_field_counter_set() returned %d\n", rv);
+            }
+    
+            rv = bcm_field_counter_set(unit, policyInfo.entry[counterPtr->ruleId], 1, counterPtr->val2);
+            if (rv != BCM_E_NONE)
+            {
+              if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
+                sysapiPrintf("- bcm_field_counter_set() returned %d\n", rv);
+            }
           }
-        }
+        #endif
       }
       else
       {
         if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_LOW)
           sysapiPrintf("- bad ruleId %d in policy %d, entryCount %d\n", counterPtr->ruleId, counterPtr->policy, policyInfo.entryCount);
diff -rpN --unified=5 esw_original/policy/broad_group_sqset.c esw/policy/broad_group_sqset.c
--- esw_original/policy/broad_group_sqset.c	2013-03-08 12:34:34.684443967 +0000
+++ esw/policy/broad_group_sqset.c	2013-07-22 20:39:45.073308743 +0100
@@ -16,10 +16,12 @@
 *
 **********************************************************************/
 #include "flex.h"
 #include "broad_group_sqset.h"
 
+#include "ptin_globaldefs.h"
+
 /* Super QSet Definitions */
 /* Only qualifiers that were explicitly requested can be used in rule
  * definitions. Therefore, we define super qsets to encompass as many
  * fields as possible to maximize the utility of each group that is
  * created.
@@ -147,11 +149,16 @@ bcm_field_qualify_t l2l3l4SrcMacGroupQse
     bcmFieldQualifyDstMac,
     bcmFieldQualifySrcIp,
     bcmFieldQualifyDstIp,
     bcmFieldQualifyEtherType,
     bcmFieldQualifyOuterVlan,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifySrcClassL2,
+#else
     bcmFieldQualifySrcMacGroup,
+#endif
     bcmFieldQualifyL2Format,
     bcmFieldQualifyVlanFormat,
     bcmFieldQualifyIpType,
     bcmFieldQualifyIpProtocol,
     bcmFieldQualifyL4SrcPort,
@@ -186,12 +193,22 @@ bcm_field_qualify_t l2l3l4ClassIdQset[] 
     bcmFieldQualifyDSCP,
     bcmFieldQualifyL2StationMove,
     bcmFieldQualifyL3DestRouteHit,
     bcmFieldQualifyL3DestHostHit,
     bcmFieldQualifyIngressStpState,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyDstClassField,
+#else
     bcmFieldQualifyLookupClass0,
+#endif
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifySrcClassL2,
+#else
     bcmFieldQualifySrcMacGroup,
+#endif
     bcmFieldQualifyStageIngress
 };
 
 #define l2l3l4ClassIdQsetSize (sizeof(l2l3l4ClassIdQset) / sizeof(bcm_field_qualify_t))
 
@@ -218,12 +235,22 @@ bcm_field_qualify_t l2l3l4Xgs4ClassIdQse
     bcmFieldQualifyDSCP,
     bcmFieldQualifyL2StationMove,
     bcmFieldQualifyL3DestRouteHit,
     bcmFieldQualifyL3DestHostHit,
     bcmFieldQualifyIngressStpState,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyDstClassField,
+#else
     bcmFieldQualifyLookupClass0,
+#endif
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifySrcClassL2,
+#else
     bcmFieldQualifySrcMacGroup,
+#endif
     bcmFieldQualifyStageIngress
 };
 
 #define l2l3l4Xgs4ClassIdQsetSize (sizeof(l2l3l4Xgs4ClassIdQset) / sizeof(bcm_field_qualify_t))
 
@@ -417,12 +444,22 @@ bcm_field_qualify_t ipv6L3L4ClassIdQset[
     bcmFieldQualifyL3DestHostHit,
     bcmFieldQualifyIngressStpState,
     bcmFieldQualifyL2Format,
     bcmFieldQualifyVlanFormat,
     bcmFieldQualifyIpType,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyDstClassField,
+#else
     bcmFieldQualifyLookupClass0,
+#endif
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifySrcClassL2,
+#else
     bcmFieldQualifySrcMacGroup,
+#endif
     bcmFieldQualifyStageIngress
 };
 
 #define ipv6L3L4ClassIdQsetSize (sizeof(ipv6L3L4ClassIdQset) / sizeof(bcm_field_qualify_t))
 
@@ -439,12 +476,22 @@ bcm_field_qualify_t ipv6SrcL4ClassIdQset
     bcmFieldQualifyL3DestHostHit,
     bcmFieldQualifyIngressStpState,
     bcmFieldQualifyL2Format,
     bcmFieldQualifyVlanFormat,
     bcmFieldQualifyIpType,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyDstClassField,
+#else
     bcmFieldQualifyLookupClass0,
+#endif
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifySrcClassL2,
+#else
     bcmFieldQualifySrcMacGroup,
+#endif
     bcmFieldQualifyStageIngress
 };
 
 #define ipv6SrcL4ClassIdQsetSize (sizeof(ipv6SrcL4ClassIdQset) / sizeof(bcm_field_qualify_t))
 
@@ -461,12 +508,22 @@ bcm_field_qualify_t ipv6DstL4ClassIdQset
     bcmFieldQualifyL3DestHostHit,
     bcmFieldQualifyIngressStpState,
     bcmFieldQualifyL2Format,
     bcmFieldQualifyVlanFormat,
     bcmFieldQualifyIpType,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyDstClassField,
+#else
     bcmFieldQualifyLookupClass0,
+#endif
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifySrcClassL2,
+#else
     bcmFieldQualifySrcMacGroup,
+#endif
     bcmFieldQualifyStageIngress
 };
 
 #define ipv6DstL4ClassIdQsetSize (sizeof(ipv6DstL4ClassIdQset) / sizeof(bcm_field_qualify_t))
 
@@ -518,14 +575,18 @@ bcm_field_qualify_t l2QsetEgress[] =    
     bcmFieldQualifySrcMac,
     bcmFieldQualifyDstMac,
     bcmFieldQualifyEtherType,
     bcmFieldQualifyOuterVlan,
     bcmFieldQualifyInnerVlanId,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyInterfaceClassPort,
+#else
     bcmFieldQualifyPortClass,
+#endif
     bcmFieldQualifyOutPort,
     bcmFieldQualifyVlanFormat,
-    bcmFieldQualifyPortClass,     /* PTin added: FP */
     bcmFieldQualifyDstIp,         /* PTin added: FP */
     bcmFieldQualifyDrop,          /* PTin added: FP */
     bcmFieldQualifyStageEgress
 };
 #define l2QsetEgressSize (sizeof(l2QsetEgress) / sizeof(bcm_field_qualify_t))
@@ -537,11 +598,16 @@ bcm_field_qualify_t l3l4QsetEgress[] =  
     bcmFieldQualifyOuterVlan,
     bcmFieldQualifyIpProtocol,
     bcmFieldQualifyL4SrcPort,
     bcmFieldQualifyL4DstPort,
     bcmFieldQualifyDSCP,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyInterfaceClassPort,
+#else
     bcmFieldQualifyPortClass,
+#endif
     bcmFieldQualifyOutPort,
     bcmFieldQualifyIp4,
     bcmFieldQualifyVlanFormat,
     bcmFieldQualifyDrop,          /* PTin added: FP */
     bcmFieldQualifyStageEgress
@@ -556,11 +622,16 @@ bcm_field_qualify_t ipv6L3L4QsetEgress[]
     bcmFieldQualifyDstIp6,          
     bcmFieldQualifyTos,          
     bcmFieldQualifyIp6NextHeader,          
     bcmFieldQualifyL4SrcPort,     /* also used for ICMP Msg Type */
     bcmFieldQualifyL4DstPort,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyInterfaceClassPort,
+#else
     bcmFieldQualifyPortClass,
+#endif
     bcmFieldQualifyOutPort,
     bcmFieldQualifyIp6,
     bcmFieldQualifyDrop,          /* PTin added: FP */
     bcmFieldQualifyStageEgress
 };
@@ -568,11 +639,16 @@ bcm_field_qualify_t ipv6L3L4QsetEgress[]
 
 /* SQSet used for double wide mode policies */
 bcm_field_qualify_t l2l3l4QsetLookup[] =    /* l2/l3 */
 {
     bcmFieldQualifyInPort,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyInterfaceClassPort,
+#else
     bcmFieldQualifyPortClass,
+#endif
     bcmFieldQualifySrcMac,
     bcmFieldQualifySrcIp,
     bcmFieldQualifyDstIp,
     bcmFieldQualifyOuterVlan,
     bcmFieldQualifyIpProtocol,
@@ -589,11 +665,16 @@ bcm_field_qualify_t l2l3l4QsetLookup[] =
  * DOT1AD specific QSET with vlan format and both VLANs                       *
  *****************************************************************************/
 bcm_field_qualify_t dot1adQsetLookup[] =    /* dot1ad specific qset */
 {                                                  
     bcmFieldQualifyInPort,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyInterfaceClassPort,
+#else
     bcmFieldQualifyPortClass,
+#endif
     bcmFieldQualifyOuterVlan,
     bcmFieldQualifyInnerVlan,
     bcmFieldQualifyL2Format,
     bcmFieldQualifyVlanFormat,
     bcmFieldQualifyIpType,
@@ -604,11 +685,16 @@ bcm_field_qualify_t dot1adQsetLookup[] =
 
 /* This sqset is shared by LLPF and IPSG. */
 static bcm_field_qualify_t llpfQsetLookup[] =    /* llpf specific qset */
 {                                                  
     bcmFieldQualifyInPort,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyInterfaceClassPort,
+#else
     bcmFieldQualifyPortClass,
+#endif
     bcmFieldQualifySrcMac,
     bcmFieldQualifyDstMac,
     bcmFieldQualifySrcIp,
     bcmFieldQualifyIpProtocol,
     bcmFieldQualifyL4DstPort,
@@ -622,11 +708,16 @@ static bcm_field_qualify_t llpfQsetLooku
 #define llpfQsetLookupSize (sizeof(llpfQsetLookup) / sizeof(bcm_field_qualify_t))
 
 bcm_field_qualify_t ipv6L3L4QsetLookup[] =  /* includes VLAN ID */
 {
     bcmFieldQualifyInPort,
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyInterfaceClassPort,
+#else
     bcmFieldQualifyPortClass,
+#endif
     bcmFieldQualifyOuterVlan,
     bcmFieldQualifySrcMac,
     bcmFieldQualifyDstMac,
     bcmFieldQualifyEtherType,
     bcmFieldQualifySrcIp6,          
diff -rpN --unified=5 esw_original/policy/broad_group_xgs3.c esw/policy/broad_group_xgs3.c
--- esw_original/policy/broad_group_xgs3.c	2013-06-27 01:13:08.607594788 +0100
+++ esw/policy/broad_group_xgs3.c	2013-07-22 20:51:43.283564604 +0100
@@ -16,20 +16,34 @@
 *
 * @end
 *
 **********************************************************************/
 
+/* PTin added: includes */
+#if 1
+#include "ptin_globaldefs.h"
+#endif
+
 #include "broad_group_xgs3.h"
 #include "bcm/field.h"
 #include "bcm/policer.h"    /* PTin added: policer */
 #include "ibde.h"
 #include "sal/core/libc.h"
 #include "osapi_support.h"
 #include "broad_group_sqset.h"
 #include "broad_group_shuffle.h"
 #include "platform_config.h"
-#include "logger.h"         /* PTin added: for debug purposes */
+
+/* PTin added: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+#include "bcm_int/ea/tk371x/field.h"
+#endif
+
+/* PTin added: includes */
+#if 1
+#include "logger.h"
+#endif
 
 /* used for the Higig B0 workaround */
 #include <soc/drv.h>
 #include <bcm_int/control.h>
 
@@ -64,22 +78,32 @@ static bcm_field_qualify_t field_map[BRO
     bcmFieldQualifyDstIp6,         /* Destination IPv6 Address */
     bcmFieldQualifyIp6FlowLabel,   /* IPv6 Flow Label */
     bcmFieldQualifyIp6TrafficClass,/* IPv6 Traffic Class */
     customFieldQualifyIcmpMsgType, /* ICMP Message Type   */
     //bcmFieldQualifyLookupClass0,    /* Class ID from VFP, to be used in IFP */
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifySrcClassL2,
+#else
     bcmFieldQualifySrcMacGroup,     /* Class ID from L2X, to be used in IFP */
+#endif
     customFieldQualifyUdf1,         /* iSCSI PDU opCode field */
     customFieldQualifyUdf1,         /* iSCSI PDU opCode field, w/ TCP options */
     bcmFieldQualifyTcpControl,
     bcmFieldQualifyVlanFormat,     /* VLAN Format */
     bcmFieldQualifyL2Format,       /* L2 Header Format */
     bcmFieldQualifySnap,           /* SNAP Header */ 
     bcmFieldQualifyIpType,         /* IP Type */
     bcmFieldQualifyInPorts,        /* InPorts, PTin added: FP */
     bcmFieldQualifyOutPort,        /* OutPort, PTin added: FP */
     bcmFieldQualifySrcTrunk,       /* SrcTrunk, PTin added: FP */
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    bcmFieldQualifyInterfaceClassPort,
+#else
     bcmFieldQualifyPortClass,      /* PortClass, PTin added: FP */
+#endif
     bcmFieldQualifyDrop,           /* Drop, PTin added: FP */
     //bcmFieldQualifyL2StationMove   /* L2 Station move, PTin added: FP */
 };
 
 /* Action Map */
@@ -1331,18 +1355,19 @@ static int _policy_super_qset_init_ifp(i
     applicable_policy_types[BROAD_POLICY_TYPE_PORT] = L7_TRUE;
     applicable_policy_types[BROAD_POLICY_TYPE_VLAN] = L7_TRUE;
 
     if (policy_stage_supported(unit, BROAD_POLICY_STAGE_LOOKUP))
     {
-      // PTin added: new switch => SOC_IS_VALKYRIE2
+      /* PTin updated: platform */
       if ( SOC_IS_TRIUMPH2(unit) ||
            SOC_IS_TRIUMPH(unit)  ||
            SOC_IS_APOLLO(unit)   ||
            SOC_IS_ENDURO(unit)   ||
            SOC_IS_SCORPION(unit) ||
            SOC_IS_VALKYRIE2(unit)||
-           SOC_IS_TRIDENT(unit)     /* PTin added: new switch BCM56843 */
+           SOC_IS_TRIDENT(unit)  || /* PTin added: new switch BCM56843 */
+           SOC_IS_TRIUMPH3(unit)    /* PTin added: new switch BCM56643 */
          )
       {
         _policy_super_qset_add(unit, &l2l3l4Xgs4ClassIdQsetDef, applicable_policy_types);
       }
       else
@@ -1390,12 +1415,13 @@ static int _policy_super_qset_init_ifp(i
   applicable_policy_types[BROAD_POLICY_TYPE_COSQ]        = L7_TRUE;
   applicable_policy_types[BROAD_POLICY_TYPE_PTIN]        = L7_TRUE;   /* PTin added: policer */
   applicable_policy_types[BROAD_POLICY_TYPE_STAT_EVC]    = L7_TRUE;   /* PTin added: stats */
   applicable_policy_types[BROAD_POLICY_TYPE_STAT_CLIENT] = L7_TRUE;   /* PTin added: stats */
 
-  // PTin added: new switch => SOC_IS_VALKYRIE2 + SOC_IS_TRIDENT
-  if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_ENDURO(unit) || SOC_IS_VALKYRIE2(unit) || SOC_IS_TRIDENT(unit))
+  /* PTin updated: platform */
+  if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_ENDURO(unit) || SOC_IS_VALKYRIE2(unit) || SOC_IS_TRIDENT(unit) ||
+      SOC_IS_TRIUMPH3(unit))        /* PTin added: new switch BCM56643 */
   {
     if (SOC_IS_TRIDENT(unit))
       LOG_WARNING(LOG_CTX_MISC, "Using systemQsetTriumph2Def for TRIDENT family!");
 
     /* Doublewide mode. */
@@ -1523,18 +1549,19 @@ static int _policy_super_qset_init(int u
   return BCM_E_NONE;
 }
 
 static int _policy_action_map_init(int unit)
 {
-  // PTin added: new switch => SOC_IS_VALKYRIE2
+  /* PTin updated: platform */
   if ((SOC_IS_TR_VL(unit)) ||
       (SOC_IS_SCORPION(unit)) || 
       (SOC_IS_TRIUMPH2(unit)) || 
       (SOC_IS_APOLLO(unit)) ||
       (SOC_IS_ENDURO(unit)) ||
       (SOC_IS_VALKYRIE2(unit)) ||
-      (SOC_IS_TRIDENT(unit)))   /* PTin added: new switch BCM56843 */
+      (SOC_IS_TRIDENT(unit)) ||     /* PTin added: new switch BCM56843 */
+      (SOC_IS_TRIUMPH3(unit)) )     /* PTin added: new switch BCM56643 */
   {
     /* Modify action maps for certain actions. */
     memcpy(&ingress_action_map[BROAD_ACTION_SET_COSQ],     &xgs4_ingress_set_cosq_action_map,     sizeof(action_map_entry_t));
     memcpy(&ingress_action_map[BROAD_ACTION_SET_USERPRIO], &xgs4_ingress_set_userprio_action_map, sizeof(action_map_entry_t));
 
@@ -2059,12 +2086,13 @@ int _policy_group_calc_qset(int         
                 if (temp16 & BROAD_LOOKUPSTATUS_VXLT_HIT)
                   BCM_FIELD_QSET_ADD(resourceReq->qsetAgg, bcmFieldQualifyVlanTranslationHit);
 
                 if (temp16 & BROAD_LOOKUPSTATUS_TUNNEL_HIT)
                 {
-                  // PTin added: new switch => SOC_IS_VALKYRIE2
-                  if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_ENDURO(unit) || SOC_IS_VALKYRIE2(unit))
+                  /* PTin updated: platform */
+                  if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_ENDURO(unit) || SOC_IS_VALKYRIE2(unit) ||
+                      SOC_IS_TRIUMPH3(unit))        /* PTin added: new switch BCM56643 */
                   {
                     /* TunnelTerminated not supported in IFP, so check for TunnelType instead. */
                     BCM_FIELD_QSET_ADD(resourceReq->qsetAgg, bcmFieldQualifyTunnelType);
                   }
                   else
@@ -2118,20 +2146,30 @@ int _policy_group_calc_qset(int         
     case BROAD_POLICY_TYPE_SYSTEM_PORT:
     case BROAD_POLICY_TYPE_COSQ:
       if (entryPtr->policyStage == BROAD_POLICY_STAGE_LOOKUP)
       {
         BCM_FIELD_QSET_ADD(resourceReq->qsetAgg, bcmFieldQualifyInPort);
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        BCM_FIELD_QSET_ADD(resourceReq->qsetAgg, bcmFieldQualifyInterfaceClassPort);
+        #else
         BCM_FIELD_QSET_ADD(resourceReq->qsetAgg, bcmFieldQualifyPortClass);
+        #endif
       }
       else if (entryPtr->policyStage == BROAD_POLICY_STAGE_INGRESS)
       {
         BCM_FIELD_QSET_ADD(resourceReq->qsetAgg, bcmFieldQualifyInPorts);
       }
       else if (entryPtr->policyStage == BROAD_POLICY_STAGE_EGRESS)
       {
         BCM_FIELD_QSET_ADD(resourceReq->qsetAgg, bcmFieldQualifyOutPort);
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        BCM_FIELD_QSET_ADD(resourceReq->qsetAgg, bcmFieldQualifyInterfaceClassPort);
+        #else
         BCM_FIELD_QSET_ADD(resourceReq->qsetAgg, bcmFieldQualifyPortClass);
+        #endif
       }
       break;
 
     default:
       break;
@@ -2156,10 +2194,15 @@ static int _policy_group_resource_check(
 
   rv = bcm_field_group_status_get(unit, gid, &stat);
   if (BCM_E_NONE != rv)
     return rv;
 
+//sysapiPrintf("  GID=%d: Entries free/total %d/%d, counters free/total %d/%d, meters free/total %d/%d\n", gid,
+//       stat.entries_free, stat.entries_total,
+//       stat.counters_free, stat.counters_total,
+//       stat.meters_free, stat.counters_total);
+
   _policy_group_status_to_sqset_width(&stat, &groupSqsetWidth);
 
   /* If this policy would require expansion of a group that is wider than the 
      policy needs, don't allow this to occur. The policy can be created w/ the
      minimal sqset later on. */
@@ -2210,11 +2253,13 @@ static int _policy_group_resource_check(
   else
   {
     rv = BCM_E_RESOURCE;
   }
 
-  return rv;
+  /* TODO: SDK 6.3.0 */
+  //return rv;
+  return BCM_E_NONE;
 }
 
 static int _policy_group_find_group(int                             unit,
                                     BROAD_POLICY_ENTRY_t           *entryPtr,
                                     policy_resource_requirements_t *resourceReq,
@@ -2419,92 +2464,96 @@ static int _policy_group_delete_group(in
 
 /* Group Management Functions */
 static void _policy_group_lookupstatus_convert(L7_ushort16 hapiStatus, L7_ushort16 *bcmStatus, L7_BOOL isMask)
 {
   *bcmStatus = 0;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if 1
   if (hapiStatus & BROAD_LOOKUPSTATUS_DOS_ATTACK_PKT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_DOS_ATTACK;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_DOS_ATTACK_PKT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_UNRESOLVED_SA)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L2_MISS;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_UNRESOLVED_SA;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_LPM_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3_LPM_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_LPM_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_STARGV_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3MC_SGV_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_STARGV_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L3_DST_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3UC_DA_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L3_DST_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L3_UC_SRC_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3UC_SA_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L3_UC_SRC_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L2_USER_ENTRY_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L2_CACHE_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L2_USER_ENTRY_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L2_TABLE_DST_L3)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3_ROUTABLE;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L2_TABLE_DST_L3;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L2_DST_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L2_DA_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L2_DST_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L2_SRC_STATIC)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L2_SA_STATIC;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L2_SRC_STATIC;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_L2_SRC_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L2_SA_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_L2_SRC_HIT;
   }
   if (isMask)
   {
     if (hapiStatus & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK)
     {
-      *bcmStatus |= BCM_FIELD_LOOKUP_ING_STP_MASK;
+      *bcmStatus |= BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK;
     }
   }
   else
   {
     if ((hapiStatus & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK) == BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_DIS)
     {
-      *bcmStatus |= BCM_FIELD_LOOKUP_ING_STP_DIS;
+      *bcmStatus |= BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_DIS;
     }
     if ((hapiStatus & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK) == BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_BLK)
     {
-      *bcmStatus |= BCM_FIELD_LOOKUP_ING_STP_BLK;
+      *bcmStatus |= BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_BLK;
     }
     if ((hapiStatus & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK) == BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_LRN)
     {
-      *bcmStatus |= BCM_FIELD_LOOKUP_ING_STP_LRN;
+      *bcmStatus |= BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_LRN;
     }
     if ((hapiStatus & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK) == BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_FWD)
     {
-      *bcmStatus |= BCM_FIELD_LOOKUP_ING_STP_FWD;
+      *bcmStatus |= BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_FWD;
     }
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_FB_VLAN_ID_VALID)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_VLAN_VALID;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_FB_VLAN_ID_VALID;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_VXLT_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_VXLT_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_VXLT_HIT;
   }
   if (hapiStatus & BROAD_LOOKUPSTATUS_TUNNEL_HIT)
   {
-    *bcmStatus |= BCM_FIELD_LOOKUP_L3_TUN_HIT;
+    *bcmStatus |= BROAD_LOOKUPSTATUS_TUNNEL_HIT;
   }
+  #endif
 }
 
 static int _policy_group_add_std_field(int                   unit,
                                        BROAD_POLICY_STAGE_t  policyStage,
                                        bcm_field_entry_t     eid,
@@ -2608,11 +2657,16 @@ static int _policy_group_add_std_field(i
           {
             rv = bcm_field_qualify_InnerVlan(unit, eid, tempVlan, tempVlanMask);
           }
           if ((BCM_E_NONE == rv) && ((tempVlan != 0) || (tempVlanMask != 0)))
           {
+            /* PTin modified: SDK 6.3.0 */
+            #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+            rv = bcm_field_qualify_VlanFormat(unit, eid, BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED | BCM_FIELD_VLAN_FORMAT_INNER_TAGGED, 0xff);
+            #else
             rv = bcm_field_qualify_VlanFormat(unit, eid, BCM_FIELD_PKT_FMT_INNER_TAGGED, BCM_FIELD_PKT_FMT_INNER_TAGGED);
+            #endif
           }
         }
         break;
     case BROAD_FIELD_DSCP:
         rv = bcm_field_qualify_DSCP(unit, eid, *((uint8*)value), *((uint8*)mask));
@@ -2688,11 +2742,16 @@ static int _policy_group_add_std_field(i
         break;
 //  case BROAD_FIELD_CLASS_ID:
 //      rv = bcm_field_qualify_LookupClass0(unit, eid, *((uint8*)value), 0xF);
 //      break;
     case BROAD_FIELD_L2_CLASS_ID:
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        rv = bcm_field_qualify_SrcClassL2(unit, eid, *((uint8*)value), 0xF);
+        #else
         rv = bcm_field_qualify_SrcMacGroup(unit, eid, *((uint8*)value), 0xF);
+        #endif
         break;
     case BROAD_FIELD_LOOKUP_STATUS:
         tempValue16 = value[0]<<8;
         tempValue16 |= value[1];
         _policy_group_lookupstatus_convert(tempValue16, &lookupStatus,     L7_FALSE);
@@ -2787,11 +2846,16 @@ static int _policy_group_add_std_field(i
         break;
     case BROAD_FIELD_SRCTRUNK:
         rv = bcm_field_qualify_SrcTrunk(unit, eid, *((bcm_trunk_t*)value), *((bcm_trunk_t*)mask));
         break;
     case BROAD_FIELD_PORTCLASS:
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        rv = bcm_field_qualify_InterfaceClassPort(unit, eid, *((uint32*)value), *((uint32*)mask));
+        #else
         rv = bcm_field_qualify_PortClass(unit, eid, *((uint32*)value), *((uint32*)mask));
+        #endif
         break;
     case BROAD_FIELD_DROP:
         rv = bcm_field_qualify_Drop(unit,eid,*((uint8*)value),1);
         break;
 //  case BROAD_FIELD_L2_STATION_MOVE:
@@ -2805,142 +2869,145 @@ static int _policy_group_add_std_field(i
 
     return rv;
 }
 static int _policy_group_lookupstatus_qualify(int unit, bcm_field_entry_t entry, L7_uint32 data, L7_uint32 mask)
 {
+  /* PTin modified: SDK 6.3.0 */
+  #if 1
   uint32 value;
 
-  if (mask & BCM_FIELD_LOOKUP_DOS_ATTACK)
+  if (mask & BROAD_LOOKUPSTATUS_DOS_ATTACK_PKT)
   {
-    value = (data & BCM_FIELD_LOOKUP_DOS_ATTACK) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_DOS_ATTACK_PKT) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN(bcm_field_qualify_DosAttack(unit, entry, value, 0x1));
   }
   
-  if (mask & BCM_FIELD_LOOKUP_L2_MISS) 
+  if (mask & BROAD_LOOKUPSTATUS_UNRESOLVED_SA) 
   {
-    value = (data & BCM_FIELD_LOOKUP_L2_MISS) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_UNRESOLVED_SA) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_L2StationMove(unit, entry, value, 0x1));
   }
   
-  if (mask & BCM_FIELD_LOOKUP_L3_LPM_HIT) 
+  if (mask & BROAD_LOOKUPSTATUS_LPM_HIT) 
   {
-    value = (data & BCM_FIELD_LOOKUP_L3_LPM_HIT) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_LPM_HIT) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_L3DestRouteHit(unit, entry, value, 0x1));
   }
   
-  if (mask & BCM_FIELD_LOOKUP_L3MC_SGV_HIT) 
+  if (mask & BROAD_LOOKUPSTATUS_STARGV_HIT) 
   {
-    value = (data & BCM_FIELD_LOOKUP_L3MC_SGV_HIT) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_STARGV_HIT) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_IpmcStarGroupHit(unit, entry, value, 0x1));
   }
 
-  if (mask & BCM_FIELD_LOOKUP_L3UC_DA_HIT) 
+  if (mask & BROAD_LOOKUPSTATUS_L3_DST_HIT) 
   {
-    value = (data & BCM_FIELD_LOOKUP_L3UC_DA_HIT) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_L3_DST_HIT) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_L3DestHostHit(unit, entry, value, 0x1));
   }
 
-  if (mask & BCM_FIELD_LOOKUP_L3UC_SA_HIT) 
+  if (mask & BROAD_LOOKUPSTATUS_L3_UC_SRC_HIT) 
   {
-    value = (data & BCM_FIELD_LOOKUP_L3UC_SA_HIT) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_L3_UC_SRC_HIT) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_L3SrcHostHit(unit, entry, value, 0x1));
   }
 
-  if (mask & BCM_FIELD_LOOKUP_L2_CACHE_HIT) 
+  if (mask & BROAD_LOOKUPSTATUS_L2_USER_ENTRY_HIT) 
   {
-    value = (data & BCM_FIELD_LOOKUP_L2_CACHE_HIT) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_L2_USER_ENTRY_HIT) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_L2CacheHit(unit, entry, value, 0x1));
   }
 
-  if (mask & BCM_FIELD_LOOKUP_L2_DA_HIT) 
+  if (mask & BROAD_LOOKUPSTATUS_L2_DST_HIT) 
   {
-    value = (data & BCM_FIELD_LOOKUP_L2_DA_HIT) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_L2_DST_HIT) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_L2DestHit(unit, entry, value, 0x1));
   }
 
-  if (mask & BCM_FIELD_LOOKUP_L2_SA_STATIC) 
+  if (mask & BROAD_LOOKUPSTATUS_L2_SRC_STATIC) 
   {
-    value = (data & BCM_FIELD_LOOKUP_L2_SA_STATIC) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_L2_SRC_STATIC) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_L2SrcStatic(unit, entry, value, 0x1));
   }
   
-  if (mask & BCM_FIELD_LOOKUP_L2_SA_HIT) 
+  if (mask & BROAD_LOOKUPSTATUS_L2_SRC_HIT) 
   {
-    value = (data & BCM_FIELD_LOOKUP_L2_SA_HIT) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_L2_SRC_HIT) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_L2SrcHit(unit, entry, value, 0x1));
   }
 
-  if (mask & BCM_FIELD_LOOKUP_ING_STP_MASK) 
+  if (mask & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK) 
   {
-    switch (data & BCM_FIELD_LOOKUP_ING_STP_MASK) 
+    switch (data & BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_MASK)
     {
-      case BCM_FIELD_LOOKUP_ING_STP_DIS:
+      case BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_DIS:
         value = BCM_STG_STP_DISABLE;
         break;
-      case BCM_FIELD_LOOKUP_ING_STP_BLK:
+      case BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_BLK:
         value = BCM_STG_STP_BLOCK;
         break;
-      case BCM_FIELD_LOOKUP_ING_STP_LRN:
+      case BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_LRN:
         value = BCM_STG_STP_LEARN;
         break;
-      case BCM_FIELD_LOOKUP_ING_STP_FWD:
+      case BROAD_LOOKUPSTATUS_INGRESS_SPG_STATE_FWD:
         value = BCM_STG_STP_FORWARD;
         break;
       default:
         return (BCM_E_PARAM);
     }
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_IngressStpState(unit, entry, value, 0x3));
   }
 
-  if (mask & BCM_FIELD_LOOKUP_VLAN_VALID) 
+  if (mask & BROAD_LOOKUPSTATUS_FB_VLAN_ID_VALID) 
   {
-    value = (data & BCM_FIELD_LOOKUP_VLAN_VALID) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_FB_VLAN_ID_VALID) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_ForwardingVlanValid(unit, entry, value, 0x1));
   }
 
-  if (mask & BCM_FIELD_LOOKUP_VXLT_HIT)
+  if (mask & BROAD_LOOKUPSTATUS_VXLT_HIT)
   {
-    value = (data & BCM_FIELD_LOOKUP_VXLT_HIT) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_VXLT_HIT) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
         (bcm_field_qualify_VlanTranslationHit(unit, entry, value, 0x1));
   }
 
-  if (mask & BCM_FIELD_LOOKUP_L3_TUN_HIT)
+  if (mask & BROAD_LOOKUPSTATUS_TUNNEL_HIT)
   {
-    // PTin added: new switch => SOC_IS_VALKYRIE2
-    if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_ENDURO(unit) || SOC_IS_VALKYRIE2(unit))
+    /* PTin updated: platform */
+    if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_ENDURO(unit) || SOC_IS_VALKYRIE2(unit) ||
+        SOC_IS_TRIUMPH3(unit))      /* PTin added: new switch BCM56643 */
     {
       /* TunnelTerminated not supported in IFP, use TunnelType instead. */
       BCM_IF_ERROR_RETURN
         (bcm_field_qualify_TunnelType(unit, entry, bcmFieldTunnelTypeIp));
     }
     else
     {
-      value = (data & BCM_FIELD_LOOKUP_L3_TUN_HIT) ? 0x1 : 0x0;
+      value = (data & BROAD_LOOKUPSTATUS_TUNNEL_HIT) ? 0x1 : 0x0;
       BCM_IF_ERROR_RETURN
         (bcm_field_qualify_TunnelTerminated(unit, entry, value, 0x1));
     }
   }
 
-  if ((mask & BCM_FIELD_LOOKUP_L3_ROUTABLE)) 
+  if ((mask & BROAD_LOOKUPSTATUS_L2_TABLE_DST_L3)) 
   {
-    value = (data & BCM_FIELD_LOOKUP_L3_ROUTABLE) ? 0x1 : 0x0;
+    value = (data & BROAD_LOOKUPSTATUS_L2_TABLE_DST_L3) ? 0x1 : 0x0;
     BCM_IF_ERROR_RETURN
       (bcm_field_qualify_L3Routable(unit, entry, value, 0x1));
   }
-
+  #endif
   return (BCM_E_NONE);
 }
 static L7_uchar8 udfL4SrcDestPortData[4];
 static L7_uchar8 udfL4SrcDestPortMask[4];
 
@@ -3247,58 +3314,166 @@ static int _policy_group_add_actions(int
     }
   }
   return rv;
 }
 
-/* PTin added: policer */
-#if 0
-static int _policy_group_add_policer(int unit, BROAD_POLICY_STAGE_t stage, bcm_field_entry_t eid, BROAD_POLICY_RULE_ENTRY_t *rulePtr, L7_int *policer_id)
+/* Only use these routines for SDK version >= 5.6.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+
+static int _policy_group_add_policer(int unit, BROAD_POLICY_STAGE_t stage, bcm_field_entry_t eid, bcm_field_group_t gid, BROAD_POLICY_RULE_ENTRY_t *rulePtr)
 {
-    int                  rv = BCM_E_NONE;
-    bcm_policer_config_t policer_profile;
-    BROAD_METER_ENTRY_t *policerPtr;
-    L7_int pol_id;
-
-    policerPtr = &rulePtr->u.meter.meterInfo;
-
-    policer_profile.flags         = 0;
-    policer_profile.mode          = (policerPtr->colorMode == BROAD_METER_COLOR_BLIND ?
-                                     bcmPolicerModeCommitted :
-                                     bcmPolicerModeTrTcm);
-    policer_profile.ckbits_sec    = policerPtr->cir;
-    policer_profile.ckbits_burst  = policerPtr->cbs*8;
-    policer_profile.pkbits_sec    = policerPtr->pir;
-    policer_profile.pkbits_burst  = policerPtr->pbs*8;
+    int                   rv = BCM_E_NONE;
+    BROAD_METER_ENTRY_t   *meterPtr;
+    bcm_policer_t         src_policer_id, policer_id;
+    bcm_policer_config_t  policer_cfg;
+
+    //printf("%s(%d) I was here!",__FUNCTION__,__LINE__);
+
+    meterPtr = &rulePtr->policer.policerInfo;
+
+    bcm_policer_config_t_init(&policer_cfg);
+    policer_cfg.flags = /*BCM_POLICER_REPLACE | BCM_POLICER_DROP_RED |*/ 0;
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    //policer_cfg.flags |= BCM_POLICER_MODE_BYTES;
+  #endif
+    policer_cfg.mode  = bcmPolicerModeTrTcm;  /* RFC 2698 */
+    policer_cfg.ckbits_sec    = meterPtr->cir;
+    policer_cfg.ckbits_burst  = meterPtr->cbs * 8;
+    policer_cfg.pkbits_sec    = meterPtr->pir;
+    policer_cfg.pkbits_burst  = meterPtr->pbs * 8;
+    policer_cfg.action_id     = bcmPolicerActionRpDrop;
+    policer_cfg.sharing_mode  = 0;
 
-    /* Create policer */
-    rv = bcm_policer_create(unit,&policer_profile,&pol_id);
-    if (BCM_E_NONE != rv)
+    if (meterPtr->colorMode == BROAD_METER_COLOR_BLIND)
+      policer_cfg.flags |= BCM_POLICER_COLOR_BLIND;
+
+    if (rulePtr->ruleFlags & BROAD_METER_SHARED)
+    {
+        bcm_field_entry_t src_eid;
+
+        src_eid = BROAD_ENTRY_TO_BCM_ENTRY(rulePtr->meterSrcEntry);
+
+        src_policer_id = rulePtr->src_policerId;
+
+        rv = bcm_field_entry_policer_attach(unit, eid, 0, src_policer_id);
+
+        if (BCM_E_NONE != rv)
+        {
+          printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+          return rv;
+        }
+
+        rulePtr->policer.policer_id = src_policer_id;
+    }
+    else
+    {
+        /* Create policer */
+        rv = bcm_policer_create(unit, &policer_cfg, &policer_id);
+        if (BCM_E_NONE != rv)
+        {
+          printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+          return rv;
+        }
+
+        /* Attach policer to field entry */
+        rv = bcm_field_entry_policer_attach(unit, eid, 0, policer_id);
+        if (BCM_E_NONE != rv)
+        {
+          printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+          return rv;
+        }
+
+        rulePtr->policer.policer_id = policer_id;
+        rulePtr->src_policerId = policer_id;
+    }
+
+    //printf("%s(%d) I was here! rv=%d",__FUNCTION__,__LINE__,rv);
+
+    return rv;
+}
+
+
+static int _policy_group_add_stat(int unit, bcm_field_entry_t eid, bcm_field_group_t gid, BROAD_POLICY_RULE_ENTRY_t *rulePtr)
+{
+    int                    rv = BCM_E_NONE;
+    uint64                 zero64;
+    BROAD_COUNTER_ENTRY_t *counterPtr;
+    bcm_field_stat_t       stat[2];
+    int                    src_stat_id, stat_id;
+
+    //printf("%s(%d) gid=%u, eid=%u",__FUNCTION__,__LINE__,gid,eid);
+
+    counterPtr = &rulePtr->counter.counterInfo;
+
+    if (rulePtr->ruleFlags & BROAD_COUNTER_SHARED)
+    {
+      src_stat_id = rulePtr->src_counterId;
+
+      rv = bcm_field_entry_stat_attach(unit, eid, src_stat_id);
+
+      if (BCM_E_NONE != rv)
+      {
+        printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
         return rv;
+      }
 
-    rv = bcm_field_entry_policer_attach(unit,eid,0,pol_id);
-    if (BCM_E_NONE != rv)
+      rulePtr->counter.counter_id = src_stat_id;
+    }
+    else
     {
-        bcm_policer_destroy(unit,pol_id);
+      /* add counter to support stats */
+      if (BROAD_COUNT_PACKETS == counterPtr->mode)
+      {
+        stat[0] = bcmFieldStatPackets;
+      }
+      else
+      {
+        stat[0] = bcmFieldStatBytes;
+      }
+
+      rv = bcm_field_stat_create(unit, gid, 1, stat, &stat_id);
+      if (BCM_E_NONE != rv)
+      {
+        printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+        return rv;
+      }
+
+      rv = bcm_field_entry_stat_attach(unit, eid, stat_id);
+      if (BCM_E_NONE != rv)
+      {
+        printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
         return rv;
+      }
+
+      rulePtr->counter.counter_id = stat_id;
+      rulePtr->src_counterId = stat_id;
     }
 
-    /* Save policer_id */
-    if (policer_id!=L7_NULLPTR)  *policer_id = pol_id;
+    /* zero values prior to first use */
+    COMPILER_64_ZERO(zero64);
+    rv = bcm_field_stat_all_set(unit, stat_id, zero64);
+    if (BCM_E_NONE != rv)
+    {
+      printf("%s(%d) We have an error! rv=%d",__FUNCTION__,__LINE__,rv);
+      return rv;
+    }
+
+    //printf("%s(%d) Success! rv=%d",__FUNCTION__,__LINE__,rv);
 
     return rv;
 }
-#endif
-/* PTin end */
+
+#else
 
 static int _policy_group_add_meter(int unit, BROAD_POLICY_STAGE_t stage, bcm_field_entry_t eid, BROAD_POLICY_RULE_ENTRY_t *rulePtr)
 {
     int                  rv = BCM_E_NONE;
     BROAD_METER_ENTRY_t *meterPtr;
     uint32               counter_flags;
     uint64               zero64;
 
-    meterPtr = &rulePtr->u.meter.meterInfo;
+    meterPtr = &rulePtr->policer.policerInfo;   /* PTin modified: SDK 6.3.0 */
 
     if (rulePtr->ruleFlags & BROAD_METER_SHARED)
     {
         bcm_field_entry_t src_eid;
 
@@ -3334,15 +3509,17 @@ static int _policy_group_add_meter(int u
     if (BCM_E_NONE != rv)
         return rv;
 
     /* add counter to support stats per entry */
     rv = bcm_field_counter_create(unit, eid);
+
     if (BCM_E_NONE != rv)
         return rv;
 
     /* zero values prior to first use */
     COMPILER_64_ZERO(zero64);
+
     (void)bcm_field_counter_set(unit, eid, 0, zero64);
     (void)bcm_field_counter_set(unit, eid, 1, zero64);
 
     counter_flags = BCM_FIELD_COUNTER_MODE_PACKETS;
     if (stage != BROAD_POLICY_STAGE_EGRESS)
@@ -3351,12 +3528,14 @@ static int _policy_group_add_meter(int u
     }
     else
     {
       counter_flags |= BCM_FIELD_COUNTER_MODE_YES_NO;
     }
+
     rv = bcm_field_action_add(unit, eid, bcmFieldActionUpdateCounter,
                   counter_flags, 0);
+
     if (BCM_E_NONE != rv)
         return rv;
 
     return rv;
 }
@@ -3366,11 +3545,11 @@ static int _policy_group_add_counter(int
     int                    rv = BCM_E_NONE;
     uint32                 flags;
     uint64                 zero64;
     BROAD_COUNTER_ENTRY_t *counterPtr;
 
-    counterPtr = &rulePtr->u.counter.counterInfo;
+    counterPtr = &rulePtr->counter.counterInfo;   /* PTin modified: SDK 6.3.0 */
 
     if (rulePtr->ruleFlags & BROAD_COUNTER_SHARED)
     {
         bcm_field_entry_t src_eid;
 
@@ -3399,15 +3578,15 @@ static int _policy_group_add_counter(int
         flags |= BCM_FIELD_COUNTER_MODE_PACKETS;
     else
         flags |= BCM_FIELD_COUNTER_MODE_BYTES;
 
     rv = bcm_field_action_add(unit, eid, bcmFieldActionUpdateCounter, flags, 0);
-    if (BCM_E_NONE != rv)
-        return rv;
 
     return rv;
 }
+#endif
+
 
 extern int hapiBroadBcmGroupRequired(int unit);
 /* 
  * Returns the reserved group id if neccessary
  * returns -1, if there is no reserved group
@@ -3452,18 +3631,19 @@ int hapiBroadPolicyFirstAclDsGroupGet(in
 {
   int groupid_rev;
 
   /* Although Scorpion, TR2, and Apollo support intraslice doublewide mode,
      their system qsets end up using doublewide mode. */
-  // PTin added: new switch => SOC_IS_VALKYRIE2
+  /* PTin updated: platform */
   if (_policy_supports_intraslice_doublewide_mode(unit) && 
       !SOC_IS_SCORPION(unit) && 
       !SOC_IS_TRIUMPH2(unit) && 
       !SOC_IS_APOLLO(unit) &&
       !SOC_IS_ENDURO(unit) &&
       !SOC_IS_VALKYRIE2(unit) &&
-      !SOC_IS_TRIDENT(unit))        /* PTin added: new switch BCM56843 */
+      !SOC_IS_TRIDENT(unit) &&      /* PTin added: new switch BCM56843 */
+      !SOC_IS_TRIUMPH3(unit) )      /* PTin added: new switch BCM56643 */
   {
     /* System rules in slice 0. */
     groupid_rev = 1;
   }
   else if (_policy_supports_wide_mode(unit) && !SOC_IS_SCORPION(unit))
@@ -3653,28 +3833,28 @@ static int _policy_group_alloc_init(int 
           group_alloc_table[unit][policyStage][ALLOC_BLOCK_STATS_EVC].lowPrio     = lowPrioGroup + 4; //groups/2 - 2;
           group_alloc_table[unit][policyStage][ALLOC_BLOCK_STATS_EVC].highPrio    = lowPrioGroup + 6 - 1; //groups/2 - 1;
         }
         /* PTin end */
 
-        LOG_INFO(LOG_CTX_STARTUP,"ALLOC_BLOCK_LOW   : Groups %u - %u",
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_LOW].lowPrio,
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_LOW].highPrio);
-        LOG_INFO(LOG_CTX_STARTUP,"ALLOC_BLOCK_MEDIUM: Groups %u - %u",
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_MEDIUM].lowPrio,
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_MEDIUM].highPrio);
-        LOG_INFO(LOG_CTX_STARTUP,"ALLOC_BLOCK_HIGH  : Groups %u - %u",
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_HIGH].lowPrio,
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_HIGH].highPrio);
-        LOG_INFO(LOG_CTX_STARTUP,"ALLOC_BLOCK_STATS_CLIENT: Groups %u - %u",
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_STATS_CLIENT].lowPrio,
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_STATS_CLIENT].highPrio);
-        LOG_INFO(LOG_CTX_STARTUP,"ALLOC_BLOCK_STATS_EVC   : Groups %u - %u",
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_STATS_EVC].lowPrio,
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_STATS_EVC].highPrio);
-        LOG_INFO(LOG_CTX_STARTUP,"ALLOC_BLOCK_PTIN  : Groups %u - %u",
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_PTIN].lowPrio,
-                 group_alloc_table[unit][policyStage][ALLOC_BLOCK_PTIN].highPrio);
+        printf("ALLOC_BLOCK_LOW   : Groups %u - %u\r\n",
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_LOW].lowPrio,
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_LOW].highPrio);
+        printf("ALLOC_BLOCK_MEDIUM: Groups %u - %u\r\n",
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_MEDIUM].lowPrio,
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_MEDIUM].highPrio);
+        printf("ALLOC_BLOCK_HIGH  : Groups %u - %u\r\n",
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_HIGH].lowPrio,
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_HIGH].highPrio);
+        printf("ALLOC_BLOCK_STATS_CLIENT: Groups %u - %u\r\n",
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_STATS_CLIENT].lowPrio,
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_STATS_CLIENT].highPrio);
+        printf("ALLOC_BLOCK_STATS_EVC   : Groups %u - %u\r\n",
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_STATS_EVC].lowPrio,
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_STATS_EVC].highPrio);
+        printf("ALLOC_BLOCK_PTIN  : Groups %u - %u\r\n",
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_PTIN].lowPrio,
+               group_alloc_table[unit][policyStage][ALLOC_BLOCK_PTIN].highPrio);
       }
       break;
     default:
       break;
     }
@@ -3720,34 +3900,36 @@ int _policy_group_total_slices(int unit,
     int          total_slices = 0;
 
     switch (policyStage)
     {
     case BROAD_POLICY_STAGE_LOOKUP:
-      // PTin added: new switch => SOC_IS_VALKYRIE2
+      /* PTin updated: platform */
       if (SOC_IS_FIREBOLT2(unit) ||
           SOC_IS_TR_VL(unit) ||
           SOC_IS_SCORPION(unit) || 
           SOC_IS_TRIUMPH2(unit) || 
           SOC_IS_APOLLO(unit)   ||
           SOC_IS_ENDURO(unit)   ||
           SOC_IS_VALKYRIE2(unit) ||
-          SOC_IS_TRIDENT(unit))     /* PTin added: new switch BCM56843 */
+          SOC_IS_TRIDENT(unit)  ||      /* PTin added: new switch BCM56843 */
+          SOC_IS_TRIUMPH3(unit) )       /* PTin added: new switch BCM56643 */
         total_slices = 4;
       else  
         total_slices = 0;
       break;
     case BROAD_POLICY_STAGE_INGRESS:
       if (SOC_IS_ENDURO(unit))
       {
         total_slices = 8;
       }
-      // PTin added: new switch => SOC_IS_VALKYRIE2
+      /* PTin updated: platform */
       else if ((SOC_IS_FIREBOLT(unit)  || 
           SOC_IS_FIREBOLT2(unit) ||
           SOC_IS_TR_VL(unit) ||
-          SOC_IS_RAVEN(unit) || SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit))
-           && !SOC_IS_TRIDENT(unit)) /* PTin added: new switch BCM56843 */
+          SOC_IS_RAVEN(unit) || SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit) ||
+          SOC_IS_TRIUMPH3(unit))        /* PTin added: new switch BCM56643 */
+           && !SOC_IS_TRIDENT(unit))    /* PTin added: new switch BCM56843 */
           total_slices = 16;
       else if (SOC_IS_RAPTOR(unit) || SOC_IS_HAWKEYE(unit)) 
       { 
         /* Note tcam_slices only counts internal slices. */
         if (soc_feature(unit, soc_feature_field_slices2)) {
@@ -3772,19 +3954,20 @@ int _policy_group_total_slices(int unit,
       {
         total_slices = 8;
       }
       break;
     case BROAD_POLICY_STAGE_EGRESS:
-      // PTin added: new switch => SOC_IS_VALKYRIE2
+      /* PTin updated: platform */
       if (SOC_IS_FIREBOLT2(unit) ||
           SOC_IS_TR_VL(unit)     ||
           SOC_IS_SCORPION(unit)  || 
           SOC_IS_TRIUMPH2(unit)  || 
           SOC_IS_APOLLO(unit)    ||
           SOC_IS_ENDURO(unit)    ||
           SOC_IS_VALKYRIE2(unit) ||
-          SOC_IS_TRIDENT(unit))     /* PTin added: new switch BCM56843 */
+          SOC_IS_TRIDENT(unit)   || /* PTin added: new switch BCM56843 */
+          SOC_IS_TRIUMPH3(unit) )   /* PTin added: new switch BCM56643 */
         total_slices = 4;
       else  
         total_slices = 0;
       break;
     default:
@@ -3799,38 +3982,40 @@ L7_BOOL policy_stage_supported(int unit,
 
   /* Only FB2 supports the LOOKUP, INGRESS, and EGRESS stages */
   switch (policyStage)
   {
   case BROAD_POLICY_STAGE_LOOKUP:
-    // PTin added: new switch => SOC_IS_VALKYRIE2
+    /* PTin updated: platform */
     if (SOC_IS_FIREBOLT2(unit) ||
         SOC_IS_TR_VL(unit)     ||
         SOC_IS_SCORPION(unit)  || 
         SOC_IS_TRIUMPH2(unit)  ||
         SOC_IS_APOLLO(unit)    ||
         SOC_IS_ENDURO(unit)    ||
         SOC_IS_VALKYRIE2(unit) ||
-        SOC_IS_TRIDENT(unit))       /* PTin added: new switch BCM56843 */
+        SOC_IS_TRIDENT(unit)   ||   /* PTin added: new switch BCM56843 */
+        SOC_IS_TRIUMPH3(unit) )     /* PTin added: new switch BCM56643 */
     {
       supported = L7_TRUE;
     }
     break;
 
   case BROAD_POLICY_STAGE_INGRESS:
     supported = L7_TRUE;
     break;
 
   case BROAD_POLICY_STAGE_EGRESS:
-    // PTin added: new switch => SOC_IS_VALKYRIE2
+    /* PTin updated: platform */
     if (SOC_IS_FIREBOLT2(unit) ||
         SOC_IS_TR_VL(unit)     ||
         SOC_IS_SCORPION(unit)  || 
         SOC_IS_TRIUMPH2(unit)  || 
         SOC_IS_APOLLO(unit)    ||
         SOC_IS_ENDURO(unit)    ||
         SOC_IS_VALKYRIE2(unit) ||
-        SOC_IS_TRIDENT(unit))       /* PTin added: new switch BCM56843 */
+        SOC_IS_TRIDENT(unit)   ||   /* PTin added: new switch BCM56843 */
+        SOC_IS_TRIUMPH3(unit) )     /* PTin added: new switch BCM56643 */
     {
       supported = L7_TRUE;
     }
     break;
 
@@ -4024,25 +4209,28 @@ int policy_group_add_rule(int           
                           BROAD_GROUP_t              group,
                           BROAD_POLICY_RULE_ENTRY_t *rulePtr,
                           bcm_pbmp_t                 pbm,
                           int                        skip_actions,
                           BROAD_ENTRY_t             *entry,
-                          L7_int                    *policer_id)      /* PTin modified: policer */
+                          int                       *policer_id,      /* PTin added: SDK 6.3.0 */
+                          int                       *counter_id)
 {
     BROAD_POLICY_FIELD_t f;
     group_table_t       *groupPtr;
-    bcm_field_entry_t    eid;
+    bcm_field_entry_t    gid, eid;
     int                  rv = BCM_E_NONE;
     BROAD_ACTION_ENTRY_t *actionPtr;
 
     CHECK_GROUP(unit, policyStage, group);
 
     groupPtr = &group_table[unit][policyStage][group];
 
     if (!(groupPtr->flags & GROUP_USED))
         return BCM_E_NOT_FOUND;
 
+    gid = groupPtr->gid;
+
     rv = bcm_field_entry_create(unit, groupPtr->gid, &eid);
 
     /* PTin added: FFP */
     #if 1
     if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_MED)
@@ -4102,44 +4290,61 @@ int policy_group_add_rule(int           
       if (rulePtr->ruleFlags & BROAD_METER_SPECIFIED)
       {
           if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_MED)
               sysapiPrintf("- adding a meter\n");
   
-          /* Ptin modified: policer */
-          rv = _policy_group_add_meter(unit, policyStage, eid, rulePtr);                    /* Original */
-          //rv = _policy_group_add_policer(unit, policyStage, eid, rulePtr, policer_id);    /* New */
+          /* PTin modified: SDK 6.3.0 */
+          #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+          rv = _policy_group_add_policer(unit, policyStage, eid, gid, rulePtr);
+          #else
+          rv = _policy_group_add_meter(unit, policyStage, eid, rulePtr);
+          #endif
           if (BCM_E_NONE != rv)
               return rv;
       }
       else if (rulePtr->ruleFlags & BROAD_COUNTER_SPECIFIED)
       {
-          if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_MED)
-              sysapiPrintf("- adding a counter\n");
-  
-          rv = _policy_group_add_counter(unit, eid, rulePtr);
-          if (BCM_E_NONE != rv)
-              return rv;
+        if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_MED)
+            sysapiPrintf("- adding a counter\n");
+
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+        rv = _policy_group_add_stat(unit, eid, gid, rulePtr);
+        #else
+        rv = _policy_group_add_counter(unit, eid, rulePtr);
+        #endif
+        if (BCM_E_NONE != rv)
+          return rv;
       }
+
+      /* Ptin added: SDK 6.3.0 */
+      #if 1
+      if (policer_id!=L7_NULLPTR)   *policer_id = rulePtr->policer.policer_id;
+      if (counter_id!=L7_NULLPTR)   *counter_id = rulePtr->counter.counter_id;
+      #endif
     }
 
     /* Only install to HW if we expect any ports to match this rule. This is mostly because
        for LOOKUP and EGRESS policies, the portClass doesn't really provide a mechanism to
        never match rule (as a NULL pbmp would do for ingress) */
     if ((policyStage == BROAD_POLICY_STAGE_INGRESS) || (policyType == BROAD_POLICY_TYPE_VLAN) || (BCM_PBMP_NOT_NULL(pbm)))
     {
       rv = bcm_field_entry_install(unit, eid);
 
+      /* PTin added: SDK 6.3.0 */
+      #if 1
+      if ( rv != BCM_E_NONE)
+      { 
+        /* Destroy rule */
+        (void) policy_group_delete_rule(unit, policyStage, gid, eid, rulePtr->policer.policer_id, rulePtr->counter.counter_id);
+      }
+      #endif
+
       /* PTin added: FFP */
       #if 1
       if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_MED)
           sysapiPrintf("- bcm_field_entry_install rv = %d (entry=%d)\n", rv, eid);
-      #else
-      if ( rv != BCM_E_NONE)
-      {  
-        if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_MED)
-            sysapiPrintf("- bcm_field_entry_install rv = %d (entry=%d)\n", rv, eid);
-      }
       #endif
     }
 
     return rv;
 }
@@ -4262,11 +4467,16 @@ int policy_group_set_portclass(int      
                 return rv;
           }
           break;
         }
 
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        rv = bcm_field_qualify_InterfaceClassPort(unit, eid, 0, 0);
+        #else
         rv = bcm_field_qualify_PortClass(unit, eid, 0, 0);
+        #endif
         if (BCM_E_NONE != rv)
             return rv;
       }
       else
       {
@@ -4281,11 +4491,17 @@ int policy_group_set_portclass(int      
           rv = bcm_field_qualify_OutPort(unit, eid, 0, 0);
           if (BCM_E_NONE != rv)
               return rv;
         }
         portClassBmp = 1 << portClass;
+
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        rv = bcm_field_qualify_InterfaceClassPort(unit, eid, portClassBmp, portClassBmp);
+        #else
         rv = bcm_field_qualify_PortClass(unit, eid, portClassBmp, portClassBmp);
+        #endif
         if (BCM_E_NONE != rv)
             return rv;
       }
 
       rv = bcm_field_entry_install(unit, eid);
@@ -4485,11 +4701,12 @@ int policy_group_rule_priority_set(int  
 
 int policy_group_delete_rule(int                  unit,
                              BROAD_POLICY_STAGE_t policyStage,
                              BROAD_GROUP_t        group,
                              BROAD_ENTRY_t        entry,
-                             L7_int               policer_id)       /* PTin modified: policer */
+                             int                  policer_id,   /* PTin added: SDK 6.3.0 */
+                             int                  counter_id)
 {
     int               rv;
     group_table_t    *groupPtr;
     bcm_field_entry_t eid;
 
@@ -4514,21 +4731,31 @@ int policy_group_delete_rule(int        
      * a rule that is not installed in the hardware. So, continue with the
      * destroy. */ 
     if((BCM_E_UNAVAIL != rv) && (BCM_E_NONE != rv))
         return rv;
 
-    /* PTin added: policer */
+    /* PTin added: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
     if (policer_id>0)
     {
-      rv = bcm_field_entry_policer_detach(unit,eid,0);
+      rv = bcm_field_entry_policer_detach(unit, eid, 0);
       if (BCM_E_NONE != rv)
           return rv;
-      rv = bcm_policer_destroy(unit,policer_id);
+      rv = bcm_policer_destroy(unit, policer_id);
       if (BCM_E_NONE != rv)
           return rv;
     }
-    /* PTin end */
+    if (counter_id>0)
+    {
+      rv = bcm_field_entry_stat_detach(unit, eid, counter_id);
+      if (BCM_E_NONE != rv)
+          return rv;
+      rv = bcm_field_stat_destroy(unit, counter_id);
+      if (BCM_E_NONE != rv)
+          return rv;
+    }
+    #endif
 
     rv = bcm_field_entry_destroy(unit, eid);
 
     /* PTin added: FFP */
     if (hapiBroadPolicyDebugLevel() > POLICY_DEBUG_MED)
@@ -4584,20 +4811,60 @@ int policy_group_get_stats(int          
     group_table_t     *groupPtr;
     bcm_field_entry_t  eid;
 
     CHECK_GROUP(unit,policyStage,group);
 
-    COMPILER_64_ZERO(*val1);
-    COMPILER_64_ZERO(*val2);
+    /* PTin modified: SDK 6.3.0 */
+    #if 1
+    if (val1!=NULL) COMPILER_64_ZERO(*val1);
+    if (val2!=NULL) COMPILER_64_ZERO(*val2);
+    #endif
 
     groupPtr = &group_table[unit][policyStage][group];
 
     if (!(groupPtr->flags & GROUP_USED))
         return BCM_E_NOT_FOUND;
 
     eid = BROAD_ENTRY_TO_BCM_ENTRY(entry);
 
+    /* PTin added: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+
+    int stat_size, stat_id;
+    bcm_field_stat_t stat_type[2];
+    uint64 values[2];
+
+    /* Get stat id for this entry */
+    rv = bcm_field_entry_stat_get(unit, entry, &stat_id);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        return rv;
+
+    /* Get number of counters */
+    rv = bcm_field_stat_size(unit, stat_id, &stat_size);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        return rv;
+    /* Limit number of counters to 2 */
+    if (stat_size>2)  stat_size = 2;
+
+    if (stat_size==0)
+      return BCM_E_EMPTY;
+
+    /* Get collection of counters */
+    rv = bcm_field_stat_config_get(unit, stat_id, stat_size, stat_type);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        return rv;
+
+    /* Get counters values */
+    rv = bcm_field_stat_multi_get(unit, stat_id, stat_size, stat_type, values);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        return rv;
+
+    if (stat_size>=1 && val1!=NULL)  *val1 = values[0];
+    if (stat_size>=2 && val2!=NULL)  *val2 = values[1];
+
+    #else
+
     if (policyStage == BROAD_POLICY_STAGE_EGRESS)
     {
       rv = bcm_field_counter_get(unit, eid, 0, val2);
       if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
           return rv;
@@ -4610,10 +4877,11 @@ int policy_group_get_stats(int          
 
       rv = bcm_field_counter_get(unit, eid, 1, val2);  /* empty means no counter */
       if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
           return rv;
     }
+    #endif
 
     return BCM_E_NONE;
 }
 
 int policy_group_stats_clear(int                  unit,
@@ -4626,20 +4894,37 @@ int policy_group_stats_clear(int        
 
     COMPILER_64_ZERO(val1);
 
     eid = BROAD_ENTRY_TO_BCM_ENTRY(entry);
 
+    /* PTin modified: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+    int                stat_id;
+
+    /* Get stat id for this entry */
+    rv = bcm_field_entry_stat_get(unit, entry, &stat_id);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        return rv;
+
+    /* Reset counters */
+    rv = bcm_field_stat_all_set(unit, stat_id, val1);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
+        return rv;
+
+    #else
+
     rv = bcm_field_counter_set(unit, eid, 0, val1);
     if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
         return rv;
 
     if (policyStage != BROAD_POLICY_STAGE_EGRESS)
     {
       rv = bcm_field_counter_set(unit, eid, 1, val1);  /* empty means no counter */
       if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
           return rv;
     }
+    #endif
 
     return BCM_E_NONE;
 }
 
 void policy_group_dataplane_cleanup(int                  unit,
@@ -4808,14 +5093,24 @@ int policy_group_create_default_rule(int
         sysapiPrintf("Incremented count_rules to %u (unit=%d, policyStage=%d, group=%d)\n",groupPtr->count_rules,unit,BROAD_POLICY_STAGE_INGRESS,group);
     #endif
 
     *entry = BCM_ENTRY_TO_BROAD_ENTRY(eid);
 
+    /* PTin modified: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    rv = bcm_field_qualify_EtherType(unit, eid, 0x0800, 0xFFFF);
+    if (BCM_E_NONE != rv)
+      return rv;
+    rv = bcm_field_qualify_IpType(unit, eid, bcmFieldIpTypeIpv4Any);
+    if (BCM_E_NONE != rv)
+      return rv;
+    #else
     rv = bcm_field_qualify_PacketFormat(unit, eid, BCM_FIELD_PKT_FMT_IPV4,
                                         BCM_FIELD_PKT_FMT_IPV4);
     if (BCM_E_NONE != rv)
       return rv;
+    #endif
 
     rv = bcm_field_action_add(unit, eid, bcmFieldActionEgressMask, 
                               SOC_PBMP_WORD_GET(epbm, 0), 0
                               );
     if (BCM_E_NONE != rv)
@@ -5131,23 +5426,82 @@ void debug_sqset_table(int unit, int ent
 }
 
 void debug_entry_counter(int unit, bcm_field_entry_t eid)
 {
     int    rv;
+
+    /* PTin modified: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+    int    i;
+    int    stat_id;
+    int    stat_size;
+    bcm_field_stat_t stat_type[4];
+    uint64 values[4];
+
+    /* Get stat id for this entry */
+    rv = bcm_field_entry_stat_get(unit, eid, &stat_id);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+    {
+      sysapiPrintf("Error with bcm_field_entry_stat_get\n");
+      return;
+    }
+
+    /* Get number of counters */
+    rv = bcm_field_stat_size(unit, stat_id, &stat_size);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+    {
+      sysapiPrintf("Error with bcm_field_stat_size\n");
+      return;
+    }
+    /* Limit number of counters to 2 */
+    if (stat_size>4)  stat_size = 4;
+
+    if (stat_size==0)
+    {
+      sysapiPrintf("No counters\n");
+      return;
+    }
+
+    /* Get collection of counters */
+    rv = bcm_field_stat_config_get(unit, stat_id, stat_size, stat_type);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+    {
+      sysapiPrintf("Error with bcm_field_stat_config_get\n");
+      return;
+    }
+
+    /* Get counters values */
+    rv = bcm_field_stat_multi_get(unit, stat_id, stat_size, stat_type, values);
+    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+    {
+      sysapiPrintf("Error with bcm_field_stat_multi_get\n");
+      return;
+    }
+
+    /* Print counters */
+    for (i=0; i<stat_size; i++)
+    {
+      sysapiPrintf("Counter %d: %08x %08x\n", i, u64_H(values[i]), u64_L(values[i]));
+    }
+
+    #else
     uint64 val64;
 
     rv = bcm_field_counter_get(unit, eid, 0, &val64);
+
     if (BCM_E_NONE == rv)
         sysapiPrintf("Counter 0: %08x %08x\n", u64_H(val64), u64_L(val64));
     else
         sysapiPrintf("error code = %d\n", rv);
 
     rv = bcm_field_counter_get(unit, eid, 1, &val64);
+
     if (BCM_E_NONE == rv)
         sysapiPrintf("Counter 1: %08x %08x\n", u64_H(val64), u64_L(val64));
     else
         sysapiPrintf("error code = %d\n", rv);
+    #endif
 }
 
 /* PTin added: FFP */
 #if 1
 group_table_t *policy_group_count_rules(int unit, int group_idx, int stage)
diff -rpN --unified=5 esw_original/policy/broad_group_xgs3.h esw/policy/broad_group_xgs3.h
--- esw_original/policy/broad_group_xgs3.h	2013-03-08 12:34:34.680447344 +0000
+++ esw/policy/broad_group_xgs3.h	2013-07-22 20:39:45.081308528 +0100
@@ -111,17 +111,19 @@ int policy_group_add_rule(int           
                           BROAD_GROUP_t              group,
                           BROAD_POLICY_RULE_ENTRY_t *ruleInfo,
                           bcm_pbmp_t                 pbm,
                           int                        skip_actions,
                           BROAD_ENTRY_t             *entry,
-                          L7_int                    *policer_id);     /* PTin modified: policer */
+                          int                       *policer_id,      /* PTin modified: SDK 6.3.0 */
+                          int                       *counter_id);
 
 int policy_group_delete_rule(int                  unit,
                              BROAD_POLICY_STAGE_t policyStage,
                              BROAD_GROUP_t        group,
                              BROAD_ENTRY_t        entry,
-                             L7_int               policer_id);        /* PTin modified: policer */
+                             int                  policer_id,         /* PTin added: SDK 6.3.0 */
+                             int                  counter_id);
 
 int policy_group_rule_priority_set(int                          unit,
                                    BROAD_POLICY_STAGE_t         policyStage,
                                    BROAD_GROUP_t                group,
                                    BROAD_ENTRY_t                entry,
diff -rpN --unified=5 esw_original/policy/broad_policy.c esw/policy/broad_policy.c
--- esw_original/policy/broad_policy.c	2013-03-08 12:34:34.680447344 +0000
+++ esw/policy/broad_policy.c	2013-07-22 20:39:45.081308528 +0100
@@ -1180,11 +1180,11 @@ L7_RC_t hapiBroadPolicyRuleMeterAdd(BROA
         /* meters and counters are mutually exclusive */
         return L7_ERROR;
     }
 
     rulePtr->ruleFlags |= BROAD_METER_SPECIFIED;
-    memcpy(&rulePtr->u.meter.meterInfo, meterInfo, sizeof(*meterInfo));
+    memcpy(&rulePtr->policer.policerInfo, meterInfo, sizeof(*meterInfo));   /* PTin modified: SDK 6.3.0 */
 
     return L7_SUCCESS;
 }
 
 /*********************************************************************
@@ -1216,12 +1216,12 @@ L7_RC_t hapiBroadPolicyRuleCounterAdd(BR
     {
         /* meters and counters are mutually exclusive */
         return L7_ERROR;
     }
 
-    rulePtr->ruleFlags                  |= BROAD_COUNTER_SPECIFIED;
-    rulePtr->u.counter.counterInfo.mode = mode;
+    rulePtr->ruleFlags               |= BROAD_COUNTER_SPECIFIED;
+    rulePtr->counter.counterInfo.mode = mode;       /* PTin modified: SDK 6.3.0 */
 
     return L7_SUCCESS;
 }
 /*********************************************************************
 *
@@ -1309,11 +1309,11 @@ L7_RC_t hapiBroadPolicyStatsGet(BROAD_PO
         }
         else
         {
             /* counted mode */
             stat->meter = L7_FALSE;
-            stat->statMode.counter.count = 0;
+            stat->statMode.counter.count = 0;     /* PTin modified: SDK 6.3.0 */
         }
 
         /* Free any rules allocated by usl_bcmx_policy_info_get(). */
         hapiBroadPolicyRulesPurge(policyInfo);
         osapiSemaGive(policyTableSema);
@@ -2417,21 +2417,23 @@ void hapiBroadPolicyDebugRule(BROAD_POLI
         }
     }
 
     if (rulePtr->ruleFlags & BROAD_METER_SPECIFIED)
     {
+        /* PTin modified: SDK 6.3.0 */
         sysapiPrintf("     Metered  (%c%c)    : CIR %d CBS %d PIR %d PBS %d\n",
-                     rulePtr->u.meter.meterInfo.colorMode == BROAD_METER_COLOR_BLIND ? 'C' : '-',
+                     rulePtr->policer.policerInfo.colorMode == BROAD_METER_COLOR_BLIND ? 'C' : '-',
                      rulePtr->ruleFlags & BROAD_METER_SHARED ? 'S' : '-',
-                     rulePtr->u.meter.meterInfo.cir, rulePtr->u.meter.meterInfo.cbs,
-                     rulePtr->u.meter.meterInfo.pir, rulePtr->u.meter.meterInfo.pbs);
+                     rulePtr->policer.policerInfo.cir, rulePtr->policer.policerInfo.cbs,
+                     rulePtr->policer.policerInfo.pir, rulePtr->policer.policerInfo.pbs);
     }
 
     if (rulePtr->ruleFlags & BROAD_COUNTER_SPECIFIED)
     {
+        /* PTin modified: SDK 6.3.0 */
         sysapiPrintf("     Counted  (%c%c)\n",
-                     rulePtr->u.counter.counterInfo.mode == BROAD_COUNT_PACKETS ? 'P' : 'B',
+                     rulePtr->counter.counterInfo.mode == BROAD_COUNT_PACKETS ? 'P' : 'B',
                      rulePtr->ruleFlags & BROAD_COUNTER_SHARED ? 'S' : '-');
     }
 }
 
 void hapiBroadPolicyDebug(BROAD_POLICY_t policy)
diff -rpN --unified=5 esw_original/ptin/ptin_hapi.c esw/ptin/ptin_hapi.c
--- esw_original/ptin/ptin_hapi.c	2013-07-22 16:26:03.043546295 +0100
+++ esw/ptin/ptin_hapi.c	2013-07-22 20:24:37.840305828 +0100
@@ -21,11 +21,10 @@
 #include "ptin_hapi_xconnect.h"
 #include "ptin_hapi_fp_bwpolicer.h"
 #include "ptin_hapi_fp_counters.h"
 #include "broad_policy.h"
 #include "simapi.h"
-#include "broad_group_bcm.h"
 
 #include <bcmx/switch.h>
 #include <bcmx/port.h>
 #include <bcmx/l2.h>
 
@@ -771,13 +770,19 @@ L7_RC_t hapi_ptin_counters_read(ptin_HWE
   {
     if (SOC_IS_VALKYRIE2(unit))
     {
       // Rx counters
       soc_counter_get(unit, port, GRMTUEr, 0, &mtuePkts);                             /* Packets > MTU bytes (good and bad) */
+      /* PTin modified: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      soc_counter_get(unit, port, DROP_PKT_CNT_INGr, 0, &tmp1);
+      rx->etherStatsDropEvents = tmp1 + mtuePkts;                                     /* Drop Events */
+      #else
       soc_counter_get(unit, port, GRDROPr          , 0, &tmp1);
       soc_counter_get(unit, port, DROP_PKT_CNT_INGr, 0, &tmp2);
-      rx->etherStatsDropEvents = tmp1 + tmp2 + mtuePkts;                       /* Drop Events */
+      rx->etherStatsDropEvents = tmp1 + tmp2 + mtuePkts;                              /* Drop Events */
+      #endif
       soc_counter_get(unit, port, GRBYTr , 0, &tmp1);
       soc_counter_get(unit, port, RRBYTr , 0, &tmp2);
       rx->etherStatsOctets = tmp1 + tmp2;                                             /* Octets */
       soc_counter_get(unit, port, GRPKTr , 0, &rx->etherStatsPkts);                   /* Packets (>=64 bytes) */
       soc_counter_get(unit, port, GRBCAr , 0, &rx->etherStatsBroadcastPkts);          /* Broadcasts */
@@ -852,13 +857,19 @@ L7_RC_t hapi_ptin_counters_read(ptin_HWE
     {
       // Rx counters
       soc_counter_get(unit, port, IRMEGr , 0, &tmp1);
       soc_counter_get(unit, port, IRMEBr , 0, &tmp2);
       mtuePkts = tmp1 + tmp2;                                                         /* Packets > MTU bytes (good and bad) */
+      /* PTin modified: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      soc_counter_get(unit, port, DROP_PKT_CNT_INGr, 0, &tmp1);
+      tmp = tmp1;
+      #else
       soc_counter_get(unit, port, IRDROPr          , 0, &tmp1);
       soc_counter_get(unit, port, DROP_PKT_CNT_INGr, 0, &tmp2);
       tmp = tmp1 + tmp2 + tmp3;
+      #endif
       ( tmp >= mtuePkts ) ? ( tmp -= mtuePkts ) : ( tmp = 0 );
       rx->etherStatsDropEvents = tmp + mtuePkts;                                      /* Drop Events */
       soc_counter_get(unit, port, IRBYTr , 0, &rx->etherStatsOctets);                 /* Octets */                   
       soc_counter_get(unit, port, IRPKTr , 0, &rx->etherStatsPkts);                   /* Packets (>=64 bytes) */
       soc_counter_get(unit, port, IRBCAr , 0, &rx->etherStatsBroadcastPkts);          /* Broadcasts */               
diff -rpN --unified=5 esw_original/ptin/ptin_hapi_fp_bwpolicer.c esw/ptin/ptin_hapi_fp_bwpolicer.c
--- esw_original/ptin/ptin_hapi_fp_bwpolicer.c	2013-03-08 12:34:35.740464972 +0000
+++ esw/ptin/ptin_hapi_fp_bwpolicer.c	2013-07-22 20:39:45.083559865 +0100
@@ -574,11 +574,11 @@ void ptin_bwpolicer_dump_debug(void)
 {
   L7_int index;
   ptin_bw_policy_t *ptr;
   BROAD_GROUP_t group_id;
   BROAD_ENTRY_t entry_id;
-  L7_int policer_id;
+  L7_int policer_id, counter_id;  /* PTin added: SDK 6.3.0 */
 
   printf("Listing bandwidth policer list...\r\n");
 
   for (index=0; index<PTIN_SYSTEM_MAX_BW_POLICERS; index++)
   {
@@ -595,12 +595,13 @@ void ptin_bwpolicer_dump_debug(void)
     printf("  IVID_in  = %u\r\n",ptr->inner_vlan_in);
     printf("  IVID_out = %u\r\n",ptr->inner_vlan_out);
     printf("  meter: cir=%u eir=%u cbs=%u ebs=%u\r\n",ptr->meter.cir,ptr->meter.eir,ptr->meter.cbs,ptr->meter.ebs);
     printf("  policy_id = %u\r\n",ptr->policy_id);
     /* Also print hw group id and entry id*/
-    if (l7_bcm_policy_hwInfo_get(0,ptr->policy_id,0,&group_id,&entry_id,&policer_id)==L7_SUCCESS)
+    /* PTin modified: SDK 6.3.0 */
+    if (l7_bcm_policy_hwInfo_get(0,ptr->policy_id,0,&group_id,&entry_id,&policer_id,&counter_id)==L7_SUCCESS)
     {
-      printf("  group=%d, entry=%d, policer_id=%d\r\n",group_id,entry_id,policer_id);
+      printf("  group=%d, entry=%d, policer_id, counter_id=%d=%d\r\n",group_id,entry_id,policer_id,counter_id);
     }
   }
 }
 
diff -rpN --unified=5 esw_original/ptin/ptin_hapi_fp_counters.c esw/ptin/ptin_hapi_fp_counters.c
--- esw_original/ptin/ptin_hapi_fp_counters.c	2013-03-08 12:34:35.736941658 +0000
+++ esw/ptin/ptin_hapi_fp_counters.c	2013-07-22 20:39:45.083559865 +0100
@@ -844,11 +844,11 @@ void ptin_fpcounters_dump_debug(void)
       printf("  Stage=%s\r\n",((stage==BROAD_POLICY_STAGE_INGRESS) ? "INGRESS" : "EGRESS"));
       printf("    policy_id = %d\r\n",ptr->policy_id[stage]);
       for (rule=0; rule<PTIN_PACKETS_TYPE_MAX; rule++)
       {
         /* Also print hw group id and entry id*/
-        if (l7_bcm_policy_hwInfo_get(0,ptr->policy_id[stage],ptr->rule_id[stage][rule],&group_id,&entry_id,L7_NULLPTR)==L7_SUCCESS)
+        if (l7_bcm_policy_hwInfo_get(0,ptr->policy_id[stage],ptr->rule_id[stage][rule],&group_id,&entry_id,L7_NULLPTR,L7_NULLPTR)==L7_SUCCESS)
         {
           printf("    Rule %d: group=%d, entry=%d\r\n",ptr->rule_id[stage][rule],group_id,entry_id);
         }
       }
     }
diff -rpN --unified=5 esw_original/qos/broad_cos.c esw/qos/broad_cos.c
--- esw_original/qos/broad_cos.c	2013-03-08 12:34:35.548940390 +0000
+++ esw/qos/broad_cos.c	2013-07-22 20:05:50.717056978 +0100
@@ -235,10 +235,11 @@ L7_BOOL hapiBroadQosCosEgressBwSupported
 
     first_time = L7_FALSE;
 
     switch (board_info->npd_id)
     {
+    /* PTin updated: new platform */
     case __BROADCOM_56224_ID:
     case __BROADCOM_56304_ID:
     case __BROADCOM_56314_ID:
     case __BROADCOM_56504_ID:
     case __BROADCOM_56514_ID:
@@ -248,10 +249,11 @@ L7_BOOL hapiBroadQosCosEgressBwSupported
     case __BROADCOM_56843_ID:   /* PTin added: new switch BCM56843 */
     case __BROADCOM_56820_ID:
     case __BROADCOM_56634_ID:
     case __BROADCOM_56524_ID:
     case __BROADCOM_56334_ID:
+    case __BROADCOM_56643_ID:   /* PTin added: new switch 56643 */
       egrBwMetersSupported = L7_TRUE;
       break;
 
     default:
       egrBwMetersSupported = L7_FALSE;
diff -rpN --unified=5 esw_original/qos/broad_qos_debug.c esw/qos/broad_qos_debug.c
--- esw_original/qos/broad_qos_debug.c	2013-03-08 12:34:35.548940390 +0000
+++ esw/qos/broad_qos_debug.c	2013-07-22 20:05:50.717056978 +0100
@@ -16,11 +16,17 @@
 *
 *********************************************************************/
 #include <string.h>
 
 #include "broad_qos.h"
+/* PTin removed: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No include */
+#else
 #include "bcm/diffserv.h"
+#endif
 #include "soc/debug.h"
 #include "soc/cm.h"
 #include "soc/mcm/allenum.h"
 #include "bcmx/cosq.h"
 #include "bcmx/port.h"
@@ -58,10 +64,14 @@ void hapiBroadQosDebugInit(void)
 *
 *********************************************************************/
 
 L7_RC_t debugDsStats(L7_uint32 dpid, L7_uint32 cfid)
 {
+  /* PTin removed: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  /* Nothing done! */
+  #else
     L7_uint32                 unit;
     bcm_ds_counters_t         ds_counter;
     L7_uint32                 rv;
     L7_ulong64                stats_in_profile;
     L7_ulong64                stats_out_profile;
@@ -76,11 +86,11 @@ L7_RC_t debugDsStats(L7_uint32 dpid, L7_
     }
     hapiBroadStatsConvert(&stats_in_profile, ds_counter.inp_pkt_cntr);
     hapiBroadStatsConvert(&stats_out_profile, ds_counter.outp_pkt_cntr);
     printf("\nIn-profile packets = %u %u\n", stats_in_profile.high, stats_in_profile.low);
     printf("Out-profile packets = %u %u\n", stats_out_profile.high, stats_out_profile.low);
-
+  #endif
     return L7_SUCCESS;
 }
 
 /*********************************************************************
 *
diff -rpN --unified=5 esw_original/switching/broad_l2_dot1x.c esw/switching/broad_l2_dot1x.c
--- esw_original/switching/broad_l2_dot1x.c	2013-03-08 12:34:35.436696632 +0000
+++ esw/switching/broad_l2_dot1x.c	2013-07-22 20:05:50.717056978 +0100
@@ -339,19 +339,21 @@ L7_BOOL hapiBroadDot1xVFPTableSupported(
 
   /* Based on the board, return the family */
 
   switch (board_info->npd_id)
   {
+  /* PTin updated: new platform */
   case __BROADCOM_56514_ID:
   case __BROADCOM_56624_ID:
   case __BROADCOM_56680_ID:
-  case __BROADCOM_56685_ID:  /* PTin added: new switch */
-  case __BROADCOM_56843_ID:  /* PTin added: new switch BCM56843 */
+  case __BROADCOM_56685_ID:   /* PTin added: new switch */
+  case __BROADCOM_56843_ID:   /* PTin added: new switch BCM56843 */
   case __BROADCOM_56820_ID:
   case __BROADCOM_56634_ID:
   case __BROADCOM_56524_ID:
   case __BROADCOM_56636_ID:
+  case __BROADCOM_56643_ID:   /* PTin added: new switch 56643 */
     supported = L7_TRUE;
     break;
   default:
     supported = L7_FALSE;
     break;
@@ -391,21 +393,23 @@ L7_BOOL hapiBroadDot1xVlanAssignmentSupp
 
   /* Based on the board, return the family */
 
   switch (board_info->npd_id)
   {
+  /* PTin updated: new platform */
   case __BROADCOM_56314_ID:
   case __BROADCOM_56514_ID:
   case __BROADCOM_56624_ID:
   case __BROADCOM_56680_ID:
   case __BROADCOM_56685_ID:  /* PTin added: new switch */
-  case __BROADCOM_56843_ID:  /* PTin added: new switch BCM56843 */
+  case __BROADCOM_56843_ID:   /* PTin added: new switch BCM56843 */
   case __BROADCOM_56820_ID:
   case __BROADCOM_56634_ID:
   case __BROADCOM_56524_ID:
   case __BROADCOM_56636_ID:
   case __BROADCOM_56304_ID:
+  case __BROADCOM_56643_ID:   /* PTin added: new switch 56643 */
 
     supported = L7_TRUE;
     break;
   default:
     supported = L7_FALSE;
@@ -448,20 +452,22 @@ L7_BOOL hapiBroadDot1xPolicySupported()
 
   /* Based on the board, return the family */
 
   switch (board_info->npd_id)
   {
+  /* PTin updated: new platform */
   case __BROADCOM_56314_ID:
   case __BROADCOM_56514_ID:
   case __BROADCOM_56624_ID:
   case __BROADCOM_56680_ID:
-  case __BROADCOM_56685_ID:  /* PTin added: new switch */
-  case __BROADCOM_56843_ID:  /* PTin added: new switch BCM56843 */
+  case __BROADCOM_56685_ID:   /* PTin added: new switch */
+  case __BROADCOM_56843_ID:   /* PTin added: new switch BCM56843 */
   case __BROADCOM_56820_ID:
   case __BROADCOM_56634_ID:
   case __BROADCOM_56524_ID:
   case __BROADCOM_56636_ID:
+  case __BROADCOM_56643_ID:   /* PTin added: new switch 56643 */
 
     supported = L7_TRUE;
     break;
   default:
     supported = L7_FALSE;
diff -rpN --unified=5 esw_original/switching/broad_l2_ipsg.c esw/switching/broad_l2_ipsg.c
--- esw_original/switching/broad_l2_ipsg.c	2013-03-08 12:34:35.436696632 +0000
+++ esw/switching/broad_l2_ipsg.c	2013-07-22 20:05:50.721058165 +0100
@@ -73,20 +73,22 @@ L7_BOOL hapiBroadIpsgSupported()
 
   /* Based on the board, return the family */
 
   switch (board_info->npd_id)
   {
+  /* PTin updated: new platform */
   case __BROADCOM_56514_ID:
   case __BROADCOM_56624_ID:
   case __BROADCOM_56680_ID:
-  case __BROADCOM_56685_ID:  /* PTin added: new switch */
-  case __BROADCOM_56843_ID:  /* PTin added: new switch BCM56843 */
+  case __BROADCOM_56685_ID:   /* PTin added: new switch */
+  case __BROADCOM_56843_ID:   /* PTin added: new switch BCM56843 */
   case __BROADCOM_56820_ID:
   case __BROADCOM_56634_ID:
   case __BROADCOM_56524_ID:
   case __BROADCOM_56636_ID:
   case __BROADCOM_56334_ID:
+  case __BROADCOM_56643_ID:   /* PTin added: new switch 56643 */
     supported = L7_TRUE;
     break;
   default:
     supported = L7_FALSE;
     break;
diff -rpN --unified=5 esw_original/switching/broad_l2_std.c esw/switching/broad_l2_std.c
--- esw_original/switching/broad_l2_std.c	2013-03-08 12:34:35.436696632 +0000
+++ esw/switching/broad_l2_std.c	2013-07-22 20:24:37.864300215 +0100
@@ -52,14 +52,25 @@
 #include "bcmx/l2.h"
 #include "bcmx/l3.h"
 #include "bcmx/stg.h"
 #include "bcmx/auth.h"
 #include "bcmx/vlan.h"
+/* PTin removed: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No include */
+#else
 #include "bcm_int/esw/draco.h"
+#endif
 #include "bcm_int/robo/l2.h"
 #include "bcm_int/esw/firebolt.h"
+/* PTin removed: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No include */
+#else
 #include "bcm_int/esw/easyrider.h"
+#endif
 #include "ibde.h"
 #include "l7_usl_bcmx_l2.h"
 #include "l7_usl_bcmx_port.h"
 #include "l7_usl_api.h"
 #include "bcm/auth.h"
diff -rpN --unified=5 esw_original/switching/broad_l2_vlan.c esw/switching/broad_l2_vlan.c
--- esw_original/switching/broad_l2_vlan.c	2013-03-08 12:34:35.436696632 +0000
+++ esw/switching/broad_l2_vlan.c	2013-07-22 20:24:37.868547135 +0100
@@ -52,11 +52,17 @@
 #include "bcmx/vlan.h"
 #include "bcmx/port.h"
 #include "bcmx/cosq.h"
 #include "bcmx/l2.h"
 #include "bcmx/l3.h"
+/* PTin removed: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No include */
+#else
 #include "bcmx/filter.h"
+#endif
 #include "bcmx/bcmx_int.h"
 
 #ifdef L7_MCAST_PACKAGE
 #include "broad_l3_mcast.h"
 #endif
diff -rpN --unified=5 esw_original/usl/common/broad_bcmx.c esw/usl/common/broad_bcmx.c
--- esw_original/usl/common/broad_bcmx.c	2013-03-08 12:34:35.668944674 +0000
+++ esw/usl/common/broad_bcmx.c	2013-07-22 20:12:46.343590721 +0100
@@ -29,10 +29,12 @@
 
 #ifdef L7_MCAST_PACKAGE
 #include "l7_rpc_ipmcast.h"
 #endif
 
+#include "ptin_globaldefs.h"  /* PTin added: SDK 6.3.0 */
+
 /*********************************************************************
 *
 * @purpose Dispatch function to handle custom BCMX port requests.
 *
 * @param
@@ -43,11 +45,17 @@
 *
 *
 * @end
 *
 *********************************************************************/
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+int custom_bcmx_port_handler(int unit, bcm_port_t port, int setget, int type,
+                             int length, uint32 *args, int *actual_length, void *user_data)
+#else
 int custom_bcmx_port_handler(int unit, bcm_port_t port, int setget, int type, uint32 *args)
+#endif
 {
   int     rv = BCM_E_NOT_FOUND;
   L7_BOOL handled = L7_FALSE;
 
   
diff -rpN --unified=5 esw_original/usl/ipmcast/l7_rpc_ipmcast.c esw/usl/ipmcast/l7_rpc_ipmcast.c
--- esw_original/usl/ipmcast/l7_rpc_ipmcast.c	2013-03-08 12:34:35.624943086 +0000
+++ esw/usl/ipmcast/l7_rpc_ipmcast.c	2013-07-22 20:30:27.774587132 +0100
@@ -30,10 +30,12 @@
 #include "bcmx/custom.h"
 #include "bcmx/bcmx_int.h"
 
 #include "l7_rpc_ipmcast.h"
 
+#include "ptin_globaldefs.h"
+
 #define RV_REPLACE(_trv, _rv)                   \
         BCMX_RV_REPLACE_OK(_trv, _rv, BCM_E_UNAVAIL)
 
 
 /*********************************************************************
@@ -448,10 +450,11 @@ l7_rpc_client_ipmc_add_l2_port_groups (b
 {
   int                        rv = BCM_E_NONE;
   L7_uint32                  i;
   usl_bcmx_port_ipmc_cmd_t  *ipmc_cmd;
   uint32                     args[BCM_CUSTOM_ARGS_MAX];
+  uint32                     n_args;
 
   memset (&args, 0, sizeof (args));
 
   if ((num_groups < 1) || (num_groups > L7_L3_MCAST_ROUTE_TBL_SIZE_TOTAL ))
   {
@@ -475,11 +478,19 @@ l7_rpc_client_ipmc_add_l2_port_groups (b
   }
 
   ipmc_cmd->vlan_id = vlan_id;
   ipmc_cmd->tagged = tagged;
 
+  n_args = sizeof(usl_bcmx_port_ipmc_cmd_t)/sizeof(uint32);
+  if (sizeof(usl_bcmx_port_ipmc_cmd_t)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_L2_PORT_ADD, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_L2_PORT_ADD, args);
+  #endif
 
   return rv;
 }
 
 /*********************************************************************
@@ -536,10 +547,11 @@ l7_rpc_client_ipmc_delete_l2_port_groups
 {
   int                           rv = BCM_E_NONE;
   L7_uint32                     i;
   usl_bcmx_port_ipmc_cmd_t     *ipmc_cmd;
   uint32                        args[BCM_CUSTOM_ARGS_MAX];
+  uint32                        n_args;
 
   memset (&args, 0, sizeof (args));
 
   if ((num_groups < 1) || 
       (num_groups > L7_L3_MCAST_ROUTE_TBL_SIZE_TOTAL ))
@@ -564,12 +576,19 @@ l7_rpc_client_ipmc_delete_l2_port_groups
   }
 
   ipmc_cmd->vlan_id = vlan_id;
   ipmc_cmd->tagged = 0;
 
-  rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_L2_PORT_DELETE, args);
+  n_args = sizeof(usl_bcmx_port_ipmc_cmd_t)/sizeof(uint32);
+  if (sizeof(usl_bcmx_port_ipmc_cmd_t)%sizeof(uint32) != 0)  n_args++;
 
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_L2_PORT_DELETE, n_args, args);
+  #else
+  rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_L2_PORT_DELETE, args);
+  #endif
 
   return rv;
 }
 
 /*********************************************************************
@@ -628,10 +647,11 @@ l7_rpc_client_ipmc_add_l3_port_groups (b
 {
   int                          rv = BCM_E_NONE;
   L7_uint32                    i;
   usl_bcmx_port_ipmc_cmd_t    *ipmc_cmd;
   uint32                       args[BCM_CUSTOM_ARGS_MAX];
+  uint32                       n_args;
 
   memset (&args, 0, sizeof (args));
 
   if ((num_groups < 1) || (num_groups > L7_L3_MCAST_ROUTE_TBL_SIZE_TOTAL ))
   {
@@ -658,11 +678,19 @@ l7_rpc_client_ipmc_add_l3_port_groups (b
   ipmc_cmd->tagged = tagged;
 
   memcpy (ipmc_cmd->mac, mac, 6);
   ipmc_cmd->ttl = ttl;
   
+  n_args = sizeof(usl_bcmx_port_ipmc_cmd_t)/sizeof(uint32);
+  if (sizeof(usl_bcmx_port_ipmc_cmd_t)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_L3_PORT_ADD, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_L3_PORT_ADD, args);
+  #endif
 
   return rv;
 }
 
 /*********************************************************************
@@ -712,10 +740,11 @@ l7_rpc_client_ipmc_egress_port_add (bcmx
                                     L7_uint32    encap_id)
 {
   int                          rv = BCM_E_NONE;
   usl_bcmx_port_ipmc_cmd_t    *ipmc_cmd;
   uint32                       args[BCM_CUSTOM_ARGS_MAX];
+  uint32                       n_args;
 
   memset (&args, 0, sizeof (args));
 
 
   ipmc_cmd = (usl_bcmx_port_ipmc_cmd_t *) args;
@@ -728,11 +757,19 @@ l7_rpc_client_ipmc_egress_port_add (bcmx
   USL_BCMX_PORT_IPMC_INDEX_MEMBER_SET (*ipmc_index, 
                                        ipmc_cmd->ipmc_index_mask);
 
   ipmc_cmd->encap_id = encap_id;
   
+  n_args = sizeof(usl_bcmx_port_ipmc_cmd_t)/sizeof(uint32);
+  if (sizeof(usl_bcmx_port_ipmc_cmd_t)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_EGRESS_PORT_ADD, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_EGRESS_PORT_ADD, args);
+  #endif
 
   return rv;
 }
 /*********************************************************************
 *
@@ -786,10 +823,11 @@ l7_rpc_client_ipmc_delete_l3_port_groups
 {
   int rv = BCM_E_NONE;
   L7_uint32 i;
   usl_bcmx_port_ipmc_cmd_t *ipmc_cmd;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   memset (&args, 0, sizeof (args));
 
   if ((num_groups < 1) || (num_groups > L7_L3_MCAST_ROUTE_TBL_SIZE_TOTAL ))
   {
@@ -812,11 +850,19 @@ l7_rpc_client_ipmc_delete_l3_port_groups
                                          ipmc_cmd->ipmc_index_mask);
   }
 
   ipmc_cmd->vlan_id = vlan_id;
 
+  n_args = sizeof(usl_bcmx_port_ipmc_cmd_t)/sizeof(uint32);
+  if (sizeof(usl_bcmx_port_ipmc_cmd_t)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_L3_PORT_DELETE, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_L3_PORT_DELETE, args);
+  #endif
 
   return rv;
 }
 
 /*********************************************************************
@@ -866,10 +912,11 @@ l7_rpc_client_ipmc_egress_port_delete (b
                                        L7_uint32    encap_id)
 {
   int rv = BCM_E_NONE;
   usl_bcmx_port_ipmc_cmd_t *ipmc_cmd;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   memset (&args, 0, sizeof (args));
 
   ipmc_cmd = (usl_bcmx_port_ipmc_cmd_t *) args;
 
@@ -880,11 +927,19 @@ l7_rpc_client_ipmc_egress_port_delete (b
   USL_BCMX_PORT_IPMC_INDEX_MEMBER_SET (*ipmc_index,
                                        ipmc_cmd->ipmc_index_mask);
 
   ipmc_cmd->encap_id = encap_id;
 
+  n_args = sizeof(usl_bcmx_port_ipmc_cmd_t)/sizeof(uint32);
+  if (sizeof(usl_bcmx_port_ipmc_cmd_t)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_EGRESS_PORT_DELETE, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_IPMC_EGRESS_PORT_DELETE, args);
+  #endif
 
   return rv;
 }
 
 /*********************************************************************
diff -rpN --unified=5 esw_original/usl/ipmcast/l7_usl_bcm_ipmcast.c esw/usl/ipmcast/l7_usl_bcm_ipmcast.c
--- esw_original/usl/ipmcast/l7_usl_bcm_ipmcast.c	2013-03-08 12:34:35.624943086 +0000
+++ esw/usl/ipmcast/l7_usl_bcm_ipmcast.c	2013-07-22 20:36:37.935540774 +0100
@@ -19,10 +19,11 @@
 * @end
 *
 **********************************************************************/
 
 #include "l7_common.h"
+#include "ptin_globaldefs.h"
 
 #ifdef L7_MCAST_PACKAGE
 
 #include "osapi.h"
 #include "log.h"
@@ -83,10 +84,25 @@ int l7_ipmc_to_bcm(usl_bcm_ipmc_addr_t  
   bcm_ipmc->ts = ipmc->ts;
   bcm_ipmc->port_tgid = ipmc->port_tgid;
   bcm_ipmc->mod_id = ipmc->mod_id; 
   bcm_ipmc->v = 1;   /* VALID */
   bcm_ipmc->flags = ipmc->flags;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_ipmc->group = ipmc->ipmc_index;
+
+  bcm_ipmc->vrf = ipmc->vrf;
+  bcm_ipmc->lookup_class = ipmc->lookup_class;
+  bcm_ipmc->distribution_class = ipmc->distribution_class;
+
+  /* Invalid id */
+  if (ipmc->ipmc_index <= 0)
+  {
+    rv = BCM_E_BADID;
+  }
+  #else
   bcm_ipmc->ipmc_index = ipmc->ipmc_index; 
   if (ipmc->ipmc_index >= 0)
   {
     bcm_ipmc->flags |= BCM_IPMC_USE_IPMC_INDEX;
   }
@@ -98,10 +114,11 @@ int l7_ipmc_to_bcm(usl_bcm_ipmc_addr_t  
   BCM_PBMP_ASSIGN (bcm_ipmc->l2_pbmp, ipmc->l2_pbmp[my_modid]);
   BCM_PBMP_OR(bcm_ipmc->l2_pbmp, PBMP_HG_ALL(bcm_unit));
   BCM_PBMP_OR(bcm_ipmc->l2_pbmp, PBMP_HL_ALL(bcm_unit));
   BCM_PBMP_ASSIGN (bcm_ipmc->l2_ubmp, ipmc->l2_ubmp[my_modid]);
   BCM_PBMP_ASSIGN (bcm_ipmc->l3_pbmp, ipmc->l3_pbmp[my_modid]);
+  #endif
 
   return rv;
 }
 
 /*********************************************************************
@@ -119,22 +136,77 @@ int usl_bcm_ipmc_add (usl_bcm_ipmc_addr_
   L7_uint32 bcm_unit;
   int rv = BCM_E_NONE;
   bcm_pbmp_t    pbmp;
   L7_uint32     port;
   bcm_ipmc_addr_t bcm_ipmc;
+  /* PTin added: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_multicast_t group;
+  L7_uint32 flags;
+  L7_BOOL   create_group;
+  #endif
 
   /* Check if the hw should be configured */
   if (USL_BCM_CONFIGURE_HW(USL_IPMC_ROUTE_DB_ID) == L7_TRUE)
   {
     /* send the request to all of the local units */
     for (bcm_unit=0;bcm_unit < soc_ndev;bcm_unit++)
     {
       if (!BCM_IS_FABRIC(bcm_unit))
       {
+        /* PTin added: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+
+        /* Input group id */
+        group = ipmc->ipmc_index;
+
+        /* Default flags */
+        flags = BCM_MULTICAST_TYPE_L2 | BCM_MULTICAST_TYPE_L3;
+        
+        /* Create group, by default */
+        create_group = L7_TRUE;
+
+        /* Check if provided group is valid */
+        if ( group > 0)
+        {
+          rv = bcm_multicast_group_is_free(bcm_unit, group);
+          if (rv != BCM_E_NONE || rv != BCM_E_EXISTS)
+          {
+            L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Invalid group index %d", group);
+            break;
+          }
+
+          /* If group id exists, no need to create it */
+          if (rv == BCM_E_EXISTS)
+          {
+            create_group = L7_FALSE;
+          }
+          /* Otherwise, create group with specific group id */
+          else
+          {
+            flags |= BCM_MULTICAST_WITH_ID;
+          }
+        }
+
+        /* Create group, if necessary */
+        if (create_group)
+        {
+          rv = bcm_multicast_create(bcm_unit, flags, &group);
+          if (rv != BCM_E_NONE && rv != BCM_E_EXISTS)
+          {
+            break;
+          }
+        }
+
+        /* Save group id */
+        ipmc->ipmc_index = group;
+        bcm_ipmc.group   = group;
+        #endif
+
         /* populate the SDK bcm structure from USL bcm structure for this unit */
         rv = l7_ipmc_to_bcm(ipmc, bcm_unit, &bcm_ipmc);  
-        if (rv != BCM_E_NONE)
+        if (rv != BCM_E_NONE && rv != BCM_E_BADID)  /* PTin modified: SDK 6.3.0 */
         {
           break;    
         }
 
         if (usl_db_ipmc_rpf_check_mode_get() == L7_FALSE)
@@ -143,11 +215,12 @@ int usl_bcm_ipmc_add (usl_bcm_ipmc_addr_
         }
         if (replace_entry)
         {
           bcm_ipmc.flags |= BCM_IPMC_REPLACE;
         }
-        rv = bcm_ipmc_add(bcm_unit, &bcm_ipmc);      
+
+        rv = bcm_ipmc_add(bcm_unit, &bcm_ipmc);
         if (L7_BCMX_OK(rv) != L7_TRUE)
         {
           break;
         }
       }
@@ -158,11 +231,16 @@ int usl_bcm_ipmc_add (usl_bcm_ipmc_addr_
 
         BCM_PBMP_OR(pbmp,PBMP_HG_ALL(bcm_unit));
 
         BCM_PBMP_ITER(pbmp, port)
         {
+          /* PTin modified: SDK 6.3.0 */
+          #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+          rv = bcm_ipmc_bitmap_set(bcm_unit, ipmc->ipmc_index, port, pbmp);
+          #else
           rv = bcm_ipmc_bitmap_set(bcm_unit, bcm_ipmc.ipmc_index, port, pbmp);
+          #endif
           if (L7_BCMX_OK(rv) != L7_TRUE)
           {
             break;
           }
         }
@@ -196,10 +274,13 @@ int usl_bcm_ipmc_delete (usl_bcm_ipmc_ad
   int                  rv = BCM_E_NONE;
   bcm_pbmp_t           pbmp, empty;
   L7_uint32            port;
   bcm_ipmc_addr_t      bcm_ipmc;
   bcm_vlan_vector_t    vlan_vector;
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_vlan_vector_t    vlan_vector_empty;
+  #endif
   
   /* Check if the hw should be configured */
   if (USL_BCM_CONFIGURE_HW(USL_IPMC_ROUTE_DB_ID) == L7_TRUE)
   {
     for (bcm_unit=0;bcm_unit < soc_ndev;bcm_unit++)
@@ -209,10 +290,41 @@ int usl_bcm_ipmc_delete (usl_bcm_ipmc_ad
         continue;
       }
 
       /* Set the replication config for all L3 ports to an empty VLAN vector. */
       memset (&bcm_ipmc, 0, sizeof (bcm_ipmc));
+
+      /* Ptin TODO: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      /* Remove replication vectors */
+      if (ipmc->ipmc_index > 0)
+      {
+        /* Run all ports, and check if there are replicators to be removed */
+        BCM_PBMP_CLEAR(pbmp);
+        BCM_PBMP_OR(pbmp, PBMP_FE_ALL(bcm_unit));
+        BCM_PBMP_OR(pbmp, PBMP_GE_ALL(bcm_unit));
+        BCM_PBMP_OR(pbmp, PBMP_XE_ALL(bcm_unit));
+        BCM_PBMP_OR(pbmp, PBMP_HG_ALL(bcm_unit));
+        BCM_PBMP_OR(pbmp, PBMP_HL_ALL(bcm_unit));
+
+        BCM_VLAN_VEC_ZERO(vlan_vector_empty);
+
+        BCM_PBMP_ITER(pbmp, port)
+        {
+          /* Only consider ports, where there is replication vectors */
+          if (bcm_multicast_repl_get(bcm_unit, ipmc->ipmc_index, port, vlan_vector) == BCM_E_NONE)
+          {
+            rv = bcm_multicast_repl_set(bcm_unit, ipmc->ipmc_index, port, vlan_vector_empty);
+            if (rv != BCM_E_NONE)
+            {
+              L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't clear VLAN vector for IPMC index %d, unit %d, port %d, rv %d", 
+                      ipmc->ipmc_index, bcm_unit, port, rv);
+            }
+          }
+        }
+      }
+      #else
       rv = bcm_ipmc_get_by_index(bcm_unit, ipmc->ipmc_index, &bcm_ipmc);
       if (rv == BCM_E_NONE)
       {
         BCM_VLAN_VEC_ZERO(vlan_vector);
 
@@ -224,12 +336,19 @@ int usl_bcm_ipmc_delete (usl_bcm_ipmc_ad
             L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't clear VLAN vector for IPMC index %d, unit %d, port %d, rv %d", 
                     ipmc->ipmc_index, bcm_unit, port, rv);
           }
         }
       }
+      #endif
 
       rv = l7_ipmc_to_bcm(ipmc, bcm_unit, &bcm_ipmc);
+
+      if (rv != BCM_E_NONE)
+      {
+        break;
+      }
+
       if (keep)
       {   
         bcm_ipmc.flags |= BCM_IPMC_KEEP_ENTRY;
       }
       else 
@@ -241,10 +360,23 @@ int usl_bcm_ipmc_delete (usl_bcm_ipmc_ad
     
       if (L7_BCMX_OK(rv) != L7_TRUE)
       {
         break;
       }
+
+      /* PTin added: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      rv = bcm_multicast_destroy(bcm_unit, ipmc->ipmc_index);
+
+      if (L7_BCMX_OK(rv) != L7_TRUE)
+      {
+        break;
+      }
+
+      ipmc->ipmc_index = -1;
+      bcm_ipmc.group   = -1;
+      #endif
     }
 
     /* Delete the entry to the local fabric chips if we have an mc index */
     if (L7_BCMX_OK(rv) == L7_TRUE)
     {
@@ -307,11 +439,26 @@ int usl_bcm_ipmc_rpf_set (usl_bcm_ipmc_a
       {
         continue;
       }
 
       memset (&bcm_ipmc, 0, sizeof (bcm_ipmc));
+      /* PTin modified: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      /* Get IPMC data */
+      rv = l7_ipmc_to_bcm(ipmc, bcm_unit, &bcm_ipmc);
+      if (rv != BCM_E_NONE)
+      {
+        break;
+      }
+      rv = bcm_ipmc_find(bcm_unit, &bcm_ipmc);
+      if (rv != BCM_E_NONE)
+      {
+        break;
+      }
+      #else
       rv = bcm_ipmc_get_by_index(bcm_unit, ipmc->ipmc_index, &bcm_ipmc);
+      #endif
       if (rv != BCM_E_NONE)
       {
         break;
       }
 
@@ -367,10 +514,16 @@ L7_RC_t usl_bcm_ipmc_set_l2_ports (usl_b
 {
   L7_int32            bcm_unit, modid;
   L7_int32            index;
   int                 rv = BCM_E_NONE;
   bcm_ipmc_addr_t     bcm_ipmc;
+  /* PTin added: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_port_t port;
+  bcm_gport_t gport;
+  bcm_if_t encap_id;
+  #endif
 
   memset (&bcm_ipmc, 0, sizeof (bcm_ipmc));
 
   index = ipmc_addr->ipmc_index;
 
@@ -382,11 +535,16 @@ L7_RC_t usl_bcm_ipmc_set_l2_ports (usl_b
       if (BCM_IS_FABRIC(bcm_unit))
       {
         continue;
       }
    
+      /* TODO: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      rv = l7_ipmc_to_bcm(ipmc_addr, bcm_unit, &bcm_ipmc);
+      #else
       rv = bcm_ipmc_get_by_index(bcm_unit, index, &bcm_ipmc);
+      #endif
       if (L7_BCMX_OK(rv) != L7_TRUE)
       {
         break;
       }
 
@@ -400,25 +558,81 @@ L7_RC_t usl_bcm_ipmc_set_l2_ports (usl_b
       if (rv != BCM_E_NONE)
       {
         break;
       }
 
+      /* PTin removed: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      /* Add L2 ports */
+      BCM_PBMP_ITER(ipmc_addr->l2_pbmp[modid], port)
+      {
+        /* Get gport */
+        rv = bcm_port_gport_get(bcm_unit, port, &gport);
+        if (rv != BCM_E_NONE)
+          break;
+
+        /* Get encap id */
+        rv = bcm_multicast_l2_encap_get(bcm_unit, ipmc_addr->ipmc_index, gport, ipmc_addr->vid, &encap_id);
+        if (rv != BCM_E_NONE)
+          break;
+
+        /* Add egress port */
+        rv = bcm_multicast_egress_add(bcm_unit, ipmc_addr->ipmc_index, gport, encap_id);
+        if (rv != BCM_E_NONE && rv != BCM_E_EXISTS)
+          break;
+      }
+      /* If error, undo procedure */
+      if (L7_BCMX_OK(rv) != L7_TRUE)
+      {
+        (void) bcm_multicast_egress_delete_all(bcm_unit, ipmc_addr->ipmc_index);
+        break;
+      }
+
+      #if 0
+      /* Add L3 ports */
+      BCM_PBMP_ITER(ipmc_addr->l3_pbmp[modid], port)
+      {
+        /* Get gport */
+        rv = bcm_port_gport_get(bcm_unit, port, &gport);
+        if (rv != BCM_E_NONE)
+          break;
+
+        /* Get encap id */
+        rv = bcm_multicast_l3_encap_get(bcm_unit, ipmc_addr->ipmc_index, gport, ipmc_addr->vid, &encap_id);
+        if (rv != BCM_E_NONE)
+          break;
+
+        /* Add egress port */
+        rv = bcm_multicast_egress_add(bcm_unit, ipmc_addr->ipmc_index, gport, encap_id);
+        if (rv != BCM_E_NONE && rv != BCM_E_EXISTS)
+          break;
+      }
+      /* If error, undo procedure */
+      if (L7_BCMX_OK(rv) != L7_TRUE)
+      {
+        (void) bcm_multicast_egress_delete_all(bcm_unit, ipmc_addr->ipmc_index);
+        break;
+      }
+      #endif
+      #else
       BCM_PBMP_ASSIGN (bcm_ipmc.l2_pbmp, ipmc_addr->l2_pbmp[modid]);
       BCM_PBMP_OR(bcm_ipmc.l2_pbmp, PBMP_HG_ALL(bcm_unit));
       BCM_PBMP_OR(bcm_ipmc.l2_pbmp, PBMP_HL_ALL(bcm_unit));
       BCM_PBMP_ASSIGN (bcm_ipmc.l2_ubmp, ipmc_addr->l2_ubmp[modid]);
 
       bcm_ipmc.flags |= BCM_IPMC_REPLACE;
       if (usl_db_ipmc_rpf_check_mode_get() == L7_FALSE)
       {
         bcm_ipmc.flags |= BCM_IPMC_SOURCE_PORT_NOCHECK;
       }
+
       rv = bcm_ipmc_add(bcm_unit, &bcm_ipmc);
       if (L7_BCMX_OK(rv) != L7_TRUE)
       {
         break;
       }
+      #endif
     }
   }
 
   /* Update the USL Db */
   if ((L7_BCMX_OK(rv) == L7_TRUE) && 
@@ -448,15 +662,20 @@ int usl_bcm_ipmc_add_l2_port_groups (int
 {
   int                            rv = BCM_E_NONE;
   usl_bcm_ipmc_addr_t            l7_ipmc, l7_ipmc_tmp;
   bcm_ipmc_addr_t                ipmc;
   int                            index;
+  /* PTin added: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_gport_t gport;
+  bcm_if_t encap_id;
+  #else
   bcm_pbmp_t                     tagged_pbmp, untagged_pbmp;
+  #endif
   L7_uint32                      i;
   L7_int32                       myModid;
 
-
   rv = bcm_stk_my_modid_get(unit, &myModid);
   if (rv != BCM_E_NONE)
   {
     return rv; 
   }
@@ -489,10 +708,34 @@ int usl_bcm_ipmc_add_l2_port_groups (int
       memset(&ipmc,    0, sizeof(ipmc));
 
       /* Check if the hw should be configured */
       if (USL_BCM_CONFIGURE_HW(USL_IPMC_ROUTE_DB_ID) == L7_TRUE)
       {
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        /* Valdiate group id */
+        if (ipmc_cmd->ipmc_index <= 0)
+        {
+          rv = BCM_E_BADID;
+          continue;
+        }
+        /* Get gport */
+        rv = bcm_port_gport_get(unit, port, &gport);
+        if (rv != BCM_E_NONE)
+          continue;
+
+        /* Get encap id */
+        rv = bcm_multicast_l2_encap_get(unit, ipmc_cmd->ipmc_index, gport, ipmc_cmd->vlan_id, &encap_id);
+        if (rv != BCM_E_NONE)
+          continue;
+
+        /* Add egress port */
+        rv = bcm_multicast_egress_add(unit, ipmc_cmd->ipmc_index, gport, encap_id);
+        if (rv != BCM_E_NONE && rv != BCM_E_EXISTS)
+          continue;
+
+        #else
         rv = bcm_ipmc_get_by_index(unit, index, &ipmc);
         if (rv != BCM_E_NONE)
         {
           continue;
         }
@@ -522,10 +765,11 @@ int usl_bcm_ipmc_add_l2_port_groups (int
         rv = bcm_ipmc_add(unit, &ipmc);
         if (L7_BCMX_OK(rv) != L7_TRUE)
         {
           continue;
         }
+        #endif
       }
 
       if (USL_BCM_CONFIGURE_DB(USL_IPMC_ROUTE_DB_ID) == L7_FALSE)
       {
         continue; 
@@ -577,10 +821,15 @@ int usl_bcm_ipmc_delete_l2_port_groups (
   usl_bcm_ipmc_addr_t           l7_ipmc, l7_ipmc_tmp;
   bcm_ipmc_addr_t               ipmc;
   int                           index;
   L7_uint32                     i;
   L7_int32                      myModid;
+  /* PTin added: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_gport_t gport;
+  bcm_if_t encap_id;
+  #endif
 
   rv = bcm_stk_my_modid_get(unit, &myModid);
   if (rv != BCM_E_NONE)
   {
     return rv; 
@@ -614,10 +863,34 @@ int usl_bcm_ipmc_delete_l2_port_groups (
       memset(&ipmc,    0, sizeof(ipmc));
 
       /* Check if the hw should be configured */
       if (USL_BCM_CONFIGURE_HW(USL_IPMC_ROUTE_DB_ID) == L7_TRUE)
       {
+        /* TODO: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        /* Valdiate group id */
+        if (ipmc_cmd->ipmc_index <= 0)
+        {
+          rv = BCM_E_BADID;
+          continue;
+        }
+        /* Get gport */
+        rv = bcm_port_gport_get(unit, port, &gport);
+        if (rv != BCM_E_NONE)
+          continue;
+
+        /* Get encap id */
+        rv = bcm_multicast_l2_encap_get(unit, ipmc_cmd->ipmc_index, gport, ipmc_cmd->vlan_id, &encap_id);
+        if (rv != BCM_E_NONE)
+          continue;
+
+        /* Add egress port */
+        rv = bcm_multicast_egress_delete(unit, ipmc_cmd->ipmc_index, gport, encap_id);
+        if (rv != BCM_E_NONE && rv != BCM_E_EXISTS)
+          continue;
+
+        #else
         rv = bcm_ipmc_get_by_index(unit, index, &ipmc);
         if (rv != BCM_E_NONE)
         {
           continue;
         }
@@ -625,11 +898,10 @@ int usl_bcm_ipmc_delete_l2_port_groups (
         if (!ipmc.v) 
         {
           continue;
         }
 
-
         BCM_PBMP_PORT_REMOVE(ipmc.l2_pbmp, port);
         BCM_PBMP_PORT_REMOVE(ipmc.l2_ubmp, port);
 
         ipmc.flags |= BCM_IPMC_REPLACE;
         if (usl_db_ipmc_rpf_check_mode_get() == L7_FALSE)
@@ -640,10 +912,11 @@ int usl_bcm_ipmc_delete_l2_port_groups (
 
         if (L7_BCMX_OK(rv) != L7_TRUE)
         {
           continue;
         }
+        #endif
       }
 
       if (USL_BCM_CONFIGURE_DB(USL_IPMC_ROUTE_DB_ID) == L7_FALSE)
       {
         continue; 
@@ -689,11 +962,17 @@ int usl_bcm_ipmc_add_l3_port_groups (int
                                      usl_bcmx_port_ipmc_cmd_t *ipmc_cmd)
 {
   int                       rv = BCM_E_NONE;
   bcm_ipmc_addr_t           ipmc;
   int                       index;
+  /* PTin added: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_gport_t gport;
+  bcm_if_t encap_id;
+  #else
   bcm_pbmp_t                l3_pbmp;
+  #endif
   L7_uint32                 i;
   int                       ipmc_untag_flag;
   L7_uint32                 myModid;
   L7_uint32                 ipmc_group_index[L7_L3_MCAST_ROUTE_TBL_SIZE_TOTAL];
   L7_uint32                 num_ipmc_groups = 0;
@@ -739,10 +1018,34 @@ int usl_bcm_ipmc_add_l3_port_groups (int
     {
       index = ipmc_group_index[i];
 
       memset(&ipmc, 0, sizeof(ipmc));
 
+      /* TODO: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      /* Validate group id */
+      if (ipmc_cmd->ipmc_index <= 0)
+      {
+        rv = BCM_E_BADID;
+        continue;
+      }
+      /* Get gport */
+      rv = bcm_port_gport_get(unit, port, &gport);
+      if (rv != BCM_E_NONE)
+        continue;
+
+      /* Get encap id */
+      rv = bcm_multicast_l3_encap_get(unit, ipmc_cmd->ipmc_index, gport, ipmc_cmd->vlan_id, &encap_id);
+      if (rv != BCM_E_NONE)
+        continue;
+
+      /* Add egress port */
+      rv = bcm_multicast_egress_add(unit, ipmc_cmd->ipmc_index, gport, encap_id);
+      if (rv != BCM_E_NONE && rv != BCM_E_EXISTS)
+        continue;
+
+      #else
       rv = bcm_ipmc_get_by_index(unit, index, &ipmc);
       if (rv != BCM_E_NONE)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't get IPMC entry for index %d, rv %d", index, rv);
         continue;
@@ -760,18 +1063,37 @@ int usl_bcm_ipmc_add_l3_port_groups (int
       if (usl_db_ipmc_rpf_check_mode_get() == L7_FALSE)
       {
         ipmc.flags |= BCM_IPMC_SOURCE_PORT_NOCHECK;
       }
       rv = bcm_ipmc_add(unit, &ipmc); 
+
       if (rv != BCM_E_NONE)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't add IPMC entry for index %d, rv %d", index, rv);
         continue;
       }
+      #endif
 
       /* Set up VLAN replication.
       */
+      /* TODO: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      rv = bcm_multicast_repl_get(unit, index, port, vlan_vector);
+      if (L7_BCMX_OK(rv) != L7_TRUE)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't get replication info for IPMC entry index %d, rv %d", index, rv);
+        continue;
+      }
+
+      BCM_VLAN_VEC_SET(vlan_vector, ipmc_cmd->vlan_id);
+      rv = bcm_multicast_repl_set(unit, index, port, vlan_vector);
+      if (L7_BCMX_OK(rv) != L7_TRUE)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't set replication info for IPMC entry index %d, rv %d", index, rv);
+        continue;
+      }
+      #else
       rv = bcm_ipmc_repl_get(unit, index, port, vlan_vector);
       if (L7_BCMX_OK(rv) != L7_TRUE)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't get replication info for IPMC entry index %d, rv %d", index, rv);
         continue;
@@ -782,10 +1104,11 @@ int usl_bcm_ipmc_add_l3_port_groups (int
       if (L7_BCMX_OK(rv) != L7_TRUE)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't set replication info for IPMC entry index %d, rv %d", index, rv);
         continue;
       }
+      #endif
 
       (void)bcm_ipmc_egress_port_set(unit, port, 
                                      ipmc_cmd->mac,
                                      ipmc_untag_flag, 
                                      ipmc_cmd->vlan_id,
@@ -834,11 +1157,17 @@ int usl_bcm_ipmc_egress_port_add (int un
   L7_uint32                 i;
   int                       ipmc_untag_flag;
   L7_uint32                 myModid;
   L7_uint32                 ipmc_group_index[L7_L3_MCAST_ROUTE_TBL_SIZE_TOTAL];
   L7_uint32                 num_ipmc_groups = 0;
+  /* PTin added: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_gport_t gport;
+  bcm_if_t encap_id;
+  #else
   bcm_multicast_t group;
+  #endif
 
   rv = bcm_stk_my_modid_get(unit, &myModid);
   if (rv != BCM_E_NONE)
   {
     return rv; 
@@ -878,10 +1207,38 @@ int usl_bcm_ipmc_egress_port_add (int un
     {
       index = ipmc_group_index[i];
 
       memset(&ipmc, 0, sizeof(ipmc));
 
+      /* TODO: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      if ( ipmc_cmd->ipmc_index <= 0)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't get IPMC entry for index %d, rv %d", index, rv);
+        rv = BCM_E_BADID;
+        continue;
+      }
+
+      /* Get gport */
+      rv = bcm_port_gport_get(unit, port, &gport);
+      if (rv != BCM_E_NONE)
+        continue;
+
+      /* Get encap id */
+      rv = bcm_multicast_l3_encap_get(unit, ipmc_cmd->ipmc_index, gport, ipmc_cmd->vlan_id, &encap_id);
+      if (rv != BCM_E_NONE)
+        continue;
+
+      /* Add egress port */
+      rv = bcm_multicast_egress_add(unit, ipmc_cmd->ipmc_index, gport, encap_id);
+      if (rv != BCM_E_NONE && rv != BCM_E_EXISTS)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't add IPMC entry for index %d, rv %d", index, rv);
+        continue;
+      }
+
+      #else
       rv = bcm_ipmc_get_by_index(unit, index, &ipmc);
       if (rv != BCM_E_NONE)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't get IPMC entry for index %d, rv %d", index, rv);
         continue;
@@ -897,10 +1254,11 @@ int usl_bcm_ipmc_egress_port_add (int un
       if (rv != BCM_E_NONE)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't add IPMC entry for index %d, rv %d", index, rv);
         continue;
       }
+      #endif
     }
   }
 
   if ((USL_BCM_CONFIGURE_DB(USL_IPMC_ROUTE_DB_ID) == L7_TRUE) &&
       (L7_BCMX_OK(rv) == L7_TRUE))
@@ -942,11 +1300,17 @@ int usl_bcm_ipmc_egress_port_delete (int
   L7_uint32                 i;
   int                       ipmc_untag_flag;
   L7_uint32                 myModid;
   L7_uint32                 ipmc_group_index[L7_L3_MCAST_ROUTE_TBL_SIZE_TOTAL];
   L7_uint32                 num_ipmc_groups = 0;
+  /* PTin added: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_gport_t gport;
+  bcm_if_t encap_id;
+  #else
   bcm_multicast_t group;
+  #endif
 
   rv = bcm_stk_my_modid_get(unit, &myModid);
   if (rv != BCM_E_NONE)
   {
     return rv; 
@@ -986,10 +1350,37 @@ int usl_bcm_ipmc_egress_port_delete (int
     {
       index = ipmc_group_index[i];
 
       memset(&ipmc, 0, sizeof(ipmc));
 
+      /* TODO: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      if ( ipmc_cmd->ipmc_index <= 0)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't get IPMC entry for index %d, rv %d", index, rv);
+        rv = BCM_E_BADID;
+        continue;
+      }
+
+      /* Get gport */
+      rv = bcm_port_gport_get(unit, port, &gport);
+      if (rv != BCM_E_NONE)
+        continue;
+
+      /* Get encap id */
+      rv = bcm_multicast_l3_encap_get(unit, ipmc_cmd->ipmc_index, gport, ipmc_cmd->vlan_id, &encap_id);
+      if (rv != BCM_E_NONE)
+        continue;
+
+      /* Add egress port */
+      rv = bcm_multicast_egress_delete(unit, ipmc_cmd->ipmc_index, gport, encap_id);
+      if (rv != BCM_E_NONE && rv != BCM_E_EXISTS)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't delete IPMC entry for index %d, rv %d", index, rv);
+        continue;
+      }
+      #else
       rv = bcm_ipmc_get_by_index(unit, index, &ipmc);
       if (rv != BCM_E_NONE)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't get IPMC entry for index %d, rv %d", index, rv);
         continue;
@@ -1005,10 +1396,11 @@ int usl_bcm_ipmc_egress_port_delete (int
       if (rv != BCM_E_NONE)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't add IPMC entry for index %d, rv %d", index, rv);
         continue;
       }
+      #endif
     }
   }
 
   if ((USL_BCM_CONFIGURE_DB(USL_IPMC_ROUTE_DB_ID) == L7_TRUE) &&
       (L7_BCMX_OK(rv) == L7_TRUE))
@@ -1100,10 +1492,15 @@ int usl_bcm_ipmc_delete_l3_port_groups (
   L7_uint32                      i;
   bcm_vlan_vector_t              vlan_vector;
   L7_uint32                      myModid;
   L7_uint32                      ipmc_group_index[L7_L3_MCAST_ROUTE_TBL_SIZE_TOTAL];
   L7_uint32                      num_ipmc_groups = 0;
+  /* PTin added: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_gport_t gport;
+  bcm_if_t encap_id;
+  #endif
 
   rv = bcm_stk_my_modid_get(unit, &myModid);
   if (rv != BCM_E_NONE)
   {
     return rv; 
@@ -1141,10 +1538,19 @@ int usl_bcm_ipmc_delete_l3_port_groups (
     {
       index = ipmc_group_index[i];
 
       memset(&ipmc, 0, sizeof(ipmc));
 
+      /* TODO: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      /* Validate group id */
+      if (ipmc_cmd->ipmc_index <= 0)
+      {
+        rv = BCM_E_BADID;
+        continue;
+      }
+      #else
       rv = bcm_ipmc_get_by_index(unit, index, &ipmc);
       if (rv != BCM_E_NONE)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't get IPMC entry for index %d, rv %d", index, rv);
         continue;
@@ -1152,13 +1558,31 @@ int usl_bcm_ipmc_delete_l3_port_groups (
 
       if (!ipmc.v) 
       {
         continue;
       }
+      #endif
 
       /* Set up VLAN replication.
       */
+      /* TODO: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      rv = bcm_multicast_repl_get(unit, index, port, vlan_vector);
+      if (L7_BCMX_OK(rv) != L7_TRUE)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't get replication info for IPMC entry index %d, rv %d", index, rv);
+        continue;
+      }
+
+      BCM_VLAN_VEC_CLR(vlan_vector, ipmc_cmd->vlan_id);
+      rv = bcm_multicast_repl_set(unit, index, port, vlan_vector);
+      if (L7_BCMX_OK(rv) != L7_TRUE)
+      {
+        L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't set replication info for IPMC entry index %d, rv %d", index, rv);
+        continue;
+      }
+      #else
       rv = bcm_ipmc_repl_get(unit, index, port, vlan_vector);
       if (L7_BCMX_OK(rv) != L7_TRUE)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't get replication info for IPMC entry index %d, rv %d", index, rv);
         continue;
@@ -1169,23 +1593,43 @@ int usl_bcm_ipmc_delete_l3_port_groups (
       if (L7_BCMX_OK(rv) != L7_TRUE)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DRIVER_COMPONENT_ID, "Couldn't set replication info for IPMC entry index %d, rv %d", index, rv);
         continue;
       }
+      #endif
 
       /* If the egress port doesn't have any more replicated VLANs then remove the
       ** port from the L3 group.
       */
       if (usl_db_ipmc_vlan_vector_is_empty(vlan_vector))
       {
+        /* TODO: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        /* Get gport */
+        rv = bcm_port_gport_get(unit, port, &gport);
+        if (rv != BCM_E_NONE)
+          continue;
+
+        /* Get encap id */
+        rv = bcm_multicast_l3_encap_get(unit, ipmc_cmd->ipmc_index, gport, ipmc_cmd->vlan_id, &encap_id);
+        if (rv != BCM_E_NONE)
+          continue;
+
+        /* Add egress port */
+        rv = bcm_multicast_egress_delete(unit, ipmc_cmd->ipmc_index, gport, encap_id);
+        if (rv != BCM_E_NONE && rv != BCM_E_EXISTS)
+          continue;
+
+        #else
         BCM_PBMP_PORT_REMOVE(ipmc.l3_pbmp, port);
         ipmc.flags |= BCM_IPMC_REPLACE;
         if (usl_db_ipmc_rpf_check_mode_get() == L7_FALSE)
         {
           ipmc.flags |= BCM_IPMC_SOURCE_PORT_NOCHECK;
         }
         rv = bcm_ipmc_add(unit, &ipmc);
+        #endif
       }
     }
   }
 
   if (USL_BCM_CONFIGURE_DB(USL_IPMC_ROUTE_DB_ID) == L7_TRUE)
@@ -1231,15 +1675,24 @@ int usl_bcm_ipmc_inuse_get(usl_bcm_ipmc_
       if (rv != BCM_E_NONE)
       {
         break;    
       }
 
+      /* TODO: SDK 6.3.0 */
+      #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+      rv = bcm_ipmc_find(bcm_unit, &bcm_ipmc);
+      if (rv != BCM_E_NONE)
+      {
+        continue;
+      }
+      #else
       rv = bcm_ipmc_get_by_index(bcm_unit, bcm_ipmc.ipmc_index, &bcm_ipmc);
       if (rv != BCM_E_NONE)
       {
         continue;
       }
+      #endif
 
       if (!bcm_ipmc.v) 
       {
         continue;
       }
@@ -1281,10 +1734,15 @@ int usl_bcm_ipmc_l3_port_repl_set(L7_uin
   L7_int32            bcm_unit, myModid;
   int                 rv = BCM_E_NONE;
   bcm_ipmc_addr_t     bcm_ipmc;
   L7_BOOL             vlanVectorIsEmpty;
   L7_BOOL             ipmcEntryChanged = L7_FALSE;
+  /* PTin added: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_gport_t gport;
+  bcm_if_t encap_id;
+  #endif
 
   memset (&bcm_ipmc, 0, sizeof (bcm_ipmc));
 
   /* Check if the hw should be configured */
   if (USL_BCM_CONFIGURE_HW(USL_IPMC_ROUTE_DB_ID) == L7_TRUE)
@@ -1296,11 +1754,16 @@ int usl_bcm_ipmc_l3_port_repl_set(L7_uin
       {
         break;
       }
       if (myModid == modid)
       {
+        /* TODO: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        rv = l7_ipmc_to_bcm(ipmcEntry, bcm_unit, &bcm_ipmc);
+        #else
         rv = bcm_ipmc_get_by_index(bcm_unit, ipmcEntry->ipmc_index, &bcm_ipmc);
+        #endif
         if (L7_BCMX_OK(rv) != L7_TRUE)
         {
           break;
         }
 
@@ -1310,10 +1773,37 @@ int usl_bcm_ipmc_l3_port_repl_set(L7_uin
           break;
         }
 
         vlanVectorIsEmpty = usl_db_ipmc_vlan_vector_is_empty(vlanVector);
         ipmcEntryChanged = L7_FALSE;
+
+        /* TODO: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        /* Get gport */
+        rv = bcm_port_gport_get(bcm_unit, bcmPort, &gport);
+        if (rv != BCM_E_NONE)
+          break;
+        /* Get encap id */
+        rv = bcm_multicast_l3_encap_get(bcm_unit, ipmcEntry->ipmc_index, gport, ipmcEntry->vid, &encap_id);
+        if (rv != BCM_E_NONE)
+          break;
+
+        if ((vlanVectorIsEmpty == L7_TRUE) && (BCM_PBMP_MEMBER(ipmcEntry->l3_pbmp[modid], bcmPort)))
+        {
+          /* Remove egress port */
+          rv = bcm_multicast_egress_delete(bcm_unit, ipmcEntry->ipmc_index, gport, encap_id);
+          if (rv != BCM_E_NONE && rv != BCM_E_EXISTS)
+            break;
+        }
+        else if ((vlanVectorIsEmpty == L7_FALSE) && (!BCM_PBMP_MEMBER(ipmcEntry->l3_pbmp[modid], bcmPort)))
+        {
+          /* Add egress port */
+          rv = bcm_multicast_egress_add(bcm_unit, ipmcEntry->ipmc_index, gport, encap_id);
+          if (rv != BCM_E_NONE && rv != BCM_E_EXISTS)
+            break;
+        }
+        #else
         if ((vlanVectorIsEmpty == L7_TRUE) && (BCM_PBMP_MEMBER(bcm_ipmc.l3_pbmp, bcmPort)))
         {
           /* Remove the port. */
           BCM_PBMP_PORT_REMOVE(bcm_ipmc.l3_pbmp, bcmPort);
           ipmcEntryChanged = L7_TRUE;
@@ -1336,16 +1826,26 @@ int usl_bcm_ipmc_l3_port_repl_set(L7_uin
           if (L7_BCMX_OK(rv) != L7_TRUE)
           {
             break;
           }
         }
+        #endif
 
+        /* TODO: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        rv = bcm_multicast_repl_set(bcm_unit, ipmcEntry->ipmc_index, bcmPort, vlanVector);
+        if (L7_BCMX_OK(rv) != L7_TRUE)
+        {
+          break;
+        }
+        #else
         rv = bcm_ipmc_repl_set(bcm_unit, ipmcEntry->ipmc_index, bcmPort, vlanVector);
         if (L7_BCMX_OK(rv) != L7_TRUE)
         {
           break;
         }
+        #endif
       }
     }
   }
 
   /* Update the USL Db */
diff -rpN --unified=5 esw_original/usl/ipmcast/l7_usl_bcmx_ipmcast.c esw/usl/ipmcast/l7_usl_bcmx_ipmcast.c
--- esw_original/usl/ipmcast/l7_usl_bcmx_ipmcast.c	2013-03-08 12:34:35.624943086 +0000
+++ esw/usl/ipmcast/l7_usl_bcmx_ipmcast.c	2013-07-22 20:30:27.776590692 +0100
@@ -18,10 +18,11 @@
 * @end
 *
 **********************************************************************/
 
 #include "l7_common.h"
+#include "ptin_globaldefs.h"
 
 #ifdef L7_MCAST_PACKAGE
 
 #include "l7_usl_bcmx_ipmcast.h"
 #include "l7_usl_ipmcast_db.h"
@@ -116,17 +117,31 @@ void usl_ipmc_bcmx_resume(void)
 *
 * @end
 *********************************************************************/
 int usl_bcmx_ipmc_add(usl_bcm_ipmc_addr_t *data)
 {
-  int     rv, index = USL_BCM_IPMC_INVALID_INDEX;
+  int     rv;
+  int     index = USL_BCM_IPMC_INVALID_INDEX;
   int     hwRv = BCM_E_NONE, dbRv = BCM_E_NONE;
 
   USL_IPMC_BCMX_LOCK_TAKE();
 
   do
   {
+    /* TODO: SDK 6.3.0 */
+    #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+    if ((data->flags & BCM_MULTICAST_WITH_ID) == L7_FALSE)
+    {
+      hwRv = usl_ipmc_hw_id_allocate(data, &index);
+      if (hwRv != BCM_E_NONE)
+      {
+        break;        
+      }
+      data->ipmc_index = index;
+      data->flags &= ~((uint32) BCM_MULTICAST_WITH_ID);
+    }
+    #else
     /* Allocate hw index if not assigned by HAPI */
     if ((data->flags & BCM_IPMC_USE_IPMC_INDEX) == L7_FALSE)
     {
       hwRv = usl_ipmc_hw_id_allocate(data, &index);
       if (hwRv != BCM_E_NONE)
@@ -135,10 +150,11 @@ int usl_bcmx_ipmc_add(usl_bcm_ipmc_addr_
       }
       
       data->ipmc_index = index;
       data->flags |= BCM_IPMC_USE_IPMC_INDEX;
     }
+    #endif
 
     /* Check if the hardware should be configured */
     if (USL_BCMX_CONFIGURE_HW(USL_IPMC_ROUTE_DB_ID) == L7_TRUE)
     {
       hwRv = l7_rpc_client_ipmc_add(data, 0, L7_NULL);
diff -rpN --unified=5 esw_original/usl/policy/l7_rpc_policy.c esw/usl/policy/l7_rpc_policy.c
--- esw_original/usl/policy/l7_rpc_policy.c	2013-03-08 12:34:35.592942226 +0000
+++ esw/usl/policy/l7_rpc_policy.c	2013-07-22 20:39:45.091554031 +0100
@@ -35,10 +35,12 @@
 #include "bcmx/types.h"
 #include "bcmx/bcmx_int.h"
 #include "ibde.h"
 #include "zlib.h"
 
+#include "ptin_globaldefs.h"  /* PTin added: SDK 6.3.0 */
+
 #define L7_RPC_POLICY_HANDLER HPC_RPC_FUNCTION_ID(L7_DRIVER_COMPONENT_ID,99)
 
 static BROAD_POLICY_CUSTOM_DATA_t *rpc_policy_data;
 static L7_uint32 rpc_policy_rule_count;
 static L7_BOOL rpc_debug = L7_FALSE;
@@ -760,11 +762,16 @@ int l7_rpc_client_policy_port_apply(BROA
   pData->policyFlags = BROAD_POLICY_FIRST | BROAD_POLICY_LAST;
   pData->policyId    = policyId;
 
   RPC_DEBUG_PRINT("l7_rpc_client_policy_port_apply: Policy-%d sending BROAD_CUSTOM_POLICY_APPLY port 0x%x\r\n", policyId, port);
 
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_POLICY_SET_HANDLER, sizeof(BROAD_POLICY_CUSTOM_DATA_t)/sizeof(L7_uint32), args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_POLICY_SET_HANDLER, args);
+  #endif
   if (L7_BCMX_OK(rv) == L7_TRUE)
     rv = BCM_E_NONE;
 
   return rv;
 }
@@ -791,11 +798,16 @@ int l7_rpc_client_policy_port_remove(BRO
   pData->policyFlags = BROAD_POLICY_FIRST | BROAD_POLICY_LAST;
   pData->policyId    = policyId;
 
   RPC_DEBUG_PRINT("l7_rpc_client_policy_port_remove: Policy-%d sending BROAD_CUSTOM_POLICY_REMOVE port 0x%x\r\n", policyId, port);
 
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_POLICY_SET_HANDLER, sizeof(BROAD_POLICY_CUSTOM_DATA_t)/sizeof(L7_uint32), args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_POLICY_SET_HANDLER, args);
+  #endif
   if (L7_BCMX_OK(rv) == L7_TRUE)
     rv = BCM_E_NONE;
 
   return rv;
 }
diff -rpN --unified=5 esw_original/usl/port/l7_rpc_port.c esw/usl/port/l7_rpc_port.c
--- esw_original/usl/port/l7_rpc_port.c	2013-03-08 12:34:35.648943317 +0000
+++ esw/usl/port/l7_rpc_port.c	2013-07-22 20:12:46.347580411 +0100
@@ -27,11 +27,13 @@
 #include "sal/core/libc.h"
 #include "bcmx/custom.h"
 #include "bcm/custom.h"
 #include "bcm/l2.h"
 #include "bcm/link.h"
- 
+
+#include "ptin_globaldefs.h"
+
 extern int l7_rpc_server_mcast_port_update_groups(int unit, bcm_port_t port, 
                                            int setget, uint32 *args);
 
 /*********************************************************************
 *
@@ -51,19 +53,28 @@ extern int l7_rpc_server_mcast_port_upda
 int l7_rpc_client_rate_bcast_set(bcmx_lport_t port, 
                                  usl_bcm_port_rate_limit_t bcast_limit)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(bcast_limit) > sizeof(args))
   {
     LOG_ERROR(sizeof(bcast_limit));
   }
 
   memcpy(args, &bcast_limit, sizeof(bcast_limit));
 
+  n_args = sizeof(bcast_limit)/sizeof(uint32);
+  if (sizeof(bcast_limit)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_BCAST_RATE_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_BCAST_RATE_SET, args);
+  #endif
 
   return rv;
 }
 
 /*********************************************************************
@@ -120,19 +131,28 @@ int l7_rpc_server_rate_bcast_set (int un
 int l7_rpc_client_rate_mcast_set(bcmx_lport_t port, 
                                  usl_bcm_port_rate_limit_t mcast_limit)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(mcast_limit) > sizeof(args))
   {
     LOG_ERROR(sizeof(mcast_limit));
   }
 
   memcpy(args, &mcast_limit, sizeof(mcast_limit));
 
+  n_args = sizeof(mcast_limit)/sizeof(uint32);
+  if (sizeof(mcast_limit)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_MCAST_RATE_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_MCAST_RATE_SET, args);
+  #endif
 
   return rv;
 }
 
 
@@ -190,19 +210,28 @@ int l7_rpc_server_rate_mcast_set (int un
 int l7_rpc_client_rate_dlfbc_set(bcmx_lport_t port, 
                                  usl_bcm_port_rate_limit_t dlf_limit)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(dlf_limit) > sizeof(args))
   {
     LOG_ERROR(sizeof(dlf_limit));
   }
 
   memcpy(args, &dlf_limit, sizeof(dlf_limit));
 
+  n_args = sizeof(dlf_limit)/sizeof(uint32);
+  if (sizeof(dlf_limit)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_DLF_RATE_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_DLF_RATE_SET, args);
+  #endif
 
   return rv;
 }
 
 
@@ -259,19 +288,28 @@ int l7_rpc_server_rate_dlfbc_set (int un
 int l7_rpc_client_port_vlan_member_set(bcmx_lport_t port, 
                                        usl_bcm_port_filter_mode_t mode)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(mode) > sizeof(args))
   {
     LOG_ERROR(sizeof(mode));
   }
 
   memcpy(args, &mode, sizeof(mode));
 
+  n_args = sizeof(mode)/sizeof(uint32);
+  if (sizeof(mode)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_FILTER_MODE_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_FILTER_MODE_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -328,19 +366,28 @@ int l7_rpc_server_port_vlan_member_set (
 int l7_rpc_client_port_untagged_priority_set(bcmx_lport_t port, 
                                              usl_bcm_port_priority_t priority)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(priority) > sizeof(args))
   {
     LOG_ERROR(sizeof(priority));
   }
 
   memcpy(args, &priority, sizeof(priority));
 
+  n_args = sizeof(priority)/sizeof(uint32);
+  if (sizeof(priority)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PRIORITY_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PRIORITY_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -398,19 +445,28 @@ int l7_rpc_server_port_untagged_priority
 int l7_rpc_client_port_frame_max_set(bcmx_lport_t port, 
                                      usl_bcm_port_frame_size_t max_frame_size)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(max_frame_size) > sizeof(args))
   {
     LOG_ERROR(sizeof(max_frame_size));
   }
 
   memcpy(args, &max_frame_size, sizeof(max_frame_size));
 
+  n_args = sizeof(max_frame_size)/sizeof(uint32);
+  if (sizeof(max_frame_size)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_MAX_FRAME_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_MAX_FRAME_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -468,19 +524,28 @@ int l7_rpc_server_port_frame_max_set(int
 int l7_rpc_client_port_learn_set(bcmx_lport_t port, 
                                  usl_bcm_port_learn_mode_t learn_mode)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(learn_mode) > sizeof(args))
   {
     LOG_ERROR(sizeof(learn_mode));
   }
 
   memcpy(args, &learn_mode, sizeof(learn_mode));
 
+  n_args = sizeof(learn_mode)/sizeof(uint32);
+  if (sizeof(learn_mode)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_LEARN_MODE_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_LEARN_MODE_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -538,19 +603,28 @@ int l7_rpc_server_port_learn_set(int uni
 int l7_rpc_client_dtag_mode_set(bcmx_lport_t port, 
                                 usl_bcm_port_dtag_mode_t dtag_mode)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(dtag_mode) > sizeof(args))
   {
     LOG_ERROR(sizeof(dtag_mode));
   }
 
   memcpy(args, &dtag_mode, sizeof(dtag_mode));
 
+  n_args = sizeof(dtag_mode)/sizeof(uint32);
+  if (sizeof(dtag_mode)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_DTAG_MODE_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_DTAG_MODE_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -609,19 +683,28 @@ int l7_rpc_server_port_dtag_mode_set(int
 *********************************************************************/
 int l7_rpc_client_port_tpid_set(bcmx_lport_t port, usl_bcm_port_tpid_t tpid)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(tpid) > sizeof(args))
   {
     LOG_ERROR(sizeof(tpid));
   }
 
   memcpy(args, &tpid, sizeof(tpid));
 
+  n_args = sizeof(tpid)/sizeof(uint32);
+  if (sizeof(tpid)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_TPID_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_TPID_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -641,19 +724,28 @@ int l7_rpc_client_port_tpid_set(bcmx_lpo
 *********************************************************************/
 int l7_rpc_client_port_tpid_add(bcmx_lport_t port, usl_bcm_port_tpid_t tpid)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(tpid) > sizeof(args))
   {
     LOG_ERROR(sizeof(tpid));
   }
 
   memcpy(args, &tpid, sizeof(tpid));
 
+  n_args = sizeof(tpid)/sizeof(uint32);
+  if (sizeof(tpid)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_TPID_ADD, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_TPID_ADD, args);
+  #endif
 
   return rv;
 
 }
 
@@ -673,19 +765,28 @@ int l7_rpc_client_port_tpid_add(bcmx_lpo
 *********************************************************************/
 int l7_rpc_client_port_tpid_delete(bcmx_lport_t port, usl_bcm_port_tpid_t tpid)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(tpid) > sizeof(args))
   {
     LOG_ERROR(sizeof(tpid));
   }
 
   memcpy(args, &tpid, sizeof(tpid));
 
+  n_args = sizeof(tpid)/sizeof(uint32);
+  if (sizeof(tpid)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_TPID_DELETE, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_TPID_DELETE, args);
+  #endif
 
   return rv;
 
 }
 
@@ -814,19 +915,28 @@ int l7_rpc_server_port_tpid_delete(int u
 *********************************************************************/
 int l7_rpc_client_port_untagged_vlan_set(bcmx_lport_t port, bcm_vlan_t vid)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(vid) > sizeof(args))
   {
     LOG_ERROR(sizeof(vid));
   }
 
   memcpy(args, &vid, sizeof(vid));
 
+  n_args = sizeof(vid)/sizeof(uint32);
+  if (sizeof(vid)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PVID_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PVID_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -884,19 +994,28 @@ int l7_rpc_server_port_untagged_vlan_set
 *********************************************************************/
 int l7_rpc_client_port_discard_set(bcmx_lport_t port, bcm_port_discard_t mode)
 {
   int     rv = BCM_E_NONE;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(mode) > sizeof(args))
   {
     LOG_ERROR(sizeof(mode));
   }
 
   memcpy(args, &mode, sizeof(mode));
 
+  n_args = sizeof(mode)/sizeof(uint32);
+  if (sizeof(mode)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_DISCARD_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_DISCARD_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -958,10 +1077,11 @@ int l7_rpc_client_port_medium_config_set
                                          bcm_phy_config_t  *config)
 {
   int        rv = BCM_E_NONE;
   uint32     args[BCM_CUSTOM_ARGS_MAX];
   L7_uchar8 *argPtr;
+  uint32     n_args;
 
   if ((sizeof(medium) + sizeof(*config)) > sizeof(args))
   {
     LOG_ERROR(sizeof(medium) + sizeof(*config));
   }
@@ -972,11 +1092,20 @@ int l7_rpc_client_port_medium_config_set
   argPtr += sizeof(medium);
 
   memcpy(argPtr, config, sizeof(*config));
   argPtr += sizeof(*config);
 
+
+  n_args = (sizeof(medium)+sizeof(*config))/sizeof(uint32);
+  if ((sizeof(medium)+sizeof(*config))%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PHY_CONFIG_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PHY_CONFIG_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -1044,19 +1173,28 @@ int l7_rpc_server_port_medium_config_set
 int l7_rpc_client_port_flow_control_set(bcmx_lport_t port, 
                                         usl_bcm_port_pause_config_t pauseConfig)
 {
   int        rv = BCM_E_NONE;
   uint32     args[BCM_CUSTOM_ARGS_MAX];
+  uint32     n_args;
 
   if (sizeof(pauseConfig) > sizeof(args))
   {
     LOG_ERROR(sizeof(pauseConfig));
   }
 
   memcpy(args, &pauseConfig, sizeof(pauseConfig));
 
+  n_args = sizeof(pauseConfig)/sizeof(uint32);
+  if (sizeof(pauseConfig)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_FLOW_CONTROL_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_FLOW_CONTROL_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -1115,19 +1253,28 @@ int l7_rpc_server_port_flow_control_set(
 int l7_rpc_client_port_cosq_sched_set(bcmx_lport_t port, 
                                       usl_bcm_port_cosq_sched_config_t cosqSchedConfig)
 {
   int        rv = BCM_E_NONE;
   uint32     args[BCM_CUSTOM_ARGS_MAX];
+  uint32     n_args;
 
   if (sizeof(cosqSchedConfig) > sizeof(args))
   {
     LOG_ERROR(sizeof(cosqSchedConfig));
   }
 
   memcpy(args, &cosqSchedConfig, sizeof(cosqSchedConfig));
 
+  n_args = sizeof(cosqSchedConfig)/sizeof(uint32);
+  if (sizeof(cosqSchedConfig)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_COSQ_SCHED_CONFIG_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_COSQ_SCHED_CONFIG_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -1185,19 +1332,28 @@ int l7_rpc_server_port_cosq_sched_set(in
 int l7_rpc_client_port_rate_egress_set(bcmx_lport_t port, 
                                        usl_bcm_port_shaper_config_t shaperConfig)
 {
   int        rv = BCM_E_NONE;
   uint32     args[BCM_CUSTOM_ARGS_MAX];
+  uint32     n_args;
 
   if (sizeof(shaperConfig) > sizeof(args))
   {
     LOG_ERROR(sizeof(shaperConfig));
   }
 
   memcpy(args, &shaperConfig, sizeof(shaperConfig));
 
+  n_args = sizeof(shaperConfig)/sizeof(uint32);
+  if (sizeof(shaperConfig)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_SHAPER_CONFIG_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_SHAPER_CONFIG_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -1260,10 +1416,11 @@ int l7_rpc_client_port_vlan_config(bcmx_
                                    L7_BOOL cmd)
 {
   int        rv;
   uint32     args[BCM_CUSTOM_ARGS_MAX];
   L7_uchar8 *argPtr;
+  uint32     n_args;
 
   if ((sizeof (*vlanConfig) + sizeof(cmd)) > sizeof (args))
   {
     LOG_ERROR(sizeof (*vlanConfig) + sizeof(cmd));
   }
@@ -1274,11 +1431,20 @@ int l7_rpc_client_port_vlan_config(bcmx_
   argPtr += sizeof(cmd);
 
   memcpy (argPtr, vlanConfig, sizeof (*vlanConfig));
   argPtr += sizeof(*vlanConfig);
 
+
+  n_args = (sizeof(cmd)+sizeof(*vlanConfig))/sizeof(uint32);
+  if ((sizeof(cmd)+sizeof(*vlanConfig))%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_CONFIG_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_CONFIG_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -1345,10 +1511,11 @@ int l7_rpc_client_stg_stp_set(bcm_stg_t 
                               bcm_stg_stp_t stpState)
 {
   int        rv;
   uint32     args[BCM_CUSTOM_ARGS_MAX];
   L7_uchar8 *argPtr;
+  uint32     n_args;
 
   if ((sizeof (stg) + sizeof(stpState)) > sizeof (args))
   {
     LOG_ERROR(sizeof (stg) + sizeof(stpState));
   }
@@ -1359,11 +1526,20 @@ int l7_rpc_client_stg_stp_set(bcm_stg_t 
   argPtr += sizeof(stg);
 
   memcpy (argPtr, &stpState, sizeof (stpState));
   argPtr += sizeof(stpState);
 
+
+  n_args = (sizeof(stg)+sizeof(stpState))/sizeof(uint32);
+  if ((sizeof(stg)+sizeof(stpState))%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_STG_STATE_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_STG_STATE_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -1434,10 +1610,11 @@ int l7_rpc_client_port_protocol_vlan_con
                                             L7_BOOL cmd)
 {
   int              rv;
   uint32           args[BCM_CUSTOM_ARGS_MAX];
   L7_uchar8       *argPtr;
+  uint32           n_args;
 
   if ((sizeof (pbvlanConfig) + sizeof(cmd)) > sizeof (args))
   {
     LOG_ERROR(sizeof (pbvlanConfig) + sizeof(cmd));
   }
@@ -1448,11 +1625,20 @@ int l7_rpc_client_port_protocol_vlan_con
   argPtr += sizeof(cmd);
 
   memcpy (argPtr, &pbvlanConfig, sizeof (pbvlanConfig));
   argPtr += sizeof(pbvlanConfig);
 
+
+  n_args = (sizeof(cmd)+sizeof(pbvlanConfig))/sizeof(uint32);
+  if ((sizeof(cmd)+sizeof(pbvlanConfig))%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PBVLAN_CONFIG_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PBVLAN_CONFIG_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -1517,19 +1703,28 @@ int l7_rpc_server_port_protocol_vlan_con
 int l7_rpc_client_port_dot1x_config(bcmx_lport_t port,
                                     L7_DOT1X_PORT_STATUS_t dot1xStatus)
 {
   int              rv;
   uint32           args[BCM_CUSTOM_ARGS_MAX];
+  uint32           n_args;
 
   if (sizeof(dot1xStatus) > sizeof (args))
   {
     LOG_ERROR(sizeof(dot1xStatus));
   }
 
   memcpy (args, &dot1xStatus, sizeof (dot1xStatus));
 
+  n_args = sizeof(dot1xStatus)/sizeof(uint32);
+  if (sizeof(dot1xStatus)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_DOT1X_CONFIG_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_DOT1X_CONFIG_SET, args);
+  #endif
 
   return rv;
 
 }
 
@@ -1594,11 +1789,18 @@ l7_rpc_client_port_sfp_diag_get(bcmx_lpo
                                 uint32 *los)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
 
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  L7_int len;
+  rv = bcmx_custom_port_get(port, USL_BCMX_PORT_SFP_DIAG_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  #else
   rv = bcmx_custom_port_get(port, USL_BCMX_PORT_SFP_DIAG_GET, args);
+  #endif
+
   if (rv >= 0) {
     *temperature = args[0];
     *voltage     = args[1];
     *current     = args[2];
     *txPower     = args[3];
@@ -1627,11 +1829,18 @@ int
 l7_rpc_client_port_copper_diag_get(bcmx_lport_t port, bcm_port_cable_diag_t *cd)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
 
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  L7_int len;
+  rv = bcmx_custom_port_get(port, USL_BCMX_PORT_COPPER_DIAG_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  #else
   rv = bcmx_custom_port_get(port, USL_BCMX_PORT_COPPER_DIAG_GET, args);
+  #endif
+
   if (rv >= 0) 
   {
     memcpy(cd, args, sizeof(bcm_port_cable_diag_t));
   }
   return rv;
@@ -1816,18 +2025,29 @@ int
 l7_rpc_client_port_dot1x_client_block(bcmx_lport_t port,
                                       usl_bcm_port_dot1x_client_t *client_cmd)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(usl_bcm_port_dot1x_client_t) > sizeof(args)) 
   {
       LOG_ERROR(sizeof(usl_bcm_port_dot1x_client_t));
   }
 
   memcpy (args, client_cmd, sizeof (usl_bcm_port_dot1x_client_t));
+
+  n_args = sizeof(usl_bcm_port_dot1x_client_t)/sizeof(uint32);
+  if (sizeof(usl_bcm_port_dot1x_client_t)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_DOT1X_CLIENT_BLOCK, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_DOT1X_CLIENT_BLOCK, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -1847,18 +2067,29 @@ int
 l7_rpc_client_port_dot1x_client_unblock(bcmx_lport_t port,
                                         usl_bcm_port_dot1x_client_t *client_cmd)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(usl_bcm_port_dot1x_client_t) > sizeof(args)) 
   {
       LOG_ERROR(sizeof(usl_bcm_port_dot1x_client_t));
   }
 
   memcpy (args, client_cmd, sizeof (usl_bcm_port_dot1x_client_t));
+
+  n_args = sizeof(usl_bcm_port_dot1x_client_t)/sizeof(uint32);
+  if (sizeof(usl_bcm_port_dot1x_client_t)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_DOT1X_CLIENT_UNBLOCK, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_DOT1X_CLIENT_UNBLOCK, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -1950,11 +2181,19 @@ l7_rpc_client_port_dot1x_client_timeout_
   {
     LOG_ERROR(sizeof(usl_bcm_port_dot1x_client_t));
   }
 
   memcpy (args, client_cmd, sizeof (usl_bcm_port_dot1x_client_t));
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  L7_int len;
+  rv = bcmx_custom_port_get(port, USL_BCMX_DOT1X_CLIENT_TIMEOUT_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  #else
   rv = bcmx_custom_port_get(port, USL_BCMX_DOT1X_CLIENT_TIMEOUT_GET, args);
+  #endif
+
   if (rv >= 0) 
   {
     pReturnClient = (usl_bcm_port_dot1x_client_t *) args;
     client_cmd->timedout_flg = pReturnClient->timedout_flg;
     
@@ -2028,12 +2267,19 @@ int l7_rpc_server_port_dot1x_client_time
 int
 l7_rpc_client_stat_get(bcmx_lport_t port, uint64 stats[snmpValCount])
 {
   int     rv, argi, s;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
- 
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  L7_int len;
+  rv = bcmx_custom_port_get(port, USL_BCMX_STATS_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  #else
   rv = bcmx_custom_port_get(port, USL_BCMX_STATS_GET, args);
+  #endif
+
   if (rv >= 0) 
   {
     argi = 0;
     for (s = 0; s < snmpValCount; s++) 
     {
@@ -2063,11 +2309,18 @@ int
 l7_rpc_client_port_stat_get(bcmx_lport_t port, uint64 stats[snmpValCount])
 {
   int     rv, argi, s;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
  
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  L7_int len;
+  rv = bcmx_custom_port_get(port, USL_BCMX_PORT_STATS_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  #else
   rv = bcmx_custom_port_get(port, USL_BCMX_PORT_STATS_GET, args);
+  #endif
+
   if (rv >= 0) 
   {
     argi = 0;
     for (s = 0; s < snmpValCount; s++) 
     {
@@ -2201,18 +2454,29 @@ static int l7_rpc_server_port_stat_get(i
 int l7_rpc_client_port_mirror_set(bcmx_lport_t port, 
                                   usl_bcm_port_mirror_config_t mirrorConfig)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(mirrorConfig) > sizeof(args)) 
   {
       LOG_ERROR(sizeof(mirrorConfig));
   }
 
   memcpy (args, &mirrorConfig, sizeof (mirrorConfig));
+
+  n_args = sizeof(mirrorConfig)/sizeof(uint32);
+  if (sizeof(mirrorConfig)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_MIRROR_CONFIG_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_MIRROR_CONFIG_SET, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -2310,18 +2574,29 @@ int l7_rpc_server_ports_admin_mode_set(i
 int l7_rpc_client_port_enable_set(bcmx_lport_t port, 
                                   int enable)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(enable) > sizeof(args)) 
   {
       LOG_ERROR(sizeof(enable));
   }
 
   memcpy (args, &enable, sizeof (enable));
+
+  n_args = sizeof(enable)/sizeof(uint32);
+  if (sizeof(enable)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_ADMIN_MODE_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_ADMIN_MODE_SET, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -2378,18 +2653,29 @@ int l7_rpc_server_port_enable_set(int un
 int l7_rpc_client_port_wred_set(bcmx_lport_t port, 
                                 usl_bcm_port_wred_config_t *wredParams)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(*wredParams) > sizeof(args)) 
   {
       LOG_ERROR(sizeof(*wredParams));
   }
 
   memcpy (args, wredParams, sizeof (*wredParams));
+
+  n_args = sizeof(*wredParams)/sizeof(uint32);
+  if (sizeof(*wredParams)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_WRED_CONFIG_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_WRED_CONFIG_SET, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -2446,18 +2732,29 @@ int l7_rpc_server_port_wred_set(int unit
 int l7_rpc_client_port_sflow_config_set(bcmx_lport_t port, 
                                         usl_bcm_port_sflow_config_t *sflowConfig)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(*sflowConfig) > sizeof(args)) 
   {
       LOG_ERROR(sizeof(*sflowConfig));
   }
 
   memcpy (args, sflowConfig, sizeof (*sflowConfig));
+
+  n_args = sizeof(*sflowConfig)/sizeof(uint32);
+  if (sizeof(*sflowConfig)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_SFLOW_CONFIG_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_SFLOW_CONFIG_SET, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -2512,13 +2809,24 @@ int l7_rpc_server_port_sflow_config_set(
 *********************************************************************/
 int l7_rpc_client_port_vlan_translate_ingress_enable_set(bcmx_lport_t port, L7_BOOL enable)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   memcpy (args, &enable, sizeof (enable));
+
+  n_args = sizeof(enable)/sizeof(uint32);
+  if (sizeof(enable)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_INGRESS_ENABLE_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_INGRESS_ENABLE_SET, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -2573,13 +2881,24 @@ int l7_rpc_server_port_vlan_translate_in
 *********************************************************************/
 int l7_rpc_client_port_vlan_translate_ingress_miss_drop_set(bcmx_lport_t port, L7_BOOL drop)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   memcpy (args, &drop, sizeof (drop));
+
+  n_args = sizeof(drop)/sizeof(uint32);
+  if (sizeof(drop)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_INGRESS_MISS_DROP_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_INGRESS_MISS_DROP_SET, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -2634,13 +2953,24 @@ int l7_rpc_server_port_vlan_translate_in
 *********************************************************************/
 int l7_rpc_client_port_vlan_translate_egress_enable_set(bcmx_lport_t port, L7_BOOL enable)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   memcpy (args, &enable, sizeof (enable));
+
+  n_args = sizeof(enable)/sizeof(uint32);
+  if (sizeof(enable)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_EGRESS_ENABLE_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_EGRESS_ENABLE_SET, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -2695,13 +3025,24 @@ int l7_rpc_server_port_vlan_translate_eg
 *********************************************************************/
 int l7_rpc_client_port_vlan_translate_egress_miss_drop_set(bcmx_lport_t port, L7_BOOL drop)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   memcpy (args, &drop, sizeof (drop));
+
+  n_args = sizeof(drop)/sizeof(uint32);
+  if (sizeof(drop)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_EGRESS_MISS_DROP_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_EGRESS_MISS_DROP_SET, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -2756,13 +3097,24 @@ int l7_rpc_server_port_vlan_translate_eg
 *********************************************************************/
 int l7_rpc_client_port_vlan_translate_key_first_set(bcmx_lport_t port, bcm_vlan_translate_key_t key)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   memcpy (args, &key, sizeof (key));
+
+  n_args = sizeof(key)/sizeof(uint32);
+  if (sizeof(key)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_KEY_FIRST_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_KEY_FIRST_SET, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -2817,13 +3169,24 @@ int l7_rpc_server_port_vlan_translate_ke
 *********************************************************************/
 int l7_rpc_client_port_vlan_translate_key_second_set(bcmx_lport_t port, bcm_vlan_translate_key_t key)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   memcpy (args, &key, sizeof (key));
+
+  n_args = sizeof(key)/sizeof(uint32);
+  if (sizeof(key)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_KEY_SECOND_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_VLAN_XLATE_KEY_SECOND_SET, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -2878,18 +3241,29 @@ int l7_rpc_server_port_vlan_translate_ke
 int l7_rpc_client_port_pfc_config_set(bcmx_lport_t port, 
                                       usl_bcm_port_pfc_config_t pfcConfig)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
 
   if (sizeof(pfcConfig) > sizeof(args)) 
   {
       LOG_ERROR(sizeof(pfcConfig));
   }
 
   memcpy (args, &pfcConfig, sizeof (pfcConfig));
+
+  n_args = sizeof(pfcConfig)/sizeof(uint32);
+  if (sizeof(pfcConfig)%sizeof(uint32) != 0)  n_args++;
+
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PFC_CONFIG_SET, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PFC_CONFIG_SET, args);
+  #endif
+
   return rv;
 }
 
 /*********************************************************************
 *
@@ -2956,11 +3330,17 @@ int l7_rpc_client_port_pfc_stat_get(bcmx
           sizeof(*stat),sizeof(args));
     return BCM_E_INTERNAL;
   }
 
   memcpy (args, stat, sizeof (*stat));
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  L7_int len;
+  rv = bcmx_custom_port_get(port, USL_BCMX_PORT_PFC_STAT_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  #else
   rv = bcmx_custom_port_get(port, USL_BCMX_PORT_PFC_STAT_GET, args);
+  #endif
 
   if (BCM_E_NONE == rv)
   {
       ret_stat = (usl_bcm_port_pfc_stat_t *)args;
       stat->ctr = ret_stat->ctr;
@@ -3015,12 +3395,31 @@ int l7_rpc_server_port_pfc_stat_get(int 
 *********************************************************************/
 int l7_rpc_client_port_pfc_stats_clear(bcmx_lport_t port)
 {
   int     rv;
   uint32  args[BCM_CUSTOM_ARGS_MAX];
+  uint32  n_args;
+
+  /* PTin added: bug? */
+  #if 1
+  if (sizeof(port) > sizeof(args)) 
+  {
+      LOG_ERROR(sizeof(port));
+  }
+
+  memcpy (args, &port, sizeof (port));
+  #endif
+
+  n_args = sizeof(port)/sizeof(uint32);
+  if (sizeof(port)%sizeof(uint32) != 0)  n_args++;
 
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PFC_STATS_CLEAR, n_args, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_PFC_STATS_CLEAR, args);
+  #endif
 
   return rv;
 }
 
 /*********************************************************************
diff -rpN --unified=5 esw_original/usl/port/l7_usl_bcmx_port.h esw/usl/port/l7_usl_bcmx_port.h
--- esw_original/usl/port/l7_usl_bcmx_port.h	2013-03-08 12:34:35.648943317 +0000
+++ esw/usl/port/l7_usl_bcmx_port.h	2013-07-22 20:15:37.539548241 +0100
@@ -27,10 +27,11 @@
 
 #include "l7_common.h"
 #include "broad_common.h"
 #include "l7_usl_bcm_port.h"
 
+#include "ptin_globaldefs.h"  /* PTin added: SDK 6.3.0 */
 
 /*********************************************************************
 *
 * @purpose Dispatch function to handle custom BCMX port requests.
 *
@@ -42,13 +43,18 @@
 *
 *
 * @end
 *
 *********************************************************************/
+/* PTin modified: SDK 6.3.0 */
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+int custom_bcmx_port_handler(int unit, bcm_port_t port, int setget, int type,
+                             int length, uint32 *args, int *actual_length, void *user_data);
+#else
 int custom_bcmx_port_handler(int unit, bcm_port_t port, int setget, int type,
                              uint32 *args);
-
+#endif
 
 /*********************************************************************
 *
 * @purpose Set the broadcast rate threshold for a port
 *
diff -rpN --unified=5 esw_original/usl/routing/l7_usl_bcm_l3.c esw/usl/routing/l7_usl_bcm_l3.c
--- esw_original/usl/routing/l7_usl_bcm_l3.c	2013-07-19 01:37:52.995585151 +0100
+++ esw/usl/routing/l7_usl_bcm_l3.c	2013-07-22 20:30:27.780547161 +0100
@@ -30,10 +30,16 @@
 #include "broad_common.h"
 #include "l7_usl_sm.h"
 #include "l7_usl_bcm_l3.h"
 #include "l7_usl_l3_db.h"
 
+/* PTin added: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+#include "logger.h"
+#endif
+
 L7_BOOL uslDebugL3Enable = L7_FALSE;
 void uslDebugL3EnableSet(L7_BOOL flag)
 {
   uslDebugL3Enable = flag;
 }
@@ -507,10 +513,20 @@ int usl_bcm_l3_egress_create (L7_uint32 
     for (i = 0; i < bde->num_devices(BDE_SWITCH_DEVICES); i++)
     {
       if (!SOC_IS_XGS_FABRIC(i))
       {
         rv = bcm_l3_egress_create (i, flags, &(egr->bcm_data), egrId);
+
+        /* PTin added: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        if (rv == BCM_E_UNAVAIL)
+        {
+          LOG_WARNING(LOG_CTX_PTIN_HAPI,"bcm_l3_egress_create is not supported in this version... ignoring!");
+          rv = BCM_E_INIT;
+        }
+        #endif
+
         if (L7_BCMX_OK(rv) != L7_TRUE)
         {
           break;
         }
       }
diff -rpN --unified=5 esw_original/usl/stacking_binds/l7_usl_l2_fdb.c esw/usl/stacking_binds/l7_usl_l2_fdb.c
--- esw_original/usl/stacking_binds/l7_usl_l2_fdb.c	2013-03-08 12:34:35.636942152 +0000
+++ esw/usl/stacking_binds/l7_usl_l2_fdb.c	2013-07-22 20:24:37.868547135 +0100
@@ -28,11 +28,17 @@
 #include "bcmx/l2.h"
 #include "bcmx/mcast.h"
 #include "bcmx/vlan.h"
 #include "bcmx/stg.h"
 #include "bcm_int/esw/mbcm.h"
+/* PTin modified: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+/* No include */
+#else
 #include "bcm_int/esw/draco.h"
+#endif
 #include "ibde.h"
 #include <bcmx/bcmx_int.h>
 #include "broad_common.h"
 
 /* Local Structure used for VLAN based L2 addr flush */
diff -rpN --unified=5 esw_original/usl/switching/l7_rpc_l2_mcast.c esw/usl/switching/l7_rpc_l2_mcast.c
--- esw_original/usl/switching/l7_rpc_l2_mcast.c	2013-03-08 12:34:35.612942796 +0000
+++ esw/usl/switching/l7_rpc_l2_mcast.c	2013-07-22 20:30:27.780547161 +0100
@@ -29,10 +29,12 @@
 #include "bcmx/custom.h"
 
 #include "l7_rpc_l2_mcast.h"
 #include "l7_usl_bcm_port.h"
 
+#include "ptin_globaldefs.h"
+
 #define RV_REPLACE(_trv, _rv)                   \
         BCMX_RV_REPLACE_OK(_trv, _rv, BCM_E_UNAVAIL)
 
 
 /*********************************************************************
@@ -341,11 +343,16 @@ int l7_rpc_client_mcast_port_update_grou
   for (i = 0; i < l2mc_index_count; i++)
   {
     L7_UINT32_PACK(msgBuf, l2mc_index[i]);
   }
 
+  /* PTin modified: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  rv = bcmx_custom_port_set(port, USL_BCMX_PORT_MCAST_GROUPS_UPDATE, 1+l2mc_index_count, args);
+  #else
   rv = bcmx_custom_port_set(port, USL_BCMX_PORT_MCAST_GROUPS_UPDATE, args);
+  #endif
 
   return rv;
 }
 
 /*********************************************************************
diff -rpN --unified=5 esw_original/usl/switching/l7_usl_bcm_l2.c esw/usl/switching/l7_usl_bcm_l2.c
--- esw_original/usl/switching/l7_usl_bcm_l2.c	2013-03-08 12:34:35.612942796 +0000
+++ esw/usl/switching/l7_usl_bcm_l2.c	2013-07-22 20:20:03.191806931 +0100
@@ -36,10 +36,12 @@
 #include "bcm/stg.h"
 #include "soc/drv.h"
 #include "bcm_int/common/multicast.h" /* PTin modified: new SDK  (esw->common) */
 #include "broad_mmu.h"
 
+#include "ptin_globaldefs.h"
+
 /* Check whether device supports enhanced DOS controls */
 L7_BOOL usl_bcm_enhanced_doscontrol_get(void)
 { 
   static L7_BOOL dos_ctrl   = L7_FALSE;
   static L7_BOOL first_time = L7_TRUE;
@@ -550,15 +552,25 @@ int usl_bcm_trunk_create(L7_uint32 appId
     {
       if (!SOC_IS_XGS_FABRIC(i))
       {
         if (flags & USL_BCM_TRUNK_CREATE_WITH_ID)
         {
+          /* PTin modified: SDK 6.3.0 */
+          #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+          rv = bcm_trunk_create(i, BCM_TRUNK_FLAG_WITH_ID, tid);
+          #else
           rv = bcm_trunk_create_id(i, *tid);
+          #endif
         }
         else
         {
+          /* PTin modified: SDK 6.3.0 */
+          #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+          rv = bcm_trunk_create(i, 0, tid);
+          #else
           rv = bcm_trunk_create(i, tid);
+          #endif
         }
         if (L7_BCMX_OK(rv) != L7_TRUE)
           break;
       }
     }
@@ -629,18 +641,48 @@ int usl_bcm_trunk_destroy(L7_uint32 appI
 int usl_bcm_trunk_set(L7_uint32 appId, bcm_trunk_t tid, 
                       bcm_trunk_add_info_t * addInfo)
 {
   int                  i, rv = BCM_E_NONE;
 
+  /* PTin added: SDK 6.3.0 */
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_trunk_info_t trunk_info;
+  int member_count, count;
+  bcm_trunk_member_t member_array[BCM_TRUNK_MAX_PORTCNT];
+  #endif
+
   /* Check if the hw should be configured */
   if (USL_BCM_CONFIGURE_HW(USL_L2_TRUNK_DB_ID) == L7_TRUE)
   {
     for (i = 0; i < bde->num_devices(BDE_SWITCH_DEVICES); i++)
     {
       if (!SOC_IS_XGS_FABRIC(i))
       {
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        memset(&trunk_info ,0, sizeof(trunk_info));
+        memset(member_array,0, sizeof(member_array));
+        trunk_info.flags        = addInfo->flags;
+        trunk_info.psc          = addInfo->psc;
+        trunk_info.ipmc_psc     = addInfo->ipmc_psc;
+        trunk_info.dlf_index    = addInfo->dlf_index;
+        trunk_info.mc_index     = addInfo->mc_index;
+        trunk_info.ipmc_index   = addInfo->ipmc_index;
+        trunk_info.dynamic_size = addInfo->dynamic_size;
+        trunk_info.dynamic_age  = addInfo->dynamic_age;
+        trunk_info.dynamic_load_exponent          = addInfo->dynamic_load_exponent;
+        trunk_info.dynamic_expected_load_exponent = addInfo->dynamic_expected_load_exponent;
+        member_count = addInfo->num_ports;
+        for (count=0; count<member_count && count<BCM_TRUNK_MAX_PORTCNT; count++)
+        {
+          BCM_GPORT_LOCAL_SET(member_array[count].gport, addInfo->tp[count]);
+        }
+        rv = bcm_trunk_set(i, tid, &trunk_info, member_count, member_array);
+        #else
         rv = bcm_trunk_set(i, tid, addInfo); 
+        #endif
+
         if (L7_BCMX_OK(rv) != L7_TRUE)
           break;
       }
     }
   }
@@ -847,21 +889,38 @@ int usl_bcm_stg_vlan_update(L7_uint32 ap
 * @end
 *********************************************************************/
 int usl_bcm_vlan_ip4_add(usl_bcm_vlan_ipsubnet_t *ipSubnetData)
 {
   int i, rv = BCM_E_NONE;
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_vlan_ip_t vlan_ip;
+  #endif
 
   /* Check if hw should be configured */
   if (USL_BCM_CONFIGURE_HW(USL_L2_VLAN_IPSUBNET_DB_ID) == L7_TRUE)
   {
     for (i = 0; i < bde->num_devices(BDE_SWITCH_DEVICES); i++)
     {
       if (!SOC_IS_XGS_FABRIC(i))
       {
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        vlan_ip.flags = 0;    /* BCM_VLAN_SUBNET_IP6 for IPv6 */
+        vlan_ip.vid   = ipSubnetData->vlanId;
+        vlan_ip.ip4   = ipSubnetData->ipSubnet;
+        vlan_ip.mask  = ipSubnetData->netMask;
+        memset(vlan_ip.ip6, 0x00, sizeof(bcm_ip6_t));
+        vlan_ip.prefix= 0;
+        vlan_ip.prio  = ipSubnetData->prio;
+
+        rv = bcm_vlan_ip_add(i, &vlan_ip);
+
+        #else
 
         rv = bcm_vlan_ip4_add(i, ipSubnetData->ipSubnet, ipSubnetData->netMask,
                               ipSubnetData->vlanId, ipSubnetData->prio);
+        #endif
         if (L7_BCMX_OK(rv) != L7_TRUE)
           break;
       }
     }
   }
@@ -890,21 +949,38 @@ int usl_bcm_vlan_ip4_add(usl_bcm_vlan_ip
 *
 * @end
 *********************************************************************/
 int usl_bcm_vlan_ip4_delete(usl_bcm_vlan_ipsubnet_t *ipSubnetData)
 {
-  int                         rv = BCM_E_NONE, tmpRv = BCM_E_NONE;
+  int                        rv = BCM_E_NONE, tmpRv = BCM_E_NONE;
   L7_int32                   i;
+  #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+  bcm_vlan_ip_t vlan_ip;
+  #endif
 
   /* Check if hw should be configured */
   if (USL_BCM_CONFIGURE_HW(USL_L2_VLAN_IPSUBNET_DB_ID) == L7_TRUE)
   {
     for (i = 0; i < bde->num_devices(BDE_SWITCH_DEVICES); i++)
     {
       if (!SOC_IS_XGS_FABRIC(i))
       {
+        /* PTin modified: SDK 6.3.0 */
+        #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+        vlan_ip.flags = 0;    /* BCM_VLAN_SUBNET_IP6 for IPv6 */
+        vlan_ip.vid   = ipSubnetData->vlanId;
+        vlan_ip.ip4   = ipSubnetData->ipSubnet;
+        vlan_ip.mask  = ipSubnetData->netMask;
+        memset(vlan_ip.ip6, 0x00, sizeof(bcm_ip6_t));
+        vlan_ip.prefix= 0;
+        vlan_ip.prio  = ipSubnetData->prio;
+
+        rv = bcm_vlan_ip_delete(i, &vlan_ip);
+
+        #else
         tmpRv = bcm_vlan_ip4_delete(i, ipSubnetData->ipSubnet, ipSubnetData->netMask);
+        #endif
         if (L7_BCMX_OK(tmpRv) != L7_TRUE)
         {
           break;    
         }
       }
diff -rpN --unified=5 esw_original/usl/switching/l7_usl_bcm_l2.h esw/usl/switching/l7_usl_bcm_l2.h
--- esw_original/usl/switching/l7_usl_bcm_l2.h	2013-03-08 12:34:35.612942796 +0000
+++ esw/usl/switching/l7_usl_bcm_l2.h	2013-07-22 20:20:03.204064658 +0100
@@ -30,10 +30,15 @@
 
 #include "bcm/types.h"
 #include "bcm/trunk.h"
 #include "bcm/vlan.h"
 
+/* PTin added: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+#include "bcm_int/common/trunk.h"
+#endif
 
 /* Number of bytes in mask */
 #define L7_CAPWAP_INDICES   ((L7_MAX_NUM_CAPWAP_TUNNEL_INTF) / (sizeof(L7_uchar8) * 8) + 1)
 #define L7_CAPWAP_PORT_MAX_MASK_BIT   L7_MAX_NUM_CAPWAP_TUNNEL_INTF
 
diff -rpN --unified=5 esw_original/usl/switching/l7_usl_bcmx_l2.h esw/usl/switching/l7_usl_bcmx_l2.h
--- esw_original/usl/switching/l7_usl_bcmx_l2.h	2013-03-08 12:34:35.612942796 +0000
+++ esw/usl/switching/l7_usl_bcmx_l2.h	2013-07-22 20:20:03.208049774 +0100
@@ -25,10 +25,16 @@
 #include "l7_usl_bcm_l2.h"
 
 #include "bcm/vlan.h"
 #include "bcmx/l2.h"
 
+/* PTin added: SDK 6.3.0 */
+#include "ptin_globaldefs.h"
+#if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
+#include "bcm_int/common/trunk.h"
+#endif
+
 /*********************************************************************
 * @purpose  Flush dynamic MAC addresses for specified trunk.
 *
 * @param    tgid - BCMX trunk identifier.
 *
