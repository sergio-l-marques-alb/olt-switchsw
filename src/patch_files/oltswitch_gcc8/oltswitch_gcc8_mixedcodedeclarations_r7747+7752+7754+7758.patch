Index: bsp/cpu/common/linux/ipl/bootos.c
===================================================================
--- bsp/cpu/common/linux/ipl/bootos.c	(revision 7746)
+++ bsp/cpu/common/linux/ipl/bootos.c	(revision 7747)
@@ -905,22 +905,24 @@ int main(int argc, char *argv[], char *e
 
   if ((argc <= 1) || (strcmp(argv[1], "boot") != 0)) {
     sprintf (ServicePortName, "eth%d:", bspapiServicePortUnitGet());
   }
 
 #if 1
-  int res;
-  struct rlimit coreLimit;
-  coreLimit.rlim_cur = RLIM_INFINITY;
-  coreLimit.rlim_max = RLIM_INFINITY;
+  {
+    int res;
+    struct rlimit coreLimit;
+    coreLimit.rlim_cur = RLIM_INFINITY;
+    coreLimit.rlim_max = RLIM_INFINITY;
 
-  res = setrlimit(RLIMIT_CORE, (const struct rlimit*)&coreLimit);
-  PT_LOG_INFO(LOG_CTX_STARTUP,"set core limit %d", res);
+    res = setrlimit(RLIMIT_CORE, (const struct rlimit*)&coreLimit);
+    PT_LOG_INFO(LOG_CTX_STARTUP,"set core limit %d", res);
 
-  res = getrlimit(RLIMIT_CORE, &coreLimit);
-  PT_LOG_INFO(LOG_CTX_STARTUP,"core size limits : cur %d max %d", (int)coreLimit.rlim_cur, (int)coreLimit.rlim_max);
+    res = getrlimit(RLIMIT_CORE, &coreLimit);
+    PT_LOG_INFO(LOG_CTX_STARTUP,"core size limits : cur %d max %d", (int)coreLimit.rlim_cur, (int)coreLimit.rlim_max);
+  }
 #endif
 
   sigemptyset(&BlockedSigs);
 
 #ifndef PC_LINUX_HOST
   /* Set up handler for segmentation faults.
Index: andl/hapi/esw/base/base/broad_cpu_intf.c
===================================================================
--- andl/hapi/esw/base/base/broad_cpu_intf.c	(revision 7746)
+++ andl/hapi/esw/base/base/broad_cpu_intf.c	(revision 7747)
@@ -1621,22 +1621,22 @@ L7_RC_t hapiBroadSend(DAPI_USP_t *usp, D
   if ( (*(L7_ushort16 *)&bcm_pkt.pkt_data->data[4+12] != osapiHtons(hapiBroadDvlanEthertype)) &&
        (*(L7_ushort16 *)&bcm_pkt.pkt_data->data[4+12] != osapiHtons(0x8100)) &&
        (*(L7_ushort16 *)&bcm_pkt.pkt_data->data[4+12] != osapiHtons(0x88A8)) && /* PTin added: ethertypes */ 
        (*(L7_ushort16 *)&bcm_pkt.pkt_data->data[4+12] != osapiHtons(0x9100))    /* PTin added: ethertypes */
      ) /* Is this correct way ? */
   {
-    memcpy(&bcm_pkt.pkt_data->data[0], &bcm_pkt.pkt_data->data[4], 12);
+    memmove(&bcm_pkt.pkt_data->data[0], &bcm_pkt.pkt_data->data[4], 12);
     *(L7_ushort16 *)&bcm_pkt.pkt_data->data[12] = osapiHtons(hapiBroadDvlanEthertype);
     *(L7_ushort16 *)&bcm_pkt.pkt_data->data[14] = osapiHtons(BCM_VLAN_CTRL(cmdInfo->cmdData.send.priority , 0, sendVlanId));
     pkt_start_idx = 0;
     frameLength+=4;
   }
   else
   {
     /* remove the initial offset(pkt_idx:4) if the packet is already tagged.*/
-    memcpy(&bcm_pkt.pkt_data->data[0], &bcm_pkt.pkt_data->data[4], frameLength);
+    memmove(&bcm_pkt.pkt_data->data[0], &bcm_pkt.pkt_data->data[4], frameLength);
     #if defined(L7_METRO_PACKAGE) && defined(L7_DOT1AD_PACKAGE)
     {
       bcm_chip_family_t    board_family;
 
       if (hapiBroadGetSystemBoardFamily(&board_family) == L7_SUCCESS)
       {
@@ -4481,20 +4481,22 @@ L7_BOOL hapiBroadReceivePdu(L7_netBufHan
       /* allow destination MAC 01:80:C2:00:00:0E for 802.1AB */
       case 0x0E:
 
         /* check if physical port is enabled to receive LLDP packets */
         if (hapiPort->hapiModeparm.physical.acceptLLDPDU == L7_TRUE)
         {
-          if ( voiceVlanAuthDebug )
-          {
-            sysapiPrintf("%s(): acceptLLDPDU is TRUE\n",__FUNCTION__);
-          }
           /* remove VLAN tag before sending to CPU,
              LLDP is only concerned with physical ports,
              do not consider LAG membership */
           unsigned char tmp_buffer[12];
+
+          if ( voiceVlanAuthDebug )
+          {
+            sysapiPrintf("%s(): acceptLLDPDU is TRUE\n",__FUNCTION__);
+          }
+
           memcpy(tmp_buffer,user_data,12);
           memcpy(user_data+4,tmp_buffer,12);
           user_data += 4;
           user_data_size -= 4;
           sysapiNetMbufSetDataStart(frameHdl,user_data);
           sysapiNetMbufSetDataLength(frameHdl,user_data_size);
Index: andl/hapi/esw/base/base/broad_system.c
===================================================================
--- andl/hapi/esw/base/base/broad_system.c	(revision 7746)
+++ andl/hapi/esw/base/base/broad_system.c	(revision 7747)
@@ -1252,13 +1252,13 @@ L7_RC_t hapiBroadSystemFlowControl(DAPI_
 *********************************************************************/
 L7_RC_t hapiBroadInterfaceFlowControl(DAPI_USP_t *usp, DAPI_CMD_t cmd, void *data, DAPI_t *dapi_g)
 {
   L7_RC_t                              result  = L7_SUCCESS;
   BROAD_PORT_t                        *hapiPortPtr;
   int                                  rv;
-  DAPI_INTF_MGMT_CMD_t                *dapiCmd = (DAPI_INTF_MGMT_CMD_t*)data;;
+  DAPI_INTF_MGMT_CMD_t                *dapiCmd = (DAPI_INTF_MGMT_CMD_t*)data;
   int                                  mode;
   usl_bcm_port_pause_config_t         pauseCmd;
 
    
   hapiPortPtr = HAPI_PORT_GET(usp, dapi_g);
 
@@ -2864,13 +2864,13 @@ L7_RC_t hapiBroadConfigMldFilter(L7_BOOL
       }
     }
   }
   return rc;
 }
 
-L7_RC_t hapiBroadConfigIgmpFilterRaptor(enableFilter)
+L7_RC_t hapiBroadConfigIgmpFilterRaptor(int enableFilter)
 {
 
   L7_RC_t          rc = L7_SUCCESS;
 #ifdef BCM_RAPTOR_SUPPORT
   L7_int32         rv;
   int              bcm_unit;
@@ -5625,13 +5625,13 @@ int hapiBroadXgs3HigigPriorityPatch(int
      }
    }
 
    return valid_rev;
 }
 
-int hapiBroadBcmGroupRequired(unit)
+int hapiBroadBcmGroupRequired(int unit)
 {
   return hapiBroadXgs3HigigPriorityPatch(unit);
 }
 
 
 /* Used for the bcm driver to get the Stacking VLAN */
@@ -7422,15 +7422,16 @@ L7_RC_t hapiBroadIntfPfcStatsClear(DAPI_
   return rc;
 }
 
 L7_RC_t hapiBroadIntfPfcConfigTest(int unit, int slot, int port, int enable, int bitmap)
 {
   DAPI_USP_t usp;
-  usp.unit = unit; usp.slot = slot; usp.port = port;
   DAPI_INTF_MGMT_CMD_t  cmd;
 
+  usp.unit = unit; usp.slot = slot; usp.port = port;
+
   cmd.cmdData.pfcConfig.enable = enable;
   cmd.cmdData.pfcConfig.priority_bmp = bitmap;
 
   return dapiCtl(&usp,DAPI_CMD_INTF_PFC_CONFIG,&cmd);
 }
 
Index: andl/hapi/esw/base/base/broad_hpc_drv.c
===================================================================
--- andl/hapi/esw/base/base/broad_hpc_drv.c	(revision 7746)
+++ andl/hapi/esw/base/base/broad_hpc_drv.c	(revision 7747)
@@ -865,12 +865,13 @@ extern void hapiBroadXgs3Opcode0Patch(in
 *********************************************************************/
 void hpcHardwareDefaultConfigApply(void)
 {
   int i;
   int index;
   int rv;
+  bcm_pbmp_t pbmp;
   bcm_pbmp_t ubmp;
   int port;
   bcm_cos_queue_t cosq;
   bcm_cos_t       priority;
   int             rate_limit;
   int             num_queues = 0;
@@ -1041,14 +1042,12 @@ void hpcHardwareDefaultConfigApply(void)
     {
       L7_LOGF(L7_LOG_SEVERITY_CRITICAL, L7_DRIVER_COMPONENT_ID,
               "Driver failed to set the Cpu cosq hardware rate limits, error code %d\n",
               rv);  
     }
 
-
-    bcm_pbmp_t pbmp;
     BCM_PBMP_ASSIGN(pbmp, PBMP_PORT_ALL(i));
 
     BCM_PBMP_CLEAR(ubmp);
 
     rv = bcm_vlan_create(i,HPC_STACKING_VLAN_ID);
     if ((rv < 0) && (rv != BCM_E_EXISTS))
Index: andl/hapi/esw/base/base/broad_base_mmu.c
===================================================================
--- andl/hapi/esw/base/base/broad_base_mmu.c	(revision 7746)
+++ andl/hapi/esw/base/base/broad_base_mmu.c	(revision 7747)
@@ -74,13 +74,13 @@ static void *mmu_lock=L7_NULLPTR;
 L7_RC_t hapiBroadFireboltMmuConfigModify(L7_uint32 unit)
 {
   int cpu_port,t1,t2;
   soc_port_t  port;
   int treg,cos;
   int ncells;
-  int static_cells = 0;;
+  int static_cells = 0;
   int dynamic_cells = 0;
   int dyncell_e,dyncell_hg;
   int ibpcell_e;
   uint32 field_max = 0;
 
   /* calculate the static allocation */
Index: andl/hapi/esw/ptin/ptin_hapi_l2.c
===================================================================
--- andl/hapi/esw/ptin/ptin_hapi_l2.c	(revision 7746)
+++ andl/hapi/esw/ptin/ptin_hapi_l2.c	(revision 7747)
@@ -983,20 +983,20 @@ L7_RC_t ptin_hapi_maclimit_reset( mac_le
  * 
  * @return L7_RC_t : L7_SUCCESS / L7_FAILURE
  */
 L7_RC_t ptin_hapi_maclimit_fdbFlush(bcm_vlan_t vlan_id, bcm_gport_t gport, BROAD_FLUSH_TYPE_t type)
 {
   L7_uint vport_id = 0;
+  BROAD_L2ADDR_FLUSH_t  l2addr_vlan;
 
   vport_id = gport & 0xffff;
 
   macLearn_info_flow[vport_id].mac_total -= macLearn_info_flow[vport_id].mac_counter;
   macLearn_info_flow[vport_id].mac_counter = 0;
 
   /* Flush FDB */
-  BROAD_L2ADDR_FLUSH_t  l2addr_vlan;
   /* Fill in the structure */
   l2addr_vlan.bcm_gport = gport;
   l2addr_vlan.vlanID = vlan_id;
   l2addr_vlan.flushtype = type;
   l2addr_vlan.flushflags = BROAD_FLUSH_FLAGS_NONE;
   l2addr_vlan.port_is_lag = L7_FALSE;
Index: andl/hapi/esw/ptin/ptin_hapi_l3.c
===================================================================
--- andl/hapi/esw/ptin/ptin_hapi_l3.c	(revision 7746)
+++ andl/hapi/esw/ptin/ptin_hapi_l3.c	(revision 7747)
@@ -26,12 +26,31 @@ L7_RC_t ptin_hapi_l3_host_add(ptin_dapi_
     bcm_trunk_t       trunk = -1;
     bcm_mac_t         mac;
     bcm_if_t          interface = -1;
     int               l2tocpu = 0;
     int               rv = L7_SUCCESS;
 
+    bcm_l3_egress_t   egress_object;
+    int               copytocpu = 0;
+    int               drop = 0;
+    int               mpls_label = BCM_MPLS_LABEL_INVALID;
+    int               object_id = -1;
+    uint32            flags = 0;
+
+    bcm_l3_host_t   host_info;
+    int             host_as_route = 0;
+    bcm_ip_t        ip_addr = 0;
+    int             untag = 0;
+    int             hits = 0;
+    int             replace = 0;
+    int             rpe = 0;
+    int             v6  = 0;
+    int             pri = 0;
+    int             vrf = 0;
+    int             lookup_class = 0;
+    bcm_ip6_t       ip6_addr;
 
     /* Input parameters */
 
     /* Input port/trunk */
     PT_LOG_TRACE(LOG_CTX_HAPI, "dapiPort={%d,%d,%d}",
               dapiPort->usp->unit, dapiPort->usp->slot, dapiPort->usp->port);
@@ -62,22 +81,13 @@ L7_RC_t ptin_hapi_l3_host_add(ptin_dapi_
     {
       PT_LOG_ERR(LOG_CTX_HAPI,"Interface has a not valid type: error!");
       return L7_FAILURE;
     }
 
 
-
     /* _l3_cmd_egress_object_create */
-
-    bcm_l3_egress_t   egress_object;             
-    int               copytocpu = 0;
-    int               drop = 0;
-    int               mpls_label = BCM_MPLS_LABEL_INVALID;
-    int               object_id = -1;
-    uint32            flags = 0;
-
     bcm_l3_egress_t_init(&egress_object);
     sal_memset(mac, 0, sizeof(bcm_mac_t));
 
     /* DMAC */
     sal_memcpy(mac, data->dstMacAddr, sizeof(L7_uint8)*L7_MAC_ADDR_LEN);
 
@@ -122,27 +132,12 @@ L7_RC_t ptin_hapi_l3_host_add(ptin_dapi_
         PT_LOG_ERR(LOG_CTX_HAPI,"Error creating egress object entry: %s\n", bcm_errmsg(rv));
         return L7_FAILURE;
     }
 
 
     /* _l3_cmd_host_add */
-
-    bcm_l3_host_t   host_info;
-    int             host_as_route = 0;
-    bcm_ip_t        ip_addr = 0;
-    int             untag = 0;
-    int             hits = 0;
-    int             replace = 0;
-    int             rpe = 0;
-    int             v6  = 0;
-    int             pri = 0;
-    int             vrf = 0;
-    int             lookup_class = 0;
-    bcm_ip6_t       ip6_addr;
-
-
     /* Init struct */
     bcm_l3_host_t_init(&host_info);
 
     host_info.l3a_vrf     = vrf;
     host_info.l3a_pri     = pri;
     host_info.l3a_lookup_class = lookup_class;
Index: andl/hapi/esw/ptin/ptin_hapi.c
===================================================================
--- andl/hapi/esw/ptin/ptin_hapi.c	(revision 7746)
+++ andl/hapi/esw/ptin/ptin_hapi.c	(revision 7747)
@@ -2145,18 +2145,18 @@ L7_RC_t ptin_hapi_portDescriptor_get(DAP
  * @param enable: linkscan state (output) 
  * 
  * @return L7_RC_t : L7_SUCCESS / L7_FAILURE
  */
 L7_RC_t ptin_hapi_linkscan_get(DAPI_USP_t *usp, DAPI_t *dapi_g, L7_uint8 *enable)
 {
-  PT_LOG_INFO(LOG_CTX_HAPI, "Linkscan read from usp {%d,%d,%d}", usp->unit, usp->slot, usp->port);
-
   DAPI_PORT_t  *dapiPortPtr;
   BROAD_PORT_t *hapiPortPtr;
   L7_int mode;
 
+  PT_LOG_INFO(LOG_CTX_HAPI, "Linkscan read from usp {%d,%d,%d}", usp->unit, usp->slot, usp->port);
+
   /* Validate dapiPort */
   if (usp->unit<0 || usp->slot<0 || usp->port<0)
   {
     PT_LOG_ERR(LOG_CTX_HAPI, "Invalid interface");
     return L7_FAILURE;
   }
@@ -2195,14 +2195,12 @@ L7_RC_t ptin_hapi_linkscan_get(DAPI_USP_
  * @return L7_RC_t : L7_SUCCESS / L7_FAILURE
  */
 L7_RC_t ptin_hapi_linkscan_set(DAPI_USP_t *usp, DAPI_t *dapi_g, L7_uint8 enable)
 {
   /* Code regarding to forcelinks procedures is going to be removed */
 #if (SDK_VERSION_IS <= SDK_VERSION(6,5,7,0))
-  PT_LOG_DEBUG(LOG_CTX_HAPI, "Linkscan procedure to usp {%d,%d,%d}", usp->unit, usp->slot, usp->port);
-
   DAPI_PORT_t  *dapiPortPtr;
   BROAD_PORT_t *hapiPortPtr;
   L7_int ptin_port;
   L7_RC_t rc = L7_SUCCESS;
 
 #if (PTIN_BOARD == PTIN_BOARD_CXO640G || PTIN_BOARD == PTIN_BOARD_CXO160G)
@@ -2210,12 +2208,14 @@ L7_RC_t ptin_hapi_linkscan_set(DAPI_USP_
   DAPI_CARD_ENTRY_t            *dapiCardPtr;
   HAPI_WC_PORT_MAP_t           *hapiWCMapPtr;
   bcm_port_if_t                 intf_type;
   bcm_error_t                   rv;
 #endif
 
+  PT_LOG_DEBUG(LOG_CTX_HAPI, "Linkscan procedure to usp {%d,%d,%d}", usp->unit, usp->slot, usp->port);
+
   /* Validate dapiPort */
   if (usp->unit<0 || usp->slot<0 || usp->port<0)
   {
     PT_LOG_ERR(LOG_CTX_HAPI, "Invalid interface");
     return L7_FAILURE;
   }
@@ -2321,14 +2321,12 @@ L7_RC_t ptin_hapi_linkscan_set(DAPI_USP_
  * @return L7_RC_t : L7_SUCCESS / L7_FAILURE
  */
 L7_RC_t ptin_hapi_link_force(DAPI_USP_t *usp, DAPI_t *dapi_g, L7_uint8 link, L7_uint8 enable)
 {
   /* Code regarding to forcelinks procedures is going to be removed */
 #if (SDK_VERSION_IS <= SDK_VERSION(6,5,7,0))
-  PT_LOG_DEBUG(LOG_CTX_HAPI, "Force link procedure (link=%u, enable=%u) for usp {%d,%d,%d}", link, enable, usp->unit, usp->slot, usp->port);
-
   DAPI_PORT_t  *dapiPortPtr;
   BROAD_PORT_t *hapiPortPtr;
   L7_int ptin_port, i, link_status;
   bcm_pbmp_t pbmp;
   bcm_error_t rv;
   L7_RC_t rc = L7_SUCCESS;
@@ -2337,12 +2335,14 @@ L7_RC_t ptin_hapi_link_force(DAPI_USP_t
   SYSAPI_HPC_CARD_DESCRIPTOR_t *sysapiHpcCardInfoPtr;
   DAPI_CARD_ENTRY_t            *dapiCardPtr;
   HAPI_WC_PORT_MAP_t           *hapiWCMapPtr;
   bcm_port_if_t                 intf_type;
 #endif
 
+  PT_LOG_DEBUG(LOG_CTX_HAPI, "Force link procedure (link=%u, enable=%u) for usp {%d,%d,%d}", link, enable, usp->unit, usp->slot, usp->port);
+
   /* Validate dapiPort */
   if (usp->unit<0 || usp->slot<0 || usp->port<0)
   {
     PT_LOG_ERR(LOG_CTX_HAPI, "Invalid interface");
     return L7_FAILURE;
   }
@@ -5807,12 +5807,14 @@ L7_RC_t ag16ga_bck_static_switching()
         hapiBroadPolicyCreateCancel();
         return L7_FAILURE;
       }
 
       do
       {
+        int index;
+        L7_short16 port_aux;
 
         rc = hapiBroadPolicyPriorityRuleAdd(&ruleId, BROAD_POLICY_RULE_PRIORITY_DEFAULT);
         if (rc != L7_SUCCESS)  break;
 
 
         if (port >= 0)
@@ -5835,18 +5837,18 @@ L7_RC_t ag16ga_bck_static_switching()
         BCM_PBMP_PORT_ADD(pbm, bcm_port);
         hapi_ptin_allportsbmp_get(&pbm_mask);
 
         rc = hapiBroadPolicyRuleQualifierAdd(ruleId, BROAD_FIELD_INPORTS, (L7_uchar8 *)&pbm, (L7_uchar8 *)&pbm_mask);
         if (rc != L7_SUCCESS)  break;
 
-        int index = i * 4 + j;
+        index = i * 4 + j;
 
         rc = hapiBroadPolicyRuleQualifierAdd(ruleId, BROAD_FIELD_OVID, (L7_uchar8 *)&vlan_value[j], (L7_uchar8 *)&vlan_mask[j]);
         if (rc != L7_SUCCESS)  break;
 
-        L7_short16 port_aux = (usp_map[index].port-1);
+        port_aux = (usp_map[index].port-1);
 
         rc = hapiBroadPolicyRuleActionAdd(ruleId, BROAD_ACTION_REDIRECT, 1 /*unit*/, 0 /*slot*/, port_aux);
         if (rc != L7_SUCCESS)
         {
           PT_LOG_ERR(LOG_CTX_STARTUP, "Error configuring rule");
           hapiBroadPolicyCreateCancel();
@@ -5918,17 +5920,16 @@ L7_RC_t ag16ga_frontal_static_switching(
       if (rc != L7_SUCCESS)  break;
 
       BCM_PBMP_CLEAR(pbm);
 
       for (j = 0; j < 4; j++)
       {
+        int index = (i * 4) + j;
 
         PT_LOG_ERR(LOG_CTX_STARTUP,"Port %d was given\r\n", port);
 
-        int index = (i * 4) + j;
-
         /* Validate port */
         if (hapi_ptin_bcmPort_get(index, &bcm_port) != L7_SUCCESS)
         {
           PT_LOG_ERR(LOG_CTX_STARTUP,"Error getting bcm_port of port %d\r\n", port);
           return L7_FAILURE;
         }
Index: andl/hapi/esw/ptin/ptin_hapi_xconnect.c
===================================================================
--- andl/hapi/esw/ptin/ptin_hapi_xconnect.c	(revision 7746)
+++ andl/hapi/esw/ptin/ptin_hapi_xconnect.c	(revision 7747)
@@ -554,12 +554,14 @@ L7_RC_t ptin_hapi_vp_create(ptin_dapi_po
                             L7_uint16 egress_ovid, L7_uint16 egress_ivid,
                             L7_int *mcast_group,
                             L7_int *virtual_gport, L7_int port_id, L7_int type)
 {
   DAPI_PORT_t  *dapiPortPtr;
   BROAD_PORT_t *hapiPortPtr;
+  bcm_vlan_port_t vlan_port;
+  bcm_vlan_action_set_t action;
   bcm_multicast_t mc_group;
   bcm_error_t error;
   bcm_multicast_t encap_id;
   int unit;
 
   PT_LOG_TRACE(LOG_CTX_HAPI, "port={%d,%d,%d}, oVlanId=%u iVlanId=%u => oVlanId=%u iVlanId=%u",
@@ -582,13 +584,12 @@ L7_RC_t ptin_hapi_vp_create(ptin_dapi_po
     PT_LOG_ERR(LOG_CTX_HAPI, "ERROR: Port {%d,%d,%d} are not physical",
             dapiPort->usp->unit,dapiPort->usp->slot,dapiPort->usp->port);
     return L7_FAILURE;
   }
 
   /* create the virtual ports */
-  bcm_vlan_port_t vlan_port;
   bcm_vlan_port_t_init(&vlan_port);
 
   /* in direction PON -> network, match on stacked VLAN, translate to client ID on ingress */
   if (egress_ivid > 0 && egress_ivid < 4096)
   {
     vlan_port.flags = BCM_VLAN_PORT_INNER_VLAN_ADD | BCM_VLAN_PORT_INNER_VLAN_REPLACE;
@@ -664,13 +665,12 @@ L7_RC_t ptin_hapi_vp_create(ptin_dapi_po
       return L7_FAILURE;
     }
     #endif
 
     /* create egress translation entries for virtual ports to do VLAN tag manipulation 
      * i.e. client -> gem_id + some_c_vlan */
-    bcm_vlan_action_set_t action;
     bcm_vlan_action_set_t_init(&action);
     
     /* for outer tagged packet => outer tag replaced with gem_id */
     action.ot_outer = bcmVlanActionReplace;
     action.dt_outer = bcmVlanActionReplace;
     action.new_outer_vlan = match_ovid;
@@ -750,12 +750,13 @@ L7_RC_t ptin_hapi_vp_remove(ptin_dapi_po
                             L7_int virtual_gport,
                             L7_int mcast_group)
 {
   int unit;
   DAPI_PORT_t  *dapiPortPtr;
   BROAD_PORT_t *hapiPortPtr;
+  bcm_vlan_port_t vlan_port;
   bcm_multicast_t encap_id;
   bcm_error_t error;
 
   PT_LOG_TRACE(LOG_CTX_HAPI, "port={%d,%d,%d}, oVlanId=%u iVlanId=%u",
             dapiPort->usp->unit,dapiPort->usp->slot,dapiPort->usp->port,
             match_ovid, match_ivid);
@@ -783,13 +784,12 @@ L7_RC_t ptin_hapi_vp_remove(ptin_dapi_po
   {
     PT_LOG_ERR(LOG_CTX_HAPI, "Invalid MC group (%d)", mcast_group);
     return L7_FAILURE;
   }
 
   /* create the virtual ports */
-  bcm_vlan_port_t vlan_port;
   bcm_vlan_port_t_init(&vlan_port);
 
   /* If virtual port id is provided, use it */
   if (virtual_gport > 0)
   {
     vlan_port.flags = BCM_VLAN_PORT_WITH_ID;
Index: andl/hapi/esw/ptin/devshell_test.c
===================================================================
--- andl/hapi/esw/ptin/devshell_test.c	(revision 7746)
+++ andl/hapi/esw/ptin/devshell_test.c	(revision 7747)
@@ -1649,24 +1649,29 @@ int ptin_vlan_stat_get(bcm_vlan_t vlanId
 int ptin_vp_gpon(L7_uint32 pon_port, L7_uint32 network_port, L7_int s_vid, L7_int c_vid)
 {
   int unit = 0;
   bcm_gport_t network_gport;
   int gemid[] = {101, 102, 103};
   int cvid[]  = {25, 35, 45};
+  bcm_vlan_port_t vlan_port[3];
+  bcm_vlan_action_set_t action;
+  bcm_multicast_t mcast_group;
+  bcm_multicast_t encap_id;
+  bcm_pbmp_t pbmp, ubmp;
+  bcm_vlan_control_vlan_t vlan_control;
   int i;
   bcm_error_t error;
 
   /* enable L3 egress mode... needed for the virtual port APIs to work */
   if ((error=bcm_switch_control_set(unit, bcmSwitchL3EgressMode, 1)) != BCM_E_NONE)
   {
     printf("Error setting on bcmSwitchL3EgressModecreating policer: error=%d (\"%s\")\r\n",error,bcm_errmsg(error));
     return error;
   }
 
   /* create the virtual ports */
-  bcm_vlan_port_t vlan_port[3];
   bcm_vlan_port_t_init(&vlan_port[0]);
   bcm_vlan_port_t_init(&vlan_port[1]);
   bcm_vlan_port_t_init(&vlan_port[2]);
 
   /* in direction PON -> network, match on stacked VLAN, translate to client ID on ingress */
   for (i = 0; i < 3; i++) {
@@ -1686,13 +1691,12 @@ int ptin_vp_gpon(L7_uint32 pon_port, L7_
 
       printf("Vlan idx %d created!\r\n",i);
   }
 
   /* create egress translation entries for virtual ports to do VLAN tag manipulation 
    * i.e. client -> gem_id + some_c_vlan */
-  bcm_vlan_action_set_t action;
   for (i = 0; i < 3; i++) {
       bcm_vlan_action_set_t_init(&action);
       
       /* for outer tagged packet => outer tag replaced with gem_id */
       action.ot_outer = bcmVlanActionReplace;
       action.dt_outer = bcmVlanActionReplace;
@@ -1709,15 +1713,12 @@ int ptin_vp_gpon(L7_uint32 pon_port, L7_
                unit, vlan_port[i].vlan_port_id, s_vid, 0, error, bcm_errmsg(error));
         return error;
       }
   }
 
   /* create multicast group, and add virtual ports to it */
-  bcm_multicast_t mcast_group;
-  bcm_multicast_t encap_id;
-
   if ((error=bcm_multicast_create(unit, BCM_MULTICAST_TYPE_VLAN, &mcast_group))!=BCM_E_NONE)
   {
     printf("Error with bcm_multicast_create(%d, %d, &mcast_group): error=%d (\"%s\")\r\n",
            unit, BCM_MULTICAST_TYPE_VLAN, error, bcm_errmsg(error));
     return error;
   }
@@ -1745,13 +1746,12 @@ int ptin_vp_gpon(L7_uint32 pon_port, L7_
   {
     printf("Error with bcm_multicast_egress_add: error=%d (\"%s\")\r\n",error, bcm_errmsg(error));
     return error;
   }
 
   /* configure vlan membership */
-  bcm_pbmp_t pbmp, ubmp;
   BCM_PBMP_CLEAR(pbmp);
   BCM_PBMP_CLEAR(ubmp);
   BCM_PBMP_PORT_ADD(pbmp, network_port);
   BCM_PBMP_PORT_ADD(pbmp, pon_port);
 
   printf("pon_port=%d, network_port=%d\r\n",pon_port, network_port);
@@ -1770,13 +1770,12 @@ int ptin_vp_gpon(L7_uint32 pon_port, L7_
   {
     printf("Error with bcm_vlan_port_add: error=%d (\"%s\")\r\n",error, bcm_errmsg(error));
     return error;
   }
 
   /* configure the VLAN to enable flooding towards virtual ports, this overrides the regular VLAN flooding */
-  bcm_vlan_control_vlan_t vlan_control;
   if ((error=bcm_vlan_control_vlan_get(unit, s_vid, &vlan_control))!=BCM_E_NONE)
   {
     printf("Error with bcm_vlan_control_vlan_get: error=%d (\"%s\")\r\n",error, bcm_errmsg(error));
     return error;
   }
   vlan_control.broadcast_group = mcast_group;
Index: andl/hapi/esw/policy/broad_group_xgs3.c
===================================================================
--- andl/hapi/esw/policy/broad_group_xgs3.c	(revision 7746)
+++ andl/hapi/esw/policy/broad_group_xgs3.c	(revision 7747)
@@ -5561,65 +5561,66 @@ int policy_group_get_stats(int
     if (!(groupPtr->flags & GROUP_USED))
         return BCM_E_NOT_FOUND;
 
     eid = BROAD_ENTRY_TO_BCM_ENTRY(entry);
 
     /* PTin added: SDK 6.3.0 */
-    #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
-
-    int stat_size, stat_id;
-    bcm_field_stat_t stat_type[2];
-    uint64 values[2];
-
-    /* Get stat id for this entry */
-    rv = bcm_field_entry_stat_get(unit, entry, &stat_id);
-    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
-        return rv;
-
-    /* Get number of counters */
-    rv = bcm_field_stat_size(unit, stat_id, &stat_size);
-    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
-        return rv;
-    /* Limit number of counters to 2 */
-    if (stat_size>2)  stat_size = 2;
-
-    if (stat_size==0)
-      return BCM_E_EMPTY;
-
-    /* Get collection of counters */
-    rv = bcm_field_stat_config_get(unit, stat_id, stat_size, stat_type);
-    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
-        return rv;
-
-    /* Get counters values */
-    rv = bcm_field_stat_multi_get(unit, stat_id, stat_size, stat_type, values);
-    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
-        return rv;
-
-    if (stat_size>=1 && val1!=NULL)  *val1 = values[0];
-    if (stat_size>=2 && val2!=NULL)  *val2 = values[1];
-
-    #else
-
-    if (policyStage == BROAD_POLICY_STAGE_EGRESS)
+#if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
     {
-      rv = bcm_field_counter_get(unit, eid, 0, val2);
-      if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
-          return rv;
+        int stat_size, stat_id;
+        bcm_field_stat_t stat_type[2];
+        uint64 values[2];
+
+        /* Get stat id for this entry */
+        rv = bcm_field_entry_stat_get(unit, entry, &stat_id);
+        if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+            return rv;
+
+        /* Get number of counters */
+        rv = bcm_field_stat_size(unit, stat_id, &stat_size);
+        if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+            return rv;
+        /* Limit number of counters to 2 */
+        if (stat_size>2)  stat_size = 2;
+
+        if (stat_size==0)
+          return BCM_E_EMPTY;
+
+        /* Get collection of counters */
+        rv = bcm_field_stat_config_get(unit, stat_id, stat_size, stat_type);
+        if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+            return rv;
+
+        /* Get counters values */
+        rv = bcm_field_stat_multi_get(unit, stat_id, stat_size, stat_type, values);
+        if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+            return rv;
+
+        if (stat_size>=1 && val1!=NULL)  *val1 = values[0];
+        if (stat_size>=2 && val2!=NULL)  *val2 = values[1];
     }
-    else
+    #else
     {
-      rv = bcm_field_counter_get(unit, eid, 0, val1);
-      if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
-          return rv;
-
-      rv = bcm_field_counter_get(unit, eid, 1, val2);  /* empty means no counter */
-      if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
-          return rv;
+        if (policyStage == BROAD_POLICY_STAGE_EGRESS)
+        {
+          rv = bcm_field_counter_get(unit, eid, 0, val2);
+          if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
+              return rv;
+        }
+        else
+        {
+          rv = bcm_field_counter_get(unit, eid, 0, val1);
+          if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
+              return rv;
+
+          rv = bcm_field_counter_get(unit, eid, 1, val2);  /* empty means no counter */
+          if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+              return rv;
+        }
     }
-    #endif
+#endif
 
     return BCM_E_NONE;
 }
 
 int policy_group_stats_clear(int                  unit,
                              BROAD_POLICY_STAGE_t policyStage,
@@ -5631,38 +5632,40 @@ int policy_group_stats_clear(int
 
     COMPILER_64_ZERO(val1);
 
     eid = BROAD_ENTRY_TO_BCM_ENTRY(entry);
 
     /* PTin modified: SDK 6.3.0 */
-    #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
-    int                stat_id;
+#if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
+    {
+        int                stat_id;
 
-    /* Get stat id for this entry */
-    rv = bcm_field_entry_stat_get(unit, entry, &stat_id);
-    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
-        return rv;
-
-    /* Reset counters */
-    rv = bcm_field_stat_all_set(unit, stat_id, val1);
-    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
-        return rv;
+        /* Get stat id for this entry */
+        rv = bcm_field_entry_stat_get(unit, entry, &stat_id);
+        if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+            return rv;
 
-    #else
+        /* Reset counters */
+        rv = bcm_field_stat_all_set(unit, stat_id, val1);
+        if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
+            return rv;
+    }
+#else
+    {
+        rv = bcm_field_counter_set(unit, eid, 0, val1);
+        if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
+            return rv;
 
-    rv = bcm_field_counter_set(unit, eid, 0, val1);
-    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))   /* empty means no counter */
-        return rv;
-
-    if (policyStage != BROAD_POLICY_STAGE_EGRESS)
-    {
-      rv = bcm_field_counter_set(unit, eid, 1, val1);  /* empty means no counter */
-      if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
-          return rv;
+        if (policyStage != BROAD_POLICY_STAGE_EGRESS)
+        {
+          rv = bcm_field_counter_set(unit, eid, 1, val1);  /* empty means no counter */
+          if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+              return rv;
+        }
     }
-    #endif
+#endif
 
     return BCM_E_NONE;
 }
 
 void policy_group_dataplane_cleanup(int                  unit,
                                     BROAD_ENTRY_t        entry,
@@ -6164,82 +6167,85 @@ void debug_sqset_table(int unit, int ent
 
 void debug_entry_counter(int unit, bcm_field_entry_t eid)
 {
     int    rv;
 
     /* PTin modified: SDK 6.3.0 */
-    #if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
-    int    i;
-    int    stat_id;
-    int    stat_size;
-    bcm_field_stat_t stat_type[4];
-    uint64 values[4];
-
-    /* Get stat id for this entry */
-    rv = bcm_field_entry_stat_get(unit, eid, &stat_id);
-    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+#if (SDK_VERSION_IS >= SDK_VERSION(5,6,0,0))
     {
-      sysapiPrintf("Error with bcm_field_entry_stat_get\n");
-      return;
-    }
+        int    i;
+        int    stat_id;
+        int    stat_size;
+        bcm_field_stat_t stat_type[4];
+        uint64 values[4];
+
+        /* Get stat id for this entry */
+        rv = bcm_field_entry_stat_get(unit, eid, &stat_id);
+        if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        {
+          sysapiPrintf("Error with bcm_field_entry_stat_get\n");
+          return;
+        }
 
-    /* Get number of counters */
-    rv = bcm_field_stat_size(unit, stat_id, &stat_size);
-    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
-    {
-      sysapiPrintf("Error with bcm_field_stat_size\n");
-      return;
-    }
-    /* Limit number of counters to 2 */
-    if (stat_size>4)  stat_size = 4;
+        /* Get number of counters */
+        rv = bcm_field_stat_size(unit, stat_id, &stat_size);
+        if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        {
+          sysapiPrintf("Error with bcm_field_stat_size\n");
+          return;
+        }
+        /* Limit number of counters to 2 */
+        if (stat_size>4)  stat_size = 4;
 
-    if (stat_size==0)
-    {
-      sysapiPrintf("No counters\n");
-      return;
-    }
+        if (stat_size==0)
+        {
+          sysapiPrintf("No counters\n");
+          return;
+        }
 
-    /* Get collection of counters */
-    rv = bcm_field_stat_config_get(unit, stat_id, stat_size, stat_type);
-    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
-    {
-      sysapiPrintf("Error with bcm_field_stat_config_get\n");
-      return;
-    }
+        /* Get collection of counters */
+        rv = bcm_field_stat_config_get(unit, stat_id, stat_size, stat_type);
+        if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        {
+          sysapiPrintf("Error with bcm_field_stat_config_get\n");
+          return;
+        }
 
-    /* Get counters values */
-    rv = bcm_field_stat_multi_get(unit, stat_id, stat_size, stat_type, values);
-    if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
-    {
-      sysapiPrintf("Error with bcm_field_stat_multi_get\n");
-      return;
-    }
+        /* Get counters values */
+        rv = bcm_field_stat_multi_get(unit, stat_id, stat_size, stat_type, values);
+        if ((BCM_E_NONE != rv) && (BCM_E_EMPTY != rv))
+        {
+          sysapiPrintf("Error with bcm_field_stat_multi_get\n");
+          return;
+        }
 
-    /* Print counters */
-    for (i=0; i<stat_size; i++)
-    {
-      sysapiPrintf("Counter %d: %08x %08x\n", i, u64_H(values[i]), u64_L(values[i]));
+        /* Print counters */
+        for (i=0; i<stat_size; i++)
+        {
+          sysapiPrintf("Counter %d: %08x %08x\n", i, u64_H(values[i]), u64_L(values[i]));
+        }
     }
+#else
+    {
+        uint64 val64;
 
-    #else
-    uint64 val64;
-
-    rv = bcm_field_counter_get(unit, eid, 0, &val64);
+        rv = bcm_field_counter_get(unit, eid, 0, &val64);
 
-    if (BCM_E_NONE == rv)
-        sysapiPrintf("Counter 0: %08x %08x\n", u64_H(val64), u64_L(val64));
-    else
-        sysapiPrintf("error code = %d\n", rv);
+        if (BCM_E_NONE == rv)
+            sysapiPrintf("Counter 0: %08x %08x\n", u64_H(val64), u64_L(val64));
+        else
+            sysapiPrintf("error code = %d\n", rv);
 
-    rv = bcm_field_counter_get(unit, eid, 1, &val64);
+        rv = bcm_field_counter_get(unit, eid, 1, &val64);
 
-    if (BCM_E_NONE == rv)
-        sysapiPrintf("Counter 1: %08x %08x\n", u64_H(val64), u64_L(val64));
-    else
-        sysapiPrintf("error code = %d\n", rv);
-    #endif
+        if (BCM_E_NONE == rv)
+            sysapiPrintf("Counter 1: %08x %08x\n", u64_H(val64), u64_L(val64));
+        else
+            sysapiPrintf("error code = %d\n", rv);
+    }
+#endif
 }
 
 /* PTin added: FFP */
 #if 1
 group_table_t *policy_group_count_rules(int unit, int group_idx, int stage)
 {
Index: andl/hapi/esw/qos/broad_acl.c
===================================================================
--- andl/hapi/esw/qos/broad_acl.c	(revision 7746)
+++ andl/hapi/esw/qos/broad_acl.c	(revision 7747)
@@ -1198,39 +1198,39 @@ static L7_RC_t hapiBroadQosAclInstAdd(DA
                       }
                     }
                 }
                 break;
 
             case L7_QOS_ACL_TLV_ATTR_MIRROR_TYPE:
+              {
+                DAPI_USP_t mirrorUsp;
+                BROAD_METER_ENTRY_t meterInfo;
+                denyFlag = 0;    
+                captureNotDeny = 1;
+
+                /* PTIN TODO: Currently the intfnum comming from the above layer is being ignored and the CPU port is forced */
+                #if 0
+                mirrorUsp.unit = osapiNtohl(*(L7_int32*)GET_VALUE_PTR(pMatchTLV,0));
+                mirrorUsp.slot = osapiNtohl(*(L7_int32*)GET_VALUE_PTR(pMatchTLV,4));
+                mirrorUsp.port = osapiNtohl(*(L7_int32*)GET_VALUE_PTR(pMatchTLV,8));
+                #else                   
+                mirrorUsp.unit = 0;
+                mirrorUsp.slot = L7_CPU_SLOT_NUM;
+                mirrorUsp.port = 0;
+                #endif
 
-              denyFlag = 0;    
-              captureNotDeny = 1;
-              DAPI_USP_t mirrorUsp;
-              BROAD_METER_ENTRY_t meterInfo;
-
-              /* PTIN TODO: Currently the intfnum comming from the above layer is being ignored and the CPU port is forced */
-              #if 0
-              mirrorUsp.unit = osapiNtohl(*(L7_int32*)GET_VALUE_PTR(pMatchTLV,0));
-              mirrorUsp.slot = osapiNtohl(*(L7_int32*)GET_VALUE_PTR(pMatchTLV,4));
-              mirrorUsp.port = osapiNtohl(*(L7_int32*)GET_VALUE_PTR(pMatchTLV,8));
-              #else                   
-              mirrorUsp.unit = 0;
-              mirrorUsp.slot = L7_CPU_SLOT_NUM;
-              mirrorUsp.port = 0;
-              #endif
-
-              result = hapiBroadPolicyRuleActionAdd(ruleId,
+                result = hapiBroadPolicyRuleActionAdd(ruleId,
                                                      BROAD_ACTION_MIRROR,
                                                      mirrorUsp.unit,
                                                      mirrorUsp.slot,
                                                      mirrorUsp.port);
 
-               result = hapiBroadPolicyRuleActionAdd(ruleId, BROAD_ACTION_PERMIT, 0, 0, 0);
+                result = hapiBroadPolicyRuleActionAdd(ruleId, BROAD_ACTION_PERMIT, 0, 0, 0);
 
-               if (result == L7_SUCCESS)
-               {
+                if (result == L7_SUCCESS)
+                {
                  /* Workaround for VK2 (TG16G) */
                  result = hapiBroadPolicyRuleActionAdd(ruleId, BROAD_ACTION_SET_COSQ, CPU_TRAPPED_PACKETS_COS_PCAP, 0, 0);
                     
                  if (L7_LAG_SLOT_NUM == mirrorUsp.slot)
                  {
                     /* This policy now depends upon the LAG as it's destination. */
@@ -1253,13 +1253,14 @@ static L7_RC_t hapiBroadQosAclInstAdd(DA
                     meterInfo.pir       = RATE_LIMIT_PCAP;
                     meterInfo.pbs       = 128;
                     meterInfo.colorMode = BROAD_METER_COLOR_BLIND;
 
                     result = hapiBroadPolicyRuleMeterAdd(ruleId, &meterInfo);
                   }
-                 }
+                }
+              }
             break;
 
             /* Timed Based ACLs - Reading the correaltor and rule status information from the TLV */
             case L7_QOS_ACL_TLV_RULE_STATUS:
                  ruleStatus = osapiNtohs(*((L7_ushort16 *)GET_VALUE_PTR(pMatchTLV,0)));             
                  trCorrelator = osapiNtohl(*(L7_int32*)GET_VALUE_PTR(pMatchTLV,4));
Index: andl/hapi/esw/usl/ipmcast/l7_usl_bcmx_ipmcast.c
===================================================================
--- andl/hapi/esw/usl/ipmcast/l7_usl_bcmx_ipmcast.c	(revision 7746)
+++ andl/hapi/esw/usl/ipmcast/l7_usl_bcmx_ipmcast.c	(revision 7747)
@@ -751,33 +751,32 @@ int usl_bcmx_ipmc_inuse_get(usl_bcm_ipmc
 
 #ifdef L7_STACKING_PACKAGE
   /* On Stackables, we query the USL Db to get the group use status */
   *inuse = usl_ipmc_inuse_get(ipmc);
 
 #else
+  {
+      L7_uint32         flags = 0;
 
-  L7_uint32         flags = 0;
-
-  ipmc->flags |= BCM_IPMC_HIT_CLEAR;
+      ipmc->flags |= BCM_IPMC_HIT_CLEAR;
 
-  rv = usl_bcm_ipmc_inuse_get(ipmc, &flags);
+      rv = usl_bcm_ipmc_inuse_get(ipmc, &flags);
 
-  if (L7_BCMX_OK(rv) == L7_TRUE) 
-  {
-    if (flags & BCM_IPMC_HIT)
-      *inuse = L7_TRUE;
+      if (L7_BCMX_OK(rv) == L7_TRUE) 
+      {
+        if (flags & BCM_IPMC_HIT)
+          *inuse = L7_TRUE;
+      }
+      else
+      {
+        USL_LOG_MSG(USL_BCM_E_LOG,
+                    "Failed to get inuse state of entry index %d\n", ipmc->ipmc_index);
+      }
   }
-  else
-  {
-    USL_LOG_MSG(USL_BCM_E_LOG,
-                "Failed to get inuse state of entry index %d\n", ipmc->ipmc_index);
-  }
-
 #endif
 
-
   return rv; 
 }
 
 /*********************************************************************
 * @purpose  Add a WLAN virtual port to an IP multicast group
 *
Index: andl/hapi/esw/usl/port/l7_rpc_port.c
===================================================================
--- andl/hapi/esw/usl/port/l7_rpc_port.c	(revision 7746)
+++ andl/hapi/esw/usl/port/l7_rpc_port.c	(revision 7747)
@@ -26,12 +26,16 @@
 
 #include "sal/core/libc.h"
 #include "bcm/custom.h"
 #include "bcm/l2.h"
 #include "bcm/link.h"
 
+#if defined (__GNUC__) && (__GNUC__ >= 7)
+#pragma GCC diagnostic ignored "-Waggressive-loop-optimizations"
+#endif
+
 extern int l7_rpc_server_mcast_port_update_groups(int unit, bcm_port_t port, 
                                            int setget, uint32 *args);
 
 /*********************************************************************
 *
 * @purpose RPC Client API to set the broadcast rate threshold for a port
@@ -1963,14 +1967,16 @@ l7_rpc_client_port_sfp_diag_get(bcm_gpor
     PT_LOG_ERR(LOG_CTX_INTF,"Invalid gport 0x%x", gport);
     return BCM_E_PARAM;
   }
 
   /* PTin modified: SDK 6.3.0 */
   #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
-  L7_int len;
-  rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_SFP_DIAG_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  {
+      L7_int len;
+      rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_SFP_DIAG_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  }
   #else
   rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_SFP_DIAG_GET, args);
   #endif
 
   if (rv >= 0) {
     *temperature = args[0];
@@ -2011,14 +2017,16 @@ l7_rpc_client_port_copper_diag_get(bcm_g
     PT_LOG_ERR(LOG_CTX_INTF,"Invalid gport 0x%x", gport);
     return BCM_E_PARAM;
   }
 
   /* PTin modified: SDK 6.3.0 */
   #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
-  L7_int len;
-  rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_COPPER_DIAG_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  {
+      L7_int len;
+      rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_COPPER_DIAG_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  }
   #else
   rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_COPPER_DIAG_GET, args);
   #endif
 
   if (rv >= 0) 
   {
@@ -2388,14 +2396,16 @@ l7_rpc_client_port_dot1x_client_timeout_
   }
 
   memcpy (args, client_cmd, sizeof (usl_bcm_port_dot1x_client_t));
 
   /* PTin modified: SDK 6.3.0 */
   #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
-  L7_int len;
-  rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_DOT1X_CLIENT_TIMEOUT_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  {
+      L7_int len;
+      rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_DOT1X_CLIENT_TIMEOUT_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  }
   #else
   rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_DOT1X_CLIENT_TIMEOUT_GET, args);
   #endif
 
   if (rv >= 0) 
   {
@@ -2482,14 +2492,16 @@ l7_rpc_client_stat_get(bcm_gport_t gport
     PT_LOG_ERR(LOG_CTX_INTF,"Invalid gport 0x%x", gport);
     return BCM_E_PARAM;
   }
 
   /* PTin modified: SDK 6.3.0 */
   #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
-  L7_int len;
-  rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_STATS_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  {
+      L7_int len;
+      rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_STATS_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  }
   #else
   rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_STATS_GET, args);
   #endif
 
   if (rv >= 0) 
   {
@@ -2531,14 +2543,16 @@ l7_rpc_client_port_stat_get(bcm_gport_t
     PT_LOG_ERR(LOG_CTX_INTF,"Invalid gport 0x%x", gport);
     return BCM_E_PARAM;
   }
 
   /* PTin modified: SDK 6.3.0 */
   #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
-  L7_int len;
-  rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_STATS_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  {
+      L7_int len;
+      rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_STATS_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  }
   #else
   rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_STATS_GET, args);
   #endif
 
   if (rv >= 0) 
   {
@@ -3648,14 +3662,16 @@ int l7_rpc_client_port_pfc_stat_get(bcm_
     return BCM_E_INTERNAL;
   }
 
   memcpy (args, stat, sizeof (*stat));
   /* PTin modified: SDK 6.3.0 */
   #if (SDK_VERSION_IS >= SDK_VERSION(6,0,0,0))
-  L7_int len;
-  rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_PFC_STAT_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  {
+      L7_int len;
+      rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_PFC_STAT_GET, BCM_CUSTOM_ARGS_MAX, args, &len);
+  }
   #else
   rv = bcm_custom_port_get(bcm_unit, bcm_port, USL_BCMX_PORT_PFC_STAT_GET, args);
   #endif
 
   if (BCM_E_NONE == rv)
   {
Index: os/linux/mgmt/dtl_net.c
===================================================================
--- os/linux/mgmt/dtl_net.c	(revision 7746)
+++ os/linux/mgmt/dtl_net.c	(revision 7747)
@@ -1297,25 +1297,25 @@ void dtlSendCmd(int fd, L7_uint32 dummy_
    L7_uint32 intIfNum;
    L7_uint32 activeState;
    char dtlIfName[32];
    register L7_ipHeader_t *ip_header;
    sysnet_pdu_info_t pduInfo;
    SYSNET_PDU_RC_t hookAction;
+   ptin_PptTsRecord_t ptpTs;
 
    /* PTin added: inband */
    L7_uint16    vid = 0;                        
    L7_BOOL      isTaggedPacket = L7_FALSE;      
    L7_BOOL      isInbandVidPacket = L7_FALSE;   
    L7_uint16    dtl0Vid = 0;
    L7_uchar8    etype_8021q[] = {0x81,0x00};    /* L7_ETYPE_8021Q */
 
    /* PTin added: Initialize L2 flags */
    info->dtlCmdInfo.cmdType.L2.flags = 0;
 
    /* Register a PTP TS */
-   ptin_PptTsRecord_t ptpTs;
    ptpTs.validTsRecord = L7_FALSE;
 
    /*
     *zero out the dtlCmd structure
     */
    memset(&info->dtlCmdInfo,0,sizeof(DTL_CMD_TX_INFO_t));
@@ -1378,18 +1378,21 @@ void dtlSendCmd(int fd, L7_uint32 dummy_
          }
 
          vid = simMgmtVlanIdGet();                    /* This is the internal VID */
       }
       else if (dtl0Vid == PTIN_VLAN_PCAP_EXT)
       {            
+        int intfNum;
+        int vlan;
+
         /* Remove PTIN_VLAN_PCAP_EXT TAG*/
         ptin_RemoveTag(data, &data_length);
 
         /* Get IntfNum from agent (were the packet were receive)*/
-        int intfNum =((data[14]<<8) & 0x0F00) | (data[15] & 0x00FF);
-        int vlan = ((data[18]<<8) & 0x0F00) | (data[19] & 0x00FF);
+        intfNum =((data[14]<<8) & 0x0F00) | (data[15] & 0x00FF);
+        vlan = ((data[18]<<8) & 0x0F00) | (data[19] & 0x00FF);
 
         if (dtlNetPtinDebug & DTLNET_PTINDEBUG_TX_LEVEL1)
         {
           SYSAPI_PRINTF(SYSAPI_LOGGING_ALWAYS, "%s(%d): Initial intfnum %u \n\r", __FUNCTION__, __LINE__, intfNum );
         }
         /* static switching, where is calculate the intfNum to send*/
Index: src/system_support/base/network/sntp/sntp_client.c
===================================================================
--- src/system_support/base/network/sntp/sntp_client.c	(revision 7746)
+++ src/system_support/base/network/sntp/sntp_client.c	(revision 7747)
@@ -848,16 +848,16 @@ static L7_RC_t sntpLocalUcastSocketOpen(
 * @end
 *********************************************************************/
 static L7_RC_t sntpLocalMcastSocketOpen()
 {
   L7_uint32 on = 1;
   L7_sockaddr_union_t baddr;
-  localAddr = L7_INADDR_ANY;
-
   struct L7_ip_mreq_s  ipMreq;
      
+  localAddr = L7_INADDR_ANY;
+
   /** Open a socket and begin querying the server. */
   if (osapiSocketCreate(L7_AF_INET, L7_SOCK_DGRAM, 0, &ucastFd) != L7_SUCCESS)
   {
     ucastFd = -1;
     SNTP_PRINTF("socket open failed - errno %d\n", osapiErrnoGet());
     return L7_ERROR;
@@ -1597,12 +1597,13 @@ static void sntpBroadcastTimestamp()
 *********************************************************************/
 static L7_RC_t sntpResponseProcess(L7_char8 * response, L7_int32 responseLen)
 {
   L7_int32 delay;
   L7_int32 offset;
   sntpPacket_t ntpData;
+  L7_char8 * buf;
   L7_RC_t updateStatus = L7_FAILURE;
   
   L7_uchar8 recvAddressDisplay[L7_SNTP_MAX_ADDRESS_LEN];
 
   memset(&ntpData, 0, sizeof(ntpData));
   memset(&recvAddressDisplay,0x00,sizeof(recvAddressDisplay));
@@ -1696,13 +1697,13 @@ static L7_RC_t sntpResponseProcess(L7_ch
     if (offset)
     {
       (void) osapiNTPTimeSet(offset);
       sntpStatusData->sntpLastUpdateTime = osapiUTCTimeNow();
 
       /* Need to add/update conversion routines in osapi */
-      L7_char8 * buf = ctime((void *)&(sntpStatusData->sntpLastUpdateTime));
+      buf = ctime((void *)&(sntpStatusData->sntpLastUpdateTime));
       buf[24] = '\0';
       SNTP_PRINTF("SNTP: system clock synchronized on %s UTC. Indicates that SNTP has"
                   " successfully synchronized the time of the box with the server.", buf);
       SNTP_PRINTF("SNTP: osapiUTCTimeNow = %u -> %s\n", osapiUTCTimeNow(), buf);
       L7_LOGF(L7_LOG_SEVERITY_DEBUG, L7_SNTP_COMPONENT_ID, "SNTP: system clock synchronized "
               "on %s UTC. Indicates that SNTP has successfully synchronized the time of"
Index: src/l7public/common/ptin/ptin_globaldefs.h
===================================================================
--- src/l7public/common/ptin/ptin_globaldefs.h	(revision 7746)
+++ src/l7public/common/ptin/ptin_globaldefs.h	(revision 7747)
@@ -276,14 +276,14 @@ extern volatile ptin_state_t ptin_state;
 
 extern volatile void        *ptin_task_msg_buffer;
 
 extern volatile L7_uint32    ptin_task_msg_id;
 
 #define PTIN_CRASH()  {       \
-  ptin_state = PTIN_STATE_CRASHED;  \
   volatile int i;             \
+  ptin_state = PTIN_STATE_CRASHED;  \
   for(;;i++) sleep(60);       \
 }
 
 #define PTIN_T_RETRY_IPC      5   /* sec */
 
 #endif /* _PTIN_GLOBALDEFS_H */
Index: src/application/routing/protocol/ospf/sprtb.c
===================================================================
--- src/application/routing/protocol/ospf/sprtb.c	(revision 7746)
+++ src/application/routing/protocol/ospf/sprtb.c	(revision 7747)
@@ -1947,25 +1947,24 @@ static e_Err AsExtModifyRte(t_RTB *p_RTB
    Bool p_flagAsExt;
    ulng X;    /* the cost to the ASBR or forwarding address for the new T5 LSA */
    ulng Y;    /* the cost specified in the T5 LSA */
    ulng prevCost;
    t_S_AsExternalLsa* lsaForRoute;
    Bool  preferNewRte = FALSE;
-
-   if (!p_PreferRte)
-     return E_FAILED;
-
    /* forwarding address advertised in the LSA for the destination network. */
    SP_IPADR fwdingAddr = 0;
 
    /* Address to use as next hop to destination. Set to the forwarding
     * address if the forwarding address is on a local subnet. Otherwise,
     * the next hop address is copied from the route to the ASBR/forwarding address */
    SP_IPADR nextHopAddr = 0;
    SP_IPADR rtEntryFwdAddr;
 
+   if (!p_PreferRte)
+     return E_FAILED;
+
    p_AsExtLsa = (t_S_AsExternalLsa *)p_DbEntry->p_Lsa;
 
    if(p_DbEntry->Lsa.LsType == S_NSSA_LSA)
      p_ARO     = (t_ARO *)p_DbEntry->ARO_Id;
 
    fwdingAddr = A_GET_4B(p_AsExtLsa->ForwardingAddress);
@@ -5866,15 +5865,16 @@ static e_Err RTB_RtoUpdate(void *p_Info)
     if (p_RTO->BundleLsas)
       LsUpdatesSend(p_RTO);
 
     /* not done yet? */
     if (e == E_BUSY)
     {
+      t_XXCallInfo *callData = 0;
+
       /* Schedule an event, this gives OSPF a chance to service its queues */
       p_RTB->spfWaitForRto++;
-      t_XXCallInfo *callData = 0;
       PACKET_INIT_MQUEUE(callData, RTB_RtoUpdate, 0, 0, OSPF_EVENT_QUEUE, 1, (ulng)p_RTB);
       ASSERT(callData);
       if (XX_Call(p_RTO->OspfRtbThread.threadHndle, callData) != E_OK)
       {
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_OSPF_MAP_COMPONENT_ID,
                "Failed to complete routing table update.");
Index: src/application/routing/protocol/ospf/sprto.c
===================================================================
--- src/application/routing/protocol/ospf/sprto.c	(revision 7746)
+++ src/application/routing/protocol/ospf/sprto.c	(revision 7747)
@@ -2315,13 +2315,13 @@ e_Err LsaRxmtTickExp(t_RTO * p_RTO)
  * @end
  * ********************************************************************/
 void o2UpdateStats(t_RTO *p_RTO)
 {
   L7_uint32 index = p_RTO->statsIndex;
   L7_uint32 prevIndex = (index == 0) ? O2_STATS_SIZE - 1 : index - 1;
-  L7_uint32 rxDelta;;
+  L7_uint32 rxDelta;
   L7_uint32 txDelta;
 
   /* Record current stats */
   p_RTO->lsuRxStats[index] = p_RTO->RxLsUpdate;
   p_RTO->lsuTxStats[index] = p_RTO->TxLsUpdate;
 
Index: src/application/routing/protocol/ospf/sparo.c
===================================================================
--- src/application/routing/protocol/ospf/sparo.c	(revision 7746)
+++ src/application/routing/protocol/ospf/sparo.c	(revision 7747)
@@ -2231,13 +2231,13 @@ e_Err ARO_OpaqueLsdbNextEntry(t_Handle R
 {
   e_Err          e;
   t_A_DbEntry    *p_Entry = NULL;
   t_A_DbKey      currentKey;
   t_RTO *p_RTO = (t_RTO*) RTO_Id;
   t_ARO *p_ARO = (t_ARO*) ARO_Id;
-  t_IFO *p_IFO = (t_IFO*) IFO_Id;;
+  t_IFO *p_IFO = (t_IFO*) IFO_Id;
   t_Handle       OpaqueLsaHl;
   ulng           nextIpAddr;
   ulng           nextIfIndex;
 
   if ((p_Lsa->LsdbType != S_LINK_OPAQUE_LSA) &&
       (p_Lsa->LsdbType != S_AREA_OPAQUE_LSA) &&
@@ -5066,35 +5066,38 @@ static e_Err LsaOrgRouter(t_Handle Id, u
   e_Err         e, err;
   word          links = 0;
   SP_IPADR      router_id = p_RTO->Cfg.RouterId;
   Bool          isBdrRtr = FALSE, isNssaRtr = FALSE;
   byte Option = 0;
   Bool forceOrig = (prm != 0);
+  ulng maxRtrLsaLen;
+  byte *pktEnd;
+  Bool lsaFull;
 
   /* if in graceful restart, don't originate */
   if (o2GracefulRestartInProgress(p_RTO))
   {
     return E_OK;
   }
 
   /* Max length router LSA. Does not include common LSA header. Even though
    * this routine does not build an IP header or standard OSPF or LSA headers,
    * we have to leave room for them. Also must leave room for MD5 authentication
    * data in case any interface in the area runs MD5. */
 
-  ulng maxRtrLsaLen = GetMaxLsaLength(p_ARO, S_ROUTER_LSA) - 
-                      (IP_HDR_LEN + OSPF_MD5_AUTH_DATA_LEN + sizeof(t_S_PckHeader) +
-                       sizeof(t_S_LsUpdate) + sizeof(t_S_LsaHeader));
+  maxRtrLsaLen = GetMaxLsaLength(p_ARO, S_ROUTER_LSA) - 
+                 (IP_HDR_LEN + OSPF_MD5_AUTH_DATA_LEN + sizeof(t_S_PckHeader) +
+                 sizeof(t_S_LsUpdate) + sizeof(t_S_LsaHeader));
 
   /* First byte beyond end of packet. Cannot write to this location or beyond
    * or router LSA will be too big to fit in an LS Update in an IP packet of 
    * size OSPF_MAX_LSA_BUF_LEN. */
-  byte *pktEnd = NULL;
+  pktEnd = NULL;
 
   /* TRUE when the LSA is full */
-  Bool lsaFull = FALSE;
+  lsaFull = FALSE;
 
   if (!p_RTO->Cfg.AdminStat || !p_ARO->OperationState)
     return E_FAILED;
 
   p_ARO->IsRtrLsaOrg = TRUE;
 
@@ -5278,26 +5281,27 @@ static e_Err LsaOrgNetwork(t_Handle Id,
    void          *p_F     = NULLP;
    e_Err         er;
    word          nr = 0;
    t_A_DbKey     key;
    t_A_DbEntry   *former;
    Bool          lsaFull = FALSE;
+   ulng maxNetworkLsaLen;
 
    /* if in graceful restart, don't originate */
    if (o2GracefulRestartInProgress(p_RTO))
    {
      return E_OK;
    }
 
    /* Max length network LSA. Does not include common LSA header. Even though
     * this routine does not build an IP header or standard OSPF or LSA headers,
     * we have to leave room for them. Also must leave room for MD5 authentication
    * data in case any interface in the area runs MD5. */
-   ulng maxNetworkLsaLen = GetMaxLsaLength(p_ARO, S_NETWORK_LSA) - 
-                           (IP_HDR_LEN + OSPF_MD5_AUTH_DATA_LEN + sizeof(t_S_PckHeader) +
-                            sizeof(t_S_LsUpdate) + sizeof(t_S_LsaHeader));
+   maxNetworkLsaLen = GetMaxLsaLength(p_ARO, S_NETWORK_LSA) - 
+                      (IP_HDR_LEN + OSPF_MD5_AUTH_DATA_LEN + sizeof(t_S_PckHeader) +
+                      sizeof(t_S_LsUpdate) + sizeof(t_S_LsaHeader));
 
    if(!p_RTO->Cfg.AdminStat || !p_ARO->OperationState)
       return E_FAILED;
 
    /* Examine only broadcast and NBMA networks attached to this Area */
    if((p_IFO->Cfg.Type != IFO_BRDC) && (p_IFO->Cfg.Type != IFO_NBMA))
Index: src/application/routing/protocol/ospf/sphlp.c
===================================================================
--- src/application/routing/protocol/ospf/sphlp.c	(revision 7746)
+++ src/application/routing/protocol/ospf/sphlp.c	(revision 7747)
@@ -49,23 +49,25 @@ extern struct ospfMapCtrl_s  ospfMapCtrl
 * @end
 *********************************************************************/
 e_Err o2GraceLsaProcess(t_NBO *p_NBO, t_A_DbEntry *p_DbEntry)
 {
   t_RTO *p_RTO = (t_RTO*) p_NBO->RTO_Id;
   L7_BOOL alreadyRestarting = o2NeighborIsRestarting(p_NBO);
+  L7_int32 timeRemaining;
+  L7_uint32 graceLsaAge;
 
   /* Ignore our own grace LSAs. We may get these back during 
    * db exchange when we do a graceful restart. */
   if (A_GET_4B(p_DbEntry->Lsa.AdvertisingRouter) == p_RTO->Cfg.RouterId)
   {
     return E_OK;
   }
 
   /* Number of seconds left in grace period */
-  L7_int32 timeRemaining = 0;
-  L7_uint32 graceLsaAge = A_GET_2B(p_DbEntry->Lsa.LsAge);
+  timeRemaining = 0;
+  graceLsaAge = A_GET_2B(p_DbEntry->Lsa.LsAge);
 
   p_RTO->grStats.helpfulNbrStats.graceLsasReceived++;
   if (graceLsaAge >= MaxAge)
   {
     if (alreadyRestarting)
     {
Index: src/application/routing/rlim/rlim_debug.c
===================================================================
--- src/application/routing/rlim/rlim_debug.c	(revision 7746)
+++ src/application/routing/rlim/rlim_debug.c	(revision 7747)
@@ -340,17 +340,17 @@ L7_RC_t rlimDebugShow()
   RLIM_MASK_FLBIT(tnnlMask, tunnelId);
   RLIM_MASK_NONZERO(tnnlMask, entryFound);
 
   sysapiPrintf("Configured Tunnel interfaces:\n");
   while (entryFound)
   {
+    rlimTunnelCfgData_t *tcp = &rlimCfgData->tunnelCfgData[tunnelId];
+
     if (tunnelId > RLIM_MAX_TUNNEL_ID)
       break;
 
-    rlimTunnelCfgData_t *tcp = &rlimCfgData->tunnelCfgData[tunnelId];
-
     sysapiPrintf("    tunnel%u\n", tunnelId);
     sysapiPrintf("        mode: %s\n", rlimTunnelModeString(tcp->tunnelMode));
 
     sysapiPrintf("        local addr: ");
     rlimAddrPrint(&tcp->localAddr);
     sysapiPrintf("\n");
Index: src/application/routing/mapping/ipmap/core/ip_util.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ip_util.c	(revision 7746)
+++ src/application/routing/mapping/ipmap/core/ip_util.c	(revision 7747)
@@ -1555,13 +1555,13 @@ static L7_RC_t ipMapIntfDisable(L7_uint3
     pCfg->flags &= ~(L7_RTR_INTF_HOST);
   }
 
   return rc;
 }
 
-L7_RC_t ptin_ipMapRoutingIntfCreate(intIfNum)
+L7_RC_t ptin_ipMapRoutingIntfCreate(L7_uint32 intIfNum)
 {
   return ipMapRoutingIntfCreate(intIfNum);
 }
 
 /*********************************************************************
 * @purpose  Check the state of an interface and determine whether the
@@ -3135,16 +3135,16 @@ L7_RC_t ipMapRtrIntfSecondaryIpAddressAp
                                             L7_uint32 ipMask, L7_uint32 index)
 {
     L7_rtrCfgCkt_t *pCfg;
     L7_routeEntry_t routeEntry;
     L7_RC_t rc;
     L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-    nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
-
     static const char *routine_name = "ipMapRtrIntfSecondaryIpAddressApply()";
 
+    nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
+
     IPMAP_TRACE("%s %d: %s : intf %d, %s\n",
                 __FILE__, __LINE__, routine_name, intIfNum, ifName);
 
     /* Check input values */
     if ((ipAddr == L7_NULL_IP_ADDR) || (ipMask == L7_NULL_IP_MASK))
     {
@@ -3426,50 +3426,52 @@ void ipMapRtrIntfStaticConfigApply(L7_ui
 *
 * @end
 *********************************************************************/
 L7_RC_t ipMapRtrIntfSecondaryIpAddressRemoveApply(L7_uint32 intIfNum, L7_uint32 ipAddr,
                                                   L7_uint32 ipMask, L7_uint32 index)
 {
-    L7_routeEntry_t routeEntry;
+  L7_routeEntry_t routeEntry;
   L7_rtrCfgCkt_t *pCfg;
 
   if (!ipMapMapIntfIsConfigurable(intIfNum, &pCfg))
+  {
     return L7_FAILURE;
+  }
 
-    if (ipMapTraceFlags & IPMAP_TRACE_SECONDARY)
-    {
-        L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
-        sprintf(traceBuf, "ipMapRtrIntfSecondaryIpAddressRemoveApply: intIfNum %d\n",
-            intIfNum);
-        ipMapTraceWrite(traceBuf);
-    }
+  if (ipMapTraceFlags & IPMAP_TRACE_SECONDARY)
+  {
+      L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
+      sprintf(traceBuf, "ipMapRtrIntfSecondaryIpAddressRemoveApply: intIfNum %d\n",
+          intIfNum);
+      ipMapTraceWrite(traceBuf);
+  }
 
   /* De-activate static routes and static ARP entries on this subnet. */
   ipMapRtrIntfStaticConfigRemoveApply(intIfNum, ipAddr, ipMask);
 
-    /* Remove the secondary address from the IP stack */
-    if (ipmRouterIfSecondaryAddrDelete(intIfNum, ipAddr, ipMask, index) != L7_SUCCESS)
-    {
-        if (ipMapTraceFlags & IPMAP_TRACE_SECONDARY)
-        {
-            L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
-            sprintf(traceBuf, "ipMapRtrIntfSecondaryIpAddressRemoveApply: "
-              "Failed to remove address from IP stack.\n");
-            ipMapTraceWrite(traceBuf);
-        }
-        return L7_FAILURE;
-    }
+  /* Remove the secondary address from the IP stack */
+  if (ipmRouterIfSecondaryAddrDelete(intIfNum, ipAddr, ipMask, index) != L7_SUCCESS)
+  {
+      if (ipMapTraceFlags & IPMAP_TRACE_SECONDARY)
+      {
+          L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
+          sprintf(traceBuf, "ipMapRtrIntfSecondaryIpAddressRemoveApply: "
+            "Failed to remove address from IP stack.\n");
+          ipMapTraceWrite(traceBuf);
+      }
+      return L7_FAILURE;
+  }
 
-    memset(&routeEntry, 0x00, sizeof(L7_routeEntry_t));
-    routeEntry.ipAddr      = (ipAddr & ipMask);
-    routeEntry.subnetMask  = ipMask;
-    routeEntry.protocol    = RTO_LOCAL;
-    routeEntry.metric      = FD_RTR_ROUTE_LOCAL_COST;
-    routeEntry.ecmpRoutes.equalCostPath[0].arpEntry.ipAddr = ipAddr;
-    routeEntry.ecmpRoutes.numOfRoutes = 1;
-    rtoRouteDelete(&routeEntry);
+  memset(&routeEntry, 0x00, sizeof(L7_routeEntry_t));
+  routeEntry.ipAddr      = (ipAddr & ipMask);
+  routeEntry.subnetMask  = ipMask;
+  routeEntry.protocol    = RTO_LOCAL;
+  routeEntry.metric      = FD_RTR_ROUTE_LOCAL_COST;
+  routeEntry.ecmpRoutes.equalCostPath[0].arpEntry.ipAddr = ipAddr;
+  routeEntry.ecmpRoutes.numOfRoutes = 1;
+  rtoRouteDelete(&routeEntry);
 
   if (ipMapIntfSupports(intIfNum, IPMAP_INTFCAP_ARP) == L7_TRUE)
   {
     /* Unregister the address with ARP code */
     if (ipMapArpSecondaryIpAddrUnregister(intIfNum, pCfg->addrs[0].ipAddr,
                                           ipAddr, ipMask) != L7_SUCCESS)
@@ -3484,17 +3486,17 @@ L7_RC_t ipMapRtrIntfSecondaryIpAddressRe
               "Failed to deregister secondary address %s/%s on interface %s with ARP.",
               ipAddrStr, ipMaskStr, ifName);
               return L7_FAILURE;
     }
   }
 
-    /* Notify registered users of deletion event. Not asynchronous. */
-    ipMapRoutingEventChangeNotify(intIfNum, L7_RTR_INTF_SECONDARY_IP_ADDR_DELETE,
+  /* Notify registered users of deletion event. Not asynchronous. */
+  ipMapRoutingEventChangeNotify(intIfNum, L7_RTR_INTF_SECONDARY_IP_ADDR_DELETE,
                                 L7_FALSE, L7_NULLPTR);
 
-    return L7_SUCCESS;
+  return L7_SUCCESS;
 }
 
 /*********************************************************************
 * @purpose  Removes the static configuration for the specified subnet
 *
 * @param    intIfNum @b{(input)} Internal interface number for address/mask
Index: src/application/security/dot1x/core/dot1x_db.c
===================================================================
--- src/application/security/dot1x/core/dot1x_db.c	(revision 7746)
+++ src/application/security/dot1x/core/dot1x_db.c	(revision 7747)
@@ -564,16 +564,17 @@ dot1xAuthHistoryLogInfo_t *dot1xAuthHist
  * *
  * * @end
  * *********************************************************************/
 L7_RC_t dot1xAuthHistoryLogInfoDeAlloc(dot1xAuthHistoryLogInfo_t *node)
 {
   dot1xAuthHistoryLogTableDb_t *pHistoryLogDb;
-  pHistoryLogDb = &dot1xAuthHistoryLogDb;
   dot1xAuthHistoryLogInfo_t *pData=L7_NULLPTR;
   L7_RC_t rc = L7_FAILURE;
 
+  pHistoryLogDb = &dot1xAuthHistoryLogDb;
+
   if(node != L7_NULLPTR)
   {
     pData = avlDeleteEntry(&pHistoryLogDb->dot1xAuthHistoryAvlTree, node);
     if (pData == L7_NULL)
     {
       /* Entry does not exist */
Index: src/application/base/dos/dos_util.c
===================================================================
--- src/application/base/dos/dos_util.c	(revision 7746)
+++ src/application/base/dos/dos_util.c	(revision 7747)
@@ -112,17 +112,17 @@ L7_BOOL dosMapIntfIsConfigurable(L7_uint
 * @end
 *********************************************************************/
 L7_BOOL dosMapIntfConfigEntryGet(L7_uint32 intIfNum, dosIntfCfgData_t **pCfg)
 {
   L7_uint32 i;
   nimConfigID_t configIdNull;
+  /* Avoid N^2 processing when interfaces created at startup */
+  static L7_uint32 nextIndex = 1;
 
   memset(&configIdNull, 0, sizeof(nimConfigID_t));
 
-  /* Avoid N^2 processing when interfaces created at startup */
-  static L7_uint32 nextIndex = 1;
 
   if (!(DOSCONTROL_IS_READY))
     return L7_FALSE;
 
   if (nextIndex < L7_DOS_MAX_INTF)
   {
Index: src/application/base/isdp/isdp_txrx.c
===================================================================
--- src/application/base/isdp/isdp_txrx.c	(revision 7746)
+++ src/application/base/isdp/isdp_txrx.c	(revision 7747)
@@ -296,24 +296,25 @@ L7_RC_t isdpTcnTx(L7_uint32 intIfNum, L7
   isdpPacket_t        *pdu      = L7_NULLPTR;
   L7_uchar8           *pduStart = L7_NULLPTR;
   L7_enetHeader_t     *enetHdr  = L7_NULLPTR;
   L7_netBufHandle     bufHandle = L7_NULL;
   L7_RC_t             rc        = L7_SUCCESS;
   L7_uchar8           ifName[L7_NIM_IFNAME_SIZE + 1];
+  isdpEntry_t         *pEntry = L7_NULLPTR;
+  isdpEntryKey_t      key;
 #ifdef L7_ROUTING_PACKAGE
   L7_IP_ADDR_t        ipAddress = 0;
   L7_IP_MASK_t        mask      = 0;
   L7_uint32           vlanId    = L7_NULL;
   L7_uint32           vlanIntIfNum = L7_NULL;
   L7_BOOL             vlanParticipate = L7_TRUE;
   L7_uint32           mode            = L7_NULL;
   L7_VLAN_MASK_t vidMask;
+
   memset(&vidMask, L7_NULL, sizeof(L7_VLAN_MASK_t));
 #endif /* L7_ROUTING_PACKAGE */
-  isdpEntry_t         *pEntry = L7_NULLPTR;
-  isdpEntryKey_t      key;
 
   memset(ifName, 0, sizeof(ifName));
 
   SYSAPI_NET_MBUF_GET(bufHandle);
   if (bufHandle == L7_NULL)
   {
Index: src/application/ptin/base/ptin_intf.c
===================================================================
--- src/application/ptin/base/ptin_intf.c	(revision 7746)
+++ src/application/ptin/base/ptin_intf.c	(revision 7747)
@@ -5074,24 +5074,25 @@ L7_RC_t ptin_QoS_intf_config_set(const p
     /* Do nothing */
     PT_LOG_WARN(LOG_CTX_INTF, "Bandwidth units were not changed");
   }
   /* Shaping rate */
   if (intfQos->mask & PTIN_QOS_INTF_SHAPINGRATE_MASK)
   {
+    ptin_intf_shaper_t   entry;
+
     PT_LOG_NOTICE(LOG_CTX_INTF, "New shaping rate is %u", intfQos->shaping_rate);
 
     if(intfQos->shaping_rate == 0)
     {
       intfQos->shaping_rate = 100;
     }
 
     PT_LOG_TRACE(LOG_CTX_INTF, "ptin_intf_shaper_max[ptin_port][PTIN_INTF_SHAPER_MAX_VALUE] = %u",ptin_intf_shaper_max[ptin_port][PTIN_INTF_SHAPER_MAX_VALUE]);
     PT_LOG_TRACE(LOG_CTX_INTF, "intfQos->shaping_rate = %u",intfQos->shaping_rate);
 
     //rc = usmDbQosCosQueueIntfShapingRateSet(1, intIfNum, (intfQos->shaping_rate * ptin_intf_shaper_max[ptin_port][PTIN_INTF_SHAPER_MAX_VALUE])/100);
-    ptin_intf_shaper_t   entry;
 
     memset(&entry, 0x00, sizeof(ptin_intf_shaper_t));
 
     entry.ptin_port  = ptin_port;
     entry.burst_size = ptin_burst_size[ptin_port]; 
 
Index: src/application/ptin/base/ptin_xlate_api.c
===================================================================
--- src/application/ptin/base/ptin_xlate_api.c	(revision 7746)
+++ src/application/ptin/base/ptin_xlate_api.c	(revision 7747)
@@ -558,12 +558,13 @@ L7_RC_t ptin_xlate_ingress_get( L7_uint3
  * 
  * @return L7_RC_t : L7_SUCCESS or L7_FAILURE
  */
 L7_RC_t ptin_xlate_ingress_get_originalVlan( L7_uint32 intIfNum, L7_uint16 *outerVlanId, L7_uint16 *innerVlanId,
                                              L7_uint16 newOuterVlanId, L7_uint16 newInnerVlanId )
 {
+  ptin_vlanXlate_t xlate;
   L7_uint16 oldOuterVid, oldInnerVid;
   L7_RC_t rc = L7_SUCCESS;
 
   if (ptin_debug_xlate)
     PT_LOG_TRACE(LOG_CTX_XLATE, "intIfNum=%u, newOuterVlanId=%u, newInnerVlanId=%u",
               intIfNum, newOuterVlanId, newInnerVlanId);
@@ -576,14 +577,12 @@ L7_RC_t ptin_xlate_ingress_get_originalV
   }
 
   /* Initialize new Vlan... as 0 (invalid value) */
   oldOuterVid = PTIN_XLATE_NOT_DEFINED;
   oldInnerVid = PTIN_XLATE_NOT_DEFINED;
 
-  ptin_vlanXlate_t xlate;
-
   memset(&xlate, 0x00, sizeof(ptin_vlanXlate_t));
   xlate.stage         = PTIN_XLATE_STAGE_INGRESS;
   xlate.portgroup     = PTIN_XLATE_PORTGROUP_INTERFACE;
   xlate.outerVlan_new = newOuterVlanId;
   xlate.innerVlan_new = newInnerVlanId;
 
@@ -1170,12 +1169,13 @@ L7_RC_t ptin_xlate_egress_get( L7_uint32
  */
 L7_RC_t ptin_xlate_egress_get_originalVlan( L7_uint32 intIfNum, L7_uint16 *outerVlanId, L7_uint16 *innerVlanId,
                                             L7_uint16 newOuterVlanId, L7_uint16 newInnerVlanId )
 {
   L7_uint32 class_id;
   L7_uint16 oldOuterVid, oldInnerVid;
+  ptin_vlanXlate_t xlate;
   L7_RC_t rc = L7_SUCCESS;
 
   if (ptin_debug_xlate)
     PT_LOG_TRACE(LOG_CTX_XLATE, "intIfNum=%u, newOuterVlanId=%u, newInnerVlanId=%u",
               intIfNum, newOuterVlanId, newInnerVlanId);
 
@@ -1199,14 +1199,12 @@ L7_RC_t ptin_xlate_egress_get_originalVl
   }
 
   /* Initialize new Vlan... as 0 (invalid value) */
   oldOuterVid = PTIN_XLATE_NOT_DEFINED;
   oldInnerVid = PTIN_XLATE_NOT_DEFINED;
 
-  ptin_vlanXlate_t xlate;
-
   memset(&xlate, 0x00, sizeof(ptin_vlanXlate_t));
   xlate.stage         = PTIN_XLATE_STAGE_EGRESS;
   xlate.portgroup     = class_id;
   xlate.outerVlan_new = newOuterVlanId;
   xlate.innerVlan_new = newInnerVlanId;
 
Index: src/application/ptin/base/ptin_l2.c
===================================================================
--- src/application/ptin/base/ptin_l2.c	(revision 7746)
+++ src/application/ptin/base/ptin_l2.c	(revision 7747)
@@ -64,118 +64,120 @@ L7_RC_t ptin_l2_learn_event(L7_uchar8 *m
 
   PT_LOG_TRACE(LOG_CTX_L2, "Processing vlan %u, MAC=%02x:%02x:%02x:%02x:%02x:%02x, intIfNum %u, vport 0x%x",
             vlanId, macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5],
             intIfNum, virtual_port);
 
 #if PTIN_QUATTRO_FLOWS_FEATURE_ENABLED
-  ptin_bw_profile_t profile;
-  ptin_bw_meter_t   meter;
-  L7_RC_t           rc = L7_SUCCESS;
-  intf_vp_entry_t   vp_entry;
-
-  /* Search for this entry */
-  memset(&vp_entry, 0x00, sizeof(vp_entry));
-  vp_entry.vport_id = virtual_port & 0xffffff;
-
-  if (intf_vp_DB(3, &vp_entry) != 0)
   {
-    PT_LOG_WARN(LOG_CTX_L2, "Virtual port 0x%08x does not exist!", virtual_port);
-    return L7_FAILURE;
-  }
+    ptin_bw_profile_t profile;
+    ptin_bw_meter_t   meter;
+    L7_RC_t           rc = L7_SUCCESS;
+    intf_vp_entry_t   vp_entry;
+
+    /* Search for this entry */
+    memset(&vp_entry, 0x00, sizeof(vp_entry));
+    vp_entry.vport_id = virtual_port & 0xffffff;
 
-#if 0
-  /* virtual ports (NGPON2) */
-  L7_uint32         position = 0;
+    if (intf_vp_DB(3, &vp_entry) != 0)
+    {
+      PT_LOG_WARN(LOG_CTX_L2, "Virtual port 0x%08x does not exist!", virtual_port);
+      return L7_FAILURE;
+    }
 
-  if (msgsType == ADD_MAC) /* Write a new MAC in a opensaf checkpoint */
-  {
-    PT_LOG_ERR(LOG_CTX_L2, "Msgtype %d", msgsType);
-    //ptin_opensaf_find_free_element(&position, vp_entry.onu, SWITCHDRVR_ONU /* checkpoint id */);
+  #if 0
+    /* virtual ports (NGPON2) */
+    L7_uint32         position = 0;
 
-    PT_LOG_ERR(LOG_CTX_L2, "Data position to write %d", position);
+    if (msgsType == ADD_MAC) /* Write a new MAC in a opensaf checkpoint */
+    {
+      PT_LOG_ERR(LOG_CTX_L2, "Msgtype %d", msgsType);
+      //ptin_opensaf_find_free_element(&position, vp_entry.onu, SWITCHDRVR_ONU /* checkpoint id */);
 
-    /* find NGPON2 Group*/
-    ptin_opensaf_write_checkpoint(macAddr, MAC_SIZE_BYTES, vp_entry.onu , position, SWITCHDRVR_ONU, ADD_MAC);
-  }
-  else /* Remove MAC from opensaf checkpoint (fill with 0's) */
-  {
-    L7_uchar8 macAddr_aux[MAC_SIZE_BYTES] ="";
-    
-    PT_LOG_ERR(LOG_CTX_L2, "Msgtype %d", msgsType);
+      PT_LOG_ERR(LOG_CTX_L2, "Data position to write %d", position);
 
-    if(ptin_checkpoint_findDatainSection(SWITCHDRVR_ONU, vp_entry.onu, macAddr, MAC_SIZE_BYTES, &position) == 0) /* Find if the MAC is in opensaf and get is position in the section*/
-    {
       /* find NGPON2 Group*/
-      ptin_opensaf_write_checkpoint(macAddr_aux, MAC_SIZE_BYTES, vp_entry.onu, position, SWITCHDRVR_ONU, REMOVE_MAC);
+      ptin_opensaf_write_checkpoint(macAddr, MAC_SIZE_BYTES, vp_entry.onu , position, SWITCHDRVR_ONU, ADD_MAC);
     }
-    else
+    else /* Remove MAC from opensaf checkpoint (fill with 0's) */
     {
-      PT_LOG_ERR(LOG_CTX_L2, "MAC not present in opensaf ");
+      L7_uchar8 macAddr_aux[MAC_SIZE_BYTES] ="";
+      
+      PT_LOG_ERR(LOG_CTX_L2, "Msgtype %d", msgsType);
+
+      if(ptin_checkpoint_findDatainSection(SWITCHDRVR_ONU, vp_entry.onu, macAddr, MAC_SIZE_BYTES, &position) == 0) /* Find if the MAC is in opensaf and get is position in the section*/
+      {
+        /* find NGPON2 Group*/
+        ptin_opensaf_write_checkpoint(macAddr_aux, MAC_SIZE_BYTES, vp_entry.onu, position, SWITCHDRVR_ONU, REMOVE_MAC);
+      }
+      else
+      {
+        PT_LOG_ERR(LOG_CTX_L2, "MAC not present in opensaf ");
+      }
     }
-  }
-#endif /*OPENSAF_SUPPORTED*/
+  #endif /*OPENSAF_SUPPORTED*/
 
 
-  /* If no policer associated, there is nothing to be done! */
-  if (!vp_entry.policer.in_use || vp_entry.policer.meter.cir == (L7_uint32)-1)
-  {
-    return L7_SUCCESS;
-  }
+    /* If no policer associated, there is nothing to be done! */
+    if (!vp_entry.policer.in_use || vp_entry.policer.meter.cir == (L7_uint32)-1)
+    {
+      return L7_SUCCESS;
+    }
 
-  /* Fill structure for policer */
-  memset(&profile, 0x00, sizeof(profile));
-  memset(&meter, 0x00, sizeof(meter));
-  profile.ptin_port           = -1;
-  profile.outer_vlan_ingress  = vlanId;
-  profile.cos                 = (L7_uint8) -1;
-  memcpy(profile.macAddr, macAddr, sizeof(L7_uint8)*L7_MAC_ADDR_LEN);
+    /* Fill structure for policer */
+    memset(&profile, 0x00, sizeof(profile));
+    memset(&meter, 0x00, sizeof(meter));
+    profile.ptin_port           = -1;
+    profile.outer_vlan_ingress  = vlanId;
+    profile.cos                 = (L7_uint8) -1;
+    memcpy(profile.macAddr, macAddr, sizeof(L7_uint8)*L7_MAC_ADDR_LEN);
 
-  if (msgsType == FDB_ADD)
-  {
-    PT_LOG_TRACE(LOG_CTX_L2, "ADD event: MAC=%02x:%02x:%02x:%02x:%02x:%02x VLAN=%u intIfNum=%u virtual_port=0x%08x",
-              macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5], vlanId, intIfNum, virtual_port);
+    if (msgsType == FDB_ADD)
+    {
+      PT_LOG_TRACE(LOG_CTX_L2, "ADD event: MAC=%02x:%02x:%02x:%02x:%02x:%02x VLAN=%u intIfNum=%u virtual_port=0x%08x",
+                macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5], vlanId, intIfNum, virtual_port);
 
-    /* Add policer */
-    meter.cir = vp_entry.policer.meter.cir;
-    meter.eir = vp_entry.policer.meter.eir;
-    meter.cbs = vp_entry.policer.meter.cbs;
-    meter.ebs = vp_entry.policer.meter.ebs;
-  }
-  else if (msgsType == FDB_DEL)
-  {
-    PT_LOG_TRACE(LOG_CTX_L2, "DEL event: MAC=%02x:%02x:%02x:%02x:%02x:%02x VLAN=%u intIfNum=%u virtual_port=0x%08x",
-              macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5], vlanId, intIfNum, virtual_port);
+      /* Add policer */
+      meter.cir = vp_entry.policer.meter.cir;
+      meter.eir = vp_entry.policer.meter.eir;
+      meter.cbs = vp_entry.policer.meter.cbs;
+      meter.ebs = vp_entry.policer.meter.ebs;
+    }
+    else if (msgsType == FDB_DEL)
+    {
+      PT_LOG_TRACE(LOG_CTX_L2, "DEL event: MAC=%02x:%02x:%02x:%02x:%02x:%02x VLAN=%u intIfNum=%u virtual_port=0x%08x",
+                macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5], vlanId, intIfNum, virtual_port);
 
-    /* Remove policer */
-    meter.cir = (L7_uint32) -1;
-    meter.eir = (L7_uint32) -1;
-    meter.cbs = (L7_uint32) -1;
-    meter.ebs = (L7_uint32) -1;
-  }
-  else
-  {
-    PT_LOG_ERR(LOG_CTX_L2, "Unknown operation type %u", msgsType);
-    rc = L7_FAILURE;
-  }
+      /* Remove policer */
+      meter.cir = (L7_uint32) -1;
+      meter.eir = (L7_uint32) -1;
+      meter.cbs = (L7_uint32) -1;
+      meter.ebs = (L7_uint32) -1;
+    }
+    else
+    {
+      PT_LOG_ERR(LOG_CTX_L2, "Unknown operation type %u", msgsType);
+      rc = L7_FAILURE;
+    }
 
-  PT_LOG_TRACE(LOG_CTX_L2, "Going to configure policer");
+    PT_LOG_TRACE(LOG_CTX_L2, "Going to configure policer");
 
-  /* Apply policer */
-  if (ptin_bwPolicer_set(&profile, &meter, vp_entry.policer.policer_id) != L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_L2, "Error applying profile");
-    rc = L7_FAILURE;
-  }
+    /* Apply policer */
+    if (ptin_bwPolicer_set(&profile, &meter, vp_entry.policer.policer_id) != L7_SUCCESS)
+    {
+      PT_LOG_ERR(LOG_CTX_L2, "Error applying profile");
+      rc = L7_FAILURE;
+    }
 
-  if (rc != L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_L2, "Error occurred");
-    return rc;
-  }
+    if (rc != L7_SUCCESS)
+    {
+      PT_LOG_ERR(LOG_CTX_L2, "Error occurred");
+      return rc;
+    }
 
-  PT_LOG_TRACE(LOG_CTX_L2, "Policer configured successfully");
+    PT_LOG_TRACE(LOG_CTX_L2, "Policer configured successfully");
+  }
 #endif
 
   return L7_SUCCESS;
 }
 
 /**
Index: src/application/ptin/base/ptin_ipdtl0_packet.c
===================================================================
--- src/application/ptin/base/ptin_ipdtl0_packet.c	(revision 7746)
+++ src/application/ptin/base/ptin_ipdtl0_packet.c	(revision 7747)
@@ -143,12 +143,14 @@ static void ptin_ipdtl0_task(void)
             }
             printf("\r\n");
             #endif
 
             if (msg.msgId == PTIN_IPDTL0_PACKET_MESSAGE_ID)
             {
+                sysnet_pdu_info_t pduInfo;
+
                 if (ptin_ipdtl0_debug_enable)
                 {
                     PT_LOG_TRACE(LOG_CTX_API, "Packet received: intIfNum %d, vlanId %d, innerVlanId %d, payloadLen %d, Rx TS %lu\n", 
                            msg.intIfNum, msg.vlanId, msg.innerVlanId, msg.payloadLen, msg.timestamp);
                 
                     #ifdef _PAYLOAD_DEBUG_
@@ -166,14 +168,12 @@ static void ptin_ipdtl0_task(void)
                         printf(" %02X", msg.payload[i]);
                     }
                     printf("\n\n\r");
                     #endif
                 }
 
-                sysnet_pdu_info_t       pduInfo;
-
                 bzero((char *)&pduInfo, sizeof(sysnet_pdu_info_t));
                 pduInfo.intIfNum = msg.intIfNum;
                 pduInfo.rxPort = msg.intIfNum;
                 pduInfo.vlanId = msg.vlanId;
                 pduInfo.timestamp = msg.timestamp;
 
Index: src/application/ptin/base/ptin_msg.c
===================================================================
--- src/application/ptin/base/ptin_msg.c	(revision 7746)
+++ src/application/ptin/base/ptin_msg.c	(revision 7747)
@@ -4754,62 +4754,62 @@ L7_RC_t ptin_msg_l2_macTable_get(msg_swi
     mac_table->entry[i].addr[2] = (L7_uint8) ((macAddr>>24) & 0xff);
     mac_table->entry[i].addr[3] = (L7_uint8) ((macAddr>>16) & 0xff);
     mac_table->entry[i].addr[4] = (L7_uint8) ((macAddr>>8) & 0xff);
     mac_table->entry[i].addr[5] = (L7_uint8) (macAddr & 0xff);
   }
 #else
-
-  ptin_switch_mac_entry *entries_list;
-
-  /* Load table */
-  if (mac_table->intro.startEntryId==0)
   {
-    if (ptin_l2_mac_table_load()!=L7_SUCCESS)
+    ptin_switch_mac_entry *entries_list;
+
+    /* Load table */
+    if (mac_table->intro.startEntryId==0)
     {
-      PT_LOG_ERR(LOG_CTX_MSG,"Error loading table");
-      return L7_FAILURE;
+      if (ptin_l2_mac_table_load()!=L7_SUCCESS)
+      {
+        PT_LOG_ERR(LOG_CTX_MSG,"Error loading table");
+        return L7_FAILURE;
+      }
     }
-  }
 
-  /* Get input number of MAC itemns, and majorate them */
+    /* Get input number of MAC itemns, and majorate them */
 
-  numEntries = mac_table->intro.numEntries;
+    numEntries = mac_table->intro.numEntries;
 
-  if (numEntries>MSG_CMDGET_MAC_TABLE_MAXENTRIES)
-  {
-    numEntries = MSG_CMDGET_MAC_TABLE_MAXENTRIES;
-  }
-
-  /* Read table */
-  if (ptin_l2_mac_table_get(ENDIAN_SWAP32(mac_table->intro.startEntryId), &numEntries, &entries_list)!=L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_MSG,"Error getting MAC list");
-    return L7_FAILURE;
-  }
+    if (numEntries>MSG_CMDGET_MAC_TABLE_MAXENTRIES)
+    {
+      numEntries = MSG_CMDGET_MAC_TABLE_MAXENTRIES;
+    }
 
-  /* Copy MAC list to output message */
-  for (i=0; i<numEntries; i++)
-  {
-    memcpy(mac_table->entry[i].addr, entries_list[i].addr, sizeof(L7_uint8)*6);
-    mac_table->entry[i].evcId          = entries_list[i].evcId;
-    mac_table->entry[i].vlanId         = entries_list[i].vlanId;
-    mac_table->entry[i].intf.intf_type = entries_list[i].intf.intf_type;
-    mac_table->entry[i].intf.intf_id   = entries_list[i].intf.intf_id;
-    mac_table->entry[i].gem_id         = entries_list[i].gem_id;
-    mac_table->entry[i].static_entry   = entries_list[i].static_entry;
+    /* Read table */
+    if (ptin_l2_mac_table_get(ENDIAN_SWAP32(mac_table->intro.startEntryId), &numEntries, &entries_list)!=L7_SUCCESS)
+    {
+      PT_LOG_ERR(LOG_CTX_MSG,"Error getting MAC list");
+      return L7_FAILURE;
+    }
 
-    ENDIAN_SWAP32_MOD(mac_table->entry[i].evcId);
-    ENDIAN_SWAP16_MOD(mac_table->entry[i].vlanId);
-    ENDIAN_SWAP16_MOD(mac_table->entry[i].gem_id);
+    /* Copy MAC list to output message */
+    for (i=0; i<numEntries; i++)
+    {
+      memcpy(mac_table->entry[i].addr, entries_list[i].addr, sizeof(L7_uint8)*6);
+      mac_table->entry[i].evcId          = entries_list[i].evcId;
+      mac_table->entry[i].vlanId         = entries_list[i].vlanId;
+      mac_table->entry[i].intf.intf_type = entries_list[i].intf.intf_type;
+      mac_table->entry[i].intf.intf_id   = entries_list[i].intf.intf_id;
+      mac_table->entry[i].gem_id         = entries_list[i].gem_id;
+      mac_table->entry[i].static_entry   = entries_list[i].static_entry;
 
-  }
+      ENDIAN_SWAP32_MOD(mac_table->entry[i].evcId);
+      ENDIAN_SWAP16_MOD(mac_table->entry[i].vlanId);
+      ENDIAN_SWAP16_MOD(mac_table->entry[i].gem_id);
 
-  /* Update number of entries */
-  mac_table->intro.numEntries = numEntries;
-  ENDIAN_SWAP32_MOD(mac_table->intro.numEntries);
+    }
 
+    /* Update number of entries */
+    mac_table->intro.numEntries = numEntries;
+    ENDIAN_SWAP32_MOD(mac_table->intro.numEntries);
+  }
 #endif
 
   return L7_SUCCESS;
 }
 
 /**
@@ -11557,104 +11557,105 @@ L7_RC_t ptin_msg_IGMP_ChannelAssoc_get(m
   PT_LOG_DEBUG(LOG_CTX_MSG," EVC_MC = %d",channel_list->evcid_mc);
   PT_LOG_DEBUG(LOG_CTX_MSG," Entry_idx = %d",channel_list->entry_idx);
   PT_LOG_DEBUG(LOG_CTX_MSG," DstIP_Channel = 0x%08x (ipv6=%u) / %u",channel_list->channel_dstIp.addr.ipv4, channel_list->channel_dstIp.family, channel_list->channel_dstmask);
   PT_LOG_DEBUG(LOG_CTX_MSG," SrcIP_Channel = 0x%08x (ipv6=%u) / %u",channel_list->channel_srcIp.addr.ipv4, channel_list->channel_srcIp.family, channel_list->channel_srcmask);
 
 #ifdef IGMPASSOC_MULTI_MC_SUPPORTED
-  L7_uint16 i, i_start;
-  L7_uint16 number_of_channels;
-  L7_uint8  slotId;
-
-  /* For null entry idex, read and store all channels */
-  if (channel_list->entry_idx==0)
   {
-    /* Clear channel list */
-    memset(igmpAssoc_list, 0x00, sizeof(igmpAssoc_list));
-    igmpAssoc_channels_max = 0;
+    L7_uint16 i, i_start;
+    L7_uint16 number_of_channels;
+    L7_uint8  slotId;
 
-    number_of_channels = PTIN_IGMP_CHANNELS_MAX;
-    if (ptin_igmp_channel_list_get(0, channel_list->evcid_mc, igmpAssoc_list, &number_of_channels)!=L7_SUCCESS)
+    /* For null entry idex, read and store all channels */
+    if (channel_list->entry_idx==0)
     {
-      PT_LOG_ERR(LOG_CTX_MSG, "Error reading list of channels");
-      return L7_FAILURE;
-    }
-    /* Update number of channels */
-    igmpAssoc_channels_max = number_of_channels;
-  }
-
-  /* Save important data of input message */
-  slotId  = channel_list->SlotId;
-  i_start = channel_list->entry_idx;
+      /* Clear channel list */
+      memset(igmpAssoc_list, 0x00, sizeof(igmpAssoc_list));
+      igmpAssoc_channels_max = 0;
 
-  /* Determine max number of messages */
-  /* First index is beyond max index: no channels to retrieve */
-  if (i_start >= igmpAssoc_channels_max)
-  {
-    number_of_channels = 0;
-  }
-  /* Remaining channels, is lower than maximum message capacity */
-  else if ( (igmpAssoc_channels_max - i_start) < IGMPASSOC_MAX_CHANNELS_IN_MESSAGE )
-  {
-    number_of_channels = igmpAssoc_channels_max - i_start;
-  }
-  /* Use maximum capacity */
-  else
-  {
-    number_of_channels = IGMPASSOC_MAX_CHANNELS_IN_MESSAGE;
-  }
+      number_of_channels = PTIN_IGMP_CHANNELS_MAX;
+      if (ptin_igmp_channel_list_get(0, channel_list->evcid_mc, igmpAssoc_list, &number_of_channels)!=L7_SUCCESS)
+      {
+        PT_LOG_ERR(LOG_CTX_MSG, "Error reading list of channels");
+        return L7_FAILURE;
+      }
+      /* Update number of channels */
+      igmpAssoc_channels_max = number_of_channels;
+    }
 
-  for (i=0; i<=number_of_channels; i++)
-  {
-    /* Constant information to be replicated in all channels */
-    channel_list[i].SlotId    = slotId;
-    channel_list[i].entry_idx = i_start + i;
+    /* Save important data of input message */
+    slotId  = channel_list->SlotId;
+    i_start = channel_list->entry_idx;
 
-    /* Group address (prepared for IPv6) */
-    if ( igmpAssoc_list[i_start+i].groupAddr.family == L7_AF_INET6 )
+    /* Determine max number of messages */
+    /* First index is beyond max index: no channels to retrieve */
+    if (i_start >= igmpAssoc_channels_max)
     {
-      channel_list[i].channel_dstIp.family = PTIN_AF_INET6;
-      memcpy( channel_list[i].channel_dstIp.addr.ipv6, igmpAssoc_list[i_start+i].groupAddr.addr.ipv6.in6.addr8, sizeof(L7_uchar8)*16);
-      channel_list[i].channel_dstmask = 128;
+      number_of_channels = 0;
     }
-    else
-    {
-      channel_list[i].channel_dstIp.family = PTIN_AF_INET;
-      channel_list[i].channel_dstIp.addr.ipv4 = igmpAssoc_list[i_start+i].groupAddr.addr.ipv4.s_addr;
-      channel_list[i].channel_dstmask = 32;
-    }
-
-    /* Source address (prepared for IPv6) */
-    if ( igmpAssoc_list[i_start+i].sourceAddr.family == L7_AF_INET6 )
+    /* Remaining channels, is lower than maximum message capacity */
+    else if ( (igmpAssoc_channels_max - i_start) < IGMPASSOC_MAX_CHANNELS_IN_MESSAGE )
     {
-      channel_list[i].channel_srcIp.family = PTIN_AF_INET6;
-      memcpy( channel_list[i].channel_srcIp.addr.ipv6, igmpAssoc_list[i_start+i].sourceAddr.addr.ipv6.in6.addr8, sizeof(L7_uchar8)*16);
-      channel_list[i].channel_srcmask = 128;
+      number_of_channels = igmpAssoc_channels_max - i_start;
     }
+    /* Use maximum capacity */
     else
     {
-      channel_list[i].channel_srcIp.family = PTIN_AF_INET;
-      channel_list[i].channel_srcIp.addr.ipv4 = igmpAssoc_list[i_start+i].sourceAddr.addr.ipv4.s_addr;
-      channel_list[i].channel_srcmask = 32;
+      number_of_channels = IGMPASSOC_MAX_CHANNELS_IN_MESSAGE;
     }
 
-    //channel_list[i].???       = igmpAssoc_list[i_start+i].evc_uc;
-    channel_list[i].evcid_mc  = igmpAssoc_list[i_start+i].evc_mc;
-    //channel_list[i].???       = igmpAssoc_list[i_start+i].is_static;
+    for (i=0; i<=number_of_channels; i++)
+    {
+      /* Constant information to be replicated in all channels */
+      channel_list[i].SlotId    = slotId;
+      channel_list[i].entry_idx = i_start + i;
 
+      /* Group address (prepared for IPv6) */
+      if ( igmpAssoc_list[i_start+i].groupAddr.family == L7_AF_INET6 )
+      {
+        channel_list[i].channel_dstIp.family = PTIN_AF_INET6;
+        memcpy( channel_list[i].channel_dstIp.addr.ipv6, igmpAssoc_list[i_start+i].groupAddr.addr.ipv6.in6.addr8, sizeof(L7_uchar8)*16);
+        channel_list[i].channel_dstmask = 128;
+      }
+      else
+      {
+        channel_list[i].channel_dstIp.family = PTIN_AF_INET;
+        channel_list[i].channel_dstIp.addr.ipv4 = igmpAssoc_list[i_start+i].groupAddr.addr.ipv4.s_addr;
+        channel_list[i].channel_dstmask = 32;
+      }
 
-   CHMSG_IP_ADDR_SWAP_MOD(channel_list[i].channel_dstIp);
-   CHMSG_IP_ADDR_SWAP_MOD(channel_list[i].channel_srcIp);
+      /* Source address (prepared for IPv6) */
+      if ( igmpAssoc_list[i_start+i].sourceAddr.family == L7_AF_INET6 )
+      {
+        channel_list[i].channel_srcIp.family = PTIN_AF_INET6;
+        memcpy( channel_list[i].channel_srcIp.addr.ipv6, igmpAssoc_list[i_start+i].sourceAddr.addr.ipv6.in6.addr8, sizeof(L7_uchar8)*16);
+        channel_list[i].channel_srcmask = 128;
+      }
+      else
+      {
+        channel_list[i].channel_srcIp.family = PTIN_AF_INET;
+        channel_list[i].channel_srcIp.addr.ipv4 = igmpAssoc_list[i_start+i].sourceAddr.addr.ipv4.s_addr;
+        channel_list[i].channel_srcmask = 32;
+      }
+
+      //channel_list[i].???       = igmpAssoc_list[i_start+i].evc_uc;
+      channel_list[i].evcid_mc  = igmpAssoc_list[i_start+i].evc_mc;
+      //channel_list[i].???       = igmpAssoc_list[i_start+i].is_static;
 
-   ENDIAN_SWAP64_MOD(channel_list[i].channelBandwidth);
-   ENDIAN_SWAP32_MOD(channel_list[i].evcid_mc);
-   ENDIAN_SWAP16_MOD(channel_list[i].entry_idx);
-  }
 
-  /* Return number of channels */
-  *n_channels = number_of_channels;
+     CHMSG_IP_ADDR_SWAP_MOD(channel_list[i].channel_dstIp);
+     CHMSG_IP_ADDR_SWAP_MOD(channel_list[i].channel_srcIp);
 
+     ENDIAN_SWAP64_MOD(channel_list[i].channelBandwidth);
+     ENDIAN_SWAP32_MOD(channel_list[i].evcid_mc);
+     ENDIAN_SWAP16_MOD(channel_list[i].entry_idx);
+    }
+
+    /* Return number of channels */
+    *n_channels = number_of_channels;
+  }
 #else
 
   PT_LOG_DEBUG(LOG_CTX_MSG,"Not supported!");
   return L7_NOT_SUPPORTED;
 
 #endif
@@ -12123,30 +12124,32 @@ L7_RC_t ptin_msg_static_channel_remove(m
       PT_LOG_ERR(LOG_CTX_MSG, "Error (%d) removing channel", rc);
       rc_global = rc;
       continue;
     }
 
     #ifdef IGMPASSOC_MULTI_MC_SUPPORTED//Remove Static Channel from (WhiteList) Group List     
-    msg_MCAssocChannel_t         channel_list;  
+    {
+      msg_MCAssocChannel_t         channel_list;  
 
-    memset(&channel_list, 0x00, sizeof(channel_list));
+      memset(&channel_list, 0x00, sizeof(channel_list));
 
-    channel_list.SlotId=channel[i].SlotId;
-    channel_list.evcid_mc=channel[i].evc_id;
+      channel_list.SlotId=channel[i].SlotId;
+      channel_list.evcid_mc=channel[i].evc_id;
 
-    channel_list.channel_dstIp.family=PTIN_AF_INET;
-    channel_list.channel_dstIp.addr.ipv4=channel[i].channelIp.s_addr;
-    channel_list.channel_dstmask=32;//32 Bits of Mask
+      channel_list.channel_dstIp.family=PTIN_AF_INET;
+      channel_list.channel_dstIp.addr.ipv4=channel[i].channelIp.s_addr;
+      channel_list.channel_dstmask=32;//32 Bits of Mask
 
-    channel_list.channel_srcIp.family=PTIN_AF_INET;
-    channel_list.channel_srcIp.addr.ipv4 = channel[i].sourceIp.s_addr;
-    channel_list.channel_srcmask=32;
+      channel_list.channel_srcIp.family=PTIN_AF_INET;
+      channel_list.channel_srcIp.addr.ipv4 = channel[i].sourceIp.s_addr;
+      channel_list.channel_srcmask=32;
 
-    channel_list.channelBandwidth = channel[i].channelBandwidth;
-    
-    ptin_msg_group_list_remove(&channel_list,1, L7_TRUE);   
+      channel_list.channelBandwidth = channel[i].channelBandwidth;
+      
+      ptin_msg_group_list_remove(&channel_list,1, L7_TRUE);   
+    }
     #endif//End Static Channel Remove
     
   }
 
   return rc_global;
 }
@@ -12371,12 +12374,14 @@ L7_RC_t ptin_msg_snoop_sync_reply(msg_Sn
   L7_inet_addr_t sourceAddr;
   char           groupAddrStr[IPV6_DISP_ADDR_LEN]={};
   char           sourceAddrStr[IPV6_DISP_ADDR_LEN]={};
 #else
   L7_uint32      sourceAddr = 0x0;
 #endif
+  msg_SnoopSyncRequest_t   snoopSyncRequest;
+  L7_uint32                ipAddr;
   
   if (snoopSyncReply==L7_NULLPTR)
   {
     PT_LOG_ERR(LOG_CTX_MSG,"Invalid parameters: snoopSyncReply=%p",snoopSyncReply);
     return L7_FAILURE;
   }
@@ -12472,15 +12477,12 @@ L7_RC_t ptin_msg_snoop_sync_reply(msg_Sn
   if(numberOfSnoopEntries!=maxNumberOfSnoopEntries)
   {
     PT_LOG_TRACE(LOG_CTX_MSG, "This is the Last Snoop Sync Reply Message Received");
     return L7_SUCCESS;
   }
 
-  msg_SnoopSyncRequest_t   snoopSyncRequest;
-  L7_uint32                ipAddr;
-
   memset(&snoopSyncRequest, 0x00, sizeof(snoopSyncRequest));
 
 #if PTIN_SYSTEM_IGMP_L3_MULTICAST_FORWARD
   memcpy(&snoopSyncRequest.groupAddr, &snoopSyncReply[numberOfSnoopEntries-1].groupAddr, sizeof(snoopSyncRequest.groupAddr));
   memcpy(&snoopSyncRequest.sourceAddr, &snoopSyncReply[numberOfSnoopEntries-1].sourceAddr, sizeof(snoopSyncRequest.sourceAddr));
 #else
@@ -12497,36 +12499,38 @@ L7_RC_t ptin_msg_snoop_sync_reply(msg_Sn
 
   /* MX board IP address */
   ipAddr = IPC_MX_PAIR_IPADDR;
   
   PT_LOG_INFO(LOG_CTX_MSG, "Sending Snoop Sync Request Message [groupAddr:%08X | serviceId:%u] to ipAddr:%08X (%u) to Sync the Remaining Snoop Entries", snoopSyncRequest.groupAddr, snoopSyncRequest.serviceId, ipAddr, MX_PAIR_SLOT_ID);         
 #else
-  ptin_prottypeb_intf_config_t protTypebIntfConfig = {0};     
+  {
+    ptin_prottypeb_intf_config_t protTypebIntfConfig = {0};
 
-  /*  Get the configuration of this portId for the Type B Scheme Protection */
-  ptin_prottypeb_intf_config_get(snoopSyncReply[numberOfSnoopEntries-1].portId, &protTypebIntfConfig);    
+    /*  Get the configuration of this portId for the Type B Scheme Protection */
+    ptin_prottypeb_intf_config_get(snoopSyncReply[numberOfSnoopEntries-1].portId, &protTypebIntfConfig);    
 
-  if(protTypebIntfConfig.status==L7_ENABLE)//If I'm a Protection
-  {
-    PT_LOG_NOTICE(LOG_CTX_MSG, "Not sending Another Snoop Sync Request Message to Sync the Remaining Snoop Entries. I'm a Active slotId/intfNum:%u/%u",protTypebIntfConfig.pairSlotId, protTypebIntfConfig.intfNum);
-    return SUCCESS;
-  }
-    
-  #if PTIN_BOARD_IS_STANDALONE
-  ipAddr = simGetIpcIpAddr();
-  #else
-  /* Determine the IP address of the working port/slot */   
-  if (L7_SUCCESS != ptin_fpga_slot_ip_addr_get(protTypebIntfConfig.pairSlotId, &ipAddr))
-  {
-    PT_LOG_ERR(LOG_CTX_MSG, "Failed to obtain ipAddress of slotId:%u", protTypebIntfConfig.pairSlotId);
-    return L7_FAILURE;
-  }
-  #endif
-  snoopSyncRequest.portId = protTypebIntfConfig.pairIntfNum;
+    if(protTypebIntfConfig.status==L7_ENABLE)//If I'm a Protection
+    {
+      PT_LOG_NOTICE(LOG_CTX_MSG, "Not sending Another Snoop Sync Request Message to Sync the Remaining Snoop Entries. I'm a Active slotId/intfNum:%u/%u",protTypebIntfConfig.pairSlotId, protTypebIntfConfig.intfNum);
+      return SUCCESS;
+    }
+      
+    #if PTIN_BOARD_IS_STANDALONE
+    ipAddr = simGetIpcIpAddr();
+    #else
+    /* Determine the IP address of the working port/slot */   
+    if (L7_SUCCESS != ptin_fpga_slot_ip_addr_get(protTypebIntfConfig.pairSlotId, &ipAddr))
+    {
+      PT_LOG_ERR(LOG_CTX_MSG, "Failed to obtain ipAddress of slotId:%u", protTypebIntfConfig.pairSlotId);
+      return L7_FAILURE;
+    }
+    #endif
+    snoopSyncRequest.portId = protTypebIntfConfig.pairIntfNum;
 
-  PT_LOG_DEBUG(LOG_CTX_MSG, "Sending Snoop Sync Request Message [groupAddr:%08X | serviceId:%u | portId:%u] to ipAddr:%08X to Sync the Remaining Snoop Entries", snoopSyncRequest.groupAddr, snoopSyncRequest.serviceId, snoopSyncRequest.portId, ipAddr);
+    PT_LOG_DEBUG(LOG_CTX_MSG, "Sending Snoop Sync Request Message [groupAddr:%08X | serviceId:%u | portId:%u] to ipAddr:%08X to Sync the Remaining Snoop Entries", snoopSyncRequest.groupAddr, snoopSyncRequest.serviceId, snoopSyncRequest.portId, ipAddr);
+  }
 #endif
               
   
   /*Send the snoop sync request to the protection matrix */  
   if (send_ipc_message(IPC_HW_FASTPATH_PORT, ipAddr, CCMSG_MGMD_SNOOP_SYNC_REQUEST,
                        (char *)(&snoopSyncRequest), NULL,
@@ -16565,16 +16569,17 @@ L7_RC_t ptin_msg_mirror(ipc_msg *inbuffe
           PT_LOG_TRACE(LOG_CTX_MSG, "Adding intfNum Src %d", ptin_port_aux);
         }
 
         /* Configure Egress XLATE on the destination interface */
         if (msg->src_intf[n].direction == 1 || msg->src_intf[n].direction == 3)
         {
+          L7_uint32 auxIntfNum, ptin_port_dst;
+
           PT_LOG_TRACE(LOG_CTX_MSG, "Src intfNum %d", ptin_port_aux);
           PT_LOG_TRACE(LOG_CTX_MSG, "Dst intfNum %d", msg->dst_intf.intf_id);
 
-          L7_uint32 auxIntfNum, ptin_port_dst;
           ptin_port_dst = msg->dst_intf.intf_id;
 
           if(msg->dst_intf.intf_id == 0)
           {         
             usmDbSwPortMonitorDestPortGet(unit, sessionNum, &auxIntfNum);
             ptin_intf_intIfNum2port(auxIntfNum, &ptin_port_dst); 
@@ -17801,70 +17806,74 @@ L7_RC_t ptin_msg_get_next_qualRFC2819(L7
   L7_int32 n_elements = 0;
   TBufferRegQualRFC2819 ring_buffer;
 
   buffer_id = buffer_index & 0xFFFF;
 
   if (buffer_index & 0x80000000)
+  {
     buffer_index=RFC2819_BUFFER_24HOURS;
+  }
   else
+  {
     buffer_index=RFC2819_BUFFER_15MIN;
+  }
 
 
-    if(ptin_rfc2819_buffer_get(buffer_index, buffer_id, &ring_buffer) <0) 
-    {
-      memset(&buffer[n_elements], 0x00, sizeof(msg_rfc2819_buffer_t)); // When no performance monotoring is avaiable send zeros.
-      return L7_SUCCESS;
-    }
-        
-    buffer[n_elements].index                = ENDIAN_SWAP32(ring_buffer.index);
-    buffer[n_elements].arg                  = ENDIAN_SWAP32(ring_buffer.arg);
-    buffer[n_elements].time                 = ENDIAN_SWAP32(ring_buffer.time);
-    buffer[n_elements].path                 = ENDIAN_SWAP32(ring_buffer.path);
-    buffer[n_elements].cTempo               = ENDIAN_SWAP32(ring_buffer.cTempo);
-
-    buffer[n_elements].Octets               = ENDIAN_SWAP64(ring_buffer.Octets);
-    buffer[n_elements].Pkts                 = ENDIAN_SWAP64(ring_buffer.Pkts);                
-    buffer[n_elements].Broadcast            = ENDIAN_SWAP64(ring_buffer.Broadcast);
-    buffer[n_elements].Multicast            = ENDIAN_SWAP64(ring_buffer.Multicast);           
-    buffer[n_elements].CRCAlignErrors       = ENDIAN_SWAP64(ring_buffer.CRCAlignErrors);      
-    buffer[n_elements].UndersizePkts        = ENDIAN_SWAP64(ring_buffer.UndersizePkts);       
-    buffer[n_elements].OversizePkts         = ENDIAN_SWAP64(ring_buffer.OversizePkts);        
-    buffer[n_elements].Fragments            = ENDIAN_SWAP64(ring_buffer.Fragments);           
-    buffer[n_elements].Jabbers              = ENDIAN_SWAP64(ring_buffer.Jabbers);             
-    buffer[n_elements].Collisions           = ENDIAN_SWAP64(ring_buffer.Collisions);          
-    buffer[n_elements].Utilization          = ENDIAN_SWAP64(ring_buffer.Utilization);         
-    buffer[n_elements].Pkts64Octets         = ENDIAN_SWAP64(ring_buffer.Pkts64Octets);        
-    buffer[n_elements].Pkts65to127Octets    = ENDIAN_SWAP64(ring_buffer.Pkts65to127Octets);   
-    buffer[n_elements].Pkts128to255Octets   = ENDIAN_SWAP64(ring_buffer.Pkts128to255Octets);  
-    buffer[n_elements].Pkts256to511Octets   = ENDIAN_SWAP64(ring_buffer.Pkts256to511Octets);  
-    buffer[n_elements].Pkts512to1023Octets  = ENDIAN_SWAP64(ring_buffer.Pkts512to1023Octets); 
-    buffer[n_elements].Pkts1024to1518Octets = ENDIAN_SWAP64(ring_buffer.Pkts1024to1518Octets);
-   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %d", buffer[n_elements].index);
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %d",  buffer[n_elements].arg );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %d", buffer[n_elements].time );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %d",  buffer[n_elements].path);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %d", buffer[n_elements].cTempo);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %d", buffer[n_elements].Octets );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %d", buffer[n_elements].Pkts);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %d", buffer[n_elements].Broadcast);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %d", buffer[n_elements].Multicast);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %d", buffer[n_elements].CRCAlignErrors);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts", buffer[n_elements].UndersizePkts);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %d", buffer[n_elements].OversizePkts);
-
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %d", buffer[n_elements].Fragments );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %d",  buffer[n_elements].Jabbers);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %d", buffer[n_elements].Collisions);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %d", buffer[n_elements].Utilization );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %d", buffer[n_elements].Pkts64Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %d", buffer[n_elements].Pkts65to127Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %d", buffer[n_elements].Pkts128to255Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %d", buffer[n_elements].Pkts256to511Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets", buffer[n_elements].Pkts512to1023Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %d", buffer[n_elements].Pkts1024to1518Octets);
+  if(ptin_rfc2819_buffer_get(buffer_index, buffer_id, &ring_buffer) <0) 
+  {
+    memset(&buffer[n_elements], 0x00, sizeof(msg_rfc2819_buffer_t)); // When no performance monotoring is avaiable send zeros.
+    return L7_SUCCESS;
+  }
+      
+  buffer[n_elements].index                = ENDIAN_SWAP32(ring_buffer.index);
+  buffer[n_elements].arg                  = ENDIAN_SWAP32(ring_buffer.arg);
+  buffer[n_elements].time                 = ENDIAN_SWAP32(ring_buffer.time);
+  buffer[n_elements].path                 = ENDIAN_SWAP32(ring_buffer.path);
+  buffer[n_elements].cTempo               = ENDIAN_SWAP32(ring_buffer.cTempo);
+
+  buffer[n_elements].Octets               = ENDIAN_SWAP64(ring_buffer.Octets);
+  buffer[n_elements].Pkts                 = ENDIAN_SWAP64(ring_buffer.Pkts);                
+  buffer[n_elements].Broadcast            = ENDIAN_SWAP64(ring_buffer.Broadcast);
+  buffer[n_elements].Multicast            = ENDIAN_SWAP64(ring_buffer.Multicast);           
+  buffer[n_elements].CRCAlignErrors       = ENDIAN_SWAP64(ring_buffer.CRCAlignErrors);      
+  buffer[n_elements].UndersizePkts        = ENDIAN_SWAP64(ring_buffer.UndersizePkts);       
+  buffer[n_elements].OversizePkts         = ENDIAN_SWAP64(ring_buffer.OversizePkts);        
+  buffer[n_elements].Fragments            = ENDIAN_SWAP64(ring_buffer.Fragments);           
+  buffer[n_elements].Jabbers              = ENDIAN_SWAP64(ring_buffer.Jabbers);             
+  buffer[n_elements].Collisions           = ENDIAN_SWAP64(ring_buffer.Collisions);          
+  buffer[n_elements].Utilization          = ENDIAN_SWAP64(ring_buffer.Utilization);         
+  buffer[n_elements].Pkts64Octets         = ENDIAN_SWAP64(ring_buffer.Pkts64Octets);        
+  buffer[n_elements].Pkts65to127Octets    = ENDIAN_SWAP64(ring_buffer.Pkts65to127Octets);   
+  buffer[n_elements].Pkts128to255Octets   = ENDIAN_SWAP64(ring_buffer.Pkts128to255Octets);  
+  buffer[n_elements].Pkts256to511Octets   = ENDIAN_SWAP64(ring_buffer.Pkts256to511Octets);  
+  buffer[n_elements].Pkts512to1023Octets  = ENDIAN_SWAP64(ring_buffer.Pkts512to1023Octets); 
+  buffer[n_elements].Pkts1024to1518Octets = ENDIAN_SWAP64(ring_buffer.Pkts1024to1518Octets);
+ 
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %d", buffer[n_elements].index);
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %d",  buffer[n_elements].arg );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %d", buffer[n_elements].time );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %d",  buffer[n_elements].path);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %d", buffer[n_elements].cTempo);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %d", buffer[n_elements].Octets );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %d", buffer[n_elements].Pkts);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %d", buffer[n_elements].Broadcast);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %d", buffer[n_elements].Multicast);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %d", buffer[n_elements].CRCAlignErrors);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts", buffer[n_elements].UndersizePkts);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %d", buffer[n_elements].OversizePkts);
+
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %d", buffer[n_elements].Fragments );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %d",  buffer[n_elements].Jabbers);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %d", buffer[n_elements].Collisions);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %d", buffer[n_elements].Utilization );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %d", buffer[n_elements].Pkts64Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %d", buffer[n_elements].Pkts65to127Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %d", buffer[n_elements].Pkts128to255Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %d", buffer[n_elements].Pkts256to511Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets", buffer[n_elements].Pkts512to1023Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %d", buffer[n_elements].Pkts1024to1518Octets);
       
   return L7_SUCCESS;
 }
 
 /**
  * RFC2819 Probe Configuration
@@ -17965,12 +17974,13 @@ L7_RC_t ptin_msg_igmp_packages_add(msg_i
 #ifdef IGMPASSOC_MULTI_MC_SUPPORTED
   L7_int32  packageIdIterator;
   L7_uint32 noOfPackagesFound = 0;
   L7_char8  packageBmpStr[PTIN_SYSTEM_IGMP_MAXPACKAGES/(sizeof(L7_uint8)*8)-1]={};
 //L7_char8 *charPtr = packageBmpStr;
   L7_RC_t   rc = L7_SUCCESS;
+  int i=0;
 
   /* Input Argument validation */
   if ( msg  == L7_NULLPTR )
   {
     PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [msg:%p]",msg);    
     return L7_FAILURE;
@@ -17983,14 +17993,12 @@ L7_RC_t ptin_msg_igmp_packages_add(msg_i
     charPtr++;
   }
 #endif
 
   ENDIAN_SWAP16_MOD(msg->noOfPackages);
 
-  int i=0;
-
   for (i=0; i<PTIN_IGMP_PACKAGE_BITMAP_SIZE;i++)
   {
     ENDIAN_SWAP32_MOD(msg->packageBmpList[i]);   
   }
       
   /*Input Parameters*/
@@ -18041,12 +18049,13 @@ L7_RC_t ptin_msg_igmp_packages_remove(ms
   L7_int32  packageIdIterator;
   L7_uint32 noOfPackagesFound = 0;
   L7_char8  packageBmpStr[PTIN_SYSTEM_IGMP_MAXPACKAGES/(sizeof(L7_uint8)*8)-1]={};
 //L7_char8 *charPtr = packageBmpStr;
   L7_BOOL   forceRemoval = L7_FALSE;
   L7_RC_t   rc = L7_SUCCESS;
+  int i=0;
 
   /* Input Argument validation */
   if ( msg  == L7_NULLPTR )
   {
     PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [msg:%p]",msg);    
     return L7_FAILURE;
@@ -18059,14 +18068,12 @@ L7_RC_t ptin_msg_igmp_packages_remove(ms
     charPtr++;
   }
 #endif 
      
   ENDIAN_SWAP16_MOD(msg->noOfPackages);
 
-  int i=0;
-
   for (i=0; i<PTIN_IGMP_PACKAGE_BITMAP_SIZE;i++)
   {
     ENDIAN_SWAP32_MOD(msg->packageBmpList[i]);   
   }
       
   /*Input Parameters*/
Index: src/application/ptin/base/ptin_igmp.c
===================================================================
--- src/application/ptin/base/ptin_igmp.c	(revision 7746)
+++ src/application/ptin/base/ptin_igmp.c	(revision 7747)
@@ -2497,26 +2497,25 @@ void ptin_igmp_proxy_config_dump__snoopi
 
 
 L7_RC_t ptin_igmp_proxy_config_set(PTIN_MGMD_CTRL_MGMD_CONFIG_t *igmpProxy)
 {
   PTIN_MGMD_EVENT_t      inEventMsg = {0}, outEventMsg = {0};
   PTIN_MGMD_EVENT_CTRL_t ctrlResMsg = {0};
+  ptin_IgmpProxyCfg_t    oldIgmpConfig;
 
   /* Create and send a PTIN_MGMD_EVENT_CTRL_PROXY_CONFIG_SET event to MGMD */
   ptin_mgmd_event_ctrl_create(&inEventMsg, PTIN_MGMD_EVENT_CTRL_PROXY_CONFIG_SET, rand(), 0, ptinMgmdTxQueueId, (void*) igmpProxy, (uint32) sizeof(PTIN_MGMD_CTRL_MGMD_CONFIG_t));
   ptin_mgmd_sendCtrlEvent(&inEventMsg, &outEventMsg);
 
   /* Parse the received reply */
   PT_LOG_DEBUG(LOG_CTX_IGMP, "MGMD replied");
   ptin_mgmd_event_ctrl_parse(&outEventMsg, &ctrlResMsg);
   PT_LOG_DEBUG(LOG_CTX_IGMP,  "  CTRL Msg Code: %08X", ctrlResMsg.msgCode);
   PT_LOG_DEBUG(LOG_CTX_IGMP,  "  CTRL Msg Id  : %08X", ctrlResMsg.msgId);
   PT_LOG_DEBUG(LOG_CTX_IGMP,  "  CTRL Res     : %u",   ctrlResMsg.res);
 
-
-  ptin_IgmpProxyCfg_t oldIgmpConfig;
   ptin_igmp_proxy_config_get__snooping_old(&oldIgmpConfig);
 
   /* If sucesseful, configure the old PTIN_IGMP struct, required for dynamic clients */
   if (0 == ctrlResMsg.res)
   {
     oldIgmpConfig.mask                                   = igmpProxy->mask;
@@ -3678,12 +3677,13 @@ L7_RC_t ptin_igmp_channelList_get(L7_uin
   else
   {
     ptinIgmpGroupClientInfoData_t *clientGroup;   
     L7_uint32                      intIfNum;
     L7_uint32                      globalGroupCountperMsg = 0;
     L7_BOOL                        isFirstDevice=L7_TRUE;
+    L7_uint16                      noOfClients;
 
     /* Find client */
     if (ptin_igmp_group_client_find(&client, &clientGroup, AVL_EXACT)!=L7_SUCCESS)
     {
       PT_LOG_ERR(LOG_CTX_IGMP,
               "Error searching for client {mask=0x%02x,"
@@ -3698,13 +3698,12 @@ L7_RC_t ptin_igmp_channelList_get(L7_uin
               client.innerVlan,
               (client.ipv4_addr>>24) & 0xff, (client.ipv4_addr>>16) & 0xff, (client.ipv4_addr>>8) & 0xff, client.ipv4_addr & 0xff,
               client.macAddr[0],client.macAddr[1],client.macAddr[2],client.macAddr[3],client.macAddr[4],client.macAddr[5]);
       return L7_FAILURE;
     }
 
-
     /*Take Semaphore*/
     osapiSemaTake(ptin_igmp_clients_sem, L7_WAIT_FOREVER);
 
     /* Validate interface */
     if (ptin_intf_ptintf2intIfNum(&client.ptin_intf, &intIfNum)!=L7_SUCCESS)
     {
@@ -3712,13 +3711,13 @@ L7_RC_t ptin_igmp_channelList_get(L7_uin
 
       /*Give Semaphore*/
       osapiSemaGive(ptin_igmp_clients_sem);
       return L7_FAILURE;
     }
 
-    L7_uint16 noOfClients = igmp_clientDevice_get_devices_number(clientGroup);
+    noOfClients = igmp_clientDevice_get_devices_number(clientGroup);
 
     if (noOfClients>0)
     {
       ptinIgmpClientDataKey_t        avl_key;
       ptinIgmpClientInfoData_t      *device_client;
 
@@ -3747,13 +3746,15 @@ L7_RC_t ptin_igmp_channelList_get(L7_uin
           break;
         }
         /* check if the device client belongs to the desired group client */
         if( device_client->igmpClientDataKey.ptin_port == clientGroup->igmpClientDataKey.ptin_port &&
             device_client->igmpClientDataKey.innerVlan == clientGroup->igmpClientDataKey.innerVlan &&
             device_client->igmpClientDataKey.outerVlan == clientGroup->igmpClientDataKey.outerVlan )
-          {
+        {
+          L7_uint16   iterator;
+          L7_uint16   existingEntry;
 
           do
           {
             PTIN_MGMD_EVENT_t                      reqMsg        = {0};
             PTIN_MGMD_EVENT_t                      resMsg        = {0};
             PTIN_MGMD_EVENT_CTRL_t                 ctrlResMsg    = {0};
@@ -3794,14 +3795,13 @@ L7_RC_t ptin_igmp_channelList_get(L7_uin
               PT_LOG_ERR(LOG_CTX_IGMP, "Invalid response size from MGMD [size:%u]. Expecting multiple of %u", ctrlResMsg.dataLength, sizeof(PTIN_MGMD_CTRL_ACTIVEGROUPS_RESPONSE_t));
               /*Give Semaphore*/
               osapiSemaGive(ptin_igmp_clients_sem);
               return L7_FAILURE;
             }
 
-            L7_uint16   iterator;
-            L7_uint16   existingEntry=L7_FALSE;
+            existingEntry=L7_FALSE;
 
             PT_LOG_DEBUG(LOG_CTX_IGMP, "Active groups (Service:%u)", McastEvcId);
             while ((ctrlResMsg.dataLength > 0) && (numberOfChannels < *max_number_of_channels))
             {
               memcpy(&mgmdGroupsRes, ctrlResMsg.data + groupCountperMsg*sizeof(PTIN_MGMD_CTRL_ACTIVEGROUPS_RESPONSE_t), sizeof(PTIN_MGMD_CTRL_ACTIVEGROUPS_RESPONSE_t));         
 
@@ -3922,12 +3922,13 @@ L7_RC_t ptin_igmp_clientList_get(L7_uint
   L7_uint32                              currentClientId = 0;
   L7_uint32                              clientBufferIdx = 0;
   ptin_client_id_t                       avl_key;
   ptinIgmpClientGroupsSnapshotInfoData_t *avl_infoData;
   L7_uint32                              totalClientCount = 0; 
   L7_uint32                              totalInvalidClients = 0; 
+  static ptin_client_id_t tempKey;
 
   /* Validate arguments */
   if (client_list==L7_NULLPTR || number_of_clients==L7_NULLPTR || total_clients==L7_NULLPTR)
   {
     PT_LOG_ERR(LOG_CTX_IGMP,"Null parameters");
     return L7_FAILURE;
@@ -3949,16 +3950,18 @@ L7_RC_t ptin_igmp_clientList_get(L7_uint
     return L7_FAILURE;
   }
 
   /* If the entry index is 0, request the client list from MGMD. Otherwise, read from our local snapshot */
   if (0 == client_index)
   {
+    PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t *mgmdGroupsRes;
     L7_uint32 maxResponseEntries = PTIN_MGMD_EVENT_CTRL_DATA_SIZE_MAX/sizeof(PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t);
-    PT_LOG_DEBUG(LOG_CTX_IGMP, "Max Entries:%u", maxResponseEntries);
     L7_uint32 pageClientCount = 0; 
 
+    PT_LOG_DEBUG(LOG_CTX_IGMP, "Max Entries:%u", maxResponseEntries);
+
     /*Take Semaphore*/
     osapiSemaTake(ptin_igmp_clients_sem, L7_WAIT_FOREVER);
 
     do
     {
       //Save current page and total client context
@@ -3990,13 +3993,13 @@ L7_RC_t ptin_igmp_clientList_get(L7_uint
 
         return L7_FAILURE;
       }
 
       PT_LOG_DEBUG(LOG_CTX_IGMP, "Active groups (Service:%u GroupAddr:%08X)", McastEvcId, groupAddr->s_addr);
 
-      PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t *mgmdGroupsRes = (PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t*) ctrlResMsg.data;      
+      mgmdGroupsRes = (PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t*) ctrlResMsg.data;      
       while (ctrlResMsg.dataLength > 0 && mgmdGroupsRes != L7_NULLPTR)
       {
         ptin_client_id_t               newClientEntry;    
         ptinIgmpClientInfoData_t      *client;
         ptinIgmpGroupClientInfoData_t *clientGroup;
         L7_uint32                      ptinPort;
@@ -4078,18 +4081,20 @@ L7_RC_t ptin_igmp_clientList_get(L7_uint
           }
         
 #endif // ONE_MULTICAST_VLAN_RING_SUPPORT
 
   #endif
   #if (MC_CLIENT_OUTERVLAN_SUPPORTED)
-          L7_uint16 nni_ovid;
+          {
+            L7_uint16 nni_ovid;
 
-          ptin_evc_get_NNIvlan_fromEvcId(McastEvcId, &nni_ovid);
-          newClientEntry.outerVlan = nni_ovid;
-          newClientEntry.mask |= PTIN_CLIENT_MASK_FIELD_OUTERVLAN;
-          //PT_LOG_DEBUG(LOG_CTX_IGMP, "oVlan: %u", newClientEntry.outerVlan);
+            ptin_evc_get_NNIvlan_fromEvcId(McastEvcId, &nni_ovid);
+            newClientEntry.outerVlan = nni_ovid;
+            newClientEntry.mask |= PTIN_CLIENT_MASK_FIELD_OUTERVLAN;
+            //PT_LOG_DEBUG(LOG_CTX_IGMP, "oVlan: %u", newClientEntry.outerVlan);
+          }
   #endif
   #if (MC_CLIENT_INNERVLAN_SUPPORTED)
           //newClientEntry.innerVlan = clientGroup->igmpClientDataKey.innerVlan;
           //newClientEntry.mask |= PTIN_CLIENT_MASK_FIELD_INNERVLAN;
           //PT_LOG_DEBUG(LOG_CTX_IGMP, "iVlan: %u", newClientEntry.innerVlan);
   #endif
@@ -4214,13 +4219,12 @@ L7_RC_t ptin_igmp_clientList_get(L7_uint
     } while (pageClientCount == maxResponseEntries); //While the number of clients returned equals the max number of clients per page
 
     /*Give Semaphore*/
     osapiSemaGive(ptin_igmp_clients_sem);
   }
 
-	static ptin_client_id_t tempKey;
   /* Get all clients */
   memset(&avl_key,0x00,sizeof(ptin_client_id_t));
   while (L7_NULLPTR != (avl_infoData = (ptinIgmpClientGroupsSnapshotInfoData_t *)avlSearchLVL7(&(igmpSnapshotClientGroups.avlTree), &avl_key, L7_MATCH_GETNEXT)))
   {   
     /* Prepare next key */
     memcpy(&avl_key, &avl_infoData->key, sizeof(ptin_client_id_t));
@@ -10453,30 +10457,32 @@ static L7_RC_t ptin_igmp_device_client_r
         igmp_clientDevice_remove(clientGroup, clientInfo);
       }
       #endif
 
 #if PTIN_SYSTEM_IGMP_ADMISSION_CONTROL_SUPPORT
 #if PTIN_BOARD_IS_LINECARD
-      L7_uint32 internalServiceId;
-      
-      /* Reset Allocated channels*/
-      clientInfo->pClientGroup->admissionControl.allocatedChannels = 0;
-      if (clientGroup->evcId < PTIN_SYSTEM_N_EXTENDED_EVCS &&        
-          clientGroup->onuId < PTIN_SYSTEM_IGMP_MAXONUS_PER_INTF)
       {
-        if (ptinIgmpAdmissionControlMulticastInternalServiceId[clientGroup->evcId] < PTIN_IGMP_MAX_MULTICAST_INTERNAL_SERVICE_ID)
+        L7_uint32 internalServiceId;
+        
+        /* Reset Allocated channels*/
+        clientInfo->pClientGroup->admissionControl.allocatedChannels = 0;
+        if (clientGroup->evcId < PTIN_SYSTEM_N_EXTENDED_EVCS &&        
+            clientGroup->onuId < PTIN_SYSTEM_IGMP_MAXONUS_PER_INTF)
         {
-          internalServiceId = ptinIgmpAdmissionControlMulticastInternalServiceId[clientGroup->evcId];
-          igmpMulticastAdmissionControl[ptin_port][clientGroup->onuId][internalServiceId].admissionControl.allocatedChannels = 0;        
+          if (ptinIgmpAdmissionControlMulticastInternalServiceId[clientGroup->evcId] < PTIN_IGMP_MAX_MULTICAST_INTERNAL_SERVICE_ID)
+          {
+            internalServiceId = ptinIgmpAdmissionControlMulticastInternalServiceId[clientGroup->evcId];
+            igmpMulticastAdmissionControl[ptin_port][clientGroup->onuId][internalServiceId].admissionControl.allocatedChannels = 0;        
+          }
+        }
+        else
+        {
+          PT_LOG_CRITIC(LOG_CTX_IGMP," Some value out of range! (EvcId %d OnuId %d) ", 
+                       clientGroup->evcId,
+                       clientGroup->onuId);
         }
-      }
-      else
-      {
-        PT_LOG_CRITIC(LOG_CTX_IGMP," Some value out of range! (EvcId %d OnuId %d) ", 
-                     clientGroup->evcId,
-                     clientGroup->onuId);
       }
 #endif
 #endif
 
       /* Remove client from unified list of clients */
       igmp_clientIndex_unmark(ptin_port, client_idx);
@@ -11813,12 +11819,13 @@ L7_RC_t ptin_igmp_stat_client_get(L7_uin
   PTIN_MGMD_EVENT_t               resMsg          = {0};
   PTIN_MGMD_EVENT_CTRL_t          ctrlResMsg      = {0};
   PTIN_MGMD_CTRL_STATS_REQUEST_t  mgmdStatsReqMsg = {0};
   PTIN_MGMD_CTRL_STATS_RESPONSE_t mgmdStatsResMsg = {0};
   //L7_uint32                       clientId;
   L7_uint32                       intIfNum;
+  L7_uint16                       noOfClients;
 
   memset(statistics, 0x00, sizeof(PTIN_MGMD_CTRL_STATS_RESPONSE_t));
 
   memcpy(&client, client_id, sizeof(ptin_client_id_t));
 
   /* Validate and rearrange clientId info */
@@ -11898,17 +11905,17 @@ L7_RC_t ptin_igmp_stat_client_get(L7_uin
 
     statistics->igmpTotalRx                        = statistics->igmpInvalidRx + 
                                                      statistics->igmpDroppedRx + 
                                                      statistics->igmpValidRx;             
   }                                              
 
-    L7_uint16 noOfClients=igmp_clientDevice_get_devices_number(clientGroup);
-    PT_LOG_DEBUG(LOG_CTX_IGMP,  "  noOfClients %u", noOfClients);
+  noOfClients=igmp_clientDevice_get_devices_number(clientGroup);
+  PT_LOG_DEBUG(LOG_CTX_IGMP,  "  noOfClients %u", noOfClients);
 
-    if (noOfClients>0) 
-    {
+  if (noOfClients>0) 
+  {
     L7_uint16 noOfClientsFound=0;
     ptinIgmpClientDataKey_t     avl_key;
     ptinIgmpClientInfoData_t    *device_client;
 
     /* Run all cells in AVL tree */
     memset(&avl_key, 0x00, sizeof(ptinIgmpClientDataKey_t));
@@ -12158,32 +12165,34 @@ L7_RC_t ptin_igmp_stat_instanceIntf_clea
   if (rc != L7_SUCCESS)
   {
     PT_LOG_ERR(LOG_CTX_IGMP,"Error getting IGMP stats for EVC %u",evc_idx);
     return L7_FAILURE;
   }
 #else
-  L7_uint igmp_idx, ptin_port;
-
-  /* Validate interface */
-  if (ptin_intf_ptintf2port(ptin_intf, &ptin_port)!=L7_SUCCESS || ptin_port>=PTIN_SYSTEM_N_INTERF)
   {
-    PT_LOG_ERR(LOG_CTX_EVC, "ptin_intf %u/%u is invalid", ptin_intf->intf_type, ptin_intf->intf_id);
-    return L7_FAILURE;
-  }
+    L7_uint igmp_idx, ptin_port;
 
-  /* Get IGMP instance */
-  if (ptin_igmp_instance_find_fromSingleEvcId(evc_idx, &igmp_idx) != L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_IGMP,"No Igmp instance found for EVC %u",evc_idx);
-    return L7_FAILURE;
-  }
+    /* Validate interface */
+    if (ptin_intf_ptintf2port(ptin_intf, &ptin_port)!=L7_SUCCESS || ptin_port>=PTIN_SYSTEM_N_INTERF)
+    {
+      PT_LOG_ERR(LOG_CTX_EVC, "ptin_intf %u/%u is invalid", ptin_intf->intf_type, ptin_intf->intf_id);
+      return L7_FAILURE;
+    }
 
-  /* Clear stats */
-  osapiSemaTake(ptin_igmp_stats_sem, L7_WAIT_FOREVER);
-  memset(&igmpInstances[igmp_idx].stats_intf[ptin_port], 0x00, sizeof(ptin_IGMP_Statistics_t));
-  osapiSemaGive(ptin_igmp_stats_sem);
+    /* Get IGMP instance */
+    if (ptin_igmp_instance_find_fromSingleEvcId(evc_idx, &igmp_idx) != L7_SUCCESS)
+    {
+      PT_LOG_ERR(LOG_CTX_IGMP,"No Igmp instance found for EVC %u",evc_idx);
+      return L7_FAILURE;
+    }
+
+    /* Clear stats */
+    osapiSemaTake(ptin_igmp_stats_sem, L7_WAIT_FOREVER);
+    memset(&igmpInstances[igmp_idx].stats_intf[ptin_port], 0x00, sizeof(ptin_IGMP_Statistics_t));
+    osapiSemaGive(ptin_igmp_stats_sem);
+  }
 #endif 
   return L7_SUCCESS;
 }
 
 /**
  * Clear all statistics of one IGMP instance
@@ -14078,16 +14087,15 @@ static L7_uint8 igmp_clientDevice_get_de
   /* Return number of elements in queue */
   return clientGroup->queue_clientDevices.n_elems;
 
 #else
 
   L7_uint8                       i_client = 0;
-  ptinIgmpClientDataKey_t        avl_key;;
+  ptinIgmpClientDataKey_t        avl_key;
   ptinIgmpClientInfoData_t      *device_client;
 
-
   /* Run all cells in AVL tree */
   memset(&avl_key,0x00,sizeof(ptinIgmpClientDataKey_t));
 
   while ( ( device_client = (ptinIgmpClientInfoData_t *)
             avlSearchLVL7(&igmpDeviceClients.avlTree.igmpClientsAvlTree, (void *)&avl_key, AVL_NEXT)
           ) != L7_NULLPTR )
@@ -14095,14 +14103,14 @@ static L7_uint8 igmp_clientDevice_get_de
 
     /* check if the device client belongs to the desired group client */
     if(device_client->ptin_port == clientGroup->ptin_port && device_client->uni_ivid == clientGroup->uni_ivid && device_client->uni_ovid == clientGroup->uni_ovid)
     {
       i_client++;
     }
-       /* Prepare next key */
-      memcpy(&avl_key, &device_client->igmpClientDataKey, sizeof(ptinIgmpClientDataKey_t));
+    /* Prepare next key */
+    memcpy(&avl_key, &device_client->igmpClientDataKey, sizeof(ptinIgmpClientDataKey_t));
   }
   return i_client;
      
   #endif
 }
 
@@ -14510,15 +14518,17 @@ static void igmp_clientIndex_mark(L7_uin
   #endif
 #endif // ONE_MULTICAST_VLAN_RING_SUPPORT
 #endif 
 
 #ifndef ONE_MULTICAST_VLAN_RING_SUPPORT
   #if PTIN_BOARD_IS_LINECARD || PTIN_BOARD_IS_STANDALONE
-  L7_uint16 nClients =  igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients;
-  igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->client_bmp[nClients] = infoData->deviceClientId;
-  igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients    = nClients + 1;
+  {
+    L7_uint16 nClients =  igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients;
+    igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->client_bmp[nClients] = infoData->deviceClientId;
+    igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients    = nClients + 1;
+  }
 #endif
 #endif // ONE_MULTICAST_VLAN_RING_SUPPORT
 }
 
 /**
  * Get outer vlan from Client Id
@@ -14562,21 +14572,25 @@ static void igmp_clientIndex_unmark(L7_u
       }
     }
   }
 
 #ifdef ONE_MULTICAST_VLAN_RING_SUPPORT
   #if PTIN_BOARD_IS_LINECARD //|| PTIN_BOARD_IS_STANDALONE
-  L7_uint16 nClients = igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients;
-  igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients = nClients - 1;
+  {
+    L7_uint16 nClients = igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients;
+    igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients = nClients - 1;
+  }
   #endif
 #endif // ONE_MULTICAST_VLAN_RING_SUPPORT
 
 #ifndef ONE_MULTICAST_VLAN_RING_SUPPORT
   #if PTIN_BOARD_IS_LINECARD || PTIN_BOARD_IS_STANDALONE
-  L7_uint16 nClients = igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients;
-  igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients = nClients - 1;
+  {
+    L7_uint16 nClients = igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients;
+    igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client->pClientGroup->number_of_clients = nClients - 1;
+  }
   #endif
 #endif
    
   igmpDeviceClients.client_devices[PTIN_IGMP_CLIENT_PORT(ptin_port)][client_idx].client = L7_NULLPTR;
 }
 
@@ -19227,17 +19241,15 @@ RC_t ptin_igmp_multicast_service_remove(
  * @notes none 
  *  
  */
 RC_t ptin_igmp_multicast_get_all_serviceId_per_onu(L7_uint32 ptinPort, L7_uint32 onuId, L7_uint32 *listOfServices, L7_uint32 *nOfServices)
 {
   L7_uint8 i = 0;
-  
-  ptinIgmpClientDataKey_t   avl_key;;
+  ptinIgmpClientDataKey_t   avl_key;
   ptinIgmpGroupClientInfoData_t  *group_client;
 
-
   /* ptinPort is valid? */
   if (ptinPort >= PTIN_SYSTEM_N_UPLINK_INTERF)
   {
     PT_LOG_TRACE(LOG_CTX_IGMP, "ptin_port is out of range! (ptin_port_id=%u max=%u)", ptinPort, PTIN_SYSTEM_N_UPLINK_INTERF);
     return L7_FAILURE;
   }
@@ -20498,22 +20510,19 @@ RC_t ptin_igmp_multicast_querierReset_on
 
 
 /*************** dump all services in use on a specific onuID *****************/
 
 void ptin_igmp_onu_services_inUse_dump(L7_uint32 ptinPort, L7_uint32 onuId)
 {
-
 #ifdef IGMPASSOC_MULTI_MC_SUPPORTED
-
-  printf("Services in use on a specific onuID (local struct):\n");
-
   L7_uint8  i = 0;
   L7_uint32 nOfServices = 0;
-
   L7_uint32 listOfServices[PTIN_SYSTEM_MAX_SERVICES_PER_ONU];
 
+  printf("Services in use on a specific onuID (local struct):\n");
+
   ptin_igmp_multicast_get_all_serviceId_per_onu(ptinPort, onuId, listOfServices, &nOfServices);
 
   while (i < PTIN_SYSTEM_MAX_SERVICES_PER_ONU)
   {
     printf("ServiceId: %u  (in_use %d )\n", serviceId_evcUc[ptinPort][onuId][i].serviceId, serviceId_evcUc[ptinPort][onuId][i].inUse);
     i++;
Index: src/application/ptin/base/ptin_fpga_api.c
===================================================================
--- src/application/ptin/base/ptin_fpga_api.c	(revision 7746)
+++ src/application/ptin/base/ptin_fpga_api.c	(revision 7747)
@@ -524,31 +524,33 @@ L7_RC_t ptin_fpga_slot_ip_addr_get(L7_ui
 L7_uint8 ptin_fpga_board_slot_get(void)
 {
   L7_uint8 board_slot_id = 0;
 
   board_slot_id = CPLD_SLOT_ID_GET();
 
-#if (PTIN_BOARD_IS_LINECARD)      
-  L7_BOOL  olt1t1_backplane;
-
-  /* Condition for OLT1T1 backplane */
-  olt1t1_backplane = (ptin_fpga_board_get() == PTIN_BOARD_CXO160G);
-  
-  /* If high and low nibbles are equal, we are at a OLT1T3 system */
-  if (!olt1t1_backplane)
+#if (PTIN_BOARD_IS_LINECARD)
   {
+    L7_BOOL  olt1t1_backplane;
+
+    /* Condition for OLT1T1 backplane */
+    olt1t1_backplane = (ptin_fpga_board_get() == PTIN_BOARD_CXO160G);
+
+    /* If high and low nibbles are equal, we are at a OLT1T3 system */
+    if (!olt1t1_backplane)
+    {
     board_slot_id += 2;
-  }
-  /* Otherwise, we are at a OLT1T1 system */
-  else
-  {
+    }
+    /* Otherwise, we are at a OLT1T1 system */
+    else
+    {
     /* Validate slot id */       
     if (board_slot_id > 4)
       return ((L7_uint8) -1);
     /* Invert slot ids */ 
     board_slot_id = 4 - board_slot_id;        
+    }
   }
 #elif (PTIN_BOARD_IS_MATRIX)
   board_slot_id = (board_slot_id == 0) ? PTIN_SYS_MX1_SLOT : PTIN_SYS_MX2_SLOT;
 #endif
 
   return board_slot_id;
Index: src/application/ptin/base/ptin_evc.c
===================================================================
--- src/application/ptin/base/ptin_evc.c	(revision 7746)
+++ src/application/ptin/base/ptin_evc.c	(revision 7747)
@@ -667,12 +667,13 @@ L7_RC_t ptin_evc_init(void)
  * Initializes EVCs for each platform
  * 
  * @return L7_RC_t : L7_SUCCESS / L7_FAILURE
  */
 L7_RC_t ptin_evc_startup(void)
 {
+  L7_uint32 intIfNum_vport;
 #if (PTIN_BOARD == PTIN_BOARD_OLT1T0)
   L7_int  i;
   L7_RC_t rc;
   ptin_HwEthMef10Evc_t evcConf;
 
   /* Create a new EVC */
@@ -719,14 +720,12 @@ L7_RC_t ptin_evc_startup(void)
     ptin_flows_fpga_init();
   }
 #endif
 
   PT_LOG_INFO(LOG_CTX_API, "Standard EVCs configured for OLT1T0 equipment");
 
-  L7_uint32 intIfNum_vport;
-
   /* Create intIfNum for Virtual ports */
   if (L7_SUCCESS != vlan_port_intIfNum_create(1, &intIfNum_vport))
   {
     PT_LOG_ERR(LOG_CTX_EVC, "Error creating intIfNum for virtual ports");
     return L7_FAILURE;
   }
@@ -4192,12 +4191,15 @@ L7_RC_t ptin_evc_destroy_all(void)
  * @author Rui Fernandes: rui-f-fernandes@telecom.pt 
  * @return L7_RC_t L7_SUCCESS
  */
 L7_RC_t ptin_evc_p2p_bridge_replicate(L7_uint32 evc_ext_id, L7_uint32 ptin_port, L7_uint32 ptin_port_ngpon2, ptin_HwEthMef10Intf_t *intf)
 {
   L7_uint32 evc_id;
+  ptin_HwEthEvcBridge_t evcBridge;
+  struct ptin_evc_client_s *pclientFlow;
+  int j;
 
   /* Validate EVC# range (EVC index [0..PTIN_SYSTEM_N_EVCS[) */
   if (evc_ext_id >= PTIN_SYSTEM_N_EXTENDED_EVCS)
   {
     PT_LOG_ERR(LOG_CTX_EVC, "eEVC# %u is out of range [0..%u]", evc_ext_id, PTIN_SYSTEM_N_EXTENDED_EVCS-1);
     return L7_FAILURE;
@@ -4207,29 +4209,24 @@ L7_RC_t ptin_evc_p2p_bridge_replicate(L7
   if (ptin_evc_ext2int(evc_ext_id, &evc_id) != L7_SUCCESS)
   {
     PT_LOG_ERR(LOG_CTX_EVC, "eEVC# %u is not in use", evc_ext_id);
     return L7_FAILURE;
   }
 
-  ptin_HwEthEvcBridge_t evcBridge;
-
   evcBridge.index = evc_ext_id;
   
   /* Validate leaf interface (from received message) */
   if ((ptin_port >= PTIN_SYSTEM_N_INTERF) ||
       (!evcs[evc_id].intf[ptin_port].in_use) ||
       (evcs[evc_id].intf[ptin_port].type != PTIN_EVC_INTF_LEAF))
   {
     return L7_FAILURE;
   }
 
-  struct ptin_evc_client_s *pclientFlow;
   dl_queue_get_head(&evcs[evc_id].intf[ptin_port_ngpon2].clients, (dl_queue_elem_t **) &pclientFlow);
 
-  int j;
-
   for (j=0; j < evcs[evc_id].intf[ptin_port_ngpon2].clients.n_elems && pclientFlow != L7_NULLPTR; j++) 
   {
 
     evcBridge.inn_vlan = pclientFlow->client_vid;
 
     evcBridge.intf.action_inner = PTIN_XLATE_ACTION_ADD;
@@ -5118,45 +5115,47 @@ L7_RC_t ptin_evc_macbridge_client_packag
   {
     PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Flows are only applied to QUATTRO services", evc_id);
     return L7_FAILURE;
   }
 
 #if PTIN_QUATTRO_FLOWS_FEATURE_ENABLED
-  L7_uint                   int_ovid;
-  ptin_client_id_t          clientId;
-  struct ptin_evc_client_s *pflow;
-  L7_BOOL                   addOrRemove = L7_FALSE;//Add Packages
-  L7_RC_t                   rc = L7_SUCCESS;
+  {
+    L7_uint                   int_ovid;
+    ptin_client_id_t          clientId;
+    struct ptin_evc_client_s *pflow;
+    L7_BOOL                   addOrRemove = L7_FALSE;//Add Packages
+    L7_RC_t                   rc = L7_SUCCESS;
 
-  /* Get internal vlan and inner NNI vlan */
-  int_ovid = evcs[evc_id].intf[leaf_port].int_vlan;
+    /* Get internal vlan and inner NNI vlan */
+    int_ovid = evcs[evc_id].intf[leaf_port].int_vlan;
 
-  /* Check if flow entry already exists */
-  ptin_evc_find_flow(ecvFlow->uni_ovid, &evcs[evc_id].intf[leaf_port].clients, (dl_queue_elem_t**) &pflow);
+    /* Check if flow entry already exists */
+    ptin_evc_find_flow(ecvFlow->uni_ovid, &evcs[evc_id].intf[leaf_port].clients, (dl_queue_elem_t**) &pflow);
 
-  if (pflow == NULL)
-  {
-    PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Flow does not exist", evc_id);
-    return L7_DEPENDENCY_NOT_MET;
-  }
+    if (pflow == NULL)
+    {
+      PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Flow does not exist", evc_id);
+      return L7_DEPENDENCY_NOT_MET;
+    }
 
-  /* Client id: For IGMP */
-  memset(&clientId, 0x00, sizeof(clientId));
-  clientId.ptin_intf.intf_type  = ecvFlow->ptin_intf.intf_type;
-  clientId.ptin_intf.intf_id    = ecvFlow->ptin_intf.intf_id;
-  clientId.outerVlan            = pflow->int_ovid;
-  clientId.innerVlan            = pflow->int_ivid;
-  clientId.mask                 = PTIN_CLIENT_MASK_FIELD_INTF | PTIN_CLIENT_MASK_FIELD_OUTERVLAN | PTIN_CLIENT_MASK_FIELD_INNERVLAN;
+    /* Client id: For IGMP */
+    memset(&clientId, 0x00, sizeof(clientId));
+    clientId.ptin_intf.intf_type  = ecvFlow->ptin_intf.intf_type;
+    clientId.ptin_intf.intf_id    = ecvFlow->ptin_intf.intf_id;
+    clientId.outerVlan            = pflow->int_ovid;
+    clientId.innerVlan            = pflow->int_ivid;
+    clientId.mask                 = PTIN_CLIENT_MASK_FIELD_INTF | PTIN_CLIENT_MASK_FIELD_OUTERVLAN | PTIN_CLIENT_MASK_FIELD_INNERVLAN;
 
-  /* Add client */
-  if ( (rc = ptin_igmp_api_client_add(&clientId, pflow->uni_ovid, pflow->uni_ivid, ecvFlow->onuId, 0x00, 0, 0, addOrRemove, ecvFlow->packageBmpList, ecvFlow->noOfPackages) != L7_SUCCESS) )
-  {
-    PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error adding client to IGMP instance", evc_id);
+    /* Add client */
+    if ( (rc = ptin_igmp_api_client_add(&clientId, pflow->uni_ovid, pflow->uni_ivid, ecvFlow->onuId, 0x00, 0, 0, addOrRemove, ecvFlow->packageBmpList, ecvFlow->noOfPackages) != L7_SUCCESS) )
+    {
+      PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error adding client to IGMP instance", evc_id);
+      return rc;
+    }
     return rc;
   }
-  return rc;
 #else
   PT_LOG_ERR(LOG_CTX_EVC, "eEVC# %u: Flows not available for this board", evc_id);
   return L7_ERROR;
 #endif  
 }
 
@@ -5226,45 +5225,47 @@ L7_RC_t ptin_evc_macbridge_client_packag
   {
     PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Flows are only applied to QUATTRO services", evc_id);
     return L7_FAILURE;
   }
 
 #if PTIN_QUATTRO_FLOWS_FEATURE_ENABLED
-  L7_uint                   int_ovid;
-  ptin_client_id_t          clientId;
-  struct ptin_evc_client_s *pflow;
-  L7_BOOL                   addOrRemove = L7_TRUE;//Remove Packages
-  L7_RC_t                   rc = L7_SUCCESS;
+  {
+    L7_uint                   int_ovid;
+    ptin_client_id_t          clientId;
+    struct ptin_evc_client_s *pflow;
+    L7_BOOL                   addOrRemove = L7_TRUE;//Remove Packages
+    L7_RC_t                   rc = L7_SUCCESS;
 
-  /* Get internal vlan and inner NNI vlan */
-  int_ovid = evcs[evc_id].intf[leaf_port].int_vlan;
+    /* Get internal vlan and inner NNI vlan */
+    int_ovid = evcs[evc_id].intf[leaf_port].int_vlan;
 
-  /* Check if flow entry already exists */
-  ptin_evc_find_flow(ecvFlow->uni_ovid, &evcs[evc_id].intf[leaf_port].clients, (dl_queue_elem_t**) &pflow);
+    /* Check if flow entry already exists */
+    ptin_evc_find_flow(ecvFlow->uni_ovid, &evcs[evc_id].intf[leaf_port].clients, (dl_queue_elem_t**) &pflow);
 
-  if (pflow == NULL)
-  {
-    PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Flow does not exist", evc_id);
-    return L7_DEPENDENCY_NOT_MET;
-  }
+    if (pflow == NULL)
+    {
+      PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Flow does not exist", evc_id);
+      return L7_DEPENDENCY_NOT_MET;
+    }
 
-  /* Client id: For IGMP */
-  memset(&clientId, 0x00, sizeof(clientId));
-  clientId.ptin_intf.intf_type  = ecvFlow->ptin_intf.intf_type;
-  clientId.ptin_intf.intf_id    = ecvFlow->ptin_intf.intf_id;
-  clientId.outerVlan            = pflow->int_ovid;
-  clientId.innerVlan            = pflow->int_ivid;
-  clientId.mask                 = PTIN_CLIENT_MASK_FIELD_INTF | PTIN_CLIENT_MASK_FIELD_OUTERVLAN | PTIN_CLIENT_MASK_FIELD_INNERVLAN;
+    /* Client id: For IGMP */
+    memset(&clientId, 0x00, sizeof(clientId));
+    clientId.ptin_intf.intf_type  = ecvFlow->ptin_intf.intf_type;
+    clientId.ptin_intf.intf_id    = ecvFlow->ptin_intf.intf_id;
+    clientId.outerVlan            = pflow->int_ovid;
+    clientId.innerVlan            = pflow->int_ivid;
+    clientId.mask                 = PTIN_CLIENT_MASK_FIELD_INTF | PTIN_CLIENT_MASK_FIELD_OUTERVLAN | PTIN_CLIENT_MASK_FIELD_INNERVLAN;
 
-  /* Add client */
-  if ( (rc = ptin_igmp_api_client_add(&clientId, pflow->uni_ovid, pflow->uni_ivid, ecvFlow->onuId, 0x0C, 0, 0, addOrRemove, ecvFlow->packageBmpList, ecvFlow->noOfPackages) != L7_SUCCESS) )
-  {
-    PT_LOG_WARN(LOG_CTX_EVC, "EVC# %u: IGMP Client Not Found", evc_id);
-    return SUCCESS;
+    /* Add client */
+    if ( (rc = ptin_igmp_api_client_add(&clientId, pflow->uni_ovid, pflow->uni_ivid, ecvFlow->onuId, 0x0C, 0, 0, addOrRemove, ecvFlow->packageBmpList, ecvFlow->noOfPackages) != L7_SUCCESS) )
+    {
+      PT_LOG_WARN(LOG_CTX_EVC, "EVC# %u: IGMP Client Not Found", evc_id);
+      return SUCCESS;
+    }
+    return rc;
   }
-  return rc;
 #else
   PT_LOG_ERR(LOG_CTX_EVC, "eEVC# %u: Flows not available for this board", evc_id);
   return L7_ERROR;
 #endif  
 }
 
@@ -5279,12 +5280,13 @@ L7_RC_t ptin_evc_macbridge_client_packag
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
 L7_RC_t ptin_evc_flow_remove_port(L7_uint32 ptin_port, L7_uint32 evc_ext_id)
 {
   L7_uint32 evc_id;
   dl_queue_t *queue;
+  struct ptin_evc_client_s *pclientFlow = NULL;
 
   /* Validate EVC# range (EVC index [0..PTIN_SYSTEM_N_EVCS[) */
   if (evc_ext_id >= PTIN_SYSTEM_N_EXTENDED_EVCS)
   {
     PT_LOG_ERR(LOG_CTX_EVC, "eEVC# %u is out of range [0..%u]", evc_ext_id, PTIN_SYSTEM_N_EXTENDED_EVCS-1);
     return L7_FAILURE;
@@ -5294,14 +5296,12 @@ L7_RC_t ptin_evc_flow_remove_port(L7_uin
   if (ptin_evc_ext2int(evc_ext_id, &evc_id) != L7_SUCCESS)
   {
     PT_LOG_ERR(LOG_CTX_EVC, "eEVC# %u is not in use", evc_id);
     return L7_FAILURE;
   }
 
-  struct ptin_evc_client_s *pclientFlow = NULL;
-
   queue = &evcs[evc_id].intf[ptin_port].clients;
   dl_queue_get_head( queue, (dl_queue_elem_t **)&pclientFlow);
 
   while (pclientFlow != NULL)
   {
 
@@ -5343,12 +5343,13 @@ L7_RC_t ptin_evc_flow_remove_port(L7_uin
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
 L7_RC_t ptin_evc_flow_replicate(L7_uint32 ptin_port, L7_uint32 evc_ext_id, L7_uint32 leaf_port)
 { 
   L7_uint32  evc_id, intIfNum;
   dl_queue_t *queue;
+  struct ptin_evc_client_s *pclientFlow = NULL;
 
  /* Validate EVC# range (EVC index [0..PTIN_SYSTEM_N_EVCS[) */
   if (evc_ext_id >= PTIN_SYSTEM_N_EXTENDED_EVCS)
   {
     PT_LOG_ERR(LOG_CTX_EVC, "eEVC# %u is out of range [0..%u]", evc_ext_id, PTIN_SYSTEM_N_EXTENDED_EVCS-1);
     return L7_FAILURE;
@@ -5374,14 +5375,12 @@ L7_RC_t ptin_evc_flow_replicate(L7_uint3
   if (ptin_intf_port2intIfNum(leaf_port, &intIfNum) != L7_SUCCESS)
   {
     PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Cannot get intIfNum from port %u", evc_id, leaf_port);
     return L7_FAILURE;
   }
 
-  struct ptin_evc_client_s *pclientFlow = NULL;
-
   queue = &evcs[evc_id].intf[leaf_port].clients;
   dl_queue_get_head( queue, (dl_queue_elem_t **)&pclientFlow);
 
   while (pclientFlow != NULL)
   {
 
@@ -5473,178 +5472,179 @@ L7_RC_t ptin_evc_flow_add(ptin_HwEthEvcF
   {
     PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Flows are only applied to QUATTRO services", evc_id);
     return L7_FAILURE;
   }
 
 #if PTIN_QUATTRO_FLOWS_FEATURE_ENABLED
-  L7_uint int_ovid;
-  L7_int  vport_id, multicast_group;
-  L7_BOOL igmp_enabled, dhcpv4_enabled, dhcpv6_enabled, pppoe_enabled;
-  /* Always add client */
-  ptin_client_id_t clientId;
+  {
+    L7_uint int_ovid;
+    L7_int  vport_id, multicast_group;
+    L7_BOOL igmp_enabled, dhcpv4_enabled, dhcpv6_enabled, pppoe_enabled;
+    /* Always add client */
+    ptin_client_id_t clientId;
 
-  struct ptin_evc_client_s *pflow;
+    struct ptin_evc_client_s *pflow;
 
-  /* Get internal vlan and inner NNI vlan */
-  int_ovid = evcs[evc_id].intf[leaf_port].int_vlan;
+    /* Get internal vlan and inner NNI vlan */
+    int_ovid = evcs[evc_id].intf[leaf_port].int_vlan;
 
-  /* Multicast group */
-  multicast_group = evcs[evc_id].multicast_group;
+    /* Multicast group */
+    multicast_group = evcs[evc_id].multicast_group;
 
-  /* Check if flow entry already exists */
-  ptin_evc_find_flow(evcFlow->uni_ovid, &evcs[evc_id].intf[leaf_port].clients, (dl_queue_elem_t**) &pflow);
+    /* Check if flow entry already exists */
+    ptin_evc_find_flow(evcFlow->uni_ovid, &evcs[evc_id].intf[leaf_port].clients, (dl_queue_elem_t**) &pflow);
 
-  /* If flow does it, create it */
-  if (pflow == NULL)
-  {
-    /* Check if there is available flows */
-    if (queue_free_clients.n_elems == 0)
+    /* If flow does it, create it */
+    if (pflow == NULL)
     {
-      PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: No available flows", evc_id);
-      return L7_FAILURE;
-    }
+      /* Check if there is available flows */
+      if (queue_free_clients.n_elems == 0)
+      {
+        PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: No available flows", evc_id);
+        return L7_FAILURE;
+      }
 
-    /* Create virtual port */
-    if (ptin_virtual_port_add(intIfNum,
-                              evcFlow->uni_ovid, evcFlow->uni_ivid,
-                              int_ovid, evcFlow->int_ivid,
-                              multicast_group,
-                              &vport_id,
-                              evcFlow->macLearnMax) != L7_SUCCESS)
-    {
-      PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error creating virtual port", evc_id);
-      return L7_FAILURE;
+      /* Create virtual port */
+      if (ptin_virtual_port_add(intIfNum,
+                                evcFlow->uni_ovid, evcFlow->uni_ivid,
+                                int_ovid, evcFlow->int_ivid,
+                                multicast_group,
+                                &vport_id,
+                                evcFlow->macLearnMax) != L7_SUCCESS)
+      {
+        PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error creating virtual port", evc_id);
+        return L7_FAILURE;
+      }
+      else
+      {
+        intf_vp_entry_t e;
+
+        e.vport_id  = vport_id & 0xffffff;
+        e.pon       = evcFlow->ptin_intf;
+        e.gem_id    = evcFlow->uni_ovid;
+        //e.onu       = evcFlow->onuId;
+        intf_vp_DB(1, &e);
+      }
+
+      /* Add client to the EVC struct */
+      dl_queue_remove_head(&queue_free_clients, (dl_queue_elem_t**) &pflow);    /* get a free client entry */
+      pflow->in_use     = L7_TRUE;                                              /* update it */
+      pflow->int_ovid   = int_ovid;
+      pflow->int_ivid   = evcFlow->int_ivid;
+      pflow->uni_ovid   = evcFlow->uni_ovid;
+      pflow->uni_ivid   = evcFlow->uni_ivid;
+      pflow->action_outer_vlan = PTIN_XLATE_ACTION_REPLACE;
+      pflow->action_inner_vlan = PTIN_XLATE_ACTION_NONE;
+      pflow->client_vid = evcFlow->uni_ivid;
+      pflow->flags      = 0; //evcFlow->flags;    /* Initial value: no flags exist */
+      pflow->virtual_gport = vport_id;
+      pflow->vport_id   = vport_id & 0xffffff;
+      pflow->macLearnMax  = evcFlow->macLearnMax;
+      pflow->onuId        = evcFlow->onuId;
+      pflow->mask         = evcFlow->mask;
+      pflow->maxBandwidth = evcFlow->maxBandwidth;
+      pflow->maxChannels  = evcFlow->maxChannels;
+
+      dl_queue_add_tail(&evcs[evc_id].intf[leaf_port].clients, (dl_queue_elem_t*) pflow); /* add it to the corresponding interface */
+      evcs[evc_id].n_clientflows++;
+
+      PT_LOG_TRACE(LOG_CTX_EVC, "eEVC# %u: flow successfully added (vport_id=%lu\tpon=%u/%u(%lu)\tgem_id=%u\tvirtual_gport=0x%8.8lx)",
+               evc_ext_id,
+               vport_id & 0xffffff,
+               evcFlow->ptin_intf.intf_type,evcFlow->ptin_intf.intf_id, intIfNum,
+               evcFlow->uni_ovid, vport_id);
     }
     else
     {
-      intf_vp_entry_t e;
+      PT_LOG_WARN(LOG_CTX_EVC, "EVC# %u: GEM id already exists", evc_id, evcFlow->uni_ovid, leaf_port);
+    }
 
-      e.vport_id  = vport_id & 0xffffff;
-      e.pon       = evcFlow->ptin_intf;
-      e.gem_id    = evcFlow->uni_ovid;
-      //e.onu       = evcFlow->onuId;
-      intf_vp_DB(1, &e);
-    }
-
-    /* Add client to the EVC struct */
-    dl_queue_remove_head(&queue_free_clients, (dl_queue_elem_t**) &pflow);    /* get a free client entry */
-    pflow->in_use     = L7_TRUE;                                              /* update it */
-    pflow->int_ovid   = int_ovid;
-    pflow->int_ivid   = evcFlow->int_ivid;
-    pflow->uni_ovid   = evcFlow->uni_ovid;
-    pflow->uni_ivid   = evcFlow->uni_ivid;
-    pflow->action_outer_vlan = PTIN_XLATE_ACTION_REPLACE;
-    pflow->action_inner_vlan = PTIN_XLATE_ACTION_NONE;
-    pflow->client_vid = evcFlow->uni_ivid;
-    pflow->flags      = 0; //evcFlow->flags;    /* Initial value: no flags exist */
-    pflow->virtual_gport = vport_id;
-    pflow->vport_id   = vport_id & 0xffffff;
-    pflow->macLearnMax  = evcFlow->macLearnMax;
-    pflow->onuId        = evcFlow->onuId;
-    pflow->mask         = evcFlow->mask;
-    pflow->maxBandwidth = evcFlow->maxBandwidth;
-    pflow->maxChannels  = evcFlow->maxChannels;
-
-    dl_queue_add_tail(&evcs[evc_id].intf[leaf_port].clients, (dl_queue_elem_t*) pflow); /* add it to the corresponding interface */
-    evcs[evc_id].n_clientflows++;
-
-    PT_LOG_TRACE(LOG_CTX_EVC, "eEVC# %u: flow successfully added (vport_id=%lu\tpon=%u/%u(%lu)\tgem_id=%u\tvirtual_gport=0x%8.8lx)",
-             evc_ext_id,
-             vport_id & 0xffffff,
-             evcFlow->ptin_intf.intf_type,evcFlow->ptin_intf.intf_id, intIfNum,
-             evcFlow->uni_ovid, vport_id);
-  }
-  else
-  {
-    PT_LOG_WARN(LOG_CTX_EVC, "EVC# %u: GEM id already exists", evc_id, evcFlow->uni_ovid, leaf_port);
-  }
+    /* Protocols */
+    igmp_enabled    = (evcFlow->flags & PTIN_EVC_MASK_IGMP_PROTOCOL  ) == PTIN_EVC_MASK_IGMP_PROTOCOL;
+    dhcpv4_enabled  = (evcFlow->flags & PTIN_EVC_MASK_DHCPV4_PROTOCOL) == PTIN_EVC_MASK_DHCPV4_PROTOCOL;
+    dhcpv6_enabled  = (evcFlow->flags & PTIN_EVC_MASK_DHCPV6_PROTOCOL) == PTIN_EVC_MASK_DHCPV6_PROTOCOL;
+    pppoe_enabled   = (evcFlow->flags & PTIN_EVC_MASK_PPPOE_PROTOCOL ) == PTIN_EVC_MASK_PPPOE_PROTOCOL;
 
-  /* Protocols */
-  igmp_enabled    = (evcFlow->flags & PTIN_EVC_MASK_IGMP_PROTOCOL  ) == PTIN_EVC_MASK_IGMP_PROTOCOL;
-  dhcpv4_enabled  = (evcFlow->flags & PTIN_EVC_MASK_DHCPV4_PROTOCOL) == PTIN_EVC_MASK_DHCPV4_PROTOCOL;
-  dhcpv6_enabled  = (evcFlow->flags & PTIN_EVC_MASK_DHCPV6_PROTOCOL) == PTIN_EVC_MASK_DHCPV6_PROTOCOL;
-  pppoe_enabled   = (evcFlow->flags & PTIN_EVC_MASK_PPPOE_PROTOCOL ) == PTIN_EVC_MASK_PPPOE_PROTOCOL;
-
-  /* Client id: For IGMP */
-  memset(&clientId, 0x00, sizeof(clientId));
-  clientId.ptin_intf.intf_type  = evcFlow->ptin_intf.intf_type;
-  clientId.ptin_intf.intf_id    = evcFlow->ptin_intf.intf_id;
-  clientId.outerVlan            = pflow->int_ovid;
-  clientId.innerVlan            = pflow->int_ivid;
-  clientId.mask                 = PTIN_CLIENT_MASK_FIELD_INTF | PTIN_CLIENT_MASK_FIELD_OUTERVLAN | PTIN_CLIENT_MASK_FIELD_INNERVLAN;
+    /* Client id: For IGMP */
+    memset(&clientId, 0x00, sizeof(clientId));
+    clientId.ptin_intf.intf_type  = evcFlow->ptin_intf.intf_type;
+    clientId.ptin_intf.intf_id    = evcFlow->ptin_intf.intf_id;
+    clientId.outerVlan            = pflow->int_ovid;
+    clientId.innerVlan            = pflow->int_ivid;
+    clientId.mask                 = PTIN_CLIENT_MASK_FIELD_INTF | PTIN_CLIENT_MASK_FIELD_OUTERVLAN | PTIN_CLIENT_MASK_FIELD_INNERVLAN;
 
-  /* Manage IGMP client */
-  if (evcFlow->flags & PTIN_EVC_MASK_IGMP_PROTOCOL)
-  {
-    /* Add client */
-    if (ptin_igmp_api_client_add(&clientId, pflow->uni_ovid, pflow->uni_ivid, evcFlow->onuId, evcFlow->mask, evcFlow->maxBandwidth, evcFlow->maxChannels, L7_FALSE, evcFlow->packageBmpList, evcFlow->noOfPackages) != L7_SUCCESS)
+    /* Manage IGMP client */
+    if (evcFlow->flags & PTIN_EVC_MASK_IGMP_PROTOCOL)
     {
-      PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error adding client to IGMP instance", evc_id);
+      /* Add client */
+      if (ptin_igmp_api_client_add(&clientId, pflow->uni_ovid, pflow->uni_ivid, evcFlow->onuId, evcFlow->mask, evcFlow->maxBandwidth, evcFlow->maxChannels, L7_FALSE, evcFlow->packageBmpList, evcFlow->noOfPackages) != L7_SUCCESS)
+      {
+        PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error adding client to IGMP instance", evc_id);
+        return L7_FAILURE;
+      }
+      else
+      {
+        PT_LOG_TRACE(LOG_CTX_EVC, "EVC# %u: Added client to IGMP instance", evc_id);
+      }
+    }
+    else if (evcs[evc_id].flags & PTIN_EVC_MASK_IGMP_PROTOCOL)
+    {
+      /* Remove client */
+      if (ptin_igmp_api_client_remove(&clientId) != L7_SUCCESS)
+      {
+        PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error removing client from IGMP instance", evc_id);
+        //rc = L7_FAILURE;    /* L7_NOT_EXIST is not an error */
+      }
+      else
+      {
+        PT_LOG_TRACE(LOG_CTX_EVC, "EVC# %u: Client removed from IGMP instance", evc_id);
+      }
+    }
+
+    /* ---------------- IGMP ------------------- */
+    /* Only configure IGMP for first time configurations */
+    if (ptin_evc_update_igmp(evc_id, &pflow->flags, igmp_enabled,
+                             L7_FALSE /*Update*/, L7_TRUE /*Look to counters*/) != L7_SUCCESS)
+    {
+      PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error configuring IGMP", evc_id);
+      ptin_igmp_api_client_remove(&clientId);
       return L7_FAILURE;
     }
     else
     {
-      PT_LOG_TRACE(LOG_CTX_EVC, "EVC# %u: Added client to IGMP instance", evc_id);
+      PT_LOG_TRACE(LOG_CTX_EVC, "EVC# %u: IGMP configured", evc_id);
     }
-  }
-  else if (evcs[evc_id].flags & PTIN_EVC_MASK_IGMP_PROTOCOL)
-  {
-    /* Remove client */
-    if (ptin_igmp_api_client_remove(&clientId) != L7_SUCCESS)
+
+    #if (!PTIN_BOARD_IS_MATRIX)
+    /* ---------------- DHCP ------------------- */
+    /* Only configure DHCP for first time configurations */
+    if (ptin_evc_update_dhcp(evc_id, &pflow->flags, dhcpv4_enabled, dhcpv6_enabled,
+                             L7_FALSE /*Update*/, L7_TRUE /*Look to counters*/) != L7_SUCCESS)
     {
-      PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error removing client from IGMP instance", evc_id);
-      //rc = L7_FAILURE;    /* L7_NOT_EXIST is not an error */
+      PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error configuring DHCP", evc_id);
+      return L7_FAILURE;
     }
     else
     {
-      PT_LOG_TRACE(LOG_CTX_EVC, "EVC# %u: Client removed from IGMP instance", evc_id);
+      PT_LOG_TRACE(LOG_CTX_EVC, "EVC# %u: DHCP configured", evc_id);
     }
-  }
 
-  /* ---------------- IGMP ------------------- */
-  /* Only configure IGMP for first time configurations */
-  if (ptin_evc_update_igmp(evc_id, &pflow->flags, igmp_enabled,
-                           L7_FALSE /*Update*/, L7_TRUE /*Look to counters*/) != L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error configuring IGMP", evc_id);
-    ptin_igmp_api_client_remove(&clientId);
-    return L7_FAILURE;
-  }
-  else
-  {
-    PT_LOG_TRACE(LOG_CTX_EVC, "EVC# %u: IGMP configured", evc_id);
-  }
-
-  #if (!PTIN_BOARD_IS_MATRIX)
-  /* ---------------- DHCP ------------------- */
-  /* Only configure DHCP for first time configurations */
-  if (ptin_evc_update_dhcp(evc_id, &pflow->flags, dhcpv4_enabled, dhcpv6_enabled,
-                           L7_FALSE /*Update*/, L7_TRUE /*Look to counters*/) != L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error configuring DHCP", evc_id);
-    return L7_FAILURE;
-  }
-  else
-  {
-    PT_LOG_TRACE(LOG_CTX_EVC, "EVC# %u: DHCP configured", evc_id);
-  }
-
-  /* ---------------- PPPoE ------------------- */
-  /* PPPoE configuration */
-  if (ptin_evc_update_pppoe(evc_id, &pflow->flags, pppoe_enabled,
-                            L7_FALSE /*Update*/, L7_TRUE /*Look to counters*/) != L7_SUCCESS)
-  {
-    PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error configuring PPPoE", evc_id);
-    return L7_FAILURE;
-  }
-  else
-  {
-    PT_LOG_TRACE(LOG_CTX_EVC, "EVC# %u: PPPoE configured", evc_id);
+    /* ---------------- PPPoE ------------------- */
+    /* PPPoE configuration */
+    if (ptin_evc_update_pppoe(evc_id, &pflow->flags, pppoe_enabled,
+                              L7_FALSE /*Update*/, L7_TRUE /*Look to counters*/) != L7_SUCCESS)
+    {
+      PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: Error configuring PPPoE", evc_id);
+      return L7_FAILURE;
+    }
+    else
+    {
+      PT_LOG_TRACE(LOG_CTX_EVC, "EVC# %u: PPPoE configured", evc_id);
+    }
+    #endif
   }
-  #endif
-
 #else
   PT_LOG_ERR(LOG_CTX_EVC, "eEVC# %u: Flows not available for this board", evc_id);
   return L7_ERROR;
 #endif
 
   return L7_SUCCESS;
Index: src/application/ptin/base/ethsrv_oam.c
===================================================================
--- src/application/ptin/base/ethsrv_oam.c	(revision 7746)
+++ src/application/ptin/base/ethsrv_oam.c	(revision 7747)
@@ -853,22 +853,21 @@ _proc_ethsrv_oam_CSF_function_end:
     if (1==_p_mep_lm->CCMs0_LMMR1) {
         //Check if it's time to send LMMs on this MEP...
         if (!valid_oam_tmr(_p_mep_lm->period)) goto _proc_ethsrv_oam_LM_function_end;
         tmout= OAM_TMR_CODE_TO_ms[_p_mep_lm->period];
         _p_mep_lm->LMM_timer += T_ms;
         if (_p_mep_lm->LMM_timer+T_ms/2 > tmout) {//time_2_send_lmm=1;
+            L7_int32 intIfNum; 
+
             _p_mep_lm->LMM_timer=0;
 
             // Get MAC Address
-            L7_int32 intIfNum; 
             ETHSRV_OAM_LOG ("%u", _p_mep->prt);
             ptin_intf_port2intIfNum( _p_mep->prt, &intIfNum);
             nimGetIntfAddress(intIfNum, 1, _p_mep_lm->DMAC.byte);   //memcpy(buff, pSMAC, 6)
 
-
-
             ETHSRV_OAM_LOG ("MAC %02x:%02x:%02x:%02x:%02x:%02x ", 
            _p_mep_lm->SMAC.byte[0],  _p_mep_lm->SMAC.byte[1],  _p_mep_lm->SMAC.byte[2],  _p_mep_lm->SMAC.byte[3],  _p_mep_lm->SMAC.byte[4],  _p_mep_lm->SMAC.byte[5]);
 
             #ifdef __Y1731_802_1ag_OAM_ETH__
 
             #if(PTIN_BOARD == PTIN_BOARD_TA48GE)
@@ -1458,13 +1457,13 @@ u16                 ltr_len = sizeof(ETH
      {
       T_LTM_EG_ID_TLV *ltm_eg_id;
 
          ltm_eg_id= (T_LTM_EG_ID_TLV *) &((u8*)p_ltm)[i_eg_id_tlv];
          memcpy(&p_eg_id->last, &ltm_eg_id->v, sizeof(p_eg_id->last));
          memset(p_eg_id->next.zero, 0, 2);
-         memcpy(p_eg_id->next.mac, MP_MAC, sizeof(p_eg_id->next.mac));
+         memcpy(p_eg_id->next.mac, MP_MAC, sizeof(u8)*6);
      }
 
      //REPLY ING/EG TLV
      //Assuming RPL_IN_ID_TLV and RPL_EG_ID_TLV are the same, other than the "type" field
      p_rpl_id=                  (T_RPL_IN_ID_TLV *) ((u8*)p_eg_id+sizeof(T_LTR_EG_ID_TLV));
      p_rpl_id->len=             htons(TLV_LENGTH(T_RPL_IN_ID_TLV));
@@ -1473,13 +1472,13 @@ u16                 ltr_len = sizeof(ETH
          p_rpl_id->action=      egaction;    
      }
      else {
          p_rpl_id->type=        REPLY_IN_TLV_TYPE;
          p_rpl_id->action=      ingaction;    
      }
-     memcpy(p_rpl_id->v.mac, MP_MAC, sizeof(p_rpl_id->v.mac));
+     memcpy(p_rpl_id->v.mac, MP_MAC, sizeof(u8)*6);
 
      //END TLV
      ((u8*)p_rpl_id)[sizeof(T_RPL_IN_ID_TLV)]=0;
 
      ltr_len+= sizeof(T_LTR_EG_ID_TLV)+sizeof(T_RPL_IN_ID_TLV);
  }
Index: src/application/ptin/base/ptin_debug.c
===================================================================
--- src/application/ptin/base/ptin_debug.c	(revision 7746)
+++ src/application/ptin/base/ptin_debug.c	(revision 7747)
@@ -1061,27 +1061,26 @@ inline void print_string_hex(char *str,
  * @param hex 
  * @param print_all 
  * @param char_identify 
  */
 void ptin_process_cpu(void)
 {
+  L7_char8   *start;
+  L7_char8   *end;
   L7_char8   printBuf[L7_CLI_MAX_STRING_LENGTH];
   L7_char8   *cpuUtil = "CPU Utilization:";
   L7_uint32  cpuUtilLen = osapiStrnlen(cpuUtil, L7_CLI_MAX_STRING_LENGTH);
 
   memset(buffer_threads, 0x00, sizeof(buffer_threads));
 
   if(usmdbCpuUtilizationStringGet(1, buffer_threads, L7_BUFFSIZE) != L7_SUCCESS)
   {
     printf("Error getting CPU utilization!\r\n");
     return;
   }
 
-  L7_char8 *start;
-  L7_char8 *end;
-
   start = buffer_threads;
   end   = buffer_threads;
   buffer_threads[L7_BUFFSIZE-1] = 0; /* For safety */
 
   do
   {
Index: src/application/ptin/base/ptin_prot_typeb.c
===================================================================
--- src/application/ptin/base/ptin_prot_typeb.c	(revision 7746)
+++ src/application/ptin/base/ptin_prot_typeb.c	(revision 7747)
@@ -100,44 +100,45 @@ L7_RC_t ptin_prottypeb_intf_config_set(p
   PT_LOG_TRACE(LOG_CTX_PROTB, "    status     : %u", data->status);
   PT_LOG_TRACE(LOG_CTX_PROTB, "    pairSlotId : %u", data->pairSlotId);
   PT_LOG_TRACE(LOG_CTX_PROTB, "    pairIntfNum: %u", data->pairIntfNum);
   memcpy(&prottypeb_interfaces[intfNum-1], data, sizeof(ptin_prottypeb_intf_config_t));
 
 #if !PTIN_BOARD_IS_MATRIX
-  if(prottypeb_interfaces[intfNum-1].status==L7_ENABLE)
   {
-    PT_LOG_NOTICE(LOG_CTX_MSG, "Not sending a Snoop Sync Request Message to Sync the  Snoop Entries. I'm a Working slotId/intfNum:%u/%u",prottypeb_interfaces[intfNum-1].slotId, prottypeb_interfaces[intfNum-1].intfNum);
-    return L7_SUCCESS;
-  }
-
-  msg_SnoopSyncRequest_t   snoopSyncRequest={0};
+    msg_SnoopSyncRequest_t   snoopSyncRequest={0};
+    L7_uint32 ipAddr;
 
-  snoopSyncRequest.portId = prottypeb_interfaces[intfNum-1].pairIntfNum;
+    if(prottypeb_interfaces[intfNum-1].status==L7_ENABLE)
+    {
+      PT_LOG_NOTICE(LOG_CTX_MSG, "Not sending a Snoop Sync Request Message to Sync the  Snoop Entries. I'm a Working slotId/intfNum:%u/%u",prottypeb_interfaces[intfNum-1].slotId, prottypeb_interfaces[intfNum-1].intfNum);
+      return L7_SUCCESS;
+    }
 
-  L7_uint32 ipAddr;
+    snoopSyncRequest.portId = prottypeb_interfaces[intfNum-1].pairIntfNum;
 
-  #if PTIN_BOARD_IS_STANDALONE
-    ipAddr = simGetIpcIpAddr();
-  #else
-    /* Determine the IP address of the working port/slot */
-    if (L7_SUCCESS != ptin_fpga_slot_ip_addr_get(prottypeb_interfaces[intfNum-1].pairSlotId, &ipAddr))
+    #if PTIN_BOARD_IS_STANDALONE
+      ipAddr = simGetIpcIpAddr();
+    #else
+      /* Determine the IP address of the working port/slot */
+      if (L7_SUCCESS != ptin_fpga_slot_ip_addr_get(prottypeb_interfaces[intfNum-1].pairSlotId, &ipAddr))
+      {
+        PT_LOG_ERR(LOG_CTX_PROTB, "Failed to obtain ipAddress of slotId:%u", prottypeb_interfaces[intfNum-1].pairSlotId);
+        return L7_FAILURE;
+      }
+    #endif      
+
+    PT_LOG_DEBUG(LOG_CTX_MSG, "Sending a Snoop Sync Request Message to ipAddr:%08X to Sync the Snoop Entries of remote slotId/intfNum:%u/%u", ipAddr,prottypeb_interfaces[intfNum-1].pairSlotId, prottypeb_interfaces[intfNum-1].pairIntfNum);
+    /*Send the snoop sync request to the protection matrix */  
+    if (send_ipc_message(IPC_HW_FASTPATH_PORT, ipAddr, CCMSG_MGMD_SNOOP_SYNC_REQUEST,
+                         (char *)(&snoopSyncRequest), NULL,
+                         sizeof(snoopSyncRequest), NULL) != 0)
     {
-      PT_LOG_ERR(LOG_CTX_PROTB, "Failed to obtain ipAddress of slotId:%u", prottypeb_interfaces[intfNum-1].pairSlotId);
+      PT_LOG_ERR(LOG_CTX_PROTB, "Failed to send Snoop Sync Request Message");
       return L7_FAILURE;
-    }
-  #endif      
-
-  PT_LOG_DEBUG(LOG_CTX_MSG, "Sending a Snoop Sync Request Message to ipAddr:%08X to Sync the Snoop Entries of remote slotId/intfNum:%u/%u", ipAddr,prottypeb_interfaces[intfNum-1].pairSlotId, prottypeb_interfaces[intfNum-1].pairIntfNum);
-  /*Send the snoop sync request to the protection matrix */  
-  if (send_ipc_message(IPC_HW_FASTPATH_PORT, ipAddr, CCMSG_MGMD_SNOOP_SYNC_REQUEST,
-                       (char *)(&snoopSyncRequest), NULL,
-                       sizeof(snoopSyncRequest), NULL) != 0)
-  {
-    PT_LOG_ERR(LOG_CTX_PROTB, "Failed to send Snoop Sync Request Message");
-    return L7_FAILURE;
-  }  
+    }  
+  }
 #endif
   return L7_SUCCESS;
 }
 
 /**
  * Get type-b protection interface configurations
Index: src/application/ip_mcast/mapping/pimsmmap/pimsm_map_debug.c
===================================================================
--- src/application/ip_mcast/mapping/pimsmmap/pimsm_map_debug.c	(revision 7746)
+++ src/application/ip_mcast/mapping/pimsmmap/pimsm_map_debug.c	(revision 7747)
@@ -1435,23 +1435,24 @@ void pimsmDebugDeRegister(void)
 
 
 
 void printPimsmDebug(L7_uchar8 family)
 {
   L7_uint32 flagIndex;
+  pimsmDebugTraceFlags_t *pimsmTraceFlags;
 
   sysapiPrintf("\n-----------------\n");
   sysapiPrintf("\n version = %d", pimsmDebugCfg.hdr.version);
   sysapiPrintf("\n compId = %d", pimsmDebugCfg.hdr.componentID);
   sysapiPrintf("\n type = %d", pimsmDebugCfg.hdr.type);
   sysapiPrintf("\n length = %d", pimsmDebugCfg.hdr.length);
   sysapiPrintf("\n fileName = %s", pimsmDebugCfg.hdr.filename);
   sysapiPrintf("\n dataChng = %d", pimsmDebugCfg.hdr.dataChanged);
   sysapiPrintf("\n-----------------\n");
 
-  pimsmDebugTraceFlags_t *pimsmTraceFlags = &(pimsmDebugCfg.cfg.pimsmDebugTraceFlag[family]);
+  pimsmTraceFlags = &(pimsmDebugCfg.cfg.pimsmDebugTraceFlag[family]);
   for (flagIndex = 0;  flagIndex < PIMSM_DEBUG_LAST_TRACE ; flagIndex ++)
   {
     if (((*(pimsmTraceFlags[flagIndex/PIMSM_DEBUG_TRACE_FLAG_BITS_MAX])) & 
          (PIMSM_DEBUG_TRACE_FLAG_VALUE << (flagIndex % PIMSM_DEBUG_TRACE_FLAG_BITS_MAX))) != 0)
     {
       sysapiPrintf("\n Flag [%d] is set", flagIndex);
Index: src/application/ip_mcast/mapping/pimdmmap/pimdm_map_debug.c
===================================================================
--- src/application/ip_mcast/mapping/pimdmmap/pimdm_map_debug.c	(revision 7746)
+++ src/application/ip_mcast/mapping/pimdmmap/pimdm_map_debug.c	(revision 7747)
@@ -1045,23 +1045,24 @@ void pimdmDebugDeRegister(void)
     (void) supportDebugDeregister(supportDebugDescr);
 }
 
 void printPimdmDebug(L7_uchar8 family)
 {
   L7_uint32 flagIndex;
+  pimdmDebugTraceFlags_t *pimdmTraceFlags;
 
   sysapiPrintf("\n-----------------\n");
   sysapiPrintf("\n version = %d", pimdmDebugCfg.hdr.version);
   sysapiPrintf("\n compId = %d", pimdmDebugCfg.hdr.componentID);
   sysapiPrintf("\n type = %d", pimdmDebugCfg.hdr.type);
   sysapiPrintf("\n length = %d", pimdmDebugCfg.hdr.length);
   sysapiPrintf("\n fileName = %s", pimdmDebugCfg.hdr.filename);
   sysapiPrintf("\n dataChng = %d", pimdmDebugCfg.hdr.dataChanged);
   sysapiPrintf("\n-----------------\n");
 
-  pimdmDebugTraceFlags_t *pimdmTraceFlags = &(pimdmDebugCfg.cfg.pimdmDebugTraceFlag[family]);
+  pimdmTraceFlags = &(pimdmDebugCfg.cfg.pimdmDebugTraceFlag[family]);
   for (flagIndex = 0;  flagIndex < PIMDM_DEBUG_LAST_TRACE ; flagIndex ++)
   {
     if (((*(pimdmTraceFlags[flagIndex/PIMDM_DEBUG_TRACE_FLAG_BITS_MAX])) & 
          (PIMDM_DEBUG_TRACE_FLAG_VALUE << (flagIndex % PIMDM_DEBUG_TRACE_FLAG_BITS_MAX))) != 0)
     {
       sysapiPrintf("\n Flag [%d] is set", flagIndex);
Index: src/application/ip_mcast/vendor/mgmd/mgmd.c
===================================================================
--- src/application/ip_mcast/vendor/mgmd/mgmd.c	(revision 7746)
+++ src/application/ip_mcast/vendor/mgmd/mgmd.c	(revision 7747)
@@ -4151,13 +4151,13 @@ static void mgmd_timeout_groups_event_ha
       mgmd_group_delete(mgmdCB,mgmd_group);
     }
     else
     {
       if (proxy_status == L7_ENABLE)
       {
-        L7_inet_addr_t       *proxySrcList = mgmdCB->querySrcList;;
+        L7_inet_addr_t       *proxySrcList = mgmdCB->querySrcList;
         L7_uint32             proxySrcCount = 0, index;
 
         for (index=0; index < MGMD_MAX_QUERY_SOURCES; index++)
         {
           inetAddressZeroSet (mgmdCB->proto, &proxySrcList[index]);
         }
Index: src/application/ip_mcast/vendor/mgmd/mgmd_main.c
===================================================================
--- src/application/ip_mcast/vendor/mgmd/mgmd_main.c	(revision 7746)
+++ src/application/ip_mcast/vendor/mgmd/mgmd_main.c	(revision 7747)
@@ -759,13 +759,13 @@ static L7_RC_t mgmd_proxy_report_destroy
 * @returns L7_SUCCESS
 * @returns L7_FAILURE
 *
 * @notes 
 * @end
 ********************************************************************/
-static L7_int32 mgmd_proxy_report_compare (void *pData1, void *pData2, size_t size)
+static L7_int32 mgmd_proxy_report_compare (void *pData1, void *pData2, L7_uint32 size)
 {
   mgmd_proxy_unsolicited_rpt_t *pKey1 = (mgmd_proxy_unsolicited_rpt_t *)pData1;
   mgmd_proxy_unsolicited_rpt_t *pKey2 = (mgmd_proxy_unsolicited_rpt_t *)pData2;
 
   if ((pKey1 == L7_NULLPTR) || (pKey2 == L7_NULLPTR))
   {
Index: src/application/ip_mcast/vendor/pimsm/pimsmcontrol.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmcontrol.c	(revision 7746)
+++ src/application/ip_mcast/vendor/pimsm/pimsmcontrol.c	(revision 7747)
@@ -2395,15 +2395,16 @@ static L7_RC_t pimsmIgmpV3MemberExcludeM
   pimsmSGIEntry_t *pSGIEntry = L7_NULLPTR;
   L7_BOOL bDelete = L7_FALSE;
   pimsmInterfaceEntry_t *pIntfEntry = L7_NULLPTR;
   L7_int32 numSrcs =0;
   L7_uint32 i = 0;
   L7_uchar8  buf[IPV6_DISP_ADDR_LEN];
-  numSrcs = srcCount;
   pimsmSGRptNode_t *pSGRptNode = L7_NULLPTR;
   
+  numSrcs = srcCount;
+
   for (i = 0; i < numSrcs; i++)
   {
     if (pMgmdGrpInfo->sourceList[i] == L7_NULLPTR)
     {
       PIMSM_TRACE(PIMSM_DEBUG_BIT_MGMD_INTERACTION, PIMSM_TRACE_ERROR,
                   "MGMD Update Entry Source List Buffer Ptr is NULL");
Index: src/application/switching/pppoe/pppoe_main.c
===================================================================
--- src/application/switching/pppoe/pppoe_main.c	(revision 7746)
+++ src/application/switching/pppoe/pppoe_main.c	(revision 7747)
@@ -274,17 +274,16 @@ L7_RC_t pppoePduReceive(L7_netBufHandle
   /* This is used only when the packet comes double tagged.*/
   vlanId = pduInfo->vlanId;
   innerVlanId = pduInfo->innerVlanId;
 
   /* Only search and validate client for non Matrix (CXP360G, etc) and untrusted interfaces */
 #if ( ! PTIN_BOARD_IS_MATRIX )
-
-  ptin_client_id_t client;
-
 //  if (!_pppoeVlanIntfTrustGet(pduInfo->vlanId,pduInfo->intIfNum))
   {
+    ptin_client_id_t client;
+
     #if 0
     /* Validate inner vlan */
     if (innerVlanId==0 || innerVlanId>=4095)
     {
       if (ptin_debug_pppoe_snooping)
         PT_LOG_ERR(LOG_CTX_PPPOE,"Client not referenced! (intIfNum=%u, innerVlanId=%u, intVlanId=%u)",
@@ -657,13 +656,13 @@ L7_RC_t pppoeCopyTlv(L7_uchar8 *original
 L7_RC_t pppoeCommonErrorFrameCreate(L7_uchar8 *originalFramePtr, L7_uchar8 *newFramePtr, L7_uint32 *newFrameLen)
 {
    L7_uchar8         *eth_header_new_ptr, *pppoe_header_new_ptr, *tlv_header_new_ptr;
    L7_pppoe_header_t *pppoe_header_new;
    L7_ethHeader_t    *eth_header_new;
    L7_tlv_header_t   tlv_header;
-   L7_uchar8         system_mac_addr;
+   L7_uchar8         system_mac_addr[L7_ENET_MAC_ADDR_LEN];
 
    /* Copy the original frame up to the end of the PPPoE header */
    memset(newFramePtr, 0x00, PPPOE_PACKET_SIZE_MAX);
    memcpy(newFramePtr, originalFramePtr, sysNetDataOffsetGet(originalFramePtr) + sizeof(L7_pppoe_header_t));
    eth_header_new_ptr   = newFramePtr;
    eth_header_new       = (L7_ethHeader_t*) eth_header_new_ptr;
@@ -692,19 +691,19 @@ L7_RC_t pppoeCommonErrorFrameCreate(L7_u
    pppoe_header_new->length = osapiHtons(sizeof(L7_tlv_header_t));
 
    /* Set Ethernet header DST as the previous SRC, and the new SRC as the system MAC address */
    memcpy(&eth_header_new->dest.addr, &eth_header_new->src.addr, sizeof(L7_enetMacAddr_t));
    if (simGetSystemIPMacType() == L7_SYSMAC_BIA)
    {
-    simGetSystemIPBurnedInMac(&system_mac_addr);
+    simGetSystemIPBurnedInMac(system_mac_addr);
    }
    else
    {
-    simGetSystemIPLocalAdminMac(&system_mac_addr);
+    simGetSystemIPLocalAdminMac(system_mac_addr);
    }
-   memcpy(&eth_header_new->src.addr, &system_mac_addr, sizeof(L7_enetMacAddr_t));
+   memcpy(&eth_header_new->src.addr, &system_mac_addr, sizeof(L7_uchar8)*L7_ENET_MAC_ADDR_LEN);
 
    return L7_SUCCESS;
 }
 
 #if 0
 /***********************************************************************
@@ -773,12 +772,13 @@ L7_RC_t pppoeClientFrameSend(L7_uint32 i
   L7_uint16         frame_len;
   L7_uchar8         *dataStart, *pppoe_header_ptr;
   L7_netBufHandle   bufHandle;
   L7_pppoe_header_t *pppoe_header;
   L7_INTF_TYPES_t   sysIntfType;
   L7_uint32         member_mode;
+  L7_uint16         extOVlan, extIVlan;
 
   /* If outgoing interface is CPU interface, don't send it */
   if ((nimGetIntfType(intIfNum, &sysIntfType) == L7_SUCCESS) &&
       (sysIntfType == L7_CPU_INTF))
   {
     return L7_SUCCESS;
@@ -806,14 +806,14 @@ L7_RC_t pppoeClientFrameSend(L7_uint32 i
   pppoe_header_ptr     = frame + sysNetDataOffsetGet(frame);
   pppoe_header         = (L7_pppoe_header_t*) pppoe_header_ptr;
   frame_len            = sysNetDataOffsetGet(frame) + sizeof(L7_pppoe_header_t) + osapiNtohs(pppoe_header->length);
 
   /* PTin added: PPPOE */
   #if 1
-  L7_uint16 extOVlan = vlanId;
-  L7_uint16 extIVlan = 0;
+  extOVlan = vlanId;
+  extIVlan = 0;
 
   /* Extract external outer and inner vlan for this tx interface */
   if (ptin_pppoe_extVlans_get(intIfNum, vlanId, innerVlanId, client_idx, &extOVlan,&extIVlan) == L7_SUCCESS)
   {
     /* Modify outer vlan */
     if (vlanId!=extOVlan)
Index: src/application/switching/link_aggregation/core/dot3ad_lacp.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_lacp.c	(revision 7746)
+++ src/application/switching/link_aggregation/core/dot3ad_lacp.c	(revision 7747)
@@ -91,13 +91,13 @@ static dot3ad_mux_machine_state_t muxSta
 
 };
 
 extern L7_uint32 dot3adBufferPoolId;
 
 static unsigned short int ptin_debug_lacp = 0;
-inline void ptin_debug_lacp_set(unsigned short int enable){ptin_debug_lacp = enable;};
+void ptin_debug_lacp_set(unsigned short int enable){ptin_debug_lacp = enable;};
 
 /**************************************************************************
 *
 * @purpose  Records the parameter values for the actor carried in the rx pdu
 *
 * @param   *p  pointer to the aggregator port structure
@@ -1520,12 +1520,13 @@ L7_RC_t dot3adMuxMachineAttachedAction(d
 *
 * @end
 *
 *************************************************************************/
 L7_RC_t dot3adMuxMachineCollDistAction(dot3ad_port_t *p)
 {
+  dot3ad_agg_t *a;
   L7_RC_t rc;
 
   PT_LOG_INFO(LOG_CTX_TRUNKS, "Coll+Dist Action: intIfNum=%u", p->actorPortNum);
 
   p->actorOperPortState |= DOT3AD_STATE_DISTRIBUTING;
   rc = dot3adEnableCollDist(p);
@@ -1548,13 +1549,12 @@ L7_RC_t dot3adMuxMachineCollDistAction(d
   /*set mux state to collDist*/
   p->muxState = COLL_DIST;
 
   /* PTin added: Blocked state */
 #if 1
   /* is the aggregator valid */
-  dot3ad_agg_t  *a;
   a = dot3adAggIntfFind(p->actorOperPortKey);
   if (a == L7_NULLPTR)
   {
     PT_LOG_TRACE(LOG_CTX_TRUNKS, "Leaving...");
     return L7_FAILURE;
   }
Index: src/application/switching/link_aggregation/core/dot3ad_lac.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_lac.c	(revision 7746)
+++ src/application/switching/link_aggregation/core/dot3ad_lac.c	(revision 7747)
@@ -301,13 +301,13 @@ L7_uint32 dot3adIntfChangeCallBackProces
 *********************************************************************/
 L7_RC_t dot3adIntfChangeCallBack(L7_uint32 intIfNum, L7_uint32 event,NIM_CORRELATOR_t correlator)
 {
   L7_RC_t rc;
   dot3adMsg_t msg;
   NIM_EVENT_COMPLETE_INFO_t status;
-
+  L7_int32 numMsg;
 
 
   PT_LOG_TRACE(LOG_CTX_EVENTS, "dot3adIntfChangeCallBack: event=%u, intIfNum=%u", event, intIfNum);
 
   if (event != L7_PORT_ENABLE &&
       event != L7_UP &&
@@ -341,13 +341,13 @@ L7_RC_t dot3adIntfChangeCallBack(L7_uint
   msg.intf  = intIfNum;
   msg.intfData.nimInfo.intIfNum     = intIfNum;
   msg.intfData.nimInfo.component    = L7_DOT3AD_COMPONENT_ID;
   msg.intfData.nimInfo.event        = event;
   msg.intfData.nimInfo.correlator   = correlator;
 
-  L7_int32 numMsg = -1;
+  numMsg = -1;
   osapiMsgQueueGetNumMsgs(dot3ad_queue, &numMsg);
   PT_LOG_TRACE(LOG_CTX_EVENTS, "Going to send message: event=%u, intIfNum=%u, msg_count=%d", event, intIfNum, numMsg);
 
   rc = osapiMessageSend(dot3ad_queue, &msg, (L7_uint32)DOT3AD_MSG_SIZE, L7_NO_WAIT, L7_MSG_PRIORITY_NORM);
 
   numMsg = -1;
Index: src/application/switching/voice_vlan/core/voice_vlan_cnfgr.c
===================================================================
--- src/application/switching/voice_vlan/core/voice_vlan_cnfgr.c	(revision 7746)
+++ src/application/switching/voice_vlan/core/voice_vlan_cnfgr.c	(revision 7747)
@@ -79,15 +79,16 @@ extern PORTEVENT_MASK_t   voiceVlanNimEv
 * @end
 *********************************************************************/
 static
 L7_RC_t voiceVlanCnfgrInitPhase1Process(L7_CNFGR_RESPONSE_t * pResponse,
                                         L7_CNFGR_ERR_RC_t * pReason)
 {
+  L7_RC_t rc = L7_FAILURE;
+
   *pResponse = L7_CNFGR_CMD_COMPLETE;
   *pReason = 0;
-  L7_RC_t rc = L7_FAILURE;
 
   /* Allocate and initialized memory for global data */
   voiceVlanCfg = (voiceVlanCfg_t *) osapiMalloc(L7_VOICE_VLAN_COMPONENT_ID,
                                                 sizeof(voiceVlanCfg_t));
 
   voiceVlanInfo  = ( voiceVlanInfo_t *) osapiMalloc(L7_VOICE_VLAN_COMPONENT_ID,
Index: src/application/switching/voice_vlan/core/voice_vlan.c
===================================================================
--- src/application/switching/voice_vlan/core/voice_vlan.c	(revision 7746)
+++ src/application/switching/voice_vlan/core/voice_vlan.c	(revision 7747)
@@ -1060,15 +1060,16 @@ L7_RC_t  voiceVlanPortStatusSet(L7_uint3
                    __FUNCTION__, intfNum, ifName,status,voiceVlanInfo->portData[operIndex].portStatus);
   if (status == L7_ENABLE && status != voiceVlanInfo->portData[operIndex].portStatus)
   {
     /* check if administratively enabled */
     if ((voiceVlanCfg->voiceVlanAdminMode == L7_ENABLE) && (pCfg->adminMode == L7_ENABLE))
     {
+      L7_uint32 currAcquired;
+
       VOICE_VLAN_TRACE(VOICE_VLAN_TRACE_DEBUG, "%s: Voice Vlan admin mode [%d] Configured Interface mode [%d] \r\n",
                        __FUNCTION__,voiceVlanCfg->voiceVlanAdminMode,pCfg->adminMode );
-      L7_uint32 currAcquired;
 
       /* check the interface state:  Link must be up and either (active or unauth voice VLAN enabled) */
       if ((L7_UP      != linkState) ||
           ((L7_ACTIVE != activeState) &&
            (L7_ENABLE == voiceVlanInfo->portData[operIndex].authState)))
       {
Index: src/application/switching/garp/dot1dgarp.c
===================================================================
--- src/application/switching/garp/dot1dgarp.c	(revision 7746)
+++ src/application/switching/garp/dot1dgarp.c	(revision 7747)
@@ -1568,20 +1568,20 @@ void garpIntfAcquireReleaseCheck(L7_uint
 * @returns  L7_SUCCESS  or L7_FAILURE
 *
 * @end
 *********************************************************************/
 L7_RC_t garpVlanChangeProcess(dot1qNotifyData_t *vlanData, L7_uint32 intIfNum, L7_uint32 event,L7_ushort16 gvrp_event)
 {
-    L7_RC_t     rc;
     GARPCommand cmd;
     L7_uint32   status;
     L7_uint32   mode;
     L7_uint32   index;
     L7_uint32 i = 0, vlanId = 0, numVlans = 0;
-    rc = L7_SUCCESS;
     L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
+    L7_RC_t     rc = L7_SUCCESS;
+
     nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
 
     for (i = 1; i<=L7_VLAN_MAX_MASK_BIT; i++)
     {
       if (vlanData->numVlans == 1)
       {
Index: src/application/switching/dhcp_snooping/core/ds_debug.c
===================================================================
--- src/application/switching/dhcp_snooping/core/ds_debug.c	(revision 7746)
+++ src/application/switching/dhcp_snooping/core/ds_debug.c	(revision 7747)
@@ -347,12 +347,13 @@ L7_RC_t dsTestPacket(L7_uint32 rxIntf,
   L7_dhcp_packet_t *dhcpHeader;
   L7_uchar8 op;
   L7_uint32 yiaddr;
   L7_uint32 siaddr;
   L7_RC_t rc;
   L7_uint32 leaseTime;
+  L7_uint client_idx;
 
   if (dsStringToMac(clientHwAddr, &clientMac) != L7_SUCCESS)
     return L7_FAILURE;
 
   /* Figure out source and destination addresses */
   if (fromClient)
@@ -448,13 +449,13 @@ L7_RC_t dsTestPacket(L7_uint32 rxIntf,
   *pos = 4;
   pos++;
   leaseTime = osapiHtonl(1440);     /* 1 day */
   memcpy(pos, &leaseTime, 4);
 
   printf("\nqueueing test packet to DHCP snooping");
-  L7_uint client_idx = (L7_uint)-1;
+  client_idx = (L7_uint)-1;
   rc = dsPacketQueue(frame, TEST_MSG_LEN, vlanId, rxIntf, sVlanId, &client_idx );
 
   osapiWriteLockGive(dsCfgRWLock);
   return rc;
 }
 /*********************************************************************
Index: src/application/switching/dhcp_snooping/core/ds_util.c
===================================================================
--- src/application/switching/dhcp_snooping/core/ds_util.c	(revision 7746)
+++ src/application/switching/dhcp_snooping/core/ds_util.c	(revision 7747)
@@ -407,12 +407,13 @@ L7_RC_t _dsBindingClear(L7_uint32 intIfN
   L7_RC_t rc = L7_SUCCESS;
   L7_RC_t retval = L7_SUCCESS;
   L7_enetMacAddr_t prevMac;
   L7_uint32 prevIntf;
   dsBindingType_t prevType;
   dhcpSnoopBinding_t dsBinding;
+  dsBindingTreeKey_t key;
 
   memset(&prevMac, 0, sizeof(prevMac));
   memset(&dsBinding, 0, sizeof(dsBinding));
 
 #ifdef L7_NSF_PACKAGE
   if ((cnfgrIsFeaturePresent(L7_FLEX_STACKING_COMPONENT_ID, L7_STACKING_NSF_FEATURE_ID)) &&
@@ -440,13 +441,12 @@ L7_RC_t _dsBindingClear(L7_uint32 intIfN
      if ( (staticBindingsClrFlag == L7_FALSE) &&
          (prevType == DS_BINDING_STATIC) )
      {
         continue;
      }
       /* Delete this binding */
-      dsBindingTreeKey_t key;
       memset(&key, 0x00, sizeof(key));
       memcpy(&key.macAddr.addr, &prevMac.addr, L7_ENET_MAC_ADDR_LEN);
       key.ipType = dsBinding.key.ipType;
       if (dsBindingRemove(&key) != L7_SUCCESS)
       retval = L7_FAILURE;
       dsInfo->debugStats.bindingsRemoved++;
@@ -588,17 +588,21 @@ L7_RC_t dsIntfTrustApply(L7_uint32 intIf
 *
 * @end
 *********************************************************************/
 L7_BOOL dsIntfIsSnooping(L7_uint32 intIfNum)
 {
   if (intIfNum > DS_MAX_INTF_COUNT)
+  {
     return L7_FALSE;
+  }
   if (dsIntfInfo[intIfNum].dsNumVlansEnabled > 0)
+  {
     return L7_TRUE;
+  }
 
-    return L7_FALSE;
+  return L7_FALSE;
 }
 
 /*********************************************************************
 * @purpose  Enable DHCP snooping on a port.
 *
 * @param    intIfNum   @b((input)) internal interface number
@@ -2174,13 +2178,13 @@ L7_RC_t dsDbRemoteRestore()
   dhcpSnoopBinding_t dsBinding;
   L7_enetMacAddr_t macAddr;
   int count=0;
   L7_uint32 unit,slot, port;
   L7_uint32 vlanId;
   L7_RC_t rc;
-
+  dsBindingTreeKey_t key;
 
   if((osapiFsFileSizeGet(DHCP_SNOOPING_DOWNLOAD_FILE_NAME,&fileSize)) != L7_SUCCESS)
   {
     return L7_ERROR;
   }
  if (osapiFsOpen(DHCP_SNOOPING_DOWNLOAD_FILE_NAME, &filedesc) != L7_ERROR)
@@ -2337,23 +2341,23 @@ L7_RC_t dsDbRemoteRestore()
                          &macAddr,
                          dsBinding.ipAddr,
                          dsBinding.vlanId, 0 /* PTin modified: DHCP */,
                         dsBinding.intIfNum);
        if ( rc == L7_FAILURE)
        {
-               L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DHCP_SNOOPING_COMPONENT_ID,
-                  "Lease time parsing problem occured while reading the snooping database.");
-                osapiFsClose(filedesc);
-                 osapiFsDeleteFile(DHCP_SNOOPING_DOWNLOAD_FILE_NAME);
-                 return L7_FAILURE;
+         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DHCP_SNOOPING_COMPONENT_ID,
+                 "Lease time parsing problem occured while reading the snooping database.");
+         osapiFsClose(filedesc);
+         osapiFsDeleteFile(DHCP_SNOOPING_DOWNLOAD_FILE_NAME);
+         return L7_FAILURE;
        }
-        dsBindingTreeKey_t key;
-        memset(&key, 0x00, sizeof(key));
-        memcpy(&key.macAddr.addr, &macAddr.addr, L7_ENET_MAC_ADDR_LEN);
-        key.ipType = L7_AF_INET;
-        dsBindingLeaseSet(&key, dsBinding.remLease);
+
+       memset(&key, 0x00, sizeof(key));
+       memcpy(&key.macAddr.addr, &macAddr.addr, L7_ENET_MAC_ADDR_LEN);
+       key.ipType = L7_AF_INET;
+       dsBindingLeaseSet(&key, dsBinding.remLease);
        break;
      }
      readCnt = readCnt+sizeof(buf);
    }
    osapiFsClose(filedesc);
    osapiFsDeleteFile(DHCP_SNOOPING_DOWNLOAD_FILE_NAME);
@@ -2423,16 +2427,16 @@ void dsDbLocalSave()
 *
 * @end
 ********************************************************************/
 
 void dsDbLocalRestore()
 {
-
   L7_RC_t rc;
   L7_uint32 dbIndex, dbEntries;
   dhcpSnoopBinding_t dsBinding;
+  dsBindingTreeKey_t key;
 
   if (dsCfgData->dsGlobalAdminMode == L7_ENABLE)
   {
     if (sysapiCfgFileGet( L7_DHCP_SNOOPING_COMPONENT_ID,
                            L7_DHCP_SNOOPING_CFG_FILENAME ,
                            (L7_char8 *)&dsDbCfgData,
@@ -2459,17 +2463,16 @@ void dsDbLocalRestore()
          rc = dsBindingFind(&dsBinding, L7_MATCH_EXACT);
          if ( rc == L7_SUCCESS)
          {
           continue;
          }
          rc = dsBindingAdd(DS_BINDING_DYNAMIC,
-                       &dsDbCfgData.dsBindingDb[dbIndex]. macAddr,
-                      dsDbCfgData.dsBindingDb[dbIndex].ipAddr,
-                      dsDbCfgData.dsBindingDb[dbIndex].vlanId, 0 /* PTin modified: DHCP */,
-                      dsDbCfgData.dsBindingDb[dbIndex].intIfNum);
-         dsBindingTreeKey_t key;
+                           &dsDbCfgData.dsBindingDb[dbIndex]. macAddr,
+                           dsDbCfgData.dsBindingDb[dbIndex].ipAddr,
+                           dsDbCfgData.dsBindingDb[dbIndex].vlanId, 0 /* PTin modified: DHCP */,
+                           dsDbCfgData.dsBindingDb[dbIndex].intIfNum);
          memset(&key, 0x00, sizeof(key));
          memcpy(&key.macAddr.addr, &dsDbCfgData.dsBindingDb[dbIndex].macAddr.addr, L7_ENET_MAC_ADDR_LEN);
          key.ipType = L7_AF_INET;
          dsBindingLeaseSet(&key,dsDbCfgData.dsBindingDb[dbIndex].remLease);
       }
    }
Index: src/application/switching/dhcp_snooping/core/ds_ipsg.c
===================================================================
--- src/application/switching/dhcp_snooping/core/ds_ipsg.c	(revision 7746)
+++ src/application/switching/dhcp_snooping/core/ds_ipsg.c	(revision 7747)
@@ -176,19 +176,19 @@ static void ipsgEntryCopy (ipsgEntryTree
 L7_RC_t ipsgEntryAdd(ipsgEntryType_t entryType,
                      L7_uint32 intIfNum,
                      L7_ushort16 vlanId,
                      L7_enetMacAddr_t *macAddr,
                      L7_inet_addr_t *ipAddr)
 {
+  L7_INTF_STATES_t intIfState;
+  ipsgEntryTreeNode_t  ipsgEntry, *pNode;
+
 #ifndef IPSG_VLAN_FIELD_IS_CARE
   vlanId = 0;
 #endif
 
-  L7_INTF_STATES_t intIfState;
-  ipsgEntryTreeNode_t  ipsgEntry, *pNode;
-
   if ( (entryType == IPSG_ENTRY_STATIC) &&
        (ipsgInfo->ipsgEntryTable.currentStaticBindings) >=
        (ipsgInfo->ipsgEntryTable.maxStaticBindings) )
 
   {
     /* return L7_TABLE_IS_FULL to warn user that Max static
@@ -1037,19 +1037,19 @@ L7_RC_t ipsgEntryRemove (ipsgEntryType_t
                      L7_uint32 intIfNum,
                      L7_ushort16 vlanId,
                      L7_enetMacAddr_t *macAddr,
                      L7_inet_addr_t* ipAddr)
 
 {
+  ipsgEntryTreeNode_t *pNode = NULL, *freeNode=NULL, ipsgEntry;
+  dhcpSnoopBinding_t dsNode;
+
 #ifndef IPSG_VLAN_FIELD_IS_CARE
   vlanId = 0;
 #endif
 
-  ipsgEntryTreeNode_t *pNode = NULL, *freeNode=NULL, ipsgEntry;
-  dhcpSnoopBinding_t dsNode;
-
   /* If IPSG enabled, remove binding from HW */
   if (ipsgEntryTreeSearch(intIfNum,
                           vlanId,
                           macAddr,
                           ipAddr, L7_MATCH_EXACT, &pNode) == L7_SUCCESS)
   {
Index: src/application/switching/dhcp_snooping/core/ds_main.c
===================================================================
--- src/application/switching/dhcp_snooping/core/ds_main.c	(revision 7746)
+++ src/application/switching/dhcp_snooping/core/ds_main.c	(revision 7747)
@@ -867,16 +867,16 @@ SYSNET_PDU_RC_t dsPacketIntercept(L7_uin
       }
 
       /* PTin added: DHCP snooping */
       /* Only search and validate client for non CXP360G and untrusted interfaces */
       #if ( !PTIN_BOARD_IS_MATRIX )
 
-      ptin_client_id_t client;
-
       if (!_dsVlanIsIntfRoot(pduInfo->vlanId,pduInfo->intIfNum))
       {
+        ptin_client_id_t client;
+
         #if 0
         /* Validate inner vlan */
         if (innerVlanId==0 || innerVlanId>=4095)
         {
           if (ptin_debug_dhcp_snooping)
             PT_LOG_ERR(LOG_CTX_DHCP,"Client not referenced! (intIfNum=%u, innerVlanId=%u, intVlanId=%u)",
@@ -1206,16 +1206,16 @@ SYSNET_PDU_RC_t dsv6PacketIntercept(L7_u
       }
 
       /* PTin added: DHCP snooping */
       /* Only search and validate client for non CXP360G and untrusted interfaces */
       #if ( !PTIN_BOARD_IS_MATRIX )
 
-      ptin_client_id_t client;
-
       if (!_dsVlanIsIntfRoot(pduInfo->vlanId,pduInfo->intIfNum))
       {
+        ptin_client_id_t client;
+
         #if 0
         /* Validate inner vlan */
         if (innerVlanId==0 || innerVlanId>=4095)
         {
           if (ptin_debug_dhcp_snooping)
             PT_LOG_ERR(LOG_CTX_DHCP,"Client not referenced! (intIfNum=%u, innerVlanId=%u, intVlanId=%u)",
@@ -4475,12 +4475,13 @@ L7_RC_t dsBindingExtract(L7_uint32 intIf
 {
   L7_dhcp_pkt_type_t dhcpPktType;
   L7_uint32 yiaddr = 0;     /* client's IP address */
   L7_enetMacAddr_t chaddr;
   L7_uint32 leaseTime;
   dhcpSnoopBinding_t dsBinding;
+  dsBindingTreeKey_t key;
 
   memcpy(&chaddr, dhcpPacket->chaddr, L7_ENET_MAC_ADDR_LEN);
 
   /* If a static entry exists with DHCP message mac address
      don't process it. Log the message. */
 
@@ -4605,13 +4606,12 @@ L7_RC_t dsBindingExtract(L7_uint32 intIf
          }
          if (dsBindingIpAddrSet(&chaddr, yiaddr, vlanId) == L7_SUCCESS)
          {
            dsInfo->debugStats.bindingsAdded++;
          }
          /* Extract lease time */
-         dsBindingTreeKey_t key;
          memset(&key, 0x00, sizeof(key));
          memcpy(&key.macAddr.addr, &chaddr.addr, L7_ENET_MAC_ADDR_LEN);
          key.ipType = L7_AF_INET;
          leaseTime = dsLeaseTimeGet(dhcpPacket, pktLen);
          dsBindingLeaseSet(&key, leaseTime);
          break;
@@ -4625,13 +4625,12 @@ L7_RC_t dsBindingExtract(L7_uint32 intIf
                      intIfNum, vlanId, innerVlanId,
                      dsBinding.key.macAddr[0],dsBinding.key.macAddr[1],dsBinding.key.macAddr[2],dsBinding.key.macAddr[3],dsBinding.key.macAddr[4],dsBinding.key.macAddr[5]);
 
          /* Client has refused or given up lease, or server has refused. Remove binding.
           * A failure removing binding could be ok. The client might be on a trusted
           * port or a port not enabled for DHCP snooping. */
-         dsBindingTreeKey_t key;
          memset(&key, 0x00, sizeof(key));
          memcpy(&key.macAddr.addr, &chaddr.addr, L7_ENET_MAC_ADDR_LEN);
          key.ipType = L7_AF_INET;
          if (dsBindingRemove(&key) == L7_SUCCESS)
          {
            dsInfo->debugStats.bindingsRemoved++;
@@ -5216,12 +5215,13 @@ L7_RC_t dsFrameSend(L7_uint32 intIfNum,
                     L7_uchar8 *frame, L7_ushort16 frameLen)
 {
   L7_netBufHandle   bufHandle;
   L7_uchar8        *dataStart;
   L7_INTF_TYPES_t   sysIntfType;
   L7_uint32         member_mode;
+  L7_uint16         extOVlan, extIVlan;
 
   if (ptin_debug_dhcp_snooping)
     PT_LOG_TRACE(LOG_CTX_DHCP, "Going to transmit packet to intIfNum %u, vlanId=%u, innerVlanId=%u", intIfNum, vlanId, innerVlanId);
 
   /* If outgoing interface is CPU interface, don't send it */
   if ((nimGetIntfType(intIfNum, &sysIntfType) == L7_SUCCESS) &&
@@ -5265,14 +5265,14 @@ L7_RC_t dsFrameSend(L7_uint32 intIfNum,
   SYSAPI_NET_MBUF_GET_DATASTART(bufHandle, dataStart);
   memcpy(dataStart, frame, frameLen);
   SYSAPI_NET_MBUF_SET_DATALENGTH(bufHandle, frameLen);
 
   /* PTin added: DHCP snooping */
   #if 1
-  L7_uint16 extOVlan = vlanId;
-  L7_uint16 extIVlan = 0;
+  extOVlan = vlanId;
+  extIVlan = 0;
 
   if (ptin_debug_dhcp_snooping)
     PT_LOG_TRACE(LOG_CTX_DHCP, "Going to transmit packet to intIfNum %u, vlanId=%u, innerVlanId=%u, frameLen %u", intIfNum, vlanId, innerVlanId, frameLen);
 
   /* Extract external outer and inner vlan for this tx interface */
   if (ptin_dhcp_extVlans_get(intIfNum, vlanId, innerVlanId, client_idx, &extOVlan,&extIVlan) == L7_SUCCESS)
Index: src/application/switching/snooping/core/snooping.c
===================================================================
--- src/application/switching/snooping/core/snooping.c	(revision 7746)
+++ src/application/switching/snooping/core/snooping.c	(revision 7747)
@@ -691,23 +691,25 @@ L7_RC_t snoopPacketHandle(L7_netBufHandl
   PT_LOG_TRACE(LOG_CTX_IGMP, "DMAC=%02x:%02x:%02x:%02x:%02x:%02x SMAC=%02x:%02x:%02x:%02x:%02x:%02x",
               data[0],data[1],data[2],data[3],data[4],data[5],data[6],data[7],data[8],data[9],data[10],data[11]);
   #endif
 
 #ifdef L7_DHCP_SNOOPING_PACKAGE
 #ifdef L7_IPSG_PACKAGE
-  L7_enetMacAddr_t   clientMacAddr;
-  memcpy(&clientMacAddr.addr, &data[6], sizeof(clientMacAddr));   
-  if ( ipsgClientAuthorized(&clientMacAddr, pduInfo->vlanId, pduInfo->intIfNum) != L7_TRUE )
   {
-    L7_uchar8 macAddrStr[SNOOP_MAC_STR_LEN];      
-    snoopMacToString(clientMacAddr.addr, macAddrStr);
+    L7_enetMacAddr_t   clientMacAddr;
+    memcpy(&clientMacAddr.addr, &data[6], sizeof(clientMacAddr));   
+    if ( ipsgClientAuthorized(&clientMacAddr, pduInfo->vlanId, pduInfo->intIfNum) != L7_TRUE )
+    {
+      L7_uchar8 macAddrStr[SNOOP_MAC_STR_LEN];      
+      snoopMacToString(clientMacAddr.addr, macAddrStr);
 
-    if(ptin_debug_igmp_snooping)
-      PT_LOG_NOTICE(LOG_CTX_IGMP, "Packet Silently Ignored. Client Not Authorized! [intIfNum:%u vlanId:%u macAddrStr:%s]", pduInfo->intIfNum, pduInfo->vlanId, macAddrStr);
-    ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, (L7_uint32)-1, SNOOP_STAT_FIELD_IGMP_DROPPED);
-    return L7_FAILURE;
+      if(ptin_debug_igmp_snooping)
+        PT_LOG_NOTICE(LOG_CTX_IGMP, "Packet Silently Ignored. Client Not Authorized! [intIfNum:%u vlanId:%u macAddrStr:%s]", pduInfo->intIfNum, pduInfo->vlanId, macAddrStr);
+      ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, (L7_uint32)-1, SNOOP_STAT_FIELD_IGMP_DROPPED);
+      return L7_FAILURE;
+    }
   }
 #endif
 #endif
   
 /*If we support Inband*/
 #if PTIN_EVC_INBAND_SUPPORT 
@@ -734,14 +736,15 @@ L7_RC_t snoopPacketHandle(L7_netBufHandl
 #endif //ONE_MULTICAST_VLAN_RING_SUPPORT
 
   ptin_timer_stop(73);
   if (rc != L7_SUCCESS)
   {
     L7_enetMacAddr_t   clientMacAddr;
+    L7_uchar8 macAddrStr[SNOOP_MAC_STR_LEN];
+
     memcpy(&clientMacAddr.addr, &data[6], sizeof(clientMacAddr));  
-    L7_uchar8 macAddrStr[SNOOP_MAC_STR_LEN];      
     snoopMacToString(clientMacAddr.addr, macAddrStr);
 
     PT_LOG_NOTICE(LOG_CTX_IGMP, "Packet Silently Ignored. Failed to Obtain Port Type! [intIfNum:%u vlanId:%u macAddrStr:%s]", pduInfo->intIfNum, pduInfo->vlanId, macAddrStr);
     ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, (L7_uint32)-1, SNOOP_STAT_FIELD_IGMP_DROPPED);    
     return L7_FAILURE;
   }  
@@ -843,182 +846,184 @@ L7_RC_t snoopPacketHandle(L7_netBufHandl
         }
       }
     }
   }
 #endif
 
-#ifdef IGMPASSOC_MULTI_MC_SUPPORTED  
-  L7_inet_addr_t   groupAddr;
-  L7_inet_addr_t   sourceAddr;
-  L7_uint16        noOfGroupRecords = 1;
-  L7_uint16        noOfSources;
-  char             groupAddrStr[IPV6_DISP_ADDR_LEN]={}; 
+#ifdef IGMPASSOC_MULTI_MC_SUPPORTED
+  {
+    L7_inet_addr_t   groupAddr;
+    L7_inet_addr_t   sourceAddr;
+    L7_uint16        noOfGroupRecords = 1;
+    L7_uint16        noOfSources;
+    char             groupAddrStr[IPV6_DISP_ADDR_LEN]={}; 
 
-  /* Set Group Address to Zero*/
-  inetAddressZeroSet(family, &groupAddr);
+    /* Set Group Address to Zero*/
+    inetAddressZeroSet(family, &groupAddr);
 
-  /*Set Source Address to Zero*/
-  inetAddressZeroSet(family, &sourceAddr);
+    /*Set Source Address to Zero*/
+    inetAddressZeroSet(family, &sourceAddr);
 
-  /* IGMP */
-  if (pSnoopCB->family == family)
-  {
-    /* Validate minimum size of packet */
-    if (dataLength < L7_ENET_HDR_SIZE + L7_ENET_HDR_TYPE_LEN_SIZE + L7_IP_HDR_LEN + SNOOP_IGMPv1v2_HEADER_LENGTH)
-    {
-      PT_LOG_DEBUG(LOG_CTX_IGMP, "Received pkt is too small %d",dataLength);
-      ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
-      return L7_FAILURE;
-    }
-    if ( ipHdrLen < L7_IP_HDR_LEN)
+    /* IGMP */
+    if (pSnoopCB->family == family)
     {
-      PT_LOG_DEBUG(LOG_CTX_IGMP, "IP Header Len is invalid %d",ipHdrLen);
-      ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
-      return L7_FAILURE;
-    }
-    if ((L7_ENET_HDR_SIZE + L7_ENET_HDR_TYPE_LEN_SIZE + ipHdrLen + SNOOP_IGMPv1v2_HEADER_LENGTH) > dataLength)
-    {
-      PT_LOG_DEBUG(LOG_CTX_IGMP, "IP Header Len is too big (%u) for the packet length (%u)", ipHdrLen, dataLength);
-      ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
-      return L7_FAILURE;
-    }
-    /* Group address */
-    /* For V1/V2 and query messages, the group address is always located at the same place */
-    if (igmpPtr[0] == L7_IGMP_MEMBERSHIP_QUERY ||
-        igmpPtr[0] == L7_IGMP_V1_MEMBERSHIP_REPORT ||
-        igmpPtr[0] == L7_IGMP_V2_MEMBERSHIP_REPORT ||
-        igmpPtr[0] == L7_IGMP_V2_LEAVE_GROUP)
-    {      
-      /*Get Multicast Group Address*/         
-      groupAddr.addr.ipv4.s_addr = *(L7_uint32 *) ((L7_uint8 *) &igmpPtr[4]);
-      
-      //Convert to Little Endian
-      groupAddr.addr.ipv4.s_addr = osapiNtohl(groupAddr.addr.ipv4.s_addr);
-    }
-    else if (igmpPtr[0] == L7_IGMP_V3_MEMBERSHIP_REPORT)
-    {
-      /*Get Number of Group Records*/
-      noOfGroupRecords = osapiNtohs(*((L7_uint16 *) &igmpPtr[6]));
-      
-      
-      if ( noOfGroupRecords > 0 )
-      { 
-        /*Get Multicast Group Address of First Group Record*/         
-        groupAddr.addr.ipv4.s_addr = *(L7_uint32 *) ((L7_uint8 *) &igmpPtr[12]);
-
+      /* Validate minimum size of packet */
+      if (dataLength < L7_ENET_HDR_SIZE + L7_ENET_HDR_TYPE_LEN_SIZE + L7_IP_HDR_LEN + SNOOP_IGMPv1v2_HEADER_LENGTH)
+      {
+        PT_LOG_DEBUG(LOG_CTX_IGMP, "Received pkt is too small %d",dataLength);
+        ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
+        return L7_FAILURE;
+      }
+      if ( ipHdrLen < L7_IP_HDR_LEN)
+      {
+        PT_LOG_DEBUG(LOG_CTX_IGMP, "IP Header Len is invalid %d",ipHdrLen);
+        ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
+        return L7_FAILURE;
+      }
+      if ((L7_ENET_HDR_SIZE + L7_ENET_HDR_TYPE_LEN_SIZE + ipHdrLen + SNOOP_IGMPv1v2_HEADER_LENGTH) > dataLength)
+      {
+        PT_LOG_DEBUG(LOG_CTX_IGMP, "IP Header Len is too big (%u) for the packet length (%u)", ipHdrLen, dataLength);
+        ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
+        return L7_FAILURE;
+      }
+      /* Group address */
+      /* For V1/V2 and query messages, the group address is always located at the same place */
+      if (igmpPtr[0] == L7_IGMP_MEMBERSHIP_QUERY ||
+          igmpPtr[0] == L7_IGMP_V1_MEMBERSHIP_REPORT ||
+          igmpPtr[0] == L7_IGMP_V2_MEMBERSHIP_REPORT ||
+          igmpPtr[0] == L7_IGMP_V2_LEAVE_GROUP)
+      {      
+        /*Get Multicast Group Address*/         
+        groupAddr.addr.ipv4.s_addr = *(L7_uint32 *) ((L7_uint8 *) &igmpPtr[4]);
+        
         //Convert to Little Endian
         groupAddr.addr.ipv4.s_addr = osapiNtohl(groupAddr.addr.ipv4.s_addr);
+      }
+      else if (igmpPtr[0] == L7_IGMP_V3_MEMBERSHIP_REPORT)
+      {
+        /*Get Number of Group Records*/
+        noOfGroupRecords = osapiNtohs(*((L7_uint16 *) &igmpPtr[6]));
+        
+        
+        if ( noOfGroupRecords > 0 )
+        { 
+          /*Get Multicast Group Address of First Group Record*/         
+          groupAddr.addr.ipv4.s_addr = *(L7_uint32 *) ((L7_uint8 *) &igmpPtr[12]);
 
-        /*Get Number of Sources of First Group Address*/
-        noOfSources = osapiNtohs(*((L7_uint16 *) &igmpPtr[10]));    
+          //Convert to Little Endian
+          groupAddr.addr.ipv4.s_addr = osapiNtohl(groupAddr.addr.ipv4.s_addr);
 
-        if (noOfSources == 0)
-        {
-          //AnySource
+          /*Get Number of Sources of First Group Address*/
+          noOfSources = osapiNtohs(*((L7_uint16 *) &igmpPtr[10]));    
+
+          if (noOfSources == 0)
+          {
+            //AnySource
+          }
+          else
+          {
+            /*Get Source  Address of First Group Record*/         
+            sourceAddr.addr.ipv4.s_addr = *(L7_uint32 *) ((L7_uint8 *) &igmpPtr[16]);
+
+            //Convert to Little Endian
+            sourceAddr.addr.ipv4.s_addr = osapiNtohl(sourceAddr.addr.ipv4.s_addr);
+          }        
         }
         else
         {
-          /*Get Source  Address of First Group Record*/         
-          sourceAddr.addr.ipv4.s_addr = *(L7_uint32 *) ((L7_uint8 *) &igmpPtr[16]);
-
-          //Convert to Little Endian
-          sourceAddr.addr.ipv4.s_addr = osapiNtohl(sourceAddr.addr.ipv4.s_addr);
-        }        
+          PT_LOG_DEBUG(LOG_CTX_IGMP,"Number of Group Records:%u [vlan=%u innerVlan=%u client_idx]: Packet Silently ignored...",
+                  noOfGroupRecords, pduInfo->vlanId, pduInfo->innerVlanId, client_idx);  
+          ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
+          return L7_FAILURE;
+        }      
       }
       else
       {
-        PT_LOG_DEBUG(LOG_CTX_IGMP,"Number of Group Records:%u [vlan=%u innerVlan=%u client_idx]: Packet Silently ignored...",
-                noOfGroupRecords, pduInfo->vlanId, pduInfo->innerVlanId, client_idx);  
+        PT_LOG_ERR(LOG_CTX_IGMP, "Protocol Not Supported :%u [vlan=%u innerVlan=%u client_idx]", igmpPtr[0], pduInfo->vlanId, pduInfo->innerVlanId, client_idx);
         ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
-        return L7_FAILURE;
-      }      
+        return L7_NOT_SUPPORTED;
+      }
+       
+      /*RFC5771 - Local Network Control Block (224.0.0.0 - 224.0.0.255 (224.0.0/24)) 
+      The range of addresses between 224.0.0.0 and 224.0.0.255, inclusive, is reserved for the use of routing protocols and other low-level topology discovery or maintenance protocols, such as gateway discovery
+      and group membership reporting.  Multicast routers should not forward any multicast datagram with destination addresses in this range, regardless of its TTL.*/    
+      if(groupAddr.addr.ipv4.s_addr >= L7_IP_MCAST_BASE_ADDR && groupAddr.addr.ipv4.s_addr <= L7_IP_MAX_LOCAL_MULTICAST )    
+      {
+        if(ptin_debug_igmp_snooping)
+          PT_LOG_DEBUG(LOG_CTX_IGMP,"Multicast Group Address is Reserved for Protocol use [vlan=%u innerVlan=%u client_idx=%u grpAddr=%s]. Packet Silently ignored...",
+                  pduInfo->vlanId, pduInfo->innerVlanId, client_idx, inetAddrPrint(&groupAddr,groupAddrStr));  
+        if(igmpPtr!=L7_NULLPTR)
+          ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, snoopPacketType2IGMPStatField(igmpPtr[0],SNOOP_STAT_FIELD_VALID_RX));
+        else
+        {      
+          ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_VALID);    
+        }      
+        return L7_SUCCESS;
+      }
     }
     else
     {
-      PT_LOG_ERR(LOG_CTX_IGMP, "Protocol Not Supported :%u [vlan=%u innerVlan=%u client_idx]", igmpPtr[0], pduInfo->vlanId, pduInfo->innerVlanId, client_idx);
+      PT_LOG_NOTICE(LOG_CTX_IGMP, "IPv6 not supported yet!");
       ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
-      return L7_NOT_SUPPORTED;
-    }
-     
-    /*RFC5771 - Local Network Control Block (224.0.0.0 - 224.0.0.255 (224.0.0/24)) 
-    The range of addresses between 224.0.0.0 and 224.0.0.255, inclusive, is reserved for the use of routing protocols and other low-level topology discovery or maintenance protocols, such as gateway discovery
-    and group membership reporting.  Multicast routers should not forward any multicast datagram with destination addresses in this range, regardless of its TTL.*/    
-    if(groupAddr.addr.ipv4.s_addr >= L7_IP_MCAST_BASE_ADDR && groupAddr.addr.ipv4.s_addr <= L7_IP_MAX_LOCAL_MULTICAST )    
-    {
-      if(ptin_debug_igmp_snooping)
-        PT_LOG_DEBUG(LOG_CTX_IGMP,"Multicast Group Address is Reserved for Protocol use [vlan=%u innerVlan=%u client_idx=%u grpAddr=%s]. Packet Silently ignored...",
-                pduInfo->vlanId, pduInfo->innerVlanId, client_idx, inetAddrPrint(&groupAddr,groupAddrStr));  
-      if(igmpPtr!=L7_NULLPTR)
-        ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, snoopPacketType2IGMPStatField(igmpPtr[0],SNOOP_STAT_FIELD_VALID_RX));
-      else
-      {      
-        ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_VALID);    
-      }      
-      return L7_SUCCESS;
+      return L7_FAILURE;
     }
-  }
-  else
-  {
-    PT_LOG_NOTICE(LOG_CTX_IGMP, "IPv6 not supported yet!");
-    ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
-    return L7_FAILURE;
-  }
 
-  ptin_timer_start(76,"ptin_igmp_McastRootVlan_get");
-  /* Get multicast root vlan */  
-  if ( ptin_igmp_McastRootVlan_get(pduInfo->vlanId, pduInfo->intIfNum, (port_type == PTIN_EVC_INTF_LEAF), client_idx, &groupAddr, &sourceAddr, &mcastRootVlan) == L7_SUCCESS )
-  {
-    PT_LOG_TRACE(LOG_CTX_IGMP,"Vlan=%u will be converted to %u (grpAddr=%s)",
-              pduInfo->vlanId, mcastRootVlan, inetAddrPrint(&groupAddr,groupAddrStr));
-    ptin_timer_stop(76);
-  }
-  else 
-  {
-    ptin_timer_stop(76);
-    if (noOfGroupRecords == 1 || igmpPtr[0] != L7_IGMP_V3_MEMBERSHIP_REPORT)
+    ptin_timer_start(76,"ptin_igmp_McastRootVlan_get");
+    /* Get multicast root vlan */  
+    if ( ptin_igmp_McastRootVlan_get(pduInfo->vlanId, pduInfo->intIfNum, (port_type == PTIN_EVC_INTF_LEAF), client_idx, &groupAddr, &sourceAddr, &mcastRootVlan) == L7_SUCCESS )
+    {
+      PT_LOG_TRACE(LOG_CTX_IGMP,"Vlan=%u will be converted to %u (grpAddr=%s)",
+                pduInfo->vlanId, mcastRootVlan, inetAddrPrint(&groupAddr,groupAddrStr));
+      ptin_timer_stop(76);
+    }
+    else 
     {
-      PT_LOG_DEBUG(LOG_CTX_IGMP,"Can't get McastRootVlan for vlan=%u (grpAddr=%s). Packet Silently ignored...",
-                pduInfo->vlanId, inetAddrPrint(&groupAddr,groupAddrStr));    
-      if(igmpPtr!=L7_NULLPTR)
-        ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, snoopPacketType2IGMPStatField(igmpPtr[0],SNOOP_STAT_FIELD_DROPPED_RX));
-      else
+      ptin_timer_stop(76);
+      if (noOfGroupRecords == 1 || igmpPtr[0] != L7_IGMP_V3_MEMBERSHIP_REPORT)
       {
+        PT_LOG_DEBUG(LOG_CTX_IGMP,"Can't get McastRootVlan for vlan=%u (grpAddr=%s). Packet Silently ignored...",
+                  pduInfo->vlanId, inetAddrPrint(&groupAddr,groupAddrStr));    
+        if(igmpPtr!=L7_NULLPTR)
+          ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, snoopPacketType2IGMPStatField(igmpPtr[0],SNOOP_STAT_FIELD_DROPPED_RX));
+        else
+        {
 #ifndef ONE_MULTICAST_VLAN_RING_SUPPORT                  
-      }
-      return L7_FAILURE;
+        }
+        return L7_FAILURE;
 #else
-      }
+        }
 #endif //ONE_MULTICAST_VLAN_RING_SUPPORT
 
 #ifdef ONE_MULTICAST_VLAN_RING_SUPPORT
-      L7_uint8  isDynamic;
-      L7_uint32 ptin_port_aux;
+        L7_uint8  isDynamic;
+        L7_uint32 ptin_port_aux;
 
-      ptin_port_aux = pduInfo->intIfNum - 1;
+        ptin_port_aux = pduInfo->intIfNum - 1;
 
-      ptin_igmp_port_is_Dynamic(ptin_port_aux,&isDynamic);
-      
-      if(port_type != PTIN_EVC_INTF_LEAF && !isDynamic )
-      {
-        return L7_FAILURE;
-      }
-      else 
-      {
-        if (pduInfo->vlanId <= 512 && isDynamic)
+        ptin_igmp_port_is_Dynamic(ptin_port_aux,&isDynamic);
+        
+        if(port_type != PTIN_EVC_INTF_LEAF && !isDynamic )
         {
-          mcastRootVlan = 512;
+          return L7_FAILURE;
+        }
+        else 
+        {
+          if (pduInfo->vlanId <= 512 && isDynamic)
+          {
+            mcastRootVlan = 512;
+          }
+          PT_LOG_TRACE(LOG_CTX_IGMP,"Vlan=%u will be converted to %u",pduInfo->vlanId ,mcastRootVlan);
         }
-        PT_LOG_TRACE(LOG_CTX_IGMP,"Vlan=%u will be converted to %u",pduInfo->vlanId ,mcastRootVlan);
-      }
 #endif //ONE_MULTICAST_VLAN_RING_SUPPORT
-    }
-    else
-    {
-      PT_LOG_DEBUG(LOG_CTX_IGMP,"Can't get McastRootVlan for vlan=%u (grpAddr=%s): Packet with more group records left:%u",
-                pduInfo->vlanId, inetAddrPrint(&groupAddr,groupAddrStr), noOfGroupRecords);    
-      mcastRootVlan = (L7_uint16) -1;
+      }
+      else
+      {
+        PT_LOG_DEBUG(LOG_CTX_IGMP,"Can't get McastRootVlan for vlan=%u (grpAddr=%s): Packet with more group records left:%u",
+                  pduInfo->vlanId, inetAddrPrint(&groupAddr,groupAddrStr), noOfGroupRecords);    
+        mcastRootVlan = (L7_uint16) -1;
+      }
     }
   }
 #else
   ptin_timer_start(76,"ptin_igmp_McastRootVlan_get");
   /* !IGMPASSOC_MULTI_MC_SUPPORTED */
 
@@ -1921,19 +1926,25 @@ L7_RC_t snoopPacketProcess(snoopPDU_Msg_
   else if (rc==L7_FAILURE) /*Invalid Packet Type*/
     ptin_igmp_stat_increment_field(mcastPacket.intIfNum, mcastPacket.vlanId, mcastPacket.client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
   else /*if (rc==L7_ERROR)*/
     ptin_igmp_stat_increment_field(mcastPacket.intIfNum, mcastPacket.vlanId, mcastPacket.client_idx, SNOOP_STAT_FIELD_IGMP_DROPPED);
 #else
   if (rc==L7_SUCCESS)
+  {
     snoopStatIgmpField=SNOOP_STAT_FIELD_VALID_RX;
+  }
   else if (rc==L7_FAILURE) /*Invalid Packet Type*/
+  {
     snoopStatIgmpField=SNOOP_STAT_FIELD_INVALID_RX;
+  }
   else /*if (rc==L7_ERROR)*/
+  {
     snoopStatIgmpField=SNOOP_STAT_FIELD_DROPPED_RX;               
+  }
 
-    ptin_igmp_stat_increment_field(mcastPacket.intIfNum, mcastPacket.vlanId, mcastPacket.client_idx, snoopPacketType2IGMPStatField(/*mcastPacket.msgType*/msgType,snoopStatIgmpField));
+  ptin_igmp_stat_increment_field(mcastPacket.intIfNum, mcastPacket.vlanId, mcastPacket.client_idx, snoopPacketType2IGMPStatField(/*mcastPacket.msgType*/msgType,snoopStatIgmpField));
 #endif
 
 
   /* If client is dynamic, and no channels are associated, flush it */
   //ptin_igmp_dynamic_client_flush(mcastPacket.vlanId, mcastPacket.client_idx);
 
Index: src/application/switching/snooping/core/snooping_db.c
===================================================================
--- src/application/switching/snooping/core/snooping_db.c	(revision 7746)
+++ src/application/switching/snooping/core/snooping_db.c	(revision 7747)
@@ -2805,15 +2805,16 @@ L7_RC_t snoopL3GroupIntfAdd(L7_uint32 se
       }
 
       /*Channel Only Has one Interface*/
       if ( newChannelEntry == L7_TRUE )
       {
         #if defined IGMP_SMART_MC_EVC_SUPPORTED
-        l3_intf_id = -1;
         L7_uint32 iptv_evc_id;
 
+        l3_intf_id = -1;
+
         if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
         {
           PT_LOG_ERR(LOG_CTX_IGMP, "Failed to get UcastEvcId");
           return L7_FAILURE;
         }
                
@@ -2854,15 +2855,16 @@ L7_RC_t snoopL3GroupIntfAdd(L7_uint32 se
             continue;
           }
 
           if (PTIN_IS_MASKBITSET(pChannelIntfMask->snoopChannelIntfMaskInfoDataKey.channelIntfMask, intf))
           {
             #if defined IGMP_SMART_MC_EVC_SUPPORTED
-            l3_intf_id = -1;
             L7_uint32 iptv_evc_id;
 
+            l3_intf_id = -1;
+
             if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
             {
               PT_LOG_ERR(LOG_CTX_IGMP, "Failed to get UcastEvcId");
               return L7_FAILURE;
             }
                    
@@ -2902,35 +2904,39 @@ L7_RC_t snoopL3GroupIntfAdd(L7_uint32 se
         PT_LOG_ERR(LOG_CTX_IGMP, "Error using existing multicast group: 0x%08x", multicast_group);      
         return L7_FAILURE;
       }
 
       /*Use Existing Multicast Group*/
       removeMulticastGroup = L7_FALSE;
-      #if defined IGMP_SMART_MC_EVC_SUPPORTED
-      l3_intf_id = -1;
-      L7_uint32 iptv_evc_id;
 
-      if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
-      {
-        PT_LOG_ERR(LOG_CTX_IGMP, "Failed to get UcastEvcId");
-        return L7_FAILURE;
-      }
-             
-      if (ptin_evc_l3_intf_get(iptv_evc_id, intIfNum, &l3_intf_id) != L7_SUCCESS || l3_intf_id < 0)
+      #if defined IGMP_SMART_MC_EVC_SUPPORTED
       {
-        PT_LOG_ERR(LOG_CTX_IGMP, "Failed to obtain l3 intf for EvcId:%u l3_intf_id:%d", iptv_evc_id, l3_intf_id);      
-        return L7_FAILURE;
-      }
-      if (ptin_debug_igmp_snooping)
-        PT_LOG_DEBUG(LOG_CTX_IGMP, "Obtained L3 Interface l3_intf_id:%d", l3_intf_id);          
+        L7_uint32 iptv_evc_id;
 
-      rc = ptin_multicast_l3_egress_port_add(intIfNum, multicast_group,  l3_intf_id);
-      if ( rc != L7_SUCCESS )
-      {
-        PT_LOG_ERR(LOG_CTX_IGMP, "Failed to add L3 Egress portId:%d to multicastGroup:0x%08x (rc%u)", l3_intf_id, multicast_group, rc);      
-        return L7_FAILURE;
+        l3_intf_id = -1;
+
+        if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
+        {
+          PT_LOG_ERR(LOG_CTX_IGMP, "Failed to get UcastEvcId");
+          return L7_FAILURE;
+        }
+               
+        if (ptin_evc_l3_intf_get(iptv_evc_id, intIfNum, &l3_intf_id) != L7_SUCCESS || l3_intf_id < 0)
+        {
+          PT_LOG_ERR(LOG_CTX_IGMP, "Failed to obtain l3 intf for EvcId:%u l3_intf_id:%d", iptv_evc_id, l3_intf_id);      
+          return L7_FAILURE;
+        }
+        if (ptin_debug_igmp_snooping)
+          PT_LOG_DEBUG(LOG_CTX_IGMP, "Obtained L3 Interface l3_intf_id:%d", l3_intf_id);          
+
+        rc = ptin_multicast_l3_egress_port_add(intIfNum, multicast_group,  l3_intf_id);
+        if ( rc != L7_SUCCESS )
+        {
+          PT_LOG_ERR(LOG_CTX_IGMP, "Failed to add L3 Egress portId:%d to multicastGroup:0x%08x (rc%u)", l3_intf_id, multicast_group, rc);      
+          return L7_FAILURE;
+        }
       }
       #else
       rc = ptin_multicast_l2_egress_port_add(intIfNum, multicast_group);
       if ( rc != L7_SUCCESS )
       {
         PT_LOG_ERR(LOG_CTX_IGMP, "Failed to add L2 Egress intIfNum:%u to multicastGroup:0x%08x (rc%u)", intIfNum, multicast_group, rc);      
@@ -3015,15 +3021,16 @@ L7_RC_t snoopL3GroupIntfAdd(L7_uint32 se
         continue;
       }
 
       if (PTIN_IS_MASKBITSET(pChannelEntry->channelIntfMask, intf))
       {
         #if defined IGMP_SMART_MC_EVC_SUPPORTED
-        l3_intf_id = -1;
         L7_uint32 iptv_evc_id;
 
+        l3_intf_id = -1;
+
         if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
         {
           PT_LOG_ERR(LOG_CTX_IGMP, "Failed to get UcastEvcId");
           return L7_FAILURE;
         }
                
@@ -3336,15 +3343,16 @@ L7_RC_t snoopL3GroupIntfRemove(L7_uint32
       pChannelEntry->pChannelIntfMask->noOfChannelEntries--;
 
     /*Is this channel the last entry of this interface mask?*/
     if ( pChannelEntry->pChannelIntfMask->noOfChannelEntries == 0 )
     {
       #if defined IGMP_SMART_MC_EVC_SUPPORTED
-      l3_intf_id = -1;
       L7_uint32 iptv_evc_id;
 
+      l3_intf_id = -1;
+
       if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
       {
         PT_LOG_ERR(LOG_CTX_IGMP, "Failed to get UcastEvcId");
         return L7_FAILURE;
       }
              
@@ -3445,12 +3453,14 @@ L7_RC_t snoopL3GroupIntfRemove(L7_uint32
     PT_LOG_TRACE(LOG_CTX_IGMP, "New Interface Mask Added");  
     //New Entry Interface Mask Entry
     newChannelIntfMaskEntry = L7_TRUE;
 
     if ( removeMulticastGroup == L7_FALSE )
     {      
+      uint32 intf;
+
       multicast_group = -1;
       #if 1/*Create L3 Multicast Replication Table on the switch*/ 
       rc = ptin_multicast_group_l3_create(&multicast_group);
       if ( rc != L7_SUCCESS || multicast_group <= 0 )
       {
         PT_LOG_ERR(LOG_CTX_IGMP, "Error creating L3 multicast group: 0x%08x (rc:%u)", multicast_group, rc);      
@@ -3472,13 +3482,12 @@ L7_RC_t snoopL3GroupIntfRemove(L7_uint32
         #else//Disabled Creating L2 Multicast Replication Table
           PT_LOG_DEBUG(LOG_CTX_IGMP, "L2 Multicast group 0x%08x created", multicast_group);     
         #endif
       }
 
       /* Add Egress Ports*/  
-      uint32 intf;
       for (intf = 1; intf <= PTIN_SYSTEM_IGMP_MAXINTERFACES; intf++)
       {
         if (!PTIN_IS_MASK_WORD_SET(pChannelIntfMask->snoopChannelIntfMaskInfoDataKey.channelIntfMask, intf))
         {
           intf += PTIN_SNOOP_PORT_MASK_UNIT;
           intf -= intf%PTIN_SNOOP_PORT_MASK_UNIT;
@@ -3490,35 +3499,38 @@ L7_RC_t snoopL3GroupIntfRemove(L7_uint32
         {
           if (intf == intIfNum)
           {
             PT_LOG_ERR(LOG_CTX_IGMP, "intf == intIfNum", intf, intIfNum);              
           }
           #if defined IGMP_SMART_MC_EVC_SUPPORTED
-          l3_intf_id = -1;
-          L7_uint32 iptv_evc_id;
-
-          if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
-          {
-            PT_LOG_ERR(LOG_CTX_IGMP, "Failed to get UcastEvcId");
-            return L7_FAILURE;
-          }
-                 
-          if (ptin_evc_l3_intf_get(iptv_evc_id, intf, &l3_intf_id) != L7_SUCCESS || l3_intf_id < 0)
           {
-            PT_LOG_ERR(LOG_CTX_IGMP, "Failed to obtain l3 intf for EvcId:%u l3_intf_id:%d", iptv_evc_id, l3_intf_id);      
-            return L7_FAILURE;
-          }
-          if (ptin_debug_igmp_snooping)
-            PT_LOG_DEBUG(LOG_CTX_IGMP, "Obtained L3 Interface l3_intf_id:%d", l3_intf_id);
+            L7_uint32 iptv_evc_id;
 
-          rc = ptin_multicast_l3_egress_port_add(intf, multicast_group,  l3_intf_id);
+            l3_intf_id = -1;
 
-          if ( rc != L7_SUCCESS )
-          {
-            PT_LOG_ERR(LOG_CTX_IGMP, "Failed to add egress portId:%d to multicastGroup:0x%08x (rc%u)", l3_intf_id, multicast_group, rc);      
-            return L7_FAILURE;
+            if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
+            {
+              PT_LOG_ERR(LOG_CTX_IGMP, "Failed to get UcastEvcId");
+              return L7_FAILURE;
+            }
+                   
+            if (ptin_evc_l3_intf_get(iptv_evc_id, intf, &l3_intf_id) != L7_SUCCESS || l3_intf_id < 0)
+            {
+              PT_LOG_ERR(LOG_CTX_IGMP, "Failed to obtain l3 intf for EvcId:%u l3_intf_id:%d", iptv_evc_id, l3_intf_id);      
+              return L7_FAILURE;
+            }
+            if (ptin_debug_igmp_snooping)
+              PT_LOG_DEBUG(LOG_CTX_IGMP, "Obtained L3 Interface l3_intf_id:%d", l3_intf_id);
+
+            rc = ptin_multicast_l3_egress_port_add(intf, multicast_group,  l3_intf_id);
+
+            if ( rc != L7_SUCCESS )
+            {
+              PT_LOG_ERR(LOG_CTX_IGMP, "Failed to add egress portId:%d to multicastGroup:0x%08x (rc%u)", l3_intf_id, multicast_group, rc);      
+              return L7_FAILURE;
+            }
           }
           #else
           rc = ptin_multicast_l2_egress_port_add(intf, multicast_group);
           if ( rc != L7_SUCCESS )
           {
             PT_LOG_ERR(LOG_CTX_IGMP, "Failed to add L2 Egress intIfNum:%u to multicastGroup:0x%08x (rc%u)", intf, multicast_group, rc);      
@@ -3539,40 +3551,44 @@ L7_RC_t snoopL3GroupIntfRemove(L7_uint32
       }
     }
     else
     {
       /*Use Existing Multicast Group*/
       removeMulticastGroup = L7_FALSE;
-      #if defined IGMP_SMART_MC_EVC_SUPPORTED
-      l3_intf_id = -1;
-      L7_uint32 iptv_evc_id;
 
-      if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
-      {
-        PT_LOG_ERR(LOG_CTX_IGMP, "Failed to get UcastEvcId");
-        return L7_FAILURE;
-      }
-           
-      PT_LOG_TRACE(LOG_CTX_IGMP, "iptv_evc_id %d", iptv_evc_id);
-        
-      if (ptin_evc_l3_intf_get(iptv_evc_id, intIfNum, &l3_intf_id) != L7_SUCCESS || l3_intf_id < 0)
+      #if defined IGMP_SMART_MC_EVC_SUPPORTED
       {
-        PT_LOG_ERR(LOG_CTX_IGMP, "Failed to obtain l3 intf for EvcId:%u l3_intf_id:%d", iptv_evc_id, l3_intf_id);      
-        return L7_FAILURE;
-      }
-      if (ptin_debug_igmp_snooping)
-        PT_LOG_DEBUG(LOG_CTX_IGMP, "Obtained L3 Interface l3_intf_id:%d", l3_intf_id);          
+        L7_uint32 iptv_evc_id;
 
-      /*Remove L3 Egress Port of this Multicast Group*/
-      rc = ptin_multicast_l3_egress_port_remove(intIfNum, pChannelEntry->pChannelIntfMask->multicastGroup,  l3_intf_id);
+        l3_intf_id = -1;
 
-      if ( rc != L7_SUCCESS )
-      {
-        PT_LOG_ERR(LOG_CTX_IGMP, "Failed to remove egress portId:%d to multicastGroup:0x%08x (rc%u)", l3_intf_id, pChannelEntry->pChannelIntfMask->multicastGroup, rc);      
-        return L7_FAILURE;
-      }       
+        if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
+        {
+          PT_LOG_ERR(LOG_CTX_IGMP, "Failed to get UcastEvcId");
+          return L7_FAILURE;
+        }
+             
+        PT_LOG_TRACE(LOG_CTX_IGMP, "iptv_evc_id %d", iptv_evc_id);
+          
+        if (ptin_evc_l3_intf_get(iptv_evc_id, intIfNum, &l3_intf_id) != L7_SUCCESS || l3_intf_id < 0)
+        {
+          PT_LOG_ERR(LOG_CTX_IGMP, "Failed to obtain l3 intf for EvcId:%u l3_intf_id:%d", iptv_evc_id, l3_intf_id);      
+          return L7_FAILURE;
+        }
+        if (ptin_debug_igmp_snooping)
+          PT_LOG_DEBUG(LOG_CTX_IGMP, "Obtained L3 Interface l3_intf_id:%d", l3_intf_id);          
+
+        /*Remove L3 Egress Port of this Multicast Group*/
+        rc = ptin_multicast_l3_egress_port_remove(intIfNum, pChannelEntry->pChannelIntfMask->multicastGroup,  l3_intf_id);
+
+        if ( rc != L7_SUCCESS )
+        {
+          PT_LOG_ERR(LOG_CTX_IGMP, "Failed to remove egress portId:%d to multicastGroup:0x%08x (rc%u)", l3_intf_id, pChannelEntry->pChannelIntfMask->multicastGroup, rc);      
+          return L7_FAILURE;
+        }       
+      }
       #else
       rc = ptin_multicast_l2_egress_port_remove(intIfNum, pChannelEntry->pChannelIntfMask->multicastGroup);
       if ( rc != L7_SUCCESS )
       {
         PT_LOG_ERR(LOG_CTX_IGMP, "Failed to remove L2 Egress intIfNum:%u from multicastGroup:0x%08x (rc%u)", intIfNum, pChannelEntry->pChannelIntfMask->multicastGroup, rc);      
         return L7_FAILURE;
@@ -3649,15 +3665,16 @@ L7_RC_t snoopL3GroupIntfRemove(L7_uint32
         continue;
       }
 
       if (PTIN_IS_MASKBITSET(pChannelEntry->pChannelIntfMask->snoopChannelIntfMaskInfoDataKey.channelIntfMask, intf))
       {
         #if defined IGMP_SMART_MC_EVC_SUPPORTED
-        l3_intf_id = -1;
         L7_uint32 iptv_evc_id;
 
+        l3_intf_id = -1;
+
         if (ptin_igmp_UcastEvcId_get(serviceId, &iptv_evc_id) != L7_SUCCESS)
         {
           PT_LOG_ERR(LOG_CTX_IGMP, "Failed to get UcastEvcId");
           return L7_FAILURE;
         }
                
@@ -4434,17 +4451,16 @@ void snoopChannelsGet(L7_uint16 vlanId,
 
     //Copy group/source if vlans match
     if (vlanId == avlTreeKey.vlanId &&       
         avlTreeEntry->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM].active==L7_TRUE && 
         snoopPTinZeroClients(avlTreeEntry->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM].clients)==L7_ALREADY_CONFIGURED)
     {
-      PT_LOG_NOTICE(LOG_CTX_IGMP,"Found group :%s", inetAddrPrint(&avlTreeEntry->snoopPTinL3InfoDataKey.mcastGroupAddr, debug_buf));
-
       snoopPTinL3Interface_t  *interface_ptr;
       L7_uint8                sourceIdx;
 
+      PT_LOG_NOTICE(LOG_CTX_IGMP,"Found group :%s", inetAddrPrint(&avlTreeEntry->snoopPTinL3InfoDataKey.mcastGroupAddr, debug_buf));
       PT_LOG_TRACE(LOG_CTX_IGMP,"\tInterface:%u Clients:0x%0*X", 8*PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE, SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM);
 
       //Add an entry for clients that have requested this group but with no source in particular.
       interface_ptr = &avlTreeEntry->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM];
 
       
@@ -4624,12 +4640,14 @@ void ptin_igmp_snoop_dump(L7_uint16 inde
              avl_info->global.number_of_channels,
              avl_info->global.number_of_clients);
     }
     /* Show one particular entry */
     else if (i_client==index)
     {
+      uint32 intf;
+
       key  = &avl_info->snoopInfoDataKey;
       intVlan = (L7_uint16) key->vlanIdMacAddr[0]<<8 | (L7_uint16) key->vlanIdMacAddr[1];
       /* Global information */
       printf("Entry#%-4u:\r\n",index);
       printf("  Family=%s     Vlan=%-4u MAC=%02x:%02x:%02x:%02x:%02x:%02x   %s\r\n",
              ((key->family==L7_AF_INET) ? "IPv4" : "IPv6"),
@@ -4645,13 +4663,12 @@ void ptin_igmp_snoop_dump(L7_uint16 inde
              avl_info->global.number_of_ports,
              avl_info->global.number_of_channels,
              avl_info->global.number_of_clients);
       /* Ports information */
       printf("  Ports information:\r\n");
       printf("  IntfNUm:");
-      uint32 intf;
       for (intf = 1; intf <= PTIN_SYSTEM_MAXINTERFACES_PER_GROUP; intf++)
       {
        if (L7_INTF_ISMASKBITSET(avl_info->snoopGrpMemberList,intf))
        {
          printf(" %u",intf);
        }
@@ -4807,21 +4824,22 @@ void snoop_l3_channels_dump(void)
   char                       sourceAddrStr[IPV6_DISP_ADDR_LEN]={};
   snoop_eb_t                *pSnoopEB;
 
   memset(&key, 0x00, sizeof(key));
   while ( (pEntry = snoopChannelEntryFind(key.vlanId, &key.groupAddr, &key.sourceAddr, L7_MATCH_GETNEXT)) != L7_NULLPTR)
   {
+      uint32 intf;
+
       printf("vlanId:%u groupAddr:%s sourceAddr:%s noOfInterfaces:%u flags:0x%02x ", 
              pEntry->snoopChannelInfoDataKey.vlanId, inetAddrPrint(&pEntry->snoopChannelInfoDataKey.groupAddr, groupAddrStr), inetAddrPrint(&pEntry->snoopChannelInfoDataKey.sourceAddr, sourceAddrStr), 
              pEntry->noOfInterfaces, pEntry->flags);
       #if PTIN_BOARD_IS_MATRIX//Protection
       printf("noOfProtectionInterfaces:%u  noOfDynamicInterfaces:%u", pEntry->noOfProtectionInterfaces, pEntry->noOfDynamicInterfaces);
       #endif
       printf("\n");            
       printf("  Ports IntfNum:");
-      uint32 intf;
       for (intf = 1; intf <= PTIN_SYSTEM_IGMP_MAXINTERFACES; intf++)
       {
        if (PTIN_IS_MASKBITSET(pEntry->channelIntfMask,intf))
        {
          printf(" %u",intf);
        }
@@ -4863,25 +4881,26 @@ void snoop_l3_channels_intf_mask_dump(vo
   snoopChannelIntfMaskInfoData_t     *pEntry;
   snoopChannelIntfMaskInfoDataKey_t  key; 
   snoop_eb_t                        *pSnoopEB;
 
   memset(&key, 0x00, sizeof(key));
   while ( (pEntry = snoopChannelIntfMaskEntryFind(key.vlanId, &key.channelIntfMask, L7_MATCH_GETNEXT)) != L7_NULLPTR )
-  {  
+  {
+    uint32 intf;
+
     printf("vlanId:%u multicastGroup:%08x noOfChannelEntries:%u noOfInterfaces:%u\n",pEntry->snoopChannelIntfMaskInfoDataKey.vlanId, pEntry->multicastGroup, pEntry->noOfChannelEntries, pEntry->noOfInterfaces);   
     #if 0
     uint32                             idx;
     printf(" groupIntfMask:0x");      
     for (idx = 0; idx < L7_INTF_INDICES; idx++)
     {
      printf("%08x", pEntry->snoopChannelIntfMaskInfoDataKey.channelIntfMask.value[idx]);       
     }
     printf("\r\n");
     #else    
     printf("  Ports IntfNum:");
-    uint32 intf;
     for (intf = 1; intf <= PTIN_SYSTEM_IGMP_MAXINTERFACES; intf++)
     {
      if (PTIN_IS_MASKBITSET(pEntry->snoopChannelIntfMaskInfoDataKey.channelIntfMask, intf))
      {
        printf(" %u",intf);
      }
@@ -4920,25 +4939,24 @@ L7_RC_t snoopEntryRemove(L7_uchar8 *macA
                          L7_uchar8 family)
 {
   snoopInfoData_t  *snoopEntry;
   mfdbMemberInfo_t  mfdb;
   L7_RC_t           rc = L7_SUCCESS;
   L7_uint           igmp_network_version;
+  L7_uint           channel_idx;
+  L7_inet_addr_t    channel;
 
   snoopEntry = snoopEntryFind(macAddr, vlanId, family, L7_MATCH_EXACT);
 
   if (snoopEntry == L7_NULLPTR)
   {
     return L7_FAILURE;
   }
 
   /* PTin added: IGMP snooping */
 #if 1
-  L7_uint channel_idx;
-  L7_inet_addr_t channel;
-
   /* Get igmp network version */
   igmp_network_version = snoopCheckPrecedenceParamGet(vlanId, L7_ALL_INTERFACES, SNOOP_PARAM_IGMP_NETWORK_VERSION, L7_AF_INET);
 
   /* Remove all channels (and send leaves) */
   for (channel_idx=0; channel_idx<SNOOP_MAX_CHANNELS_PER_SNOOP_ENTRY; channel_idx++)
   {
Index: src/application/switching/snooping/core/snooping_ptin_util.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_util.c	(revision 7746)
+++ src/application/switching/snooping/core/snooping_ptin_util.c	(revision 7747)
@@ -430,16 +430,19 @@ L7_RC_t snoopPTinScheduleReportMessage(L
           PT_LOG_ERR(LOG_CTX_IGMP, "Failed to snoopPTinReportSend()");
           return L7_FAILURE;
         }
 #if 0 
 //      newgroupPtr=newgroupPtr+igmpCfg.host.max_records_per_report;       
 #else //Since the group records are not sequencialy ordered on the memory, we cannot perform any arithmetic operation with pointers. Therefore we need to move the pointer record by record.
-        L7_uint32 numberOfRecords;
-        for (numberOfRecords=0;numberOfRecords<igmpCfg.host.max_records_per_report && newgroupPtr!=L7_NULLPTR ;numberOfRecords++)
         {
-          newgroupPtr=newgroupPtr->nextGroupRecord;
+          L7_uint32 numberOfRecords;
+
+          for (numberOfRecords=0;numberOfRecords<igmpCfg.host.max_records_per_report && newgroupPtr!=L7_NULLPTR ;numberOfRecords++)
+          {
+            newgroupPtr=newgroupPtr->nextGroupRecord;
+          }
         }
 #endif
       }
       else
       {
         if (snoopPTinReportSend(vlanId,newgroupPtr,noOfPendingRecords,&igmpCfg)!=L7_SUCCESS)
@@ -580,19 +583,20 @@ L7_RC_t snoopPTinReportFrameV3Build(L7_u
 
   return L7_SUCCESS;
 }
 
 static L7_uchar8* snoopPTinGroupRecordV3Build(L7_uint32 vlanId, L7_inet_addr_t* groupAddr,L7_uint8 recordType,L7_uint16 numberOfSources,snoopPTinProxySource_t* source, L7_uchar8 *buffer, L7_uint32 *length)
 {
-
+  L7_uint32 i;
+  char              debug_buf[IPV6_DISP_ADDR_LEN]={};
   L7_uchar8         *dataPtr,*noSourcesPtr, byteVal;
   L7_ushort16       shortVal;
   L7_uint32         ipv4Addr;
   snoopPTinProxySource_t* sourcePtr;
-  L7_uint32 i;
-  char                debug_buf[IPV6_DISP_ADDR_LEN]={};
+  L7_INTF_MASK_t    mcastRtrAttached;  
+  L7_uint32         noOfInterfaces = 0;
 
   /* Argument validation */
   if (buffer == L7_NULLPTR || length == L7_NULLPTR || groupAddr==L7_NULLPTR || (numberOfSources>0 && source==L7_NULLPTR))
   {
     PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments");
     return L7_NULLPTR;
@@ -655,14 +659,12 @@ static L7_uchar8* snoopPTinGroupRecordV3
   }
 
   /* Update frame length */
   *length = SNOOP_IGMPV3_RECORD_GROUP_HEADER_MIN_LENGTH + L7_IP_ADDR_LEN * numberOfSources;
 //bufferOut=dataPtr;
 
-  L7_INTF_MASK_t mcastRtrAttached;  
-  L7_uint32      noOfInterfaces = 0;
   if (ptin_igmp_rootIntfs_getList(vlanId, &mcastRtrAttached, &noOfInterfaces)==L7_SUCCESS)
   {
     L7_uint32         intf; /* Loop through internal interface numbers */
     /* Increment Counter on all root interfaces in this VLAN with multicast routers attached */
     for (intf = 1; intf <= L7_MAX_INTERFACE_COUNT; intf++)
     {
@@ -1151,21 +1153,21 @@ void snoopPTinMcastgroupPrint(L7_int32 v
 
     for (ifIdx=0; ifIdx<PTIN_SYSTEM_MAXINTERFACES_PER_GROUP; ++ifIdx)
     {
       if (snoopEntry->interfaces[ifIdx].active == L7_TRUE)
       {
         L7_uint32 sourceIdx; 
+        L7_int8 clientIdx;
 
         printf("Interface: %02u |\n", ifIdx);                
         printf("              |Static:         %s\n", snoopEntry->interfaces[ifIdx].isStatic?"Yes":"No");        
         printf("              |Filter-Mode:    %s\n", snoopEntry->interfaces[ifIdx].filtermode==PTIN_SNOOP_FILTERMODE_INCLUDE?"Include":"Exclude");
         printf("              |Nbr of Sources: %u\n", snoopEntry->interfaces[ifIdx].numberOfSources);        
         printf("              |Group-Timer:    %u\n", snoop_ptin_grouptimer_timeleft(&snoopEntry->interfaces[ifIdx].groupTimer));                
         printf("              |Nbr of Clients: %u\n", snoopEntry->interfaces[ifIdx].numberOfClients);        
         printf("              |Clients: ");
-        L7_int8 clientIdx;
         for (clientIdx=(PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE-1); clientIdx>=0; --clientIdx)
         {
           printf("%08X", snoopEntry->interfaces[ifIdx].clients[clientIdx]);
         }                      
         printf("\n");
         for (sourceIdx=0; sourceIdx<PTIN_SYSTEM_IGMP_MAXSOURCES_PER_GROUP; ++sourceIdx)
@@ -1206,24 +1208,22 @@ void snoopPTinMcastgroupPrint(L7_int32 v
  *
  * @return  none
  *
  *************************************************************************/
 void snoopPTinGroupRecordPrint(L7_uint32 vlanId,L7_uint32 groupAddrText,L7_uint8 recordType)
 {
-  char                  debug_buf[IPV6_DISP_ADDR_LEN]={};
   L7_uint32 i;
-
+  char                  debug_buf[IPV6_DISP_ADDR_LEN]={};
   L7_inet_addr_t        groupAddr;
+  snoopPTinProxyInterface_t *interfacePtr;
+  snoopPTinProxyGroup_t     *groupPtr;
+  snoopPTinProxySource_t    *sourcePtr;
+
   memset(&groupAddr, 0x00, sizeof(L7_inet_addr_t));
   groupAddr.family=1;
 
-
-  snoopPTinProxyInterface_t *interfacePtr;
-  snoopPTinProxyGroup_t *groupPtr;    
-  snoopPTinProxySource_t *sourcePtr;    
-
   if ( vlanId<0 || vlanId>4095 /*|| addrStr==L7_NULLPTR*/)
   {
     printf("Invalid Arguments: %d", vlanId);  
     return;
   }
 
Index: src/application/switching/snooping/core/snooping_api.c
===================================================================
--- src/application/switching/snooping/core/snooping_api.c	(revision 7746)
+++ src/application/switching/snooping/core/snooping_api.c	(revision 7747)
@@ -261,15 +261,17 @@ L7_RC_t ptin_snoop_clientsList_get(L7_in
 
   /* Get igmp network version */
   igmp_network_version = snoopCheckPrecedenceParamGet(vlanId, L7_ALL_INTERFACES, SNOOP_PARAM_IGMP_NETWORK_VERSION, L7_AF_INET);
 
   if (igmp_network_version==3)
   {
+    snoopPTinL3InfoData_t  *snoopEntryV3; 
+
     PT_LOG_TRACE(LOG_CTX_IGMP,"IGMPv3 Clients List Get!");
-     snoopPTinL3InfoData_t  *snoopEntryV3; 
-     /* Search for entry in AVL tree*/
+
+    /* Search for entry in AVL tree*/
     if (L7_NULLPTR == (snoopEntryV3 = snoopPTinL3EntryFind(vlanId, groupAddr, L7_MATCH_EXACT)) || 
         snoopEntryV3->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM].active==L7_FALSE ||
         snoopEntryV3->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM].numberOfClients==0)
     {
       PT_LOG_WARN(LOG_CTX_IGMP,"Channel %u.%u.%u.%u does not exist for vlan %u",
                   (groupAddr->addr.ipv4.s_addr>>24) & 0xff,
@@ -282,17 +284,18 @@ L7_RC_t ptin_snoop_clientsList_get(L7_in
       return L7_SUCCESS;
     }
     /* If exists read client bitmap, per leaf interface*/
     else
     {
       L7_uint32 client_list_bmp_tmp[PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE];
-      memset(client_list_bmp_tmp,0x00,sizeof(snoopEntryV3->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM].clients));
-      *number_of_clients=0;
       L7_uint16 intIfNum; 
       L7_uint16 idx;     
 
+      memset(client_list_bmp_tmp,0x00,sizeof(snoopEntryV3->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM].clients));
+      *number_of_clients=0;
+
       for (intIfNum=1; intIfNum<PTIN_SYSTEM_MAXINTERFACES_PER_GROUP; intIfNum++)
       {
         if(snoopEntryV3->interfaces[intIfNum].active==L7_TRUE && snoopEntryV3->interfaces[intIfNum].numberOfClients>0)
         {    
           for (idx=0;idx<PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE ; idx++)
           {
@@ -4079,12 +4082,15 @@ L7_RC_t snoopPortClose(L7_uint32 service
   L7_RC_t        rc = L7_SUCCESS;
   snoop_cb_t    *pSnoopCB = L7_NULLPTR;
   snoopPDU_Msg_t msg;
   snoop_eb_t    *pSnoopEB = L7_NULLPTR;
   char           groupAddrStr[IPV6_DISP_ADDR_LEN]={};
   char           sourceAddrStr[IPV6_DISP_ADDR_LEN]={};
+#if (PTIN_BOARD_IS_LINECARD || PTIN_BOARD_IS_STANDALONE)
+  ptin_prottypeb_intf_config_t protTypebIntfConfig = {0};
+#endif
 
   inetAddrPrint(groupAddr, groupAddrStr);
   inetAddrPrint(sourceAddr, sourceAddrStr);
 
   PT_LOG_DEBUG(LOG_CTX_IGMP, "Context [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s isProtection:%s]", serviceId, intIfNum, groupAddr, sourceAddr, isProtection?"Yes":"No");
 
@@ -4099,13 +4105,12 @@ L7_RC_t snoopPortClose(L7_uint32 service
     return rc;
   }
 #endif
 
 
 #if (PTIN_BOARD_IS_LINECARD || PTIN_BOARD_IS_STANDALONE)
-  ptin_prottypeb_intf_config_t protTypebIntfConfig = {0};
   ptin_prottypeb_intf_config_get(intIfNum, &protTypebIntfConfig);
 #endif
 
   /*Workaround to prevent MGMD from closing a port, when it is inactive and belongs to a protection scheme*/
   if (
   #if PTIN_BOARD_IS_MATRIX
Index: src/application/switching/snooping/core/snooping_util.c
===================================================================
--- src/application/switching/snooping/core/snooping_util.c	(revision 7746)
+++ src/application/switching/snooping/core/snooping_util.c	(revision 7747)
@@ -1240,12 +1240,13 @@ void snoopPacketSend(L7_uint32 intIfNum,
                      L7_int client_idx)
 {
   L7_netBufHandle   bufHandle;
   L7_uchar8        *dataStart;
   L7_INTF_TYPES_t   sysIntfType;
   L7_uint32         member_mode;
+  L7_uint16         extOVlan, extIVlan;
 
 #if PTIN_BOARD_IS_MATRIX  
   /* Do nothing for slave matrix */
   if (!ptin_fpga_mx_is_matrixactive_rt())
   {
     if (ptin_debug_igmp_snooping)
@@ -1292,14 +1293,14 @@ void snoopPacketSend(L7_uint32 intIfNum,
            "snoopPacketSend: System out of netbuffs");    
     return;
   }
 
   /* PTin added: IGMP snooping */
   #if 1
-  L7_uint16 extOVlan = vlanId;
-  L7_uint16 extIVlan = 0;
+  extOVlan = vlanId;
+  extIVlan = 0;
 
   /* Extract external outer and inner vlan for this tx interface */
   if (ptin_igmp_extVlans_get(intIfNum, vlanId, innerVIDUntagged, client_idx, &extOVlan, &extIVlan) == L7_SUCCESS)
   {
     /* Modify outer vlan */
     if (vlanId!=extOVlan)
Index: src/application/switching/snooping/core/snooping_mgmd_api.c
===================================================================
--- src/application/switching/snooping/core/snooping_mgmd_api.c	(revision 7746)
+++ src/application/switching/snooping/core/snooping_mgmd_api.c	(revision 7747)
@@ -964,26 +964,34 @@ unsigned int snooping_tx_packet(unsigned
   L7_uint32             dstIpAddr;
   L7_uchar8            *destIpPtr;
   L7_inet_addr_t        destIp;
   L7_uint32             activeState;
   L7_uint16             int_ovlan;
   L7_uint16             int_ivlan    = 0;
+
   ptin_IgmpProxyCfg_t   igmpCfg;
+  ptin_mgmd_port_type_t portType;
+  L7_uint32             groupAddress;
+#ifdef ONE_MULTICAST_VLAN_RING_SUPPORT
+  L7_uint8              isDynamic;
+#endif //ONE_MULTICAST_VLAN_RING_SUPPORT
 
   PT_LOG_TRACE(LOG_CTX_IGMP, "Context [payLoad:%p payloadLength:%u serviceId:%u portId:%u clientId:%u family:%u]", payload, payloadLength, serviceId, portId, clientId, family);
 
 #if (PTIN_BOARD_IS_LINECARD || PTIN_BOARD_IS_STANDALONE)
-  ptin_prottypeb_intf_config_t protTypebIntfConfig = {0};
-
-  /* Get  the protection status of this switch port */
-  ptin_prottypeb_intf_config_get(portId, &protTypebIntfConfig);
-  if( protTypebIntfConfig.intfRole != PROT_TYPEB_ROLE_NONE &&  protTypebIntfConfig.status != L7_ENABLE)
   {
-    if (ptin_debug_igmp_snooping)
-      PT_LOG_NOTICE(LOG_CTX_IGMP,"Silently ignoring packet transmission. I'm a Protection Port [portId=%u serviceId=%u]",portId, serviceId );
-    return SUCCESS;
+    ptin_prottypeb_intf_config_t protTypebIntfConfig = {0};
+
+    /* Get  the protection status of this switch port */
+    ptin_prottypeb_intf_config_get(portId, &protTypebIntfConfig);
+    if( protTypebIntfConfig.intfRole != PROT_TYPEB_ROLE_NONE &&  protTypebIntfConfig.status != L7_ENABLE)
+    {
+      if (ptin_debug_igmp_snooping)
+        PT_LOG_NOTICE(LOG_CTX_IGMP,"Silently ignoring packet transmission. I'm a Protection Port [portId=%u serviceId=%u]",portId, serviceId );
+      return SUCCESS;
+    }
   }
 #else
   #error "Not Implemented Yet"
 #endif
 
   //Ignore if the port has link down
@@ -998,17 +1006,12 @@ unsigned int snooping_tx_packet(unsigned
   if (ptin_igmp_proxy_config_get__snooping_old(&igmpCfg) != L7_SUCCESS)
   {
     PT_LOG_ERR(LOG_CTX_IGMP, "Error getting IGMP Proxy configurations");
   }
   //Workaround to support Group Specific Queries; IPv6 is not complaint with this approach!
 #if (!PTIN_BOARD_IS_MATRIX && (defined (IGMP_QUERIER_IN_UC_EVC)))
-  ptin_mgmd_port_type_t portType;
-  L7_uint32             groupAddress;
-#ifdef ONE_MULTICAST_VLAN_RING_SUPPORT
-  L7_uint8              isDynamic;
-#endif //ONE_MULTICAST_VLAN_RING_SUPPORT
   if (snooping_portType_get(serviceId, portId, &portType) != L7_SUCCESS)
   {
     PT_LOG_ERR(LOG_CTX_IGMP,"Unable to get port type from int_ovlan [%u] portId [%u]",serviceId,portId);
     return FAILURE;
   }
 
Index: src/application/switching/spanning_tree/dot1s/core/dot1s_control.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/core/dot1s_control.c	(revision 7746)
+++ src/application/switching/spanning_tree/dot1s/core/dot1s_control.c	(revision 7747)
@@ -970,18 +970,19 @@ L7_RC_t dot1sIssueCmd(L7_uint32 event,
                       L7_uint32 intIfNum,
                       L7_uint32 instanceId,
                       void* data)
 {
   L7_RC_t rc = L7_FAILURE;
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
 
   /* find storage for new msg, possibly add to another queue */
   DOT1S_MSG_t msg;
   DOT1S_STATE_CHANGE_MSG_t stateChgMsg;
 
+  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
+
   if ((event != dot1sStateChangeDone) &&
       (event != dot1sStateSetError))
   {
     /* copy event, intIfNum, instanceId and data ptr to msg struct */
     msg.event = event;
     msg.intf = intIfNum;
Index: src/application/switching/spanning_tree/dot1s/core/dot1s_db.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/core/dot1s_db.c	(revision 7746)
+++ src/application/switching/spanning_tree/dot1s/core/dot1s_db.c	(revision 7747)
@@ -294,14 +294,16 @@ L7_uint32 dot1sGetPortTransmitIntervalIn
   return L7_NULL;
 }
 
 
 void dot1sIntfTest()
 {
-  portIndexDebug = 1;
   DOT1S_PORT_COMMON_t *p;
+
+  portIndexDebug = 1;
+
   printf("MAx interface count %d \t Max Port count %d \t L7_MAX_NUM_LAG_INTF %d\n",
          L7_MAX_INTERFACE_COUNT,L7_MAX_PORT_COUNT,L7_MAX_NUM_LAG_INTF);
 
   printf("%s: Enter \n", __FUNCTION__);
   p = dot1sIntfFindFirst();
   while (p != L7_NULLPTR)
Index: src/application/qos/acl/acl.c
===================================================================
--- src/application/qos/acl/acl.c	(revision 7746)
+++ src/application/qos/acl/acl.c	(revision 7747)
@@ -11059,16 +11059,16 @@ void aclTRCorrEntryListInitialize()
 *
 * @end
 *********************************************************************/
 L7_RC_t aclTRCorrEntryGet(aclTRCorrEntry_t **aclTRCorrEntryPtr)
 {
   L7_uint32 msgLvlReqd;
+  aclTRCorrEntry_t *aclTRCorrEntryTemp = L7_NULLPTR;
+
   /* always display output for this function */
   msgLvlReqd = ACL_MSGLVL_LO_2;
- 
-  aclTRCorrEntry_t *aclTRCorrEntryTemp = L7_NULLPTR;
 
   if (aclTRCorrEntryPtr == L7_NULLPTR ||
       aclTRCorrEntryListFree == L7_NULLPTR)
   {
     ACL_PRT(ACL_MSGLVL_LO_2,"Invalid input parameters.");
     return L7_FAILURE;
Index: src/dtl/ip_mcast/dtl_l3_ipv4_mcast.c
===================================================================
--- src/dtl/ip_mcast/dtl_l3_ipv4_mcast.c	(revision 7746)
+++ src/dtl/ip_mcast/dtl_l3_ipv4_mcast.c	(revision 7747)
@@ -511,16 +511,16 @@ L7_RC_t dtlMulticastSGCountersGet(L7_mul
    L7_RC_t rc;
    L7_RC_t dr;
    DAPI_ROUTING_INTF_MGMT_CMD_t dapiCmd;
    nimUSP_t nimusp;
    DAPI_USP_t ddusp;
    L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-   nimGetIntfName(pMcastForwEntryCntQuery->inIntIfNum, L7_SYSNAME, ifName);
-
    static const char *routine_name = "dtlMulticastSGCountersGet()";
 
+   nimGetIntfName(pMcastForwEntryCntQuery->inIntIfNum, L7_SYSNAME, ifName);
+
    DTL_IP_TRACE("%s %d: %s : Dest IP Addr = %x  Source IP addr = %x ,inIntf = %u, %s\n",
                   __FILE__, __LINE__, routine_name,
                   pMcastForwEntryCntQuery->mcastGroupDestAddress.addr.ipv4.s_addr,
                   pMcastForwEntryCntQuery->sourceIpAddress.addr.ipv4.s_addr,
                   pMcastForwEntryCntQuery->inIntIfNum, ifName);
 
@@ -623,16 +623,16 @@ L7_RC_t dtlMulticastSGUseGet(L7_multicas
    L7_RC_t rc;
    L7_RC_t dr;
    DAPI_ROUTING_INTF_MGMT_CMD_t dapiCmd;
    nimUSP_t nimusp;
    DAPI_USP_t ddusp;
    L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-   nimGetIntfName(pMcastForwEntryUseQuery->inIntIfNum, L7_SYSNAME, ifName);
-
    static const char *routine_name = "dtlMulticastSGCountersGet()";
 
+   nimGetIntfName(pMcastForwEntryUseQuery->inIntIfNum, L7_SYSNAME, ifName);
+
    DTL_IP_TRACE("%s %d: %s : Dest IP Addr = %x  Source IP addr = %x ,inIntf = %u, %s\n",
                   __FILE__, __LINE__, routine_name,
                   pMcastForwEntryUseQuery->mcastGroupDestAddress.addr.ipv4.s_addr,
                   pMcastForwEntryUseQuery->sourceIpAddress.addr.ipv4.s_addr,
                   pMcastForwEntryUseQuery->inIntIfNum, ifName);
 
@@ -788,16 +788,16 @@ L7_RC_t dtlMcastVlanPortMemberUpdate(L7_
 
   L7_uint32            intIfNum;
   L7_uint32            portIntIfType;
   L7_uint32            mode;
   L7_uint32            tagMode;
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-  nimGetIntfName(portIntIfNum, L7_SYSNAME, ifName);
-
   static const char   *routine_name = "dtlMcastVlanPortMemberUpdate()";
 
+  nimGetIntfName(portIntIfNum, L7_SYSNAME, ifName);
+
   DTL_IP_TRACE("%s %d: %s : vid = %d, portIntf = %u, %s \n",
                  __FILE__, __LINE__, routine_name,
                  vid, portIntIfNum, ifName);
 
   /* convert vid to a DAPI usp for vlan's router interface  */
   if ((rc = usmDbIpVlanRtrVlanIdToIntIfNum(usmDbThisUnitGet(),vid,
Index: src/dtl/routing/dtl_l3_ipv4.c
===================================================================
--- src/dtl/routing/dtl_l3_ipv4.c	(revision 7746)
+++ src/dtl/routing/dtl_l3_ipv4.c	(revision 7747)
@@ -350,13 +350,12 @@ L7_RC_t dtlIpv4SpoofingModeSet(L7_uint32
 * @notes   This configuration is valid only if spoofing is enabled.
 *
 * @end
 *********************************************************************/
 L7_RC_t dtlIpv4SpoofingHandlingSet(L7_uint32 mode)
 {
-
   static const char *routine_name = "dtlIpv4SpoofingHandlingSet()";
 
   DTL_IP_TRACE("%s : mode =  %s, \n",
                  routine_name,
                  mode?"enable":"disable");
 
@@ -382,13 +381,12 @@ L7_RC_t dtlIpv4ICMPRedirectModeSet(L7_ui
 {
   L7_RC_t rc;
   DAPI_ROUTING_MGMT_CMD_t dapiCmd;
   L7_BOOL     enable;
   DAPI_USP_t ddusp;
   L7_RC_t dr;
-
   static const char *routine_name = "dtlIpv4ICMPRedirectModeSet()";
 
   DTL_IP_TRACE("%s : mode =  %s, \n", routine_name, mode?"enable":"disable");
 
   ddusp.unit = -1;
   ddusp.slot = -1;
@@ -788,17 +786,16 @@ L7_RC_t dtlIpv4LocalMulticastAddrAdd(L7_
   L7_RC_t rc;
   L7_RC_t dr;
   DAPI_ROUTING_INTF_MGMT_CMD_t dapiCmd;
   nimUSP_t nimusp;
   DAPI_USP_t ddusp;
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
-
-
   static const char *routine_name = "dtlIpv4LocalMulticastAddrAdd()";
 
+  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
+
   DTL_IP_TRACE("%s : intf = %u, %s, IP Addr = %x  \n",
                  routine_name,
                  intIfNum, ifName, ipAddress);
 
   if (nimGetUnitSlotPort(intIfNum, &nimusp) != L7_SUCCESS)
   {
@@ -847,16 +844,16 @@ L7_RC_t dtlIpv4LocalMulticastAddrDelete(
   L7_RC_t rc;
   L7_RC_t dr;
   DAPI_ROUTING_INTF_MGMT_CMD_t dapiCmd;
   nimUSP_t nimusp;
   DAPI_USP_t ddusp;
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
-
   static const char *routine_name = "dtlIpv4LocalMulticastAddrDelete()";
 
+  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
+
   DTL_IP_TRACE("%s : intf = %u, %s, IP Addr = %x  \n",
                  routine_name,
                  intIfNum, ifName, ipAddress);
 
   if (nimGetUnitSlotPort(intIfNum, &nimusp) != L7_SUCCESS)
   {
@@ -913,17 +910,16 @@ L7_RC_t dtlIpv4ArpEntryAdd(L7_arpEntry_t
   L7_RC_t rc;
   L7_RC_t dr;
   DAPI_ROUTING_ARP_CMD_t dapiCmd;
   nimUSP_t nimusp;
   DAPI_USP_t ddusp;
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-  nimGetIntfName(pArp->intIfNum, L7_SYSNAME, ifName);
-
-
   static const char *routine_name = "dtlIpv4ArpEntryAdd()";
 
+  nimGetIntfName(pArp->intIfNum, L7_SYSNAME, ifName);
+
   DTL_IP_TRACE("%s : IP Addr = %x, intf = %u, %s, flags = %x, vlan = %d" \
                  " mac addr = %d:%d:%d:%d:%d:%d \n",
                  routine_name,
                  pArp->ipAddr, pArp->intIfNum, ifName, pArp->flags,pArp->vlanId,
                  pArp->macAddr.addr.enetAddr.addr[0],
                  pArp->macAddr.addr.enetAddr.addr[1],
@@ -994,16 +990,16 @@ L7_RC_t dtlIpv4ArpEntryModify(L7_arpEntr
   L7_RC_t rc;
   L7_RC_t dr;
   DAPI_ROUTING_ARP_CMD_t dapiCmd;
   nimUSP_t nimusp;
   DAPI_USP_t ddusp;
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-  nimGetIntfName(pArp->intIfNum, L7_SYSNAME, ifName);
-
   static const char *routine_name = "dtlIpv4ArpEntryModify()";
 
+  nimGetIntfName(pArp->intIfNum, L7_SYSNAME, ifName);
+
   DTL_IP_TRACE("%s : IP Addr = %x, intf = %u, %s, flags = %x, vlan = %d" \
                  " mac addr = %d:%d:%d:%d:%d:%d \n",
                  routine_name,
                  pArp->ipAddr, pArp->intIfNum, ifName, pArp->flags,pArp->vlanId,
                  pArp->macAddr.addr.enetAddr.addr[0],
                  pArp->macAddr.addr.enetAddr.addr[1],
@@ -1070,13 +1066,12 @@ L7_RC_t dtlIpv4ArpEntryDelete(L7_arpEntr
 {
   L7_RC_t rc;
   L7_RC_t dr;
   DAPI_ROUTING_ARP_CMD_t dapiCmd;
   nimUSP_t nimusp;
   DAPI_USP_t ddusp;
-
   static const char *routine_name = "dtlIpv4ArpEntryDelete()";
 
   DTL_IP_TRACE("%s : IP Addr =  %x,  \n",
                  routine_name,
                  pArp->ipAddr);
 
@@ -1139,13 +1134,12 @@ L7_RC_t
 dtlIpv4ArpEntryDeleteAll (void)
 {
   L7_RC_t rc;
   L7_RC_t dr;
   DAPI_ROUTING_ARP_CMD_t dapiCmd;
   DAPI_USP_t ddusp;
-
   static const char *routine_name = "dtlIpv4ArpEntryDeleteAll()";
 
   DTL_IP_TRACE("%s \n", routine_name);
 
   ddusp.unit = -1;
   ddusp.slot = -1;
@@ -1190,17 +1184,16 @@ L7_RC_t dtlIpv4ArpEntryQuery(L7_arpQuery
   L7_RC_t dr;
   DAPI_ROUTING_ARP_CMD_t dapiCmd;
   nimUSP_t nimusp;
   DAPI_USP_t ddusp;
   L7_uint32 lhs,lhd;
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-  nimGetIntfName(pArp->intIfNum, L7_SYSNAME, ifName);
-
-
   static const char *routine_name = "dtlIpv4ArpEntryQuery()";
 
+  nimGetIntfName(pArp->intIfNum, L7_SYSNAME, ifName);
+
   DTL_IP_TRACE("%s %d: %s : IP Addr = %x, vlan = %d, intf = %u, %s\n",
                __FILE__, __LINE__, routine_name,
                pArp->ipAddr, pArp->vlanId, pArp->intIfNum, ifName);
 
   if (nimGetUnitSlotPort(pArp->intIfNum, &nimusp) != L7_SUCCESS)
   {
@@ -1279,16 +1272,14 @@ L7_RC_t dtlIpv4ArpEntryCallback(DAPI_USP
                                 DAPI_EVENT_t event,
                                 void *dapiEventInfo)
 {
   DAPI_ROUTING_ARP_CMD_t *dapiRsp = (DAPI_ROUTING_ARP_CMD_t *)dapiEventInfo;
   L7_arpEntry_t arpEntry;
   nimUSP_t      nimUsp;
-
   static const char *routine_name = "dtlIpv4ArpEntryQueryCallback()";
 
-
   /* this function only for ARP Mgmt family */
   if (family != DAPI_FAMILY_ROUTING_ARP_MGMT)
     return L7_FAILURE;
 
   /* Check for driver-initiated request to resolve an ARP entry.  This
    * entry may have been issued previously, but the driver was unable
@@ -1677,13 +1668,12 @@ static L7_RC_t dtlIpv4RouteEntryExtract(
   L7_uint32 i;
   nimUSP_t  nimUsp;
 #if FUTURE_FUNC
   DAPI_ROUTING_ROUTE_DESTINATION_t *pEcrRow, *pEcr;
 #endif
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-
   static const char *routine_name = "dtlIpv4RouteEntryExtract()";
 
   for (i=0; i < pRoute->ecmpRoutes.numOfRoutes; i++)
   {
     nimGetIntfName(pRoute->ecmpRoutes.equalCostPath[i].arpEntry.intIfNum, L7_SYSNAME, ifName);
     DTL_IP_TRACE("%s : IP Addr = %x, Mask = %x. intf = %u, %s, vlan = %d, flags =  %x  \n",
@@ -1805,16 +1795,16 @@ L7_RC_t dtlIpv4VrrpVridAdd(L7_uint32 int
   L7_RC_t dr;
   DAPI_ROUTING_INTF_MGMT_CMD_t dapiCmd;
   dtlRtrIntf_t ipCircuit;
   DAPI_USP_t ddusp;
   nimUSP_t nimusp;
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
-
   static const char *routine_name = "dtlIpv4VrrpVridAdd()";
 
+  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
+
   ipCircuit.intIfNum    = intIfNum;
   ipCircuit.vlanId      = 0;        /* FUTURE_FUNC */
 
   if (nimGetUnitSlotPort(ipCircuit.intIfNum, &nimusp) != L7_SUCCESS)
   {
     return L7_FAILURE;
@@ -1867,16 +1857,16 @@ L7_RC_t dtlIpv4VrrpVridDelete(L7_uint32
   L7_RC_t dr;
   DAPI_ROUTING_INTF_MGMT_CMD_t dapiCmd;
   dtlRtrIntf_t ipCircuit;
   DAPI_USP_t ddusp;
   nimUSP_t nimusp;
   L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
-  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
-
   static const char *routine_name = "dtlIpv4VrrpVridDelete()";
 
+  nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
+
   ipCircuit.intIfNum    = intIfNum;
   ipCircuit.vlanId      = 0;        /* FUTURE_FUNC */
 
   if (nimGetUnitSlotPort(ipCircuit.intIfNum, &nimusp) != L7_SUCCESS)
   {
     return L7_FAILURE;
Index: src/mgmt/broadcom/cli/routing/common/cli_config_l3.c
===================================================================
--- src/mgmt/broadcom/cli/routing/common/cli_config_l3.c	(revision 7746)
+++ src/mgmt/broadcom/cli/routing/common/cli_config_l3.c	(revision 7747)
@@ -4435,12 +4435,13 @@ const L7_char8 *commandIpMtu(EwsContext
   L7_int32 ipMtuSize;
 
   L7_uint32 numArg;
   L7_uint32 unit;
   L7_RC_t status = L7_SUCCESS;
   L7_char8 buf[L7_CLI_MAX_STRING_LENGTH];
+  L7_RC_t rc;
 
   ewsContext->actionFunctionStatusFlag=L7_ACTION_FUNC_FAILED;
   cliSyntaxTop (ewsContext);
 
   numArg = cliNumFunctionArgsGet();
 
@@ -4490,13 +4491,13 @@ const L7_char8 *commandIpMtu(EwsContext
            osapiSnprintf(buf, sizeof(buf), pStrErr_routing_IpMtuOutOfRange, 
                          L7_L3_MIN_IP_MTU, maxIpMtu);
            ewsTelnetWriteAddBlanks (1,1, 0, 0, L7_NULLPTR,ewsContext, buf);
            continue;
         }
 
-        L7_RC_t rc = usmDbIntfIpMtuSet(unit, iface, ipMtuSize);
+        rc = usmDbIntfIpMtuSet(unit, iface, ipMtuSize);
         if (rc == L7_FAILURE)
         {
           status = L7_FAILURE;
           ewsTelnetWriteAddBlanks (1, 0, 0, 0, L7_NULLPTR, ewsContext, cliDisplayInterfaceHelp(unit, s, p));
           ewsTelnetWriteAddBlanks (1, 0, 0, 0, pStrErr_common_CouldNot, ewsContext,
                                                  pStrErr_common_CfgMaxFrameSize);
Index: src/mgmt/broadcom/cli/base/common/cli_show_running_config.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/cli_show_running_config.c	(revision 7746)
+++ src/mgmt/broadcom/cli/base/common/cli_show_running_config.c	(revision 7747)
@@ -2162,23 +2162,22 @@ L7_RC_t cliRunningConfigRadiusInfo(EwsCo
   L7_char8 strIpAddr[L7_CLI_MAX_STRING_LENGTH];
   L7_IP_ADDRESS_TYPE_t authTypeList[L7_RADIUS_MAX_AUTH_SERVERS] = {L7_IP_ADDRESS_TYPE_UNKNOWN};
   L7_char8 authHostList[L7_RADIUS_MAX_AUTH_SERVERS][L7_DNS_HOST_NAME_LEN_MAX];
   L7_IP_ADDRESS_TYPE_t acctTypeList[L7_RADIUS_MAX_ACCT_SERVERS] = {L7_IP_ADDRESS_TYPE_UNKNOWN};
   L7_char8 acctHostList[L7_RADIUS_MAX_ACCT_SERVERS][L7_DNS_HOST_NAME_LEN_MAX];
 
+  L7_IP_ADDRESS_TYPE_t type = L7_IP_ADDRESS_TYPE_UNKNOWN;
+  L7_char8 name[L7_RADIUS_SERVER_NAME_LENGTH+1];
+
   L7_uint32 count;
   L7_int32 i;
   L7_RC_t rc = L7_FAILURE;
 
   memset(authHostList, 0x00, sizeof(L7_DNS_HOST_NAME_LEN_MAX) * L7_RADIUS_MAX_AUTH_SERVERS);
   memset(acctHostList, 0x00, sizeof(L7_DNS_HOST_NAME_LEN_MAX) * L7_RADIUS_MAX_ACCT_SERVERS);
 
-
-  L7_IP_ADDRESS_TYPE_t type = L7_IP_ADDRESS_TYPE_UNKNOWN;
-  L7_char8 name[L7_RADIUS_SERVER_NAME_LENGTH+1];
-
   if ( usmDbRadiusAccountingModeGet(unit, &val ) == L7_SUCCESS )
   {
     cliShowCmdEnable (ewsContext, val, FD_RADIUS_ACCT_ADMIN_MODE, pStrInfo_base_RadiusAcctMode);
 
   }
 
@@ -2813,23 +2812,22 @@ L7_RC_t cliRunningPhysicalInterfaceInfo(
   static L7_uint32 taggedVids[4500], tagCount = 0;
   static L7_uint32 notaggedVids[4500], notagCount = 0;
   L7_RATE_UNIT_t rate_unit;
   L7_uchar8 paeCap;
   L7_uint32 tmpVal;
   L7_int32 hashMode;
-
   L7_ushort16 defPrio;
+#ifdef L7_ROUTING_PACKAGE
+  L7_int32 bandwidth;
+#endif
 
   autoCount = 0;
   includeCount = 0;
   excludeCount = 0;
   tagCount = 0;
   notagCount = 0;
-#ifdef L7_ROUTING_PACKAGE
-  L7_int32 bandwidth;
-#endif
 
 #if defined L7_DOT1AD_PACKAGE
   DOT1AD_INTFERFACE_TYPE_t  intfType;
 #endif
 
   groupID = 0;
Index: src/mgmt/broadcom/cli/base/common/cli_show_usermgr.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/cli_show_usermgr.c	(revision 7746)
+++ src/mgmt/broadcom/cli/base/common/cli_show_usermgr.c	(revision 7747)
@@ -2047,20 +2047,21 @@ const L7_char8  *commandShowLoginHistory
 *********************************************************************/
 const L7_char8 *commandShowPasswordsResult(EwsContext ewsContext,
                                            uintf argc,
                                            const L7_char8 * * argv,
                                            uintf index)
 {
-  cliSyntaxTop(ewsContext);
   L7_uint32   authMethod, id, result;
   L7_BOOL     strengthCheck;
   L7_char8    userName[L7_LOGIN_SIZE]={0};
   L7_ushort16 minPassLen;
   L7_uint8    val;
   L7_char8    buf[L7_CLI_MAX_STRING_LENGTH * 2]={0};
 
+  cliSyntaxTop(ewsContext);
+
   usmDbMinPassLengthGet(&minPassLen);
       
   if(usmDbUserMgrLastPasswordResultGet(&authMethod, &id,
                                        &strengthCheck, &result) != L7_SUCCESS)
   {
     return cliSyntaxReturnPrompt (ewsContext, "");
Index: src/mgmt/broadcom/cli/base/common/clicommands.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/clicommands.c	(revision 7746)
+++ src/mgmt/broadcom/cli/base/common/clicommands.c	(revision 7747)
@@ -448,14 +448,14 @@ void cliCommandsInit(void)
 *********************************************************************/
 void buildTreeMaintenanceMode(void)
 {
   EwsCliCommandP depth1;
   EwsCliCommandP depth2,depth3,depth4, depth5, depth6;
   
-  #ifdef L7_PBVLAN_PACKAGE
-  EwsCliCommandP depth7,depth8, depth9;;
+#ifdef L7_PBVLAN_PACKAGE
+  EwsCliCommandP depth7,depth8, depth9;
   L7_uint32      unit = 0;
 #endif
 
   depth1 = ewsCliAddNode ( NULL, NULL, NULL, NULL, L7_NO_OPTIONAL_PARAMS);
 
   cliSetMode(L7_MAINTENANCE_MODE, depth1);
Index: src/mgmt/snmp/util/switching/trap_api_switching.c
===================================================================
--- src/mgmt/snmp/util/switching/trap_api_switching.c	(revision 7746)
+++ src/mgmt/snmp/util/switching/trap_api_switching.c	(revision 7747)
@@ -1717,21 +1717,22 @@ L7_RC_t snmpSwitchCpuRisingThresholdTrap
   VarBind *temp_vb = NULL;
   
   OID *snmpTrapOID = MakeOIDFromDot("agentSwitchCpuRisingThresholdTrap");
   OID *oid_risingThreshold = MakeOIDFromDot("agentSwitchCpuProcessRisingThreshold");
   OID *oid_buf = MakeOIDFromDot("agentSwitchCpuProcessName");
 
+  OctetString *os_buf = MakeOctetStringFromText(buf);
   VarBind *var_risingThreshold = L7_NULLPTR;
+  VarBind *var_buf = MakeVarBindWithValue(oid_buf, NULL, OCTET_PRIM_TYPE, os_buf);
+
   var_risingThreshold = MakeVarBindWithValue(oid_risingThreshold, NULL, INTEGER_TYPE, &risingThreshold);
 
-  OctetString *os_buf = MakeOctetStringFromText(buf);
   if (os_buf == NULL)
   {
     return L7_FAILURE;
   }
-  VarBind *var_buf = MakeVarBindWithValue(oid_buf, NULL, OCTET_PRIM_TYPE, os_buf);
 
   FreeOID(oid_risingThreshold);
   FreeOID(oid_buf);
   
   if (snmpTrapOID == NULL || var_risingThreshold == NULL || var_buf == NULL)
   {
Index: src/mgmt/snmp/packages/switching/common/k_mib_fastpathswitching.c
===================================================================
--- src/mgmt/snmp/packages/switching/common/k_mib_fastpathswitching.c	(revision 7746)
+++ src/mgmt/snmp/packages/switching/common/k_mib_fastpathswitching.c	(revision 7747)
@@ -407,17 +407,18 @@ k_agentSupportedMibEntry_get(int serialN
 #ifdef I_agentSwitchCpuProcessMemFree
 agentSwitchCpuProcessGroup_t *
 k_agentSwitchCpuProcessGroup_get(int serialNum, ContextInfo *contextInfo,
                                  int nominator)
 {
    static agentSwitchCpuProcessGroup_t agentSwitchCpuProcessGroupData;
-   ZERO_VALID(agentSwitchCpuProcessGroupData.valid);
 #ifdef I_agentSwitchCpuProcessTotalUtilization
    L7_char8 snmp_buffer[SNMP_BUFFER_LEN];
 #endif /* I_agentSwitchCpuProcessTotalUtilization */
 
+   ZERO_VALID(agentSwitchCpuProcessGroupData.valid);
+
    /*
     * put your code to retrieve the information here
     */
   switch (nominator)
   {
   case -1:
@@ -1243,16 +1244,17 @@ k_agentPasswordManagementConfigGroup_set
 {
   /*
    * Defining temporary variable for storing the valid bits for the case when the
    * set request is only paritally successful
   */
   L7_char8 tempValid[sizeof(data->valid)];
-  bzero(tempValid, sizeof(tempValid));
   L7_uint8 val8;
   L7_uint32 enable;
 
+  bzero(tempValid, sizeof(tempValid));
+
   if (VALID(I_agentPasswordManagementMinLength, data->valid))
   {
     if(usmDbMinPasswdSet(USMDB_UNIT_CURRENT, data->agentPasswordManagementMinLength) != L7_SUCCESS)
     {
       memcpy(data->valid, tempValid, sizeof(data->valid));
       return COMMIT_FAILED_ERROR;
@@ -1681,20 +1683,20 @@ k_agentUserConfigGroup_ready(ObjectInfo
 int
 k_agentUserConfigGroup_set(agentUserConfigGroup_t *data,
                            ContextInfo *contextInfo, int function)
 {
   L7_char8 snmp_buffer[SNMP_BUFFER_LEN];
   L7_char8 auditMsg[SNMP_BUFFER_LEN];
+  L7_char8 tempValid[sizeof(data->valid)];
 
   memset(snmp_buffer, L7_NULL, sizeof(snmp_buffer));
   memset(auditMsg, L7_NULL, sizeof(auditMsg));
   /*
    * Defining temporary variable for storing the valid bits for the case when the
    * set request is only paritally successful
   */
-  L7_char8 tempValid[sizeof(data->valid)];
   bzero(tempValid, sizeof(tempValid));
 
   if (VALID(I_agentUserConfigCreate, data->valid))
   {
     bzero(snmp_buffer, SNMP_BUFFER_LEN);
     memcpy(snmp_buffer, data->agentUserConfigCreate->octet_ptr, data->agentUserConfigCreate->length);
@@ -1970,24 +1972,24 @@ k_agentUserConfigEntry_set_defaults(doLi
 int
 k_agentUserConfigEntry_set(agentUserConfigEntry_t *data,
                            ContextInfo *contextInfo, int function)
 {
   L7_char8 snmp_buffer[SNMP_BUFFER_LEN];
   L7_char8 auditMsg[SNMP_BUFFER_LEN];
+  L7_char8 tempValid[sizeof(data->valid)];
 
 #if defined(I_agentUserEncryptionType)
   L7_uint32 temp_encryption_type;
 #endif
 
   memset(snmp_buffer, L7_NULL, sizeof(snmp_buffer));
   memset(auditMsg, L7_NULL, sizeof(auditMsg));
   /*
    * Defining temporary variable for storing the valid bits for the case when the
    * set request is only paritally successful
   */
-  L7_char8 tempValid[sizeof(data->valid)];
   bzero(tempValid, sizeof(tempValid));
 
   if ( snmpAgentUserConfigEntryGet(USMDB_UNIT_CURRENT, data->agentUserIndex) != L7_SUCCESS)
   {
     ZERO_VALID(data->valid);
     return(COMMIT_FAILED_ERROR);
@@ -3517,18 +3519,19 @@ k_agentNetworkConfigGroup_set(agentNetwo
   /*
    * Defining temporary variable for storing the valid bits for the case when the
    * set request is only paritally successful
   */
   L7_char8 snmp_buffer[SNMP_BUFFER_LEN];
   L7_char8 tempValid[sizeof(data->valid)];
-  bzero(tempValid, sizeof(tempValid));
   L7_uint32 oldval;
 #ifdef L7_ROUTING_PACKAGE
   L7_uint32 intIfNum;
 #endif
     
+  bzero(tempValid, sizeof(tempValid));
+
   if ( VALID(I_agentNetworkConfigProtocol, data->valid))
   {
     if(snmpAgentNetworkConfigProtocolSet(USMDB_UNIT_CURRENT,
                                          data->agentNetworkConfigProtocol) != L7_SUCCESS )
     {
       memcpy(data->valid, tempValid, sizeof(data->valid));
@@ -4460,15 +4463,16 @@ k_agentServicePortConfigGroup_set(agentS
    * set request is only paritally successful
   */
   #if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
   L7_char8 snmp_buffer[SNMP_BUFFER_LEN];
   #endif
   L7_char8 tempValid[sizeof(data->valid)];
-  bzero(tempValid, sizeof(tempValid));
   L7_uint32 oldval;
 
+  bzero(tempValid, sizeof(tempValid));
+
   if (usmDbComponentPresentCheck(USMDB_UNIT_CURRENT, L7_SERVICE_PORT_PRESENT_ID ) == L7_FALSE )
       return(COMMIT_FAILED_ERROR);
 
   if ( VALID(I_agentServicePortConfigProtocol, data->valid))
   {
     if(snmpAgentServicePortConfigProtocolSet(USMDB_UNIT_CURRENT,
@@ -12105,20 +12109,20 @@ k_agentTransferUploadGroup_ready(ObjectI
 int
 k_agentTransferUploadGroup_set(agentTransferUploadGroup_t *data,
                                ContextInfo *contextInfo, int function)
 {
   L7_char8 snmp_buffer[SNMP_BUFFER_LEN];
   L7_char8 auditMsg[SNMP_BUFFER_LEN];
+  L7_char8 tempValid[sizeof(data->valid)];
 
   memset(auditMsg, L7_NULL, sizeof(auditMsg));
 
   /*
    * Defining temporary variable for storing the valid bits for the case when the
    * set request is only paritally successful
   */
-  L7_char8 tempValid[sizeof(data->valid)];
   bzero(tempValid, sizeof(tempValid));
 
   if ( VALID(I_agentTransferUploadMode, data->valid))
   {
     if( snmpAgentTransferUploadModeSet(USMDB_UNIT_CURRENT,
                                       data->agentTransferUploadMode) != L7_SUCCESS )
@@ -12484,20 +12488,20 @@ k_agentTransferDownloadGroup_ready(Objec
 int
 k_agentTransferDownloadGroup_set(agentTransferDownloadGroup_t *data,
                                  ContextInfo *contextInfo, int function)
 {
   L7_char8 snmp_buffer[SNMP_BUFFER_LEN];
   L7_char8 auditMsg[L7_CLI_MAX_STRING_LENGTH];
+  L7_char8 tempValid[sizeof(data->valid)];
 
   memset(auditMsg, L7_NULL, sizeof(auditMsg));
 
   /*
    * Defining temporary variable for storing the valid bits for the case when the
    * set request is only paritally successful
   */
-  L7_char8 tempValid[sizeof(data->valid)];
   bzero(tempValid, sizeof(tempValid));
 
   if ( VALID(I_agentTransferDownloadMode, data->valid))
   {
     if( snmpAgentTransferDownloadModeSet(USMDB_UNIT_CURRENT,
                                         data->agentTransferDownloadMode) != L7_SUCCESS )
Index: src/mgmt/snmp/packages/security/k_mib_dot1xAdvanced.c
===================================================================
--- src/mgmt/snmp/packages/security/k_mib_dot1xAdvanced.c	(revision 7746)
+++ src/mgmt/snmp/packages/security/k_mib_dot1xAdvanced.c	(revision 7747)
@@ -486,15 +486,16 @@ k_agentDot1xClientConfigEntry_get(int se
 
 agentDot1xMonitorModeConfigGroup_t *
 k_agentDot1xMonitorModeConfigGroup_get(int serialNum, ContextInfo *contextInfo,
                                        int nominator)
 {
   static agentDot1xMonitorModeConfigGroup_t agentDot1xMonitorModeConfigGroupData;
-  ZERO_VALID(agentDot1xMonitorModeConfigGroupData.valid);
   L7_BOOL enable; 
 
+  ZERO_VALID(agentDot1xMonitorModeConfigGroupData.valid);
+
   switch (nominator)
   {
     case I_agentDot1xMonitorModeEnabled:
       if(usmDbDot1xMonitorModeGet(USMDB_UNIT_CURRENT, &enable) == L7_SUCCESS)
       {
         if(enable == L7_DISABLE)
Index: src/application/ip_mcast/mapping/mgmdmap/mgmdmap_debug.c
===================================================================
--- src/application/ip_mcast/mapping/mgmdmap/mgmdmap_debug.c	(revision 7751)
+++ src/application/ip_mcast/mapping/mgmdmap/mgmdmap_debug.c	(revision 7752)
@@ -1068,23 +1068,23 @@ void mgmdDebugDeRegister(void)
 
 
 
 void mgmdDebugPrint(L7_uchar8 family)
 {
   L7_uint32 flagIndex;
+  mgmdDebugTraceFlags_t *mgmdTraceFlags = &(mgmdDebugCfg.cfg.mgmdDebugTraceFlag[family]);
 
   sysapiPrintf("\n-----------------\n");
   sysapiPrintf("\n version = %d", mgmdDebugCfg.hdr.version);
   sysapiPrintf("\n compId = %d", mgmdDebugCfg.hdr.componentID);
   sysapiPrintf("\n type = %d", mgmdDebugCfg.hdr.type);
   sysapiPrintf("\n length = %d", mgmdDebugCfg.hdr.length);
   sysapiPrintf("\n fileName = %s", mgmdDebugCfg.hdr.filename);
   sysapiPrintf("\n dataChng = %d", mgmdDebugCfg.hdr.dataChanged);
   sysapiPrintf("\n-----------------\n");
 
-  mgmdDebugTraceFlags_t *mgmdTraceFlags = &(mgmdDebugCfg.cfg.mgmdDebugTraceFlag[family]);
   for (flagIndex = 0;  flagIndex < MGMD_DEBUG_LAST_TRACE ; flagIndex ++)
   {
     if (((*(mgmdTraceFlags[flagIndex/MGMD_DEBUG_TRACE_FLAG_BITS_MAX])) & 
          (MGMD_DEBUG_TRACE_FLAG_VALUE << (flagIndex % MGMD_DEBUG_TRACE_FLAG_BITS_MAX))) != 0)
     {
       sysapiPrintf("\n Flag [%d] is set", flagIndex);
Index: src/mgmt/broadcom/cli/base/common/cliutil.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/cliutil.c	(revision 7751)
+++ src/mgmt/broadcom/cli/base/common/cliutil.c	(revision 7752)
@@ -6260,32 +6260,33 @@ L7_RC_t passwdRecoveryFlagGet(L7_int32 *
   if(osapiFsRead("envFile",(L7_char8 *)&envVaribles,sizeof(envVar_t)) != L7_SUCCESS)
   {
     return L7_FAILURE;
   }
 
 #elif _L7_OS_LINUX_
+  {
+    /* Get the data from a text file because its text file for this OS */
+    L7_char8 passwordBuff[50],*tempPtr = L7_NULLPTR;
 
- /* Get the data from a text file because its text file for this OS */
- L7_char8 passwordBuff[50],*tempPtr = L7_NULLPTR;
-
- memset(passwordBuff,0x00,sizeof(passwordBuff));
+    memset(passwordBuff,0x00,sizeof(passwordBuff));
 
- /* Open the text file and convert the text data to integer */
- /* PTin modified: paths */
- if(osapiFsRead("/var/log/switchdrvr/envFile",(L7_char8 *)passwordBuff,sizeof(passwordBuff)) != L7_SUCCESS)
- {
-    return L7_FAILURE;
- }
- tempPtr = strstr(passwordBuff,"defaultPwdFlag=");
- if(tempPtr == L7_NULL)
- {
-     return L7_ERROR;
- }
+    /* Open the text file and convert the text data to integer */
+    /* PTin modified: paths */
+    if(osapiFsRead("/var/log/switchdrvr/envFile",(L7_char8 *)passwordBuff,sizeof(passwordBuff)) != L7_SUCCESS)
+    {
+      return L7_FAILURE;
+    }
+    tempPtr = strstr(passwordBuff,"defaultPwdFlag=");
+    if(tempPtr == L7_NULL)
+    {
+      return L7_ERROR;
+    }
 
- tempPtr = tempPtr + strlen("defaultPwdFlag=");
- envVaribles.defaultPasswordFlag = atoi(tempPtr);
+    tempPtr = tempPtr + strlen("defaultPwdFlag=");
+    envVaribles.defaultPasswordFlag = atoi(tempPtr);
+  }
 #endif
 *envVar = envVaribles.defaultPasswordFlag;
 return L7_SUCCESS;
 
 }
 /****************************************************************************
@@ -6318,22 +6319,24 @@ L7_RC_t passwdRecoveryFlagSet(L7_uint32
   /* The file exists now,Write the flag into file */
   if(osapiFsWrite("envFile",(L7_char8 *)&envVaribles,sizeof(envVar_t)) != L7_SUCCESS)
   {
      return L7_ERROR;
   }
 #elif _L7_OS_LINUX_
-  L7_char8 passwordBuff[50];
+  {
+    L7_char8 passwordBuff[50];
 
     memset(passwordBuff,0x00,sizeof(passwordBuff));
-  /* Open the text file and Write a text data to the file */
-  osapiSnprintf(passwordBuff,sizeof(passwordBuff),"defaultPwdFlag=%d",envVaribles.defaultPasswordFlag);
+    /* Open the text file and Write a text data to the file */
+    osapiSnprintf(passwordBuff,sizeof(passwordBuff),"defaultPwdFlag=%d",envVaribles.defaultPasswordFlag);
     /* PTin modified: paths */
     if(osapiFsWrite("/var/log/switchdrvr/envFile",passwordBuff,sizeof(passwordBuff)) != L7_SUCCESS)
     {
       return L7_FAILURE;
     }
+  }
 #endif
     return L7_SUCCESS;
 }
 
 L7_RC_t cliParseRangeInput(const L7_char8 *buf, L7_uint32 *count, L7_uint32 *list, L7_uint32 listSize)
 {
Index: src/system_support/base/infrastructure/nim/nim_events.c
===================================================================
--- src/system_support/base/infrastructure/nim/nim_events.c	(revision 7753)
+++ src/system_support/base/infrastructure/nim/nim_events.c	(revision 7754)
@@ -516,12 +516,16 @@ L7_RC_t nimNotifyLinkUp()
 void nimDtlIntfChangeCallback(nimUSP_t *usp, L7_uint32 event, void * dapiIntmgmt)
 {
   nimUSP_t      nimUsp;
   L7_uint32     intIfNum = 0;
   NIM_HANDLE_t           handle;
   NIM_EVENT_NOTIFY_INFO_t eventInfo;
+  /* PTin added: set an alarm for posterior processing */
+#if 1
+  extern L7_uint32 linkStatus_alarm[L7_ALL_INTERFACES/32+1];
+#endif
 
   if (nimPhaseStatusCheck() != L7_TRUE)
   {
     return;
   }
 
@@ -546,13 +550,12 @@ void nimDtlIntfChangeCallback(nimUSP_t *
       NIM_INTF_SETMASKBIT(nimCtlBlk_g->linkStateMask, nimCtlBlk_g->nimPorts[intIfNum].runTimeMaskId);
       break;
     case L7_DOWN:
       NIM_INTF_CLRMASKBIT(nimCtlBlk_g->linkStateMask, nimCtlBlk_g->nimPorts[intIfNum].runTimeMaskId);
       /* PTin added: set an alarm for posterior processing */
       #if 1
-      extern L7_uint32 linkStatus_alarm[L7_ALL_INTERFACES/32+1];
       /* Signalize an alarm to ptin_control task */
       linkStatus_alarm[intIfNum/32] |= (L7_uint32) 1 << (intIfNum%32);  /* An alarm has happen */
       PT_LOG_DEBUG(LOG_CTX_INTF,"Alarm-down signaled for intIfNum %u", intIfNum);
       #endif
       break;
     default:
Index: src/application/ptin/base/ptin_msghandler.c
===================================================================
--- src/application/ptin/base/ptin_msghandler.c	(revision 7757)
+++ src/application/ptin/base/ptin_msghandler.c	(revision 7758)
@@ -343,17 +343,17 @@ int CHMessageHandler (ipc_msg *inbuffer,
       PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "...Stdout redirected to here :-)");
       return IPC_OK;  /* CCMSG_APP_CHANGE_STDOUT */
     }
 
     case CCMSG_APP_LOGGER_OUTPUT:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APP_LOGGER_OUTPUT (0x%04X)", msgId);
-
       L7_uint8 output;
       char *filename;
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APP_LOGGER_OUTPUT (0x%04X)", msgId);
+
       /* If infodim is null, use stdout */
       if (infoDim == 0)
       {
         PT_LOG_NOTICE(LOG_CTX_MSGHANDLER, "Redirecting logger output (0) to \"%s\"...", LOG_OUTPUT_FILE_DEFAULT);
         logger_redirect(LOG_OUTPUT_FILE, LOG_OUTPUT_FILE_DEFAULT);
         ptin_mgmd_logredirect(MGMD_LOG_FILE, LOG_OUTPUT_FILE_DEFAULT);
@@ -411,19 +411,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       return IPC_OK;  /* CCMSG_APP_SHELL_CMD_RUN */
     }
 
     /* CCMSG_ETH_PHY_ACTIVITY_GET ************************************************/
     case CCMSG_ETH_PHY_ACTIVITY_GET:
     {
+      msg_HWEthPhyActivity_t *pin  = (msg_HWEthPhyActivity_t *) inbuffer->info;
+      msg_HWEthPhyActivity_t *pout = (msg_HWEthPhyActivity_t *) outbuffer->info;
+
       PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_ACTIVITY_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HWEthPhyActivity_t);
 
-      msg_HWEthPhyActivity_t *pin  = (msg_HWEthPhyActivity_t *) inbuffer->info;
-      msg_HWEthPhyActivity_t *pout = (msg_HWEthPhyActivity_t *) outbuffer->info;
-
       /* Reference structure */
       memcpy(pout, pin, sizeof(msg_HWEthPhyActivity_t));
 
       if (ptin_msg_PhyActivity_get(pout) != L7_SUCCESS)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port activity (slot=%u/%u)", ENDIAN_SWAP8(pin->intf.slot), ENDIAN_SWAP8(pin->intf.port));
@@ -436,17 +436,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       return IPC_OK;  /* CCMSG_ETH_PHY_ACTIVITY_GET */
     }
 
     /* CCMSG_BOARD_SHOW *******************************************************/
     case CCMSG_BOARD_SHOW:
     {
+      msg_FWFastpathInfo *fpInfo;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_BOARD_SHOW (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(0);
 
-      msg_FWFastpathInfo *fpInfo;
       fpInfo = (msg_FWFastpathInfo *) outbuffer->info;
 
       /* Get values */
       ptin_msg_FPInfo_get(fpInfo);  /* returns always success */
 
       /* Copy slot id information if available! */
@@ -460,16 +461,17 @@ int CHMessageHandler (ipc_msg *inbuffer,
       return IPC_OK;  /* CCMSG_BOARD_SHOW */
     }
 
     /* CCMSG_HW_INTF_INFO_GET ****************************************************/
     case CCMSG_HW_INTF_INFO_GET:
     {
+      msg_HwIntfInfo_t *ptr;
+
       PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_HW_INTF_INFO_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_ATLEAST(L7_uint32);
-      msg_HwIntfInfo_t *ptr;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwIntfInfo_t));
       ptr = (msg_HwIntfInfo_t *) outbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_intfInfo_get(ptr);
@@ -507,20 +509,21 @@ int CHMessageHandler (ipc_msg *inbuffer,
       return IPC_NO_REPLY;
     }
 
     /* CCMSG_APPLICATION_RESOURCES *********************************************/
     case CCMSG_APPLICATION_RESOURCES:
     {
+      msg_ptin_policy_resources *resources;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_APPLICATION_RESOURCES (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_ptin_policy_resources);
 
       /* Copy inbuffer to outbuffer */
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_ptin_policy_resources));
 
-      msg_ptin_policy_resources *resources;
       resources = (msg_ptin_policy_resources *) outbuffer->info;
 
       /* Get values */
       if ( L7_SUCCESS != (rc=ptin_msg_hw_resources_get(resources)) )
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while consulting hardware resources");
@@ -579,19 +582,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * Control processing
      **************************************************************************/
 
     /* Uplink protection command *********************************************/
     case CHMSG_ETH_UPLINK_COMMAND:
     {
+      msg_uplinkProtCmd *ptr = (msg_uplinkProtCmd *) inbuffer->info;
+      L7_int n = MSG_N_ELEMS(sizeof(msg_uplinkProtCmd));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_ETH_UPLINK_COMMAND (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_uplinkProtCmd);
 
-      msg_uplinkProtCmd *ptr = (msg_uplinkProtCmd *) inbuffer->info;
-      L7_int n = MSG_N_ELEMS(sizeof(msg_uplinkProtCmd));
-
       ret = IPC_NO_REPLY;
 
       rc = ptin_msg_uplink_protection_cmd(ptr, n);
 
       if (L7_SUCCESS != rc)
       {
@@ -617,17 +620,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
   #endif
 
     /* Sync MGMD open ports between different cards/interfaces*/
     case CCMSG_MGMD_PORT_SYNC:
     {
+      msg_HwMgmdPortSync *ptr;
+
       PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MGMD_PORT_SYNC (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwMgmdPortSync);
 
-      msg_HwMgmdPortSync *ptr;
       ptr = (msg_HwMgmdPortSync *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwMgmdPortSync));
 
       /* Execute command */
       rc = ptin_msg_mgmd_sync_ports(ptr);
@@ -693,18 +697,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_DEFAULTS_RESET */
     }
 
     /* CCMSG_MULTICAST_MACHINE_RESET *******************************************/
     case CCMSG_MULTICAST_MACHINE_RESET:
     {
+      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MULTICAST_MACHINE_RESET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwGenReq_t);
 
-      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
-
       /* Reset multicast machine */
       rc = ptin_msg_multicast_reset(ptr);
 
       /* Error? */
       if (L7_SUCCESS != rc)
       {
@@ -718,18 +722,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_DEFAULTS_RESET */
     }
 
     /* CCMSG_TYPEB_PROT_SWITCH *******************************************/
     case CCMSG_TYPEB_PROT_SWITCH_NOTIFY:
     {
+      msg_HwTypeBProtSwitchNotify_t *ptr = (msg_HwTypeBProtSwitchNotify_t *) &inbuffer->info[0];
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_TYPEB_PROT_SWITCH_NOTIFY (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwTypeBProtSwitchNotify_t);
 
-      msg_HwTypeBProtSwitchNotify_t *ptr = (msg_HwTypeBProtSwitchNotify_t *) &inbuffer->info[0];
-
       /* TYPE B Protection Switching */
       rc = ptin_msg_typeBprotIntfSwitchNotify(ptr);
 
       /* Error? */
       if (L7_SUCCESS != rc)
       {
@@ -742,18 +746,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
       break;  /* CCMSG_DEFAULTS_RESET */
     }
 
     case CCMSG_TYPEB_PROT_INTF_CONFIG:
     {
+      msg_HwTypeBProtIntfConfig_t *ptr = (msg_HwTypeBProtIntfConfig_t *) &inbuffer->info[0];
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_TYPEB_PROT_INTF_CONFIG (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwTypeBProtIntfConfig_t);
 
-      msg_HwTypeBProtIntfConfig_t *ptr = (msg_HwTypeBProtIntfConfig_t *) &inbuffer->info[0];
-
       /* TYPE B Protection Switching */
       rc = ptin_msg_typeBprotIntfConfig(ptr);
 
       /* Error? */
       if (L7_SUCCESS != rc)
       {
@@ -766,18 +770,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
       break;  /* CCMSG_DEFAULTS_RESET */
     }
 
     case CCMSG_TYPEB_PROT_SWITCH:
     {
+      msg_HwTypeBprot_t *ptr = (msg_HwTypeBprot_t *) &inbuffer->info[0];
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_TYPEB_PROT_SWITCH (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwTypeBprot_t);
 
-      msg_HwTypeBprot_t *ptr = (msg_HwTypeBprot_t *) &inbuffer->info[0];
-
       /* TYPE B Protection Switching */
       rc = ptin_msg_typeBprotSwitch(ptr);
 
       /* Error? */
       if (L7_SUCCESS != rc)
       {
@@ -790,18 +794,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
       break;  /* CCMSG_DEFAULTS_RESET */
     }
 
     case CCMSG_HW_BOARD_ACTION:
     {
+      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_HW_BOARD_ACTION (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwGenReq_t);
 
-      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
-
       /* Hwardware procedure */
       rc = ptin_msg_board_action(ptr);
 
       /* Error? */
       if (L7_SUCCESS != rc)
       {
@@ -814,18 +818,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
       break;  /* CCMSG_HW_BOARD_ACTION */
     }
 
     case CCMSG_HW_LINK_ACTION:
     {
+      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_HW_LINK_ACTION (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwGenReq_t);
 
-      msg_HwGenReq_t *ptr = (msg_HwGenReq_t *) &inbuffer->info[0];
-
       /* Hwardware procedure */
       rc = ptin_msg_link_action(ptr);
 
       /* Error? */
       if (L7_SUCCESS != rc)
       {
@@ -1015,16 +1019,17 @@ int CHMessageHandler (ipc_msg *inbuffer,
     /************************************************************************** 
      * SLOT MODE CONFIGURATION
      **************************************************************************/
 
     case CCMSG_SLOT_MAP_MODE_GET:
     {
+      msg_slotModeCfg_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SLOT_MAP_MODE_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_ATLEAST(L7_uint32);
-      msg_slotModeCfg_t *ptr;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_slotModeCfg_t));
       ptr = (msg_slotModeCfg_t *) outbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_slotMode_get(ptr);
@@ -1040,18 +1045,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPC_INFODIM(sizeof(msg_slotModeCfg_t));
     }
     break;
 
     case CCMSG_SLOT_MAP_MODE_VALIDATE:
     {
+      msg_slotModeCfg_t *ptr = (msg_slotModeCfg_t *) inbuffer->info;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SLOT_MAP_MODE_VALIDATE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_slotModeCfg_t);
 
-      msg_slotModeCfg_t *ptr = (msg_slotModeCfg_t *) inbuffer->info;
-
       /* Execute command */
       rc = ptin_msg_slotMode_validate(ptr);
 
       if (L7_SUCCESS != rc)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
@@ -1086,16 +1091,16 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
     }
     break;
 
     case CCMSG_SWITCH_TEMPERATURE_GET:
     {
-      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SWITCH_TEMPERATURE_GET (0x%04X)", msgId);
-
       msg_ptin_temperature_monitor_t *ptr;
 
+      PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "Message received: CCMSG_SWITCH_TEMPERATURE_GET (0x%04X)", msgId);
+
       ptr = (msg_ptin_temperature_monitor_t *) outbuffer->info;
       memset(ptr, 0x00, sizeof(msg_ptin_temperature_monitor_t));
 
       /* Execute command */
       rc = ptin_msg_switch_temperature_get(ptr);
 
@@ -1135,87 +1140,90 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
     }
     break;
 
     case CCMSG_ETH_PHY_STATUS_GET:
     {
+      msg_HWEthPhyStatus_t *pin = (msg_HWEthPhyStatus_t *) inbuffer->info;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_STATUS_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_ATLEAST(L7_uint32);
 
-      msg_HWEthPhyStatus_t *pin     = (msg_HWEthPhyStatus_t *) inbuffer->info;
-
       #if (PTIN_SYSTEM_N_PONS > 0 || PTIN_SYSTEM_N_ETH > 0)
-      L7_uint i;
-      msg_HWEthPhyStatus_t *pout    = (msg_HWEthPhyStatus_t *) outbuffer->info;
-
-      /* Output info read */
-      PT_LOG_DEBUG(LOG_CTX_MSG, "Requesting...");
-      PT_LOG_DEBUG(LOG_CTX_MSG, " SlotId    = %u", ENDIAN_SWAP8(pin->SlotId));
-      PT_LOG_DEBUG(LOG_CTX_MSG, " BoardType = %u", ENDIAN_SWAP8(pin->BoardType));
-      PT_LOG_DEBUG(LOG_CTX_MSG, " PortId    = %u", ENDIAN_SWAP8(pin->Port));
-
-      /* Single port ? */
-      if (ENDIAN_SWAP8(pin->Port) < max(PTIN_SYSTEM_N_PONS, PTIN_SYSTEM_N_ETH))
       {
-        memcpy(pout, pin, sizeof(msg_HWEthPhyStatus_t));
+        L7_uint i;
+        msg_HWEthPhyStatus_t *pout    = (msg_HWEthPhyStatus_t *) outbuffer->info;
 
-        if (ptin_msg_PhyStatus_get(pout) != L7_SUCCESS)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port status (port# %u)", ENDIAN_SWAP8(pin->Port));
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-          SetIPCNACK(outbuffer, res);
-          break;
-        }
+        /* Output info read */
+        PT_LOG_DEBUG(LOG_CTX_MSG, "Requesting...");
+        PT_LOG_DEBUG(LOG_CTX_MSG, " SlotId    = %u", ENDIAN_SWAP8(pin->SlotId));
+        PT_LOG_DEBUG(LOG_CTX_MSG, " BoardType = %u", ENDIAN_SWAP8(pin->BoardType));
+        PT_LOG_DEBUG(LOG_CTX_MSG, " PortId    = %u", ENDIAN_SWAP8(pin->Port));
 
-        SETIPC_INFODIM(sizeof(msg_HWEthPhyStatus_t));
-      }
-      /* Swipe all ports */
-      else
-      {
-        for (i = 0; i < PTIN_SYSTEM_N_ETH; i++)
+        /* Single port ? */
+        if (ENDIAN_SWAP8(pin->Port) < max(PTIN_SYSTEM_N_PONS, PTIN_SYSTEM_N_ETH))
         {
-          memcpy(&pout[i], pin, sizeof(msg_HWEthPhyStatus_t));
-          pout[i].Port = ENDIAN_SWAP8(i);
+          memcpy(pout, pin, sizeof(msg_HWEthPhyStatus_t));
 
-          if (ptin_msg_PhyStatus_get(&pout[i]) != L7_SUCCESS)
+          if (ptin_msg_PhyStatus_get(pout) != L7_SUCCESS)
+          {
+            PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port status (port# %u)", ENDIAN_SWAP8(pin->Port));
+            res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+            SetIPCNACK(outbuffer, res);
             break;
-        }
+          }
 
-        /* Error? */
-        if (i < PTIN_SYSTEM_N_ETH)
-        {
-          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port Status (port# %u)", ENDIAN_SWAP8(pin->Port));
-          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-          SetIPCNACK(outbuffer, res);
-          break;
+          SETIPC_INFODIM(sizeof(msg_HWEthPhyStatus_t));
         }
+        /* Swipe all ports */
+        else
+        {
+          for (i = 0; i < PTIN_SYSTEM_N_ETH; i++)
+          {
+            memcpy(&pout[i], pin, sizeof(msg_HWEthPhyStatus_t));
+            pout[i].Port = ENDIAN_SWAP8(i);
+
+            if (ptin_msg_PhyStatus_get(&pout[i]) != L7_SUCCESS)
+              break;
+          }
+
+          /* Error? */
+          if (i < PTIN_SYSTEM_N_ETH)
+          {
+            PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port Status (port# %u)", ENDIAN_SWAP8(pin->Port));
+            res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+            SetIPCNACK(outbuffer, res);
+            break;
+          }
 
-        SETIPC_INFODIM(sizeof(msg_HWEthPhyStatus_t) * i);
+          SETIPC_INFODIM(sizeof(msg_HWEthPhyStatus_t) * i);
+        }
       }
       #else
-      PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port Status (port# %u)", ENDIAN_SWAP8(pin->Port));
-      res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
-      SetIPCNACK(outbuffer, res);
-      break;
+      {
+        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting port Status (port# %u)", ENDIAN_SWAP8(pin->Port));
+        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
+        SetIPCNACK(outbuffer, res);
+        break;
+      }
       #endif
 
-
       break;  /* CCMSG_ETH_PHY_STATUS_GET */
     }
 
     /* CCMSG_ETH_PHY_CONFIG_SET ***********************************************/
     case CCMSG_ETH_PHY_CONFIG_SET:
     {
+      L7_uint i, n;
+      msg_HWEthPhyConf_t *pi = (msg_HWEthPhyConf_t *) &inbuffer->info[0];
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_CONFIG_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_HWEthPhyConf_t);
 
-      L7_uint i, n;
-      msg_HWEthPhyConf_t *pi = (msg_HWEthPhyConf_t *) &inbuffer->info[0];
-
       /* Validate info size */
       if ( (infoDim < sizeof(msg_HWEthPhyConf_t)) || ((infoDim % sizeof(msg_HWEthPhyConf_t)) != 0) )
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Data size inconsistent! (%u)", infoDim);
         res = SIR_ERROR(ERROR_FAMILY_IPC, ERROR_SEVERITY_ERROR, ERROR_CODE_WRONGSIZE);
         SetIPCNACK(outbuffer, res);
@@ -1245,21 +1253,21 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_PHY_CONFIG_GET ***********************************************/
     case CCMSG_ETH_PHY_CONFIG_GET:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_CONFIG_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwGenReq_t);
-
       L7_uint i;
       msg_HwGenReq_t     *req  = (msg_HwGenReq_t *) &inbuffer->info[0];
       msg_HWEthPhyConf_t *pout = (msg_HWEthPhyConf_t *) &outbuffer->info[0];
       msg_HWEthPhyConf_t  pin[1];
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_CONFIG_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwGenReq_t);
+
       /* Reference structure */
       memset(pin,0x00,sizeof(msg_HWEthPhyConf_t));
       pin->SlotId = req->slot_id;
       pin->Port   = req->generic_id;
       pin->Mask   = ENDIAN_SWAP16(0xffff);
 
@@ -1307,21 +1315,21 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_PHY_STATE_GET ************************************************/
     case CCMSG_ETH_PHY_STATE_GET:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_STATE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_HwGenReq_t);
-
       L7_uint i;
       msg_HwGenReq_t      *request = (msg_HwGenReq_t *) inbuffer->info;
       msg_HWEthPhyState_t *pout    = (msg_HWEthPhyState_t *) outbuffer->info;
       msg_HWEthPhyState_t  pin[1];
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_STATE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_HwGenReq_t);
+
       /* Reference structure */
       memset(pin,0x00,sizeof(msg_HWEthPhyState_t));
       pin->SlotId = request->slot_id;
       pin->Port   = request->generic_id;
       pin->Mask   = ENDIAN_SWAP16(0xffff);
 
@@ -1372,20 +1380,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * PHY COUNTERS Processing
      **************************************************************************/
 
     /* CCMSG_ETH_PHY_COUNTERS_GET *********************************************/
     case CCMSG_ETH_PHY_COUNTERS_GET:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_COUNTERS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_HwGenReq_t);
-
       msg_HwGenReq_t                    *request;
       msg_HWEthRFC2819_PortStatistics_t *portStats;
       L7_uint nElems = MSG_N_ELEMS(sizeof(msg_HwGenReq_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_COUNTERS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_HwGenReq_t);
+
       request   = (msg_HwGenReq_t *) inbuffer->info;
       portStats = (msg_HWEthRFC2819_PortStatistics_t *) outbuffer->info;
 
       /* Get values */
       if (L7_SUCCESS != ptin_msg_PhyCounters_read(request, portStats, nElems))
       {
@@ -1400,17 +1408,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_PHY_COUNTERS_CLEAR *******************************************/
     case CCMSG_ETH_PHY_COUNTERS_CLEAR:
     {
+      msg_HWEthRFC2819_PortStatistics_t *portStats;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PHY_COUNTERS_CLEAR (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HWEthRFC2819_PortStatistics_t);
 
-      msg_HWEthRFC2819_PortStatistics_t *portStats;
       portStats = (msg_HWEthRFC2819_PortStatistics_t *) inbuffer->info;
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_PhyCounters_clear(portStats))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing counters (port# %u)", ENDIAN_SWAP8(portStats->Port));
@@ -1427,19 +1436,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * Port Type Settings
      **************************************************************************/
 
     /* Set Port type (MEF extension) configuration */
     case CCMSG_ETH_PORT_EXT_SET:
     {
+      msg_HWPortExt_t *ptr = (msg_HWPortExt_t *) inbuffer->info;
+      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_HWPortExt_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_EXT_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_HWPortExt_t);
 
-      msg_HWPortExt_t *ptr = (msg_HWPortExt_t *) inbuffer->info;
-      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_HWPortExt_t));
-
       /* Execute command */
       rc = ptin_msg_portExt_set(ptr, nElems);
 
       if (L7_SUCCESS != rc)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
@@ -1452,19 +1461,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get Port type (MEF extension) configuration */
     case CCMSG_ETH_PORT_EXT_GET:
     {
+      msg_HWPortExt_t *ptr;
+      L7_uint          nElems;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_TYPE_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HWPortExt_t);
 
-      msg_HWPortExt_t *ptr;
-      L7_uint          nElems;
-
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HWPortExt_t));
       ptr = (msg_HWPortExt_t *) outbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_portExt_get(ptr,&nElems);
 
@@ -1480,19 +1489,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Set MAC address */
     case CCMSG_ETH_PORT_MAC_SET:
     {
+      msg_HWPortMac_t *ptr = (msg_HWPortMac_t *) inbuffer->info;
+      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_HWPortMac_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_MAC_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_HWPortMac_t);
 
-      msg_HWPortMac_t *ptr = (msg_HWPortMac_t *) inbuffer->info;
-      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_HWPortMac_t));
-
       /* Execute command */
       rc = ptin_msg_portMAC_set(ptr, nElems);
 
       if (L7_SUCCESS != rc)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
@@ -1505,19 +1514,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get MAC address */
     case CCMSG_ETH_PORT_MAC_GET:
     {
+      msg_HWPortMac_t *ptr;
+      L7_uint          nElems;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_MAC_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HWPortMac_t);
 
-      msg_HWPortMac_t *ptr;
-      L7_uint          nElems;
-
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HWPortMac_t));
       ptr = (msg_HWPortMac_t *) outbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_portMAC_get(ptr, &nElems);
 
@@ -1537,17 +1546,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * QoS Processing
      **************************************************************************/
 
     /* Get CoS configuration */
     case CCMSG_ETH_PORT_COS_GET:
     {
+      msg_QoSConfiguration_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_QoSConfiguration_t);
 
-      msg_QoSConfiguration_t *ptr;
       ptr = (msg_QoSConfiguration_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_QoSConfiguration_t));
 
       /* Execute command */
       rc = ptin_msg_CoS_get(ptr);
@@ -1564,17 +1574,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Set new CoS configuration */
     case CCMSG_ETH_PORT_COS_SET:
     {
+      msg_QoSConfiguration_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_QoSConfiguration_t);
 
-      msg_QoSConfiguration_t *ptr;
       ptr = (msg_QoSConfiguration_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_CoS_set(ptr);
 
       if (L7_SUCCESS != rc)
@@ -1589,17 +1600,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get CoS configuration */
     case CCMSG_ETH_PORT_COS2_GET:
     {
+      msg_QoSConfiguration2_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS2_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_QoSConfiguration2_t);
 
-      msg_QoSConfiguration2_t *ptr;
       ptr = (msg_QoSConfiguration2_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_QoSConfiguration2_t));
 
       /* Execute command */
       rc = ptin_msg_CoS2_get(ptr);
@@ -1616,17 +1628,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Set new CoS configuration */
     case CCMSG_ETH_PORT_COS2_SET:
     {
+      msg_QoSConfiguration2_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS2_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_QoSConfiguration2_t);
 
-      msg_QoSConfiguration2_t *ptr;
       ptr = (msg_QoSConfiguration2_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_CoS2_set(ptr);
 
       if (L7_SUCCESS != rc)
@@ -1641,17 +1654,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get CoS configuration */
     case CCMSG_ETH_PORT_COS3_GET:
     {
+      msg_QoSConfiguration3_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS3_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_QoSConfiguration3_t);
 
-      msg_QoSConfiguration3_t *ptr;
       ptr = (msg_QoSConfiguration3_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_QoSConfiguration3_t));
 
       /* Execute command */
       rc = ptin_msg_CoS3_get(ptr);
@@ -1668,17 +1682,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Set new CoS configuration */
     case CCMSG_ETH_PORT_COS3_SET:
     {
+      msg_QoSConfiguration3_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PORT_COS3_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_QoSConfiguration3_t);
 
-      msg_QoSConfiguration3_t *ptr;
       ptr = (msg_QoSConfiguration3_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_CoS3_set(ptr);
 
       if (L7_SUCCESS != rc)
@@ -1697,20 +1712,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * LAGs Processing
      **************************************************************************/
 
     /* CCMSG_ETH_LACP_LAG_GET *************************************************/
     case CCMSG_ETH_LACP_LAG_GET:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_LACPLagInfo_t);
-
       msg_LACPLagInfo_t *request = (msg_LACPLagInfo_t *) inbuffer->info;
       msg_LACPLagInfo_t *lagInfo = (msg_LACPLagInfo_t *) outbuffer->info;
       L7_uint            nElems;
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_LACPLagInfo_t);
+
       memcpy(lagInfo, request, sizeof(msg_LACPLagInfo_t));
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_Lag_get(lagInfo, &nElems))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting LAGs info");
@@ -1725,17 +1740,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_LACP_LAG_ADD *************************************************/
     case CCMSG_ETH_LACP_LAG_ADD:
     {
+      msg_LACPLagInfo_t *lagInfo;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_LACPLagInfo_t);
 
-      msg_LACPLagInfo_t *lagInfo;
       lagInfo = (msg_LACPLagInfo_t *) inbuffer->info;
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_Lag_create(lagInfo))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while creating a LAG");
@@ -1750,17 +1766,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_LACP_LAG_REMOVE **********************************************/
     case CCMSG_ETH_LACP_LAG_REMOVE:
     {
+      msg_LACPLagInfo_t *lagInfo;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_LACPLagInfo_t);
 
-      msg_LACPLagInfo_t *lagInfo;
       lagInfo = (msg_LACPLagInfo_t *) inbuffer->info;
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_Lag_destroy(lagInfo))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while destroying a LAG");
@@ -1774,20 +1791,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_LACP_LAG_STATUS_GET ******************************************/
     case CCMSG_ETH_LACP_LAG_STATUS_GET:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_STATUS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_LACPLagStatus_t);
-
       msg_LACPLagStatus_t *request   = (msg_LACPLagStatus_t *) inbuffer->info;
       msg_LACPLagStatus_t *lagStatus = (msg_LACPLagStatus_t *) outbuffer->info;
       L7_uint              nElems=0;
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_LAG_STATUS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_LACPLagStatus_t);
+
       memcpy(lagStatus, request, sizeof(msg_LACPLagStatus_t));
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_LagStatus_get(lagStatus, &nElems))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting LAGs status");
@@ -1801,19 +1818,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_LACP_ADMINSTATE_SET ******************************************/
     case CCMSG_ETH_LACP_ADMINSTATE_SET:
     {
+      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_LACPAdminState_t));
+      msg_LACPAdminState_t *lagAdminState = (msg_LACPAdminState_t *) inbuffer->info;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_ADMINSTATE_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_LACPAdminState_t);
 
-      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_LACPAdminState_t));
-      msg_LACPAdminState_t *lagAdminState = (msg_LACPAdminState_t *) inbuffer->info;
-
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_LACPAdminState_set(lagAdminState, nElems))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting LACP admin state");
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, ERROR_CODE_INVALIDPARAM);
         SetIPCNACK(outbuffer, res);
@@ -1826,20 +1843,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_LACP_ADMINSTATE_GET ******************************************/
     case CCMSG_ETH_LACP_ADMINSTATE_GET:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_ADMINSTATE_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_LACPAdminState_t);
-
       L7_uint nElems;
       msg_LACPAdminState_t *request       = (msg_LACPAdminState_t *) inbuffer->info;
       msg_LACPAdminState_t *lagAdminState = (msg_LACPAdminState_t *) outbuffer->info;
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_ADMINSTATE_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_LACPAdminState_t);
+
       memcpy(lagAdminState, request, sizeof(msg_LACPAdminState_t));
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_LACPAdminState_get(lagAdminState, &nElems))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while getting LACP admin state");
@@ -1853,20 +1870,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_LACP_STATS_GET ***********************************************/
     case CCMSG_ETH_LACP_STATS_GET:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_STATS_GET (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_LACPStats_t);
-
       L7_uint nElems;
       msg_LACPStats_t  *request = (msg_LACPStats_t *) inbuffer->info;
       msg_LACPStats_t *lagStats = (msg_LACPStats_t *) outbuffer->info;
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_STATS_GET (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE(msg_LACPStats_t);
+
       /* Note: the index field provides the LAG nr (if out of range, all LAGs are returned) */
       memcpy(lagStats, request, sizeof(msg_LACPStats_t));
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_LACPStats_get(lagStats, &nElems))
       {
@@ -1881,17 +1898,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_LACP_STATS_CLEAR *********************************************/
     case CCMSG_ETH_LACP_STATS_CLEAR:
     {
+      msg_LACPStats_t *lagStats;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_LACP_STATS_CLEAR (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_LACPStats_t);
 
-      msg_LACPStats_t *lagStats;
       lagStats = (msg_LACPStats_t *) inbuffer->info;
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_LACPStats_clear(lagStats))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while clearing LACP stats");
@@ -1909,16 +1927,17 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * L2 Table Processing
      **************************************************************************/
 
     /* L2 Aging get */
     case CCMSG_ETH_SWITCH_CONFIG_GET:
     {
+      msg_switch_config_t *switch_config = (msg_switch_config_t *) &outbuffer->info[0];
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_SWITCH_CONFIG_GET (0x%04X)", msgId);
       CHECK_INFO_SIZE(msg_switch_config_t);
 
-      msg_switch_config_t *switch_config = (msg_switch_config_t *) &outbuffer->info[0];
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_switch_config_t));
 
       /* Execute command */
       rc = ptin_msg_l2_switch_config_get(switch_config);
 
       if (L7_SUCCESS != rc)
@@ -1933,17 +1952,17 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* L2 Aging set */
     case CCMSG_ETH_SWITCH_CONFIG_SET:
     {
+      msg_switch_config_t *switch_config = (msg_switch_config_t *) &inbuffer->info[0];
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_SWITCH_CONFIG_SET (0x%04X)", msgId);
       CHECK_INFO_SIZE(msg_switch_config_t);
 
-      msg_switch_config_t *switch_config = (msg_switch_config_t *) &inbuffer->info[0];
-
       /* Execute command */
       rc = ptin_msg_l2_switch_config_set(switch_config);
 
       if (L7_SUCCESS != rc)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
@@ -1957,16 +1976,17 @@ int CHMessageHandler (ipc_msg *inbuffer,
     break;
 
     /* Get L2 table */
     case CCMSG_ETH_MAC_TABLE_SHOW:
     case CCMSG_ETH_MAC_TABLE_SHOW2:
     {
+      msg_switch_mac_table_t *mac_table = (msg_switch_mac_table_t *) outbuffer->info;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_MAC_TABLE_SHOW (0x%04X)", msgId);
       CHECK_INFO_SIZE(msg_switch_mac_intro_t);
 
-      msg_switch_mac_table_t *mac_table = (msg_switch_mac_table_t *) outbuffer->info;
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_switch_mac_intro_t));
 
       /* Execute command */
       rc = ptin_msg_l2_macTable_get(mac_table, ((CCMSG_ETH_MAC_TABLE_SHOW == msgId) ? 1 : 2));
 
       if (L7_SUCCESS != rc)
@@ -1981,18 +2001,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Remove an entry of the L2 table */
     case CCMSG_ETH_MAC_ENTRY_REMOVE:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_MAC_ENTRY_REMOVE (0x%04X)", msgId);
-      CHECK_INFO_SIZE(msg_switch_mac_table_entry_t);
-
       msg_switch_mac_table_entry_t *mac_table = (msg_switch_mac_table_entry_t *) inbuffer->info;
       L7_uint32 n = MSG_N_ELEMS(sizeof(msg_switch_mac_table_entry_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_MAC_ENTRY_REMOVE (0x%04X)", msgId);
+      CHECK_INFO_SIZE(msg_switch_mac_table_entry_t);
+
       /* Execute command */
       rc = ptin_msg_l2_macTable_remove(mac_table, n);
 
       if (L7_SUCCESS != rc)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while removing MAC");
@@ -2005,18 +2025,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Add an entry to the L2 table */
     case CCMSG_ETH_MAC_ENTRY_ADD:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_MAC_ENTRY_ADD (0x%04X)", msgId);
-      CHECK_INFO_SIZE(msg_switch_mac_table_entry_t);
-
       msg_switch_mac_table_entry_t *mac_table = (msg_switch_mac_table_entry_t *) inbuffer->info;
       L7_uint32 n = MSG_N_ELEMS(sizeof(msg_switch_mac_table_entry_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_MAC_ENTRY_ADD (0x%04X)", msgId);
+      CHECK_INFO_SIZE(msg_switch_mac_table_entry_t);
+
       /* Execute command */
       rc = ptin_msg_l2_macTable_add(mac_table, n);
 
       if (L7_SUCCESS != rc)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while adding MAC");
@@ -2032,17 +2052,17 @@ int CHMessageHandler (ipc_msg *inbuffer,
     /************************************************************************** 
      * Dynamic ARP Inspection
      **************************************************************************/
     /* Dynamic ARP Inspection */
     case CCMSG_ETH_DAI_GLOBAL_CONFIG:
     {
+      msg_dai_global_settings_t *config = (msg_dai_global_settings_t *) &inbuffer->info[0];
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_GLOBAL_CONFIG (0x%04X)", msgId);
       CHECK_INFO_SIZE(msg_dai_global_settings_t);
 
-      msg_dai_global_settings_t *config = (msg_dai_global_settings_t *) &inbuffer->info[0];
-
       /* Execute command */
       rc = ptin_msg_dai_global_config(config);
 
       if (L7_SUCCESS != rc)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
@@ -2054,18 +2074,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
     }
     break;
 
     case CCMSG_ETH_DAI_INTF_CONFIG:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_INTF_CONFIG (0x%04X)", msgId);
-      CHECK_INFO_SIZE_MOD(msg_dai_intf_settings_t);
-
       msg_dai_intf_settings_t *config = (msg_dai_intf_settings_t *) &inbuffer->info[0];
       L7_uint nElems = MSG_N_ELEMS(sizeof(msg_dai_intf_settings_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_INTF_CONFIG (0x%04X)", msgId);
+      CHECK_INFO_SIZE_MOD(msg_dai_intf_settings_t);
+
       /* Execute command */
       rc = ptin_msg_dai_intf_config(config, nElems);
 
       if (L7_SUCCESS != rc)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
@@ -2077,18 +2097,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
     }
     break;
 
     case CCMSG_ETH_DAI_VLAN_CONFIG:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_VLAN_CONFIG (0x%04X)", msgId);
-      CHECK_INFO_SIZE_MOD(msg_dai_vlan_settings_t);
-
       msg_dai_vlan_settings_t *config = (msg_dai_vlan_settings_t *) &inbuffer->info[0];
       L7_uint nElems = MSG_N_ELEMS(sizeof(msg_dai_vlan_settings_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_VLAN_CONFIG (0x%04X)", msgId);
+      CHECK_INFO_SIZE_MOD(msg_dai_vlan_settings_t);
+
       /* Execute command */
       rc = ptin_msg_dai_vlan_config(config, nElems);
 
       if (L7_SUCCESS != rc)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
@@ -2100,21 +2120,21 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
     }
     break;
 
     case CCMSG_ETH_DAI_STATISTICS:
     {
+      msg_dai_statistics_t *stats = (msg_dai_statistics_t *) &outbuffer->info[0];
+      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_dai_statistics_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DAI_STATISTICS (0x%04X)", msgId);
       CHECK_INFO_SIZE_MOD(msg_dai_statistics_t);
 
       /* Copy input to output */
       memcpy(outbuffer->info, inbuffer->info, infoDim);
 
-      msg_dai_statistics_t *stats = (msg_dai_statistics_t *) &outbuffer->info[0];
-      L7_uint nElems = MSG_N_ELEMS(sizeof(msg_dai_statistics_t));
-
       /* Execute command */
       rc = ptin_msg_dai_stats_get(stats, nElems);
 
       if (L7_SUCCESS != rc)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting config");
@@ -2131,17 +2151,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * EVCs Processing
      **************************************************************************/
 
     /* CCMSG_ETH_EVC_GET ******************************************************/
     case CCMSG_ETH_EVC_GET:
     {
+      msg_HwEthMef10Evc_t *evcConf;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_GET (0x%04X)", msgId);
   
       CHECK_INFO_SIZE(msg_HwEthMef10Evc_t);
 
-      msg_HwEthMef10Evc_t *evcConf;
       evcConf = (msg_HwEthMef10Evc_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwEthMef10Evc_t));
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_EVC_get(evcConf))
@@ -2180,19 +2201,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_EVC_ADD */
     }
 
     /* CCMSG_ETH_EVC_REMOVE ***************************************************/
     case CCMSG_ETH_EVC_REMOVE:
     {
+      msg_HwEthMef10EvcRemove_t *evcConf = (msg_HwEthMef10EvcRemove_t *) inbuffer->info;
+      L7_uint16 n_structs = MSG_N_ELEMS(sizeof(msg_HwEthMef10EvcRemove_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_HwEthMef10EvcRemove_t);
 
-      msg_HwEthMef10EvcRemove_t *evcConf = (msg_HwEthMef10EvcRemove_t *) inbuffer->info;
-      L7_uint16 n_structs = MSG_N_ELEMS(sizeof(msg_HwEthMef10EvcRemove_t));
-
       /* Execute command */
       rc = ptin_msg_EVC_delete(evcConf, n_structs);
 
       if (L7_SUCCESS != rc)
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while deleting EVCs");
@@ -2206,19 +2227,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_EVC_REMOVE */
     }
 
     /* CCMSG_ETH_EVC_PORT_ADD ******************************************************/
     case CCMSG_ETH_EVC_PORT_ADD:
     {
+      msg_HWevcPort_t *evcPort = (msg_HWevcPort_t *) inbuffer->info;
+      L7_uint16        n_size  = MSG_N_ELEMS(sizeof(msg_HWevcPort_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_PORT_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_HWevcPort_t);
 
-      msg_HWevcPort_t *evcPort = (msg_HWevcPort_t *) inbuffer->info;
-      L7_uint16        n_size  = MSG_N_ELEMS(sizeof(msg_HWevcPort_t));
-
       /* Execute command */
       rc = ptin_msg_evc_port(evcPort, n_size, PTIN_MSG_OPER_ADD);
 
       if (L7_SUCCESS != rc)
       {       
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
@@ -2232,19 +2253,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_EVC_PORT_ADD */
     }
 
     /* CCMSG_ETH_EVC_PORT_REMOVE ***************************************************/
     case CCMSG_ETH_EVC_PORT_REMOVE:
     {
+      msg_HWevcPort_t *evcPort = (msg_HWevcPort_t *) inbuffer->info;
+      L7_uint16        n_size  = MSG_N_ELEMS(sizeof(msg_HWevcPort_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_PORT_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_HWevcPort_t);
 
-      msg_HWevcPort_t *evcPort = (msg_HWevcPort_t *) inbuffer->info;
-      L7_uint16        n_size  = MSG_N_ELEMS(sizeof(msg_HWevcPort_t));
-
       /* Execute command */
       rc = ptin_msg_evc_port(evcPort, n_size, PTIN_MSG_OPER_REMOVE);
 
       if (L7_SUCCESS != rc)
       {        
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
@@ -2301,17 +2322,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
 
       break;  /* CCMSG_ETH_EVC_QOS_SET */
 
     /* CCMSG_ETH_EVC_BRIDGE_ADD ***********************************************/
     case CCMSG_ETH_EVC_BRIDGE_ADD:
     {
+      msg_HwEthEvcBridge_t *evcBridge;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_BRIDGE_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthEvcBridge_t);
 
-      msg_HwEthEvcBridge_t *evcBridge;
       evcBridge = (msg_HwEthEvcBridge_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_EVCBridge_add(evcBridge);
 
       if (L7_SUCCESS != rc)
@@ -2328,17 +2350,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_EVC_BRIDGE_REMOVE ********************************************/
     case CCMSG_ETH_EVC_BRIDGE_REMOVE:
     {
+      msg_HwEthEvcBridge_t *evcBridge;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_BRIDGE_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthEvcBridge_t);
 
-      msg_HwEthEvcBridge_t *evcBridge;
       evcBridge = (msg_HwEthEvcBridge_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_EVCBridge_remove(evcBridge);
 
       if (L7_SUCCESS != rc)
@@ -2354,17 +2377,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_EVC_BRIDGE_REMOVE */
     }
 
     /* CCMSG_ETH_EVC_FLOW_ADD ***********************************************/
     case CCMSG_ETH_EVC_FLOW_ADD:
     {
+      msg_HwEthEvcFlow_t *evcFlow;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOW_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthEvcFlow_t);
 
-      msg_HwEthEvcFlow_t *evcFlow;
       evcFlow = (msg_HwEthEvcFlow_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_EVCFlow_add(evcFlow);
 
       if (L7_SUCCESS != rc)
@@ -2380,17 +2404,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_EVC_FLOW_ADD */
     }
 
     /* CCMSG_ETH_EVC_FLOW_REMOVE ********************************************/
     case CCMSG_ETH_EVC_FLOW_REMOVE:
     {
+      msg_HwEthEvcFlow_t *evcFlow;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOW_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthEvcFlow_t);
 
-      msg_HwEthEvcFlow_t *evcFlow;
       evcFlow = (msg_HwEthEvcFlow_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_EVCFlow_remove(evcFlow);
 
       if (L7_SUCCESS != rc)
@@ -2406,19 +2431,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_EVC_BRIDGE_REMOVE */
     }
 
     /* Add vlan to be flooded */
     case CCMSG_ETH_EVC_FLOOD_VLAN_ADD:
     {
+      msg_HwEthEvcFloodVlan_t *evcFlood;
+      L7_uint32 n_clients;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOOD_VLAN_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_HwEthEvcFloodVlan_t);
 
-      msg_HwEthEvcFloodVlan_t *evcFlood;
-      L7_uint32 n_clients;
-
       evcFlood  = (msg_HwEthEvcFloodVlan_t *) inbuffer->info;
       n_clients = MSG_N_ELEMS(sizeof(msg_HwEthEvcFloodVlan_t));
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_EvcFloodVlan_add(evcFlood, n_clients))
       {
@@ -2433,19 +2458,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_EVC_FLOOD_VLAN_ADD */
     }
 
     /* Remove vlan to be flooded */
     case CCMSG_ETH_EVC_FLOOD_VLAN_REMOVE:
     {
+      msg_HwEthEvcFloodVlan_t *evcFlood;
+      L7_uint32 n_clients;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_FLOOD_VLAN_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_HwEthEvcFloodVlan_t);
 
-      msg_HwEthEvcFloodVlan_t *evcFlood;
-      L7_uint32 n_clients;
-
       evcFlood  = (msg_HwEthEvcFloodVlan_t *) inbuffer->info;
       n_clients = MSG_N_ELEMS(sizeof(msg_HwEthEvcFloodVlan_t));
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_EvcFloodVlan_remove(evcFlood, n_clients))
       {
@@ -2464,17 +2489,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * EVCs Counters config
      **************************************************************************/
 
     /* CCMSG_ETH_EVC_COUNTERS_GET *********************************************/
     case CCMSG_ETH_EVC_COUNTERS_GET:
     {
+      msg_evcStats_t *evcstat_in, *evcstat_out;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_COUNTERS_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_evcStats_t);
 
-      msg_evcStats_t *evcstat_in, *evcstat_out;
       evcstat_in  = (msg_evcStats_t *) inbuffer->info;
       evcstat_out = (msg_evcStats_t *) outbuffer->info;
 
       memcpy(evcstat_out, evcstat_in, sizeof(msg_evcStats_t));
 
       /* Execute command */
@@ -2493,17 +2519,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_EVC_COUNTERS_ADD *********************************************/
     case CCMSG_ETH_EVC_COUNTERS_ADD:
     {
+      msg_evcStats_t *evc_stat;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_COUNTERS_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_evcStats_t);
 
-      msg_evcStats_t *evc_stat;
       evc_stat = (msg_evcStats_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_evcStats_set(evc_stat);
 
       if (L7_SUCCESS != rc)
@@ -2519,17 +2546,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_EVC_COUNTERS_ADD */
     }
 
     /* CCMSG_ETH_EVC_COUNTERS_REMOVE ******************************************/
     case CCMSG_ETH_EVC_COUNTERS_REMOVE:
     {
+      msg_evcStats_t *evc_stat;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_EVC_COUNTERS_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_evcStats_t);
 
-      msg_evcStats_t *evc_stat;
       evc_stat = (msg_evcStats_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_evcStats_delete(evc_stat);
 
       if (L7_SUCCESS != rc)
@@ -2550,17 +2578,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * Bandwidth profiles Config
      **************************************************************************/
 
     /* CCMSG_ETH_BW_PROFILE_GET ***********************************************/
     case CCMSG_ETH_BW_PROFILE_GET:
     {
+      msg_HwEthBwProfile_t *bwProfile_in, *bwProfile_out;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_BW_PROFILE_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthBwProfile_t);
 
-      msg_HwEthBwProfile_t *bwProfile_in, *bwProfile_out;
       bwProfile_in  = (msg_HwEthBwProfile_t *) inbuffer->info;
       bwProfile_out = (msg_HwEthBwProfile_t *) outbuffer->info;
 
       memcpy(bwProfile_out,bwProfile_in,sizeof(msg_HwEthBwProfile_t));
 
       /* Execute command */
@@ -2580,18 +2609,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
 
 
     /* CCMSG_ETH_BW_PROFILE_SET ***********************************************/
     case CCMSG_ETH_BW_PROFILE_SET:
     case CCMSG_ETH_BW_PROFILE_SET_II:
     {
+      msg_HwEthBwProfile_t *bwProfile;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_BW_PROFILE_SET (0x%04X)", msgId);
 
       if (CCMSG_ETH_BW_PROFILE_SET == msgId) CHECK_INFO_SIZE(msg_HwEthBwProfile_t)
       else                                   CHECK_INFO_SIZE(msg_HwEthBwProfile_II_t)
 
-      msg_HwEthBwProfile_t *bwProfile;
       bwProfile = (msg_HwEthBwProfile_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_bwProfile_set(bwProfile, msgId);
 
       if (L7_SUCCESS != rc)
@@ -2609,18 +2639,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
 
 
     /* CCMSG_ETH_BW_PROFILE_DELETE ********************************************/
     case CCMSG_ETH_BW_PROFILE_DELETE:
     case CCMSG_ETH_BW_PROFILE_DELETE_II:
     {
+      msg_HwEthBwProfile_t *bwProfile;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_BW_PROFILE_DELETE (0x%04X)", msgId);
 
       if (CCMSG_ETH_BW_PROFILE_DELETE == msgId) CHECK_INFO_SIZE(msg_HwEthBwProfile_t)
       else                                      CHECK_INFO_SIZE(msg_HwEthBwProfile_II_t)
 
-      msg_HwEthBwProfile_t *bwProfile;
       bwProfile = (msg_HwEthBwProfile_t *) inbuffer->info;
 
       rc = ptin_msg_bwProfile_delete(bwProfile, msgId);
 
       /* Execute command */
       if ( L7_SUCCESS != rc )
@@ -2636,17 +2667,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_BW_PROFILE_DELETE */
     }
 
     /* CCMSG_ETH_STORM_CONTROL_GET ***********************************************/
     case CCMSG_ETH_STORM_CONTROL_GET:
     {
+      msg_HwEthStormControl_t *stormControl_in, *stormControl_out;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthStormControl_t);
 
-      msg_HwEthStormControl_t *stormControl_in, *stormControl_out;
       stormControl_in  = (msg_HwEthStormControl_t *) inbuffer->info;
       stormControl_out = (msg_HwEthStormControl_t *) outbuffer->info;
 
       memcpy(stormControl_out, stormControl_in, sizeof(msg_HwEthStormControl_t));
 
       /* Execute command */
@@ -2662,17 +2694,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_STORM_CONTROL_GET */
     }
 
     /* CCMSG_ETH_STORM_CONTROL_SET ***********************************************/
     case CCMSG_ETH_STORM_CONTROL_SET:
     {
+      msg_HwEthStormControl_t *stormControl;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthStormControl_t);
 
-      msg_HwEthStormControl_t *stormControl;
       stormControl = (msg_HwEthStormControl_t *) inbuffer->info;
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_stormControl_set(stormControl))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting Storm Control profile");
@@ -2686,17 +2719,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_STORM_CONTROL_SET */
     }
 
     /* CCMSG_ETH_STORM_CONTROL_RESET *********************************************/
     case CCMSG_ETH_STORM_CONTROL_RESET:
     {
+      msg_HwEthStormControl_t *stormControl;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_RESET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthStormControl_t);
 
-      msg_HwEthStormControl_t *stormControl;
       stormControl = (msg_HwEthStormControl_t *) inbuffer->info;
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_stormControl_reset(stormControl))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while resetting Storm Control profile");
@@ -2710,17 +2744,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_STORM_CONTROL_RESET */
     }
 
     /* CCMSG_ETH_STORM_CONTROL_CLEAR ********************************************/
     case CCMSG_ETH_STORM_CONTROL_CLEAR:
     {
+      msg_HwEthStormControl_t *stormControl;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORM_CONTROL_CLEAR (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthStormControl_t);
 
-      msg_HwEthStormControl_t *stormControl;
       stormControl = (msg_HwEthStormControl_t *) inbuffer->info;
 
       rc = ptin_msg_stormControl_clear(stormControl);
 
       /* Execute command */
       if ( L7_SUCCESS != rc )
@@ -2736,17 +2771,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_BW_PROFILE_DELETE */
     }
 
     /* CCMSG_ETH_STORMCONTROL2_GET ***********************************************/
     case CCMSG_ETH_STORMCONTROL2_GET:
     {
+      msg_HwEthStormControl2_t *stormControl_in, *stormControl_out;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORMCONTROL2_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthStormControl2_t);
 
-      msg_HwEthStormControl2_t *stormControl_in, *stormControl_out;
       stormControl_in  = (msg_HwEthStormControl2_t *) inbuffer->info;
       stormControl_out = (msg_HwEthStormControl2_t *) outbuffer->info;
 
       memcpy(stormControl_out, stormControl_in, sizeof(msg_HwEthStormControl2_t));
 
       /* Execute command */
@@ -2762,17 +2798,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_STORMCONTROL2_GET */
     }
 
     /* CCMSG_ETH_STORMCONTROL2_SET ***********************************************/
     case CCMSG_ETH_STORMCONTROL2_SET:
     {
+      msg_HwEthStormControl2_t *stormControl;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_STORMCONTROL2_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthStormControl2_t);
 
-      msg_HwEthStormControl2_t *stormControl;
       stormControl = (msg_HwEthStormControl2_t *) inbuffer->info;
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_stormControl2_set(stormControl))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting StormControl2 profile");
@@ -2790,17 +2827,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * inBand Config
      **************************************************************************/
 
     /* CCMSG_ETH_NTW_CONNECTIVITY_GET *****************************************/
     case CCMSG_ETH_NTW_CONNECTIVITY_GET:
     {
+      msg_NtwConnectivity_t *ntwConn;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_NTW_CONNECTIVITY_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_NtwConnectivity_t);
 
-      msg_NtwConnectivity_t *ntwConn;
       ntwConn = (msg_NtwConnectivity_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_NtwConnectivity_t));
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_ntw_connectivity_get(ntwConn))
@@ -2815,17 +2853,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_NTW_CONNECTIVITY_GET */
     }
 
     /* CCMSG_ETH_NTW_CONNECTIVITY_SET *****************************************/
     case CCMSG_ETH_NTW_CONNECTIVITY_SET:
     {
+      msg_NtwConnectivity_t *ntwConn;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_NTW_CONNECTIVITY_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_NtwConnectivity_t);
 
-      msg_NtwConnectivity_t *ntwConn;
       ntwConn = (msg_NtwConnectivity_t *) inbuffer->info;
 
       /* Execute command */
       if (L7_SUCCESS != ptin_msg_ntw_connectivity_set(ntwConn))
       {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error while setting Network Connectivity config");
@@ -2843,17 +2882,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * DHCP Relay Agent
      **************************************************************************/
 
     /* Reconfigure Global DHCP EVC ****************************/
     case CCMSG_ETH_DHCP_EVC_RECONF:
     {
+      msg_DhcpEvcReconf_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_EVC_RECONF (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_DhcpEvcReconf_t);
 
-      msg_DhcpEvcReconf_t *ptr;
       ptr = (msg_DhcpEvcReconf_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_DhcpEvcReconf_t));
 
       /* Execute command */
       rc = ptin_msg_DHCP_evc_reconf(ptr);
@@ -2870,17 +2910,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Configure DHCP circuit-id global components ****************************/
     case CCMSG_ETH_DHCP_EVC_CIRCUITID_SET:
     {
+      msg_AccessNodeCircuitId_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_EVC_CIRCUITID_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_AccessNodeCircuitId_t);
 
-      msg_AccessNodeCircuitId_t *ptr;
       ptr = (msg_AccessNodeCircuitId_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_AccessNodeCircuitId_t));
 
       /* Execute command */
       rc = ptin_msg_DHCP_circuitid_set(ptr);
@@ -2897,17 +2938,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get DHCP profile data **************************************************/
     case CCMSG_ETH_DHCP_EVC_CIRCUITID_GET:
     {
+      msg_AccessNodeCircuitId_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_AccessNodeCircuitId_t);
 
-      msg_AccessNodeCircuitId_t *ptr;
       ptr = (msg_AccessNodeCircuitId_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_AccessNodeCircuitId_t));
 
       /* Execute command */
       rc = ptin_msg_DHCP_circuitid_get(ptr);
@@ -2924,17 +2966,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get DHCP profile data **************************************************/
     case CCMSG_ETH_DHCP_PROFILE_GET:
     {
+      msg_HwEthernetDhcpOpt82Profile_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_HwEthernetDhcpOpt82Profile_t);
 
-      msg_HwEthernetDhcpOpt82Profile_t *ptr;
       ptr = (msg_HwEthernetDhcpOpt82Profile_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_HwEthernetDhcpOpt82Profile_t));
 
       /* Execute command */
       rc = ptin_msg_DHCP_profile_get(ptr);
@@ -2951,19 +2994,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Add a new DHCP profile **************************************************/
     case CCMSG_ETH_DHCP_PROFILE_ADD:
     {
+      msg_HwEthernetDhcpOpt82Profile_t *ptr;
+      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_HwEthernetDhcpOpt82Profile_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_HwEthernetDhcpOpt82Profile_t);
 
-      msg_HwEthernetDhcpOpt82Profile_t *ptr;
       ptr = (msg_HwEthernetDhcpOpt82Profile_t *) inbuffer->info;
-      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_HwEthernetDhcpOpt82Profile_t));
 
       /* Execute command */
       rc = ptin_msg_DHCP_profile_add(ptr, n_clients);
 
       if (L7_SUCCESS != rc)
       {
@@ -2977,19 +3021,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Remove a DHCP profile ****************************************************/
     case CCMSG_ETH_DHCP_PROFILE_REMOVE:
     {
+      msg_HwEthernetDhcpOpt82Profile_t *ptr;
+      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_HwEthernetDhcpOpt82Profile_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_PROFILE_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_HwEthernetDhcpOpt82Profile_t);
 
-      msg_HwEthernetDhcpOpt82Profile_t *ptr;
       ptr = (msg_HwEthernetDhcpOpt82Profile_t *) inbuffer->info;
-      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_HwEthernetDhcpOpt82Profile_t));
 
       rc = ptin_msg_DHCP_profile_remove(ptr, n_clients);
 
       /* Execute command */
       if (L7_SUCCESS != rc)
       {
@@ -3003,17 +3048,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get client DHCP statistics */
     case CCMSG_ETH_DHCP_CLIENT_STATS_GET:
     {
+      msg_DhcpClientStatistics_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_CLIENT_STATS_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
 
-      msg_DhcpClientStatistics_t *ptr;
       ptr = (msg_DhcpClientStatistics_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_DhcpClientStatistics_t));
 
       /* Execute command */
       rc = ptin_msg_DHCP_clientStats_get(ptr);
@@ -3030,17 +3076,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Clear client DHCP statistics */
     case CCMSG_ETH_DHCP_CLIENT_STATS_CLEAR:
     {
+      msg_DhcpClientStatistics_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_CLIENT_STATS_CLEAR (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
 
-      msg_DhcpClientStatistics_t *ptr;
       ptr = (msg_DhcpClientStatistics_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_DHCP_clientStats_clear(ptr);
 
       if (L7_SUCCESS != rc)
@@ -3055,17 +3102,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get interface DHCP statistics */
     case CCMSG_ETH_DHCP_INTF_STATS_GET:
     {
+      msg_DhcpClientStatistics_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_INTF_STATS_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
 
-      msg_DhcpClientStatistics_t *ptr;
       ptr = (msg_DhcpClientStatistics_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_DhcpClientStatistics_t));
 
       /* Execute command */
       rc = ptin_msg_DHCP_intfStats_get(ptr);
@@ -3082,17 +3130,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Clear interface DHCP statistics */
     case CCMSG_ETH_DHCP_INTF_STATS_CLEAR:
     {
+      msg_DhcpClientStatistics_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_INTF_STATS_CLEAR (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_DhcpClientStatistics_t);
 
-      msg_DhcpClientStatistics_t *ptr;
       ptr = (msg_DhcpClientStatistics_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_DHCP_intfStats_clear(ptr);
 
       if (L7_SUCCESS != rc)
@@ -3107,18 +3156,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get DHCP Bind Table */
     case CCMSG_ETH_DHCP_BIND_TABLE_GET:
     {
+      msg_DHCP_bind_table_request_t *pin;
+      msg_DHCPv4v6_bind_table_t     *pout;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_BIND_TABLE_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_DHCP_bind_table_request_t);
 
-      msg_DHCP_bind_table_request_t *pin;
-      msg_DHCPv4v6_bind_table_t     *pout;
       pin  = (msg_DHCP_bind_table_request_t*) inbuffer->info;
       pout = (msg_DHCPv4v6_bind_table_t *) outbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_DHCPv4v6_bindTable_get(pin, pout);
 
@@ -3134,19 +3184,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Remove a DHCP Bind Table entry */
     case CCMSG_ETH_DHCP_BIND_TABLE_REMOVE:
     {
+      msg_DHCP_bind_table_entry_t *bind_table;
+      L7_uint32 n = MSG_N_ELEMS(sizeof(msg_DHCP_bind_table_entry_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_DHCP_BIND_TABLE_CLEAR (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_DHCP_bind_table_entry_t);
 
-      msg_DHCP_bind_table_entry_t *bind_table;
       bind_table = (msg_DHCP_bind_table_entry_t *) inbuffer->info;
-      L7_uint32 n = MSG_N_ELEMS(sizeof(msg_DHCP_bind_table_entry_t));
 
       /* Execute command */
       rc = ptin_msg_DHCP_bindTable_remove(bind_table, n);
 
       if (L7_SUCCESS != rc)
       {
@@ -3162,17 +3213,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     /************************************************************************** 
     *                     IP Source Guard
     **************************************************************************/
    
     case CCMSG_ETH_IPSG_ENABLE:
     {
+      msg_IPSG_set_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IPSG_ENABLE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_IPSG_set_t);
 
-      msg_IPSG_set_t *ptr;
       ptr = (msg_IPSG_set_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_ipsg_verify_source_set(ptr);
 
       if (L7_SUCCESS != rc)
@@ -3186,18 +3238,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
 
       break; 
     }
     case CCMSG_ETH_IPSG_STATIC_ENTRY:
     {
+      L7_uint16 n_msg;
+      msg_IPSG_static_entry_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IPSG_VERIFY_SOURCE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_IPSG_static_entry_t);
 
-      L7_uint16 n_msg;
-      msg_IPSG_static_entry_t *ptr;
       ptr = (msg_IPSG_static_entry_t *) inbuffer->info;
       n_msg = MSG_N_ELEMS(sizeof(msg_IPSG_static_entry_t));
 
       /* Execute command */
       rc = ptin_msg_ipsg_static_entry_set(ptr, n_msg);
 
@@ -3218,17 +3271,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * IGMP Admission Control Config
      **************************************************************************/
 
     /* CCMSG_ETH_IGMP_ADMISSION_CONTROL ***********************************************/
     case CCMSG_ETH_IGMP_ADMISSION_CONTROL:
     {
+      msg_IgmpAdmissionControl_t *igmpAdmissionControl;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_ADMISSION_CONTROL (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_IgmpAdmissionControl_t);
 
-      msg_IgmpAdmissionControl_t *igmpAdmissionControl;
       igmpAdmissionControl = (msg_IgmpAdmissionControl_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpAdmissionControl_t));
 
       /* Execute command */
       rc = ptin_msg_igmp_admission_control_set(igmpAdmissionControl);
@@ -3250,17 +3304,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
      * IGMP Proxy Config
      **************************************************************************/
 
     /* CCMSG_ETH_IGMP_PROXY_SET ***********************************************/
     case CCMSG_ETH_IGMP_PROXY_SET:
     {
+      msg_IgmpProxyCfg_t *igmpProxy;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_PROXY_SET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_IgmpProxyCfg_t);
 
-      msg_IgmpProxyCfg_t *igmpProxy;
       igmpProxy = (msg_IgmpProxyCfg_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpProxyCfg_t));
 
       /* Execute command */
       rc = ptin_msg_igmp_proxy_set(igmpProxy);
@@ -3279,17 +3334,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_IGMP_PROXY_GET ***********************************************/
     case CCMSG_ETH_IGMP_PROXY_GET:
     {
+      msg_IgmpProxyCfg_t *igmpProxy;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_PROXY_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_IgmpProxyCfg_t);
 
-      msg_IgmpProxyCfg_t *igmpProxy;
       igmpProxy = (msg_IgmpProxyCfg_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_igmp_proxy_get(igmpProxy);
 
       if (L7_SUCCESS != rc)
@@ -3306,17 +3362,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_IGMP_ENTRY_ADD ***********************************************/
     case CCMSG_ETH_IGMP_ENTRY_ADD:
     {
+      msg_IgmpMultcastUnicastLink_t *igmpEntry;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_ENTRY_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_IgmpMultcastUnicastLink_t);
 
-      msg_IgmpMultcastUnicastLink_t *igmpEntry;
       igmpEntry = (msg_IgmpMultcastUnicastLink_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_igmp_instance_add(igmpEntry);
 
       if (L7_SUCCESS != rc)
@@ -3332,17 +3389,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_IGMP_ENTRY_ADD */
     }
 
     /* CCMSG_ETH_IGMP_ENTRY_REMOVE ********************************************/
     case CCMSG_ETH_IGMP_ENTRY_REMOVE:
     {
+      msg_IgmpMultcastUnicastLink_t *igmpEntry;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_ENTRY_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_IgmpMultcastUnicastLink_t);
 
-      msg_IgmpMultcastUnicastLink_t *igmpEntry;
       igmpEntry = (msg_IgmpMultcastUnicastLink_t *) inbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_igmp_instance_remove(igmpEntry);
 
       if (L7_SUCCESS != rc)
@@ -3358,19 +3416,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_IGMP_ENTRY_REMOVE */
     }
 
     /* CCMSG_ETH_IGMP_CLIENT_ADD **********************************************/
     case CCMSG_ETH_IGMP_CLIENT_ADD:
     {
+      msg_IgmpClient_t *igmpClient;
+      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClient_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_IgmpClient_t);
 
-      msg_IgmpClient_t *igmpClient;
       igmpClient = (msg_IgmpClient_t *) inbuffer->info;
-      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClient_t));
 
       /* Execute command */
       rc = ptin_msg_igmp_client_add(igmpClient, n_clients);
 
       if (L7_SUCCESS != rc)
       {       
@@ -3385,19 +3444,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_IGMP_CLIENT_ADD */
     }
 
     /* CCMSG_ETH_IGMP_CLIENT_REMOVE *******************************************/
     case CCMSG_ETH_IGMP_CLIENT_REMOVE:
     {
+      msg_IgmpClient_t *igmpClient;
+      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClient_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_IgmpClient_t);
 
-      msg_IgmpClient_t *igmpClient;
       igmpClient = (msg_IgmpClient_t *) inbuffer->info;
-      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClient_t));
 
       rc = ptin_msg_igmp_client_delete(igmpClient, n_clients);
 
       /* Execute command */
       if (L7_SUCCESS != rc)
       {        
@@ -3412,17 +3472,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_IGMP_CLIENT_REMOVE */
     }
 
     /* CCMSG_ETH_IGMP_CLIENT_STATS_GET ****************************************/
     case CCMSG_ETH_IGMP_CLIENT_STATS_GET:
     {
+      msg_IgmpClientStatistics_t *igmpClientStats;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_STATS_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
 
-      msg_IgmpClientStatistics_t *igmpClientStats;
       igmpClientStats = (msg_IgmpClientStatistics_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpClientStatistics_t));
 
       /* Execute command */
       rc = ptin_msg_IGMP_clientStats_get(igmpClientStats);
@@ -3441,19 +3502,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR **************************************/
     case CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR:
     {
+      msg_IgmpClientStatistics_t *igmpClient;
+      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClientStatistics_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
 
-      msg_IgmpClientStatistics_t *igmpClient;
       igmpClient = (msg_IgmpClientStatistics_t *) inbuffer->info;
-      L7_uint32 n_clients = MSG_N_ELEMS(sizeof(msg_IgmpClientStatistics_t));
 
       /* Execute command */
       rc = ptin_msg_IGMP_clientStats_clear(igmpClient, n_clients);
 
       if (L7_SUCCESS != rc)
       {        
@@ -3467,17 +3529,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_ETH_IGMP_CLIENT_STATS_CLEAR */
     }
 
     /* CCMSG_ETH_IGMP_INTF_STATS_GET ******************************************/
     case CCMSG_ETH_IGMP_INTF_STATS_GET:
     {
+      msg_IgmpClientStatistics_t *igmpPortStats;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_INTF_STATS_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
 
-      msg_IgmpClientStatistics_t *igmpPortStats;
       igmpPortStats = (msg_IgmpClientStatistics_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_IgmpClientStatistics_t));
 
       /* Execute command */
       rc = ptin_msg_IGMP_intfStats_get(igmpPortStats);
@@ -3495,19 +3558,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 
 
     /* CCMSG_ETH_IGMP_INTF_STATS_CLEAR ****************************************/
     case CCMSG_ETH_IGMP_INTF_STATS_CLEAR:
     {
+      msg_IgmpClientStatistics_t *igmpIntf;
+      L7_uint32 n_ports = MSG_N_ELEMS(sizeof(msg_IgmpClientStatistics_t));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_INTF_STATS_CLEAR (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_IgmpClientStatistics_t);
 
-      msg_IgmpClientStatistics_t *igmpIntf;
       igmpIntf = (msg_IgmpClientStatistics_t *) inbuffer->info;
-      L7_uint32 n_ports = MSG_N_ELEMS(sizeof(msg_IgmpClientStatistics_t));
 
       /* Execute command */
       rc = ptin_msg_IGMP_intfStats_clear(igmpIntf, n_ports);
 
       if (L7_SUCCESS != rc)
       {        
@@ -3521,19 +3585,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
 
       break;  /* CCMSG_ETH_IGMP_INTF_STATS_CLEAR */
     }
 
     case CCMSG_ETH_IGMP_CHANNEL_ASSOC_GET:
     {
+      msg_MCAssocChannel_t *ptr;
+      L7_uint16             n=0;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_GET (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_MCAssocChannel_t);
 
-      msg_MCAssocChannel_t *ptr;
-      L7_uint16             n=0;
-
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_MCAssocChannel_t));
       ptr = (msg_MCAssocChannel_t *) outbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_IGMP_ChannelAssoc_get(ptr, &n);
 
@@ -3548,19 +3612,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPC_INFODIM(sizeof(msg_MCAssocChannel_t) * n);
     }
     break;
 
     case CCMSG_ETH_IGMP_CHANNEL_ASSOC_ADD:
     {
+      msg_MCAssocChannel_t *ptr;
+      L7_uint16             n;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_MCAssocChannel_t);
 
-      msg_MCAssocChannel_t *ptr;
-      L7_uint16             n;
-
       ptr = (msg_MCAssocChannel_t *) inbuffer->info;
       n = MSG_N_ELEMS(sizeof(msg_MCAssocChannel_t));
 
       /* Execute command */
       rc  = ptin_msg_group_list_add(ptr, n, L7_FALSE);
 
@@ -3575,19 +3639,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
     }
     break;
 
     case CCMSG_ETH_IGMP_CHANNEL_ASSOC_REMOVE:
     {
+      msg_MCAssocChannel_t *ptr;
+      L7_uint16             n;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_MCAssocChannel_t);
 
-      msg_MCAssocChannel_t *ptr;
-      L7_uint16             n;
-
       ptr = (msg_MCAssocChannel_t *) inbuffer->info;
       n = MSG_N_ELEMS(sizeof(msg_MCAssocChannel_t));
 
       /* Execute command */
       rc  = ptin_msg_group_list_remove(ptr, n, L7_FALSE);
 
@@ -3602,19 +3666,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPCACKOK(outbuffer);
     }
     break;
 
     case CCMSG_ETH_IGMP_CHANNEL_BULK_DELETE:
     {
+      msg_MCAssocChannel_t *ptr;
+      L7_uint16             n;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_CHANNEL_ASSOC_REMALL (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_MCAssocChannel_t);
 
-      msg_MCAssocChannel_t *ptr;
-      L7_uint16             n;
-
       ptr = (msg_MCAssocChannel_t *) inbuffer->info;
       n = MSG_N_ELEMS(sizeof(msg_MCAssocChannel_t));
 
       /* Execute command */
       rc  = ptin_msg_IGMP_ChannelAssoc_remove_all(ptr, n);
 
@@ -3630,19 +3694,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Add static multicast channel */
     case CCMSG_ETH_IGMP_STATIC_GROUP_ADD:
     {
+      msg_MCStaticChannel_t *ptr;
+      L7_uint16             n;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_STATIC_GROUP_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_MCStaticChannel_t);
 
-      msg_MCStaticChannel_t *ptr;
-      L7_uint16             n;
-
       ptr = (msg_MCStaticChannel_t *) inbuffer->info;
       n = MSG_N_ELEMS(sizeof(msg_MCStaticChannel_t));
 
       /* Execute command */
       rc  = ptin_msg_static_channel_add(ptr, n);
 
@@ -3658,19 +3722,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Remove static multicast channel */
     case CCMSG_ETH_IGMP_STATIC_GROUP_REMOVE:
     {
+      msg_MCStaticChannel_t *ptr;
+      L7_uint16             n;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_STATIC_GROUP_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_MCStaticChannel_t);
 
-      msg_MCStaticChannel_t *ptr;
-      L7_uint16             n;
-
       ptr = (msg_MCStaticChannel_t *) inbuffer->info;
       n = MSG_N_ELEMS(sizeof(msg_MCStaticChannel_t));
 
       /* Execute command */
       rc = ptin_msg_static_channel_remove(ptr, n);
 
@@ -3718,24 +3782,25 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get list of clients watching a multicast channel */
     case CCMSG_ETH_IGMP_CLIENT_GROUPS_GET:
     {      
+      msg_MCActiveChannelClientsResponse_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER,
                   "Message received: CCMSG_ETH_IGMP_CLIENT_GROUPS_GET (0x%04X) msgSize:%u bytes", msgId, infoDim);
 
       #if 1//To be changed to 0
       CHECK_INFO_SIZE_ATLEAST(msg_MCActiveChannelClientsRequest_t);
       #else
       CHECK_INFO_SIZE(msg_MCActiveChannelClientsRequest_t);
       #endif
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_MCActiveChannelClientsRequest_t));
 
-      msg_MCActiveChannelClientsResponse_t *ptr;
       ptr = (msg_MCActiveChannelClientsResponse_t *) outbuffer->info;
 
       /* Execute command */
       ptin_timer_start(41,"CCMSG_ETH_IGMP_CLIENT_GROUPS_GET");
       rc = ptin_msg_IGMP_clientList_get(ptr);
       ptin_timer_stop(41);
@@ -3752,19 +3817,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Remove static multicast channel */
     case CCMSG_ETH_IGMP_STATIC_GROUP_REMALL:
     {
+      msg_MCStaticChannel_t *ptr;
+      L7_uint16             n;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_IGMP_STATIC_GROUP_REMALL (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_MCStaticChannel_t);
 
-      msg_MCStaticChannel_t *ptr;
-      L7_uint16             n;
-
       ptr = (msg_MCStaticChannel_t *) inbuffer->info;
       n = MSG_N_ELEMS(sizeof(msg_MCStaticChannel_t));
 
       /* Execute command */
       rc = ptin_msg_igmp_static_channel_remove_all(ptr, n);
 
@@ -3828,17 +3893,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
     /***************************************************** 
      * Routing messages
      ****************************************************/
     /* CCMSG_ROUTING_INTF_CREATE ****************************************/
     case CCMSG_ROUTING_INTF_CREATE:
     {
+      msg_RoutingIntf *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_INTF_CREATE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_RoutingIntf);
 
-      msg_RoutingIntf *data;
       data = (msg_RoutingIntf *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingIntf));
 
       /* Execute command */
       rc = ptin_msg_routing_intf_create(data);
@@ -3855,17 +3921,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;
     }
 
     /* CCMSG_ROUTING_INTF_MODIFY ****************************************/
     case CCMSG_ROUTING_INTF_MODIFY:
     {
+      msg_RoutingIntf *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_INTF_MODIFY (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_RoutingIntf);
 
-      msg_RoutingIntf *data;
       data = (msg_RoutingIntf *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingIntf));
 
       /* Execute command */
       rc = ptin_msg_routing_intf_modify(data);
@@ -3882,17 +3949,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;
     }
 
     /* CCMSG_ROUTING_INTF_REMOVE ****************************************/
     case CCMSG_ROUTING_INTF_REMOVE:
     {
+      msg_RoutingIntf *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_INTF_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_RoutingIntf);
 
-      msg_RoutingIntf *data;
       data = (msg_RoutingIntf *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingIntf));
 
       /* Execute command */
       rc = ptin_msg_routing_intf_remove(data);
@@ -3938,17 +4006,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;    
     }
 
     /* CCMSG_ROUTING_ARPENTRY_PURGE ****************************************/
     case CCMSG_ROUTING_ARPENTRY_PURGE:
     {
+      msg_RoutingArpEntryPurge *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_ARPENTRY_PURGE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_RoutingArpEntryPurge);
 
-      msg_RoutingArpEntryPurge *data;
       data = (msg_RoutingArpEntryPurge *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingArpEntryPurge));
 
       /* Execute command */
       rc = ptin_msg_routing_arpentry_purge(data);
@@ -3997,17 +4066,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;    
     }
 
     /* CCMSG_ROUTING_STATICROUTE_ADD ****************************************/
     case CCMSG_ROUTING_STATICROUTE_ADD:
     {
+      msg_RoutingStaticRoute *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_STATICROUTE_ADD (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_RoutingStaticRoute);
 
-      msg_RoutingStaticRoute *data;
       data = (msg_RoutingStaticRoute *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingStaticRoute));
 
       /* Execute command */
       rc = ptin_msg_routing_staticroute_add(data);
@@ -4024,17 +4094,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;
     }
 
     /* CCMSG_ROUTING_STATICROUTE_DELETE ****************************************/
     case CCMSG_ROUTING_STATICROUTE_DELETE:
     {
+      msg_RoutingStaticRoute *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_STATICROUTE_DELETE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_RoutingStaticRoute);
 
-      msg_RoutingStaticRoute *data;
       data = (msg_RoutingStaticRoute *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingStaticRoute));
 
       /* Execute command */
       rc = ptin_msg_routing_staticroute_delete(data);
@@ -4051,17 +4122,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;
     }
 
     /* CCMSG_ROUTING_PINGSESSION_CREATE ****************************************/
     case CCMSG_ROUTING_PINGSESSION_CREATE:
     {
+      msg_RoutingPingSessionCreate *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_PINGSESSION_CREATE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_RoutingPingSessionCreate);
 
-      msg_RoutingPingSessionCreate *data;
       data = (msg_RoutingPingSessionCreate *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingPingSessionCreate));
 
       /* Execute command */
       rc = ptin_msg_routing_pingsession_create(data);
@@ -4078,17 +4150,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;
     }
 
     /* CCMSG_ROUTING_PINGSESSION_QUERY ****************************************/
     case CCMSG_ROUTING_PINGSESSION_QUERY:
     {
+      msg_RoutingPingSessionQuery *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_PINGSESSION_QUERY (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_RoutingPingSessionQuery);
 
-      msg_RoutingPingSessionQuery *data;
       data = (msg_RoutingPingSessionQuery *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingPingSessionQuery));
 
       /* Execute command */
       rc = ptin_msg_routing_pingsession_query(data);
@@ -4105,17 +4178,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;
     }
 
     /* CCMSG_ROUTING_PINGSESSION_FREE ****************************************/
     case CCMSG_ROUTING_PINGSESSION_FREE:
     {
+      msg_RoutingPingSessionFree *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_PINGSESSION_FREE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_RoutingPingSessionFree);
 
-      msg_RoutingPingSessionFree *data;
       data = (msg_RoutingPingSessionFree *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingPingSessionFree));
 
       /* Execute command */
       rc = ptin_msg_routing_pingsession_free(data);
@@ -4132,17 +4206,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;
     }
 
     /* CCMSG_ROUTING_TRACERTSESSION_CREATE ****************************************/
     case CCMSG_ROUTING_TRACERTSESSION_CREATE:
     {
+      msg_RoutingTracertSessionCreate *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_TRACERTSESSION_CREATE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_RoutingTracertSessionCreate);
 
-      msg_RoutingTracertSessionCreate *data;
       data = (msg_RoutingTracertSessionCreate *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingTracertSessionCreate));
 
       /* Execute command */
       rc = ptin_msg_routing_tracertsession_create(data);
@@ -4159,17 +4234,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;
     }
 
     /* CCMSG_ROUTING_TRACERTSESSION_QUERY ****************************************/
     case CCMSG_ROUTING_TRACERTSESSION_QUERY:
     {
+      msg_RoutingTracertSessionQuery *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_TRACERTSESSION_QUERY (0x%04X)", msgId);
 
       CHECK_INFO_SIZE(msg_RoutingTracertSessionQuery);
 
-      msg_RoutingTracertSessionQuery *data;
       data = (msg_RoutingTracertSessionQuery *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingTracertSessionQuery));
 
       /* Execute command */
       rc = ptin_msg_routing_tracertsession_query(data);
@@ -4218,17 +4294,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;    
     }
 
     /* CCMSG_ROUTING_TRACERTSESSION_FREE ****************************************/
     case CCMSG_ROUTING_TRACERTSESSION_FREE:
     {
+      msg_RoutingTracertSessionFree *data;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ROUTING_TRACERTSESSION_FREE (0x%04X)", CCMSG_ROUTING_TRACERTSESSION_FREE);
 
       CHECK_INFO_SIZE(msg_RoutingTracertSessionFree);
 
-      msg_RoutingTracertSessionFree *data;
       data = (msg_RoutingTracertSessionFree *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_RoutingTracertSessionFree));
 
       /* Execute command */
       rc = ptin_msg_routing_tracertsession_free(data);
@@ -4245,19 +4322,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;
     }
 
         /* Set PRBS mode */
     case CCMSG_ETH_PCS_PRBS_ENABLE:
     {
+      msg_ptin_pcs_prbs *ptr;
+      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_pcs_prbs));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PCS_PRBS_ENABLE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_ptin_pcs_prbs);
 
-      msg_ptin_pcs_prbs *ptr;
-      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_pcs_prbs));
-
       ptr = (msg_ptin_pcs_prbs *) inbuffer->info;
 
       /* Execute command */
       rc  = ptin_msg_pcs_prbs_enable(ptr,n);
 
       if (L7_SUCCESS != rc)
@@ -4272,19 +4349,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get PRBS status */
     case CCMSG_ETH_PCS_PRBS_STATUS:
     {
+      msg_ptin_pcs_prbs *ptr;
+      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_pcs_prbs));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PCS_PRBS_STATUS (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_ptin_pcs_prbs);
 
-      msg_ptin_pcs_prbs *ptr;
-      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_pcs_prbs));
-
       ptr = (msg_ptin_pcs_prbs *) outbuffer->info;
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_ptin_pcs_prbs)*n);
 
       /* Execute command */
       rc = ptin_msg_pcs_prbs_status(ptr,n);
 
@@ -4300,19 +4377,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Set PRBS mode */
     case CCMSG_ETH_PRBS_ENABLE:
     {
+      msg_ptin_prbs_enable *ptr;
+      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_prbs_enable));
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PRBS_ENABLE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_ptin_prbs_enable);
 
-      msg_ptin_prbs_enable *ptr;
-      L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_prbs_enable));
-
       ptr = (msg_ptin_prbs_enable *) inbuffer->info;
 
       /* Execute command */
       rc  = ptin_msg_prbs_enable(ptr,n);
 
       if (L7_SUCCESS != rc)
@@ -4327,20 +4404,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
     break;
 
     /* Get PRBS status */
     case CCMSG_ETH_PRBS_STATUS:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PRBS_STATUS (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE_MOD(msg_ptin_prbs_request);
-
       msg_ptin_prbs_request *ptr_in;
       msg_ptin_prbs_status  *ptr_out;
       L7_int n = MSG_N_ELEMS(sizeof(msg_ptin_prbs_request));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ETH_PRBS_STATUS (0x%04X)", msgId);
+
+      CHECK_INFO_SIZE_MOD(msg_ptin_prbs_request);
+
       ptr_in  = (msg_ptin_prbs_request *) inbuffer->info;
       ptr_out = (msg_ptin_prbs_status  *) outbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_prbs_status(ptr_in, ptr_out, &n);
 
@@ -4375,66 +4452,69 @@ int CHMessageHandler (ipc_msg *inbuffer,
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
         SetIPCNACK(outbuffer, res);
         break;
       }
 
       SETIPCACKOK(outbuffer);
-    
       break;
+
     case CCMSG_RM_MEP:
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_RM_MEP (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_bd_mep_t);
 
       rc = ptin_msg_del_MEP(inbuffer, outbuffer, 0);
 
-      if (L7_SUCCESS != rc) {
+      if (L7_SUCCESS != rc)
+      {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
         SetIPCNACK(outbuffer, res);
         break;
       }
 
       SETIPCACKOK(outbuffer);
-
       break;
+
     case CCMSG_WR_RMEP:
     case CCMSG_FLUSH_RMEP:
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_WR_RMEP/CCMSG_FLUSH_RMEP (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_bd_rmep_t);
 
       rc = ptin_msg_wr_RMEP(inbuffer, outbuffer, 0);
 
-      if (L7_SUCCESS != rc) {
+      if (L7_SUCCESS != rc)
+      {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
         SetIPCNACK(outbuffer, res);
         break;
       }
 
       SETIPCACKOK(outbuffer);
-
       break;
+
     case CCMSG_RM_RMEP:
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_RM_RMEP (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_bd_rmep_t);
 
       rc = ptin_msg_del_RMEP(inbuffer, outbuffer, 0);
 
-      if (L7_SUCCESS != rc) {
+      if (L7_SUCCESS != rc)
+      {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
         SetIPCNACK(outbuffer, res);
         break;
       }
 
       SETIPCACKOK(outbuffer);
-
       break;
+
     case CCMSG_DUMP_MEPs:
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_DUMP_MEPs (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_generic_prefix_t);
 
       rc = ptin_msg_dump_MEPs(inbuffer, outbuffer);
@@ -4442,13 +4522,12 @@ int CHMessageHandler (ipc_msg *inbuffer,
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
         SetIPCNACK(outbuffer, res);
         break;
       }
 
-
       break;
 
     case CCMSG_DUMP_MEs:
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_DUMP_MEs (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_bd_me_t);
@@ -4458,14 +4537,12 @@ int CHMessageHandler (ipc_msg *inbuffer,
       if (L7_SUCCESS != rc) {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
         SetIPCNACK(outbuffer, res);
         break;
       }
-
-
       break;
 
     case CCMSG_DUMP_LUT_MEPs:
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_DUMP_LUT_MEPs (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_generic_prefix_t);
@@ -4476,13 +4553,12 @@ int CHMessageHandler (ipc_msg *inbuffer,
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
         SetIPCNACK(outbuffer, res);
         break;
       }
 
-
       break;
 
     case CCMSG_WR_MIP:
     case CCMSG_RM_MIP:
         PT_LOG_INFO(LOG_CTX_MSGHANDLER,
                     CCMSG_WR_MIP==msgId? "Message received: CCMSG_WR_MIP (0x%04X)"
@@ -4490,13 +4566,14 @@ int CHMessageHandler (ipc_msg *inbuffer,
 
         CHECK_INFO_SIZE_MOD(msg_bd_mip_t);
 
         if (CCMSG_WR_MIP==msgId)    rc = ptin_msg_wr_MIP(inbuffer, outbuffer, 0);
         else                        rc = ptin_msg_del_MIP(inbuffer, outbuffer, 0);
 
-        if (L7_SUCCESS != rc) {
+        if (L7_SUCCESS != rc)
+        {
           PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
           res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
           SetIPCNACK(outbuffer, res);
           break;
         }
 
@@ -4511,45 +4588,53 @@ int CHMessageHandler (ipc_msg *inbuffer,
                                             "Message received: CCMSG_RM_MEP_LM (0x%04X)", msgId);
     
       CHECK_INFO_SIZE(msg_bd_mep_lm_t);
     
 #if MNGMT_DIFFERENT_ENDIANNESS
       {
-       msg_bd_mep_lm_t *p;
+        msg_bd_mep_lm_t *p;
 
-       p = (msg_bd_mep_lm_t*)inbuffer->info;
+        p = (msg_bd_mep_lm_t*)inbuffer->info;
 
-       p->idx = ENDIAN_SWAP32(p->idx);
-       p->port = ENDIAN_SWAP32(p->port);
+        p->idx = ENDIAN_SWAP32(p->idx);
+        p->port = ENDIAN_SWAP32(p->port);
       }
 #endif
 
-      if (CCMSG_RM_MEP_LM == msgId) {
-          rc = del_mep_lm(((msg_bd_mep_lm_t*)inbuffer->info)->idx, &oam)? L7_FAILURE: L7_SUCCESS;
+      if (CCMSG_RM_MEP_LM == msgId)
+      {
+        rc = del_mep_lm(((msg_bd_mep_lm_t*)inbuffer->info)->idx, &oam)? L7_FAILURE: L7_SUCCESS;
       }
-      else {
-       msg_bd_mep_lm_t *p;
+      else
+      {
+        msg_bd_mep_lm_t *p;
        
-       p = (msg_bd_mep_lm_t*)inbuffer->info;
+        p = (msg_bd_mep_lm_t*)inbuffer->info;
 
-       if (0==p->type) rc = L7_NOT_SUPPORTED;
-       else {
-        T_MEP_LM mep_lm;
+        if (0==p->type)
+        {
+          rc = L7_NOT_SUPPORTED;
+        }
+        else
+        {
+          T_MEP_LM mep_lm;
 
-        mep_lm.CCMs0_LMMR1 =    p->type;
-        mep_lm.period =         p->lmmPeriod;
+          mep_lm.CCMs0_LMMR1 =    p->type;
+          mep_lm.period =         p->lmmPeriod;
     
-        switch (wr_mep_lm(p->idx, &mep_lm, &oam)) {
-        case 0: rc = L7_SUCCESS; break;
-        case 1: rc = L7_NOT_EXIST; break;
-        default: rc = L7_ERROR; break;
-        }//switch
-       }
+          switch (wr_mep_lm(p->idx, &mep_lm, &oam))
+          {
+            case 0: rc = L7_SUCCESS; break;
+            case 1: rc = L7_NOT_EXIST; break;
+            default: rc = L7_ERROR; break;
+          }//switch
+        }
       }
     
-      if (L7_SUCCESS != rc) {
+      if (L7_SUCCESS != rc)
+      {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
         SetIPCNACK(outbuffer, res);
         break;
       }
 
@@ -4673,35 +4758,42 @@ int CHMessageHandler (ipc_msg *inbuffer,
     case CCMSG_RM_MEP_DM:
       PT_LOG_INFO(LOG_CTX_MSGHANDLER,
                   CCMSG_WR_MEP_DM == msgId? "Message received: CCMSG_WR_MEP_DM (0x%04X)":
                                             "Message received: CCMSG_RM_MEP_DM (0x%04X)", msgId);
       CHECK_INFO_SIZE(msg_bd_mep_dm_t);
 
-      if (CCMSG_RM_MEP_DM == msgId) {
-          rc = del_mep_dm(((msg_bd_mep_dm_t*)inbuffer->info)->idx, &oam)? L7_FAILURE: L7_SUCCESS;
+      if (CCMSG_RM_MEP_DM == msgId)
+      {
+        rc = del_mep_dm(((msg_bd_mep_dm_t*)inbuffer->info)->idx, &oam)? L7_FAILURE: L7_SUCCESS;
       }
-      else {
-       msg_bd_mep_dm_t *p;
+      else
+      {
+        msg_bd_mep_dm_t *p;
 
-       p = (msg_bd_mep_dm_t*)inbuffer->info;
+        p = (msg_bd_mep_dm_t*)inbuffer->info;
 
-       if (0==p->packet_number) rc = L7_NOT_EXIST;
-       else {
-        T_MEP_DM mep_dm;
-
-        mep_dm.n_frames =          p->packet_number;
-        mep_dm.period =            p->period;
-        mep_dm.oam_datagrm_len =   p->packet_size;
-//        mep_dm.dmmCosColor =         p->dmmCosColor;
-
-        switch (wr_mep_dm(p->idx, &mep_dm, &oam)) {
-			case 0: rc = L7_SUCCESS; break;
-			case 1: rc = L7_NOT_EXIST; break;
-			default: rc = L7_ERROR; break;
-        }//switch
-       }
+        if (0==p->packet_number)
+        {
+          rc = L7_NOT_EXIST;
+        }
+        else
+        {
+          T_MEP_DM mep_dm;
+
+          mep_dm.n_frames =          p->packet_number;
+          mep_dm.period =            p->period;
+          mep_dm.oam_datagrm_len =   p->packet_size;
+          //        mep_dm.dmmCosColor =         p->dmmCosColor;
+
+          switch (wr_mep_dm(p->idx, &mep_dm, &oam))
+          {
+            case 0: rc = L7_SUCCESS; break;
+            case 1: rc = L7_NOT_EXIST; break;
+            default: rc = L7_ERROR; break;
+          }//switch
+        }
       }
 
       if (L7_SUCCESS != rc) {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
         SetIPCNACK(outbuffer, res);
@@ -4761,71 +4853,71 @@ int CHMessageHandler (ipc_msg *inbuffer,
     /************************************************************************** 
     * ERPS Configuration
     **************************************************************************/
 
     case CCMSG_ERPS_SET:
       {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_SET (0x%04X)", msgId);
-    
-      CHECK_INFO_SIZE_MOD(msg_erps_t);
+        msg_erps_t *ptr;
 
-      msg_erps_t *ptr;
-      ptr = (msg_erps_t *) outbuffer->info;
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_SET (0x%04X)", msgId);
+      
+        CHECK_INFO_SIZE_MOD(msg_erps_t);
 
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_t));
+        ptr = (msg_erps_t *) outbuffer->info;
+        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_t));
 
-      /* Execute command */
-      rc = ptin_msg_erps_set(ptr);
+        /* Execute command */
+        rc = ptin_msg_erps_set(ptr);
 
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
 
-      SETIPCACKOK(outbuffer);
+        SETIPCACKOK(outbuffer);
       }
       break;
 
     case CCMSG_ERPS_DEL:
       {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_DEL (0x%04X)", msgId);
-    
-      CHECK_INFO_SIZE_MOD(msg_erps_t);
+        msg_erps_t *ptr;
 
-      msg_erps_t *ptr;
-      ptr = (msg_erps_t *) outbuffer->info;
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_DEL (0x%04X)", msgId);
+      
+        CHECK_INFO_SIZE_MOD(msg_erps_t);
 
-      memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_t));
+        ptr = (msg_erps_t *) outbuffer->info;
+        memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_t));
 
-      /* Execute command */
-      rc = ptin_msg_erps_del(ptr);
+        /* Execute command */
+        rc = ptin_msg_erps_del(ptr);
 
-      if (L7_SUCCESS != rc)
-      {
-        PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
-        res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
-        SetIPCNACK(outbuffer, res);
-        break;
-      }
+        if (L7_SUCCESS != rc)
+        {
+          PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
+          res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
+          SetIPCNACK(outbuffer, res);
+          break;
+        }
 
-      SETIPCACKOK(outbuffer);
+        SETIPCACKOK(outbuffer);
       }
       break;
 
     case CCMSG_ERPS_CONF:
       {
+        msg_erps_t *ptr;
+
         PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_CONF (0x%04X)", msgId);
       
         CHECK_INFO_SIZE_MOD(msg_erps_t);
 
-        msg_erps_t *ptr;
         ptr = (msg_erps_t *) outbuffer->info;
-
         memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_t));
 
         /* Execute command */
         rc = ptin_msg_erps_config(ptr);
 
         if (L7_SUCCESS != rc)
@@ -4839,19 +4931,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
         SETIPCACKOK(outbuffer);        
       }
       break;
 
     case CCMSG_ERPS_STATUS:
       {
+        msg_erps_status_t *ptr;
+
         PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_STATUS (0x%04X)", msgId);
       
         CHECK_INFO_SIZE_MOD(msg_erps_status_t);
 
-        msg_erps_status_t *ptr;
         ptr = (msg_erps_status_t *) outbuffer->info;
-
         memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_status_t));
 
         /* Execute command */
         rc = ptin_msg_erps_status(ptr);
 
         if (L7_SUCCESS != rc)
@@ -4865,21 +4957,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
         SETIPC_INFODIM(sizeof(msg_erps_status_t));
       }
       break;
 
     case CCMSG_ERPS_STATUS_NEXT:
       {
+        msg_erps_status_t *ptr;
+        L7_int            n;
+
         PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_STATUS_NEXT (0x%04X)", msgId);
       
         CHECK_INFO_SIZE_MOD(msg_erps_status_t);
 
-        msg_erps_status_t *ptr;
-        L7_int            n;
-
         ptr = (msg_erps_status_t *) outbuffer->info;
-
         memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_status_t));
 
         /* Execute command */
         rc = ptin_msg_erps_status_next(ptr, &n);
 
         if (L7_SUCCESS != rc)
@@ -4893,20 +4984,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
         SETIPC_INFODIM(sizeof(msg_erps_status_t) * n);
       }
       break;
 
     case CCMSG_ERPS_OPERATOR_CMD:
       {
+        msg_erps_cmd_t *ptr;
+
         PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_OPERATOR_CMD (0x%04X)", msgId);
       
         CHECK_INFO_SIZE_MOD(msg_erps_cmd_t);
 
-        msg_erps_cmd_t *ptr;
-
         ptr = (msg_erps_cmd_t *) outbuffer->info;
-
         memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_cmd_t));
 
         /* Execute command */
         rc = ptin_msg_erps_cmd(ptr);
 
         if (L7_SUCCESS != rc)
@@ -4920,20 +5010,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
         SETIPCACKOK(outbuffer);        
       }
       break;
 
     case CCMSG_ERPS_SYNC:
       {
+        msg_erps_cmd_t *ptr;
+
         PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_ERPS_SYNC (0x%04X)", msgId);
       
         CHECK_INFO_SIZE_MOD(msg_erps_cmd_t);
 
-        msg_erps_cmd_t *ptr;
-
         ptr = (msg_erps_cmd_t *) outbuffer->info;
-
         memcpy(outbuffer->info, inbuffer->info, sizeof(msg_erps_cmd_t));
 
         /* Execute command */
         rc = ptin_msg_erps_cmd(ptr);
 
         if (L7_SUCCESS != rc)
@@ -5068,19 +5157,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       }
       break;
   #endif
       
     case CHMSG_RFC2819_MONITORING_GET_ONE_REG:
       {
+        msg_rfc2819_monitoring_t *in_ptr;
+        msg_rfc2819_buffer_t *ptr;
+
         PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_GET (0x%04X)", msgId);
 
         CHECK_INFO_SIZE_MOD(msg_rfc2819_monitoring_t);
 
-        msg_rfc2819_monitoring_t *in_ptr;
-        msg_rfc2819_buffer_t *ptr;
-
         ptr = (msg_rfc2819_buffer_t *) outbuffer->info;
         in_ptr = (msg_rfc2819_monitoring_t *) inbuffer->info;
 
         ENDIAN_SWAP32_MOD(in_ptr->n);
         /* Execute command */
         rc = ptin_msg_get_next_qualRFC2819(in_ptr->n, ptr);
@@ -5098,18 +5187,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;
 
 
 
     case CHMSG_RFC2819_MONITORING_CONFIG:      
       {
+        msg_rfc2819_admin_t *ptr;
+
         PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_CONFIG (0x%04X)", msgId);
 
         CHECK_INFO_SIZE_MOD(msg_rfc2819_admin_t);
 
-        msg_rfc2819_admin_t *ptr;
-
         ptr = (msg_rfc2819_admin_t *)inbuffer->info;
 
         /* Execute command */
         rc = ptin_msg_config_rfc2819_monitoring(ptr);
 
         if (L7_SUCCESS != rc)
@@ -5123,20 +5212,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
         SETIPCACKOK(outbuffer);
       }
      break;
 
     case CHMSG_RFC2819_MONITORING_GET:
       {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_GET (0x%04X)", msgId);
-  
-        CHECK_INFO_SIZE_MOD(msg_rfc2819_monitoring_t);
-  
         msg_rfc2819_buffer_t      *ptr;
         msg_rfc2819_monitoring_t  *ptr_in;
         L7_int                n;
+
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_GET (0x%04X)", msgId);
   
+        CHECK_INFO_SIZE_MOD(msg_rfc2819_monitoring_t);
+    
         ptr     = (msg_rfc2819_buffer_t  *) outbuffer->info;
         ptr_in  = (msg_rfc2819_monitoring_t * )inbuffer->info;
 
         PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "SlotID %d ", ptr_in->SlotId);
         ENDIAN_SWAP32_MOD(ptr_in->n);
         PT_LOG_TRACE(LOG_CTX_MSGHANDLER, "n %d ", ptr_in->n);
@@ -5155,18 +5244,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
         SETIPC_INFODIM(sizeof(msg_rfc2819_buffer_t) * n);
       }
       break;
 
     case CHMSG_RFC2819_MONITORING_CLEAR:
       {
+        msg_rfc2819_monitoring_t  *ptr_in;
+        msg_rfc2819_monitoring_t  *ptr_out;
+
         PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_CLEAR (0x%04X)", msgId);
   
         CHECK_INFO_SIZE_MOD(msg_rfc2819_monitoring_t);
 
-        msg_rfc2819_monitoring_t  *ptr_in;
-        msg_rfc2819_monitoring_t  *ptr_out;
         ptr_in   = (msg_rfc2819_monitoring_t * )inbuffer->info;
         ptr_out  = (msg_rfc2819_monitoring_t * )outbuffer->info;
 
         /* Execute command */
         ENDIAN_SWAP32_MOD(ptr_in->n);
         rc = ptin_msg_clear_rfc2819_monitoring_buffer(ptr_in->n);
@@ -5183,17 +5273,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       }
       break;
 
 
     case CHMSG_RFC2819_MONITORING_SHOW_CONF:
       {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_SHOW_CONF (0x%04X)", msgId);
-
         L7_int Port;
         L7_uint8 Admin;        
         L7_uint32 *resp;        
+
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_SHOW_CONF (0x%04X)", msgId);
+
         CHECK_INFO_SIZE_MOD(L7_int);
 
         Port = *((L7_uint32 *)inbuffer->info);
         resp = (L7_uint32 *)outbuffer->info;
 
         /* Execute command */
@@ -5217,17 +5308,17 @@ int CHMessageHandler (ipc_msg *inbuffer,
         SETIPC_INFODIM(sizeof(L7_uint32));
       }
       break;
 
     case CHMSG_RFC2819_MONITORING_BUFF_STATUS:
       {
-        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_BUFF_STATUS (0x%04X)", msgId);
-
         msg_rfc2819_buffer_status_t *status;
         L7_int buffer_type;
 
+        PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CHMSG_RFC2819_MONITORING_BUFF_STATUS (0x%04X)", msgId);
+
         status = (msg_rfc2819_buffer_status_t *) outbuffer->info;
 
         CHECK_INFO_SIZE_MOD(L7_int);
 
         buffer_type = *((L7_int *)inbuffer->info);
 
@@ -5276,18 +5367,18 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;
 #endif //__802_1x__
 
 /*****************************************Multicast Package Feature********************************************************/
     /*Multicast Packages Add*/
     case CCMSG_IGMP_PACKAGES_ADD:
-    {        
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGES_ADD (0x%04X)", msgId);
+    {
+      msg_igmp_package_t *msgPtr;
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGES_ADD (0x%04X)", msgId);
       CHECK_INFO_SIZE(msg_igmp_package_t);
 
-      msg_igmp_package_t *msgPtr;
       msgPtr = (msg_igmp_package_t *) outbuffer->info;
 
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_igmp_package_t));
 
       /* Execute command */
       rc = ptin_msg_igmp_packages_add(msgPtr);
@@ -5303,20 +5394,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPC_INFODIM(sizeof(msg_igmp_package_t));
       break;/*Multicast Packages Add*/
     }
 
     /*Multicast Packages Remove*/
     case CCMSG_IGMP_PACKAGES_REMOVE:
-    {        
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGES_REMOVE (0x%04X)", msgId);
-
-      CHECK_INFO_SIZE(msg_igmp_package_t);
-
+    {
       msg_igmp_package_t *msgPtr;
       msgPtr = (msg_igmp_package_t *) outbuffer->info;
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGES_REMOVE (0x%04X)", msgId);
+      CHECK_INFO_SIZE(msg_igmp_package_t);
+
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_igmp_package_t));
 
       /* Execute command */
       rc = ptin_msg_igmp_packages_remove(msgPtr);
 
       if (L7_SUCCESS != rc)
@@ -5330,20 +5420,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
       SETIPC_INFODIM(sizeof(msg_igmp_package_t));
       break; /* CCMSG_IGMP_PACKAGES_REMOVE */
     }
 
     /*Multicast Package Channels Add*/
     case CCMSG_IGMP_PACKAGE_CHANNELS_ADD:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGE_CHANNELS_ADD (0x%04X)", msgId);
+    {
+      msg_igmp_package_channels_t *msgPtr;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_package_channels_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGE_CHANNELS_ADD (0x%04X)", msgId);
       CHECK_INFO_SIZE_MOD(msg_igmp_package_channels_t);
 
-      msg_igmp_package_channels_t *msgPtr;
       msgPtr = (msg_igmp_package_channels_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_package_channels_t));
 
       /* Execute command */
       rc = ptin_msg_igmp_package_channels_add(msgPtr, noOfMessages);
 
       if (L7_SUCCESS != rc)
       {       
@@ -5357,20 +5447,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
 
       break;  /* CCMSG_IGMP_PACKAGE_CHANNELS_ADD */
     }
 
     /*Multicast Package Channels Remove*/
     case CCMSG_IGMP_PACKAGE_CHANNELS_REMOVE:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGE_CHANNELS_REMOVE (0x%04X)", msgId);
+    {
+      msg_igmp_package_channels_t *msgPtr;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_package_channels_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_PACKAGE_CHANNELS_REMOVE (0x%04X)", msgId);
       CHECK_INFO_SIZE_MOD(msg_igmp_package_channels_t);
 
-      msg_igmp_package_channels_t *msgPtr;
       msgPtr = (msg_igmp_package_channels_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_package_channels_t));
 
       /* Execute command */
       rc = ptin_msg_igmp_package_channels_remove(msgPtr, noOfMessages);
 
       if (L7_SUCCESS != rc)
       {       
@@ -5385,19 +5475,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_IGMP_PACKAGE_CHANNELS_REMOVE */
     }
 
     /*Igmp Unicast Client Packages Add*/
     case CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_ADD:
     {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_ADD (0x%04X)", msgId);
+      msg_igmp_unicast_client_packages_t *msgPtr;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_unicast_client_packages_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_ADD (0x%04X)", msgId);
       CHECK_INFO_SIZE_MOD(msg_igmp_unicast_client_packages_t);
 
-      msg_igmp_unicast_client_packages_t *msgPtr;
       msgPtr = (msg_igmp_unicast_client_packages_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_unicast_client_packages_t));
 
       /* Execute command */      
       rc = ptin_msg_igmp_unicast_client_packages_add(msgPtr, noOfMessages);
       
       if (L7_SUCCESS != rc)
       {       
@@ -5411,20 +5501,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
 
       break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_ADD */
     }
 
     /*Igmp Unicast Client Packages Remove*/
     case CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE (0x%04X)", msgId);
+    {
+      msg_igmp_unicast_client_packages_t *msgPtr;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_unicast_client_packages_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE (0x%04X)", msgId);
       CHECK_INFO_SIZE_MOD(msg_igmp_unicast_client_packages_t);
 
-      msg_igmp_unicast_client_packages_t *msgPtr;
       msgPtr = (msg_igmp_unicast_client_packages_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_unicast_client_packages_t));
       
       /* Execute command */      
       rc = ptin_msg_igmp_unicast_client_packages_remove(msgPtr, noOfMessages);
 
       if (L7_SUCCESS != rc)
       {       
@@ -5439,19 +5529,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
     }
 
     /*Igmp Macbridge Client Packages Add*/
     case CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_ADD:
     {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_ADD (0x%04X)", msgId);
+      msg_igmp_macbridge_client_packages_t *msgPtr;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_macbridge_client_packages_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_ADD (0x%04X)", msgId);
       CHECK_INFO_SIZE_MOD(msg_igmp_macbridge_client_packages_t);
 
-      msg_igmp_macbridge_client_packages_t *msgPtr;
       msgPtr = (msg_igmp_macbridge_client_packages_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_macbridge_client_packages_t));
 
       /* Execute command */      
       rc = ptin_msg_igmp_macbridge_client_packages_add(msgPtr, noOfMessages);
 
       if (L7_SUCCESS != rc)
       {       
@@ -5466,19 +5556,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
     }
 
     /*Igmp Macbridge Client Packages Remove*/
     case CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_REMOVE:
     {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_REMOVE (0x%04X)", msgId);
+      msg_igmp_macbridge_client_packages_t *msgPtr;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_macbridge_client_packages_t));
+
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_IGMP_MACBRIDGE_CLIENT_PACKAGES_REMOVE (0x%04X)", msgId);
 
       CHECK_INFO_SIZE_MOD(msg_igmp_macbridge_client_packages_t);
 
-      msg_igmp_macbridge_client_packages_t *msgPtr;
       msgPtr = (msg_igmp_macbridge_client_packages_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_igmp_macbridge_client_packages_t));
 
       /* Execute command */
       rc = ptin_msg_igmp_macbridge_client_packages_remove(msgPtr, noOfMessages);
 
       if (L7_SUCCESS != rc)
       {       
@@ -5492,20 +5583,20 @@ int CHMessageHandler (ipc_msg *inbuffer,
 
       break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
     }
 
     /*Multicast Service Add*/
     case CCMSG_MULTICAST_SERVICE_ADD:
-    {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MULTICAST_SERVICE_ADD (0x%04X)", msgId);
+    { 
+      msg_multicast_service_t *msgPtr;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_multicast_service_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MULTICAST_SERVICE_ADD (0x%04X)", msgId);
       CHECK_INFO_SIZE_MOD(msg_multicast_service_t);
 
-      msg_multicast_service_t *msgPtr;
       msgPtr = (msg_multicast_service_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_multicast_service_t));
 
       /* Execute command */
       rc = ptin_msg_igmp_multicast_service_add(msgPtr, noOfMessages);
 
       if (L7_SUCCESS != rc)
       {       
@@ -5520,19 +5611,19 @@ int CHMessageHandler (ipc_msg *inbuffer,
       break;  /* CCMSG_IGMP_UNICAST_CLIENT_PACKAGES_REMOVE */
     }
 
     /*Multicast Service Remove*/
     case CCMSG_MULTICAST_SERVICE_REMOVE:
     {        
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MULTICAST_SERVICE_REMOVE (0x%04X)", msgId);
+      msg_multicast_service_t *msgPtr;
+      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_multicast_service_t));
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_MULTICAST_SERVICE_REMOVE (0x%04X)", msgId);
       CHECK_INFO_SIZE_MOD(msg_multicast_service_t);
 
-      msg_multicast_service_t *msgPtr;
       msgPtr = (msg_multicast_service_t *) inbuffer->info;
-      L7_uint32 noOfMessages = MSG_N_ELEMS(sizeof(msg_multicast_service_t));
 
       /* Execute command */
       rc = ptin_msg_igmp_multicast_service_remove(msgPtr, noOfMessages);
 
       if (L7_SUCCESS != rc)
       {       
@@ -5548,18 +5639,17 @@ int CHMessageHandler (ipc_msg *inbuffer,
     }
 /************************************End Multicast Package Feature********************************************************/
 #if (PTIN_BOARD == PTIN_BOARD_AG16GA)
 
     case CCMSG_AGENT_TRAP_CONFIGURE:
     {
-      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_AGENT_TRAP_CONFIGURE (0x%04X)", inbuffer->msgId);
+      msg_agent_trap_conf_t *ptr;
 
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_AGENT_TRAP_CONFIGURE (0x%04X)", inbuffer->msgId);
       CHECK_INFO_SIZE(msg_agent_trap_conf_t);
-
-      msg_agent_trap_conf_t *ptr;
-        
+       
       ptr = (msg_agent_trap_conf_t *) outbuffer->info;
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_agent_trap_conf_t));
 
       ptin_msg_configure_trap(ptr->vlan, ptr->port_id, ptr->protocol, ptr->admin);
 
       /* Execute command */
@@ -5579,17 +5669,17 @@ int CHMessageHandler (ipc_msg *inbuffer,
     /************************************************************************** 
     * MAC Limiting Configuration
     **************************************************************************/
 
     case CCMSG_L2_MACLIMIT_CONFIG:
     {
+      msg_l2_maclimit_config_t *ptr;
+
       PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_L2_MACLIMIT_CONFIG (0x%04X)", msgId); 
       CHECK_INFO_SIZE(msg_l2_maclimit_config_t);
-
-      msg_l2_maclimit_config_t *ptr;
-    
+   
       memcpy(outbuffer->info, inbuffer->info, sizeof(msg_l2_maclimit_config_t));
       ptr = (msg_l2_maclimit_config_t *) outbuffer->info;
 
       /* Execute command */
       rc = ptin_msg_l2_maclimit_config(ptr);  
     
@@ -5609,30 +5699,30 @@ int CHMessageHandler (ipc_msg *inbuffer,
     /************************************************************************** 
     * MAC Limiting Status
     **************************************************************************/
 
     case CCMSG_L2_MACLIMIT_STATUS:
     {
-     PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_L2_MACLIMIT_STATUS (0x%04X)", msgId);
-     CHECK_INFO_SIZE(msg_l2_maclimit_status_t);
+      msg_l2_maclimit_status_t *ptr;
 
-     msg_l2_maclimit_status_t *ptr;
+      PT_LOG_INFO(LOG_CTX_MSGHANDLER, "Message received: CCMSG_L2_MACLIMIT_STATUS (0x%04X)", msgId);
+      CHECK_INFO_SIZE(msg_l2_maclimit_status_t);
 
-     ptr = (msg_l2_maclimit_status_t *) outbuffer->info;
-     memcpy(&outbuffer->info, &inbuffer->info, sizeof(msg_l2_maclimit_status_t));
+      ptr = (msg_l2_maclimit_status_t *) outbuffer->info;
+      memcpy(&outbuffer->info, &inbuffer->info, sizeof(msg_l2_maclimit_status_t));
 
-     /* Execute command */
-     rc = ptin_msg_l2_maclimit_status(ptr);  
+      /* Execute command */
+      rc = ptin_msg_l2_maclimit_status(ptr);  
 
-     if (L7_SUCCESS != rc)
-     {
+      if (L7_SUCCESS != rc)
+      {
         PT_LOG_ERR(LOG_CTX_MSGHANDLER, "Error sending data");
         res = SIR_ERROR(ERROR_FAMILY_HARDWARE, ERROR_SEVERITY_ERROR, SIRerror_get(rc));
         SetIPCNACK(outbuffer, res);
         break;
-     }
+      }
 
       SETIPC_INFODIM(sizeof(msg_l2_maclimit_status_t));
 
       PT_LOG_TRACE(LOG_CTX_MSGHANDLER," Status Response");
       PT_LOG_TRACE(LOG_CTX_MSGHANDLER," slotId       = %u",      ptr->slotId);
       PT_LOG_TRACE(LOG_CTX_MSGHANDLER," interface    = %u/%u",   ptr->intf.intf_type, ptr->intf.intf_id);
