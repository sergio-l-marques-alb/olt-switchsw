Index: os/linux/log/log_extend.c
===================================================================
--- os/linux/log/log_extend.c	(revision 6677)
+++ os/linux/log/log_extend.c	(working copy)
@@ -253,11 +253,11 @@
     L7_int32    fd;
 
     if (Log_Ptr != L7_NULLPTR)
     {
         L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LOG_COMPONENT_ID,
-                "Log_Init: Re-initializing logs, old size %d, new size %d\n",
+                "Log_Init: Re-initializing logs, old size %ld, new size %ld\n",
                 EventLogSize, event_log_size);
 
         if (event_log_size != EventLogSize)
         {
             osapiFree(L7_LOG_COMPONENT_ID, Log_Ptr);
Index: os/linux/osapi/osapi.c
===================================================================
--- os/linux/osapi/osapi.c	(revision 6677)
+++ os/linux/osapi/osapi.c	(working copy)
@@ -659,12 +659,12 @@
   
       if (((comp_id == 0) || (mem_alloc->component_id == comp_id)) &&
           (mem_alloc->length > size) &&
           (mem_alloc->time_stamp > time_stamp))
       {
-      if (cnt < sizeAllocBuffer)
-        memcpy(&allocBuffer[cnt++], mem_alloc, sizeof(osapiMemAllocType));
+        if (cnt < sizeAllocBuffer)
+          memcpy(&allocBuffer[cnt++], mem_alloc, sizeof(osapiMemAllocType));
 
         total_blocks_match++;
         total_size_match += mem_alloc->length;
       }
       
Index: os/linux/osapi/osapi_task.c
===================================================================
--- os/linux/osapi/osapi_task.c	(revision 6677)
+++ os/linux/osapi/osapi_task.c	(working copy)
@@ -628,11 +628,11 @@
     osapi_task_destroy(newTask);
     
     return(L7_ERROR);
   }
 
-  PT_LOG_NOTICE(LOG_CTX_STARTUP, "New pthread created: \"%s\" -> pthread_id=%u (task_id=%u)",
+  PT_LOG_NOTICE(LOG_CTX_STARTUP, "New pthread created: \"%s\" -> pthread_id=%lu (task_id=%u)",
              namePtr, newTask->thread, (unsigned int)task_id);
 
   return(task_id);
 
 }
Index: os/linux/routing/lvl7arpd.c
===================================================================
--- os/linux/routing/lvl7arpd.c	(revision 6677)
+++ os/linux/routing/lvl7arpd.c	(working copy)
@@ -38,11 +38,11 @@
 #include <unistd.h>
 #include <errno.h>
 #include <string.h>
 /* PTin added: ARM processor */
 #ifndef __arm__
-#include <stropts.h>
+//#include <stropts.h>
 #endif
 #include <asm/types.h>
 #include <sys/socket.h>
 #include <sys/ioctl.h>
 #include <linux/netlink.h>
Index: src/application/base/dot1ab/core/lldp_cnfgr.c
===================================================================
--- src/application/base/dot1ab/core/lldp_cnfgr.c	(revision 6677)
+++ src/application/base/dot1ab/core/lldp_cnfgr.c	(working copy)
@@ -701,11 +701,11 @@
   *pResponse  = L7_CNFGR_CMD_COMPLETE;
   *pReason    = 0;
 
   /* TBD - disable Tx/Rx on all interfaces?? */
 
-  memset(lldpCfgData, 0, sizeof(lldpCfgData));
+  memset(lldpCfgData, 0, sizeof(*lldpCfgData));
 
   lldpCnfgrState = LLDP_PHASE_WMU;
 
   return L7_SUCCESS;
 }
Index: src/application/base/dot1ab/core/lldp_rdb.c
===================================================================
--- src/application/base/dot1ab/core/lldp_rdb.c	(revision 6677)
+++ src/application/base/dot1ab/core/lldp_rdb.c	(working copy)
@@ -511,28 +511,28 @@
   currEntry = avlInsertEntry(&lldpRemDbTree,entry);
   if (currEntry == entry)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
             "%s:%d Error Adding the node to the Remote Tree for intf %s \n",
-            __FUNCTION__,__FILE__,ifName);
+            __FUNCTION__,__LINE__,ifName);
     return L7_NULLPTR;
   }
   currEntry = lldpRemDataEntryGet((lldpRemDataKey_t*)entry);
   if (currEntry == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
             "%s:%d Error Retrieving the node from the Remote Tree for intf %s \n",
-            __FUNCTION__,__FILE__,ifName);
+            __FUNCTION__,__LINE__,ifName);
     return L7_NULLPTR;
   }
   /* allocate the index list */
   if (bufferPoolAllocate(lldpRemDBIndexBufferPoolId,
                          (L7_uchar8 **)&indexNode) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_LLDP_COMPONENT_ID,
             "%s:%d Error allocating the node to the remote index for intf %s \n",
-            __FUNCTION__,__FILE__,ifName);
+            __FUNCTION__,__LINE__,ifName);
     lldpRemEntryDelete(currEntry);
     avlDeleteEntry(&lldpRemDbTree,currEntry);
     return L7_NULLPTR;
   }
 
Index: src/application/base/doublevlantag/dvlantag_ih.c
===================================================================
--- src/application/base/doublevlantag/dvlantag_ih.c	(revision 6677)
+++ src/application/base/doublevlantag/dvlantag_ih.c	(working copy)
@@ -642,14 +642,16 @@
   }
 
   if (i < L7_DVLANTAG_MAX_INTERFACE_COUNT)
   {
     dvlantagMapTbl[intIfNum] = i;
+
     if (pCfg != L7_NULLPTR)
-        *pCfg = &dvlantagCfg->intfCfg[i];
-        return L7_TRUE;
-      }
+      *pCfg = &dvlantagCfg->intfCfg[i];
+
+    return L7_TRUE;
+  }
 
   return L7_FALSE;
 }
 
 /*********************************************************************
Index: src/application/base/isdp/isdp_util.c
===================================================================
--- src/application/base/isdp/isdp_util.c	(revision 6677)
+++ src/application/base/isdp/isdp_util.c	(working copy)
@@ -681,11 +681,11 @@
   msg.data.nimStartupEvent.startupPhase = startupPhase;
 
   if (isdpProcessMsgQueue(msg) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_ISDP_COMPONENT_ID,
-            "%s: Failed to send NIM startup %s msg to ISDP msg queue.",
+            "%s: Failed to send NIM startup %d msg to ISDP msg queue.",
             __FUNCTION__, startupPhase);
   }
 
   return;
 }
Index: src/application/base/sflow/sflow_api.c
===================================================================
--- src/application/base/sflow/sflow_api.c	(revision 6677)
+++ src/application/base/sflow/sflow_api.c	(working copy)
@@ -873,11 +873,11 @@
     if (usmDbIntIfNumTypeFirstGet(UnitIndex, inclintIfType, exclintIfType,
                                    &intIfIndex) == L7_SUCCESS)
     {
       if( usmDbExtIfNumFromIntIfNum(intIfIndex, &ifIndex) == L7_SUCCESS)
       {
-        memset(index, 0, sizeof(index));
+//        memset(index, 0, sizeof(index)); ???
         sprintf(index,"%s.%d",L7_SFLOW_IFINDEX, ifIndex);
         *instance =1;
         return L7_SUCCESS;
       }
       return L7_FAILURE;
@@ -1247,11 +1247,11 @@
     if (usmDbIntIfNumTypeFirstGet(UnitIndex, inclintIfType, exclintIfType,
                                    &intIfIndex) == L7_SUCCESS)
     {
       if( usmDbExtIfNumFromIntIfNum(intIfIndex, &ifIndex) == L7_SUCCESS)
       {
-        memset(index, 0, sizeof(index));
+//        memset(index, 0, sizeof(index)); ???
         sprintf(index,"%s.%d",L7_SFLOW_IFINDEX, ifIndex);
         *instance =1;
         return L7_SUCCESS;
       }
       return L7_FAILURE;
Index: src/application/ip_mcast/mapping/dvmrpmap/dvmrp_map_util.c
===================================================================
--- src/application/ip_mcast/mapping/dvmrpmap/dvmrp_map_util.c	(revision 6677)
+++ src/application/ip_mcast/mapping/dvmrpmap/dvmrp_map_util.c	(working copy)
@@ -196,11 +196,11 @@
     /* delete DVMRP router multicast address from NPU */
     if (dtlIpv4LocalMulticastAddrDelete(intIfNum, L7_IP_ALL_DVMRP_RTRS_ADDR)
         != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_FLEX_DVMRP_MAP_COMPONENT_ID,
-              "DVMRP All Routers Address - %x Delete from the DTL Mcast List "
+              "DVMRP All Routers Address - %lx Delete from the DTL Mcast List "
               "Failed for intf - %s"
               " DMVRP All Routers Address deletion from the local multicast list Failed."
               " As a result of this, DVMRP Multicast packets are still received at the"
               " application though DVMRP is disabled.", L7_IP_ALL_DVMRP_RTRS_ADDR, ifName);
       /*return L7_FAILURE;*/
@@ -240,11 +240,11 @@
     /* set DVMRP router multicast address in NPU */
     if (dtlIpv4LocalMulticastAddrAdd(intIfNum, L7_IP_ALL_DVMRP_RTRS_ADDR)
         != L7_SUCCESS)
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_FLEX_DVMRP_MAP_COMPONENT_ID,
-              "DVMRP All Routers Address - %x Add to the DTL Mcast List "
+              "DVMRP All Routers Address - %lx Add to the DTL Mcast List "
               "Failed for intf - %s"
               "DMVRP All Routers Address addition to the local multicast list Failed."
               " As a result of this, DVMRP Multicast packets with this address will not"
               " be received at the application.", L7_IP_ALL_DVMRP_RTRS_ADDR, ifName);
       return L7_FAILURE;
Index: src/application/ip_mcast/mapping/mcastmap/core/mcast_debug.c
===================================================================
--- src/application/ip_mcast/mapping/mcastmap/core/mcast_debug.c	(revision 6677)
+++ src/application/ip_mcast/mapping/mcastmap/core/mcast_debug.c	(working copy)
@@ -748,11 +748,11 @@
                      inetAddrPrint(&srcAddr, srcBuff), inetAddrPrint(&grpAddr, destBuff),
                      usp.unit, usp.slot, usp.port, length);
   }
   else
   {
-    MCAST_USER_TRACE("Sent mcast data pkt %s with Src %s and Grp %s on interface %d/%d/%d of len = %d ",
+    MCAST_USER_TRACE("Sent mcast data pkt with Src %s and Grp %s on interface %d/%d/%d of len = %d ",
                      inetAddrPrint(&srcAddr, srcBuff), inetAddrPrint(&grpAddr, destBuff),
                      usp.unit, usp.slot, usp.port, length);
   }
   return;
 }
Index: src/application/ip_mcast/vendor/pimsm/pimsmrp.c
===================================================================
--- src/application/ip_mcast/vendor/pimsm/pimsmrp.c	(revision 6677)
+++ src/application/ip_mcast/vendor/pimsm/pimsmrp.c	(working copy)
@@ -687,11 +687,11 @@
       *ppAddrListNode = L7_NULLPTR;
       return L7_FAILURE;
     }
 
     /* 2. populate the rp_node */
-    memset(pAddrListNode,0,sizeof(pAddrListNode));
+    memset(pAddrListNode,0,sizeof(*pAddrListNode));
     inetCopy(&pAddrListNode->pimsmIpAddr, &grpAddr);
     pAddrListNode->pimsmCb = pimsmCb;
     pAddrListNode->pimsmOrigin = origin;
     pAddrListNode->pimsmMaskLen = grpMaskLen;
     pAddrListNode->pimsmRpGrpNode = (void *)pRpGrpNode;
@@ -911,11 +911,11 @@
                                 L7_inet_addr_t     rpAddr,
                                 PIMSM_RP_GRP_MAPPING_ORIGIN_TYPE  origin,
                                 pimsmAddrList_t  **ppAddrListNode)
 {
   pimsmRpBlock_t     *rpBlock;
-  pimsmAddrList_t    *pAddrListNode = L7_NULLPTR,addrListSearchNode;
+  pimsmAddrList_t    *pAddrListNode = L7_NULLPTR, addrListSearchNode;
 
   rpBlock = pimsmCb->pimsmRpInfo;
   /* 1. search for the node in the node's rp list */
   memset(&addrListSearchNode,0,sizeof(pimsmAddrList_t));
   inetCopy(&addrListSearchNode.pimsmIpAddr, &rpAddr);
@@ -938,11 +938,11 @@
       *ppAddrListNode = L7_NULLPTR;
       return L7_FAILURE;
     }
 
     /* 2. populate the pRpGrpNode */
-    memset(pAddrListNode,0,sizeof(pAddrListNode));
+    memset(pAddrListNode,0,sizeof(*pAddrListNode));
     inetCopy(&pAddrListNode->pimsmIpAddr, &rpAddr);
     pAddrListNode->pimsmCb= pimsmCb;
     pAddrListNode->pimsmOrigin = origin;
     pAddrListNode->pimsmRpGrpNode = pRpGrpNode;
     pAddrListNode->pimsmOriginFlag = L7_FALSE;
Index: src/application/ptin/base/ethsrv_oam.c
===================================================================
--- src/application/ptin/base/ethsrv_oam.c	(revision 6677)
+++ src/application/ptin/base/ethsrv_oam.c	(working copy)
@@ -2197,11 +2197,11 @@
      //Response to an LTM
      //if (0==p_ltm->TTL) return 0;//5
 
      this_MPs_MAC(oam_prt, vid, MEP_in_DB?1:0, this_MP_MAC.byte);
      TerminalMP= memcmp(p_ltm->targ_mac, this_MP_MAC.byte, sizeof(T_ETH_OAM_MAC))? 0:1;
-     ETHSRV_OAM_LOG("this_MP_MAC=%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\tTerminalMP=%2.2u TTL=%u transID=%u pkt_len-2=%u"NLS,
+     ETHSRV_OAM_LOG("this_MP_MAC=%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\tTerminalMP=%2.2u TTL=%u transID=%lu pkt_len-2=%lu"NLS,
                     this_MP_MAC.byte[0], this_MP_MAC.byte[1], this_MP_MAC.byte[2],
                     this_MP_MAC.byte[3], this_MP_MAC.byte[4], this_MP_MAC.byte[5], TerminalMP,
                     p_ltm->TTL, p_ltm->transID, pkt_len-2);
 
      if (MEP_in_DB) {   //we're a MEP
Index: src/application/ptin/base/include/ptin_cfg.h
===================================================================
--- src/application/ptin/base/include/ptin_cfg.h	(revision 6677)
+++ src/application/ptin/base/include/ptin_cfg.h	(working copy)
@@ -40,11 +40,11 @@
 /**
  * Returns the external inBand VLAN ID
  * 
  * @return L7_uint16 inBand VID (zero if not configured)
  */
-extern inline L7_uint16 ptin_cfg_inband_vlan_get(void);
+extern L7_uint16 ptin_cfg_inband_vlan_get(void);
 
 /**
  * Creates a bridge between dtl0 interface and a virtual interface eth0.4093 
  *  
  * NOTE: 
Index: src/application/ptin/base/include/ptin_intf.h
===================================================================
--- src/application/ptin/base/include/ptin_intf.h	(revision 6677)
+++ src/application/ptin/base/include/ptin_intf.h	(working copy)
@@ -305,159 +305,159 @@
  * @param ptin_port PTin port index
  * @param intIfNum  FP intIfNum
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_port2intIfNum(L7_uint32 ptin_port, L7_uint32 *intIfNum);
+extern L7_RC_t ptin_intf_port2intIfNum(L7_uint32 ptin_port, L7_uint32 *intIfNum);
 
 /**
  * Converts FP interface# to PTin port mapping (including LAGs)
  * 
  * @param intIfNum  FP intIfNum
  * @param ptin_port PTin port index
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_intIfNum2port(L7_uint32 intIfNum, L7_uint32 *ptin_port);
+extern L7_RC_t ptin_intf_intIfNum2port(L7_uint32 intIfNum, L7_uint32 *ptin_port);
 
 /**
  * Converts ptin_port index to LAG index
  * 
  * @param ptin_port PTin port index
  * @param lag_idx   LAG index
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_port2lag(L7_uint32 ptin_port, L7_uint32 *lag_idx);
+extern L7_RC_t ptin_intf_port2lag(L7_uint32 ptin_port, L7_uint32 *lag_idx);
 
 /**
  * Converts LAG index to ptin_port
  *  
  * @param lag_idx   LAG index 
  * @param ptin_port PTin port index 
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-inline L7_RC_t ptin_intf_lag2port(L7_uint32 lag_idx, L7_uint32 *ptin_port);
+extern L7_RC_t ptin_intf_lag2port(L7_uint32 lag_idx, L7_uint32 *ptin_port);
 
 /**
  * Converts ptin_port index to PTin port type and id
  * 
  * @param ptin_port PTin port index
  * @param port_type PTin port type (0 is physical and 1 is LAG) 
  * @param port_id   PTin port id
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_port2ptintf(L7_uint32 ptin_port, ptin_intf_t *ptin_intf);
+extern L7_RC_t ptin_intf_port2ptintf(L7_uint32 ptin_port, ptin_intf_t *ptin_intf);
 
 /**
  * Converts PTin port type and id to ptin_port index
  * 
  * @param port_type PTin port type (0 is physical and 1 is LAG) 
  * @param port_id   PTin port id
  * @param ptin_port PTin port index
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_ptintf2port(const ptin_intf_t *ptin_intf, L7_uint32 *ptin_port);
+extern L7_RC_t ptin_intf_ptintf2port(const ptin_intf_t *ptin_intf, L7_uint32 *ptin_port);
 
 /**
  * Converts PTin port type and id to ptin_port index
  * 
  * @param intf_type PTin port type (0 is physical and 1 is LAG) 
  * @param intf_id   PTin port id
  * @param ptin_port PTin port index
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_typeId2port(L7_uint8 intf_type, L7_uint8 intf_id, L7_uint32 *ptin_port);
+extern L7_RC_t ptin_intf_typeId2port(L7_uint8 intf_type, L7_uint8 intf_id, L7_uint32 *ptin_port);
 
 /**
  * Converts ptin_port index to port type and id
  * 
  * @param ptin_port PTin port index
  * @param intf_type PTin port type (out)
  * @param intf_id   PTin port id (out)
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_port2typeId(L7_uint32 ptin_port, L7_uint8 *intf_type, L7_uint8 *intf_id);
+extern L7_RC_t ptin_intf_port2typeId(L7_uint32 ptin_port, L7_uint8 *intf_type, L7_uint8 *intf_id);
 
 /**
  * Converts FP interface# to PTin port type and id
  * 
  * @param intIfNum  FP intIfNum
  * @param port_type PTin port type (0 is physical and 1 is LAG) 
  * @param port_id   PTin port id
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_intIfNum2ptintf(L7_uint32 intIfNum, ptin_intf_t *ptin_intf);
+extern L7_RC_t ptin_intf_intIfNum2ptintf(L7_uint32 intIfNum, ptin_intf_t *ptin_intf);
 
 /**
  * Converts PTin port type and id to FP interface#
  * 
  * @param port_type PTin port type (0 is physical and 1 is LAG) 
  * @param port_id   PTin port id
  * @param intIfNum  FP intIfNum
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_ptintf2intIfNum(const ptin_intf_t *ptin_intf, L7_uint32 *intIfNum);
+extern L7_RC_t ptin_intf_ptintf2intIfNum(const ptin_intf_t *ptin_intf, L7_uint32 *intIfNum);
 
 /**
  * Converts PTin port type and id to FP interface#
  * 
  * @param intf_type PTin port type (0 is physical and 1 is LAG) 
  * @param intf_id   PTin port id
  * @param intIfNum  FP intIfNum
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_typeId2intIfNum(L7_uint8 intf_type, L7_uint8 intf_id, L7_uint32 *intIfNum);
+extern L7_RC_t ptin_intf_typeId2intIfNum(L7_uint8 intf_type, L7_uint8 intf_id, L7_uint32 *intIfNum);
 
 /**
  * Converts LAG index [1..PTIN_SYSTEM_N_LAGS] to FP intIfNum
  * 
  * @param intIfNum  FP intIfNum
  * @param ptin_port PTin port index
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_lag2intIfNum(L7_uint32 lag_idx, L7_uint32 *intIfNum);
+extern L7_RC_t ptin_intf_lag2intIfNum(L7_uint32 lag_idx, L7_uint32 *intIfNum);
 
 /**
  * Convert intIfNum to LAG index
  * 
  * @param intIfNum  FP intIfNum
  * @param lag_idx   LAG index (output)
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_intIfNum2lag(L7_uint32 intIfNum, L7_uint32 *lag_idx);
+extern L7_RC_t ptin_intf_intIfNum2lag(L7_uint32 intIfNum, L7_uint32 *lag_idx);
 
 #if PTIN_BOARD_IS_MATRIX
 /**
  * Converts Slot to LAG index [0..PTIN_SYSTEM_N_LAGS[
  * 
  * @param slot      slot
  * @param lag_idx   LAG index [0..PTIN_SYSTEM_N_LAGS[ (output)
  * 
  * @return L7_RC_t L7_SUCCESS/L7_FAILURE
  */
-extern inline L7_RC_t ptin_intf_slot2lagIdx(L7_uint16 slot, L7_uint32 *lag_idx);
+extern L7_RC_t ptin_intf_slot2lagIdx(L7_uint16 slot, L7_uint32 *lag_idx);
 #endif
 
 /**
  * Check if a LAG is created [1..PTIN_SYSTEM_N_LAGS]
  * 
  * @param lag_idx   LAG index [1..PTIN_SYSTEM_N_LAGS]
  * 
  * @return L7_RC_t L7_TRUE/L7_FALSE
  */
-extern inline L7_RC_t ptin_intf_lag_exists(L7_uint32 lag_idx);
+extern L7_RC_t ptin_intf_lag_exists(L7_uint32 lag_idx);
 
 
 /**
  * Check if a particular port is used for uplink protection
  * 
Index: src/application/ptin/base/include/ptin_xlate_api.h
===================================================================
--- src/application/ptin/base/include/ptin_xlate_api.h	(revision 6677)
+++ src/application/ptin/base/include/ptin_xlate_api.h	(working copy)
@@ -18,11 +18,11 @@
 #define PTIN_XLATE_PORTGROUP_ROOTS_10G    (PTIN_XLATE_PORTGROUP_SPECIAL_BASE+2)     /* 10G Root ports */
 
 /**
  * Inline functions
  */
-inline char ptin_vlanxlate_action_getchar(ptin_vlanXlate_action_enum action);
+extern char ptin_vlanxlate_action_getchar(ptin_vlanXlate_action_enum action);
 
 /**
  * Module initialization function
  * 
  * @return L7_RC_t : L7_SUCCESS or L7_FAILURE
Index: src/application/ptin/base/ptin_dhcp.c
===================================================================
--- src/application/ptin/base/ptin_dhcp.c	(revision 6677)
+++ src/application/ptin/base/ptin_dhcp.c	(working copy)
@@ -226,11 +226,11 @@
 
 /*********************************************************** 
  * INLINE FUNCTIONS
  ***********************************************************/
 
-inline L7_BOOL dhcp_clientIndex_check_free(L7_uint8 dhcp_idx)
+static inline L7_BOOL dhcp_clientIndex_check_free(L7_uint8 dhcp_idx)
 {
   /* Validate arguments */
   if (dhcp_idx >= PTIN_SYSTEM_N_DHCP_INSTANCES)
   {
     PT_LOG_ERR(LOG_CTX_DHCP,"Invalid DHCP instance %u", dhcp_idx);
@@ -239,11 +239,11 @@
 
   return (dhcpClients_unified.number_of_clients < PTIN_SYSTEM_DHCP_MAXCLIENTS &&
           queue_free_clients.n_elems > 0);
 }
 
-inline L7_int dhcp_clientIndex_allocate(L7_uint8 dhcp_idx, ptinDhcpClientInfoData_t *infoData)
+static inline L7_int dhcp_clientIndex_allocate(L7_uint8 dhcp_idx, ptinDhcpClientInfoData_t *infoData)
 {
   L7_int  client_idx;
   struct ptin_clientIdx_entry_s  *clientIdx_pool_entry;
   struct ptin_clientInfo_entry_s *clientInfo_pool_entry;
   L7_RC_t rc;
@@ -304,11 +304,11 @@
 
   /* Return new client id */
   return client_idx;
 }
 
-inline void dhcp_clientIndex_release(L7_uint8 dhcp_idx, L7_uint32 client_idx)
+static inline void dhcp_clientIndex_release(L7_uint8 dhcp_idx, L7_uint32 client_idx)
 {
   struct ptin_clientIdx_entry_s  *clientIdx_pool_entry;
   struct ptin_clientInfo_entry_s *clientInfo_pool_entry;
   L7_RC_t rc;
 
Index: src/application/ptin/base/ptin_evc.c
===================================================================
--- src/application/ptin/base/ptin_evc.c	(revision 6677)
+++ src/application/ptin/base/ptin_evc.c	(working copy)
@@ -2173,11 +2173,11 @@
   }
 
   /* Get interface configuration */
   if (ptin_evc_intf_type_get(intVlan, intIfNum, &intf_type)!=L7_SUCCESS)
   {
-    PT_LOG_WARN(LOG_CTX_DHCP, "Error acquiring interface %u/%u type from internalVid %u and intIfNum %u", intVlan, intIfNum);
+    PT_LOG_WARN(LOG_CTX_DHCP, "Error acquiring from internalVid %u and intIfNum %u", intVlan, intIfNum);
     return L7_FALSE;
   }
   if(intf_type == PTIN_EVC_INTF_ROOT)
   {
      return L7_TRUE;
@@ -4652,11 +4652,11 @@
      for (intf_vp_modu=INTF_VP_MAX; 1;) {                                     //Just to improve modulus
          for (i=2; i*i<intf_vp_modu; i++) if (0==intf_vp_modu%i) break;
          if (i*i>=intf_vp_modu) break;
          intf_vp_modu++;
      }
-     PT_LOG_INFO(LOG_CTX_EVC, "IfN_vp_DB init(%d)\tN=%lu\tmodu=%lu\tL7_MAX_INTERFACE_COUNT=%lu", _0init_1insert_2remove_3find, INTF_VP_MAX, intf_vp_modu, L7_MAX_INTERFACE_COUNT);
+     PT_LOG_INFO(LOG_CTX_EVC, "IfN_vp_DB init(%d)\tN=%d\tmodu=%lu\tL7_MAX_INTERFACE_COUNT=%d", _0init_1insert_2remove_3find, INTF_VP_MAX, intf_vp_modu, L7_MAX_INTERFACE_COUNT);
      break;
   case 1:
   case 2:
   case 3:
      i=vportId__2__i(entry->vport_id, intf_vp_modu%INTF_VP_MAX);
@@ -4872,11 +4872,11 @@
   else
   {
     /* Check if policer exists */
     if (!intf_vp->policer.in_use)
     {
-      PT_LOG_WARN(LOG_CTX_L2, "vport 0x%x already does not have policer", intf_vp->vport_id);
+      PT_LOG_WARN(LOG_CTX_L2, "vport 0x%lx already does not have policer", intf_vp->vport_id);
       return L7_SUCCESS;
     }
 
     PT_LOG_TRACE(LOG_CTX_EVC,"Going to remove policer");
 
@@ -4944,11 +4944,11 @@
   }
 
   /* If success... */
   if (rc == L7_SUCCESS)
   {
-    PT_LOG_TRACE(LOG_CTX_L2, "Success updating policer to virtual port 0x%08x",intf_vp->vport_id);
+    PT_LOG_TRACE(LOG_CTX_L2, "Success updating policer to virtual port 0x%08lx",intf_vp->vport_id);
 
     /* Remove policer, if it was that intention */
     if (meter == L7_NULLPTR || meter->cir == (L7_uint32)-1)
     {
       PT_LOG_TRACE(LOG_CTX_EVC,"Policer %d", intf_vp->policer.policer_id);
@@ -4972,11 +4972,11 @@
       intf_vp->policer.in_use = L7_FALSE;
     }
   }
   else
   {
-    PT_LOG_ERR(LOG_CTX_L2, "Error updating policer to virtual port 0x%08x",intf_vp->vport_id);
+    PT_LOG_ERR(LOG_CTX_L2, "Error updating policer to virtual port 0x%08lx",intf_vp->vport_id);
   }
 
   PT_LOG_TRACE(LOG_CTX_EVC,"Finished");
 
   return L7_SUCCESS;
@@ -5009,11 +5009,11 @@
   L7_uint32   intIfNum; 
 
   /* Input Argument validation */
   if ( ecvFlow  == L7_NULLPTR)
   {
-    PT_LOG_ERR(LOG_CTX_EVC, "Invalid arguments [msg:%p noOfMessages:%u]",ecvFlow);    
+    PT_LOG_ERR(LOG_CTX_EVC, "Invalid arguments");    
     return L7_FAILURE;
   }
   
   evc_ext_id = ecvFlow->evc_idx;
   PT_LOG_TRACE(LOG_CTX_EVC, "Adding eEVC# %u flow connection...", evc_ext_id);
@@ -5117,11 +5117,11 @@
   L7_uint32   intIfNum;
     
   /* Input Argument validation */
   if ( ecvFlow  == L7_NULLPTR)
   {
-    PT_LOG_ERR(LOG_CTX_EVC, "Invalid arguments [msg:%p noOfMessages:%u]",ecvFlow);    
+    PT_LOG_ERR(LOG_CTX_EVC, "Invalid arguments");
     return L7_FAILURE;
   }
 
   evc_ext_id = ecvFlow->evc_idx;
   PT_LOG_TRACE(LOG_CTX_EVC, "Adding eEVC# %u flow connection...", evc_ext_id);
@@ -5487,19 +5487,22 @@
     pflow->maxChannels  = evcFlow->maxChannels;
 
     dl_queue_add_tail(&evcs[evc_id].intf[leaf_port].clients, (dl_queue_elem_t*) pflow); /* add it to the corresponding interface */
     evcs[evc_id].n_clientflows++;
 
-    PT_LOG_TRACE(LOG_CTX_EVC, "eEVC# %u: flow successfully added (vport_id=%lu\tpon=%u/%u(%lu)\tgem_id=%u\tvirtual_gport=0x%8.8lx)",
+    PT_LOG_TRACE(LOG_CTX_EVC, "eEVC# %u: flow successfully added (vport_id=%d\tpon=%u/%u(%u)\tgem_id=%u\tvirtual_gport=0x%8.8x)",
              evc_ext_id,
              vport_id & 0xffffff,
-             evcFlow->ptin_intf.intf_type,evcFlow->ptin_intf.intf_id, intIfNum,
-             evcFlow->uni_ovid, vport_id);
+             evcFlow->ptin_intf.intf_type,
+             evcFlow->ptin_intf.intf_id,
+             intIfNum,
+             evcFlow->uni_ovid,
+             vport_id);
   }
   else
   {
-    PT_LOG_WARN(LOG_CTX_EVC, "EVC# %u: GEM id already exists", evc_id, evcFlow->uni_ovid, leaf_port);
+    PT_LOG_WARN(LOG_CTX_EVC, "EVC# %u: GEM id already exists", evc_id);
   }
 
   /* Protocols */
   igmp_enabled    = (evcFlow->flags & PTIN_EVC_MASK_IGMP_PROTOCOL  ) == PTIN_EVC_MASK_IGMP_PROTOCOL;
   dhcpv4_enabled  = (evcFlow->flags & PTIN_EVC_MASK_DHCPV4_PROTOCOL) == PTIN_EVC_MASK_DHCPV4_PROTOCOL;
@@ -9542,11 +9545,11 @@
     {
       rc = ptin_igmp_mgmd_port_remove(evcs[evc_id].extended_id, intIfNum);
       if (rc != L7_SUCCESS)
       {
         PT_LOG_ERR(LOG_CTX_EVC, "EVC# %u: error removing Mgmd Port [extended_id=%u intIfNum=%u]",
-                evcs[evc_id].extended_id, intIfNum);
+                evc_id, evcs[evc_id].extended_id, intIfNum);
   //    return L7_FAILURE;
       }
       else
       {
         PT_LOG_TRACE(LOG_CTX_EVC, "Removed Mgmd Port [extended_id:%u intIfNum=%u]", evcs[evc_id].extended_id, intIfNum);
@@ -11271,12 +11274,12 @@
   if (leaf_out_vlan >= 1)
   {
     rc = ptin_xlate_egress_delete(intIfNum, int_vlan, leaf_inner_vlan);
     if (rc != L7_SUCCESS)
     {
-      PT_LOG_ERR(LOG_CTX_EVC, "Error deleting intf %u xlate Egress entry [Root Int.VLAN %u + Inn.VLAN %u (rc=%d)",
-              leaf_intf, int_vlan, leaf_inner_vlan, leaf_out_vlan, rc);
+      PT_LOG_ERR(LOG_CTX_EVC, "Error deleting intfIfNum %u xlate Egress entry [Root Int.VLAN %u + Inn.VLAN %u (rc=%d)",
+              intIfNum, int_vlan, leaf_inner_vlan, rc);
       return L7_FAILURE;
     }
   }
   else
   {
@@ -11371,12 +11374,12 @@
   if (leaf_out_vlan >= 1)
   {
     rc = ptin_xlate_egress_delete(intIfNum, int_vlan, 0); 
     if (rc != L7_SUCCESS)
     {
-      PT_LOG_ERR(LOG_CTX_EVC, "Error deleting intf %u xlate Egress entry [Root Int.VLAN %u (rc=%d)",
-              leaf_intf, int_vlan, leaf_out_vlan, rc);
+      PT_LOG_ERR(LOG_CTX_EVC, "Error deleting intfIfNum %u xlate Egress entry [Root Int.VLAN %u (rc=%d)",
+              intIfNum, int_vlan, rc);
       return L7_FAILURE;
     }
   }
   else
   {
@@ -12260,11 +12263,11 @@
             if (profile->outer_vlan_lookup!=pclientFlow->uni_ovid)
             {
               PT_LOG_ERR(LOG_CTX_EVC,"OVid_in %u does not match to the one in EVC client (%u)", profile->outer_vlan_lookup, pclientFlow->uni_ovid);
               return L7_FAILURE;
             }
-            PT_LOG_TRACE(LOG_CTX_EVC,"OVid_in %u verified for client %u",ptin_port,profile->outer_vlan_lookup,profile->inner_vlan_ingress);
+            PT_LOG_TRACE(LOG_CTX_EVC,"OVid_in %u verified for client %u", profile->outer_vlan_lookup, profile->inner_vlan_ingress);
           }
           /* Removed: for non QUATTRO services, these vlans should be null */
           //profile->outer_vlan_out = pclientFlow->uni_ovid;
           //profile->inner_vlan_out = 0;                /* There is no inner vlan, after packet leaves the port (leaf port in a stacked service) */
         }
@@ -12423,11 +12426,11 @@
           if (profile->outer_vlan_lookup!=pclientFlow->uni_ovid)
           {
             PT_LOG_ERR(LOG_CTX_EVC,"OVid_in %u does not match to the one in EVC client (%u)",profile->outer_vlan_lookup,pclientFlow->uni_ovid);
             return L7_FAILURE;
           }
-          PT_LOG_TRACE(LOG_CTX_EVC,"OVid_in %u verified for client %u",ptin_port,profile->outer_vlan_lookup,profile->inner_vlan_ingress);
+          PT_LOG_TRACE(LOG_CTX_EVC,"OVid_in %u verified for client %u", profile->outer_vlan_lookup, profile->inner_vlan_ingress);
         }
         profile->outer_vlan_egress = pclientFlow->uni_ovid;
         profile->inner_vlan_egress = 0;                /* No need to consider inner vlan at the egress */
       }
     } /* else (profile->inner_vlan_in==0) */
Index: src/application/ptin/base/ptin_fieldproc.c
===================================================================
--- src/application/ptin/base/ptin_fieldproc.c	(revision 6677)
+++ src/application/ptin/base/ptin_fieldproc.c	(working copy)
@@ -185,11 +185,11 @@
         {
           ptin_port_bmp = lagInfo.members_pbmp64;
         }
         else
         {
-          PT_LOG_ERR(LOG_CTX_API, "ptin_port %u (LAG) does not have members", intIfNum, profile->ptin_port);
+          PT_LOG_ERR(LOG_CTX_API, "ptin_port %u (LAG) does not have members", profile->ptin_port);
           return L7_FAILURE;
         }
       }
       else
       {
Index: src/application/ptin/base/ptin_igmp.c
===================================================================
--- src/application/ptin/base/ptin_igmp.c	(revision 6660)
+++ src/application/ptin/base/ptin_igmp.c	(working copy)
@@ -2688,11 +2688,11 @@
       memset(&igmpInstances[igmp_idx], 0x00, sizeof(st_IgmpInstCfg_t));
     ptin_evc_igmpInst_set(evc_idx, IGMP_INVALID_ENTRY);
     return L7_FAILURE;
   }
 
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Going to enable trap rule of igmp_idx=%u",evc_idx, igmp_idx);
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Going to enable trap rule of igmp_idx=%u", igmp_idx);
 
   /* Trap rule */
 #if PTIN_QUATTRO_FLOWS_FEATURE_ENABLED
   if (evc_type != PTIN_EVC_TYPE_QUATTRO_STACKED || igmp_quattro_stacked_evcs == 0)
 #endif
@@ -2745,11 +2745,11 @@
   }
 
   /* Check if there is an instance with these parameters */
   if ( ptin_igmp_instance_find(evc_idx, 0 /*Not used*/, &igmp_idx)!=L7_SUCCESS )
   {
-    PT_LOG_WARN(LOG_CTX_IGMP,"There is no instance with [mcEvcId,ucEvcId]=[%u,%u]",evc_idx);
+    PT_LOG_WARN(LOG_CTX_IGMP,"There is no instance with EvcId=%u", evc_idx);
     return L7_SUCCESS;
   }
 
   /* Get EVC type */
   if (ptin_evc_check_evctype(evc_idx, &evc_type) != L7_SUCCESS)
@@ -3348,11 +3348,11 @@
       PT_LOG_DEBUG(LOG_CTX_IGMP, "Response");
       PT_LOG_DEBUG(LOG_CTX_IGMP, "  CTRL Msg Code            : %08X",      ctrlResMsg.msgCode);
       PT_LOG_DEBUG(LOG_CTX_IGMP, "  CTRL Msg Id              : %08X",      ctrlResMsg.msgId);
       PT_LOG_DEBUG(LOG_CTX_IGMP, "  CTRL Res                 : %u",        ctrlResMsg.res);
       PT_LOG_DEBUG(LOG_CTX_IGMP, "  CTRL Length              : %u", ctrlResMsg.dataLength);
-      PT_LOG_DEBUG(LOG_CTX_IGMP, "  Entry Length             : %u", sizeof(PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t), ctrlResMsg.dataLength/sizeof(PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t));
+      PT_LOG_DEBUG(LOG_CTX_IGMP, "  Entry Length             : %u", sizeof(PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t));
       PT_LOG_DEBUG(LOG_CTX_IGMP, "  Number Of Entries Length : %u", ctrlResMsg.dataLength/sizeof(PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t));
 
       if (0 != ctrlResMsg.dataLength%sizeof(PTIN_MGMD_CTRL_GROUPCLIENTS_RESPONSE_t))
       {
         if (ctrlResMsg.res==NOT_EXIST)
@@ -7035,11 +7035,12 @@
   }
 
   osapiSemaGive(ptin_igmp_timers_sem);
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer Started: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p timeout=%u (s)", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer Started: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u timeout=%u (s)",
+                 ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
 
   return L7_SUCCESS;
 }
 
 /**
@@ -7093,29 +7094,32 @@
 
   if (pTimerData->timer == L7_NULL)
   {
     osapiSemaGive(ptin_igmp_timers_sem);
     if (ptin_debug_igmp_snooping)
-      PT_LOG_ERR(LOG_CTX_IGMP,"Client timer not running: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle:%p", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
+      PT_LOG_ERR(LOG_CTX_IGMP,"Client timer not running: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle:%u",
+                 ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
     return L7_FAILURE;
   }
 
   timeout = (igmpProxyCfg.querier.group_membership_interval*3)/2;
 
   if (appTimerUpdate(igmpDeviceClients.timerCB, pTimerData->timer,
                      L7_NULLPTR, L7_NULLPTR, timeout,
                      "PTIN_TIMER") != L7_SUCCESS)
   {
     osapiSemaGive(ptin_igmp_timers_sem);
-    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to update client timer: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p timeout=%u (s)", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to update client timer: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u timeout=%u (s)",
+               ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
     return L7_FAILURE;
   }
 
   osapiSemaGive(ptin_igmp_timers_sem);
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer Updated: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p timeout=%u (s)", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer Updated: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u timeout=%u (s)",
+                 ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
 
   return L7_SUCCESS;
 }
 
 /**
@@ -7168,18 +7172,18 @@
 
   if (pTimerData->timer == L7_NULL)
   {
     osapiSemaGive(ptin_igmp_timers_sem);
     if (ptin_debug_igmp_snooping)
-      PT_LOG_ERR(LOG_CTX_IGMP,"Client timer not running: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
+      PT_LOG_ERR(LOG_CTX_IGMP,"Client timer not running: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
     return L7_FAILURE;
   }
 
   appTimerTimeLeftGet(igmpDeviceClients.timerCB, pTimerData->timer, &time_left);
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Client Timer TimeOut: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p time_left=%u (s))", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, time_left);
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Client Timer TimeOut: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u time_left=%u (s))", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle, time_left);
 
   osapiSemaGive(ptin_igmp_timers_sem);
 
   return time_left;
 }
@@ -7224,18 +7228,18 @@
   /* Remove node for SLL list */
   if (SLLDelete(&igmpDeviceClients.ll_timerList, (L7_sll_member_t *)&timerData) != L7_SUCCESS)
   {
     osapiSemaGive(ptin_igmp_timers_sem);
     if (ptin_debug_igmp_snooping)
-      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p", ptin_port, client_idx, igmpDeviceClients.timerCB, timerData.timer, timerData.timerHandle);
+      PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node: ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u", ptin_port, client_idx, igmpDeviceClients.timerCB, timerData.timer, timerData.timerHandle);
     return L7_FAILURE;
   }
 
   osapiSemaGive(ptin_igmp_timers_sem);
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer stopped successfully for ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p", ptin_port, client_idx, igmpDeviceClients.timerCB, timerData.timer, timerData.timerHandle);
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Timer stopped successfully for ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u", ptin_port, client_idx, igmpDeviceClients.timerCB, timerData.timer, timerData.timerHandle);
 
   return L7_SUCCESS;
 }
 
 /*************************************************************************
@@ -7256,11 +7260,11 @@
   L7_uint ptin_port, client_idx;
 
   igmpTimerData_t *pTimerData;
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP,"Expiration event ocurred for timerHandle %p!",timerHandle);
+    PT_LOG_TRACE(LOG_CTX_IGMP,"Expiration event ocurred for timerHandle %u!",timerHandle);
 
   osapiSemaTake(ptin_igmp_clients_sem, L7_WAIT_FOREVER);
   osapiSemaTake(ptin_igmp_timers_sem, L7_WAIT_FOREVER);
 
   /* Get timer handler */
@@ -7282,11 +7286,11 @@
   /* Save client information */
   ptin_port  = PTIN_IGMP_CLIENT_PORT(pTimerData->ptin_port);
   client_idx = pTimerData->client_idx;
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP,"Expiration event ocurred for ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%p", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
+    PT_LOG_TRACE(LOG_CTX_IGMP,"Expiration event ocurred for ptin_port=%u client_idx=%u timerCB=%p timer=%p timerHandle=%u", ptin_port, client_idx, igmpDeviceClients.timerCB, pTimerData->timer, pTimerData->timerHandle);
 
 #if 0
   /* Delete timer */
   if (appTimerDelete(igmpClients_unified.timerCB, pTimerData->timer)!=L7_SUCCESS)
   {
@@ -7857,11 +7861,11 @@
     if (inetIsAddressZero(channel_group) != L7_TRUE)
     {
       //Only IPv4 is supported!
       if (channel_group->family!=L7_AF_INET || channel_source->family!=L7_AF_INET)
       {
-        PT_LOG_ERR(LOG_CTX_IGMP,"IPv6 not supported for MGMD [UC_EVC=%u MC_EVC]",evc_uc,evc_mc);
+        PT_LOG_ERR(LOG_CTX_IGMP,"IPv6 not supported for MGMD [UC_EVC=%u MC_EVC=%u]", evc_uc, evc_mc);
         return L7_FAILURE;                       
       }
       if (L7_SUCCESS != ptin_igmp_mgmd_whitelist_add(evc_mc,channel_group->addr.ipv4.s_addr,channel_grpMask,channel_source->addr.ipv4.s_addr, channel_srcMask,channelBandwidth))
       {
         PT_LOG_ERR(LOG_CTX_IGMP,"Unable to create requested entry in the whitelist");
@@ -8111,11 +8115,12 @@
   L7_uchar8 maxMasklen;
 
   /*Validate Input Parameters*/
   if (channel_in == L7_NULLPTR || channel_out == L7_NULLPTR || number_of_channels == L7_NULLPTR)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Invalid Input Arguments: channel_in:%p channel_out:%p number_of_channels:%p");
+    PT_LOG_ERR(LOG_CTX_IGMP,"Invalid Input Arguments: channel_in:%p channel_out:%p number_of_channels:%p",
+               (void*)channel_in, (void*)channel_out, (void*)number_of_channels);
     return L7_FAILURE;
   }
 
   if ( L7_SUCCESS != ptin_igmp_max_mask_size(channel_in->family, &maxMasklen) )
   {
@@ -14177,16 +14182,18 @@
 RC_t ptin_igmp_admission_control_port_set(L7_uint32 ptin_port, L7_uint8 mask, L7_uint16 maxAllowedChannels, L7_uint64 maxAllowedBandwidth)  
 {
   /*Input Parameters Validation*/
   if (ptin_port >= PTIN_SYSTEM_N_UPLINK_INTERF)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%ull]",ptin_port, mask, maxAllowedChannels, maxAllowedBandwidth);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%llu]",
+               ptin_port, mask, maxAllowedChannels, maxAllowedBandwidth);    
     return L7_FAILURE;
   }
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Input arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%ull]",ptin_port, mask, maxAllowedChannels, maxAllowedBandwidth);
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Input arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%llu]",
+                 ptin_port, mask, maxAllowedChannels, maxAllowedBandwidth);
 
   if ( (mask & PTIN_IGMP_ADMISSION_CONTROL_MASK_MAX_ALLOWED_CHANNELS) == PTIN_IGMP_ADMISSION_CONTROL_MASK_MAX_ALLOWED_CHANNELS)
   {
     if (maxAllowedChannels == PTIN_IGMP_ADMISSION_CONTROL_MAX_CHANNELS_DISABLE) /*Disable this Parameter*/
     {
@@ -14215,11 +14222,15 @@
       igmpPortAdmissionControl[ptin_port].admissionControl.mask |= PTIN_IGMP_ADMISSION_CONTROL_MASK_MAX_ALLOWED_BANDWIDTH;
     }
   }
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Output arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%ull]",ptin_port, igmpPortAdmissionControl[ptin_port].admissionControl.mask, igmpPortAdmissionControl[ptin_port].admissionControl.maxAllowedChannels, igmpPortAdmissionControl[ptin_port].admissionControl.maxAllowedBandwidth);
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Output arguments [ptin_port:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%u]",
+                 ptin_port, 
+                 igmpPortAdmissionControl[ptin_port].admissionControl.mask, 
+                 igmpPortAdmissionControl[ptin_port].admissionControl.maxAllowedChannels, 
+                 igmpPortAdmissionControl[ptin_port].admissionControl.maxAllowedBandwidth);
 
   return L7_SUCCESS;
 }
 
 /**
@@ -14490,16 +14501,17 @@
   }
 
   if (igmpAdmissionControl->ptin_port >= PTIN_SYSTEM_N_UPLINK_INTERF || igmpAdmissionControl->onuId > PTIN_SYSTEM_IGMP_MAXONUS_PER_INTF || igmpAdmissionControl->mask > PTIN_IGMP_ADMISSION_CONTROL_MASK_VALID ||
       ((L7_uint8) -1) == (internalServiceId = ptin_igmp_admission_control_multicast_internal_id_get(igmpAdmissionControl->serviceId)) || internalServiceId >= PTIN_IGMP_MAX_MULTICAST_INTERNAL_SERVICE_ID)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [ptin_port:%u onuId:%u serviceId:%u internalServiceId:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%ull]",igmpAdmissionControl->ptin_port, igmpAdmissionControl->onuId, igmpAdmissionControl->serviceId, internalServiceId, igmpAdmissionControl->mask, igmpAdmissionControl->maxAllowedChannels, igmpAdmissionControl->maxAllowedBandwidth);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [ptin_port:%u onuId:%u serviceId:%u internalServiceId:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%llu]",
+               igmpAdmissionControl->ptin_port, igmpAdmissionControl->onuId, igmpAdmissionControl->serviceId, internalServiceId, igmpAdmissionControl->mask, igmpAdmissionControl->maxAllowedChannels, igmpAdmissionControl->maxAllowedBandwidth);    
     return L7_FAILURE;
   }
 
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Arguments [ptin_port:%u onuId:%u serviceId:%u internalServiceId:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%ull]",igmpAdmissionControl->ptin_port, igmpAdmissionControl->onuId, igmpAdmissionControl->serviceId, internalServiceId, igmpAdmissionControl->mask, igmpAdmissionControl->maxAllowedChannels, igmpAdmissionControl->maxAllowedBandwidth);
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Arguments [ptin_port:%u onuId:%u serviceId:%u internalServiceId:%u mask:0x%x maxAllowedChannels:%u maxAllowedBandwidth:%llu]",igmpAdmissionControl->ptin_port, igmpAdmissionControl->onuId, igmpAdmissionControl->serviceId, internalServiceId, igmpAdmissionControl->mask, igmpAdmissionControl->maxAllowedChannels, igmpAdmissionControl->maxAllowedBandwidth);
 
   if ( (igmpAdmissionControl->mask & PTIN_IGMP_ADMISSION_CONTROL_MASK_MAX_ALLOWED_CHANNELS) == PTIN_IGMP_ADMISSION_CONTROL_MASK_MAX_ALLOWED_CHANNELS)
   {
     if (igmpAdmissionControl->maxAllowedChannels == PTIN_IGMP_ADMISSION_CONTROL_MAX_CHANNELS_DISABLE) /*Disable this Parameter*/
     {
@@ -16608,12 +16620,12 @@
   }
 
   for (evc_idx=0; evc_idx<PTIN_SYSTEM_N_EXTENDED_EVCS; evc_idx++)
   {
     /* Print this? */
-    if (evc_idx>0)
-      continue;
+//    if (evc_idx>0 && evc_idx!=evc_idx)
+//      continue;
 
     /* EVC must be active */
     if (!ptin_evc_is_in_use(evc_idx))
     {
       if (evc_idx>0)
@@ -17711,17 +17723,18 @@
 static RC_t queue_channel_entry_find(L7_uint32 packageId, ptinIgmpChannelInfoData_t *channelAvlTreeEntry, struct channelPoolEntry_s **channelEntry)
 {
   /* Input Argument validation */
   if ( packageId >= PTIN_SYSTEM_IGMP_MAXPACKAGES || channelAvlTreeEntry == L7_NULLPTR  || channelEntry ==  L7_NULLPTR)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u channelAvlTreeEntry:%p channelEntry:%u]", packageId, channelAvlTreeEntry, channelEntry);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u channelAvlTreeEntry:%p channelEntry:%p]",
+               packageId, channelAvlTreeEntry, channelEntry);    
     return L7_FAILURE;
   }
 
   /*Input Parameters*/
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [packageId:%u channelAvlTreeEntry:%p channelEntry:%u]",
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [packageId:%u channelAvlTreeEntry:%p channelEntry:%p]",
               packageId, channelAvlTreeEntry, channelEntry);
 
   if (multicastPackage[packageId].queueChannel.n_elems != 0)
   {
     *channelEntry = (struct channelPoolEntry_s*) multicastPackage[packageId].queueChannel.head;
@@ -17962,17 +17975,18 @@
 static RC_t queue_package_entry_find(L7_uint32 packageId, ptinIgmpChannelInfoData_t *channelAvlTreeEntry, struct packagePoolEntry_s  **packageEntry )
 {
   /* Input Argument validation */
   if ( packageId >= PTIN_SYSTEM_IGMP_MAXPACKAGES || channelAvlTreeEntry == L7_NULLPTR  || packageEntry ==  L7_NULLPTR)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u channelAvlTreeEntry:%p channelEntry:%u]", packageId, channelAvlTreeEntry, packageEntry);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u channelAvlTreeEntry:%p packageEntry:%p]",
+               packageId, channelAvlTreeEntry, packageEntry);    
     return L7_FAILURE;
   }
 
   /*Input Parameters*/
   if (ptin_debug_igmp_snooping)
-    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [packageId:%u channelAvlTreeEntry:%p channelEntry:%u]",
+    PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [packageId:%u channelAvlTreeEntry:%p packageEntry:%p]",
               packageId, channelAvlTreeEntry, packageEntry);
 
   if (channelAvlTreeEntry->queuePackage.n_elems != 0)
   {
     *packageEntry = (struct packagePoolEntry_s*) channelAvlTreeEntry->queuePackage.head;
@@ -18595,11 +18609,12 @@
     PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [ptinPort:%u deviceClientId:%u groupAddr:%s sourceAddr:%s serviceId:%p]",
               ptinPort, deviceClientId, inetAddrPrint(groupAddr, groupAddrStr), inetAddrPrint(sourceAddr, sourceAddrStr), serviceId);
 
   if ( (groupClient = deviceClientId2groupClientPtr(ptinPort, deviceClientId)) == L7_NULLPTR)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Obtain groupClient [ptinPort:%u deviceClientId:%u serviceId:%u groupAddr:%p sourceAddr:%p serviceId:%p groupClient:%p]",ptinPort, deviceClientId, groupAddr, sourceAddr, serviceId, groupClient);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Obtain groupClient [ptinPort:%u deviceClientId:%u serviceId:%u groupAddr:%p sourceAddr:%p serviceId:%p groupClient:%p]",
+               ptinPort, deviceClientId, *serviceId, groupAddr, sourceAddr, serviceId, groupClient);    
     return L7_FAILURE;
   }
 
   /*Save the ONU Id*/
   onuId = groupClient->onuId;
@@ -18658,12 +18673,20 @@
       /*Next Multicast Service*/      
       continue;      
     }
     else if (rc != L7_SUCCESS || channelEntry == L7_NULLPTR )
     {
-      PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Search Channel Entry [ptinPort:%u deviceClientId:%u onuId:%u serviceId:%u groupAddr:%p sourceAddr:%p serviceId:%u internalServiceId:%u noOfMulticastServices:%u]", 
-              ptinPort, deviceClientId, onuId, inetAddrPrint(groupAddr, groupAddrStr), inetAddrPrint(sourceAddr, sourceAddrStr), serviceIdAux, internalServiceId, multicastServices[ptinPort][onuId].noOfMulticastServices);    
+      PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Search Channel Entry:");
+      PT_LOG_ERR(LOG_CTX_IGMP, "  ptinPort:       %u", ptinPort);
+      PT_LOG_ERR(LOG_CTX_IGMP, "  deviceClientId: %u", deviceClientId);
+      PT_LOG_ERR(LOG_CTX_IGMP, "  onuId:          %u", onuId);
+      PT_LOG_ERR(LOG_CTX_IGMP, "  serviceId:      %u", serviceIdAux);
+      PT_LOG_ERR(LOG_CTX_IGMP, "  groupAddr:      %p", inetAddrPrint(groupAddr, groupAddrStr));
+      PT_LOG_ERR(LOG_CTX_IGMP, "  sourceAddr:     %p", inetAddrPrint(sourceAddr, sourceAddrStr));
+      PT_LOG_ERR(LOG_CTX_IGMP, "  intServiceId:   %u", internalServiceId);
+      PT_LOG_ERR(LOG_CTX_IGMP, "  Nr MC Services: %u", multicastServices[ptinPort][onuId].noOfMulticastServices);
+
       return L7_FAILURE;
     }
 
     /* Is clientId Not Set in the client bitmap */
     if (IS_BITMAP_BIT_SET(channelEntry->groupClientBmpPerPort[ptinPort], groupClientId, UINT32_BITSIZE) == L7_FALSE)
@@ -19392,18 +19415,19 @@
 RC_t ptin_igmp_multicast_client_package_get(L7_uint32 packageId, ptinIgmpGroupClientInfoData_t *groupClient, L7_BOOL *isBitSet)
 {
   /* Input Argument validation */
   if ( packageId >= PTIN_SYSTEM_IGMP_MAXPACKAGES || groupClient == L7_NULLPTR  || isBitSet == L7_NULLPTR )
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u groupClient:%p isBitSet:%p]",packageId, groupClient);    
+    PT_LOG_ERR(LOG_CTX_IGMP, "Invalid arguments [packageId:%u groupClient:%p isBitSet:%p]",
+               packageId, groupClient, isBitSet);
     return L7_FAILURE;
   }
 
   /*Input Parameters*/
   if (ptin_debug_igmp_snooping)
     PT_LOG_TRACE(LOG_CTX_IGMP, "Input Parameters [packageId:%u groupClient:%p isBitSet:%p]",
-              packageId, groupClient);
+                packageId, groupClient, isBitSet);
 
   /*Let us Check if this Package is Configured*/
   if (multicastPackage[packageId].inUse == L7_FALSE )
   {
     PT_LOG_ERR(LOG_CTX_IGMP, "This package does not exist [packageId:%u]", packageId);    
@@ -19623,22 +19647,22 @@
   }
 
   while ( L7_NULLPTR != (channelEntry = queue_channel_entry_get_next(packageId, channelEntry)) && 
           L7_NULLPTR != (channelAvlTreeEntryAux = channelEntry->channelAvlTreeEntry) )
   {
-    if ( channelAvlTreeEntryAux->channelDataKey.evc_mc == channelEntry->channelAvlTreeEntry->channelDataKey.evc_mc)
+    if (channelAvlTreeEntryAux->channelDataKey.evc_mc == channelEntry->channelAvlTreeEntry->channelDataKey.evc_mc)
     {
       /*Move to next Channel*/
       continue;
     }
 
     if ( (L7_INET_ADDR_COMPARE(&channelAvlTreeEntryAux->channelDataKey.channel_group, 
                                &channelAvlTreeEntryAux->channelDataKey.channel_group) == 0) &&
          (L7_INET_ADDR_COMPARE(&channelAvlTreeEntryAux->channelDataKey.channel_source, 
                                &channelAvlTreeEntryAux->channelDataKey.channel_source) == 0) )
     {
-      PT_LOG_ERR(LOG_CTX_IGMP,"Conflict Found: Channel configured within two services [packageId:%u serviceId:%u groupAddr:%s sourceAddr:%s][serviceIdNew:]",
+      PT_LOG_ERR(LOG_CTX_IGMP,"Conflict Found: Channel configured within two services [packageId:%u serviceId:%u groupAddr:%s sourceAddr:%s][serviceIdNew:%u]",
               packageId, channelAvlTreeEntry->channelDataKey.evc_mc, 
               inetAddrPrint(&channelAvlTreeEntry->channelDataKey.channel_group, groupAddrStr), inetAddrPrint(&channelAvlTreeEntry->channelDataKey.channel_source, sourceAddrStr),
               channelAvlTreeEntryAux->channelDataKey.evc_mc);    
       return L7_FAILURE;
     }
Index: src/application/ptin/base/ptin_intf.c
===================================================================
--- src/application/ptin/base/ptin_intf.c	(revision 6677)
+++ src/application/ptin/base/ptin_intf.c	(working copy)
@@ -781,11 +781,11 @@
   PT_LOG_TRACE(LOG_CTX_INTF," egress_type = %u"                 , mefExt->egress_type);
   PT_LOG_TRACE(LOG_CTX_INTF," macLearn_enable = %u"             , mefExt->macLearn_enable);
   PT_LOG_TRACE(LOG_CTX_INTF," macLearn_stationMove_enable = %u" , mefExt->macLearn_stationMove_enable);
   PT_LOG_TRACE(LOG_CTX_INTF," macLearn_stationMove_prio   = %u" , mefExt->macLearn_stationMove_prio);
   PT_LOG_TRACE(LOG_CTX_INTF," Max Channels      = %u"           , mefExt->maxChannels);
-  PT_LOG_TRACE(LOG_CTX_INTF," Max Bandwidth     = %u"           , mefExt->maxBandwidth);
+  PT_LOG_TRACE(LOG_CTX_INTF," Max Bandwidth     = %llu"         , mefExt->maxBandwidth);
   PT_LOG_TRACE(LOG_CTX_INTF," Interface trusted = %u"           , mefExt->dhcp_trusted);
 
   PT_LOG_TRACE(LOG_CTX_INTF, "Success getting MEF Ext of port %u/%u", ptin_intf->intf_type,ptin_intf->intf_id);
 
   return L7_SUCCESS;
@@ -4825,11 +4825,11 @@
   PT_LOG_TRACE(LOG_CTX_INTF,"Mask         = 0x%02x",intfQos->mask);
   PT_LOG_TRACE(LOG_CTX_INTF,"TrustMode    = %u",intfQos->trust_mode);
   PT_LOG_TRACE(LOG_CTX_INTF,"BWunits      = %u",intfQos->bandwidth_unit);
   PT_LOG_TRACE(LOG_CTX_INTF,"ShapingRate  = %u",intfQos->shaping_rate);
   PT_LOG_TRACE(LOG_CTX_INTF,"WREDDecayExp = %u",intfQos->wred_decay_exponent);
-  PT_LOG_TRACE(LOG_CTX_INTF,"PrioMap.mask   =0x%02x",intfQos->pktprio.mask);
+  PT_LOG_TRACE(LOG_CTX_INTF,"PrioMap.mask   =0x%02x", (L7_uint32)intfQos->pktprio.mask);
   PT_LOG_TRACE(LOG_CTX_INTF,"PrioMap.prio[8]={0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x}",
             intfQos->pktprio.cos[0],
             intfQos->pktprio.cos[1],
             intfQos->pktprio.cos[2],
             intfQos->pktprio.cos[3],
Index: src/application/ptin/base/ptin_l2.c
===================================================================
--- src/application/ptin/base/ptin_l2.c	(revision 6677)
+++ src/application/ptin/base/ptin_l2.c	(working copy)
@@ -279,14 +279,15 @@
     if (intfType==L7_VLAN_PORT_INTF) {
         intf_vp_entry_t   e;
 
         e.vport_id = fdbEntry.dot1dTpFdbVirtualPort;
         if (intf_vp_DB(3, &e)) {
-            PT_LOG_WARN(LOG_CTX_L2,"PON&GEMid for intIfNum %lu / vport %lu not found",fdbEntry.dot1dTpFdbPort,fdbEntry.dot1dTpFdbVirtualPort);
+            PT_LOG_WARN(LOG_CTX_L2,"PON&GEMid for intIfNum %u / vport %u not found",
+                        fdbEntry.dot1dTpFdbPort, fdbEntry.dot1dTpFdbVirtualPort);
             continue;
         }
-        else PT_LOG_TRACE(LOG_CTX_L2,"intIfNum %lu / vport %u, PON=%u/%u GEMid=%u",
+        else PT_LOG_TRACE(LOG_CTX_L2,"intIfNum %u / vport %u, PON=%u/%u GEMid=%u",
                        fdbEntry.dot1dTpFdbPort, fdbEntry.dot1dTpFdbVirtualPort, e.pon.intf_type, e.pon.intf_id, e.gem_id);
         ptin_intf = e.pon;
         gem_id    = e.gem_id;
     }
     else
Index: src/application/ptin/base/ptin_msg.c
===================================================================
--- src/application/ptin/base/ptin_msg.c	(revision 6677)
+++ src/application/ptin/base/ptin_msg.c	(working copy)
@@ -1308,12 +1308,12 @@
   msgPhyStatus->phy.alarmes       = ENDIAN_SWAP32(msgPhyStatus->phy.alarmes);
   msgPhyStatus->phy.alarmes_mask  = ENDIAN_SWAP32(msgPhyStatus->phy.alarmes_mask);
 
   /* Output info read */
   PT_LOG_DEBUG(LOG_CTX_MSG, "Port # %u",                   ENDIAN_SWAP8 (msgPhyStatus->Port));
-  PT_LOG_DEBUG(LOG_CTX_MSG, " alarmes          = 0x%04X",  ENDIAN_SWAP32(msgPhyStatus->phy.alarmes));
-  PT_LOG_DEBUG(LOG_CTX_MSG, " alarmes_mask     = 0x%04X",  ENDIAN_SWAP32(msgPhyStatus->phy.alarmes_mask));
+  PT_LOG_DEBUG(LOG_CTX_MSG, " alarmes          = 0x%04lX", ENDIAN_SWAP32(msgPhyStatus->phy.alarmes));
+  PT_LOG_DEBUG(LOG_CTX_MSG, " alarmes_mask     = 0x%04lX", ENDIAN_SWAP32(msgPhyStatus->phy.alarmes_mask));
 
   return L7_SUCCESS;
 }
 
 /**
@@ -1738,11 +1738,11 @@
       PT_LOG_ERR(LOG_CTX_MSG,"Error setting MEF EXT configurations");
       return L7_FAILURE;
     }
   }
 
-  PT_LOG_DEBUG(LOG_CTX_MSG, "Success setting MEF EXT configurations",__FUNCTION__);
+  PT_LOG_DEBUG(LOG_CTX_MSG, "Success setting MEF EXT configurations");
 
   return L7_SUCCESS;
 }
 
 /**
@@ -1879,11 +1879,11 @@
       PT_LOG_ERR(LOG_CTX_MSG,"Error setting MAC address");
       return L7_FAILURE;
     }
   }
 
-  PT_LOG_DEBUG(LOG_CTX_MSG, "Success setting MAC address",__FUNCTION__);
+  PT_LOG_DEBUG(LOG_CTX_MSG, "Success setting MAC address");
 
   return L7_SUCCESS;
 }
 
 /**
@@ -5232,11 +5232,11 @@
       }
       /* Get internal VLAN from eEVC# */
       dai_maxVlans = 1;
       if (ptin_evc_intRootVlan_get(item->service.id_val.evc_id, &dai_intVid_list[0]) != L7_SUCCESS)
       {
-        PT_LOG_ERR(LOG_CTX_MSG, "Cannot get intVlan from eEVC#%u!", item->service.id_val.evc_id, dai_intVid_list[0]);
+        PT_LOG_ERR(LOG_CTX_MSG, "Cannot get intVlan from eEVC#%u!", item->service.id_val.evc_id);
         rc_global = rc_global_failure = L7_FAILURE;
         continue;
       }
     }
     /* Use given VLANs range */
@@ -5359,14 +5359,14 @@
   for (i = 0; i < nElems; i++)
   {
     item = &msg_stats[i];
 
     PT_LOG_DEBUG(LOG_CTX_MSG,"Stats index %u:", i);
-    PT_LOG_DEBUG(LOG_CTX_MSG," SlotId       = %u", ENDIAN_SWAP8 (item->slotId));
-    PT_LOG_DEBUG(LOG_CTX_MSG," EVC id       = %u", ENDIAN_SWAP32(item->evc_idx));
-    PT_LOG_DEBUG(LOG_CTX_MSG," VLAN id      = %u", ENDIAN_SWAP16(item->vlan_id));
-    PT_LOG_DEBUG(LOG_CTX_MSG," Intf         = %u", ENDIAN_SWAP8 (item->intf.intf_type), ENDIAN_SWAP8 (item->intf.intf_id));
+    PT_LOG_DEBUG(LOG_CTX_MSG," SlotId       = %u",    ENDIAN_SWAP8 (item->slotId));
+    PT_LOG_DEBUG(LOG_CTX_MSG," EVC id       = %u",    ENDIAN_SWAP32(item->evc_idx));
+    PT_LOG_DEBUG(LOG_CTX_MSG," VLAN id      = %u",    ENDIAN_SWAP16(item->vlan_id));
+    PT_LOG_DEBUG(LOG_CTX_MSG," Intf         = %u/%u", ENDIAN_SWAP8 (item->intf.intf_type), ENDIAN_SWAP8 (item->intf.intf_id));
 
     /* Clear list of VLANs */
     memset(dai_intVid_list, 0x00, sizeof(dai_intVid_list));
     dai_maxVlans = 0;
 
@@ -5951,15 +5951,16 @@
       ptinEvcConf.intf[index_port].vid         = ENDIAN_SWAP16(msgEvcConf->evc.intf[i].vid);
       ptinEvcConf.intf[index_port].vid_inner   = ENDIAN_SWAP16(msgEvcConf->evc.intf[i].inner_vid);
       ptinEvcConf.intf[index_port].action_outer= PTIN_XLATE_ACTION_REPLACE;
       ptinEvcConf.intf[index_port].action_inner= PTIN_XLATE_ACTION_NONE;
 
-      PT_LOG_DEBUG(LOG_CTX_MSG, "   %s %02u %s VID=%04u/%-04u",
-         ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_type == PTIN_EVC_INTF_PHYSICAL ? "PHY":"LAG",
-         ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_id,
-         ptinEvcConf.intf[index_port].mef_type == PTIN_EVC_INTF_ROOT ? "Root":"Leaf",
-         ptinEvcConf.intf[index_port].vid,ptinEvcConf.intf[i].vid_inner);
+      PT_LOG_DEBUG(LOG_CTX_MSG, "   %s %02u %s VID=%04u/%-4u",
+                   ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_type == PTIN_EVC_INTF_PHYSICAL ? "PHY":"LAG",
+                   ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_id,
+                   ptinEvcConf.intf[index_port].mef_type == PTIN_EVC_INTF_ROOT ? "Root":"Leaf",
+                   ptinEvcConf.intf[index_port].vid,
+                   ptinEvcConf.intf[i].vid_inner);
       PT_LOG_DEBUG(LOG_CTX_MSG, "PTIN_INTF_TYPE_DEBUG: %u", ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_type);
 
 #ifdef NGPON2_SUPPORTED
       /* If is a physical port apply the EVC */
       if ( ptinEvcConf.intf[index_port].intf.value.ptin_intf.intf_type == PTIN_EVC_INTF_PHYSICAL )
@@ -6211,11 +6212,11 @@
     else
     {
       evc_id = ENDIAN_SWAP32(msgEvcQoS[i].id.id_val.evc_id);
       if (ptin_evc_get_NNIvlan_fromEvcId(evc_id, &nni_vlan) != L7_SUCCESS)
       {
-        PT_LOG_ERR(LOG_CTX_MSG, "Error obtaining NNI_VLAN %u from EVC %u", evc_id);
+        PT_LOG_ERR(LOG_CTX_MSG, "Error obtaining NNI_VLAN from EVC %u", evc_id);
         return L7_NOT_EXIST;
       }
     }
 
     /* Get EVC flags */
@@ -7667,13 +7668,13 @@
   }
 
   PT_LOG_DEBUG(LOG_CTX_MSG," slotId = %u",          ENDIAN_SWAP8 (msgStormControl->SlotId));
   PT_LOG_DEBUG(LOG_CTX_MSG," intf   = %u/%u",       ENDIAN_SWAP8 (msgStormControl->intf.intf_type), ENDIAN_SWAP8 (msgStormControl->intf.intf_id));
   PT_LOG_DEBUG(LOG_CTX_MSG," mask   = 0x%02x",      ENDIAN_SWAP8 (msgStormControl->mask));
-  PT_LOG_DEBUG(LOG_CTX_MSG," Broadcast = %ld (%u)", ENDIAN_SWAP32(msgStormControl->broadcast.rate_value),  ENDIAN_SWAP8 (msgStormControl->broadcast.rate_units));
-  PT_LOG_DEBUG(LOG_CTX_MSG," Multicast = %ld (%u)", ENDIAN_SWAP32(msgStormControl->multicast.rate_value),  ENDIAN_SWAP8 (msgStormControl->multicast.rate_units));
-  PT_LOG_DEBUG(LOG_CTX_MSG," UnknownUC = %ld (%u)", ENDIAN_SWAP32(msgStormControl->unknown_uc.rate_value), ENDIAN_SWAP8 (msgStormControl->unknown_uc.rate_units));
+  PT_LOG_DEBUG(LOG_CTX_MSG," Broadcast = %u (%u)",  ENDIAN_SWAP32(msgStormControl->broadcast.rate_value),  ENDIAN_SWAP8 (msgStormControl->broadcast.rate_units));
+  PT_LOG_DEBUG(LOG_CTX_MSG," Multicast = %u (%u)",  ENDIAN_SWAP32(msgStormControl->multicast.rate_value),  ENDIAN_SWAP8 (msgStormControl->multicast.rate_units));
+  PT_LOG_DEBUG(LOG_CTX_MSG," UnknownUC = %u (%u)",  ENDIAN_SWAP32(msgStormControl->unknown_uc.rate_value), ENDIAN_SWAP8 (msgStormControl->unknown_uc.rate_units));
   PT_LOG_DEBUG(LOG_CTX_MSG," Block UC = %u",        ENDIAN_SWAP8 (msgStormControl->block_unicast));
   PT_LOG_DEBUG(LOG_CTX_MSG," Block MC = %u",        ENDIAN_SWAP8 (msgStormControl->block_multicast));
 
   return L7_SUCCESS;
 }
@@ -7716,13 +7717,13 @@
   ENDIAN_SWAP8_MOD (msgStormControl->block_multicast);
 
   PT_LOG_DEBUG(LOG_CTX_MSG," slotId = %u",          msgStormControl->SlotId);
   PT_LOG_DEBUG(LOG_CTX_MSG," intf   = %u/%u",       msgStormControl->intf.intf_type, msgStormControl->intf.intf_id);
   PT_LOG_DEBUG(LOG_CTX_MSG," mask   = 0x%02x",      msgStormControl->mask);
-  PT_LOG_DEBUG(LOG_CTX_MSG," Broadcast = %ld (%u)", msgStormControl->broadcast.rate_value,  msgStormControl->broadcast.rate_units);
-  PT_LOG_DEBUG(LOG_CTX_MSG," Multicast = %ld (%u)", msgStormControl->multicast.rate_value,  msgStormControl->multicast.rate_units);
-  PT_LOG_DEBUG(LOG_CTX_MSG," UnknownUC = %ld (%u)", msgStormControl->unknown_uc.rate_value, msgStormControl->unknown_uc.rate_units);
+  PT_LOG_DEBUG(LOG_CTX_MSG," Broadcast = %u (%u)",  msgStormControl->broadcast.rate_value,  msgStormControl->broadcast.rate_units);
+  PT_LOG_DEBUG(LOG_CTX_MSG," Multicast = %u (%u)",  msgStormControl->multicast.rate_value,  msgStormControl->multicast.rate_units);
+  PT_LOG_DEBUG(LOG_CTX_MSG," UnknownUC = %u (%u)",  msgStormControl->unknown_uc.rate_value, msgStormControl->unknown_uc.rate_units);
   PT_LOG_DEBUG(LOG_CTX_MSG," Block UC = %u",        msgStormControl->block_unicast);
   PT_LOG_DEBUG(LOG_CTX_MSG," Block MC = %u",        msgStormControl->block_multicast);
 
   ptin_intf.intf_type = msgStormControl->intf.intf_type;
   ptin_intf.intf_id   = msgStormControl->intf.intf_id;
@@ -7731,21 +7732,21 @@
   if (PTIN_BOARD == PTIN_BOARD_TG16GF || PTIN_BOARD == PTIN_BOARD_OLT1T0F || PTIN_BOARD == PTIN_BOARD_TT04SXG)
   {
     if(msgStormControl->broadcast.rate_value == 1 && msgStormControl->broadcast.rate_units == 0 /* PPS */)
     {
       msgStormControl->broadcast.rate_value = 2;
-      PT_LOG_NOTICE(LOG_CTX_MSG," Broadcast = %ld (%u) (changed)", msgStormControl->broadcast.rate_value,  msgStormControl->broadcast.rate_units);
+      PT_LOG_NOTICE(LOG_CTX_MSG," Broadcast = %u (%u) (changed)", msgStormControl->broadcast.rate_value,  msgStormControl->broadcast.rate_units);
     }
     if(msgStormControl->multicast.rate_value == 1 && msgStormControl->multicast.rate_units == 0 /* PPS */)
     {
       msgStormControl->multicast.rate_value = 2;
-      PT_LOG_NOTICE(LOG_CTX_MSG," Multicast = %ld (%u) (changed)", msgStormControl->multicast.rate_value,  msgStormControl->multicast.rate_units);
+      PT_LOG_NOTICE(LOG_CTX_MSG," Multicast = %u (%u) (changed)", msgStormControl->multicast.rate_value,  msgStormControl->multicast.rate_units);
     }
     if(msgStormControl->unknown_uc.rate_value == 1 && msgStormControl->unknown_uc.rate_units == 0 /* PPS */)
     {
       msgStormControl->unknown_uc.rate_value = 2;
-      PT_LOG_NOTICE(LOG_CTX_MSG," UnknownUC = %ld (%u) (changed)", msgStormControl->unknown_uc.rate_value,  msgStormControl->unknown_uc.rate_units);
+      PT_LOG_NOTICE(LOG_CTX_MSG," UnknownUC = %u (%u) (changed)", msgStormControl->unknown_uc.rate_value,  msgStormControl->unknown_uc.rate_units);
     }
   }
 
   /* -------- BROADCAST STORMCONTROL -------- */
   if (msgStormControl->mask & MSG_STORMCONTROL_MASK_BCAST)
@@ -10591,11 +10592,11 @@
     PT_LOG_DEBUG(LOG_CTX_MSG, "   Client.IVlan = %u",     McastClient[i].client.inner_vlan);
     PT_LOG_DEBUG(LOG_CTX_MSG, "   Client.Intf  = %u/%u",  McastClient[i].client.intf.intf_type, McastClient[i].client.intf.intf_id);
 
     if (McastClient[i].mask > PTIN_MSG_IGMP_CLIENT_MASK_VALID)
     {
-      PT_LOG_ERR(LOG_CTX_MSG, "Invalid Mask [mask:0x%02x]",McastClient[i].mask, McastClient[i].maxBandwidth, McastClient[i].maxChannels);
+      PT_LOG_ERR(LOG_CTX_MSG, "Invalid Mask [mask:0x%02x]", McastClient[i].mask);
       return L7_FAILURE;
     }
 
 #if PTIN_SYSTEM_IGMP_ADMISSION_CONTROL_SUPPORT                                         
     if ( ( ( (McastClient[i].mask & PTIN_MSG_IGMP_CLIENT_MASK_MAX_ALLOWED_BANDWIDTH) == PTIN_MSG_IGMP_CLIENT_MASK_MAX_ALLOWED_BANDWIDTH ) &&
@@ -12353,11 +12354,12 @@
     return L7_FAILURE;
   }
   #endif
   snoopSyncRequest.portId = protTypebIntfConfig.pairIntfNum;
 
-  PT_LOG_DEBUG(LOG_CTX_MSG, "Sending Snoop Sync Request Message [groupAddr:%08X | serviceId:%u | portId:%u] to ipAddr:%08X to Sync the Remaining Snoop Entries", snoopSyncRequest.groupAddr, snoopSyncRequest.serviceId, snoopSyncRequest.portId, ipAddr);
+  PT_LOG_DEBUG(LOG_CTX_MSG, "Sending Snoop Sync Request Message [groupAddr:%08X | serviceId:%u | portId:%u] to ipAddr:%08X to Sync the Remaining Snoop Entries",
+               snoopSyncRequest.groupAddr.addr.ipv4, snoopSyncRequest.serviceId, snoopSyncRequest.portId, ipAddr);
 #endif
               
   
   /*Send the snoop sync request to the protection matrix */  
   if (send_ipc_message(IPC_HW_FASTPATH_PORT, ipAddr, CCMSG_MGMD_SNOOP_SYNC_REQUEST, (char *)(&snoopSyncRequest), NULL, sizeof(snoopSyncRequest), NULL) < 0)
@@ -12794,11 +12796,11 @@
     PT_LOG_DEBUG(LOG_CTX_MSG, " protIndex = %u",  protConf[i].protIndex);
     PT_LOG_DEBUG(LOG_CTX_MSG, " mask      = 0x%x",protConf[i].confMask);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.OperationMode     = %u", protConf[i].protParams.OperationMode);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.HoldOffTimer      = %u", protConf[i].protParams.HoldOffTimer);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.WaitToRestoreTimer= %u", protConf[i].protParams.WaitToRestoreTimer);
-    PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.alarmsEnFlag      = 0x%08x", protConf[i].protParams.alarmsEnFlag);
+    PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.alarmsEnFlag      = 0x%08lx", protConf[i].protParams.alarmsEnFlag);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.flags             = 0x%02x", protConf[i].protParams.flags);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.slotW/portW = %u/%u", protConf[i].protParams.slotW, protConf[i].protParams.portW);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.slotP/portP = %u/%u", protConf[i].protParams.slotP, protConf[i].protParams.portP);
 
     /* Validate index */
@@ -12948,11 +12950,11 @@
     PT_LOG_DEBUG(LOG_CTX_MSG, " protIndex = %u", protConf[i].protIndex);
     PT_LOG_DEBUG(LOG_CTX_MSG, " mask      = 0x%x", protConf[i].confMask);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.OperationMode     = %u", protConf[i].protParams.OperationMode);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.HoldOffTimer      = %u", protConf[i].protParams.HoldOffTimer);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.WaitToRestoreTimer= %u", protConf[i].protParams.WaitToRestoreTimer);
-    PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.alarmsEnFlag      = 0x%08x", protConf[i].protParams.alarmsEnFlag);
+    PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.alarmsEnFlag      = 0x%08lx", protConf[i].protParams.alarmsEnFlag);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.flags             = 0x%02x", protConf[i].protParams.flags);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.slotW/portW = %u/%u", protConf[i].protParams.slotW, protConf[i].protParams.portW);
     PT_LOG_DEBUG(LOG_CTX_MSG, " protParams.slotP/portP = %u/%u", protConf[i].protParams.slotP, protConf[i].protParams.portP);
 
     rc = L7_SUCCESS;
@@ -13475,11 +13477,11 @@
 
       /* Read number of PRBS errors */
       rc = ptin_pcs_prbs_errors_get(intIfNum, &rxStatus);
       if (rc != L7_SUCCESS)
       {
-        PT_LOG_ERR(LOG_CTX_MSG,"Error getting PRBS errors from port %u/%u", port);
+        PT_LOG_ERR(LOG_CTX_MSG,"Error getting PRBS errors from port %u", port);
         rc_global = rc;
         continue;
       }
 
       PT_LOG_TRACE(LOG_CTX_MSG,"Success getting PRBS errors from port %u", port);
@@ -13522,11 +13524,11 @@
 
       /* Read number of PRBS errors */
       rc = ptin_pcs_prbs_errors_get(intIfNum, &rxStatus);
       if (rc != L7_SUCCESS)
       {
-        PT_LOG_ERR(LOG_CTX_MSG,"Error getting PRBS errors from port %u/%u", port);
+        PT_LOG_ERR(LOG_CTX_MSG,"Error getting PRBS errors from port %u", port);
         rc_global = rc;
         continue;
       }
 
       PT_LOG_TRACE(LOG_CTX_MSG,"Success getting PRBS errors from port %u", port);
@@ -15963,11 +15965,11 @@
   /* Validate Session ID */
   sessionNum = 1; // msg->sessionId;
 
   if( sessionNum > L7_MIRRORING_MAX_SESSIONS || sessionNum == 0)
   {
-    PT_LOG_ERR(LOG_CTX_MSG, "Invalid Session ID %u, sessionNum");
+    PT_LOG_ERR(LOG_CTX_MSG, "Invalid Session ID %u", sessionNum);
     return L7_FAILURE;
   }
 
   /* Check if Feature is supported */
   if(cnfgrIsFeaturePresent(L7_PORT_MIRROR_COMPONENT_ID, L7_MIRRORING_DIRECTION_PER_SOURCE_PORT_SUPPORTED_FEATURE_ID) != L7_TRUE)
@@ -17235,33 +17237,33 @@
       buffer[*n_elements].Pkts256to511Octets    = ENDIAN_SWAP64(ring_buffer.Pkts256to511Octets);                 
       buffer[*n_elements].Pkts512to1023Octets   = ENDIAN_SWAP64(ring_buffer.Pkts512to1023Octets);                
       buffer[*n_elements].Pkts1024to1518Octets  = ENDIAN_SWAP64(ring_buffer.Pkts1024to1518Octets);               
     #endif
 
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %d", buffer[*n_elements].index);
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %d",  buffer[*n_elements].arg );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %d", buffer[*n_elements].time );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %d",  buffer[*n_elements].path);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %d", buffer[*n_elements].cTempo);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %d", buffer[*n_elements].Octets );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %d", buffer[*n_elements].Pkts);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %d", buffer[*n_elements].Broadcast);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %d", buffer[*n_elements].Multicast);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %d", buffer[*n_elements].CRCAlignErrors);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts", buffer[*n_elements].UndersizePkts);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %d", buffer[*n_elements].OversizePkts);
-
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %d", buffer[*n_elements].Fragments );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %d",  buffer[*n_elements].Jabbers);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %d", buffer[*n_elements].Collisions);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %d", buffer[*n_elements].Utilization );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %d", buffer[*n_elements].Pkts64Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %d", buffer[*n_elements].Pkts65to127Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %d", buffer[*n_elements].Pkts128to255Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %d", buffer[*n_elements].Pkts256to511Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets", buffer[*n_elements].Pkts512to1023Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %d", buffer[*n_elements].Pkts1024to1518Octets);
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %lu", buffer[*n_elements].index);
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %lu",  buffer[*n_elements].arg );   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %lu", buffer[*n_elements].time );   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %lu",  buffer[*n_elements].path);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %lu", buffer[*n_elements].cTempo);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %llu", buffer[*n_elements].Octets );   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %llu", buffer[*n_elements].Pkts);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %llu", buffer[*n_elements].Broadcast);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %llu", buffer[*n_elements].Multicast);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %llu", buffer[*n_elements].CRCAlignErrors);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts %llu", buffer[*n_elements].UndersizePkts);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %llu", buffer[*n_elements].OversizePkts);
+
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %llu", buffer[*n_elements].Fragments );   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %llu",  buffer[*n_elements].Jabbers);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %llu", buffer[*n_elements].Collisions);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %llu", buffer[*n_elements].Utilization );   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %llu", buffer[*n_elements].Pkts64Octets);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %llu", buffer[*n_elements].Pkts65to127Octets);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %llu", buffer[*n_elements].Pkts128to255Octets);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %llu", buffer[*n_elements].Pkts256to511Octets);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets %llu", buffer[*n_elements].Pkts512to1023Octets);   
+    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %llu", buffer[*n_elements].Pkts1024to1518Octets);
 
     if (first_reg<0) 
       break;
 
     (*n_elements)++;        
@@ -17291,63 +17293,63 @@
     buffer_index=RFC2819_BUFFER_24HOURS;
   else
     buffer_index=RFC2819_BUFFER_15MIN;
 
 
-    if(ptin_rfc2819_buffer_get(buffer_index, buffer_id, &ring_buffer) <0) 
-    {
-      memset(&buffer[n_elements], 0x00, sizeof(msg_rfc2819_buffer_t)); // When no performance monotoring is avaiable send zeros.
-      return L7_SUCCESS;
-    }
-        
-    buffer[n_elements].index                = ENDIAN_SWAP32(ring_buffer.index);
-    buffer[n_elements].arg                  = ENDIAN_SWAP32(ring_buffer.arg);
-    buffer[n_elements].time                 = ENDIAN_SWAP32(ring_buffer.time);
-    buffer[n_elements].path                 = ENDIAN_SWAP32(ring_buffer.path);
-    buffer[n_elements].cTempo               = ENDIAN_SWAP32(ring_buffer.cTempo);
-
-    buffer[n_elements].Octets               = ENDIAN_SWAP64(ring_buffer.Octets);
-    buffer[n_elements].Pkts                 = ENDIAN_SWAP64(ring_buffer.Pkts);                
-    buffer[n_elements].Broadcast            = ENDIAN_SWAP64(ring_buffer.Broadcast);
-    buffer[n_elements].Multicast            = ENDIAN_SWAP64(ring_buffer.Multicast);           
-    buffer[n_elements].CRCAlignErrors       = ENDIAN_SWAP64(ring_buffer.CRCAlignErrors);      
-    buffer[n_elements].UndersizePkts        = ENDIAN_SWAP64(ring_buffer.UndersizePkts);       
-    buffer[n_elements].OversizePkts         = ENDIAN_SWAP64(ring_buffer.OversizePkts);        
-    buffer[n_elements].Fragments            = ENDIAN_SWAP64(ring_buffer.Fragments);           
-    buffer[n_elements].Jabbers              = ENDIAN_SWAP64(ring_buffer.Jabbers);             
-    buffer[n_elements].Collisions           = ENDIAN_SWAP64(ring_buffer.Collisions);          
-    buffer[n_elements].Utilization          = ENDIAN_SWAP64(ring_buffer.Utilization);         
-    buffer[n_elements].Pkts64Octets         = ENDIAN_SWAP64(ring_buffer.Pkts64Octets);        
-    buffer[n_elements].Pkts65to127Octets    = ENDIAN_SWAP64(ring_buffer.Pkts65to127Octets);   
-    buffer[n_elements].Pkts128to255Octets   = ENDIAN_SWAP64(ring_buffer.Pkts128to255Octets);  
-    buffer[n_elements].Pkts256to511Octets   = ENDIAN_SWAP64(ring_buffer.Pkts256to511Octets);  
-    buffer[n_elements].Pkts512to1023Octets  = ENDIAN_SWAP64(ring_buffer.Pkts512to1023Octets); 
-    buffer[n_elements].Pkts1024to1518Octets = ENDIAN_SWAP64(ring_buffer.Pkts1024to1518Octets);
-   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %d", buffer[n_elements].index);
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %d",  buffer[n_elements].arg );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %d", buffer[n_elements].time );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %d",  buffer[n_elements].path);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %d", buffer[n_elements].cTempo);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %d", buffer[n_elements].Octets );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %d", buffer[n_elements].Pkts);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %d", buffer[n_elements].Broadcast);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %d", buffer[n_elements].Multicast);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %d", buffer[n_elements].CRCAlignErrors);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts", buffer[n_elements].UndersizePkts);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %d", buffer[n_elements].OversizePkts);
-
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %d", buffer[n_elements].Fragments );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %d",  buffer[n_elements].Jabbers);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %d", buffer[n_elements].Collisions);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %d", buffer[n_elements].Utilization );   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %d", buffer[n_elements].Pkts64Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %d", buffer[n_elements].Pkts65to127Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %d", buffer[n_elements].Pkts128to255Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %d", buffer[n_elements].Pkts256to511Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets", buffer[n_elements].Pkts512to1023Octets);   
-    PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %d", buffer[n_elements].Pkts1024to1518Octets);
+  if(ptin_rfc2819_buffer_get(buffer_index, buffer_id, &ring_buffer) <0) 
+  {
+    memset(&buffer[n_elements], 0x00, sizeof(msg_rfc2819_buffer_t)); // When no performance monotoring is avaiable send zeros.
+    return L7_SUCCESS;
+  }
+      
+  buffer[n_elements].index                = ENDIAN_SWAP32(ring_buffer.index);
+  buffer[n_elements].arg                  = ENDIAN_SWAP32(ring_buffer.arg);
+  buffer[n_elements].time                 = ENDIAN_SWAP32(ring_buffer.time);
+  buffer[n_elements].path                 = ENDIAN_SWAP32(ring_buffer.path);
+  buffer[n_elements].cTempo               = ENDIAN_SWAP32(ring_buffer.cTempo);
+
+  buffer[n_elements].Octets               = ENDIAN_SWAP64(ring_buffer.Octets);
+  buffer[n_elements].Pkts                 = ENDIAN_SWAP64(ring_buffer.Pkts);                
+  buffer[n_elements].Broadcast            = ENDIAN_SWAP64(ring_buffer.Broadcast);
+  buffer[n_elements].Multicast            = ENDIAN_SWAP64(ring_buffer.Multicast);           
+  buffer[n_elements].CRCAlignErrors       = ENDIAN_SWAP64(ring_buffer.CRCAlignErrors);      
+  buffer[n_elements].UndersizePkts        = ENDIAN_SWAP64(ring_buffer.UndersizePkts);       
+  buffer[n_elements].OversizePkts         = ENDIAN_SWAP64(ring_buffer.OversizePkts);        
+  buffer[n_elements].Fragments            = ENDIAN_SWAP64(ring_buffer.Fragments);           
+  buffer[n_elements].Jabbers              = ENDIAN_SWAP64(ring_buffer.Jabbers);             
+  buffer[n_elements].Collisions           = ENDIAN_SWAP64(ring_buffer.Collisions);          
+  buffer[n_elements].Utilization          = ENDIAN_SWAP64(ring_buffer.Utilization);         
+  buffer[n_elements].Pkts64Octets         = ENDIAN_SWAP64(ring_buffer.Pkts64Octets);        
+  buffer[n_elements].Pkts65to127Octets    = ENDIAN_SWAP64(ring_buffer.Pkts65to127Octets);   
+  buffer[n_elements].Pkts128to255Octets   = ENDIAN_SWAP64(ring_buffer.Pkts128to255Octets);  
+  buffer[n_elements].Pkts256to511Octets   = ENDIAN_SWAP64(ring_buffer.Pkts256to511Octets);  
+  buffer[n_elements].Pkts512to1023Octets  = ENDIAN_SWAP64(ring_buffer.Pkts512to1023Octets); 
+  buffer[n_elements].Pkts1024to1518Octets = ENDIAN_SWAP64(ring_buffer.Pkts1024to1518Octets);
+ 
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].index %lu", buffer[n_elements].index);
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].arg  %lu",  buffer[n_elements].arg );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].time  %lu", buffer[n_elements].time );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].path %lu",  buffer[n_elements].path);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].cTempo %lu", buffer[n_elements].cTempo);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Octets  %llu", buffer[n_elements].Octets );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts %llu", buffer[n_elements].Pkts);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Broadcast %llu", buffer[n_elements].Broadcast);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Multicast %llu", buffer[n_elements].Multicast);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].CRCAlignErrors %llu", buffer[n_elements].CRCAlignErrors);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].UndersizePkts %llu", buffer[n_elements].UndersizePkts);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].OversizePkts %llu", buffer[n_elements].OversizePkts);
+
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Fragments  %llu", buffer[n_elements].Fragments );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Jabbers %llu",  buffer[n_elements].Jabbers);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Collisions %llu", buffer[n_elements].Collisions);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Utilization  %llu", buffer[n_elements].Utilization );   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts64Octets %llu", buffer[n_elements].Pkts64Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts65to127Octets %llu", buffer[n_elements].Pkts65to127Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts128to255Octets %llu", buffer[n_elements].Pkts128to255Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts256to511Octets %llu", buffer[n_elements].Pkts256to511Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts512to1023Octets %llu", buffer[n_elements].Pkts512to1023Octets);   
+  PT_LOG_DEBUG(LOG_CTX_MSG, "buffer[n_elements].Pkts1024to1518Octets %llu", buffer[n_elements].Pkts1024to1518Octets);
       
   return L7_SUCCESS;
 }
 
 /**
@@ -18912,20 +18914,29 @@
     else
 #endif /*NGPON2_SUPPORTED*/
     {
       /*Input Parameters*/
       PT_LOG_DEBUG(LOG_CTX_MSG, "Input Arguments [slotId:%u evcId:%u intf.type:%u intf.id:%u onuId:%u]",
-                ENDIAN_SWAP8(msg[messageIterator].slotId),ENDIAN_SWAP32(msg[messageIterator].evcId), ENDIAN_SWAP8(msg[messageIterator].intf.intf_type), ENDIAN_SWAP8(msg[messageIterator].intf.intf_id), ENDIAN_SWAP8(msg[messageIterator].onuId));
+                   ENDIAN_SWAP8(msg[messageIterator].slotId),
+                   ENDIAN_SWAP32(msg[messageIterator].evcId), 
+                   ENDIAN_SWAP8(msg[messageIterator].intf.intf_type), 
+                   ENDIAN_SWAP8(msg[messageIterator].intf.intf_id), 
+                   ENDIAN_SWAP8(msg[messageIterator].onuId));
 
       /*Copy to ptin intf struct*/
       ptinIntf.intf_type = ENDIAN_SWAP8(msg[messageIterator].intf.intf_type);
       ptinIntf.intf_id   = ENDIAN_SWAP8(msg[messageIterator].intf.intf_id);
 
       /*Convert from ptin intf to otin port*/
       if ( L7_SUCCESS != (rc = ptin_intf_ptintf2port(&ptinIntf, &ptinPort) ) )
       {
-        PT_LOG_ERR(LOG_CTX_IGMP, "Failed to convert to ptin port [slotId:%u evcId:%u intf.type:%u intf.id:%u onuId:%u]");  
+        PT_LOG_ERR(LOG_CTX_IGMP, "Failed to convert to ptin port [slotId:%u evcId:%u intf.type:%u intf.id:%u onuId:%u]",
+                   ENDIAN_SWAP8(msg[messageIterator].slotId),
+                   ENDIAN_SWAP32(msg[messageIterator].evcId), 
+                   ENDIAN_SWAP8(msg[messageIterator].intf.intf_type), 
+                   ENDIAN_SWAP8(msg[messageIterator].intf.intf_id), 
+                   ENDIAN_SWAP8(msg[messageIterator].onuId));  
         return rc;
       }
 
       /*If Any Error Occurs It is Already Logged*/
       if ( L7_SUCCESS != (rc = ptin_igmp_multicast_service_remove(ptinPort, ENDIAN_SWAP8(msg[messageIterator].onuId), ENDIAN_SWAP32(msg[messageIterator].evcId)) ) )
@@ -19156,11 +19167,11 @@
                 if (L7_SUCCESS!=osapiIfEnable(ifName)) {
                     PT_LOG_ERR(LOG_CTX_MSG,"osapiIfEnable(ifName=%s)", ifName);
                     return ERROR_CODE_INVALIDPARAM;
                 }
                 if (L7_SUCCESS!=osapiNetIfConfig(ifName, ip, msk)) {
-                    PT_LOG_ERR(LOG_CTX_MSG,"osapiNetIfConfig(ifName=%s, ip=0x%lx, msk=0x%lx)", ifName, ip, msk);
+                    PT_LOG_ERR(LOG_CTX_MSG,"osapiNetIfConfig(ifName=%s, ip=0x%x, msk=0x%x)", ifName, ip, msk);
                     return ERROR_CODE_INVALIDPARAM;
                 }
                 //sprintf(com, "ifconfig %s %d.%d.%d.%d netmask %d.%d.%d.%d up\n", ifName,
                 //                ib->IP[0], ib->IP[1], ib->IP[2], ib->IP[3],
                 //                ib->IPmsk[0], ib->IPmsk[1], ib->IPmsk[2], ib->IPmsk[3]);
@@ -19169,12 +19180,12 @@
             }
 
 #if (!PTIN_BOARD_IS_STANDALONE)
             rc = ptin_ipdtl0_control(ib->dtl0vid, ib->vid, internalVid, intIfNum, PTIN_IPDTL0_ETH_IPv4_UDP_PTP, enable);
             if (L7_SUCCESS!=rc) {
-                PT_LOG_ERR(LOG_CTX_MSG,"ptin_ipdtl0_control(ib->dtl0vid=%u, ib->vid=%u, internalVid=%u, intIfNum=%lu, PTIN_IPDTL0_ETH_IPv4_UDP_PTP, enable=%u)=%d",
-                                            ib->dtl0vid, ib->vid, internalVid, intIfNum, PTIN_IPDTL0_ETH_IPv4_UDP_PTP, enable, rc);
+                PT_LOG_ERR(LOG_CTX_MSG,"ptin_ipdtl0_control(ib->dtl0vid=%u, ib->vid=%u, internalVid=%u, intIfNum=%u, PTIN_IPDTL0_ETH_IPv4_UDP_PTP=%u, enable=%u)=%d",
+                           ib->dtl0vid, ib->vid, internalVid, intIfNum, PTIN_IPDTL0_ETH_IPv4_UDP_PTP, enable, rc);
                 return ERROR_CODE_INVALIDPARAM;
             }
 #endif
 
             if (!enable) {
Index: src/application/ptin/base/ptin_msghandler.c
===================================================================
--- src/application/ptin/base/ptin_msghandler.c	(revision 6677)
+++ src/application/ptin/base/ptin_msghandler.c	(working copy)
@@ -5897,13 +5897,15 @@
 #if (PTIN_BOARD_IS_MATRIX)
       msgId == CCMSG_ETH_LACP_MATRIXES_SYNC2 || 
 #endif
       msgId == CCMSG_MGMD_PORT_SYNC || 
       msgId == CCMSG_APPLICATION_RESOURCES)
-    PT_LOG_TRACE(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %lu usec [response:%u (bytes) rc=%u res=0x%08x]", msgId, outbuffer->infoDim, time_delta, rc, res);    
+    PT_LOG_TRACE(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %u usec [response:%u (bytes) rc=%u res=0x%08x]",
+                 msgId, time_delta, outbuffer->infoDim, rc, res);    
   else
-    PT_LOG_INFO(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %lu usec  [response:%u (bytes) rc=%u res=0x%08x]", msgId, outbuffer->infoDim, time_delta, rc, res);
+    PT_LOG_INFO(LOG_CTX_MSGHANDLER,"Message processed: 0x%04X in %u usec  [response:%u (bytes) rc=%u res=0x%08x]",
+                msgId, time_delta, outbuffer->infoDim, rc, res);
 
   /* Message Runtime Meter */
   /* Only for successfull messages */
   if (rc==L7_SUCCESS)
   {
Index: src/application/ptin/base/ptin_packet.c
===================================================================
--- src/application/ptin/base/ptin_packet.c	(revision 6677)
+++ src/application/ptin/base/ptin_packet.c	(working copy)
@@ -233,11 +233,12 @@
 
   /* Validate interface and vlan, as belonging to a valid interface in a valid EVC */
   if (ptin_evc_intfVlan_validate(intIfNum, vlanId)!=L7_SUCCESS)
   {
     if (ptin_packet_debug_enable)
-      PT_LOG_ERR(LOG_CTX_PACKET,"intIfNum %u and vlan %u does not belong to any valid EVC/interface");
+      PT_LOG_ERR(LOG_CTX_PACKET,"intIfNum %u and vlan %u does not belong to any valid EVC/interface",
+                 intIfNum, vlanId);
     return L7_FAILURE;
   }
 
   /* Send packet to queue */
   memset(&msg, 0x00, sizeof(msg));
Index: src/application/ptin/base/ptin_pppoe.c
===================================================================
--- src/application/ptin/base/ptin_pppoe.c	(revision 6677)
+++ src/application/ptin/base/ptin_pppoe.c	(working copy)
@@ -226,11 +226,11 @@
 
 /*********************************************************** 
  * INLINE FUNCTIONS
  ***********************************************************/
 
-inline L7_BOOL pppoe_clientIndex_check_free(L7_uint8 pppoe_idx)
+static inline L7_BOOL pppoe_clientIndex_check_free(L7_uint8 pppoe_idx)
 {
   /* Validate arguments */
   if (pppoe_idx >= PTIN_SYSTEM_N_PPPOE_INSTANCES)
   {
     PT_LOG_ERR(LOG_CTX_PPPOE,"Invalid PPPOE instance %u", pppoe_idx);
@@ -239,11 +239,11 @@
 
   return (pppoeClients_unified.number_of_clients < PTIN_SYSTEM_PPPOE_MAXCLIENTS &&
           queue_free_clients.n_elems > 0);
 }
 
-inline L7_int pppoe_clientIndex_allocate(L7_uint8 pppoe_idx, ptinPppoeClientInfoData_t *infoData)
+static inline L7_int pppoe_clientIndex_allocate(L7_uint8 pppoe_idx, ptinPppoeClientInfoData_t *infoData)
 {
   L7_int  client_idx;
   struct ptin_clientIdx_entry_s  *clientIdx_pool_entry;
   struct ptin_clientInfo_entry_s *clientInfo_pool_entry;
   L7_RC_t rc;
@@ -304,11 +304,11 @@
 
   /* Return new client id */
   return client_idx;
 }
 
-inline void pppoe_clientIndex_release(L7_uint8 pppoe_idx, L7_uint32 client_idx)
+static inline void pppoe_clientIndex_release(L7_uint8 pppoe_idx, L7_uint32 client_idx)
 {
   struct ptin_clientIdx_entry_s  *clientIdx_pool_entry;
   struct ptin_clientInfo_entry_s *clientInfo_pool_entry;
   L7_RC_t rc;
 
@@ -2894,10 +2894,11 @@
             #endif
             #if (PPPOE_CLIENT_MACADDR_SUPPORTED)
                               "MacAddr=%02x:%02x:%02x:%02x:%02x:%02x"
             #endif
                               "}"
+            ,client_idx
             #if (PPPOE_CLIENT_INTERF_SUPPORTED)
             ,clientInfo->pppoeClientDataKey.ptin_port
             #endif
             #if (PPPOE_CLIENT_OUTERVLAN_SUPPORTED)
             ,clientInfo->pppoeClientDataKey.outerVlan
Index: src/application/ptin/base/ptin_prot_uplink.c
===================================================================
--- src/application/ptin/base/ptin_prot_uplink.c	(revision 6677)
+++ src/application/ptin/base/ptin_prot_uplink.c	(working copy)
@@ -699,11 +699,12 @@
   }
 
   osapiSemaGive(ptin_prot_timers_sem);
 
   //if (ptin_debug_igmp_snooping)
-  PT_LOG_DEBUG(LOG_CTX_INTF,"Timer Started: protIdx=%u timerCB=%p timer=%p timerHandle=%p timeout=%u (s)", protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
+  PT_LOG_DEBUG(LOG_CTX_INTF,"Timer Started: protIdx=%u timerCB=%p timer=%p timerHandle=%u timeout=%u (s)",
+               protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
 
   return L7_SUCCESS;
 }
 
 /**
@@ -748,18 +749,20 @@
   /* Remove node for SLL list */
   if (SLLDelete(&prot_timerMgmt.ll_timerList, (L7_sll_member_t *)&timerData) != L7_SUCCESS)
   {
     osapiSemaGive(ptin_prot_timers_sem);
     //if (ptin_debug_igmp_snooping)
-    PT_LOG_ERR(LOG_CTX_INTF,"Failed to delete timer node: protIdx=%u timerCB=%p timer=%p timerHandle=%p", protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
+    PT_LOG_ERR(LOG_CTX_INTF,"Failed to delete timer node: protIdx=%u timerCB=%p timer=%p timerHandle=%u",
+               protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
     return L7_FAILURE;
   }
 
   osapiSemaGive(ptin_prot_timers_sem);
 
   //if (ptin_debug_igmp_snooping)
-  PT_LOG_DEBUG(LOG_CTX_INTF,"Timer stopped successfully for protIdx=%u timerCB=%p timer=%p timerHandle=%p", protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
+  PT_LOG_DEBUG(LOG_CTX_INTF,"Timer stopped successfully for protIdx=%u timerCB=%p timer=%p timerHandle=%u",
+               protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
 
   return L7_SUCCESS;
 }
 
 /**
@@ -805,18 +808,20 @@
 
   if (pTimerData->timer == L7_NULL)
   {
     osapiSemaGive(ptin_prot_timers_sem);
     //if (ptin_debug_igmp_snooping)
-    PT_LOG_ERR(LOG_CTX_INTF,"Client timer not running: protIdx=%u timerCB=%p timer=%p timerHandle=%p", protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle);
+    PT_LOG_ERR(LOG_CTX_INTF,"Client timer not running: protIdx=%u timerCB=%p timer=%p timerHandle=%u",
+               protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle);
     return L7_FAILURE;
   }
 
   appTimerTimeLeftGet(prot_timerMgmt.timerCB, pTimerData->timer, &time_left);
 
   //if (ptin_debug_igmp_snooping)
-  PT_LOG_DEBUG(LOG_CTX_INTF,"Client Timer TimeOut: protIdx=%u timerCB=%p timer=%p timerHandle=%p time_left=%u (s))", protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle, time_left);
+  PT_LOG_DEBUG(LOG_CTX_INTF,"Client Timer TimeOut: protIdx=%u timerCB=%p timer=%p timerHandle=%u time_left=%u (s))",
+               protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle, time_left);
 
   osapiSemaGive(ptin_prot_timers_sem);
 
   if (timeLeft != L7_NULLPTR)
   {
@@ -846,11 +851,11 @@
   L7_uint32 protIdx;
 
   protTimerData_t *pTimerData;
 
   //if (ptin_debug_igmp_snooping)
-  PT_LOG_DEBUG(LOG_CTX_INTF,"Expiration event ocurred for timerHandle %p!",timerHandle);
+  PT_LOG_DEBUG(LOG_CTX_INTF,"Expiration event ocurred for timerHandle %u!",timerHandle);
 
   osapiSemaTake(ptin_prot_timers_sem, L7_WAIT_FOREVER);
 
   /* Get timer handler */
   pTimerData = (protTimerData_t *) handleListNodeRetrieve(timerHandle);
@@ -875,15 +880,17 @@
 
   PT_LOG_TRACE(LOG_CTX_INTF,"Deleting SLL node (protIdx=%u)", protIdx);
   /* Remove node for SLL list */
   if (SLLDelete(&prot_timerMgmt.ll_timerList, (L7_sll_member_t *)&timerData) != L7_SUCCESS)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node: protIdx=%u timerCB=%p timer=%p timerHandle=%p", protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
+    PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer node: protIdx=%u timerCB=%p timer=%p timerHandle=%u",
+               protIdx, prot_timerMgmt.timerCB, timerData.timer, timerData.timerHandle);
   }
 
   //if (ptin_debug_igmp_snooping)
-  PT_LOG_TRACE(LOG_CTX_INTF,"Expiration event ocurred for protIidx=%u timerCB=%p timer=%p timerHandle=%p", protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle);
+  PT_LOG_TRACE(LOG_CTX_INTF,"Expiration event ocurred for protIidx=%u timerCB=%p timer=%p timerHandle=%u",
+               protIdx, prot_timerMgmt.timerCB, pTimerData->timer, pTimerData->timerHandle);
 
   osapiSemaGive(ptin_prot_timers_sem);
 
   /* Processing timeout */
   osapiSemaTake(ptin_prot_uplink_sem, L7_WAIT_FOREVER);
@@ -2552,11 +2559,11 @@
   }
   
   rc = ptin_prot_uplink_index_find(intIfNum, &protIdx, &portType);
   if (rc != L7_SUCCESS)
   {
-    PT_LOG_WARN(LOG_CTX_INTF, "No group found using this intIfNum", intIfNum);
+    PT_LOG_WARN(LOG_CTX_INTF, "No group found using this intIfNum %u:s", intIfNum);
     return L7_SUCCESS;
   }
   
   /* Skip inactive instances */
   if (!uplinkprot[protIdx].admin)
Index: src/application/ptin/base/ptin_rfc2819.c
===================================================================
--- src/application/ptin/base/ptin_rfc2819.c	(revision 6677)
+++ src/application/ptin/base/ptin_rfc2819.c	(working copy)
@@ -236,11 +236,11 @@
   aux_qual_RFC2819.Pkts128to255Octets   =   qual->status[RFC2819_ACTUAL].Pkts128to255Octets  ;
   aux_qual_RFC2819.Pkts256to511Octets   =   qual->status[RFC2819_ACTUAL].Pkts256to511Octets  ;
   aux_qual_RFC2819.Pkts512to1023Octets  =   qual->status[RFC2819_ACTUAL].Pkts512to1023Octets ;
   aux_qual_RFC2819.Pkts1024to1518Octets =   qual->status[RFC2819_ACTUAL].Pkts1024to1518Octets;   
 
-  PT_LOG_TRACE(LOG_CTX_RFC2819, "15MIN  : %.08lx  |  %.02d-%.02d-%.04d  |  %d:%.02d:00  | %5d | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld",
+  PT_LOG_TRACE(LOG_CTX_RFC2819, "15MIN  : %.08lx  |  %.02d-%.02d-%.04d  |  %d:%.02d:00  | %5ld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld",
             qual->conf.path,
             qual->reg_data.dia,
             qual->reg_data.mes,
             qual->reg_data.ano,
             qual->reg_data.hora,
@@ -310,11 +310,11 @@
   aux_qual_RFC2819.Pkts128to255Octets  =   qual->status[RFC2819_PER24HORAS].Pkts128to255Octets  ;
   aux_qual_RFC2819.Pkts256to511Octets  =   qual->status[RFC2819_PER24HORAS].Pkts256to511Octets  ;
   aux_qual_RFC2819.Pkts512to1023Octets =   qual->status[RFC2819_PER24HORAS].Pkts512to1023Octets ;
   aux_qual_RFC2819.Pkts1024to1518Octets=   qual->status[RFC2819_PER24HORAS].Pkts1024to1518Octets;
 
-  PT_LOG_TRACE(LOG_CTX_RFC2819, "24HOURS: %.08lx  |  %.02d-%.02d-%.04d  |  %d:%.02d:00  | %5d | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld",
+  PT_LOG_TRACE(LOG_CTX_RFC2819, "24HOURS: %.08lx  |  %.02d-%.02d-%.04d  |  %d:%.02d:00  | %5ld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld | %13lld",
             qual->conf.path,
             qual->reg_data.dia,
             qual->reg_data.mes,
             qual->reg_data.ano,
             qual->reg_data.hora,
Index: src/application/ptin/base/ptin_routing.c
===================================================================
--- src/application/ptin/base/ptin_routing.c	(revision 6677)
+++ src/application/ptin/base/ptin_routing.c	(working copy)
@@ -1344,11 +1344,11 @@
   }
 
   /* Ensure that the requested index belongs to a traceroute session not in use */
   if(__traceroute_sessions[sessionIdx].isRunning == L7_TRUE)
   {
-    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index is already being used in an active traceroute session [index:%u]", index);
+    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index is already being used in an active traceroute session [index:%u]", sessionIdx);
     return L7_FAILURE;
   }
 
   /* Save session configurations */
   __traceroute_sessions[sessionIdx].index         = sessionIdx;
@@ -1453,11 +1453,11 @@
     return L7_ERROR;
   }
 
   if(sessionIdx > __traceroute_sessions_max)
   {
-    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index[%u] is higher than the maximum allowed number of ping sessions", index);
+    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index[%u] is higher than the maximum allowed number of ping sessions", sessionIdx);
     return L7_FAILURE;
   }
 
   /* Ensure that the requested index belongs to a created session */
   if(__traceroute_sessions[sessionIdx].handle == 0)
@@ -1628,11 +1628,11 @@
     PT_LOG_ERR(LOG_CTX_ROUTING, "Error while setting ICMP Redirects on intfIfNum %u to value %d", routingIntfNum, enable);
     return L7_FAILURE;
   }
 
   /* Enable/Disable ICMP Redirects on this Router */
-  PT_LOG_DEBUG(LOG_CTX_ROUTING, "Setting ICMP Redirects on Router to value %d", routingIntfNum, enable);
+  PT_LOG_DEBUG(LOG_CTX_ROUTING, "Setting ICMP Redirects on Router to value %d", enable);
   usmDbIpMapRtrICMPRedirectsModeSet(enable);
 
   return L7_SUCCESS;
 }
 
@@ -2292,11 +2292,11 @@
   }
 
   /* Get the handle for this traceroute session */
   if(sessionIdx > __traceroute_sessions_max)
   {
-    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index[%u] is higher than the maximum allowed number of ping sessions", index);
+    PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index[%u] is higher than the maximum allowed number of ping sessions", sessionIdx);
     return;
   }
   if(__traceroute_sessions[sessionIdx].handle == 0)
   {
     PT_LOG_ERR(LOG_CTX_ROUTING, "Requested index is does not belong to a created session [sessionIdx:%u]", sessionIdx);
Index: src/application/ptin/base/ptin_ssm.c
===================================================================
--- src/application/ptin/base/ptin_ssm.c	(revision 6677)
+++ src/application/ptin/base/ptin_ssm.c	(working copy)
@@ -613,11 +613,11 @@
   /* ITU-OUI */
   itu_oui = ((L7_uint32) pdu->itu_oui[0]<<16) | ((L7_uint32) pdu->itu_oui[1]<<8) | ((L7_uint32) pdu->itu_oui[2]);
 
   if (itu_oui != SSM_ITU_OUI)
   {
-    PT_LOG_ERR(LOG_CTX_SSM,"ITU-T field is not valid: received=0x%x, expected=0x%x",itu_oui,SSM_ITU_OUI);
+    PT_LOG_ERR(LOG_CTX_SSM,"ITU-T field is not valid: received=0x%x, expected=0x%lx",itu_oui,SSM_ITU_OUI);
     bufferPoolFree(ssmBufferPoolId,  buffer);
     return L7_FAILURE;
   }
   /* Protocol version */
   if ((pdu->version >> 4) != 1)
Index: src/application/ptin/base/ptin_xconnect_api.c
===================================================================
--- src/application/ptin/base/ptin_xconnect_api.c	(revision 6677)
+++ src/application/ptin/base/ptin_xconnect_api.c	(working copy)
@@ -846,11 +846,11 @@
 
   if (rc == L7_SUCCESS)
   {
     if (vport.virtual_gport <= 0)
     {
-      PT_LOG_ERR(LOG_CTX_API, "Finished: Invalid vport id %d (MC group=%d)", rc, vport.virtual_gport, vport.multicast_group);
+      PT_LOG_ERR(LOG_CTX_API, "Finished: Invalid vport id %d (MC group=%d)", vport.virtual_gport, vport.multicast_group);
       return L7_FAILURE;
     }
     /* Return vport id */
     if (vport_id != L7_SUCCESS)
       *vport_id = vport.virtual_gport;
Index: src/application/ptin/base/ptin_xlate_api.c
===================================================================
--- src/application/ptin/base/ptin_xlate_api.c	(revision 6677)
+++ src/application/ptin/base/ptin_xlate_api.c	(working copy)
@@ -1366,13 +1366,14 @@
   xlate.remove_VLANs = (xlate_table_pvid[intIfNum] == newOuterVlanId);
 
   if (xlate.remove_VLANs)
   {
     /* Set untagged port */
-    if (usmDbVlanTaggedSet(unit, intf_vlan->vid, intIfNum, L7_DOT1Q_UNTAGGED) != L7_SUCCESS)
+    rc = usmDbVlanTaggedSet(unit, intf_vlan->vid, intIfNum, L7_DOT1Q_UNTAGGED);
+    if (rc != L7_SUCCESS)
     {
-      PT_LOG_ERR(LOG_CTX_EVC, "Error setting intIfNum# %u internal VLAN %u as UNtagged (rc=%d)", intIfNum, intf_vlan->vid);
+      PT_LOG_ERR(LOG_CTX_EVC, "Error setting intIfNum# %u internal VLAN %u as UNtagged (rc=%d)", intIfNum, intf_vlan->vid, rc);
       return L7_FAILURE;
     }
   }
 
   /* DTL call */
Index: src/application/ptin/utils/ipc_lib.c
===================================================================
--- src/application/ptin/utils/ipc_lib.c	(revision 6677)
+++ src/application/ptin/utils/ipc_lib.c	(working copy)
@@ -110,11 +110,11 @@
    tv.tv_sec = 1;
    tv.tv_usec = 0;
    *handlerid = -1;
 //   DEBUGTRACE (TRACE_MODULE_ALL | TRACE_LAYER_IPC, TRACE_SEVERITY_INFORMATIONAL,
    PT_LOG_INFO(LOG_CTX_IPC,
-            "Abertura de canal de comunicacao (%d, %08X, %d).", porto_rx, MessageHandler, timeout); 
+            "Abertura de canal de comunicacao (%d, %08X, %d).", porto_rx, (int)MessageHandler, timeout); 
    // Deteccao do primeiro canal livre
    for(i=0;i<IPCLIB_MAX_CANAIS;i++)
    {
       if(ipc_canais[i].estado==IPCLIB_CANAL_LIVRE)
          break;
Index: src/application/ptin/utils/ptin_timerMng.c
===================================================================
--- src/application/ptin/utils/ptin_timerMng.c	(revision 6677)
+++ src/application/ptin/utils/ptin_timerMng.c	(working copy)
@@ -668,11 +668,12 @@
   }
 
   osapiSemaGive(ptin_timers_sem);
 
   if (ptin_timerMng_debug_snooping)
-    PT_LOG_DEBUG(LOG_CTX_MISC,"Timer Started: timerCB=%p timer=%p timerHandle=%p timeout=%u (s)", timersMng.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
+    PT_LOG_DEBUG(LOG_CTX_MISC,"Timer Started: timerCB=%p timer=%p timerHandle=%u timeout=%u (s)", 
+                 timersMng.timerCB, pTimerData->timer, pTimerData->timerHandle, timeout);
 
   return L7_SUCCESS;
 }
 
 /**
Index: src/application/qos/diffserv/base/diffserv_cluster.c
===================================================================
--- src/application/qos/diffserv/base/diffserv_cluster.c	(revision 6677)
+++ src/application/qos/diffserv/base/diffserv_cluster.c	(working copy)
@@ -2861,11 +2861,11 @@
    */
   if (diffServClusterConfigServiceIntfRemap(pCfgData) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
             "%s: Error mapping DiffServ service interface config.\n",
-            __FUNCTION__, dsmibPrvtTableIdStr[tableID]);
+            __FUNCTION__);
     rc = L7_FAILURE;
   }
 
   DIFFSERV_CLUSTER_DLOG("LEAVING %s (rc = %d)\n", __FUNCTION__, rc);
 
Index: src/application/qos/diffserv/base/diffserv_distiller.c
===================================================================
--- src/application/qos/diffserv/base/diffserv_distiller.c	(revision 6677)
+++ src/application/qos/diffserv/base/diffserv_distiller.c	(working copy)
@@ -1417,11 +1417,11 @@
             {
               sprintf((char *)nameStr, "index %u", policyIndex);
             }
             L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,
                     "Policy invalid for service intf: "
-                    "policy \'%s\', intf %s, direction %u."
+                    "policy \'%s\', intf %u, direction %u."
                     " The DiffServ policy definition is not compatible"
                     " with the capabilities of the interface specified.  "
                     "Check the platform release notes for information on "
                     "configuration limitations.",
                     (char *)nameStr, intIfNum, ifDirection);
Index: src/application/qos/iscsi/core/iscsi.c
===================================================================
--- src/application/qos/iscsi/core/iscsi.c	(revision 6677)
+++ src/application/qos/iscsi/core/iscsi.c	(working copy)
@@ -492,11 +492,11 @@
   if (dtlIscsiTargetPortAdd(tcpPort, ipAddress, cosQueue, taggingEnabled, tagMode, tagData) == L7_SUCCESS)
     return L7_SUCCESS;
   else
   {
     L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_FLEX_QOS_ISCSI_COMPONENT_ID,
-            "Error adding iSCSI target TCP port/address: tcpPort = %u, ipAddress=%X, cosQueue=%u, ",
+            "Error adding iSCSI target TCP port/address: tcpPort = %u, ipAddress=%X, cosQueue=%u, "
             "taggingEnabled=%u, tagMode=%u, tagData=%u",
             tcpPort, ipAddress, cosQueue, taggingEnabled, tagMode, tagData);
     return L7_FAILURE;
   }
 }
Index: src/application/routing/mapping/ipmap/core/ip_util.c
===================================================================
--- src/application/routing/mapping/ipmap/core/ip_util.c	(revision 6677)
+++ src/application/routing/mapping/ipmap/core/ip_util.c	(working copy)
@@ -1556,11 +1556,11 @@
   }
 
   return rc;
 }
 
-L7_RC_t ptin_ipMapRoutingIntfCreate(intIfNum)
+L7_RC_t ptin_ipMapRoutingIntfCreate(L7_uint32 intIfNum)
 {
   return ipMapRoutingIntfCreate(intIfNum);
 }
 
 /*********************************************************************
@@ -3433,17 +3433,17 @@
   L7_rtrCfgCkt_t *pCfg;
 
   if (!ipMapMapIntfIsConfigurable(intIfNum, &pCfg))
     return L7_FAILURE;
 
-    if (ipMapTraceFlags & IPMAP_TRACE_SECONDARY)
-    {
-        L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
-        sprintf(traceBuf, "ipMapRtrIntfSecondaryIpAddressRemoveApply: intIfNum %d\n",
-            intIfNum);
-        ipMapTraceWrite(traceBuf);
-    }
+  if (ipMapTraceFlags & IPMAP_TRACE_SECONDARY)
+  {
+      L7_uchar8 traceBuf[IPMAP_TRACE_LEN_MAX];
+      sprintf(traceBuf, "ipMapRtrIntfSecondaryIpAddressRemoveApply: intIfNum %d\n",
+          intIfNum);
+      ipMapTraceWrite(traceBuf);
+  }
 
   /* De-activate static routes and static ARP entries on this subnet. */
   ipMapRtrIntfStaticConfigRemoveApply(intIfNum, ipAddr, ipMask);
 
     /* Remove the secondary address from the IP stack */
Index: src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c
===================================================================
--- src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c	(revision 6677)
+++ src/application/routing/mapping/ospfmap/core/ospf_vend_exten.c	(working copy)
@@ -2315,115 +2315,115 @@
   /* In this function, we check for the secondaryFlags that
    * was set due to "network area" or "ip ospf area secondaries none"
    * and compile only the enabled addresses on the interface
    * and inform the vendor code.
    */
-    if ((p_IFO = ifoPtrGet(intIfNum)) == NULL)
-    {
-        return L7_ERROR;
-    }
+  if ((p_IFO = ifoPtrGet(intIfNum)) == NULL)
+  {
+      return L7_ERROR;
+  }
 
-    memcpy(&ifoCfg, &p_IFO->Cfg, sizeof(t_IFO_Cfg));
+  memcpy(&ifoCfg, &p_IFO->Cfg, sizeof(t_IFO_Cfg));
   memcpy((L7_char8 *)prevAddrs, (L7_char8 *)ifoCfg.addrs,
          L7_L3_NUM_IP_ADDRS*sizeof(L7_rtrIntfIpAddr_t));
 
-    if (ipMapRtrIntfIpAddrListGet(intIfNum, addrs) == L7_SUCCESS)
-    {
-    ifoCfg.DupNet[0] = 0;
-    memset((L7_char8 *)ifoCfg.addrs, 0,
-               L7_L3_NUM_IP_ADDRS*(sizeof(L7_rtrIntfIpAddr_t)));
-
-    memcpy((L7_char8 *)(&ifoCfg.addrs[0]), (L7_char8 *)(&addrs[0]),
-           sizeof(L7_rtrIntfIpAddr_t));
-
-    ospfMapIntfEffectiveSecondariesFlagGet(intIfNum, &secondariesFlag);
-    for (i = 1; i < L7_L3_NUM_IP_ADDRS; i++)
-        {
-            ifoCfg.DupNet[i] = 0;
-      if(secondariesFlag & (1<<i))
+  if (ipMapRtrIntfIpAddrListGet(intIfNum, addrs) == L7_SUCCESS)
+  {
+  ifoCfg.DupNet[0] = 0;
+  memset((L7_char8 *)ifoCfg.addrs, 0,
+             L7_L3_NUM_IP_ADDRS*(sizeof(L7_rtrIntfIpAddr_t)));
+
+  memcpy((L7_char8 *)(&ifoCfg.addrs[0]), (L7_char8 *)(&addrs[0]),
+         sizeof(L7_rtrIntfIpAddr_t));
+
+  ospfMapIntfEffectiveSecondariesFlagGet(intIfNum, &secondariesFlag);
+  for (i = 1; i < L7_L3_NUM_IP_ADDRS; i++)
       {
-        j++;
-        memcpy((L7_char8 *)(&ifoCfg.addrs[j]), (L7_char8 *)(&addrs[i]),
-               sizeof(L7_rtrIntfIpAddr_t));
+          ifoCfg.DupNet[i] = 0;
+    if(secondariesFlag & (1<<i))
+    {
+      j++;
+      memcpy((L7_char8 *)(&ifoCfg.addrs[j]), (L7_char8 *)(&addrs[i]),
+             sizeof(L7_rtrIntfIpAddr_t));
+    }
       }
-        }
 
-        for (i = 0; i < L7_L3_NUM_IP_ADDRS - 1; i++)
-        {
-            if (addrs[i].ipAddr == 0)
-            {
-                continue;
-            }
-
-            ipNet1 = addrs[i].ipAddr & addrs[i].ipMask;
-            for (j = i+1; j < L7_L3_NUM_IP_ADDRS; j++)
-            {
-                if (addrs[j].ipAddr == 0)
-                {
-                    continue;
-                }
-
-                ipNet2 = addrs[j].ipAddr & addrs[j].ipMask;
-
-                if (ipNet2 == ipNet1)
-                {
-                    ifoCfg.DupNet[j] = 1;
-                }
-            }
-        }
-    }
+      for (i = 0; i < L7_L3_NUM_IP_ADDRS - 1; i++)
+      {
+          if (addrs[i].ipAddr == 0)
+          {
+              continue;
+          }
+
+          ipNet1 = addrs[i].ipAddr & addrs[i].ipMask;
+          for (j = i+1; j < L7_L3_NUM_IP_ADDRS; j++)
+          {
+              if (addrs[j].ipAddr == 0)
+              {
+                  continue;
+              }
+
+              ipNet2 = addrs[j].ipAddr & addrs[j].ipMask;
+
+              if (ipNet2 == ipNet1)
+              {
+                  ifoCfg.DupNet[j] = 1;
+              }
+          }
+      }
+  }
 
   /* There is no change in the set of addresses
    * to be informed to the vendor code
    */
   if(memcmp((void *)prevAddrs, (void *)ifoCfg.addrs,
      L7_L3_NUM_IP_ADDRS*sizeof(L7_rtrIntfIpAddr_t)) == 0)
     return L7_SUCCESS;
 
-    switch (val)
-    {
-        case L7_OSPF_ROW_ACTIVE:
-            parm = ROW_ACTIVE;
-            break;
-
-        case L7_OSPF_ROW_NOT_IN_SERVICE:
-            parm = ROW_NOT_IN_SERVICE;
-            break;
-
-        case L7_OSPF_ROW_NOT_READY:
-            parm = ROW_NOT_READY;
-            break;
-
-        case L7_OSPF_ROW_CREATE_AND_GO:
-            parm = ROW_CREATE_AND_GO;
-            break;
-
-        case L7_OSPF_ROW_CREATE_AND_WAIT:
-            parm = ROW_CREATE_AND_WAIT;
-            break;
-
-        case L7_OSPF_ROW_DESTROY:
-            parm = ROW_DESTROY;
-            break;
-
-        case L7_OSPF_ROW_CHANGE:
-            parm = ROW_CHANGE;
-            break;
-
-        default:
-            return L7_FAILURE;
-            break;
-    }
-
-    ifoCfg.IfStatus = parm;
+  switch (val)
+  {
+      case L7_OSPF_ROW_ACTIVE:
+          parm = ROW_ACTIVE;
+          break;
+
+      case L7_OSPF_ROW_NOT_IN_SERVICE:
+          parm = ROW_NOT_IN_SERVICE;
+          break;
+
+      case L7_OSPF_ROW_NOT_READY:
+          parm = ROW_NOT_READY;
+          break;
+
+      case L7_OSPF_ROW_CREATE_AND_GO:
+          parm = ROW_CREATE_AND_GO;
+          break;
+
+      case L7_OSPF_ROW_CREATE_AND_WAIT:
+          parm = ROW_CREATE_AND_WAIT;
+          break;
+
+      case L7_OSPF_ROW_DESTROY:
+          parm = ROW_DESTROY;
+          break;
+
+      case L7_OSPF_ROW_CHANGE:
+          parm = ROW_CHANGE;
+          break;
+
+      default:
+          return L7_FAILURE;
+          break;
+  }
+
+  ifoCfg.IfStatus = parm;
+
+  if (IFO_Config_Pack((t_Handle)p_IFO, &ifoCfg) != E_OK)
+  {
+      return L7_FAILURE;
+  }
 
-    if (IFO_Config_Pack((t_Handle)p_IFO, &ifoCfg) != E_OK)
-    {
-        return L7_FAILURE;
-    }
-
-    return L7_SUCCESS;
+  return L7_SUCCESS;
 }
 
 /*********************************************************************
 * @purpose  Test if Ospf multicast forwarding for the specified
 *           interface is settable.
Index: src/application/routing/mapping/ripmap/rip_map_sysctl.c
===================================================================
--- src/application/routing/mapping/ripmap/rip_map_sysctl.c	(revision 6677)
+++ src/application/routing/mapping/ripmap/rip_map_sysctl.c	(working copy)
@@ -168,44 +168,51 @@
   name += 3;
   namelen -= 3;
 
   if (new)
     return (EPERM);
-    if (namelen != 3)
-        return (EINVAL);
-    af = name[0];
+
+  if (namelen != 3)
+      return (EINVAL);
+  af = name[0];
+
   if (af != AF_INET)
     return (ENOPROTOOPT);
-    bzero((caddr_t)&w, sizeof(w));
+
+  bzero((caddr_t)&w, sizeof(w));
   w.w_where = where;
   w.w_given = *given;
   w.w_needed = 0 - w.w_given;
-    w.w_op = name[1];
-    w.w_arg = name[2];
+  w.w_op = name[1];
+  w.w_arg = name[2];
 
-    /* s = splnet(); */                   /* LVL7_MOD */
-    switch (w.w_op) {
+  /* s = splnet(); */                   /* LVL7_MOD */
+  switch (w.w_op) {
 
     case NET_RT_IFLIST:
-        error = ripMapSysctl_iflist(af, &w);
-    break;
+      error = ripMapSysctl_iflist(af, &w);
+      break;
+
+    default:
+      break;
+  }
 
-  default:
-    break;
-    }
-    /* splx(s); */                        /* LVL7_MOD */
-    if (w.w_tmem)
+  /* splx(s); */                        /* LVL7_MOD */
+  if (w.w_tmem)
     osapiFree(L7_RIP_MAP_COMPONENT_ID, w.w_tmem);                /* LVL7_MOD */
+
   w.w_needed += w.w_given;
+
   if (where) {
     *given = w.w_where - where;
-    if (*given < w.w_needed)
-      return (ENOMEM);
+  if (*given < w.w_needed)
+    return (ENOMEM);
   } else {
     *given = (w.w_needed * 11) / 10;
   }
-    return (error);
+
+  return (error);
 }
 
 
 /*********************************************************************
 * @purpose  Prepares the message buffer containing information about all
Index: src/application/routing/protocol/ospf/ospfmib.c
===================================================================
--- src/application/routing/protocol/ospf/ospfmib.c	(revision 6677)
+++ src/application/routing/protocol/ospf/ospfmib.c	(working copy)
@@ -905,29 +905,30 @@
  *
  * @end
  * ********************************************************************/
 e_Err ospfAreaTable_SetTest(word lastOid, ulng newValue, t_Handle p)
 {
-   ospfAreaEntry *p_areaEntry = (ospfAreaEntry *)p;  
+  ospfAreaEntry *p_areaEntry = (ospfAreaEntry *)p;  
 
-   /* The first verification: the new value of the object is in range */
-   if (!CheckValueInRange(ospfAreaTestTable, 
-                            sizeof(ospfAreaTestTable)/sizeof(ospfAreaTestTable[0]),
-                            lastOid, newValue))
+  /* The first verification: the new value of the object is in range */
+  if (!CheckValueInRange(ospfAreaTestTable, 
+                           sizeof(ospfAreaTestTable)/sizeof(ospfAreaTestTable[0]),
+                           lastOid, newValue))
+     return E_FAILED;
+  
+  /* Since OSPF Area configuration parameters are "CREATE_READ" objects, */
+  /* they can be changed (set) only during conceptual row creation.      */
+  /* Rowstatus are "READ_WRITE" objects, so they can be set at any time. */
+
+  if ( lastOid == ospfAreaTableRowStatusSubId)  
+     return E_OK;
+  else
+    if((p_areaEntry->info.rowStatus != notReady) &&
+       (p_areaEntry->info.rowStatus != notInService))
       return E_FAILED;
-   
-   /* Since OSPF Area configuration parameters are "CREATE_READ" objects, */
-   /* they can be changed (set) only during conceptual row creation.      */
-   /* Rowstatus are "READ_WRITE" objects, so they can be set at any time. */
 
-   if ( lastOid == ospfAreaTableRowStatusSubId)  
-      return E_OK;
-   else
-      if((p_areaEntry->info.rowStatus != notReady) &&
-         (p_areaEntry->info.rowStatus != notInService))
-          return E_FAILED;
-      return E_OK;   
+  return E_OK;   
 }
 
 
 
 
@@ -4763,36 +4764,36 @@
  *
  * @end
  * ********************************************************************/
 e_Err ospfVirtIfTable_SetTest(word lastOid, ulng newValue, t_Handle p)
 {
-   ospfVirtIfEntry *p_virtIfEntry = (ospfVirtIfEntry *)p;
-   
-   /* The first verification: the new value of the object is in range */
-   if (!CheckValueInRange(ospfVirtIfTestTable,
-                            sizeof(ospfVirtIfTestTable)/
-                            sizeof(ospfVirtIfTestTable[0]),
-                            lastOid, newValue))
-      return E_FAILED;
-
-   /* OSPF Virt Interface table fields are "CREATE_READ" objects. */
-   /* Therefore they can be changed (set) only during conceptual  */
-   /* row creation (i.e. before the row status becomes "active"). */
+  ospfVirtIfEntry *p_virtIfEntry = (ospfVirtIfEntry *)p;
+  
+  /* The first verification: the new value of the object is in range */
+  if (!CheckValueInRange(ospfVirtIfTestTable,
+                           sizeof(ospfVirtIfTestTable)/
+                           sizeof(ospfVirtIfTestTable[0]),
+                           lastOid, newValue))
+     return E_FAILED;
 
-   if (lastOid == ospfVirtIfTableRowStatusSubId)
-   {
-      if (p_virtIfEntry)
-         if (p_virtIfEntry->info.internalCreated == TRUE)
-            return E_FAILED;
-      return E_OK;
-   }
-   else
-      if((p_virtIfEntry->info.rowStatus != notReady) &&
-         (p_virtIfEntry->info.rowStatus != notInService))
-          return E_FAILED;
+  /* OSPF Virt Interface table fields are "CREATE_READ" objects. */
+  /* Therefore they can be changed (set) only during conceptual  */
+  /* row creation (i.e. before the row status becomes "active"). */
+
+  if (lastOid == ospfVirtIfTableRowStatusSubId)
+  {
+    if (p_virtIfEntry)
+      if (p_virtIfEntry->info.internalCreated == TRUE)
+        return E_FAILED;
+    return E_OK;
+  }
+  else
+     if((p_virtIfEntry->info.rowStatus != notReady) &&
+        (p_virtIfEntry->info.rowStatus != notInService))
+       return E_FAILED;
 
-      return E_OK;   
+  return E_OK;   
 }
 
 
 
 /*********************************************************************
@@ -5500,32 +5501,32 @@
  *
  * @end
  * ********************************************************************/
 e_Err ospfNbrTable_SetTest(word lastOid, ulng newValue, t_Handle p)
 {
-   ospfNbrEntry  *p_nbrEntry = (ospfNbrEntry *)p;
-   
-   /* The first verification: the new value of the object is in range */
-   if (!CheckValueInRange(ospfNbrTestTable, 
-                            sizeof(ospfNbrTestTable)/
-                            sizeof(ospfNbrTestTable[0]),
-                            lastOid, newValue))
+  ospfNbrEntry  *p_nbrEntry = (ospfNbrEntry *)p;
+  
+  /* The first verification: the new value of the object is in range */
+  if (!CheckValueInRange(ospfNbrTestTable, 
+                           sizeof(ospfNbrTestTable)/
+                           sizeof(ospfNbrTestTable[0]),
+                           lastOid, newValue))
+     return E_FAILED;
+  
+  /* OSPF Neighbor table fields are "CREATE_READ" objects.         */
+  /* Therefore they can be changed (set) only during conceptual row      */
+  /* creation (i.e. before the row status becomes "active").             */
+  /* Rowstatus are "READ_WRITE" objects, so they can be set at any time. */
+
+  if (lastOid == ospfNbrTableRowStatusSubId)  
+    return E_OK;
+  else
+    if((p_nbrEntry->info.rowStatus != notReady) &&
+       (p_nbrEntry->info.rowStatus != notInService))
       return E_FAILED;
-   
-   /* OSPF Neighbor table fields are "CREATE_READ" objects.         */
-   /* Therefore they can be changed (set) only during conceptual row      */
-   /* creation (i.e. before the row status becomes "active").             */
-   /* Rowstatus are "READ_WRITE" objects, so they can be set at any time. */
-
-   if (lastOid == ospfNbrTableRowStatusSubId)  
-      return E_OK;
-   else
-      if((p_nbrEntry->info.rowStatus != notReady) &&
-         (p_nbrEntry->info.rowStatus != notInService))
-          return E_FAILED;
 
-      return E_OK;   
+  return E_OK;   
 }
 
 
 
 /*********************************************************************
Index: src/application/routing/protocol/ospf/sparo.c
===================================================================
--- src/application/routing/protocol/ospf/sparo.c	(revision 6677)
+++ src/application/routing/protocol/ospf/sparo.c	(working copy)
@@ -3886,22 +3886,24 @@
         (p_DbEntry->Lsa.LsType == S_NETWORK_LSA)) &&
        (A_GET_2B(p_DbEntry->Lsa.LsAge) >= MaxAge))
    {
      t_VpnCos VpnCos = OSPF_PUBLIC_VPN_ID;
      t_RTB *p_RTB = NULL;
-      /* Remove LSA preparsing elements */
-      if (p_DbEntry->ConnList)
-         LsaParseDel(p_ARO, p_DbEntry);
-
-      if (HL_FindFirst(p_RTO->RtbHl, (byte *) &VpnCos, (void *)&p_RTB) == E_OK)
-      {
-        if(!TIMER_Active(p_RTB->RecalcTimer))
-          /* Start recalculation timer */
-          RTB_ComputeCalcDelay(p_RTB, p_RTO);
-          TIMER_StartSec(p_RTB->RecalcTimer, p_RTB->CalcDelay,
-                         0, RecalcTimerExp, p_RTO->OspfRtbThread.threadHndle);
-      }
+     /* Remove LSA preparsing elements */
+     if (p_DbEntry->ConnList)
+        LsaParseDel(p_ARO, p_DbEntry);
+
+     if (HL_FindFirst(p_RTO->RtbHl, (byte *) &VpnCos, (void *)&p_RTB) == E_OK)
+     {
+       if(!TIMER_Active(p_RTB->RecalcTimer))
+       {
+         /* Start recalculation timer */
+         RTB_ComputeCalcDelay(p_RTB, p_RTO);
+         TIMER_StartSec(p_RTB->RecalcTimer, p_RTB->CalcDelay,
+                        0, RecalcTimerExp, p_RTO->OspfRtbThread.threadHndle);
+       }
+     }
    }
      
    return E_OK;
 }
 
@@ -4342,11 +4344,11 @@
    {
       if(p_foundLsa)
          *p_foundLsa = p_DbEntry;
       if(p_LsId)
          *p_LsId = A_GET_4B(p_DbEntry->Lsa.LsId);
-         return E_OK;
+      return E_OK;
    }
 
    return E_NOT_FOUND;
 }
 
Index: src/application/routing/protocol/ospf/spifo.c
===================================================================
--- src/application/routing/protocol/ospf/spifo.c	(revision 6677)
+++ src/application/routing/protocol/ospf/spifo.c	(working copy)
@@ -345,38 +345,40 @@
   TIMER_Delete( p_IFO->AckTimer );
   TIMER_Delete( p_IFO->HelloTimer );
   TIMER_Delete( p_IFO->WaitTimer );
   TIMER_Delete(p_IFO->grSuppressHelloTimer);
 
-   /* if no more Interfaces in this Area */
-   if (p_ARO && flag)
-      if (HL_GetFirst(p_ARO->IfoHl, (void *)&p_tmpIfo) != E_OK)
-      {
-          if (p_RTO->Cfg.DelAreaOnLastIfDel)
-            ARO_Delete(p_ARO, 1);
-
-         /* If the deleted area is not the last one of the router */
-         /* Recalculate the appropriate routing table             */
-         if(p_RTO->AreasNum != 0)
-         {
-            if(HL_FindFirst(p_RTO->RtbHl, (byte *) &zero, (void *)&p_RTB) == E_OK)
-            {
-               /* Start recalculation timer */
-               if(!TIMER_Active(p_RTB->RecalcTimer))
-               {
-                 RTB_ComputeCalcDelay(p_RTB, p_RTO);
-                 TIMER_StartSec(p_RTB->RecalcTimer, p_RTB->CalcDelay, 0, RecalcTimerExp,
-                                p_RTO->OspfRtbThread.threadHndle);
-               }
-            }
-         }
-      }
+  /* if no more Interfaces in this Area */
+  if (p_ARO && flag)
+  {
+    if (HL_GetFirst(p_ARO->IfoHl, (void *)&p_tmpIfo) != E_OK)
+    {
+        if (p_RTO->Cfg.DelAreaOnLastIfDel)
+          ARO_Delete(p_ARO, 1);
+    
+       /* If the deleted area is not the last one of the router */
+       /* Recalculate the appropriate routing table             */
+       if(p_RTO->AreasNum != 0)
+       {
+          if(HL_FindFirst(p_RTO->RtbHl, (byte *) &zero, (void *)&p_RTB) == E_OK)
+          {
+             /* Start recalculation timer */
+             if(!TIMER_Active(p_RTB->RecalcTimer))
+             {
+               RTB_ComputeCalcDelay(p_RTB, p_RTO);
+               TIMER_StartSec(p_RTB->RecalcTimer, p_RTB->CalcDelay, 0, RecalcTimerExp,
+                              p_RTO->OspfRtbThread.threadHndle);
+             }
+          }
+       }
+    }
+  }
 
-      if (p_IFO->PendingUpdate)
-      {
-        F_Delete(p_IFO->PendingUpdate);
-      }
+  if (p_IFO->PendingUpdate)
+  {
+    F_Delete(p_IFO->PendingUpdate);
+  }
 
 #if L7_OSPF_TE
    /* Free the interface TE Link Lsa instance number   */
    /* (i.e. set the appropriate bit to FALSE)          */
    if (((t_RTO *)p_IFO->RTO_Id)->TeLsaInstBS)
@@ -1268,11 +1270,11 @@
    {
        L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
        nimGetIntfName(p_IFO->Cfg.IfIndex, L7_SYSNAME, ifName);
 
        L7_LOGF(L7_LOG_SEVERITY_INFO, L7_OSPF_MAP_COMPONENT_ID,
-               "Max allowed OSPF pkt len on intf %d, %s is zero", p_IFO->Cfg.IfIndex, ifName);
+               "Max allowed OSPF pkt len on intf %lu, %s is zero", p_IFO->Cfg.IfIndex, ifName);
        return NULL;
    }
 
    p_B = B_NewEx(0, 0, maxBufLen);
    if (p_B == NULL)
Index: src/application/routing/rlim/rlim_api.c
===================================================================
--- src/application/routing/rlim/rlim_api.c	(revision 6677)
+++ src/application/routing/rlim/rlim_api.c	(working copy)
@@ -387,11 +387,11 @@
     if (nimIntfQuery(&nimQueryData) != L7_SUCCESS)
     {
       /* should never get here */
       nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
       L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_RLIM_COMPONENT_ID,
-              "nimIntfQuery() failed for interface %s with intIfNum",
+              "nimIntfQuery() failed for interface %s with intIfNum %u",
               ifName, intIfNum);
       return L7_FAILURE;
     }
 
     if (nimQueryData.data.state >= L7_INTF_CREATED)
Index: src/application/routing/services/rtproto.c
===================================================================
--- src/application/routing/services/rtproto.c	(revision 6677)
+++ src/application/routing/services/rtproto.c	(working copy)
@@ -522,11 +522,11 @@
     rc = L7_FAILURE;
   }
   else
   {
     callbackparam = (cbparam_t *) buffer_addr;
-    memset(callbackparam,0,sizeof(callbackparam));
+    memset(callbackparam,0,sizeof(*callbackparam));
     callbackparam->intIfNum = intIfNum;
     callbackparam->routerIP = dest_ip_addr;
     callbackparam->srcrt = srcrt;
 
     /* Try to resolve the ARP entry. If it is net directed broadcast packet,
Index: src/application/security/dot1x/core/dot1x_control.c
===================================================================
--- src/application/security/dot1x/core/dot1x_control.c	(revision 6677)
+++ src/application/security/dot1x/core/dot1x_control.c	(working copy)
@@ -6329,11 +6329,11 @@
             dot1xMacBasedVlanParticipationReset(logicalPortInfo, logicalPortInfo->defaultVlanId);
           }
 
           logicalPortInfo->isMonitorModeClient = L7_FALSE;
           logicalPortInfo->defaultVlanId = L7_NULL;
-          L7_LOGF(L7_LOG_SEVERITY_ERROR,L7_DOT1X_COMPONENT_ID,"Port:[%u] moved from authenticated state as Monitor Mode is not Operational\n\r",
+          L7_LOGF(L7_LOG_SEVERITY_ERROR,L7_DOT1X_COMPONENT_ID,"%s(%u) Port:[%u] moved from authenticated state as Monitor Mode is not Operational\n\r",
                       __FUNCTION__, __LINE__, lIntIfNum);          
         }
         logicalPortInfo = dot1xLogicalPortInfoGetNextNode(intIfNum, &lIntIfNum);
       }
   }while(dot1xNextValidIntf(intIfNum, &intIfNum) == L7_SUCCESS);
Index: src/application/security/dot1x/core/dot1x_db.c
===================================================================
--- src/application/security/dot1x/core/dot1x_db.c	(revision 6677)
+++ src/application/security/dot1x/core/dot1x_db.c	(working copy)
@@ -181,11 +181,11 @@
       osapiSemaGive(dot1xLogicalPortTreeDb.semId);
       if (retNode == &newNode)
       {
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT1X_COMPONENT_ID,
                 "%s:%d Error Adding the node to the Dot1x Tree for phyintf %s \n",
-                __FUNCTION__,__FILE__,ifName);
+                __FUNCTION__,__LINE__,ifName);
         return L7_NULLPTR;
       }
       return dot1xLogicalPortInfoGet(lIntIfNum);
     }
     else if(tmpNode->inUse == L7_FALSE)
@@ -194,11 +194,11 @@
     }
   }
   L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
       "%s:%d Error allocating node for phyintf %s as it reached maximum limit per port."
       " Could not allocate memory for client as maximum number of clients  allowed per port"
-      " has been reached.", __FUNCTION__,__FILE__,ifName);
+      " has been reached.", __FUNCTION__,__LINE__,ifName);
   return L7_NULLPTR;
 }
 
 /*********************************************************************
 * @purpose  To Deallocate a Logical Port Info Node
Index: src/application/security/dot1x/core/dot1x_debug.c
===================================================================
--- src/application/security/dot1x/core/dot1x_debug.c	(revision 6677)
+++ src/application/security/dot1x/core/dot1x_debug.c	(working copy)
@@ -1369,17 +1369,17 @@
 
       if ((dot1xDebugPacketTraceRxFlag == L7_TRUE) && (rxFlag == L7_TRUE))
       {
         DOT1X_USER_TRACE_RX(DOT1X_DEBUG_PACKET_RX_FORMAT,
                             (L7_uint32)usp.unit, (L7_int32)usp.slot, (L7_int32)usp.port,
-                            intIfNum,ifName,srcMac, destMac, type,code,eapPkt->id);
+                            intIfNum,ifName,srcMac, destMac, type); //,code,eapPkt->id);
       }
       else if ((dot1xDebugPacketTraceTxFlag == L7_TRUE) && (txFlag == L7_TRUE))
       {
         DOT1X_USER_TRACE_TX(DOT1X_DEBUG_PACKET_TX_FORMAT,
                             (L7_uint32)usp.unit, (L7_int32)usp.slot, (L7_int32)usp.port,
-                            intIfNum,ifName,srcMac, destMac, type,code,eapPkt->id);
+                            intIfNum,ifName,srcMac, destMac, type,code); //,eapPkt->id);
       }
     }
   }
 
   return;
Index: src/application/security/mgmt_acal/macal_cnfgr.c
===================================================================
--- src/application/security/mgmt_acal/macal_cnfgr.c	(revision 6677)
+++ src/application/security/mgmt_acal/macal_cnfgr.c	(working copy)
@@ -420,11 +420,11 @@
   *pReason    = 0;
 
   /* Sysnet deregister for Management Access Control and Administration List */
   (void)macalSysnetRegisterDeregister(L7_FALSE);
 
-  memset(macalCfgData, 0, sizeof(macalCfgData));
+  memset(macalCfgData, 0, sizeof(macalCfgData_t));
 
   macalCnfgrState = MACAL_PHASE_WMU;
 
   return L7_SUCCESS;
 }
Index: src/application/switching/dhcp_snooping/core/ds_cnfgr.c
===================================================================
--- src/application/switching/dhcp_snooping/core/ds_cnfgr.c	(revision 6677)
+++ src/application/switching/dhcp_snooping/core/ds_cnfgr.c	(working copy)
@@ -471,11 +471,11 @@
     *pResponse = 0;
     *pReason = L7_CNFGR_ERR_RC_LACK_OF_RESOURCES;
     dsRC = L7_ERROR;
     return dsRC;
   }
-  memset(dsInfo, 0, sizeof(dsInfo));
+  memset(dsInfo, 0, sizeof(*dsInfo));
   dsInfoInit();
   dsBindingsTableCreate();
 #ifdef L7_IPSG_PACKAGE
   ipsgInfo = (ipsgInfo_t*) osapiMalloc(L7_DHCP_SNOOPING_COMPONENT_ID, sizeof(ipsgInfo_t));
   if (!ipsgInfo)
@@ -483,11 +483,11 @@
     *pResponse = 0;
     *pReason = L7_CNFGR_ERR_RC_LACK_OF_RESOURCES;
     dsRC = L7_ERROR;
     return dsRC;
   }
-  memset(ipsgInfo, 0, sizeof(ipsgInfo));
+  memset(ipsgInfo, 0, sizeof(*ipsgInfo));
   ipsgInfoInit();
   ipsgEntryTableCreate();
 #endif
   dsIntfInfo = (dsIntfInfo_t*) osapiMalloc(L7_DHCP_SNOOPING_COMPONENT_ID,
                                            (DS_MAX_INTF_COUNT+1) * sizeof(dsIntfInfo_t));
Index: src/application/switching/dhcp_snooping/core/ds_main.c
===================================================================
--- src/application/switching/dhcp_snooping/core/ds_main.c	(revision 6677)
+++ src/application/switching/dhcp_snooping/core/ds_main.c	(working copy)
@@ -796,11 +796,11 @@
         L7_uchar8 traceMsg[DS_MAX_TRACE_LEN];
         osapiSnprintf(traceMsg, DS_MAX_TRACE_LEN,
                       "(%s) Packet ignored, because of ip source (0x%08x)",
                       __FUNCTION__, osapiNtohl(ipHeader->iph_src));
         dsTraceWrite(traceMsg);
-        PT_LOG_TRACE(LOG_CTX_DHCP,"Packet ignored, because of ip source (0x%08x)", osapiNtohl(ipHeader->iph_src));
+        PT_LOG_TRACE(LOG_CTX_DHCP,"Packet ignored, because of ip source (0x%08x)", (L7_uint32)osapiNtohl(ipHeader->iph_src));
       }
 
       return SYSNET_PDU_RC_IGNORED;
     }
 
@@ -2335,11 +2335,11 @@
    if(L7_DHCP6_OPT_INTERFACE_ID == dhcpOp)
    {
       if(!strlen(circuit_id))
       {
         if (ptin_debug_dhcp_snooping)
-          PT_LOG_ERR(LOG_CTX_DHCP, "DHCP Relay-Agent: Invalid circuit-id string (string length is 0)", circuit_id);
+          PT_LOG_ERR(LOG_CTX_DHCP, "DHCP Relay-Agent: Invalid circuit-id string (string length is 0)");
         return L7_FAILURE;
       }
       if (ptin_debug_dhcp_snooping)
         PT_LOG_TRACE(LOG_CTX_DHCP, "DHCP Relay-Agent: Adding interface-id '%s'", circuit_id);
       memcpy(frame + *frameLen, circuit_id, strlen(circuit_id)); //Copy circuit-id string
@@ -2355,11 +2355,11 @@
      *frameLen += sizeof(L7_uint32);
 
       if(!strlen(remote_id))
       {
         if (ptin_debug_dhcp_snooping)
-          PT_LOG_ERR(LOG_CTX_DHCP, "DHCP Relay-Agent: Invalid remote-id string (string length is 0)", remote_id);
+          PT_LOG_ERR(LOG_CTX_DHCP, "DHCP Relay-Agent: Invalid remote-id string (string length is 0)");
         return L7_FAILURE;
       }
       if (ptin_debug_dhcp_snooping)
         PT_LOG_TRACE(LOG_CTX_DHCP, "DHCP Relay-Agent: Adding remote-id '%s'", remote_id);
       memcpy(frame + *frameLen, remote_id, strlen(remote_id)); //Copy remote-id string
@@ -3557,11 +3557,11 @@
   passOverLen = relayEnd - (L7_uchar8 *)packet;
   relayOffset += DHCP_OPTION_CONTENT_OFFSET;
   while ((relayOffset < relayEnd) && (*relayOffset != DHO_END))
   {
     if (ptin_debug_dhcp_snooping)
-      PT_LOG_TRACE(LOG_CTX_DHCP,"Suboption detected? %u (relayOffset=%u)",*relayOffset,relayOffset);
+      PT_LOG_TRACE(LOG_CTX_DHCP,"Suboption detected? (relayOffset=%u)", *relayOffset);
 
     switch (*relayOffset)
     {
     case DHCP_RELAY_AGENT_CIRCUIT_ID_SUBOPTION:
       {
@@ -4230,11 +4230,11 @@
             lastMsg = osapiUpTimeRaw();
             nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
             dsMacToString(srcMacAddr->addr, srcMacStr);
             L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_DHCP_SNOOPING_COMPONENT_ID,
                     "DHCP snooping dropping %s received on "
-                    "interface %s, vlan %u, from %s. Station not in bindings table.",
+                    "interface %s, vlan %u, from %s. Station not in bindings table."
                       " This message appears when DHCP Snooping untrusted port  drops "
                       "DHCP Decline or DHCP release messages for a non-existing entry "
                       "in SNOOPING table.",
                     dhcpMsgTypeNames[dhcpPktType], ifName, vlanId, srcMacStr);
             dsLogEthernetHeader((L7_enetHeader_t*) frame, DS_TRACE_LOG);
Index: src/application/switching/dhcp_snooping/core/ds_util.c
===================================================================
--- src/application/switching/dhcp_snooping/core/ds_util.c	(revision 6677)
+++ src/application/switching/dhcp_snooping/core/ds_util.c	(working copy)
@@ -593,11 +593,11 @@
   if (intIfNum > DS_MAX_INTF_COUNT)
     return L7_FALSE;
   if (dsIntfInfo[intIfNum].dsNumVlansEnabled > 0)
     return L7_TRUE;
 
-    return L7_FALSE;
+  return L7_FALSE;
 }
 
 /*********************************************************************
 * @purpose  Enable DHCP snooping on a port.
 *
Index: src/application/switching/dynamic_arp_inspection/dai_cnfgr.c
===================================================================
--- src/application/switching/dynamic_arp_inspection/dai_cnfgr.c	(revision 6677)
+++ src/application/switching/dynamic_arp_inspection/dai_cnfgr.c	(working copy)
@@ -410,11 +410,11 @@
     *pResponse = 0;
     *pReason = L7_CNFGR_ERR_RC_LACK_OF_RESOURCES;
     daiRC = L7_ERROR;
     return daiRC;
   }
-  memset(daiInfo, 0, sizeof(daiInfo));
+  memset(daiInfo, 0, sizeof(*daiInfo));
   daiInfoInit();
 
   daiIntfInfo = (daiIntfInfo_t*) osapiMalloc(L7_DAI_COMPONENT_ID,
                                              DAI_MAX_INTF_COUNT * sizeof(daiIntfInfo_t));
   if (!daiIntfInfo)
Index: src/application/switching/garp/garp_debug.c
===================================================================
--- src/application/switching/garp/garp_debug.c	(revision 6677)
+++ src/application/switching/garp/garp_debug.c	(working copy)
@@ -2167,11 +2167,11 @@
   {
     L7_uint32 i=0;
     if ( vlanId > L7_MAX_VLANS)
     {
       L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_GARP_COMPONENT_ID,
-              "\n%s: Vlan Id out of range. Vlan Id : %u",vlanId);
+              "\n%s: Vlan Id out of range. Vlan Id : %u", __FUNCTION__, vlanId);
       return;
     }
 
     /* check if vlanId needs to be tracked */
     for(i=0;i<vlanCnt;i++)
@@ -2230,11 +2230,11 @@
    }
 
    if ((VlanIndx <0 ) || ( VlanIndx > L7_MAX_VLAN_TRACK))
    {
      L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_GARP_COMPONENT_ID,
-             "\n%s: Vlan Id out of range. Vlan Index : %u",VlanIndx);
+             "\n%s: Vlan Id out of range. Vlan Index : %u", __FUNCTION__, VlanIndx);
      return;
    }
 
    /* set vlan cnt */
    if (garpDebugVlanRec[VlanIndx].bVlanCreated == L7_FALSE)
Index: src/application/switching/garp/garp_timer.c
===================================================================
--- src/application/switching/garp/garp_timer.c	(revision 6677)
+++ src/application/switching/garp/garp_timer.c	(working copy)
@@ -262,11 +262,11 @@
 
 
     if (timerList == L7_NULL)
     {
         L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_GARP_COMPONENT_ID,
-                "Error:Timer Type (%d) of the timer (%x) invalid :timerList cannot be found \n", pTimer->timerType , pTimer);
+                "Error:Timer Type (%d) of the timer (%x) invalid :timerList cannot be found \n", pTimer->timerType , (L7_uint)pTimer);
         return rc;
     }
 
     if (timerList->head == L7_NULL)
     {
@@ -412,11 +412,11 @@
 
     /* delete pTimer from listToSearch */
     if (garpTimerListDeleteElement(pTimer,timerList)!= L7_SUCCESS)
     {
         L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_GARP_COMPONENT_ID,
-                "Failed to free timer: timerType %d, port %d, vid %d, status %d, expiry %d\n",
+                "Failed to free timer: timerType %d, port %d, vid %d, status %d, expiry %lld\n",
                 pTimer->timerType, pTimer->port_no, pTimer->vid, pTimer->timer_status,
                 pTimer->expiryTime);
     }
 
     /* Mark the timer as being unused */
@@ -476,11 +476,11 @@
         }
     }
     else
     {
         /* A timer is being added */
-        memset(pTimer, 0, sizeof(pTimer));
+        memset(pTimer, 0, sizeof(*pTimer));
 
         pTimer->timerType    = timer_type;
         pTimer->vid          = vid;
         pTimer->port_no      = port_no;
         pTimer->expiryTime   = newExpiryTime;
@@ -824,11 +824,11 @@
                 milliseconds = rand();
 
                 pTimer = &timerList[index % 20];
                 index++;
 
-                memset(pTimer, 0, sizeof(pTimer));
+                memset(pTimer, 0, sizeof(*pTimer));
 
                 pTimer->timerType    = 4;
                 pTimer->vid          = 1;
                 pTimer->port_no      = 21;
                 pTimer->expiryTime   = milliseconds + osapiTimeMillisecondsGet64();
Index: src/application/switching/garp/garpapi.c
===================================================================
--- src/application/switching/garp/garpapi.c	(revision 6677)
+++ src/application/switching/garp/garpapi.c	(working copy)
@@ -507,11 +507,11 @@
 void garpIntfStartupCallback(NIM_STARTUP_PHASE_t startupPhase)
 {
   GarpPacket   msg;
   L7_RC_t      rc;
 
-  if (!GarpIsReady() == L7_TRUE)
+  if (GarpIsReady() != L7_TRUE)
   {
     nimStartupEventDone(L7_GARP_COMPONENT_ID);
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_GARP_COMPONENT_ID,
             "Received NIM startup %d callback while in init state %s",
             startupPhase, garpCnfgrStateNames[garpCnfgrState]);
Index: src/application/switching/garp/gid.c
===================================================================
--- src/application/switching/garp/gid.c	(revision 6677)
+++ src/application/switching/garp/gid.c	(working copy)
@@ -108,11 +108,11 @@
    GARP_TRACE_INTERNAL_EVENTS("%s Gid %x created for port no %d application %s \n",
                                __FUNCTION__, my_port, port_no,
                               (GARP_GMRP_APP == application->app) ? "GMRP" :
                               (GARP_GVRP_APP == application->app) ? "GVRP" : "Unknown");
 
-   memset(my_port, 0x00, sizeof(my_port));
+   memset(my_port, 0x00, sizeof(*my_port));
 
    my_port->application            = application;
    my_port->port_no                = port_no;
    my_port->next_in_port_ring      = my_port;
    my_port->next_in_connected_ring = my_port;
Index: src/application/switching/link_aggregation/core/dot3ad_cfg.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_cfg.c	(revision 6677)
+++ src/application/switching/link_aggregation/core/dot3ad_cfg.c	(working copy)
@@ -482,11 +482,11 @@
         break;
 
       default:
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
                 "%s: notification received for unknown event(%d), intf(%s), reason(%d)\n",
-            retVal.event,ifName,retVal.response.reason);
+            __FUNCTION__,retVal.event,ifName,retVal.response.reason);
         /* only care about create for now */
         break;
     }
   }
 }
Index: src/application/switching/link_aggregation/core/dot3ad_debug.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_debug.c	(revision 6677)
+++ src/application/switching/link_aggregation/core/dot3ad_debug.c	(working copy)
@@ -853,11 +853,11 @@
   }
 }
 
 L7_uchar8* dot3adDisplayState(L7_uchar8 state, L7_uchar8 *buf, L7_uint32 size)
 {
- memset(buf,0,sizeof(buf));
+ memset(buf,0,size);
 
  if (state & DOT3AD_STATE_EXPIRED)
  {
   osapiSnprintfcat(buf,size,"Exp,");
  }
Index: src/application/switching/link_aggregation/core/dot3ad_lac.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_lac.c	(revision 6677)
+++ src/application/switching/link_aggregation/core/dot3ad_lac.c	(working copy)
@@ -4891,20 +4891,22 @@
           p->portEnabled = L7_TRUE;
         else
           p->portEnabled = L7_FALSE;
         if (linkState == L7_UP)
         {
-          if (p->lacpEnabled == L7_TRUE)
+          if (p->lacpEnabled == L7_TRUE) {
             rc2=LACIssueCmd(lacpPortEnabledLacpEnabled,p->actorPortNum,L7_NULL);
-             if (rc2 != L7_SUCCESS)
-               L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
-                       "\n aggStaticModeSet: Static to Dynamic:Failure to Send lacpPortEnabledLacpEnabled for configured port : %d\n",a->aggWaitSelectedPortList[i]);
-          else
+            if (rc2 != L7_SUCCESS)
+              L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
+                      "\n aggStaticModeSet: Static to Dynamic:Failure to Send lacpPortEnabledLacpEnabled for configured port : %d\n",a->aggWaitSelectedPortList[i]);
+          }
+          else {
             rc2=LACIssueCmd(lacpPortEnabledLacpDisabled,p->actorPortNum,L7_NULL);
             if (rc2 != L7_SUCCESS)
-               L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
-                       "\n aggStaticModeSet: Static to Dynamic:Failure to Send lacpPortEnabledLacpDisabled for configured port : %d\n",a->aggWaitSelectedPortList[i]);
+              L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DOT3AD_COMPONENT_ID,
+                      "\n aggStaticModeSet: Static to Dynamic:Failure to Send lacpPortEnabledLacpDisabled for configured port : %d\n",a->aggWaitSelectedPortList[i]);
+          }
         }/* link up*/
 
       }/* p!=NULLPTR*/
     }/* for each configured port*/
   
Index: src/application/switching/link_aggregation/core/dot3ad_lacp.c
===================================================================
--- src/application/switching/link_aggregation/core/dot3ad_lacp.c	(revision 6677)
+++ src/application/switching/link_aggregation/core/dot3ad_lacp.c	(working copy)
@@ -92,11 +92,15 @@
 };
 
 extern L7_uint32 dot3adBufferPoolId;
 
 static unsigned short int ptin_debug_lacp = 0;
-inline void ptin_debug_lacp_set(unsigned short int enable){ptin_debug_lacp = enable;};
+
+static inline void ptin_debug_lacp_set(unsigned short int enable)
+{
+  ptin_debug_lacp = enable;
+};
 
 /**************************************************************************
 *
 * @purpose  Records the parameter values for the actor carried in the rx pdu
 *
Index: src/application/switching/port_mac_locking/pml_cnfgr.c
===================================================================
--- src/application/switching/port_mac_locking/pml_cnfgr.c	(revision 6677)
+++ src/application/switching/port_mac_locking/pml_cnfgr.c	(working copy)
@@ -484,11 +484,11 @@
     pmlRC     = L7_ERROR;
 
     return pmlRC;
   }
 
-  memset(pmlCfgData, 0, sizeof(pmlCfgData));
+  memset(pmlCfgData, 0, sizeof(*pmlCfgData));
 
   pmlCnfgrState = PML_PHASE_WMU;
 
   return pmlRC;
 }
Index: src/application/switching/snooping/core/snooping.c
===================================================================
--- src/application/switching/snooping/core/snooping.c	(revision 6677)
+++ src/application/switching/snooping/core/snooping.c	(working copy)
@@ -632,11 +632,11 @@
        ptin_timer_stop(74);  
        /*Client Does Not Exist*/
        if (rc == L7_NOT_EXIST)
        {
          #ifdef IGMP_DYNAMIC_CLIENTS_SUPPORTED
-          PT_LOG_TRACE(LOG_CTX_IGMP,"Client Does Not Exist: (intIfNum=%u vlan=%u innerVlanId=%u", rc, pduInfo->intIfNum, pduInfo->vlanId, pduInfo->innerVlanId);  
+          PT_LOG_TRACE(LOG_CTX_IGMP,"Client Does Not Exist: (intIfNum=%u vlan=%u innerVlanId=%u", pduInfo->intIfNum, pduInfo->vlanId, pduInfo->innerVlanId);  
          #else         
           PT_LOG_ERR(LOG_CTX_IGMP,"Failed (rc:%u) to obtain clientId (intIfNum=%u vlan=%u innerVlanId=%u", rc, pduInfo->intIfNum, pduInfo->vlanId, pduInfo->innerVlanId);  
           return L7_FAILURE;
          #endif
        }
@@ -808,19 +808,20 @@
           sourceAddr.addr.ipv4.s_addr = osapiNtohl(sourceAddr.addr.ipv4.s_addr);
         }        
       }
       else
       {
-        PT_LOG_DEBUG(LOG_CTX_IGMP,"Number of Group Records:%u [vlan=%u innerVlan=%u client_idx]: Packet Silently ignored...",
+        PT_LOG_DEBUG(LOG_CTX_IGMP,"Number of Group Records:%u [vlan=%u innerVlan=%u client_idx=%u]: Packet Silently ignored...",
                 noOfGroupRecords, pduInfo->vlanId, pduInfo->innerVlanId, client_idx);  
         ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
         return L7_FAILURE;
       }      
     }
     else
     {
-      PT_LOG_ERR(LOG_CTX_IGMP, "Protocol Not Supported :%u [vlan=%u innerVlan=%u client_idx]", igmpPtr[0], pduInfo->vlanId, pduInfo->innerVlanId, client_idx);
+      PT_LOG_ERR(LOG_CTX_IGMP, "Protocol Not Supported :%u [vlan=%u innerVlan=%u client_idx=%u]",
+                 igmpPtr[0], pduInfo->vlanId, pduInfo->innerVlanId, client_idx);
       ptin_igmp_stat_increment_field(pduInfo->intIfNum, pduInfo->vlanId, client_idx, SNOOP_STAT_FIELD_IGMP_RECEIVED_INVALID);
       return L7_NOT_SUPPORTED;
     }
      
     /*RFC5771 - Local Network Control Block (224.0.0.0 - 224.0.0.255 (224.0.0/24)) 
@@ -1765,11 +1766,11 @@
   else if (rc==L7_FAILURE) /*Invalid Packet Type*/
     snoopStatIgmpField=SNOOP_STAT_FIELD_INVALID_RX;
   else /*if (rc==L7_ERROR)*/
     snoopStatIgmpField=SNOOP_STAT_FIELD_DROPPED_RX;               
 
-    ptin_igmp_stat_increment_field(mcastPacket.intIfNum, mcastPacket.vlanId, mcastPacket.client_idx, snoopPacketType2IGMPStatField(/*mcastPacket.msgType*/msgType,snoopStatIgmpField));
+  ptin_igmp_stat_increment_field(mcastPacket.intIfNum, mcastPacket.vlanId, mcastPacket.client_idx, snoopPacketType2IGMPStatField(/*mcastPacket.msgType*/msgType,snoopStatIgmpField));
 #endif
 
 
   /* If client is dynamic, and no channels are associated, flush it */
   //ptin_igmp_dynamic_client_flush(mcastPacket.vlanId, mcastPacket.client_idx);
Index: src/application/switching/snooping/core/snooping_api.c
===================================================================
--- src/application/switching/snooping/core/snooping_api.c	(revision 6677)
+++ src/application/switching/snooping/core/snooping_api.c	(working copy)
@@ -93,11 +93,11 @@
   }
   else
   {
     if (workingPortId == protectionPortId)
     {
-      PT_LOG_ERR(LOG_CTX_PROTB, "Invalid Configuration: protectionSlotId:%u == workingSlotId:%u && workingPortId == protectionPortId = :%u", protectionSlotId, workingPortId);
+      PT_LOG_ERR(LOG_CTX_PROTB, "Invalid Configuration: protectionSlotId:%u == workingSlotId:%u && workingPortId == protectionPortId = :%u", protectionSlotId, workingSlotId, workingPortId);
       return L7_FAILURE;
     }
   }  
 
   /* Fill the sync structure */
@@ -4080,11 +4080,11 @@
   char           sourceAddrStr[IPV6_DISP_ADDR_LEN]={};
 
   inetAddrPrint(groupAddr, groupAddrStr);
   inetAddrPrint(sourceAddr, sourceAddrStr);
 
-  PT_LOG_DEBUG(LOG_CTX_IGMP, "Context [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s isProtection:%s]", serviceId, intIfNum, groupAddr, sourceAddr, isProtection?"Yes":"No");
+  PT_LOG_DEBUG(LOG_CTX_IGMP, "Context [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s isProtection:%s]", serviceId, intIfNum, groupAddrStr, sourceAddrStr, isProtection?"Yes":"No");
 
 #if !PTIN_SYSTEM_IGMP_L3_MULTICAST_FORWARD
   /*In L2 we do not support forwarding multicast packets based on the Source Address. 
     To support IGMPv3 protocol we only close the ports if the Source Address is equal to 0x0000.
     If not we ignore the request*/
@@ -4113,11 +4113,11 @@
   #endif
   && isProtection == L7_FALSE
   )
   {
 //  if (ptin_debug_igmp_snooping)
-      PT_LOG_NOTICE(LOG_CTX_IGMP, "Ignoring Port Close. This port is standby [serviceId:%u portId:%u groupAddr:%08X sourceAddr:%08X]", serviceId, intIfNum, groupAddr, sourceAddr);
+      PT_LOG_NOTICE(LOG_CTX_IGMP, "Ignoring Port Close. This port is standby [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s]", serviceId, intIfNum, groupAddrStr, sourceAddrStr);
    
     return rc;
   } 
 
   /* Get Snoop Execution Block and Control Block */
Index: src/application/switching/snooping/core/snooping_ctrl.c
===================================================================
--- src/application/switching/snooping/core/snooping_ctrl.c	(revision 6677)
+++ src/application/switching/snooping/core/snooping_ctrl.c	(working copy)
@@ -3388,11 +3388,12 @@
   if( L7_SUCCESS != (rc=ptin_evc_intRootVlan_get(serviceId, &mcastRootVlan)))
   {
     if( rc != L7_NOT_EXIST)
     {
       if (ptin_debug_igmp_snooping)
-        PT_LOG_ERR(LOG_CTX_IGMP, "Unable to get mcastRootVlan [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s isStatic:%s isProtection:%s]", mcastRootVlan, serviceId, intIfNum, groupAddrStr, sourceAddrStr, isStatic?"Yes":"No", isProtection?"Yes":"No");
+        PT_LOG_ERR(LOG_CTX_IGMP, "Unable to get mcastRootVlan [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s isStatic:%s isProtection:%s]",
+                   serviceId, intIfNum, groupAddrStr, sourceAddrStr, isStatic?"Yes":"No", isProtection?"Yes":"No");
       return;
     }
     if (ptin_debug_igmp_snooping)
       PT_LOG_NOTICE(LOG_CTX_IGMP, "Evc Id is not yet created. Silently Ignoring Port Open Request! [serviceId:%u portId:%u groupAddr:%s sourceAddr:%s isStatic:%s isProtection:%s]", serviceId, intIfNum, groupAddrStr, sourceAddrStr, isStatic?"Yes":"No", isProtection?"Yes":"No");
     return;
Index: src/application/switching/snooping/core/snooping_db.c
===================================================================
--- src/application/switching/snooping/core/snooping_db.c	(revision 6677)
+++ src/application/switching/snooping/core/snooping_db.c	(working copy)
@@ -1691,11 +1691,11 @@
 
   /* Verify if one more client can be added */
   if (snoopEntry->channel_list[channel_index].number_of_clients>=PTIN_SYSTEM_IGMP_MAXCLIENTS)
   {
     if (ptin_debug_igmp_snooping)
-      PT_LOG_ERR(LOG_CTX_IGMP,"snoopClientAdd: No more room to add a new client",client);
+      PT_LOG_ERR(LOG_CTX_IGMP,"snoopClientAdd: No more room to add a new client (idx %u)", client);
     return L7_FAILURE;
   }
 
   /* Activate new client for this IP channel */
   PTIN_SET_MASKBIT(snoopEntry->channel_list[channel_index].clients_list,client);
@@ -1815,10 +1815,11 @@
   L7_BOOL fwdFlag = L7_FALSE;
   L7_uint32 igmp_network_version;
   L7_uint32 intIfNum;
   L7_INTF_MASK_t mcastClientAttached;
   L7_uint32      noOfInterfaces = 0;
+  L7_char8       groupAddrStr[IPV6_DISP_ADDR_LEN];
 
   /* Validate arguments */
   if (dmac==L7_NULLPTR || vlanId<PTIN_VLAN_MIN || vlanId>PTIN_VLAN_MAX ||
       mgmdGroupAddr==L7_NULLPTR || mgmdGroupAddr->family!=L7_AF_INET)
   {
@@ -1959,11 +1960,11 @@
         if ( (L7_INTF_ISMASKBITSET(mcastClientAttached,intIfNum)) )
         {
           if (snoopChannelIntfAdd(snoopEntry, intIfNum, mgmdGroupAddr, L7_FALSE)!=L7_SUCCESS)
           {
             if (ptin_debug_igmp_snooping)
-              PT_LOG_ERR(LOG_CTX_IGMP, "Error adding intIfNum %u to channel 0x%08x",intIfNum,mgmdGroupAddr);
+              PT_LOG_ERR(LOG_CTX_IGMP, "Error adding intIfNum %u to channel %s", intIfNum, inetAddrPrint(mgmdGroupAddr,  groupAddrStr));
           }
         }
       }
     }
 
@@ -3488,11 +3489,11 @@
 
         if (PTIN_IS_MASKBITSET(pChannelIntfMask->snoopChannelIntfMaskInfoDataKey.channelIntfMask, intf))
         {
           if (intf == intIfNum)
           {
-            PT_LOG_ERR(LOG_CTX_IGMP, "intf == intIfNum", intf, intIfNum);              
+            PT_LOG_ERR(LOG_CTX_IGMP, "intf == intIfNum = %u", intf);
           }
           #if defined IGMP_SMART_MC_EVC_SUPPORTED
           l3_intf_id = -1;
           L7_uint32 iptv_evc_id;
 
@@ -4126,11 +4127,11 @@
 
   /* Find snoop entry */
   if ((entry=snoopEntryFind(dmac,vlanId,L7_AF_INET,AVL_EXACT))==L7_NULLPTR)
   {
     if (ptin_debug_igmp_snooping)
-      PT_LOG_WARN(LOG_CTX_IGMP,"VLAN+MAC (%u+%02x:02x:02x:02x:02x:02x) do not exist!",vlanId,dmac[0],dmac[1],dmac[2],dmac[3],dmac[4],dmac[5]);
+      PT_LOG_WARN(LOG_CTX_IGMP,"VLAN+MAC (%u+%02x:%02x:%02x:%02x:%02x:%02x) do not exist!",vlanId,dmac[0],dmac[1],dmac[2],dmac[3],dmac[4],dmac[5]);
     return L7_FALSE;
   }
 
   /* Output snoop entry pointer */
   if (snoopEntry!=L7_NULLPTR)
@@ -4412,11 +4413,12 @@
       PT_LOG_NOTICE(LOG_CTX_IGMP,"Found group :%s", inetAddrPrint(&avlTreeEntry->snoopPTinL3InfoDataKey.mcastGroupAddr, debug_buf));
 
       snoopPTinL3Interface_t  *interface_ptr;
       L7_uint8                sourceIdx;
 
-      PT_LOG_TRACE(LOG_CTX_IGMP,"\tInterface:%u Clients:0x%0*X", 8*PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE, SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM);
+// ARS: comentado porque no existe correlao entre a fmt string e os parametros
+//      PT_LOG_TRACE(LOG_CTX_IGMP,"\tInterface:%u Clients:0x%0*X", 8*PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE, SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM);
 
       //Add an entry for clients that have requested this group but with no source in particular.
       interface_ptr = &avlTreeEntry->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM];
 
       
@@ -4448,11 +4450,12 @@
             snoopPTinZeroClients(avlTreeEntry->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM].sources[sourceIdx].clients)==L7_ALREADY_CONFIGURED)
         { 
           //Filter by client (if requested)
           if ((client_index == (L7_uint16)-1) || (PTIN_IS_MASKBITSET(avlTreeEntry->interfaces[intIfNum].sources[sourceIdx].clients, client_index)))
           {
-            PT_LOG_TRACE(LOG_CTX_IGMP,"\t\tSource:0x%08X Clients:0x%0*X", 8*PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE, source_ptr->sourceAddr);
+// ARS: comentado porque no existe correlao entre a fmt string e os parametros
+//            PT_LOG_TRACE(LOG_CTX_IGMP,"\t\tSource:0x%08X Clients:0x%0*X", 8*PTIN_SYSTEM_IGMP_CLIENT_BITMAP_SIZE, source_ptr->sourceAddr);
             inetCopy(&channel_list[*num_channels].groupAddr, &avlTreeKey.mcastGroupAddr);
             inetCopy(&channel_list[*num_channels].sourceAddr, &source_ptr->sourceAddr);
             /* If group address is static, get static information to source channel */
             if (avlTreeEntry->interfaces[SNOOP_PTIN_PROXY_ROOT_INTERFACE_NUM].isStatic)
             {
@@ -6034,13 +6037,13 @@
 #if 0
   fdbGetTypeOfVL(&fdbType);
 #endif
 
 //memcpy(&key.interfacePtr,&interfacePtr, sizeof(snoopPTinProxyInterface_t*));
-  memcpy(&key.vlanId,&vlanId, sizeof(L7_uint32*));  
-  memcpy(&key.groupAddr,groupAddr,sizeof(L7_inet_addr_t));
-  memcpy(&key.recordType,&recordType,sizeof(L7_uint8));
+  memcpy(&key.vlanId, &vlanId, sizeof(key.vlanId));  
+  memcpy(&key.groupAddr, groupAddr,sizeof(L7_inet_addr_t));
+  memcpy(&key.recordType, &recordType,sizeof(L7_uint8));
   pData = avlSearchLVL7(&pSnoopEB->snoopPTinProxyGroupAvlTree, &key, flag);
   if (flag == L7_MATCH_GETNEXT)
   {
     while (pData)
     {
Index: src/application/switching/snooping/core/snooping_ptin_db.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_db.c	(revision 6677)
+++ src/application/switching/snooping/core/snooping_ptin_db.c	(working copy)
@@ -3288,11 +3288,12 @@
  *************************************************************************/
 L7_RC_t snoopPTinAddStaticGroup(L7_uint32 vlanId, L7_uint32 intIfNum,L7_inet_addr_t *groupAddr,L7_uint32 noOfSources,L7_inet_addr_t* sourceAddr)
 {
   ptin_IgmpProxyCfg_t igmpCfg;  
   L7_uint32 clientIdx;
-  snoopPTinL3InfoData_t  *snoopEntry; 
+  snoopPTinL3InfoData_t  *snoopEntry;
+  L7_uchar8 groupAddrStr[IPV6_DISP_ADDR_LEN];
 
   L7_BOOL newEntry,interfaceProvided=L7_FALSE;
 
 
   L7_RC_t rc=L7_SUCCESS;
@@ -3331,11 +3332,11 @@
       PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Add L3 Entry");
       return L7_FAILURE;
     }
     else
     {
-      PT_LOG_TRACE(LOG_CTX_IGMP, "snoopPTinL3EntryAdd(%u,%u)",groupAddr,vlanId);
+      PT_LOG_TRACE(LOG_CTX_IGMP, "snoopPTinL3EntryAdd(%u,%s)", vlanId, inetAddrPrint(groupAddr, groupAddrStr));
     }
     if (L7_NULLPTR == (snoopEntry = snoopPTinL3EntryFind(vlanId, groupAddr, L7_MATCH_EXACT)))
     {
       PT_LOG_ERR(LOG_CTX_IGMP, "Failed to Add&Find L3 Entry");
       return L7_FAILURE;
Index: src/application/switching/snooping/core/snooping_ptin_grouptimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_grouptimer.c	(revision 6677)
+++ src/application/switching/snooping/core/snooping_ptin_grouptimer.c	(working copy)
@@ -594,11 +594,11 @@
     {
       PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
     }
     pTimer->timer = L7_NULLPTR;
     handleListNodeDelete(handleList, &pTimer->timerHandle);
-    memset(pTimer, 0x00, sizeof(pTimer));
+    memset(pTimer, 0x00, sizeof(*pTimer));
     osapiSemaGive(timerSem);
     PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
     return L7_FAILURE;
   }
 
Index: src/application/switching/snooping/core/snooping_ptin_proxytimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_proxytimer.c	(revision 6677)
+++ src/application/switching/snooping/core/snooping_ptin_proxytimer.c	(working copy)
@@ -519,11 +519,11 @@
   {
 #if 0
     PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Group timer (timeout:%u group:%s)",timeout,
               inetAddrPrint(&pTimer->(snoopPTinProxyGroup_t*)(groupData)->key.groupAddr, debug_buf));
 #else
-    PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Group timer (timeout:%u groupRecord:%u",timeout);
+    PT_LOG_DEBUG(LOG_CTX_IGMP,"Starting Proxy Group timer (timeout:%u",timeout);
 #endif
   }
 
   /* New timer handle */
   if ((pTimer->timerHandle = handleListNodeStore(handleList, pTimer)) == 0)
@@ -553,11 +553,11 @@
     {
       PT_LOG_ERR(LOG_CTX_IGMP,"Failed to delete timer");
     }
     pTimer->timer = L7_NULLPTR;
     handleListNodeDelete(handleList, &pTimer->timerHandle);
-    memset(pTimer, 0x00, sizeof(pTimer));
+    memset(pTimer, 0x00, sizeof(*pTimer));
     osapiSemaGive(timerSem);
     PT_LOG_WARN(LOG_CTX_IGMP,"Could not add new timer data node");
     return L7_FAILURE;
   }
 
Index: src/application/switching/snooping/core/snooping_ptin_querytimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_querytimer.c	(revision 6677)
+++ src/application/switching/snooping/core/snooping_ptin_querytimer.c	(working copy)
@@ -389,11 +389,11 @@
   if (interfacePtr->filtermode == PTIN_SNOOP_FILTERMODE_EXCLUDE)
   {
     L7_uint32 i;
 
     /* Remove every source whose timer has expired */
-    for (i = 0; i < PTIN_SYSTEM_IGMP_MAXSOURCES_PER_GROUP; ++i)
+    for (i = 0; i < (sizeof(interfacePtr->sources)/sizeof(*interfacePtr->sources)); ++i)
     {
       sourcePtr = &interfacePtr->sources[i];
       if (sourcePtr->sourceTimer.isRunning == L7_FALSE)
       {
         PT_LOG_DEBUG(LOG_CTX_IGMP,"Removing sourceIdx %u", i);
Index: src/application/switching/snooping/core/snooping_ptin_sourcetimer.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_sourcetimer.c	(revision 6677)
+++ src/application/switching/snooping/core/snooping_ptin_sourcetimer.c	(working copy)
@@ -401,12 +401,15 @@
   interfacePtr = &groupData->interfaces[intIfNum];
   sourcePtr    = &groupData->interfaces[intIfNum].sources[sourceIdx];
 
   osapiSemaGive(timerSem);
 
-  PT_LOG_TRACE(LOG_CTX_IGMP,"Sourcetimer expired (group:%s vlan:%u ifId:%u sourceAddr)", 
-            inetAddrPrint(&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf), groupData->snoopPTinL3InfoDataKey.vlanId, intIfNum, inetAddrPrint(&sourcePtr->sourceAddr,debug_buf2));
+  PT_LOG_TRACE(LOG_CTX_IGMP,"Sourcetimer expired (group:%s vlan:%u ifId:%u sourceAddr:%s)", 
+               inetAddrPrint(&(groupData->snoopPTinL3InfoDataKey.mcastGroupAddr), debug_buf),
+               groupData->snoopPTinL3InfoDataKey.vlanId,
+               intIfNum,
+               inetAddrPrint(&sourcePtr->sourceAddr,debug_buf2));
 
   /* Check if our handle is OK*/
   if (timerHandle != pTimerData->timerHandle)
   {
     PT_LOG_ERR(LOG_CTX_IGMP,"timerHandle and pTimerData->timerHandle do not match!");    
Index: src/application/switching/snooping/core/snooping_ptin_util.c
===================================================================
--- src/application/switching/snooping/core/snooping_ptin_util.c	(revision 6677)
+++ src/application/switching/snooping/core/snooping_ptin_util.c	(working copy)
@@ -720,11 +720,12 @@
     snoopMulticastMacFromIpAddr(destIp, destMac);
 
     /* Validate MAC address */
     if (snoopMacAddrCheck(destMac, L7_AF_INET) != L7_SUCCESS)
     {
-      PT_LOG_ERR(LOG_CTX_IGMP, "Invalid MAC Address :%06x",destMac);
+      PT_LOG_ERR(LOG_CTX_IGMP, "Invalid MAC Address :%02x:%02x:%02x:%02x:%02x:%02x",
+                 destMac[0], destMac[1], destMac[2], destMac[3], destMac[4], destMac[5]);
       return L7_FAILURE;
     }
 
     /* Get base MAC address (could be BIA or LAA) and use it as src MAC */
     if (simGetSystemIPMacType() == L7_SYSMAC_BIA)
@@ -829,11 +830,11 @@
   *length = L7_ENET_HDR_SIZE + 4 + L7_ENET_ENCAPS_HDR_SIZE + L7_IP_HDR_LEN + IGMP_IP_ROUTER_ALERT_LENGTH + igmpFrameLength;
 
   /* Verify packet size */
   if (*length > L7_MAX_FRAME_SIZE)
   {
-    PT_LOG_ERR(LOG_CTX_IGMP, "Packet Size Invalid length : %u > L7_MAX_FRAME_SIZE",*length,L7_MAX_FRAME_SIZE);
+    PT_LOG_ERR(LOG_CTX_IGMP, "Packet Size Invalid length : %u > L7_MAX_FRAME_SIZE=%u", *length, L7_MAX_FRAME_SIZE);
     return L7_FAILURE;
   }
   else
   {
     PT_LOG_TRACE(LOG_CTX_IGMP, "Packet Size length : %u" ,*length);
Index: src/application/switching/snooping/core/snooping_timer.c
===================================================================
--- src/application/switching/snooping/core/snooping_timer.c	(revision 6677)
+++ src/application/switching/snooping/core/snooping_timer.c	(working copy)
@@ -241,11 +241,11 @@
 
       if (snoopTimerStart(L7_NULL, intIfNum, vlanId, timerType, pSnoopCB)
                             != L7_SUCCESS)
       {
         L7_LOGF(L7_LOG_SEVERITY_WARNING, L7_SNOOPING_COMPONENT_ID,
-               "snoopTimerUpdate: Failed to re-start mrtr timer\n", timerValue);
+               "snoopTimerUpdate: Failed to re-start mrtr timer\n");
       }
     }/* End of mrtr timer data validity check */
   }/* End of timer type check */
 }
 /*************************************************************************
Index: src/application/switching/spanning_tree/dot1s/core/dot1s_cfg.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/core/dot1s_cfg.c	(revision 6677)
+++ src/application/switching/spanning_tree/dot1s/core/dot1s_cfg.c	(working copy)
@@ -536,84 +536,84 @@
     if (nimIntIfFromConfigIDGet(&dot1sCfg->cfg.dot1sCfgPort[i].configId, &intIfNum) != L7_SUCCESS)
       continue;
     if (dot1sIsValidIntf(intIfNum) != L7_TRUE)
       continue;
 
-      pPort = dot1sIntfFind(intIfNum);
+    pPort = dot1sIntfFind(intIfNum);
 
-      if (pPort == L7_NULLPTR)
-      {
-        return L7_FAILURE;
-      }
-      /* Initialize with the defaults then replace the configured fields
-       * with their configured values.
-       */
-      rc = dot1sPortDefaultPopulate(pPort, intIfNum);
+    if (pPort == L7_NULLPTR)
+    {
+      return L7_FAILURE;
+    }
+    /* Initialize with the defaults then replace the configured fields
+     * with their configured values.
+     */
+    rc = dot1sPortDefaultPopulate(pPort, intIfNum);
 
     pPortCfg = &dot1sCfg->cfg.dot1sCfgPort[intIfNum];
 
-      pPort->portAdminMode = pPortCfg->portAdminMode;
-      /* notParticipating must be kept in sync with Admin Mode
-       * up until the time of an IhAcquire or IhRelease
-       */
-      if (pPort->portAdminMode == L7_ENABLE)
-      {
-        pPort->notParticipating = L7_FALSE;
-      }
-      else
-      {
-        pPort->notParticipating = L7_TRUE;
-      }
+    pPort->portAdminMode = pPortCfg->portAdminMode;
+    /* notParticipating must be kept in sync with Admin Mode
+     * up until the time of an IhAcquire or IhRelease
+     */
+    if (pPort->portAdminMode == L7_ENABLE)
+    {
+      pPort->notParticipating = L7_FALSE;
+    }
+    else
+    {
+      pPort->notParticipating = L7_TRUE;
+    }
 
     pPort->portNum = intIfNum;
-      pPort->adminEdge = pPortCfg->adminEdge;
-      pPort->autoEdge = pPortCfg->autoEdge;
-      pPort->restrictedRole = pPortCfg->restrictedRole;
-      pPort->loopGuard = pPortCfg->loopGuard;
-      pPort->restrictedTcn = pPortCfg->restrictedTcn;
-
-      for (instIndex = DOT1S_CIST_INDEX; instIndex <= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
-      {
-        pPort->portInstInfo[instIndex].ExternalPortPathCost = pPortCfg->portInstInfo[instIndex].ExternalPortPathCost;
-        pPort->portInstInfo[instIndex].InternalPortPathCost = pPortCfg->portInstInfo[instIndex].InternalPortPathCost;
-        pPort->portInstInfo[instIndex].autoInternalPortPathCost = pPortCfg->portInstInfo[instIndex].autoInternalPortPathCost;
+    pPort->adminEdge = pPortCfg->adminEdge;
+    pPort->autoEdge = pPortCfg->autoEdge;
+    pPort->restrictedRole = pPortCfg->restrictedRole;
+    pPort->loopGuard = pPortCfg->loopGuard;
+    pPort->restrictedTcn = pPortCfg->restrictedTcn;
+
+    for (instIndex = DOT1S_CIST_INDEX; instIndex <= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
+    {
+      pPort->portInstInfo[instIndex].ExternalPortPathCost = pPortCfg->portInstInfo[instIndex].ExternalPortPathCost;
+      pPort->portInstInfo[instIndex].InternalPortPathCost = pPortCfg->portInstInfo[instIndex].InternalPortPathCost;
+      pPort->portInstInfo[instIndex].autoInternalPortPathCost = pPortCfg->portInstInfo[instIndex].autoInternalPortPathCost;
       pPort->portInstInfo[instIndex].autoExternalPortPathCost = pPortCfg->portInstInfo[instIndex].autoExternalPortPathCost;
 
       pPort->portInstInfo[instIndex].portId = ((pPortCfg->portInstInfo[instIndex].portPriority << 8) | intIfNum);
-        /* msti */
-        if (instIndex != DOT1S_CIST_INDEX)
-        {
-        priInstId = dot1sCfg->cfg.dot1sInstance.msti[instIndex].BridgeIdentifier.priInstId;
-
-          pPort->portInstInfo[instIndex].inst.msti.mstiDesignatedPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.msti.mstiDesignatedPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.msti.mstiMsgPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.msti.mstiMsgPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.msti.mstiPortPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.msti.mstiPortPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-        }
-        else /* cist */
-        {
-        priInstId = dot1sCfg->cfg.dot1sInstance.cist.BridgeIdentifier.priInstId;
+      /* msti */
+      if (instIndex != DOT1S_CIST_INDEX)
+      {
+      priInstId = dot1sCfg->cfg.dot1sInstance.msti[instIndex].BridgeIdentifier.priInstId;
 
-          pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.rootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.rootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.rootId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
-          pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.regRootId.priInstId = (L7_ushort16)priInstId;
-        }
-      }/*endfor instIndex*/
-
-      /* Handle the current link state for this port in case it is
-       * already up.
-       */
-      if (nimGetIntfLinkState(intIfNum, &portLinkState) == L7_SUCCESS)
+        pPort->portInstInfo[instIndex].inst.msti.mstiDesignatedPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.msti.mstiDesignatedPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.msti.mstiMsgPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.msti.mstiMsgPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.msti.mstiPortPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.msti.mstiPortPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+      }
+      else /* cist */
       {
+        priInstId = dot1sCfg->cfg.dot1sInstance.cist.BridgeIdentifier.priInstId;
+
+        pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.rootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.rootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.rootId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
+        pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.regRootId.priInstId = (L7_ushort16)priInstId;
+      }
+    }/*endfor instIndex*/
+
+    /* Handle the current link state for this port in case it is
+     * already up.
+     */
+    if (nimGetIntfLinkState(intIfNum, &portLinkState) == L7_SUCCESS)
+    {
       rc = dot1sIhNotifySystem(intIfNum, portLinkState);
     }
   }
   /* Set mode to the saved configured value and generate all necessary events */
   if (cfgMode == L7_ENABLE)
Index: src/application/switching/spanning_tree/dot1s/encryption/md5.c
===================================================================
--- src/application/switching/spanning_tree/dot1s/encryption/md5.c	(revision 6677)
+++ src/application/switching/spanning_tree/dot1s/encryption/md5.c	(working copy)
@@ -141,12 +141,12 @@
   /* Compute number of bytes mod 64 */
   index = (L7_uint32)((context->count[0] >> 3) & 0x3F);
 
   /* Update number of bits */
   if ((context->count[0] += ((L7_uint32)inputLen << 3)) < ((L7_uint32)inputLen << 3))
-	  context->count[1]++;
-	  context->count[1] += ((L7_uint32)inputLen >> 29);
+    context->count[1]++;
+  context->count[1] += ((L7_uint32)inputLen >> 29);
 
   partLen = 64 - index;
 
   /* Transform as many times as possible.
 */
Index: src/application/switching/vlan/dot1q/dot1q_control.c
===================================================================
--- src/application/switching/vlan/dot1q/dot1q_control.c	(revision 6677)
+++ src/application/switching/vlan/dot1q/dot1q_control.c	(working copy)
@@ -1094,11 +1094,11 @@
                }   
             } 
           } 
           /* Somebody has taken the ownership and we dont need to do actual deletion */         
           L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1Q_COMPONENT_ID,
-                 "Can not delete the VLAN, Some unknown component has taken the ownership!",vlanId); 
+                 "Can not delete the VLAN=%u, Some unknown component has taken the ownership!",vlanId); 
           dot1qCurrentVlanCountUpdate(L7_TRUE);
           osapiSemaGive(dot1qSem);
           return L7_SUCCESS;  
        }
     }
Index: src/application/switching/voice_vlan/core/voice_vlan_db.c
===================================================================
--- src/application/switching/voice_vlan/core/voice_vlan_db.c	(revision 6677)
+++ src/application/switching/voice_vlan/core/voice_vlan_db.c	(working copy)
@@ -191,11 +191,11 @@
         L7_uchar8 ifName[L7_NIM_IFNAME_SIZE + 1];
         nimGetIntfName(intIfNum, L7_SYSNAME, ifName);
 
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_VOICE_VLAN_COMPONENT_ID,
                 "%s:%d Error Adding the node to the Voice Vlan Device Info Tree for mac address: %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ,phyintf %d, %s, voice vlan : %d \n",
-                __FUNCTION__,__FILE__,
+                __FUNCTION__,__LINE__,
                 mac_addr[0],
                 mac_addr[1],
                 mac_addr[2],
                 mac_addr[3],
                 mac_addr[4],
Index: src/dtl/base/dtl_pdu_landd.c
===================================================================
--- src/dtl/base/dtl_pdu_landd.c	(revision 6677)
+++ src/dtl/base/dtl_pdu_landd.c	(working copy)
@@ -60,11 +60,15 @@
 {
   pdu_receive_debug = enable;
 }
 
 static L7_uint8  ptin_debug_dtl = 0;
-inline void ptin_debug_dtl_set(L7_uint8 enable){ptin_debug_dtl = enable;};
+
+static inline void ptin_debug_dtl_set(L7_uint8 enable)
+{
+  ptin_debug_dtl = enable;
+};
 #endif
 
 
 /*
 **********************************************************************
Index: src/dtl/switching/dtl_l2_fdb.c
===================================================================
--- src/dtl/switching/dtl_l2_fdb.c	(revision 6677)
+++ src/dtl/switching/dtl_l2_fdb.c	(working copy)
@@ -592,11 +592,11 @@
   DAPI_ADDR_MGMT_CMD_t dapiCmd;
   DAPI_ADDR_FLAG_t dapiFlag;
   L7_RC_t dr;
   nimUSP_t usp;
 
-  PT_LOG_TRACE(LOG_CTX_L2, "vlan=%u, MAC=%02x:%02x:%02x:%02x:%02x:%02x",
+  PT_LOG_TRACE(LOG_CTX_L2, "vlan=%lu, MAC=%02x:%02x:%02x:%02x:%02x:%02x",
             filterDbID,
             macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5]);
 
   if (nimGetUnitSlotPort(intfNum, &usp) != L7_SUCCESS)
   {
Index: src/l7public/common/ptin/logger.h
===================================================================
--- src/l7public/common/ptin/logger.h	(revision 6677)
+++ src/l7public/common/ptin/logger.h	(working copy)
@@ -186,11 +186,11 @@
  * @param func Function name (can be NULL)
  * @param line Line# (if zero, is ignored)
  * @param fmt  Format string+ arguments (like printf)
  */
 extern void logger_print(log_context_t ctx, log_severity_t sev, char const *file,
-               char const *func, int line, char const *fmt, ...);
+               char const *func, int line, char const *fmt, ...) __attribute__((format(printf, 6, 7)));
 
 
 #define PT_LOG_TRACE( ctx , fmt , args... ) \
     logger_print( ctx, LOG_SEV_TRACE, NULL, __FUNCTION__, __LINE__, fmt, ##args )
     
Index: src/l7public/common/ptin/ptin_globaldefs.h
===================================================================
--- src/l7public/common/ptin/ptin_globaldefs.h	(revision 6677)
+++ src/l7public/common/ptin/ptin_globaldefs.h	(working copy)
@@ -39,11 +39,11 @@
 #define PTIN_SYSTEM_MAX_NGPON2_GROUPS               PTIN_SYSTEM_N_PORTS
 #define PTIN_SYSTEM_MAX_NGPON2_GROUPS_ELEMENTS      32
 #define PTIN_SYSTEM_MAX_SERVICES_PER_ONU            8
 #define PTIN_SYSTEM_ETH_MTU_SIZE                    9600
 #define PTIN_SYSTEM_PON_MTU_SIZE                    2048
-#define PTIN_SYSTEM_EXT_EVCS_MGMT                   (1UL << 22)     /* 17 bits will be used by management */
+#define PTIN_SYSTEM_EXT_EVCS_MGMT                   (1U << 22)     /* 17 bits will be used by management */
 #define PTIN_SYSTEM_N_EXTENDED_EVCS                 (PTIN_SYSTEM_EXT_EVCS_MGMT + 64)    /* 64 Extra EVCs */
 
 #define PTIN_IS_PORT_PON(p)           ((((unsigned long long)1 << p) & PTIN_SYSTEM_PON_PORTS_MASK) != 0)
 #define PTIN_IS_PORT_ETH(p)           ((((unsigned long long)1 << p) & PTIN_SYSTEM_ETH_PORTS_MASK) != 0)
 #define PTIN_IS_PORT_10G(p)           ((((unsigned long long)1 << p) & PTIN_SYSTEM_10G_PORTS_MASK) != 0)
Index: src/l7public/common/ptin/ptin_utils.h
===================================================================
--- src/l7public/common/ptin/ptin_utils.h	(revision 6677)
+++ src/l7public/common/ptin/ptin_utils.h	(working copy)
@@ -170,18 +170,18 @@
 
 /****************************************************************************** 
  * BITMAPS MANIPULATION
  ******************************************************************************/
 
-extern inline int _bmp_set(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
-extern inline int _bmp_set_all(bmp_cell_t bmp[], unsigned int sizeof_bmp);
+extern int _bmp_set(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
+extern int _bmp_set_all(bmp_cell_t bmp[], unsigned int sizeof_bmp);
 
-extern inline int _bmp_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
-extern inline int _bmp_clear_all(bmp_cell_t bmp[], unsigned int sizeof_bmp);
+extern int _bmp_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
+extern int _bmp_clear_all(bmp_cell_t bmp[], unsigned int sizeof_bmp);
                                     
-extern inline int _bmp_is_set(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
-extern inline int _bmp_is_all_set(bmp_cell_t bmp[], unsigned int sizeof_bmp);
+extern int _bmp_is_set(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
+extern int _bmp_is_all_set(bmp_cell_t bmp[], unsigned int sizeof_bmp);
 
-extern inline int _bmp_is_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
-extern inline int _bmp_is_all_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp);
+extern int _bmp_is_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp, unsigned int bit);
+extern int _bmp_is_all_clear(bmp_cell_t bmp[], unsigned int sizeof_bmp);
 
 #endif
Index: src/mgmt/broadcom/cli/base/common/cli_config_time.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/cli_config_time.c	(revision 6677)
+++ src/mgmt/broadcom/cli/base/common/cli_config_time.c	(working copy)
@@ -441,14 +441,15 @@
   /* get switch ID based on presence/absence of STACKING package */
   if (cliIsStackingSupported () == L7_TRUE)
     unit = EWSUNIT (ewsContext);
   else
     unit = cliGetUnitId ();
-    if (cliConvertTo32BitUnsignedInteger (argv[index], &stWeek) != L7_SUCCESS)
+
+  if (cliConvertTo32BitUnsignedInteger (argv[index], &stWeek) != L7_SUCCESS)
   {
 
-  if (usmDbWeekNumberGet ((L7_char8 *)argv[index], &stWeek) != L7_SUCCESS)
+    if (usmDbWeekNumberGet ((L7_char8 *)argv[index], &stWeek) != L7_SUCCESS)
     {
       ewsTelnetWrite (ewsContext, pStrInfo_base_clierror_summertime_startweek);
       cliSyntaxBottom (ewsContext);
       return cliPrompt (ewsContext);
     }
Index: src/mgmt/broadcom/cli/base/common/cli_show_running_config.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/cli_show_running_config.c	(revision 6677)
+++ src/mgmt/broadcom/cli/base/common/cli_show_running_config.c	(working copy)
@@ -5367,20 +5367,20 @@
 
   if (osapiSemaTake(cliRunCfgSema, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_CLI_WEB_COMPONENT_ID,
            "Failed to take cliRunCfgSemaphore %x\n",
-            cliRunCfgSema);
+            (int)cliRunCfgSema);
   }
 
   prompt = cliShowRunningConfigGenerate(ewsContext, argv, numArg, chkFile);
 
   if (osapiSemaGive(cliRunCfgSema) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_CLI_WEB_COMPONENT_ID,
             "Failed to give cliRunCfgSema %x\n",
-            cliRunCfgSema);
+            (int)cliRunCfgSema);
   }
 
   return prompt;
 }
 
Index: src/mgmt/broadcom/cli/base/common/cli_txtcfg.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/cli_txtcfg.c	(revision 6677)
+++ src/mgmt/broadcom/cli/base/common/cli_txtcfg.c	(working copy)
@@ -693,11 +693,11 @@
 
   if (osapiSemaTake(cliRunCfgSema, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_CLI_WEB_COMPONENT_ID,
            "Failed to take cliRunCfgSemaphore %x\n",
-            cliRunCfgSema);
+            (int)cliRunCfgSema);
   }
 
   if (strcmp(filename,sysapiTxtRunCfgFileGet()) == 0 )
   {
     context = &cliTxtRunCfg->ewsContext;
@@ -747,11 +747,11 @@
 
   if (osapiSemaGive(cliRunCfgSema) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_CLI_WEB_COMPONENT_ID,
             "Failed to give cliRunCfgSema %x\n",
-            cliRunCfgSema);
+            (int)cliRunCfgSema);
   }
 
 
 
   return L7_SUCCESS;
Index: src/mgmt/broadcom/cli/base/common/cliutil.c
===================================================================
--- src/mgmt/broadcom/cli/base/common/cliutil.c	(revision 6677)
+++ src/mgmt/broadcom/cli/base/common/cliutil.c	(working copy)
@@ -780,11 +780,11 @@
         rc = L7_FAILURE;
         challengeFlags= L7_TRUE;
       }
       if (L7_SUCCESS == rc)
         {
-            memset(challengePhrase, 0, sizeof(challengePhrase));
+            memset(challengePhrase, 0, sizeof(*challengePhrase));
             /* User is authenticated */
             usmDbLoginSessionUserSet(U_IDX, cliLoginSessionIndexGet(), userNameSSH);
 
             /* Store access level */
             cliCommon[cliUtil.handleNum].userAccess = accessLevel; /* for security */
Index: src/mgmt/broadcom/cli/qos/acl/cli_config_acl.c
===================================================================
--- src/mgmt/broadcom/cli/qos/acl/cli_config_acl.c	(revision 6677)
+++ src/mgmt/broadcom/cli/qos/acl/cli_config_acl.c	(working copy)
@@ -1294,11 +1294,11 @@
     cliSyntaxBottom(ewsContext);
     return NULL;
   }
 
   osapiStrncpySafe( strMacAddr, argv[index+*relIndex], sizeof(strMacAddr));
-  memset (macAddr, 0,sizeof(macAddr));
+  memset (macAddr, 0, (size_t)L7_MAC_ADDR_LEN);
   *relIndex  = *relIndex+1;
 
   if (cliConvertMac(strMacAddr, macAddr) != L7_TRUE)
   {
     sprintfAddBlanks (1, 0, 0, 0, pStrErr_common_IncorrectInput, buf,pStrErr_qos_IncorrectMacAddrType);
Index: src/mgmt/broadcom/cli/qos/diffserv/cliutil_diffserv.c
===================================================================
--- src/mgmt/broadcom/cli/qos/diffserv/cliutil_diffserv.c	(revision 6677)
+++ src/mgmt/broadcom/cli/qos/diffserv/cliutil_diffserv.c	(working copy)
@@ -1662,11 +1662,11 @@
   return;
 }
 
 void cliConstructAndPrintPoliceSimpleSyntax(EwsContext ewsContext, L7_char8 * buf, L7_int32 bufLenMax)
 {
-  memset (buf, 0,sizeof(buf));
+  memset (buf, 0, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, pStrErr_common_IncorrectInput, buf, pStrErr_qos_PoliceSimple_1, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, L7_NULLPTR, buf, pStrErr_qos_PoliceViolate, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncat(buf, pStrErr_qos_Close, bufLenMax - strlen(buf) - 1);
@@ -1675,11 +1675,11 @@
   return;
 }
 
 void cliConstructAndPrintPoliceSingleRateSyntax(EwsContext ewsContext, L7_char8 * buf, L7_int32 bufLenMax)
 {
-  memset (buf, 0,sizeof(buf));
+  memset (buf, 0, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, pStrErr_common_IncorrectInput, buf, pStrErr_qos_PoliceSingleRate_1, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, L7_NULLPTR, buf, pStrErr_qos_PoliceExceed, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, L7_NULLPTR, buf, pStrErr_qos_PoliceViolate, bufLenMax - strlen(buf) - 1);
@@ -1690,11 +1690,11 @@
   return;
 }
 
 void cliConstructAndPrintPoliceTwoRateSyntax(EwsContext ewsContext, L7_char8 * buf, L7_int32 bufLenMax)
 {
-  memset (buf, 0,sizeof(buf));
+  memset (buf, 0, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, pStrErr_common_IncorrectInput, buf, pStrErr_qos_PoliceTwoRate_1, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, L7_NULLPTR, buf, pStrErr_qos_PoliceExceed, bufLenMax - strlen(buf) - 1);
   cliConstructPoliceParmsSyntax(buf, bufLenMax);
   osapiStrncatAddBlanks (1, 0, 0, 0, L7_NULLPTR, buf, pStrErr_qos_PoliceViolate, bufLenMax - strlen(buf) - 1);
Index: src/mgmt/broadcom/cli/switching/spanning_tree/cliutil_dot1s.c
===================================================================
--- src/mgmt/broadcom/cli/switching/spanning_tree/cliutil_dot1s.c	(revision 6677)
+++ src/mgmt/broadcom/cli/switching/spanning_tree/cliutil_dot1s.c	(working copy)
@@ -548,11 +548,11 @@
   }
 
   if ( usmDbDot1sMstiPortForwardingStateGet(unit, instance,
                                             iface, &val) == L7_SUCCESS )
   {
-    memset (stat, 0,sizeof(stat));
+    memset (stat, 0, size);
     switch (val)
     {
     case L7_DOT1S_DISCARDING:
       if ((usmDbDot1sMstiPortLoopInconsistentStateGet(unit, instance, iface, &val) == L7_SUCCESS) 
             && (val == L7_TRUE))
Index: src/mgmt/broadcom/emweb/linux/ewmain.c
===================================================================
--- src/mgmt/broadcom/emweb/linux/ewmain.c	(revision 6677)
+++ src/mgmt/broadcom/emweb/linux/ewmain.c	(working copy)
@@ -1828,14 +1828,14 @@
 
 }
 
 /*********************************************************************
 *********************************************************************/
-L7_RC_t L7_ewsPhaseOneInit(arg0 /* max connections - use default */
-                           ,arg1 /* max buffers - use default */
-                           ,arg2 /* buffer data size - use default */
-                           ,arg3 /* port number - use default */
+L7_RC_t L7_ewsPhaseOneInit(int arg0 /* max connections - use default */
+                           ,int arg1 /* max buffers - use default */
+                           ,int arg2 /* buffer data size - use default */
+                           ,int arg3 /* port number - use default */
                           )
 {
 #if defined(L7_WEB_PACKAGE) || defined(L7_XWEB_PACKAGE)
   EwaStatus             app_status;
 #endif
Index: src/mgmt/snmp/packages/base/k_mib_fastpath_timerange.c
===================================================================
--- src/mgmt/snmp/packages/base/k_mib_fastpath_timerange.c	(revision 6677)
+++ src/mgmt/snmp/packages/base/k_mib_fastpath_timerange.c	(working copy)
@@ -276,14 +276,14 @@
   {
     /* ignore if deleting a non-existant entry */
     if (data->timeRangeStatus == D_timeRangeStatus_destroy)
       return NO_ERROR;
 
-      /* undoin g an add, so delete */
-      data->timeRangeStatus = D_timeRangeStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoin g an add, so delete */
+    data->timeRangeStatus = D_timeRangeStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if ((undodata->timeRangeStatus == D_timeRangeStatus_notReady)
@@ -680,14 +680,14 @@
   {
     /* ignore if deleting a non-existant entry */
     if (data->timeRangeAbsoluteStatus == D_timeRangeAbsoluteStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->timeRangeAbsoluteStatus = D_timeRangeAbsoluteStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->timeRangeAbsoluteStatus = D_timeRangeAbsoluteStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if ((undodata->timeRangeAbsoluteStatus == D_timeRangeAbsoluteStatus_notReady)
@@ -1086,14 +1086,14 @@
   {
     /* ignore if deleting a non-existant entry */
     if (data->timeRangePeriodicStatus == D_timeRangePeriodicStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->timeRangePeriodicStatus = D_timeRangePeriodicStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->timeRangePeriodicStatus = D_timeRangePeriodicStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if ((undodata->timeRangePeriodicStatus == D_timeRangePeriodicStatus_notReady)
Index: src/mgmt/snmp/packages/ip_mcast/k_mib_mcast_api.h
===================================================================
--- src/mgmt/snmp/packages/ip_mcast/k_mib_mcast_api.h	(revision 6677)
+++ src/mgmt/snmp/packages/ip_mcast/k_mib_mcast_api.h	(working copy)
@@ -295,22 +295,22 @@
     return L7_FAILURE;
   inetAddressReset(&inetSrcMask);
   if(L7_SUCCESS != inetAddressSet(L7_AF_INET, &ipMask, &inetSrcMask))
     return L7_FAILURE;
 
-    switch (val)
-    {
-        case D_ipMRouteBoundaryStatus_active:
-        case D_ipMRouteBoundaryStatus_createAndGo:
-			 rc = usmDbMcastMrouteBoundaryAdd(UnitIndex, intIfNum, &inetMRtSrc, &inetSrcMask);
-             break;
+  switch (val)
+  {
+      case D_ipMRouteBoundaryStatus_active:
+      case D_ipMRouteBoundaryStatus_createAndGo:
+           rc = usmDbMcastMrouteBoundaryAdd(UnitIndex, intIfNum, &inetMRtSrc, &inetSrcMask);
+           break;
 
-        case D_ipMRouteBoundaryStatus_destroy:
-             rc = usmDbMcastMrouteBoundaryDelete(UnitIndex, intIfNum, &inetMRtSrc, &inetSrcMask);
-	        break;
-        default:
-             rc = L7_FAILURE;
-    }
+      case D_ipMRouteBoundaryStatus_destroy:
+           rc = usmDbMcastMrouteBoundaryDelete(UnitIndex, intIfNum, &inetMRtSrc, &inetSrcMask);
+          break;
+      default:
+           rc = L7_FAILURE;
+  }
 
   return rc;
 }
 #endif
Index: src/mgmt/snmp/packages/qos/k_mib_qos_acl.c
===================================================================
--- src/mgmt/snmp/packages/qos/k_mib_qos_acl.c	(revision 6677)
+++ src/mgmt/snmp/packages/qos/k_mib_qos_acl.c	(working copy)
@@ -228,14 +228,14 @@
   {
     /* ignore if deleting a non-existant entry */
     if (data->aclStatus == D_aclStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->aclStatus = D_aclStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->aclStatus = D_aclStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if((undodata->aclStatus == D_aclStatus_notReady)
@@ -469,14 +469,14 @@
   {
     /* ignore if deleting a non-existant entry */
     if (data->aclIfStatus == D_aclIfStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->aclIfStatus = D_aclIfStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->aclIfStatus = D_aclIfStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if((undodata->aclIfStatus == D_aclIfStatus_notReady)
@@ -1131,14 +1131,14 @@
   {
     /* ignore if deleting a non-existant entry */
     if (data->aclRuleStatus == D_aclRuleStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->aclRuleStatus = D_aclRuleStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->aclRuleStatus = D_aclRuleStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if((undodata->aclRuleStatus == D_aclRuleStatus_notReady)
@@ -1413,14 +1413,14 @@
   {
     /* ignore if deleting a non-existant entry */
     if (data->aclMacStatus == D_aclMacStatus_destroy)
       return NO_ERROR;
 
-      /* undoin g an add, so delete */
-      data->aclMacStatus = D_aclMacStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoin g an add, so delete */
+    data->aclMacStatus = D_aclMacStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if((undodata->aclMacStatus == D_aclMacStatus_notReady)
@@ -2067,14 +2067,14 @@
   {
     /* ignore if deleting a non-existant entry */
     if (data->aclMacRuleStatus == D_aclMacRuleStatus_destroy)
       return NO_ERROR;
 
-      /* undoing an add, so delete */
-      data->aclMacRuleStatus = D_aclMacRuleStatus_destroy;
-      setdata = data;
-      function = SR_DELETE;
+    /* undoing an add, so delete */
+    data->aclMacRuleStatus = D_aclMacRuleStatus_destroy;
+    setdata = data;
+    function = SR_DELETE;
   }
   else
   {
       /* undoing a delete or modify, replace the original data */
       if((undodata->aclMacRuleStatus == D_aclMacRuleStatus_notReady)
Index: src/mgmt/snmp/packages/qos/k_mib_qos_diffserv_private_api.h
===================================================================
--- src/mgmt/snmp/packages/qos/k_mib_qos_diffserv_private_api.h	(revision 6677)
+++ src/mgmt/snmp/packages/qos/k_mib_qos_diffserv_private_api.h	(working copy)
@@ -1480,11 +1480,11 @@
                                                    L7_uint32 *prefixLen)
 {
    L7_in6_addr_t prefix;
    
    memset(&prefix, 0x00, sizeof(prefix));
-   memset(snmp_buffer, 0x00, sizeof(snmp_buffer));
+   memset(snmp_buffer, 0x00, sizeof(*snmp_buffer));
    if((usmDbDiffServClassRuleMatchDstIpv6AddrGet(UnitIndex, classIndex, classRuleIndex, &prefix) == L7_SUCCESS) &&
       (usmDbDiffServClassRuleMatchDstIpv6PrefLenGet(UnitIndex, classIndex, classRuleIndex, prefixLen) == L7_SUCCESS))
    {
       memcpy(snmp_buffer, prefix.in6.addr8, sizeof(prefix.in6.addr8)); 
       *prefix_len = sizeof(prefix.in6.addr8);
@@ -1501,11 +1501,11 @@
                                                    L7_uint32 *prefixLen)
 {
    L7_in6_addr_t prefix6;
 
    memset(&prefix6, 0x00, sizeof(prefix6));
-   memset(snmp_buffer, 0x00, sizeof(snmp_buffer));
+   memset(snmp_buffer, 0x00, sizeof(*snmp_buffer));
    if((usmDbDiffServClassRuleMatchSrcIpv6AddrGet(UnitIndex, classIndex, classRuleIndex, &prefix6) == L7_SUCCESS) &&
       (usmDbDiffServClassRuleMatchSrcIpv6PrefLenGet(UnitIndex, classIndex, classRuleIndex, prefixLen) == L7_SUCCESS))
    {
       memcpy(snmp_buffer, prefix6.in6.addr8, sizeof(prefix6.in6.addr8)); 
       *prefix_len = sizeof(prefix6.in6.addr8);
Index: src/mgmt/snmp/packages/routing/vrrp/k_mib_vrrp.c
===================================================================
--- src/mgmt/snmp/packages/routing/vrrp/k_mib_vrrp.c	(revision 6677)
+++ src/mgmt/snmp/packages/routing/vrrp/k_mib_vrrp.c	(working copy)
@@ -1458,8 +1458,8 @@
                                 data->agentRouterVrrpTrackRtStatus) != L7_SUCCESS))
     return(COMMIT_FAILED_ERROR);
 
 
 
-    return NO_ERROR;
+  return NO_ERROR;
 }
 
Index: src/mgmt/snmp/packages/switching/common/k_mib_fastpathswitching_api.h
===================================================================
--- src/mgmt/snmp/packages/switching/common/k_mib_fastpathswitching_api.h	(revision 6677)
+++ src/mgmt/snmp/packages/switching/common/k_mib_fastpathswitching_api.h	(working copy)
@@ -13423,25 +13423,25 @@
      if (usmdbVoiceVlanPortDeviceInfoFirstGet(UnitIndex,intIfNum,deviceMacAddr) == L7_SUCCESS )
      {
        if (memcmp(deviceMacAddr,macAddress,sizeof(deviceMacAddr))== 0)
        {
          if(voiceVlanDeviceDebugFlag== L7_TRUE)
-          printf("\n %s: Returning success",__FUNCTION__);
-          return L7_SUCCESS;
+           printf("\n %s: Returning success",__FUNCTION__);
+         return L7_SUCCESS;
        }
      }
      else
      {
        rc1=usmdbVoiceVlanPortDeviceInfoNextGet(UnitIndex,intIfNum,deviceMacAddr);
         while(rc1==L7_SUCCESS)
         {
           if (memcmp(deviceMacAddr,macAddress,sizeof(deviceMacAddr))== 0)
-            {
-              if(voiceVlanDeviceDebugFlag== L7_TRUE)
-                printf("\n %s: Returning success",__FUNCTION__);
-              return L7_SUCCESS;
-            }
+          {
+            if(voiceVlanDeviceDebugFlag== L7_TRUE)
+              printf("\n %s: Returning success",__FUNCTION__);
+            return L7_SUCCESS;
+          }
           rc1 = usmdbVoiceVlanPortDeviceInfoNextGet(UnitIndex,intIfNum,deviceMacAddr);
         }
      }
   }
 
Index: src/mgmt/user_mgr/user_mgr_radius.c
===================================================================
--- src/mgmt/user_mgr/user_mgr_radius.c	(revision 6677)
+++ src/mgmt/user_mgr/user_mgr_radius.c	(working copy)
@@ -191,11 +191,11 @@
   L7_radiusAttrHeader_t *radiusAttr;
   L7_BOOL done = L7_FALSE;
 
   /* Initialize pChallengeFlag to false in case the challenge phrase is not found. */
   *pChallengeFlag = L7_FALSE;
-  memset( pChallengePhrase, 0, sizeof(pChallengePhrase));
+  memset( pChallengePhrase, 0, sizeof(*pChallengePhrase));
 
   /* If no attributes found, exit. */
   if (attributesLen <= sizeof(L7_radiusAttrHeader_t))
     return;
 
Index: src/system_support/base/infrastructure/box_services/boxs_api.c
===================================================================
--- src/system_support/base/infrastructure/box_services/boxs_api.c	(revision 6677)
+++ src/system_support/base/infrastructure/box_services/boxs_api.c	(working copy)
@@ -389,11 +389,11 @@
 L7_RC_t boxsApiTempStatusTrapEnableGet(L7_BOOL *enable)
 {
   if (boxsCfg == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_BOX_SERVICES_COMPONENT_ID,
-            "invalid value %d\n",enable);
+            "invalid value %d\n", (int)enable);
     return L7_FAILURE;
   }
   /* we don't need any sync for read operation */
   *enable = boxsCfg->cfg.globalCfgData.trapTempStatusEnabled;
 
@@ -415,11 +415,11 @@
 L7_RC_t boxsApiFanStatusTrapEnableGet(L7_BOOL *enable)
 {
   if (boxsCfg == L7_NULLPTR)
   {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_BOX_SERVICES_COMPONENT_ID,
-              "invalid value %d\n",enable);
+              "invalid value %d\n", (int)enable);
     return L7_FAILURE;
   }
   /* we don't need any sync for read operation */
   *enable = boxsCfg->cfg.globalCfgData.trapFanStatusEnabled;
 
@@ -441,11 +441,11 @@
 L7_RC_t boxsApiPowSupplyStatusTrapEnableGet(L7_BOOL *enable)
 {
   if (boxsCfg == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_BOX_SERVICES_COMPONENT_ID,
-            "box services configuration: null pointer\n",enable);
+            "box services configuration: null pointer\n");
     return L7_FAILURE;
   }
   /* we don't need any sync for read operation */
   *enable = boxsCfg->cfg.globalCfgData.trapPowSupplyStatusEnabled;
 
@@ -465,11 +465,11 @@
 L7_RC_t boxsApiSfpStatusTrapEnableGet(L7_BOOL *enable)
 {
   if (boxsCfg == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_BOX_SERVICES_COMPONENT_ID,
-            "box services configuration: null pointer\n",enable);
+            "box services configuration: null pointer\n");
     return L7_FAILURE;
   }
   /* we don't need any sync for read operation */
   *enable = boxsCfg->cfg.globalCfgData.trapSfpStatusEnabled;
 
@@ -489,11 +489,11 @@
 L7_RC_t boxsApiXfpStatusTrapEnableGet(L7_BOOL *enable)
 {
   if (boxsCfg == L7_NULLPTR)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_BOX_SERVICES_COMPONENT_ID,
-            "box services configuration: null pointer\n",enable);
+            "box services configuration: null pointer\n");
     return L7_FAILURE;
   }
   /* we don't need any sync for read operation */
   *enable = boxsCfg->cfg.globalCfgData.trapXfpStatusEnabled;
 
Index: src/system_support/base/infrastructure/nim/nim_migrate.c
===================================================================
--- src/system_support/base/infrastructure/nim/nim_migrate.c	(revision 6677)
+++ src/system_support/base/infrastructure/nim/nim_migrate.c	(working copy)
@@ -462,15 +462,15 @@
   i = count + 1;
   count = min (L7_MAX_INTERFACE_COUNT_REL_4_3, L7_MAX_INTERFACE_COUNT_REL_4_4);
   for ( ; i <= count; i++)
   {
     MIGRATE_COPY_STRUCT (pCfgV5->cfgPort[i+diff], pCfgV4->cfgPort[i]);
-    if (pCfgV5->cfgPort[i+diff].configIdMaskOffset != 0)
-    {
-      /* Adjust configIdMaskOffset as that contains intIfNum */
-      pCfgV5->cfgPort[i+diff].configIdMaskOffset = pCfgV5->cfgPort[i+diff].configIdMaskOffset + diff;
-    }
+//    if (pCfgV5->cfgPort[i+diff].configIdMaskOffset != 0)
+//    {
+//      /* Adjust configIdMaskOffset as that contains intIfNum */
+//      pCfgV5->cfgPort[i+diff].configIdMaskOffset = pCfgV5->cfgPort[i+diff].configIdMaskOffset + diff;
+//    }
   }
 
 
 
   /* Signal truncation if more nim entries existed than can be copied to
Index: src/system_support/base/l7util/l7utils/l7utils_convert.c
===================================================================
--- src/system_support/base/l7util/l7utils/l7utils_convert.c	(revision 6677)
+++ src/system_support/base/l7util/l7utils/l7utils_convert.c	(working copy)
@@ -291,15 +291,15 @@
   return L7_SUCCESS;
 }
 
 L7_uint32 l7utilsBytesToInt(L7_char8 *b)
 {
-#ifdef PC_LINUX_HOST
+//#ifdef PC_LINUX_HOST
   return b[0]<<24 | (b[1]&0xff)<<16 | (b[2]&0xff)<<8 | (b[3]&0xff);
-#else
-  return *b<<24 | ((*++b)&0xff)<<16 | ((*++b)&0xff)<<8 | ((*++b)&0xff);
-#endif
+//#else
+//  return *b<<24 | ((*++b)&0xff)<<16 | ((*++b)&0xff)<<8 | ((*++b)&0xff);
+//#endif
 }
 
 void l7utilsIntToBytes(L7_char8 *b, L7_uint32 i)
 {
   *b   = (L7_char8)(i>>24);
Index: src/system_support/base/l7util/radix/l7_radix.c
===================================================================
--- src/system_support/base/l7util/radix/l7_radix.c	(revision 6677)
+++ src/system_support/base/l7util/radix/l7_radix.c	(working copy)
@@ -286,15 +286,15 @@
    * serves as a starting point for getting the next entry
    */
   if(!keyMatch)
     x = 0;
 
-    if (x && netmask) {
-        /* walk duplicates e.g. for 1.1.1.0/24 and 1.1.1.0/28 */
-        while (x && x->rn_mask != netmask)
-            x = x->rn_dupedkey;
-    }
+  if (x && netmask) {
+    /* walk duplicates e.g. for 1.1.1.0/24 and 1.1.1.0/28 */
+    while (x && x->rn_mask != netmask)
+      x = x->rn_dupedkey;
+  }
 
   /* exact match? */
   if(type == L7_RN_EXACT)
           return x;
 
@@ -2159,11 +2159,11 @@
      * Never return the root node itself, it seems to cause a
      * lot of confusion.
      */
     if (t->rn_flags & RNF_ROOT)
         t = t->rn_dupedkey;
-        return t;
+    return t;
 
 on1:
     /* The search tested the bit specified by rn_bmask (rn_bit)
      * so some other  bit may also vary before it!
      * So find first bit that differs!
Index: src/system_support/base/network/dhcp/dhcp_prot.c
===================================================================
--- src/system_support/base/network/dhcp/dhcp_prot.c	(revision 6677)
+++ src/system_support/base/network/dhcp/dhcp_prot.c	(working copy)
@@ -318,11 +318,11 @@
     dhcpNotifyRegisteredUsers(&notifyInfo);
     break;
 
     default:
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DHCP_CLIENT_COMPONENT_ID,
-            "%s: Unsupported DHCP option requested for extraction.");
+            "%s: Unsupported DHCP option requested for extraction.", __FUNCTION__);
   }
 
   /*option was not present in the first place*/
   return L7_FAILURE;
 }
Index: src/system_support/base/network/dns/dns_client_cnfgr.c
===================================================================
--- src/system_support/base/network/dns/dns_client_cnfgr.c	(revision 6677)
+++ src/system_support/base/network/dns/dns_client_cnfgr.c	(working copy)
@@ -547,11 +547,11 @@
 
   /* disable the client */
   dnsClientAdminModeApply(L7_FALSE);
 
   memset(dnsNotifyTbl, 0, L7_LAST_COMPONENT_ID * sizeof(dnsNotifyEntry_t));
-  memset(dnsCfgData, 0, sizeof(dnsCfgData));
+  memset(dnsCfgData, 0, sizeof(*dnsCfgData));
 
   dnsCnfgrState = DNS_CLIENT_PHASE_WMU;
 
   return L7_SUCCESS;
 }
Index: src/system_support/base/network/dns/dns_client_txrx.c
===================================================================
--- src/system_support/base/network/dns/dns_client_txrx.c	(revision 6677)
+++ src/system_support/base/network/dns/dns_client_txrx.c	(working copy)
@@ -157,10 +157,11 @@
   L7_uint32 i = 0;
   L7_sockaddr_union_t addr;
   L7_uint32      opt = 1;
   L7_uint32      broadcastEnable = (L7_INET_IS_ADDR_BROADCAST(&serverAddr))?1:0;
   L7_uchar8      family = 0;
+  L7_uchar8      srvAddr[DNS_INET_ADDR_LEN];
 
   /* Get the family from server address */
   family = L7_INET_GET_FAMILY(serverAddr);
 
   /* find or create the active entry for this server, config entries
@@ -237,12 +238,13 @@
       addr.u.sa4.sin_family = L7_AF_INET;
       addr.u.sa4.sin_port = osapiHtons(DNS_UDP_PORT);
       addr.u.sa4.sin_addr.s_addr = L7_INADDR_ANY;
       if (osapiSocketBind(entry->socket,(L7_sockaddr_t *)&addr.u.sa4,sizeof(addr.u.sa4)) != L7_SUCCESS)
       {
+        inetAddrPrint(serverAddr, srvAddr);
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DNS_CLIENT_COMPONENT_ID,
-                "DNS Client: Bind error on addr 0x%X\n", serverAddr);
+                "DNS Client: Bind error on addr %s\n", srvAddr);
         osapiSocketClose(entry->socket);
         return L7_FAILURE;
       }
     }
 #if defined(L7_IPV6_PACKAGE) || defined(L7_IPV6_MGMT_PACKAGE)
@@ -252,12 +254,13 @@
       memset(&addr.u.sa6, 0, sizeof(addr.u.sa6));
       addr.u.sa6.sin6_family = L7_AF_INET6;
       addr.u.sa6.sin6_port = osapiHtons(DNS_UDP_PORT);
       if (osapiSocketBind(entry->socket,(L7_sockaddr_t *)&addr.u.sa6,sizeof(addr)) != L7_SUCCESS)
       {
+        inetAddrPrint(serverAddr, srvAddr);
         L7_LOGF(L7_LOG_SEVERITY_INFO, L7_DNS_CLIENT_COMPONENT_ID,
-                "DNS Client: Bind error on addr 0x%X\n", serverAddr);
+                "DNS Client: Bind error on addr %s\n", srvAddr);
         osapiSocketClose(entry->socket);
         return L7_FAILURE;
       }
     }
 #endif
@@ -368,15 +371,16 @@
                               (L7_uchar8 *)packet,
                               DNS_UDP_MSG_SIZE_MAX,
                               L7_NULL,
                               ( L7_sockaddr_t *)&rx_addr, &addrlen, &length) != L7_SUCCESS)
       {
+        inetAddrPrint(&dnsOprData->serverTbl[i].serverAddr, srvAddr);
         L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DNS_CLIENT_COMPONENT_ID,
-                "DNS Client: osapiSocketRecvFrom returned error for addr 0x%X."
+                "DNS Client: osapiSocketRecvFrom returned error for addr %s."
                 " Indicates there is a stack error in receiving the DNS response"
                 " packet from the server.",
-                inetAddrPrint(&dnsOprData->serverTbl[i].serverAddr, srvAddr));
+                srvAddr);
         continue;
       }
 
       if (length < sizeof(dnsMessageHeader_t))
       {
Index: src/system_support/base/network/xmodem/getput.c
===================================================================
--- src/system_support/base/network/xmodem/getput.c	(revision 6677)
+++ src/system_support/base/network/xmodem/getput.c	(working copy)
@@ -363,11 +363,12 @@
   newSignal.sa_flags = 0;
   sigaction(SIGTERM, &newSignal, NULL);
 #else
 /* PTin modified: ARM processor */
 /* Ptin TODO: signal */
-#ifndef __arm__
+//#ifndef __arm__
+#if 0
   sigvec(SIGTERM, (struct sigvec *) NULL,  &origSignal);
   newSignal.sv_handler = onintr;
   newSignal.sv_mask = 0;
   newSignal.sv_flags = 0;
   sigvec(SIGTERM, &newSignal, NULL);
@@ -395,11 +396,12 @@
 
 #ifdef _L7_OS_ECOS_
   sigaction(SIGTERM, &origSignal, NULL);
 #else
 /* PTin TODO: signal */
-#ifndef __arm__
+//#ifndef __arm__
+#if 0
   sigvec(SIGTERM, &origSignal, NULL);
 #endif
 #endif
   return;
 }
Index: src/system_support/base/system/base/hpc_util.c
===================================================================
--- src/system_support/base/system/base/hpc_util.c	(revision 6677)
+++ src/system_support/base/system/base/hpc_util.c	(working copy)
@@ -1382,11 +1382,11 @@
 
   /* Send off the packet to all CPUs */
   hpcBroadcastMessageSend(test_registrarID, sizeof(payload), payload);
 }
 
-void hpcDebugMsgSend(unit)
+void hpcDebugMsgSend(int unit)
 {
   L7_uchar8 payload[] = "hpcDebugMsgSend test msg";
 
   /* Send off the packet to selected CPU */
   hpcMessageSend(test_registrarID, unit, sizeof(payload), payload);
Index: src/system_support/base/system/base/sysapi.c
===================================================================
--- src/system_support/base/system/base/sysapi.c	(revision 6677)
+++ src/system_support/base/system/base/sysapi.c	(working copy)
@@ -2492,11 +2492,11 @@
   {
     dataArea = osapiMalloc (component_id, compressedFileSize);
     if (dataArea == L7_NULL)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_SIM_COMPONENT_ID,
-              "Failed to allocate %ld for config file %s\n", compressedFileSize, filename);
+              "Failed to allocate %d for config file %s\n", compressedFileSize, filename);
       return L7_ERROR;
     }
   }
 
   /*
Index: src/system_support/base/system/base/sysapi_cputil.c
===================================================================
--- src/system_support/base/system/base/sysapi_cputil.c	(revision 6677)
+++ src/system_support/base/system/base/sysapi_cputil.c	(working copy)
@@ -71,11 +71,11 @@
 void sysapiCpuUtilLockTake(void)
 {
   if (osapiSemaTake(sysapiCpuUtilTblSema, L7_WAIT_FOREVER) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_OSAPI_COMPONENT_ID,
-            "Failed to take cpuUtilSema %x\n", sysapiCpuUtilTblSema);
+            "Failed to take cpuUtilSema %x\n", (int)sysapiCpuUtilTblSema);
   }
 }
 
 
 /*********************************************************************
@@ -93,11 +93,11 @@
 void sysapiCpuUtilLockGive(void)
 {
   if (osapiSemaGive(sysapiCpuUtilTblSema) != L7_SUCCESS)
   {
     L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_OSAPI_COMPONENT_ID,
-            "Failed to give cpuUtilSema %x\n", sysapiCpuUtilTblSema);
+            "Failed to give cpuUtilSema %x\n", (int)sysapiCpuUtilTblSema);
   }
 }
 
 
 /*********************************************************************
Index: src/system_support/base/system/support/sysapi_support.c
===================================================================
--- src/system_support/base/system/support/sysapi_support.c	(revision 6677)
+++ src/system_support/base/system/support/sysapi_support.c	(working copy)
@@ -429,11 +429,11 @@
   /* Make sure that the configuration file is correct for the target device.
   */
   if (cfgFileHdr.targetDevice != hpc_unit->configLoadTargetId)
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_SIM_COMPONENT_ID,
-            "Unexpected target device:  %s\n",cfgFileHdr.targetDevice);
+            "Unexpected target device:  %d\n",cfgFileHdr.targetDevice);
     (void)osapiFsClose (file_desc);
     (void)osapiSemaGive(sysapiSupportCfgSema);
     return L7_ERROR;
   }
 
@@ -1310,11 +1310,11 @@
   {
     dataArea = osapiMalloc (component_id, compressedFileSize);
     if (dataArea == L7_NULL)
     {
       L7_LOGF(L7_LOG_SEVERITY_INFO, L7_SIM_COMPONENT_ID,
-              "Failed to allocate %ld for support config file %s\n", compressedFileSize, filename);
+              "Failed to allocate %d for support config file %s\n", compressedFileSize, filename);
       return L7_ERROR;
     }
   }
 
     /*
Index: src/system_support/routing/arp/arp.c
===================================================================
--- src/system_support/routing/arp/arp.c	(revision 6677)
+++ src/system_support/routing/arp/arp.c	(working copy)
@@ -1368,11 +1368,11 @@
    p_Rqe = (t_RQE *)XX_Malloc(sizeof(t_RQE ));
    if (p_Rqe == NULL)
    {
      return E_NOMEMORY;
    }
-   memset(p_Rqe, 0, sizeof(p_Rqe));
+   memset(p_Rqe, 0, sizeof(*p_Rqe));
    p_Rqe->dstAddrId = p_Adr;
    p_Rqe->userId = userId;
    p_Rqe->l3addr.protocolId = 0;
    memcpy(p_Rqe->l3addr.lay3Addr, ipAddr, sizeof(t_IPAddr));
    XX_AddToDLList(p_Rqe, p_Adr->request);
@@ -1418,11 +1418,11 @@
     if (p_Adr)
     {
       memset(p_Adr, 0, sizeof(t_ADR));
       p_Adr->p_obj = p_A;
       p_Adr->status = ARP_ENT_STAT_Valid;
-      memcpy(p_Adr->ipAddr, ipAddr, sizeof(ipAddr));
+      memcpy(p_Adr->ipAddr, ipAddr, sizeof(*ipAddr));
       p_Adr->intfNum = index;
       p_Adr->entryType = ARP_ENTRY_TYPE_DYNAMIC;
       temporary = L7_TRUE;
     }
   }
Index: src/system_support/routing/tcp/tcpbind.c
===================================================================
--- src/system_support/routing/tcp/tcpbind.c	(revision 6677)
+++ src/system_support/routing/tcp/tcpbind.c	(working copy)
@@ -1442,11 +1442,11 @@
             if (reqLength != rxLength)
             {
               /* should never happen */
               recvLenError++;
               L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_OSPF_MAP_COMPONENT_ID,
-                     "OSPF receive thread requested %d bytes. Received %d bytes.");
+                     "OSPF receive thread requested %d bytes. Received %d bytes.", reqLength, rxLength);
             }
             if (noPeekFlags & MSG_TRUNC)
             {
               /* should never happen */
               recvTrunc++;
Index: src/system_support/routing/utils/frame.c
===================================================================
--- src/system_support/routing/utils/frame.c	(revision 6677)
+++ src/system_support/routing/utils/frame.c	(working copy)
@@ -510,11 +510,11 @@
       useCount = buffer->useCount;
       if(B_GetSize(buffer) > (word)B_GetLength(buffer))
       {
          /* first buffer has enough space to prepend data */
          frame->frameLen++;
-         B_AddByteToStart( buffer, data );
+         (void)B_AddByteToStart( buffer, data );
          return TRUE;
       }
       p = &buffer->prev;
    }
 
@@ -525,11 +525,11 @@
    buffer->next = frame->firstBuf;
    *p = buffer; /* where (*p) is (firstBuf==NULL) ? firstBuf : firstBuf->prev */
    frame->firstBuf = buffer;
    buffer->useCount = useCount;
    frame->frameLen++;
-   B_AddByteToStart( buffer, data );
+   (void)B_AddByteToStart( buffer, data );
    return TRUE;
 }
 
 /* Add array to the end of the frame */
 word   F_AddToEnd( void *p_Frame, byte *pData, word Length )
@@ -652,11 +652,11 @@
       useCount = buffer->useCount;
       if(B_GetSize(buffer)>(word)B_GetLength(buffer))
       {
          /* last buffer has enough space to pospend data */
          frame->frameLen++;
-         B_AddByteToEnd( buffer, data );
+         (void)B_AddByteToEnd( buffer, data );
          return TRUE;
       }
    }
 
    /* Try allocate a new buffer and put data into it */
@@ -665,11 +665,11 @@
 
    buf->useCount = useCount;
    *p = buf;
    frame->frameLen++;
    buf->prev = buffer;
-   B_AddByteToEnd( buf, data );
+   (void)B_AddByteToEnd( buf, data );
    return TRUE;
 }
 
 
 /* Remove data from the start of the frame */
Index: src/system_support/routing/utils/ospfv2_decode.c
===================================================================
--- src/system_support/routing/utils/ospfv2_decode.c	(revision 6677)
+++ src/system_support/routing/utils/ospfv2_decode.c	(working copy)
@@ -129,11 +129,11 @@
 char *v2aseLsaForwAddrStr = "Forwarding Address";
 char *v2aseLsaTagStr = "Tag";
 char *v2aseLsaOptionsEBitStr = "E-Bit";
 
 /* graceful restart reasons (RFC 3623) */
-static char* restartReasonStr(restartReason)
+static char* restartReasonStr(L7_uint restartReason)
 {
   switch (restartReason)
   {
     case 0: return "Unknown";
     case 1: return "Software restart";
Index: src/system_support/routing/utils/timer.c
===================================================================
--- src/system_support/routing/utils/timer.c	(revision 6677)
+++ src/system_support/routing/utils/timer.c	(working copy)
@@ -986,11 +986,11 @@
             (void) XX_Call(thread, callInfo);  /* May fail if queue full. OK for some queues. */
          }
          else
          {
            L7_LOGF(L7_LOG_SEVERITY_CRITICAL, L7_IP_MAP_COMPONENT_ID,
-                   "Memory allocation failure in _checkTimers for queue %d thread 0x%x",
+                   "Memory allocation failure in _checkTimers for queue %lu thread 0x%lx",
                    p_T->queueId, thread->TaskID);
          }
          XX_Freeze();
       }
 
Index: src/system_support/security/radius/client/radius_control.c
===================================================================
--- src/system_support/security/radius/client/radius_control.c	(revision 6677)
+++ src/system_support/security/radius/client/radius_control.c	(working copy)
@@ -885,11 +885,11 @@
       RADIUS_DLOG(RD_LEVEL_INFO,"%s(): DNS resolution failed.. ",__FUNCTION__);
     }
     else
     {
       RADIUS_DLOG(RD_LEVEL_INFO,"%s(): DNS Resolution success, host: %s - ip: %s\n",
-                     hostAddr->host.hostName,osapiInet_ntoa(ipaddr));
+                     __FUNCTION__, hostAddr->host.hostName,osapiInet_ntoa(ipaddr));
     }
   }
   else
   {
     ipaddr = hostAddr->host.ipAddr;
@@ -2881,11 +2881,11 @@
 
   else if( 0 == index || L7_NULLPTR == serverName ||
            0 == authServerNameArray[index-1].serverCount  )
   {
     RADIUS_DLOG(RD_LEVEL_INFO,"RADIUS: %s() Invalid Parameters: \
-                    index=%d serverName(ptr):%u serverCount:%d\n",__FUNCTION__,
+                    index=%d serverName:%s serverCount:%d\n",__FUNCTION__,
                     index,serverName,authServerNameArray[index-1].serverCount);
     return L7_FAILURE;
   }
 
   osapiStrncpySafe(serverName,authServerNameArray[index-1].serverName,
Index: src/system_support/security/radius/client/radius_txrx.c
===================================================================
--- src/system_support/security/radius/client/radius_txrx.c	(revision 6677)
+++ src/system_support/security/radius/client/radius_txrx.c	(working copy)
@@ -992,11 +992,11 @@
   L7_RC_t rc = L7_FAILURE;
 
   if( L7_NULL == interfaceSocket )
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_RADIUS_COMPONENT_ID,
-            "RADIUS: %S(): Invalid parameters \n",__FUNCTION__);
+            "RADIUS: %s(): Invalid parameters \n",__FUNCTION__);
     return L7_FAILURE;
   }
 
   for(i=0;i<radiusGlobalData.totalNwInterfaces;i++)
   {
@@ -1010,11 +1010,11 @@
   }
   if(L7_FAILURE == rc )
   {
     L7_LOGF(L7_LOG_SEVERITY_INFO, L7_RADIUS_COMPONENT_ID,
             "RADIUS: radiusNwInterfaceSocketTimeStampPut(): Could not find the \
-                     ipAddr for specified socket : %s\n",interfaceSocket);
+                     ipAddr for specified socket : %u\n",interfaceSocket);
   }
 
   return rc;
 }
 
Index: src/usmdb/system_support/base/usmdb_util.c
===================================================================
--- src/usmdb/system_support/base/usmdb_util.c	(revision 6677)
+++ src/usmdb/system_support/base/usmdb_util.c	(working copy)
@@ -468,15 +468,15 @@
   L7_ulong32 value[4], part, carry = 0;
 
 #define MAX_VALUE 4440000U
 
 
-  /* If no num */
-  if (&num == NULL)
-  {
-    return L7_FAILURE;
-  }
+///* If no num */
+//if (&num == NULL)
+//{
+//  return L7_FAILURE;
+//}
 
   /* If only a 32 bit counter */
   if (num.high == 0)
   {
     sprintf(buf, "%lu", (L7_ulong32) num.low);
@@ -3343,11 +3343,11 @@
   {
     return L7_FAILURE;
   }
   
   memcpy (&timeInSeconds, timeTicks, sizeof (L7_uint32));
-  memset (buf, 0, sizeof (buf));
+//  memset (buf, 0, sizeof (buf)); MEDO!!!
   
   timeInSeconds = timeInSeconds / 100;  /*to get no of seconds */  
   days = timeInSeconds / 86400;
   timeInSeconds = timeInSeconds % 86400;
   hours = timeInSeconds / 3600;
