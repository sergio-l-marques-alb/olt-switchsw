
/*******************************************************************************
 *
 * (C) Copyright Broadcom Corporation 2000-2008
 *
 ********************************************************************************
 *
 * @filename fpobj_baseLogEventLogEntry.c
 *
 * @purpose  
 *
 * @component object handlers
 *
 * @comments  Refer to base-object.xml
 *
 * @create  10 July 2008, Thursday
 *
 * @notes   This file is auto generated and should be used as starting point to
 *          develop the object handlers
 *
 * @author  Rama Sasthri, Kristipati
 * @end
 *
 ********************************************************************************/

#include "fpobj_util.h"
#include "_xe_baseLogEventLogEntry_obj.h"
#include "fpobj_event_log_util.h"
#include "usmdb_log_api.h"

/*******************************************************************************
 * @function fpObjGet_baseLogEventLogEntry_logIndex
 *
 * @purpose Get 'logIndex'
 *@description  [logIndex]  An index that uniquely identifies an entry in the
 * log table amongst those generated by the same eventEntries. These
 * indexes are assigned beginning with 1 and increase by one with
 * each new log entry. The association    
 * @notes       
 *
 * @return
 *******************************************************************************/
xLibRC_t fpObjGet_baseLogEventLogEntry_logIndex (void *wap, void *bufp)
{
  fpObjWa_t owa = FPOBJ_INIT_WA2 ();
  xLibU32_t objlogIndexValue;
  xLibU32_t nextObjlogIndexValue;
  xLibS8_t eventLog[LOG_MSG_MAX_MSG_SIZE];


  FPOBJ_TRACE_ENTER (bufp);
  memset(eventLog,0x0,sizeof(eventLog));

  /* retrieve key: logIndex */
  owa.len = sizeof (objlogIndexValue);
  owa.rc = xLibFilterGet (wap, XOBJ_baseLogEventLogEntry_logIndex,
      (xLibU8_t *) & objlogIndexValue, &owa.len);
  if (owa.rc != XLIBRC_SUCCESS)
  {
    FPOBJ_TRACE_CURRENT_KEY (bufp, NULL, 0);
    objlogIndexValue= L7_NULL;
  }
  FPOBJ_TRACE_CURRENT_KEY (bufp, &objlogIndexValue, owa.len);
  nextObjlogIndexValue  = usmDbLogEventLogEntryNextGet(L7_EVENT_LOG_UNIT_CURRENT, objlogIndexValue, eventLog);

  if (nextObjlogIndexValue  == L7_NULL)
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_NEW_KEY (bufp, &nextObjlogIndexValue, owa.len);

  /* return the object value: logIndex */
  owa.rc = xLibBufDataSet (bufp, (xLibU8_t *) & nextObjlogIndexValue,
      sizeof (nextObjlogIndexValue));
  FPOBJ_TRACE_EXIT (bufp, owa);
  return owa.rc;

}

/*******************************************************************************
 * @function fpObjGet_baseLogEventLogEntry_LogEventIndex
 *
 * @purpose Get 'LogEventIndex'
 *@description  [LogEventIndex] Index to the next event log entry or NULL if
 * requesting the first   
 * @notes       
 *
 * @return
 *******************************************************************************/
xLibRC_t fpObjGet_baseLogEventLogEntry_LogEventIndex (void *wap, void *bufp)
{
  fpObjWa_t owa = FPOBJ_INIT_WA2 ();
  xLibU32_t objLogEventIndexValue;
  xLibU32_t nextObjLogEventIndexValue = L7_NULL;

  xLibU32_t keylogIndexValue;
  xLibU32_t nextkeylogIndexValue = L7_NULL;
  xLibS8_t eventLog[LOG_MSG_MAX_MSG_SIZE];

  FPOBJ_TRACE_ENTER (bufp);
  memset(eventLog,0x0,sizeof(eventLog));

  /* retrieve key: logIndex */
  owa.len = sizeof (keylogIndexValue);
  owa.rc = xLibFilterGet (wap, XOBJ_baseLogEventLogEntry_logIndex,
      (xLibU8_t *) & keylogIndexValue, &owa.len);
  if (owa.rc != XLIBRC_SUCCESS)
  {
    owa.rc = XLIBRC_FILTER_MISSING;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_CURRENT_KEY (bufp, &keylogIndexValue, owa.len);

  /* retrieve key: LogEventIndex */
  owa.len = sizeof (objLogEventIndexValue);
  owa.rc = xLibFilterGet (wap, XOBJ_baseLogEventLogEntry_LogEventIndex,
      (xLibU8_t *) & objLogEventIndexValue, &owa.len);
  if (owa.rc != XLIBRC_SUCCESS)
  {
    FPOBJ_TRACE_CURRENT_KEY (bufp, NULL, 0);
    objLogEventIndexValue = 0;
  }

  FPOBJ_TRACE_CURRENT_KEY (bufp, &objLogEventIndexValue, owa.len);
  nextkeylogIndexValue = usmDbLogEventLogEntryNextGet(L7_EVENT_LOG_UNIT_CURRENT, keylogIndexValue,
      eventLog);

  if (nextkeylogIndexValue == L7_NULL)
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }
  nextObjLogEventIndexValue = objLogEventIndexValue + 1;

  FPOBJ_TRACE_NEW_KEY (bufp, &nextObjLogEventIndexValue, owa.len);

  /* return the object value: LogEventIndex */
  owa.rc = xLibBufDataSet (bufp, (xLibU8_t *) & nextObjLogEventIndexValue,
      sizeof (nextObjLogEventIndexValue));
  FPOBJ_TRACE_EXIT (bufp, owa);
  return owa.rc;

}

/*******************************************************************************
 * @function fpObjGet_baseLogEventLogEntry_EventLog
 *
 * @purpose Get 'EventLog'
 *@description  [EventLog] Ptr to place the formatted event log requested   
 * @notes       
 *
 * @return
 *******************************************************************************/
xLibRC_t fpObjGet_baseLogEventLogEntry_EventLog (void *wap, void *bufp)
{
  fpObjWa_t owa = FPOBJ_INIT_WA2 ();
  xLibS8_t objEventLogValue[LOG_MSG_MAX_MSG_SIZE];

  xLibU32_t keylogIndexValue;
  xLibU32_t nextkeylogIndexValue = L7_NULL;

  FPOBJ_TRACE_ENTER (bufp);
  memset(objEventLogValue,0x0,sizeof(objEventLogValue));

  /* retrieve key: logIndex */
  owa.len = sizeof (keylogIndexValue);
  owa.rc = xLibFilterGet (wap, XOBJ_baseLogEventLogEntry_logIndex,
      (xLibU8_t *) & keylogIndexValue, &owa.len);
  if (owa.rc != XLIBRC_SUCCESS)
  {
    owa.rc = XLIBRC_FILTER_MISSING;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_CURRENT_KEY (bufp, &keylogIndexValue, owa.len);

  /* get the value from application */
  nextkeylogIndexValue  = usmDbLogEventLogEntryNextGet(L7_EVENT_LOG_UNIT_CURRENT, keylogIndexValue, objEventLogValue);
  if (nextkeylogIndexValue  == L7_NULL)
  {
    owa.rc = XLIBRC_FAILURE;    /* TODO: Change if required */
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_VALUE (bufp, objEventLogValue, strlen (objEventLogValue));

  /* return the object value: EventLog */
  owa.rc = xLibBufDataSet (bufp, (xLibU8_t *) objEventLogValue, strlen (objEventLogValue));
  FPOBJ_TRACE_EXIT (bufp, owa);
  return owa.rc;

}

/*******************************************************************************
 * @function fpObjGet_baseLogEventLogEntry_logTime
 *
 * @purpose Get 'logTime'
 *@description  [logTime]  The value of sysUpTime when this log entry was
 * created.   
 * @notes       
 *
 * @return
 *******************************************************************************/
xLibRC_t fpObjGet_baseLogEventLogEntry_logTime (void *wap, void *bufp)
{
  fpObjWa_t owa = FPOBJ_INIT_WA2 ();

  xLibU32_t keylogIndexValue;
  xLibU32_t nextkeylogIndexValue = L7_NULL;
  xLibS8_t eventLog[LOG_MSG_MAX_MSG_SIZE];
  xLibS8_t retBuf[LOG_MSG_MAX_MSG_SIZE];
  xLibS8_t tempBuf[LOG_MSG_MAX_MSG_SIZE];
  xLibS8_t tempBuf1[LOG_MSG_MAX_MSG_SIZE];
  xLibS8_t* space = " ";

  FPOBJ_TRACE_ENTER (bufp);
  memset(eventLog,0x0,sizeof(eventLog));  
  memset(retBuf,0x0,sizeof(retBuf));  
  memset(tempBuf,0x0,sizeof(tempBuf));  
  memset(tempBuf1,0x0,sizeof(tempBuf1));  

  /* retrieve key: logIndex */
  owa.len = sizeof (keylogIndexValue);
  owa.rc = xLibFilterGet (wap, XOBJ_baseLogEventLogEntry_logIndex,
      (xLibU8_t *) & keylogIndexValue, &owa.len);
  if (owa.rc != XLIBRC_SUCCESS)
  {
    owa.rc = XLIBRC_FILTER_MISSING;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_CURRENT_KEY (bufp, &keylogIndexValue, owa.len);

  /* get the value from application */
  nextkeylogIndexValue = usmDbLogEventLogEntryNextGet(L7_EVENT_LOG_UNIT_CURRENT, keylogIndexValue,
      eventLog);

  if (nextkeylogIndexValue == L7_NULL)
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }
  FPOBJ_TRACE_VALUE (bufp, &objlogTimeValue, sizeof (objlogTimeValue));
  memcpy(tempBuf1,eventLog,strlen(eventLog));
  if(XLIBRC_SUCCESS == L7_event_log_string_get(tempBuf1,DAYS," ",tempBuf))
  {
    osapiStrncat(retBuf,tempBuf,strlen(tempBuf)); 
    osapiStrncat(retBuf,space,strlen(space));
  } 
  memset(tempBuf,0x0,sizeof(tempBuf));  
  memset(tempBuf1,0x0,sizeof(tempBuf1));  
  memcpy(tempBuf1,eventLog,strlen(eventLog));
  if(XLIBRC_SUCCESS == L7_event_log_string_get(tempBuf1,HOURS," ",tempBuf))
  {
    osapiStrncat(retBuf,tempBuf,strlen(tempBuf));
    osapiStrncat(retBuf,space,strlen(space));
  }
  memset(tempBuf,0x0,sizeof(tempBuf));  
  memset(tempBuf1,0x0,sizeof(tempBuf1));  
  memcpy(tempBuf1,eventLog,strlen(eventLog));
  if(XLIBRC_SUCCESS == L7_event_log_string_get(tempBuf1,MINS," ",tempBuf))
  {
    osapiStrncat(retBuf,tempBuf,strlen(tempBuf));
    osapiStrncat(retBuf,space,strlen(space));
  }
  memset(tempBuf,0x0,sizeof(tempBuf));  
  memset(tempBuf1,0x0,sizeof(tempBuf1));  
  memcpy(tempBuf1,eventLog,strlen(eventLog));
  if(XLIBRC_SUCCESS == L7_event_log_string_get(tempBuf1,SECS," ",tempBuf))
  {
    osapiStrncat(retBuf,tempBuf,strlen(tempBuf));
  }

  /* return the object value: logTime */
  owa.rc = xLibBufDataSet (bufp, (xLibU8_t *) &retBuf, sizeof (retBuf));
  FPOBJ_TRACE_EXIT (bufp, owa);
  return owa.rc;

}

/*******************************************************************************
 * @function fpObjGet_baseLogEventLogEntry_logFileName
 *
 * @purpose Get 'logFileName'
 *@description  [logFileName]  An implementation dependent description of the
 * event that activated this log entry.   
 * @notes       
 *
 * @return
 *******************************************************************************/
xLibRC_t fpObjGet_baseLogEventLogEntry_logFileName (void *wap, void *bufp)
{
  fpObjWa_t owa = FPOBJ_INIT_WA2 ();
  xLibS8_t eventLog[LOG_MSG_MAX_MSG_SIZE];
  xLibS8_t tempBuf[LOG_MSG_MAX_MSG_SIZE];

  xLibU32_t keylogIndexValue;
  xLibU32_t nextkeylogIndexValue = L7_NULL;

  FPOBJ_TRACE_ENTER (bufp);
  memset(eventLog,0x0,sizeof(eventLog));

  /* retrieve key: logIndex */
  owa.len = sizeof (keylogIndexValue);
  owa.rc = xLibFilterGet (wap, XOBJ_baseLogEventLogEntry_logIndex,
      (xLibU8_t *) & keylogIndexValue, &owa.len);
  if (owa.rc != XLIBRC_SUCCESS)
  {
    owa.rc = XLIBRC_FILTER_MISSING;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_CURRENT_KEY (bufp, &keylogIndexValue, owa.len);

  nextkeylogIndexValue = usmDbLogEventLogEntryNextGet(L7_EVENT_LOG_UNIT_CURRENT, keylogIndexValue,
      eventLog);

  if (nextkeylogIndexValue == L7_NULL)
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  if(XLIBRC_SUCCESS != L7_event_log_string_get(eventLog,FILENAME," ",tempBuf))
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_VALUE (bufp, tempBuf, strlen (tempBuf));

  /* return the object value: logFileName */
  owa.rc = xLibBufDataSet (bufp, (xLibU8_t *) tempBuf, strlen (tempBuf));
  FPOBJ_TRACE_EXIT (bufp, owa);
  return owa.rc;

}

/*******************************************************************************
 * @function fpObjGet_baseLogEventLogEntry_logLineNumber
 *
 * @purpose Get 'logLineNumber'
 *@description  [logLineNumber]  An implementation dependent description of the
 * event that activated this log entry.   
 * @notes       
 *
 * @return
 *******************************************************************************/
xLibRC_t fpObjGet_baseLogEventLogEntry_logLineNumber (void *wap, void *bufp)
{
  fpObjWa_t owa = FPOBJ_INIT_WA2 ();

  xLibU32_t keylogIndexValue;
  xLibU32_t nextkeylogIndexValue = L7_NULL;
  xLibS8_t eventLog[LOG_MSG_MAX_MSG_SIZE];
  xLibS8_t tempBuf[LOG_MSG_MAX_MSG_SIZE];

  FPOBJ_TRACE_ENTER (bufp);
  memset(eventLog,0x0,sizeof(eventLog));
  memset(tempBuf,0x0,sizeof(tempBuf));

  /* retrieve key: logIndex */
  owa.len = sizeof (keylogIndexValue);
  owa.rc = xLibFilterGet (wap, XOBJ_baseLogEventLogEntry_logIndex,
      (xLibU8_t *) & keylogIndexValue, &owa.len);
  if (owa.rc != XLIBRC_SUCCESS)
  {
    owa.rc = XLIBRC_FILTER_MISSING;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_CURRENT_KEY (bufp, &keylogIndexValue, owa.len);

  nextkeylogIndexValue = usmDbLogEventLogEntryNextGet(L7_EVENT_LOG_UNIT_CURRENT, keylogIndexValue,
      eventLog);

  if (nextkeylogIndexValue == L7_NULL)
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  if(XLIBRC_SUCCESS != L7_event_log_string_get(eventLog,LINE_NUMBER," ",tempBuf))
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }


  FPOBJ_TRACE_VALUE (bufp, tempBuf, strlen (tempBuf));

  /* return the object value: logLineNumber */
  owa.rc = xLibBufDataSet (bufp, (xLibU8_t *) tempBuf,
      strlen (tempBuf));
  FPOBJ_TRACE_EXIT (bufp, owa);
  return owa.rc;

}

/*******************************************************************************
 * @function fpObjGet_baseLogEventLogEntry_logTaskId
 *
 * @purpose Get 'logTaskId'
 *@description  [logTaskId]  An implementation dependent description of the
 * event that activated this log entry.   
 * @notes       
 *
 * @return
 *******************************************************************************/
xLibRC_t fpObjGet_baseLogEventLogEntry_logTaskId (void *wap, void *bufp)
{
  fpObjWa_t owa = FPOBJ_INIT_WA2 ();

  xLibU32_t keylogIndexValue;
  xLibU32_t nextkeylogIndexValue = L7_NULL;
  xLibS8_t eventLog[LOG_MSG_MAX_MSG_SIZE];
  xLibS8_t tempBuf[LOG_MSG_MAX_MSG_SIZE];

  FPOBJ_TRACE_ENTER (bufp);
  memset(eventLog,0x0,sizeof(eventLog));
  memset(tempBuf,0x0,sizeof(tempBuf));

  /* retrieve key: logIndex */
  owa.len = sizeof (keylogIndexValue);
  owa.rc = xLibFilterGet (wap, XOBJ_baseLogEventLogEntry_logIndex,
      (xLibU8_t *) & keylogIndexValue, &owa.len);
  if (owa.rc != XLIBRC_SUCCESS)
  {
    owa.rc = XLIBRC_FILTER_MISSING;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_CURRENT_KEY (bufp, &keylogIndexValue, owa.len);

  nextkeylogIndexValue = usmDbLogEventLogEntryNextGet(L7_EVENT_LOG_UNIT_CURRENT, keylogIndexValue,
      eventLog);

  if (nextkeylogIndexValue == L7_NULL)
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }
  if(XLIBRC_SUCCESS != L7_event_log_string_get(eventLog,DAYS," ",tempBuf))
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }


  FPOBJ_TRACE_VALUE (bufp, tempBuf, strlen (tempBuf));

  /* return the object value: logTaskId */
  owa.rc = xLibBufDataSet (bufp, (xLibU8_t *) tempBuf, strlen (tempBuf));
  FPOBJ_TRACE_EXIT (bufp, owa);
  return owa.rc;

}

/*******************************************************************************
 * @function fpObjGet_baseLogEventLogEntry_logCode
 *
 * @purpose Get 'logCode'
 *@description  [logCode]  An implementation dependent description of the event
 * that activated this log entry.   
 * @notes       
 *
 * @return
 *******************************************************************************/
xLibRC_t fpObjGet_baseLogEventLogEntry_logCode (void *wap, void *bufp)
{
  fpObjWa_t owa = FPOBJ_INIT_WA2 ();

  xLibU32_t keylogIndexValue;
  xLibU32_t nextkeylogIndexValue = L7_NULL;
  xLibS8_t eventLog[LOG_MSG_MAX_MSG_SIZE];
  xLibS8_t tempBuf[LOG_MSG_MAX_MSG_SIZE];

  FPOBJ_TRACE_ENTER (bufp);
  memset(eventLog,0x0,sizeof(eventLog));
  memset(tempBuf,0x0,sizeof(tempBuf));

  /* retrieve key: logIndex */
  owa.len = sizeof (keylogIndexValue);
  owa.rc = xLibFilterGet (wap, XOBJ_baseLogEventLogEntry_logIndex,
      (xLibU8_t *) & keylogIndexValue, &owa.len);
  if (owa.rc != XLIBRC_SUCCESS)
  {
    owa.rc = XLIBRC_FILTER_MISSING;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_CURRENT_KEY (bufp, &keylogIndexValue, owa.len);

  nextkeylogIndexValue = usmDbLogEventLogEntryNextGet(L7_EVENT_LOG_UNIT_CURRENT, keylogIndexValue,
      eventLog);

  if (nextkeylogIndexValue == L7_NULL)
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  if(XLIBRC_SUCCESS != L7_event_log_string_get(eventLog,CODE," ",tempBuf))
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;

  }

  FPOBJ_TRACE_VALUE (bufp, tempBuf, strlen (tempBuf));

  /* return the object value: logCode */
  owa.rc = xLibBufDataSet (bufp, (xLibU8_t *)tempBuf, strlen (tempBuf));
  FPOBJ_TRACE_EXIT (bufp, owa);
  return owa.rc;
}

/*******************************************************************************
 * @function fpObjGet_baseLogEventLogEntry_EventType
 *
 * @purpose Get 'EventType'
 *@description  [EventType] Ptr to place the formatted event log requested
 * @notes
 *
 * @return
 *******************************************************************************/
xLibRC_t fpObjGet_baseLogEventLogEntry_EventType (void *wap, void *bufp)
{
  fpObjWa_t owa = FPOBJ_INIT_WA2 ();
  xLibS8_t eventLog[LOG_MSG_MAX_MSG_SIZE];
  xLibS8_t tempBuf[LOG_MSG_MAX_MSG_SIZE];
  xLibU32_t keylogIndexValue;
  xLibU32_t nextkeylogIndexValue = L7_NULL;

  FPOBJ_TRACE_ENTER (bufp);
  memset(eventLog,0x0,sizeof(eventLog));
  memset(tempBuf,0x0,sizeof(tempBuf));

  /* retrieve key: logIndex */
  owa.len = sizeof (keylogIndexValue);
  owa.rc = xLibFilterGet (wap, XOBJ_baseLogEventLogEntry_logIndex,
      (xLibU8_t *) & keylogIndexValue, &owa.len);
  if (owa.rc != XLIBRC_SUCCESS)
  {
    owa.rc = XLIBRC_FILTER_MISSING;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_CURRENT_KEY (bufp, &keylogIndexValue, owa.len);
  nextkeylogIndexValue = usmDbLogEventLogEntryNextGet(L7_EVENT_LOG_UNIT_CURRENT, keylogIndexValue,
      eventLog);

  if (nextkeylogIndexValue == L7_NULL)
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;
  }

  FPOBJ_TRACE_VALUE (bufp, objEventTypeValue, strlen (objEventTypeValue));
  if(XLIBRC_SUCCESS != L7_event_log_string_get(eventLog,EVENT," ",tempBuf))
  {
    owa.rc = XLIBRC_ENDOF_TABLE;
    FPOBJ_TRACE_EXIT (bufp, owa);
    return owa.rc;

  }
  /* return the object value: EventType */
  owa.rc = xLibBufDataSet (bufp, (xLibU8_t *) tempBuf, strlen (tempBuf));
  FPOBJ_TRACE_EXIT (bufp, owa);
  return owa.rc;

}

