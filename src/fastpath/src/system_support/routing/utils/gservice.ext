/********************************************************************
 *
 * (C) Copyright Broadcom Corporation 2003-2007
 *
 * *********************************************************************
 *
 * @filename        gservice.ext
 *
 * @purpose         This file contains gate procedures for initialization
 *                  and access to different service types.
 *
 * @component       Routing Utils Component
 *
 * @comments
 *
 * @create
 *
 * @author
 *
 * @end
 *
 * ********************************************************************/
#ifndef gservice_ext
#define gservice_ext

#include "std.h"

#include "common.h"

/*-------------------------------------------------------------------------------------*/
/* The prototypes for user defined functions.                                          */
/*-------------------------------------------------------------------------------------*/

/* User browser function or NULL function.                                             */
/* Returns TRUE for the valid entry and FALSE otherwise.                               */
typedef Bool (*GS_BROWSEFUNC) (IN  byte *p_value, /* pointer to a value                */
                               IN  ulng Ctrl);    /* control params                    */

/* User key compare function or the default function.                                  */
/* Returns result of key compare operation.                                            */
typedef int (*GS_KEYCOMPFUNC) (IN  const void  *p_key1, /* pointer to the first key    */
                              IN  const void   *p_key2, /* pointer to the second key   */
                              IN  unsigned int len);    /* key length                  */

/* User fill object function or NULL function.                                         */
/* Can be used in case an object can be datafilled from some external source (bulk     */
/* update). Such method of update can be applied to empty or non empty object. Can be  */
/* applied for the services with "slow" insert/delete operation (for example for       */
/* different types of balanced store methods). Fill function has to recognize the data */
/* input presentation format and convert this format into insert operation format.     */
typedef void (*GS_FILLOBJFUNC)(IN  t_Handle objId, /* object handle returned by
                                                      an object constructor            */
                              IN  void     *p_data,/* pointer to a user data           */
                              IN  ulng     Ctrl);  /* control parameters               */

/* User value compare function or the default  function.                               */
/* Returns result of value compare operation.                                          */
/* Returns result of value compare operation.                                          */
/* Can be used in case when some values contain the duplicated info while only one     */
/* copy of this info should be stored. In such case duplicators can be removed.        */
typedef int  (*GS_VALCOMPFUNC)(IN  const void  *p_value1,/* pointer to the first value */
                               IN  const void  *p_value2,/* pointer to the second value*/
                               IN  unsigned int len);    /*  value length              */

/* User defined hash function - hash calculation callback                              */
typedef word (*GS_HASHFUNC)(byte *key);

/* User defined get key function - get key via handle of stored value                  */
typedef byte *(*GS_GETKEYFUNC)(void *);

/* User callback routine that can be used to indicate user about some event, that      */
/* requires user intervention. For example, if balanced structure has some threshold   */
/* value as rebuild criteria, this callback can notify user that threshold value has   */
/* been reached or withdrawn, In this situation user can invoke _WriteLock or          */
/* _WriteUnLock APIs.                                                                  */
typedef void (*GS_USEREVENT)(IN t_Handle ownerId,    /* handle of the object owner     */
                             IN t_Handle objId,      /* handle of object itself        */
                             IN ulng     userEvent); /* control parameters             */

/* The set of parameters that has to be supplied for object constructor routine.
   No one of this parameters is mandatory.
*/
typedef struct tagt_ConstrDataParams
{
   word             flags;          /* control flags                                       */
   word             KeyOffset;      /* key offset in the handle structure                  */
   word             KeyLen;         /* key length in bytes                                 */
   word             ValueLen;       /* value length or offset in user data (handle         */
                                    /* structure), at which  destination address is stored */
   ulng             TableSize;      /* numbers of fields in hash/link list                 */
   GS_GETKEYFUNC    f_GetKey;       /* user defined function to get key via the handle     */
                                    /* the handle, if NULLP key is in the handle structure */
   GS_KEYCOMPFUNC   f_KeyCompare;   /* user or default (if called with NULLP)              */
                                    /* routine for key comparison;                         */
   GS_VALCOMPFUNC   f_ValCompare;   /* user or default (if called with NULLP)              */
                                    /* routine for value comparison;                       */
   GS_HASHFUNC      f_Hash;         /* user defined hash function, if NULLP, then default  */
                                    /* hash function is used.                              */
   GS_FILLOBJFUNC   f_Fill;         /* user defined datafill function (in case of some     */
                                    /* special user requirements for datafill or NULLP     */
                                    /* otherwise.                                          */
   GS_USEREVENT     f_UserEvent;    /* user defined function for special event handling.   */
   t_Handle         userParams;     /* Pointer to abstract strucrture with user additional */
                                    /* parameters                                          */
} t_ConstrDataParams;

/* Full set of targets supplied for generic service interface.
   For full description, see the related gate routines below.
*/

/* Destruct object.
   Parameters:
   IN     t_Handle        objId            - object instance handle.
*/
typedef   void      (*GS_Destruct)(t_Handle);

/* Insert new entry into an object.
   Parameters:
   IN     t_Handle        objId       - object instance handle;
   IN     byte            *p_key      - pointer to key;
   IN     void            *p_value    - pointer to user data.
*/
typedef   e_Err     (*GS_Insert)(t_Handle, byte*, void*);

/* Insert new entry into an object in a sorted way.
   Parameters:
   IN     t_Handle        objId        - object instance handle;
   IN     byte            *p_key       - pointer to key;
   IN     void            *p_value     - pointer to user data.
*/
typedef   e_Err     (*GS_SortedInsert)(t_Handle, byte*, void*);

/* Change an object entry stored within an input key.
   Parameters:
   IN     t_Handle        objId        - object instance handle;
   IN     byte            *p_key       - pointer to key;
   IN     void            *p_value     - pointer to a user data to be
                                         inserted into an object instead of old
                                         data.
*/
typedef   e_Err     (*GS_Change)(t_Handle, byte*, void*);

/* Move object entry in accordance with new key.
   Parameters:
   IN     t_Handle         objId       - object instance handle;
   IN     byte             *p_oldKey   - pointer to key to find entry;
   IN     void             *p_value    - pointer to a user data;
   IN     byte             *p_newKey   - pointer to a new key.
*/
typedef   e_Err     (*GS_Move)(t_Handle, byte*, void*, byte*);

/* Delete entry from object stored by an input key (or the first entry found
   by this key).
   Parameters:
   IN     t_Handle         objId       - object instance handle;
   IN     byte             *p_key      - pointer to a key;
   OUT    void             **pp_value  - double pointer to put a user data.
*/
typedef   e_Err     (*GS_Delete)(t_Handle, byte*, void**);

/* Delete entry from object that matched input value (fixed value).
   Parameters:
   IN     t_Handle         objId       - object instance handle;
   IN     byte             *p_key      - pointer to a key;
   OUT    void             *p_value    - pointer to a user data to be deleted.
*/
typedef   e_Err     (*GS_DeleteFixed)(t_Handle, byte*, void*);

/* Find entry from stored by an input key (or the first entry found
   by this key).
   Parameters:
   IN     t_Handle         objId       - object instance handle;
   IN     Bool             flag        - flag to indicate whtether best (TRUE) or exact (FALSE)
                                         match for input key is to be found
   IN     byte             *p_key      - pointer to a key;
   OUT    void             **pp_value  - double pointer to put a user data.
*/
typedef   e_Err     (*GS_Find)(t_Handle, Bool, byte*, void**);

/* Find entry which hits specified key next after value pointed by p_valueLast
   Parameters:
   IN     t_Handle         objId       - object instance handle;
   IN     byte             *p_key      - pointer to a key;
   IN     void             *p_valueLast- pointer to value from which get next
                                         operation has to lookup;
   OUT    void             **pp_value  - double pointer to to put a user data.
*/
typedef   e_Err     (*GS_FindNext)(t_Handle, byte*, void*, void**);

/* Browse entries of object which hit specified key, calling  browse funcion
   for every entry, if browse funcion for some entry returns FALSE, delete the
   entry.
   Parameters:
   IN  t_Handle            objId       - object instance handle;
   IN  byte                *p_key      - pointer to key
   IN  GS_BROWSEFUNC       f_Browse    - user defined browse function;
   IN  ulng                param       - parameter to be passed to browse function.
*/
typedef   e_Err     (*GS_FindBrowse)(t_Handle, byte*, GS_BROWSEFUNC, ulng);

/* Browse whole object instance, apply user defined browse routine f_Browse
   to every valid object entry.  If browse funcion for some entry returns FALSE,
   delete the entry.
   Parameters:
   IN  t_Handle            objId       - object instance handle;
   IN  GS_BROWSEFUNC       f_Browse    - user defined browse function;
   IN  ulng                param       - parameter to be passed to browse function.
*/
typedef   e_Err     (*GS_Browse)(t_Handle, GS_BROWSEFUNC, ulng);

/* Get the first object instance entry.
   Parameters:

   IN     t_Handle         objId       - object instance handle;
   OUT    void             **pp_value  - double pointer to put a value.
*/
typedef   e_Err     (*GS_GetFirst)(t_Handle, void**);

/* Get an object instance entry following next after value pointed by p_value.
   Parameters:

   IN     t_Handle         objId       - object instance handle;
   OUT    void             **pp_value  - double pointer to put a value.
   IN     void             *p_value    - pointer to the last accessed value
                                         (or NULLP if object itself keep track
                                         on the last accessed value).
*/
typedef   e_Err     (*GS_GetNext)(t_Handle, void**, void*);

/* Datafill empty object instance or extend the non empty object (bulk update).
   Input data is to be allocated by user (entries). This data can be presented by
   file, stream etc.
   Such method of update can be applied for the services with "slow" insert/delete operation
   (for example for different types of balanced store methods that required some
   preliminary work for construction of some object internal structures).
   Fill function has to recognize the data input presentation format and convert
   this format into insert operation format.
   Parameters:
   IN     t_Handle        objId        - object instance handle;
   IN     t_Handle        entries      - pointer to pre-allocated user input data;
   IN     ulng            EntriesN     - number of items pre-allocated for datafill;
   IN     GS_FILLOBJFUNC  f_Fill       - user defined datafill function;
   IN     ulng            Ctrl         - control parameters for f_Fill routine.
*/
typedef   e_Err     (*GS_FillObject)(t_Handle, t_Handle, ulng, GS_FILLOBJFUNC, ulng);

/* Lock object instance to prevent it from write access.
   After this method is applied to an object instance all the requested write
   operation must be stored in some object instance pending queue until object
   instance is unlocked. At the time it's locked, all lookup operation can or can
   not perform an additional search over this pending queue according to object
   instance configuration.
   The decision to apply this method can follow after some notification through user
   callback (see description of type GS_USEREVENT).
   Parameters:
   IN     t_Handle        objId        - object instance handle.
*/
typedef   e_Err     (*GS_WriteLock)(t_Handle);

/* Unlock object instance to allow write access.
   After this method is applied to an object instance all the pending write
   opearation that has been stored in a pending queue are to be applied.
   The decision to apply this method can follow after some notification through user
   callback (see description of type GS_USEREVENT).
   Parameters:
   IN     t_Handle        objId        - object instance handle.
*/
typedef   e_Err     (*GS_WriteUnLock)(t_Handle);

/* Interrupt object browsing if running.
   Parameters:
   IN     t_Handle        objId        - object instance handle
*/
typedef   e_Err     (*GS_Interrupt)(t_Handle);

/* Get the number of entries stored within the object instance.
   Parameters:
   IN     t_Handle        objId        - object instance handle;
   OUT    ulng            *p_entries   - pointer to the number of user data
                                         items.
*/
typedef   e_Err     (*GS_GetEntriesNmb)(t_Handle, ulng*);

/* Cleanup object instance data, but don't destroy an object instance itself.
   Parameters:
   IN     t_Handle        objId        - object instance handle.
*/
typedef   void      (*GS_Cleanup)(t_Handle, Bool);

/* Print object instance entry.
   Can be used to print specific input entry, to find and print an entry specified
   by input key, or together with browse method to print all object instance
   entries.
   Parameters:
   IN     t_Handle      objId        - object instance handle;
   IN     byte          *p_key       - pointer to a key (if NULLP - assume
                                       that specified value is to be printed);
   IN     void          *p_value     - pointer to a value to printed
                                       by f_PrintEntry (if NULLP - find
                                       the first value that hit specified key);
   IN     F_PrintStruct f_PrintEntry - entry specific print routine;
   IN     word          prtFlg       - print flags to be passed to print routine.
*/
typedef   void      (*GS_PrintEntry)(t_Handle, byte*, void*, F_PrintStruct, word);

/* The aspect containing the vector of target routines.                            */
/* The related gate procedures are defined in the module gservice.ext.             */
typedef struct tagt_GServiceAspect
{
   GS_Destruct       f_Destruct;      /* object destructor                                        */
   GS_Insert         f_Insert;        /* insert new entry into store                              */
   GS_SortedInsert   f_SortedInsert;  /* insert new entry in a sorted way                         */
   GS_Delete         f_Delete;        /* delete entry (first entry) from store hit specified key  */
   GS_DeleteFixed    f_DeleteFixed;   /* delete entry hit specified key and value                 */
   GS_Change         f_Change;        /* change an object entry stored within an input key        */
   GS_Move           f_Move;          /* move entry according to the new key                      */
   GS_Browse         f_Browse;        /* call browse funcion for each store entry                 */
   GS_Find           f_Find;          /* lookup for an entry (first entry) that is the exact or   */
                                      /* or the best match for specified key                      */
   GS_FindNext       f_FindNext;      /* find the next entry that hit specified key               */
   GS_FindBrowse     f_FindBrowse;    /* call browse funcion for entries that hit specified key   */
   GS_GetFirst       f_GetFirst;      /* get the first entry from store                           */
   GS_GetNext        f_GetNext;       /* get the next entry from store                            */
   GS_FillObject     f_FillObject;    /* fill empty or non-empty object in bulk mode              */
   GS_WriteLock      f_WriteLock;     /* disallow write operations (store write requests pending) */
   GS_WriteUnLock    f_WriteUnLock;   /* allow write operations (complete all pending requests)   */
   GS_Interrupt      f_Interrupt;     /* interrupt object browsing if running                     */
   GS_GetEntriesNmb  f_GetEntriesNmb; /* get number of stored entries                             */
   GS_Cleanup        f_Cleanup;       /* cleanup object data, but don't destroy an object itself  */
   GS_PrintEntry     f_PrintEntry;    /* print entry                                              */
} t_GServiceAspect;


/* User defined constructor :
   - the input first parameter is input data for constructor, could be pointer to
     t_ConstrDataParams, or pointer to some other user defined structure;
   - the first input output parameter is handle of the set of object methods
     allocated by application and filled by constructor;
   - the second output parameter is a pointer to handle of the object created by
     constructor.
*/
typedef e_Err (*GS_Constructor)(IN     t_Handle, /* assume t_ConstrDataParams*  */
                                IN OUT t_Handle, /* assume t_GServiceAspect*    */
                                OUT    t_Handle*);

/* ----------------------------------------------------------------------------- */
/* Example of convergence from MATCH table to (example)                          */
/* ----------------------------------------------------------------------------- */
/* MATCH Table    | HASH list        | Binary tree         | AVL tree            */
/* ---------------|------------------|---------------------|-------------------- */
/* keyLen most    |OWN_LINK=TRUE     |BT_OWN_LINK=TRUE     |                     */
/* sig.byte = 0   |                  |                     |                     */
/* ---------------|------------------|---------------------|-------------------- */
/* keyLen less    |keyLen            |keyLen               |keyLen               */
/* sig.byte       |                  |                     |                     */
/* ---------------|------------------|---------------------|-------------------- */
/* valueLen       |keyOffset         |keyOffset            |keyOffset            */
/* ---------------|------------------|---------------------|-------------------- */
/* tableSize      |tableSize         |                     |                     */
/* ---------------|------------------|---------------------|-------------------- */
/*                |KEY_AT_START=FALSE|                     |                     */
/*                |KEY_IS_VALUE=FALSE|BT_KEY_IS_VALUE=FALSE|                     */
/* ---------------|------------------|---------------------|-------------------- */
/* dataOffset     |                  |                     |                     */
/* sizeof(t_Value)|OFFSET            |BT_OFFSET            |                     */
/* -1             |                  |                     |                     */
/* ----------------------------------------------------------------------------- */
/* Example of replace MT service with HL, BT, AVL (constructor).                 */
/*                                                                               */
/* MT_Construct(MAXLAY3ADDR, sizeof(t_UrfeIntInfo *), URF_TABLESIZE,             */
/*              NULLP, NULLP, &fib->MT_URF[index]);                              */
/*                                                                               */
/* HL_Init (OWN_LINK, MAXLAY3ADDR, sizeof(t_UrfeIntInfo *), URF_TABLESIZE,       */
/*          NULLP, NULLP, &fib->MT_URF[index]);                                  */
/* BT_Init (BT_OWN_LINK, MAXLAY3ADDR, sizeof(t_UrfeIntInfo *),                   */
/*          NULLP, NULLP, &fib->MT_URF[index]);                                  */
/* AVL_Init (AVL_KEY_ULNG, MAXLAY3ADDR, sizeof(t_UrfeIntInfo *),                 */
/*          NULLP, NULLP, &fib->MT_URF[index]);                                  */
/*                                                                               */
/* Example of service configuration (extrenal):                                  */
/* param.urfConstrData = XX_Malloc(sizeof(t_ConstrDataParams));                  */
/* memset(fibParam.urfConstrData, 0, sizeof(t_ConstrDataParams));                */
/* ((t_ConstrDataParams *)param.urfConstrData)->flags = AVL_KEY_ULNG;            */
/* ((t_ConstrDataParams *)param.urfConstrData)->KeyOffset = MAXLAY3ADDR;         */
/* ((t_ConstrDataParams *)param.urfConstrData)->ValueLen = sizeof(void *);       */
/* param.urfConstruct = AVL_Constructor;                                         */
/* ----------------------------------------------------------------------------- */

/* ------------------------------------------------------------------ */
/* The types and routines below can be used to support static binding */
/* ------------------------------------------------------------------ */

#define MAX_SERVICES   7           /* Maximum number of the available services  */

/* Avaialable service types */

typedef enum
{
   BT_S,
   LCT_S,
   PT_S,
   HL_S,
   MT_S,
   AVL_S,
   AVLH_S
} G_Service;

/* Structure is used for service initialization.
   For those service types that are capable of use the generalized call through
   the gate routines, every object control structure must contain the filed
   of the type t_Target at the first position.
*/
typedef struct tagt_Target
{
   G_Service        service;       /* The services type.                           */
   t_GServiceAspect *target;       /* Pointer to a vector with the target routines.*/
} t_Target;


/*********************************************************************
 * @purpose            Gate routine constructs an empty object instance
 *                     through the call to the object constructor target.
 *
 *
 * @param  service     @b{(input)}  type of general service
 *                                  (object type);
 * @param  *dparams    @b{(input)}  pointer to constructor input data;
 * @param  fConstruct  @b{(input)}  object constructor;
 * @param  *ftarg      @b{(input)}  is handle of the set of object methods;
 *
 * @param  *p_objId    @b{(output)}  pointer to returned object instance handle  ;
 *
 * @returns            E_OK         - Success
 * @returns            Not E_OK     - Failure, look at std.h for detail
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_Construct                 (IN     G_Service           service,
                                   IN     t_ConstrDataParams  *dparams,
                                   IN     GS_Constructor       fConstruct,
                                   IN OUT t_GServiceAspect    *ftarg,
                                   OUT    t_Handle            *p_objId);




/*********************************************************************
 * @purpose        Gate routine performs object destruction through the
 *                 call to the object destructor target.
 *
 *
 * @param objId   @b{(input)}  object instance handle returned by
 *                             g_Construct.
 *
 * @returns       n/a
 *
 * @notes
 *
 * @end
 * ********************************************************************/
void g_Destruct                   (IN  t_Handle       objId);


/*********************************************************************
 * @purpose          Gate routine deletes an element from an object instance
 *                   through the call to the object to the object related
 *                   target.
 *
 *
 * @param objId      @b{(input)}  object instance handle returned by
 *                                g_Construct
 * @param *p_key     @b{(input)}  pointer to a key
 * @param **pp_value @b{(output)}  double pointer to a user data
 *
 * @returns      E_OK         - Success
 * @returns      Not E_OK     - Failure, look at std.h for details
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_Delete                    (IN  t_Handle       objId,
                                   IN  byte           *p_key,
                                   OUT void           **pp_value);




/*********************************************************************
 * @purpose     Gate routine datafills empty object instance or extends
 *              the non empty object.
 *
 *
 * @param objId       @b{(input)}  object instance handle returned by
 *                                 g_Construct;
 * @param entry       @b{(input)}  pointer to pre-allocated user input
 *                                 data;
 * @param EntriesN    @b{(input)}  number of items allocated for datafill;
 * @param f_Fill      @b{(input)}  user defined datafill function (in cas
 *                                 of some special user requirements for
 *                                 datafill or NULLP otherwise);
 * @param Ctrl        @b{(input)}  control parameters for f_Fill routine.
 *
 * @returns           E_OK         - Success
 * @returns           Not E_OK     - Failure, look at std.h for details
 *
 * @notes       Gate routine datafills empty object instance or extends
 *              the non empty object. with an input data through the call
 *              to the object related target.Input data is to be allocated
 *              by user (entry).
 *
 *
 * @end
 * ********************************************************************/
e_Err g_FillObject                (IN  t_Handle       objId,
                                   IN  t_Handle       entry,
                                   IN  ulng           EntriesN,
                                   IN  GS_FILLOBJFUNC f_Fill,
                                   IN  ulng           Ctrl);

/*********************************************************************
 * @purpose      Gate routine inserts an element into an object instance.
 *
 *
 * @param objId      @b{(input)}  object instance handle returned by
 *                                g_Construct;
 * @param *p_key     @b{(input)}  pointer to a key;
 * @param *p_value   @b{(input)}  pointer to a user data.
 *
 * @returns          E_OK         - Success
 * @returns          Not E_OK     - Failure, look at std.h for details
 *
 * @notes            by key *p_key with the reference to user specified data
 *                   p_value through the call to the object related target.
 *
 * @end
 * ********************************************************************/
e_Err g_Insert                    (IN  t_Handle       objId,
                                   IN  byte           *p_key,
                                   IN  void           *p_value);




/*********************************************************************
 * @purpose     Gate routine inserts an element.
 *
 *
 * @param objId       @b{(input)}  object instance handle returned by
 *                                 g_Construct;
 * @param *p_key      @b{(input)}  pointer to a key;
 * @param *p_value    @b{(input)}  pointer to a user data that has to
 *                                 inserted into an object instead of
 *                                 old data.
 *
 * @returns           E_OK         - Success
 * @returns           Not E_OK     - Failure, look at std.h for details
 *
 * @notes       Gate routine inserts an element. (pointed by p_value into
 *              a routing object by key *p_key instead of an element
 *              currently stored within this object by this key) through
 *              the call to the object related target.
 *
 * @end
 * ********************************************************************/
e_Err g_Change                    (IN  t_Handle       objId,
                                   IN  byte           *p_key,
                                   IN  void           *p_value);


/*********************************************************************
 * @purpose     Gate routine performs a lookup for the exact  match for
 *              a user data stored within an object instance.
 *
 *
 * @param objId       @b{(input)}  object instance handle returned by
 *                                 g_Construct;
 * @param flag        @b{(input)}  find flag;
 * @param *p_key      @b{(input)}  pointer to a key;
 *
 * @param **pp_value  @b{(output)}  double pointer to the found user data
 *                                  stored by *p_key.
 *
 * @returns           E_OK         - Success
 * @returns           Not E_OK     - Failure, look at std.h for details
 *
 * @notes       Gate routine performs a lookup for the exact  match for
 *              a user data stored within an object instance through
 *              the call to the object related target.
 *
 * @end
 * ********************************************************************/
e_Err g_Find                      (IN  t_Handle       objId,
                                   IN  Bool           flag,
                                   IN  byte           *p_key,
                                   OUT void           **pp_value);



/*********************************************************************
 * @purpose     Gate routine browses an object instance through the
 *              call to the object related target.
 *
 *
 * @param objId       @b{(input)}  object instance handle returned by
 *                                 g_Construct;
 * @param f_Browser   @b{(input)}  user defined browser routine;
 * @param Ctrl        @b{(input)}  control parameters for f_Browser
 *
 * @returns           E_OK         - Success
 * @returns           Not E_OK     - Failure, look at std.h for details
 *
 * @notes             This target applies user defined browse routine
 *                    f_Browser to every valid object entry.
 *
 * @end
 * ********************************************************************/
e_Err g_Browse                    (IN  t_Handle       objId,
                                   IN  GS_BROWSEFUNC  f_Browse,
                                   IN  ulng           Ctrl);




/*********************************************************************
 * @purpose     Gate routine is used to prevent an object instance
 *              from write access through the call to the object related
 *              target.
 *
 *
 * @param objId      @b{(input)}  routing object handle returned by
 *                                g_Construct.
 *
 * @returns          E_OK         - Success
 * @returns          Not E_OK     - Failure, look at std.h for details
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_WriteLock                 (IN  t_Handle       objId);





/*********************************************************************
 * @purpose     Gate routine allows write access to an object through
 *              the call to the object related target.
 *
 *
 * @param  objId    @b{(input)}  object instance handle returned by
 *                                 g_Construct.
 *
 * @returns            E_OK         - Success
 * @returns            Not E_OK     - Failure, look at std.h for details
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_WriteUnLock               (IN  t_Handle       objId);




/*********************************************************************
 * @purpose    Gate routine returns number of the object instance entries
 *             through the call to the object related target.
 *
 *
 * @param  objId         @b{(input)}  object instance handle returned by
 *                                    g_Construct;
 * @param  *p_entries    @b{(output)}  pointer to the number of user data
 *                                     items.
 *
 * @returns              E_OK         - Success
 * @returns              Not E_OK     - Failure, look at std.h for details
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_GetEntriesNmb             (IN  t_Handle       objId,
                                   OUT ulng           *p_entries);




/*********************************************************************
 * @purpose     Gate routine performs object instance cleanup through
 *              the call to the object related target.
 *
 *
 * @param objId      @b{(input)}  object instance handle returned by
 *                                g_Construct.
 *
 * @notes
 *
 * @end
 * ********************************************************************/
void g_Cleanup                    (IN  t_Handle       objId,
                                   IN  Bool           flag);





/*********************************************************************
 * @purpose     Gate routine displays the internal object instance data
 *              through the call to the object related target.
 *
 *
 * @param objId      @b{(input)}  object instance handle returned by
 *                                g_Construct.
 * @param flag      @b{(input)}  flag indicating whether entry is to be
 *                               deleted or not
 *
 * @notes
 *
 * @end
 * ********************************************************************/
void g_DisplayObj                 (IN  t_Handle       objId);





/*********************************************************************
 * @purpose     Gate routine returns the next from last accessed entry
 *              in an object instance through the call to the object
 *              related target.
 *
 *
 * @param objId         @b{(input)}  object instance handle returned by
 *                                   g_Construct;
 * @param *p_value      @b{(input)}  last accessed value.
 *
 * @param **pp_value    @b{(output)}  double pointer to put the value;
 *
 * @returns             E_OK         - Success
 * @returns             Not E_OK     - Failure, look at std.h for details
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_GetNext                   (IN  t_Handle       objId,
                                   OUT void           **pp_value,
                                   IN  void           *p_value);





/*********************************************************************
 * @purpose        Gate routine returns the first object instance entry
 *                 through the call to the object related target.
 *
 *
 * @param objId        @b{(input)}  object instance handle returned by
 *                                  g_Construct;
 * @param **pp_value   @b{(output)}  double pointer to put the value.
 *
 * @returns            E_OK         - Success
 * @returns            Not E_OK     - Failure, look at std.h for details
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_GetFirst                  (IN  t_Handle    objId,
                                   OUT void        **pp_value);




/*********************************************************************
 * @purpose           Insert new entry in sorted order .
 *
 *
 * @param objId       @b{(input)}  object Id
 * @param *p_key      @b{(input)}  pointer to key
 * @param *p_value    @b{(input)}  pointer to value
 *
 * @returns           E_OK         - Success
 * @returns           Not E_OK     - Failure, look at std.h for details
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_SortedInsert              (IN  t_Handle    objId,
                                   IN  byte        *p_key,
                                   IN  void        *p_value);




/*********************************************************************
 * @purpose        Find entry which hits specified key next after
 *                 previously found in f_Find / f_FindNext loop
 *
 *
 * @param objId         @b{(input)}  object handle
 * @param *p_key        @b{(input)}  pointer to key
 * @param *p_valueLast  @b{(input)}  pointer to value from which get next
 *                                   operation is to be started
 *
 * @param **pp_value    @b{(output)} pointer to return value or NULLP
 *
 * @returns             E_OK         - Success
 * @returns             Not E_OK     - Failure, look at std.h for details
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_FindNext                  (IN  t_Handle    objId,
                                   IN  byte        *p_key,
                                   IN  void        *p_valueLast,
                                   OUT void        **pp_value);





/*********************************************************************
 * @purpose     Browse entries of object which hit specified key, calling
 *              browse funcion for every entry.
 *
 *
 * @param objId      @b{(input)}  object handle
 * @param *p_key     @b{(input)}  pointer to key
 * @param f_Browse   @b{(input)}  user defined browse function
 * @param param      @b{(input)}  parameter to be passed to browse function
 *
 * @returns          E_OK        success
 * @returns          E_BADPARM   wrong parameters
 *
 * @notes            If browse funcion for some entry returns FALSE,
 *                   delete the entry
 *
 * @end
 * ********************************************************************/
e_Err g_FindBrowse                (IN  t_Handle      objId,
                                   IN  byte          *p_key,
                                   IN  GS_BROWSEFUNC f_Browse,
                                   IN  ulng          param);




/*********************************************************************
 * @purpose          Delete the first entry by key from object
 *
 *
 * @param objId      @b{(input)}  object handle
 * @param *p_key     @b{(input)}  pointer to key
 * @param *p_value   @b{(input)}  pointer to value to be deleted
 *
 * @returns          E_OK        success
 * @returns          E_BADPARM   wrong parameters
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_DeleteFirst               (IN  t_Handle    objId,
                                   IN  byte        *p_key,
                                   IN  void        *p_value);






/*********************************************************************
 * @purpose           Move the value to other entry according to the
 *                    new key
 *
 *
 * @param objId        @b{(input)}  object Id
 * @param *p_oldKey    @b{(input)}  key to find entry
 * @param *p_value     @b{(input)}  entry value
 * @param *p_newKey    @b{(input)}  new key to be changed and moved
 *
 * @returns           E_OK        success
 * @returns           E_BADPARM   wrong parameters
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_Move                      (IN  t_Handle    objId,
                                   IN  byte        *p_oldKey,
                                   IN  void        *p_value,
                                   IN  byte        *p_newKey);





/*********************************************************************
 * @purpose          Interrupt f_Browse
 *
 *
 * @param objId      @b{(input)}  object Id
 *
 * @returns          E_OK        success
 * @returns          E_BADPARM   wrong parameters
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err g_Interrupt                 (IN  t_Handle    objId);




/*********************************************************************
 * @purpose            Print all object entry fileds
 *
 *
 * @param objId         @b{(input)}  object Id
 * @param *p_key        @b{(input)}  pointer to a key
 * @param *p_value      @b{(input)}  pointer to an entry
 * @param f_PrintEntry  @b{(input)}  entry specific print routine
 * @param prtFlg        @b{(input)}  print flags
 *
 * @notes
 *
 * @end
 * ********************************************************************/
void  g_PrintEntry                (IN  t_Handle      objId,
                                   IN  byte          *p_key,
                                   IN  void          *p_value,
                                   IN  F_PrintStruct f_PrintEntry,
                                   IN  word          prtFlg);





/*********************************************************************
 * @purpose     Routine is to be invoked during global system initiali
 *              zation (system startup).
 *
 *
 * @returns     E_OK         - Success
 * @returns     Not E_OK     - Failure, look at std.h for details
 *
 * @notes       he purpose of this routine is allocate null target for
 *              the generalized service aspect and to initialize all the
 *              entries in a service table to null target value.
 *
 * @end
 * ********************************************************************/
e_Err InitAllServices             (void);


#endif
