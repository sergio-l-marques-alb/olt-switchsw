/********************************************************************
 *
 * (C) Copyright Broadcom Corporation 2003-2007
 *
 * *********************************************************************
 *
 * @filename     frame.ext
 *
 * @purpose      Frame management public API
 *
 * @component    Routing Utils Component
 *
 * @comments
 *
 * @create       01/09/93
 *
 * @author       Jonathan Masel
 *               Igor Bryskin
 *
 * @end
 *
 * ********************************************************************/
#ifndef _FRAME_EXT
#define _FRAME_EXT

#include "std.h"
#include "tuning.h"

#if defined(L7_FRMCYAN)
   /* Frame object is amulated via ATMOS CYANBUFFER */
   #include "cyanlib.h"
#else
   /* Native Atic frames */
   #define  L7_FRMNATIVE 1
#endif

/* Bit-flags used in frame operations */

#define FRAME_DSCRD     0x0001   /* frame was discarded during Tx      */
#define FRAME_LP        0x0001   /* loss priority                      */
#define FRAME_DE        FRAME_LP
#define FRAME_CI        0x0002   /* congestion indication              */
#define FRAME_FECN      FRAME_CI
#define FRAME_BECN      0x0004   /* congestion is in reverse direction */
#define FRAME_DE0       0x0008   /* force DE = 0                       */
#define FRAME_NOCNF     0x0040   /* this frame needs no Tx confirmation*/
#define FRAME_USER_FLAG 0x0080   /* reserved for error injection use   */

/* The following two bits are used by the funnel in order   */
/* to classify this frame as normal rate or excess rate     */
#define FRAME_RATE1  0x0010   /* frame is within rate1 (committed) */
#define FRAME_RATE2  0x0020   /* frame is within rate2 (excess)    */

#define FRAME_TXPRI  0x00c0   /* add this to connection's tx priority */
#define GET_TXPRI(f) (((f) & FRAME_TXPRI) >> 6)

#define FRAME_CR     0x0100   /* command/response bit (in UU info field) */
#define FRAME_UU     0xff00   /* user-to-user information                */
#define GET_UU(f)    (((f) & FRAME_UU) >>8 )
#define SET_UU(f,u)  (((f) & ~FRAME_UU) | ((u) << 8))

/* The following bits are used in SA5 interfacing with physical drivers  */
/* which provide AAL5 buffer transfer capability                         */
#define FRAME_MORE   0x0004   /* the buffer of the frame is not the last one       */
#define FRAME_LGT_ER 0x0008   /* frame length error during frame receiving         */
#define FRAME_CRC_ER 0x0010   /* CRC32 error during frame receiving                */
#define FRAME_HEC_ER 0x0020   /* HEC error in one of frame's cell during receiving */
#define FRAME_FIRST  0x0040   /* this buffer is the first buffer in the frame      */
#define FRAME_RAS_ER 0x0080   /* cell level reassembly timeout error               */
#define FRAME_ERR (FRAME_LGT_ER | FRAME_CRC_ER | FRAME_HEC_ER | FRAME_RAS_ER)

#define FRAME_CPI    0x00ff0000 /* CPI field passed to/from physical driver */
#define GET_CPI(f)   (((f) & FRAME_CPI)>>16)
#define SET_CPI(f,c) ((  ((ulng)((c) & 0xFF)) << 16) | ( ((ulng)(f)) & 0xFF00FFFF))


/* Offsets of F_SetInfo used for frame related things storage            */
#define F_IN_BUFFER_INFO   1 /* The "middle of buffer transmission" flag */
                             /*  used locally in SA5                     */

#define F_CALL_BACK_INFO   1 /* Call back routine address                */
                             /*  used locally in CP5                     */

#define F_CRNT_BUFFER_INFO 2 /* Pointer to current transmitted buffer    */
                             /*  used locally in SA5                     */
#define F_AAL_HANDLE_INFO  2 /* AAL connection handle                    */
                             /*  used locally in CP5                     */
#define F_FF_HANDLE_INFO   2 /* FF object handle                         */
                             /*  used locally in FF                      */

#define F_FRAME_FLAGS_INFO 3 /* The flags pertaining to frame            */
                             /*  used locally in CP5                     */
                             /*  reused in SA5 and should be preserved   */
                             /*   by frame interface drivers             */

#define F_CRC32_VAL_INFO   4 /* CRC32 value returned by PHYC32           */
                             /*  used locally in CP5                     */

#define F_TOTAL_ADD_INFO   5 /* The total number of bytes added during Tx*/
                             /*  used in CP5 and in SA5                  */
                             /*  should be preserved by buffer and frame */
                             /*  interface drivers which requires AAL5   */
                             /*  trailer to be added by CP5              */

#if L7_FRMNATIVE

/* Get the size of the FRAME structure */
#define    F_Sizeof() sizeof(t_Frame)

#endif  /* #if L7_FRMNATIVE */

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* Assign default pools for frames, buffer structures, and data buffers                        */
e_Err F_AssignDefPools(t_Handle defFramesPool,/* default mem pool to allocate frames           */
                       t_Handle defBufPool,   /* default mem pool to allocate buffer structures*/
                       t_Handle defDatPool);  /* default mem pool to allocate data buffers     */



#if !defined(FRMCHK) || defined(L7_FRMCYAN)
   /*Allocate a new frame */
   void *F_New(void *p_Buff);           /* buffer to put in frame, NULLP is none  */
   void *F_NewEx(void *p_Buff,          /* buffer to put in frame, NULLP is none  */
                 t_Handle framesPool,   /* mem pool to allocate frames            */
                 t_Handle bufPool,      /* mem pool to allocate buffer structures */
                 t_Handle datPool);     /* mem pool to allocate data buffers      */
   /* Copy frame to another frame */
   void *F_Copy(void *p_Frame);
#if L7_FRMNATIVE
   /* Create a clone of the frame */
   void *F_Clone(void *p_Frame);
#endif
   /* Delete a frame */
   void F_DeleteExt(void *p_Frame, Bool delDataBuf );
   /* Delete a frame */
   #define F_Delete(p_Frame) F_DeleteExt(p_Frame, TRUE )
   #define F_SET_OWNER(f)
#else
   void *_F_New(void *p_Buff,            /* buffer to put in frame, NULLP is none  */
                const char *file,
                word line);
   void *_F_NewEx(void *p_Buff,          /* buffer to put in frame, NULLP is none  */
                  t_Handle framesPool,   /* mem pool to allocate frames            */
                  t_Handle bufPool,      /* mem pool to allocate buffer structures */
                  t_Handle datPool,      /* mem pool to allocate data buffers      */
                  const char *file,
                  word line);
   void *_F_Copy(void *p_Frame, const char *file, word line);
   void *_F_Clone(void *p_Frame, const char *file, word line);
   void _F_DeleteExt(void *p_Frame, Bool delDataBuf, const char *file, word line);

   #define F_New(p_Buff)   _F_New(p_Buff, __FILE__, (word)__LINE__)
   #define F_NewEx(p_Buff, framesPool, bufPool, datPool) \
            _F_NewEx(p_Buff, framesPool, bufPool, datPool, __FILE__, (word)__LINE__)
   #define F_Copy(p_Frame)   _F_Copy(p_Frame,  __FILE__, (word)__LINE__)
   #define F_Clone(p_Frame)  _F_Clone(p_Frame, __FILE__, (word)__LINE__)
   #define F_DeleteExt(p_Frame,delDataBuf) _F_DeleteExt(p_Frame, delDataBuf, __FILE__, (word)__LINE__)
   #define F_Delete(p_Frame) _F_DeleteExt(p_Frame, TRUE, __FILE__, (word)__LINE__)
   /* Display allocated frames (for debugging leaks) */
   void    F_DisplayFrames(void);
   #define F_SET_OWNER(f) ( ((t_Frame *)(f))->ownerLine = (word)__LINE__,\
   ((t_Frame *)(f))->ownerFile = __FILE__)
#endif  /*  !defined(FRMCHK) || defined(L7_FRMCYAN) */

/* The following functions are supported only for native frames */
/* The following macros are implemented differently for *CYAN* and   */
/* native frames                                                */
#if L7_FRMNATIVE

   /* Reinitiate frame with releasing all it's buffers */
   e_Err F_Init(void *p_Frame);

   /*Create link to the frame */
   #define F_Link(p_F)          (((t_Frame *)(p_F))->useCount++)

   /*Get frame length */
   #define F_GetLength(p_F)     (((t_Frame *)(p_F))->frameLen)

   /*Get *next* pointer offset in t_Frame object */
   #define F_GetNextFieldOffset()  offsetof( t_Frame, nextFrame )

   /*Set user info */
   #define F_SetInfo(p_F, info, number)\
      ((t_Frame *)(p_F))->frameAttr[number - 1] = (t_HandleAsLong)(info)

   /*Get user info */
   #define F_GetInfo(p_F, number) (((t_Frame *)p_F)->frameAttr[number - 1])

   /* Convert frame to array */
   #define F_Frame2Array(p_F)\
      (((t_Frame *)p_F)->firstBuf       &&           /* there is first buffer */\
       !((t_Frame *)p_F)->firstBuf->next &&           /* first is the only buffer */\
         B_BIG_TAIL(((t_Frame *)p_F)->firstBuf) ?     /* buffer is of BIG TAIL type */\
         B_GetData(((t_Frame *)p_F)->firstBuf): NULLP)

   #define F_GetFirstBuf(p_F) ((t_Frame *)p_F)->firstBuf

   /* Get pointer to the last buffer */
   void   *F_GetLastBuf( void *p_Frame );

   /*Get a pointer to the first buffer and remove it from the frame*/
   void   *F_RemoveFirstBuffer( void *p_Frame);

   /*Put the buffer to the end of the frame*/
   void    F_PutBuffer( void *p_Frame, void *p_Buff );

   /*Put the buffer to the start of the frame*/
   void    F_PutToStartBuffer( void *p_Frame, void *p_Buff );

   /*Assign a callback for frame release notification */
   #define  F_DeleteInd( p_F, f_Delete)\
      ((t_Frame *)(p_F))->f_ReleaseInd = f_Delete;\
      ((t_Frame *)(p_F))->relParam = p_F

   /* Add frame release notification parameter */
   #define F_AddDelIndParam(p_F, param) ((t_Frame *)(p_F))->relParam = param

   /* Return the number of segments in the frame */
   /* Each Big-Tail buffer with length > 0 is of one segment. */
   /* Each non Big-Tail buffer with length > 0 is of two segments */
   /* p_nBuffs gives number of buffers with length > 0 */
   word    F_HowManySegs( void *p_F, word *p_nBuffs);

   /* Pack frame starts from buffer p_Buff */
   /* If p_Buff=NULL, pack the whole frame */
   /* In the packed frame buffers are aligned to zero offset */
   /* and all buffers but may be the last are fully filled */
   e_Err   F_Pack( void *p_F, void *p_Buff );

#else
   /* Reinitiate frame with releasing all it's buffers */
   #define F_Init(p_F)  (((CYANBUFFER *)(p_F))->length=0)

   /*Get *next* pointer offset in CYANBUFFER object */
   #define F_GetNextFieldOffset()  offsetof( CYANBUFFER, next )

   /*Get frame length */
   #define F_GetLength(p_F)   ((CYANBUFFER *)(p_F))->length

   /*Set user info. Only 1 information element is supported ! */
   #define F_SetInfo(p_F, info, number)\
      { \
      if ( number == 1 ) ((CYANBUFFER *)(p_F))->parameter1 = (ulng)(info); \
      else if ( number == 2 ) ((CYANBUFFER *)(p_F))->parameter2 = (ulng)(info); \
      else ASSERT( FALSE ); }

   /*Get user info. Only 1 information element is supported ! */
   #define F_GetInfo(p_F, number) ((number==1)?((CYANBUFFER *)p_F)->parameter1 : \
                                  ((number==2)?((CYANBUFFER *)p_F)->parameter2 : 0 ) )

   /* The only buffer is frame itself */
   #define F_GetFirstBuf(p_F)    (p_F)

   /* The only buffer is frame itself */
   #define F_GetLastBuf(p_F)     (p_F)

   /* Convert frame to array */
   #define F_Frame2Array(p_F)    (((CYANBUFFER *)(p_F))->data)

   /*************************************************/
   /* Buffer object is not included in the load.    */
   /* Add some buffer flavor here for compatibility */
   /*************************************************/

   /* Buffer length */
   #define B_GetLength(pBuf)     ((CYANBUFFER *)(pBuf))->length

   /* Peek byte from buffer */
   #define B_Peek(p,buf,offset)  F_Peek(p,buf,offset)

   /* Read data from buffer */
   #define B_Read(p,buf,offset,length) F_Read(p,buf,offset,length)

#endif /* #if L7_FRMNATIVE */

/* Get a pointer to the buffer */
void   *F_GetBuffer( void *p_Frame, word BuffNum, Bool *pLast );

/* Return the number of buffers in the frame */
word    F_HowManyBuffs( void *p_F);

/*Add array to the start of the frame */
word    F_AddToStart( void *p_Frame, byte *pData, word Length );

/* Put data to frame head */
#define F_Prepend(pFrame, buffer, len)   F_AddToStart((*pFrame), buffer, len)

/*Add 1 byte to the start of the frame */
word    F_AddByteToStart( void *p_Frame, byte data);

/*Add array to the end of the frame */
word    F_AddToEnd( void *p_Frame, byte *pData, word Length );

/*Add 1 byte to the end of the frame */
word    F_AddByteToEnd( void *p_Frame, byte data);

/*Remove data from the start of the frame */
word    F_CutFromStart( void *p_Frame, word Length );

/*Remove data from the end of the frame */
word    F_CutFromEnd( void *p_Frame, word Length );

/* Remove data beginning from the offset */
word    F_CutSlice( void *p_F, word offset, word Length );

/* Read to array beginning from the offset */
word    F_Read( void *p, void *p_F, word offset, word Length );

/* Read array from start and remove from the frame */
word    F_ReadStartRemove( void *p, void *p_F, word Length );

/* Read array from end and remove from the frame */
word    F_ReadEndRemove( void *p, void *p_F, word Length );

/* Overwrite data in frame beginning from the offset from array  */
word    F_Write( void *p, void *p_F, word offset, word Length );

/* Read one byte from the frame */
word    F_Peek( byte *p, void *p_F, word Offset );

/* Replace one byte in the frame */
word    F_Replace( byte data, void *p_F, word Offset );

/* Prepend frame 1 to frame 2 and discard frame 1 */
void   *F_PrependAndDisc1(void *p_F1, void *p_F2);

/* Concatenate frame 2 to frame 1 */
void   *F_Concatenate(void *p_F1, void *p_F2);

/* Concatenate frame 2 to frame 1 and discard frame 2 */
void   *F_ConcAndDisc(void *p_F1, void *p_F2);

/* Split frame from start */
void   *F_SplitFromStart(void *p_Frame, word length);

/* return number of bytes in frame */
/* Attention: the below function is fully equivalent to      */
/* F_GetLength but it is intentionally defined as a function */
/* and not as a macro for using as callback routine          */
word    F_HowManyBytes(void *p_F);

/* Convert frame to array extended. Returns also max array length */
byte   *F_Frame2ArrayExt( void *p_Frame, word *p_maxArrayLength );

/* Set frame length. This function is useful when frame data   */
/* was modified outside frame interface. E.g., flat buffer     */
/* pointer can by obtained by using F_Frame2ArrayExt.          */
/* The function can be used only for single-buffer flat frames */
e_Err   F_SetLength( void *pFrame, word length );

#if FRMOBJ_FREELIST && L7_FRMNATIVE
/* Initialization of free frame list */
void F_FreeListInit( void );

/* Release all frames from frame free list */
void F_FreeListFlush( void );
#endif

#ifdef __cplusplus
}
#endif


#endif  /*_FRAME_EXT */
